var m9 = Object.defineProperty;
var p9 = (s, e, t) => e in s ? m9(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var fi = (s, e, t) => p9(s, typeof e != "symbol" ? e + "" : e, t);
function oo(s, e = 0) {
  return s[s.length - (1 + e)];
}
function A9(s) {
  if (s.length === 0)
    throw new Error("Invalid tail call");
  return [s.slice(0, s.length - 1), s[s.length - 1]];
}
function pi(s, e, t = (i, n) => i === n) {
  if (s === e)
    return !0;
  if (!s || !e || s.length !== e.length)
    return !1;
  for (let i = 0, n = s.length; i < n; i++)
    if (!t(s[i], e[i]))
      return !1;
  return !0;
}
function _9(s, e) {
  const t = s.length - 1;
  e < t && (s[e] = s[t]), s.pop();
}
function wM(s, e, t) {
  return b9(s.length, (i) => t(s[i], e));
}
function b9(s, e) {
  let t = 0, i = s - 1;
  for (; t <= i; ) {
    const n = (t + i) / 2 | 0, o = e(n);
    if (o < 0)
      t = n + 1;
    else if (o > 0)
      i = n - 1;
    else
      return n;
  }
  return -(t + 1);
}
function vx(s, e, t) {
  if (s = s | 0, s >= e.length)
    throw new TypeError("invalid index");
  const i = e[Math.floor(e.length * Math.random())], n = [], o = [], r = [];
  for (const a of e) {
    const l = t(a, i);
    l < 0 ? n.push(a) : l > 0 ? o.push(a) : r.push(a);
  }
  return s < n.length ? vx(s, n, t) : s < n.length + r.length ? r[0] : vx(s - (n.length + r.length), o, t);
}
function RB(s, e) {
  const t = [];
  let i;
  for (const n of s.slice(0).sort(e))
    !i || e(i[0], n) !== 0 ? (i = [n], t.push(i)) : i.push(n);
  return t;
}
function* CM(s, e) {
  let t, i;
  for (const n of s)
    i !== void 0 && e(i, n) ? t.push(n) : (t && (yield t), t = [n]), i = n;
  t && (yield t);
}
function O4(s, e) {
  for (let t = 0; t <= s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], t === s.length ? void 0 : s[t]);
}
function w9(s, e) {
  for (let t = 0; t < s.length; t++)
    e(t === 0 ? void 0 : s[t - 1], s[t], t + 1 === s.length ? void 0 : s[t + 1]);
}
function mm(s) {
  return s.filter((e) => !!e);
}
function FB(s) {
  let e = 0;
  for (let t = 0; t < s.length; t++)
    s[t] && (s[e] = s[t], e += 1);
  s.length = e;
}
function P4(s) {
  return !Array.isArray(s) || s.length === 0;
}
function Ys(s) {
  return Array.isArray(s) && s.length > 0;
}
function du(s, e = (t) => t) {
  const t = /* @__PURE__ */ new Set();
  return s.filter((i) => {
    const n = e(i);
    return t.has(n) ? !1 : (t.add(n), !0);
  });
}
function vM(s, e) {
  return s.length > 0 ? s[0] : e;
}
function Yn(s, e) {
  let t = typeof e == "number" ? s : 0;
  typeof e == "number" ? t = s : (t = 0, e = s);
  const i = [];
  if (t <= e)
    for (let n = t; n < e; n++)
      i.push(n);
  else
    for (let n = t; n > e; n--)
      i.push(n);
  return i;
}
function f0(s, e, t) {
  const i = s.slice(0, e), n = s.slice(e);
  return i.concat(t, n);
}
function VS(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.unshift(e));
}
function sb(s, e) {
  const t = s.indexOf(e);
  t > -1 && (s.splice(t, 1), s.push(e));
}
function Sx(s, e) {
  for (const t of e)
    s.push(t);
}
function H4(s) {
  return Array.isArray(s) ? s : [s];
}
function C9(s, e, t) {
  const i = W4(s, e), n = s.length, o = t.length;
  s.length = n + o;
  for (let r = n - 1; r >= i; r--)
    s[r + o] = s[r];
  for (let r = 0; r < o; r++)
    s[r + i] = t[r];
}
function OB(s, e, t, i) {
  const n = W4(s, e);
  let o = s.splice(n, t);
  return o === void 0 && (o = []), C9(s, n, i), o;
}
function W4(s, e) {
  return e < 0 ? Math.max(e + s.length, 0) : Math.min(e, s.length);
}
var CA;
(function(s) {
  function e(o) {
    return o < 0;
  }
  s.isLessThan = e;
  function t(o) {
    return o <= 0;
  }
  s.isLessThanOrEqual = t;
  function i(o) {
    return o > 0;
  }
  s.isGreaterThan = i;
  function n(o) {
    return o === 0;
  }
  s.isNeitherLessOrGreaterThan = n, s.greaterThan = 1, s.lessThan = -1, s.neitherLessOrGreaterThan = 0;
})(CA || (CA = {}));
function _o(s, e) {
  return (t, i) => e(s(t), s(i));
}
function v9(...s) {
  return (e, t) => {
    for (const i of s) {
      const n = i(e, t);
      if (!CA.isNeitherLessOrGreaterThan(n))
        return n;
    }
    return CA.neitherLessOrGreaterThan;
  };
}
const Ml = (s, e) => s - e, S9 = (s, e) => Ml(s ? 1 : 0, e ? 1 : 0);
function y9(s) {
  return (e, t) => -s(e, t);
}
class Pl {
  /**
   * Constructs a queue that is backed by the given array. Runtime is O(1).
  */
  constructor(e) {
    this.items = e, this.firstIdx = 0, this.lastIdx = this.items.length - 1;
  }
  get length() {
    return this.lastIdx - this.firstIdx + 1;
  }
  /**
   * Consumes elements from the beginning of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).
  */
  takeWhile(e) {
    let t = this.firstIdx;
    for (; t < this.items.length && e(this.items[t]); )
      t++;
    const i = t === this.firstIdx ? null : this.items.slice(this.firstIdx, t);
    return this.firstIdx = t, i;
  }
  /**
   * Consumes elements from the end of the queue as long as the predicate returns true.
   * If no elements were consumed, `null` is returned.
   * The result has the same order as the underlying array!
  */
  takeFromEndWhile(e) {
    let t = this.lastIdx;
    for (; t >= 0 && e(this.items[t]); )
      t--;
    const i = t === this.lastIdx ? null : this.items.slice(t + 1, this.lastIdx + 1);
    return this.lastIdx = t, i;
  }
  peek() {
    if (this.length !== 0)
      return this.items[this.firstIdx];
  }
  dequeue() {
    const e = this.items[this.firstIdx];
    return this.firstIdx++, e;
  }
  takeCount(e) {
    const t = this.items.slice(this.firstIdx, this.firstIdx + e);
    return this.firstIdx += e, t;
  }
}
const qg = class qg {
  constructor(e) {
    this.iterate = e;
  }
  toArray() {
    const e = [];
    return this.iterate((t) => (e.push(t), !0)), e;
  }
  filter(e) {
    return new qg((t) => this.iterate((i) => e(i) ? t(i) : !0));
  }
  map(e) {
    return new qg((t) => this.iterate((i) => t(e(i))));
  }
  findLast(e) {
    let t;
    return this.iterate((i) => (e(i) && (t = i), !0)), t;
  }
  findLastMaxBy(e) {
    let t, i = !0;
    return this.iterate((n) => ((i || CA.isGreaterThan(e(n, t))) && (i = !1, t = n), !0)), t;
  }
};
qg.empty = new qg((e) => {
});
let Eh = qg;
function _s(s) {
  return typeof s == "string";
}
function Ti(s) {
  return typeof s == "object" && s !== null && !Array.isArray(s) && !(s instanceof RegExp) && !(s instanceof Date);
}
function x9(s) {
  const e = Object.getPrototypeOf(Uint8Array);
  return typeof s == "object" && s instanceof e;
}
function id(s) {
  return typeof s == "number" && !isNaN(s);
}
function PB(s) {
  return !!s && typeof s[Symbol.iterator] == "function";
}
function V4(s) {
  return s === !0 || s === !1;
}
function Mn(s) {
  return typeof s > "u";
}
function Pf(s) {
  return !Ws(s);
}
function Ws(s) {
  return Mn(s) || s === null;
}
function jt(s, e) {
  if (!s)
    throw new Error("Unexpected type");
}
function xc(s) {
  if (Ws(s))
    throw new Error("Assertion Failed: argument is undefined or null");
  return s;
}
function Gw(s) {
  return typeof s == "function";
}
function E9(s, e) {
  const t = Math.min(s.length, e.length);
  for (let i = 0; i < t; i++)
    L9(s[i], e[i]);
}
function L9(s, e) {
  if (_s(e)) {
    if (typeof s !== e)
      throw new Error(`argument does not match constraint: typeof ${e}`);
  } else if (Gw(e)) {
    try {
      if (s instanceof e)
        return;
    } catch {
    }
    if (!Ws(s) && s.constructor === e || e.length === 1 && e.call(void 0, s) === !0)
      return;
    throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
  }
}
function ll(s) {
  if (!s || typeof s != "object" || s instanceof RegExp)
    return s;
  const e = Array.isArray(s) ? [] : {};
  return Object.entries(s).forEach(([t, i]) => {
    e[t] = i && typeof i == "object" ? ll(i) : i;
  }), e;
}
function k9(s) {
  if (!s || typeof s != "object")
    return s;
  const e = [s];
  for (; e.length > 0; ) {
    const t = e.shift();
    Object.freeze(t);
    for (const i in t)
      if (z4.call(t, i)) {
        const n = t[i];
        typeof n == "object" && !Object.isFrozen(n) && !x9(n) && e.push(n);
      }
  }
  return s;
}
const z4 = Object.prototype.hasOwnProperty;
function U4(s, e) {
  return yx(s, e, /* @__PURE__ */ new Set());
}
function yx(s, e, t) {
  if (Ws(s))
    return s;
  const i = e(s);
  if (typeof i < "u")
    return i;
  if (Array.isArray(s)) {
    const n = [];
    for (const o of s)
      n.push(yx(o, e, t));
    return n;
  }
  if (Ti(s)) {
    if (t.has(s))
      throw new Error("Cannot clone recursive data-structure");
    t.add(s);
    const n = {};
    for (const o in s)
      z4.call(s, o) && (n[o] = yx(s[o], e, t));
    return t.delete(s), n;
  }
  return s;
}
function m0(s, e, t = !0) {
  return Ti(s) ? (Ti(e) && Object.keys(e).forEach((i) => {
    i in s ? t && (Ti(s[i]) && Ti(e[i]) ? m0(s[i], e[i], t) : s[i] = e[i]) : s[i] = e[i];
  }), s) : e;
}
function bs(s, e) {
  if (s === e)
    return !0;
  if (s == null || e === null || e === void 0 || typeof s != typeof e || typeof s != "object" || Array.isArray(s) !== Array.isArray(e))
    return !1;
  let t, i;
  if (Array.isArray(s)) {
    if (s.length !== e.length)
      return !1;
    for (t = 0; t < s.length; t++)
      if (!bs(s[t], e[t]))
        return !1;
  } else {
    const n = [];
    for (i in s)
      n.push(i);
    n.sort();
    const o = [];
    for (i in e)
      o.push(i);
    if (o.sort(), !bs(n, o))
      return !1;
    for (t = 0; t < n.length; t++)
      if (!bs(s[n[t]], e[n[t]]))
        return !1;
  }
  return !0;
}
function D9(s) {
  let e = [];
  for (; Object.prototype !== s; )
    e = e.concat(Object.getOwnPropertyNames(s)), s = Object.getPrototypeOf(s);
  return e;
}
function xx(s) {
  const e = [];
  for (const t of D9(s))
    typeof s[t] == "function" && e.push(t);
  return e;
}
function I9(s, e) {
  const t = (n) => function() {
    const o = Array.prototype.slice.call(arguments, 0);
    return e(n, o);
  }, i = {};
  for (const n of s)
    i[n] = t(n);
  return i;
}
function Q4() {
  return globalThis._VSCODE_NLS_MESSAGES;
}
function SM() {
  return globalThis._VSCODE_NLS_LANGUAGE;
}
const M9 = SM() === "pseudo" || typeof document < "u" && document.location && document.location.hash.indexOf("pseudo=true") >= 0;
function jw(s, e) {
  let t;
  return e.length === 0 ? t = s : t = s.replace(/\{(\d+)\}/g, (i, n) => {
    const o = n[0], r = e[o];
    let a = i;
    return typeof r == "string" ? a = r : (typeof r == "number" || typeof r == "boolean" || r === void 0 || r === null) && (a = String(r)), a;
  }), M9 && (t = "［" + t.replace(/[aouei]/g, "$&$&") + "］"), t;
}
function f(s, e, ...t) {
  return jw(typeof s == "number" ? G4(s, e) : e, t);
}
function G4(s, e) {
  const t = Q4()?.[s];
  if (typeof t != "string") {
    if (typeof e == "string")
      return e;
    throw new Error(`!!! NLS MISSING: ${s} !!!`);
  }
  return t;
}
function ni(s, e, ...t) {
  let i;
  typeof s == "number" ? i = G4(s, e) : i = e;
  const n = jw(i, t);
  return {
    value: n,
    original: e === i ? n : jw(e, t)
  };
}
const kg = "en";
let Yw = !1, Kw = !1, uw = !1, j4 = !1, yM = !1, xM = !1, Y4 = !1, ob, zS = kg, HB = kg, N9, qa;
const Nl = globalThis;
let lo;
typeof Nl.vscode < "u" && typeof Nl.vscode.process < "u" ? lo = Nl.vscode.process : typeof process < "u" && typeof process?.versions?.node == "string" && (lo = process);
const T9 = typeof lo?.versions?.electron == "string", B9 = T9 && lo?.type === "renderer";
if (typeof lo == "object") {
  Yw = lo.platform === "win32", Kw = lo.platform === "darwin", uw = lo.platform === "linux", uw && lo.env.SNAP && lo.env.SNAP_REVISION, lo.env.CI || lo.env.BUILD_ARTIFACTSTAGINGDIRECTORY, ob = kg, zS = kg;
  const s = lo.env.VSCODE_NLS_CONFIG;
  if (s)
    try {
      const e = JSON.parse(s);
      ob = e.userLocale, HB = e.osLocale, zS = e.resolvedLanguage || kg, N9 = e.languagePack?.translationsConfigFile;
    } catch {
    }
  j4 = !0;
} else typeof navigator == "object" && !B9 ? (qa = navigator.userAgent, Yw = qa.indexOf("Windows") >= 0, Kw = qa.indexOf("Macintosh") >= 0, xM = (qa.indexOf("Macintosh") >= 0 || qa.indexOf("iPad") >= 0 || qa.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0, uw = qa.indexOf("Linux") >= 0, Y4 = qa?.indexOf("Mobi") >= 0, yM = !0, zS = SM() || kg, ob = navigator.language.toLowerCase(), HB = ob) : console.error("Unable to resolve platform.");
const yn = Yw, ze = Kw, Fn = uw, vA = j4, pm = yM, R9 = yM && typeof Nl.importScripts == "function", F9 = R9 ? Nl.origin : void 0, Ea = xM, K4 = Y4, La = qa, O9 = typeof Nl.postMessage == "function" && !Nl.importScripts, J4 = (() => {
  if (O9) {
    const s = [];
    Nl.addEventListener("message", (t) => {
      if (t.data && t.data.vscodeScheduleAsyncWork)
        for (let i = 0, n = s.length; i < n; i++) {
          const o = s[i];
          if (o.id === t.data.vscodeScheduleAsyncWork) {
            s.splice(i, 1), o.callback();
            return;
          }
        }
    });
    let e = 0;
    return (t) => {
      const i = ++e;
      s.push({
        id: i,
        callback: t
      }), Nl.postMessage({ vscodeScheduleAsyncWork: i }, "*");
    };
  }
  return (s) => setTimeout(s);
})(), Us = Kw || xM ? 2 : Yw ? 1 : 3;
let WB = !0, VB = !1;
function P9() {
  if (!VB) {
    VB = !0;
    const s = new Uint8Array(2);
    s[0] = 1, s[1] = 2, WB = new Uint16Array(s.buffer)[0] === 513;
  }
  return WB;
}
const q4 = !!(La && La.indexOf("Chrome") >= 0), H9 = !!(La && La.indexOf("Firefox") >= 0), W9 = !!(!q4 && La && La.indexOf("Safari") >= 0), V9 = !!(La && La.indexOf("Edg/") >= 0), z9 = !!(La && La.indexOf("Android") >= 0), an = {
  tabSize: 4,
  indentSize: 4,
  insertSpaces: !0,
  detectIndentation: !0,
  trimAutoWhitespace: !0,
  largeFileOptimizations: !0,
  bracketPairColorizationOptions: {
    enabled: !0,
    independentColorPoolPerBracketType: !1
  }
};
var nt;
(function(s) {
  function e(w) {
    return w && typeof w == "object" && typeof w[Symbol.iterator] == "function";
  }
  s.is = e;
  const t = Object.freeze([]);
  function i() {
    return t;
  }
  s.empty = i;
  function* n(w) {
    yield w;
  }
  s.single = n;
  function o(w) {
    return e(w) ? w : n(w);
  }
  s.wrap = o;
  function r(w) {
    return w || t;
  }
  s.from = r;
  function* a(w) {
    for (let S = w.length - 1; S >= 0; S--)
      yield w[S];
  }
  s.reverse = a;
  function l(w) {
    return !w || w[Symbol.iterator]().next().done === !0;
  }
  s.isEmpty = l;
  function c(w) {
    return w[Symbol.iterator]().next().value;
  }
  s.first = c;
  function d(w, S) {
    let x = 0;
    for (const y of w)
      if (S(y, x++))
        return !0;
    return !1;
  }
  s.some = d;
  function h(w, S) {
    for (const x of w)
      if (S(x))
        return x;
  }
  s.find = h;
  function* u(w, S) {
    for (const x of w)
      S(x) && (yield x);
  }
  s.filter = u;
  function* g(w, S) {
    let x = 0;
    for (const y of w)
      yield S(y, x++);
  }
  s.map = g;
  function* m(w, S) {
    let x = 0;
    for (const y of w)
      yield* S(y, x++);
  }
  s.flatMap = m;
  function* p(...w) {
    for (const S of w)
      yield* S;
  }
  s.concat = p;
  function A(w, S, x) {
    let y = x;
    for (const D of w)
      y = S(y, D);
    return y;
  }
  s.reduce = A;
  function* _(w, S, x = w.length) {
    for (S < 0 && (S += w.length), x < 0 ? x += w.length : x > w.length && (x = w.length); S < x; S++)
      yield w[S];
  }
  s.slice = _;
  function b(w, S = Number.POSITIVE_INFINITY) {
    const x = [];
    if (S === 0)
      return [x, w];
    const y = w[Symbol.iterator]();
    for (let D = 0; D < S; D++) {
      const I = y.next();
      if (I.done)
        return [x, s.empty()];
      x.push(I.value);
    }
    return [x, { [Symbol.iterator]() {
      return y;
    } }];
  }
  s.consume = b;
  async function C(w) {
    const S = [];
    for await (const x of w)
      S.push(x);
    return Promise.resolve(S);
  }
  s.asyncToArray = C;
})(nt || (nt = {}));
var xl;
let Ci = (xl = class {
  constructor(e) {
    this.element = e, this.next = xl.Undefined, this.prev = xl.Undefined;
  }
}, xl.Undefined = new xl(void 0), xl);
class Nn {
  constructor() {
    this._first = Ci.Undefined, this._last = Ci.Undefined, this._size = 0;
  }
  get size() {
    return this._size;
  }
  isEmpty() {
    return this._first === Ci.Undefined;
  }
  clear() {
    let e = this._first;
    for (; e !== Ci.Undefined; ) {
      const t = e.next;
      e.prev = Ci.Undefined, e.next = Ci.Undefined, e = t;
    }
    this._first = Ci.Undefined, this._last = Ci.Undefined, this._size = 0;
  }
  unshift(e) {
    return this._insert(e, !1);
  }
  push(e) {
    return this._insert(e, !0);
  }
  _insert(e, t) {
    const i = new Ci(e);
    if (this._first === Ci.Undefined)
      this._first = i, this._last = i;
    else if (t) {
      const o = this._last;
      this._last = i, i.prev = o, o.next = i;
    } else {
      const o = this._first;
      this._first = i, i.next = o, o.prev = i;
    }
    this._size += 1;
    let n = !1;
    return () => {
      n || (n = !0, this._remove(i));
    };
  }
  shift() {
    if (this._first !== Ci.Undefined) {
      const e = this._first.element;
      return this._remove(this._first), e;
    }
  }
  pop() {
    if (this._last !== Ci.Undefined) {
      const e = this._last.element;
      return this._remove(this._last), e;
    }
  }
  _remove(e) {
    if (e.prev !== Ci.Undefined && e.next !== Ci.Undefined) {
      const t = e.prev;
      t.next = e.next, e.next.prev = t;
    } else e.prev === Ci.Undefined && e.next === Ci.Undefined ? (this._first = Ci.Undefined, this._last = Ci.Undefined) : e.next === Ci.Undefined ? (this._last = this._last.prev, this._last.next = Ci.Undefined) : e.prev === Ci.Undefined && (this._first = this._first.next, this._first.prev = Ci.Undefined);
    this._size -= 1;
  }
  *[Symbol.iterator]() {
    let e = this._first;
    for (; e !== Ci.Undefined; )
      yield e.element, e = e.next;
  }
}
const $4 = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
function U9(s = "") {
  let e = "(-?\\d*\\.\\d\\w*)|([^";
  for (const t of $4)
    s.indexOf(t) >= 0 || (e += "\\" + t);
  return e += "\\s]+)", new RegExp(e, "g");
}
const EM = U9();
function LM(s) {
  let e = EM;
  if (s && s instanceof RegExp)
    if (s.global)
      e = s;
    else {
      let t = "g";
      s.ignoreCase && (t += "i"), s.multiline && (t += "m"), s.unicode && (t += "u"), e = new RegExp(s.source, t);
    }
  return e.lastIndex = 0, e;
}
const X4 = new Nn();
X4.unshift({
  maxLen: 1e3,
  windowSize: 15,
  timeBudget: 150
});
function SA(s, e, t, i, n) {
  if (e = LM(e), n || (n = nt.first(X4)), t.length > n.maxLen) {
    let c = s - n.maxLen / 2;
    return c < 0 ? c = 0 : i += c, t = t.substring(c, s + n.maxLen / 2), SA(s, e, t, i, n);
  }
  const o = Date.now(), r = s - 1 - i;
  let a = -1, l = null;
  for (let c = 1; !(Date.now() - o >= n.timeBudget); c++) {
    const d = r - n.windowSize * c;
    e.lastIndex = Math.max(0, d);
    const h = Q9(e, t, r, a);
    if (!h && l || (l = h, d <= 0))
      break;
    a = d;
  }
  if (l) {
    const c = {
      word: l[0],
      startColumn: i + 1 + l.index,
      endColumn: i + 1 + l.index + l[0].length
    };
    return e.lastIndex = 0, c;
  }
  return null;
}
function Q9(s, e, t, i) {
  let n;
  for (; n = s.exec(e); ) {
    const o = n.index || 0;
    if (o <= t && s.lastIndex >= t)
      return n;
    if (i > 0 && o > i)
      return null;
  }
  return null;
}
const qr = 8;
class Z4 {
  /**
   * @internal
   */
  constructor(e) {
    this._values = e;
  }
  hasChanged(e) {
    return this._values[e];
  }
}
class eH {
  constructor() {
    this.stableMinimapLayoutInput = null, this.stableFitMaxMinimapScale = 0, this.stableFitRemainingWidth = 0;
  }
}
class Bt {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return p0(e, t);
  }
  compute(e, t, i) {
    return i;
  }
}
class Dp {
  constructor(e, t) {
    this.newValue = e, this.didChange = t;
  }
}
function p0(s, e) {
  if (typeof s != "object" || typeof e != "object" || !s || !e)
    return new Dp(e, s !== e);
  if (Array.isArray(s) || Array.isArray(e)) {
    const i = Array.isArray(s) && Array.isArray(e) && pi(s, e);
    return new Dp(e, !i);
  }
  let t = !1;
  for (const i in e)
    if (e.hasOwnProperty(i)) {
      const n = p0(s[i], e[i]);
      n.didChange && (s[i] = n.newValue, t = !0);
    }
  return new Dp(s, t);
}
class L_ {
  constructor(e) {
    this.schema = void 0, this.id = e, this.name = "_never_", this.defaultValue = void 0;
  }
  applyUpdate(e, t) {
    return p0(e, t);
  }
  validate(e) {
    return this.defaultValue;
  }
}
class Am {
  constructor(e, t, i, n) {
    this.id = e, this.name = t, this.defaultValue = i, this.schema = n;
  }
  applyUpdate(e, t) {
    return p0(e, t);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : e;
  }
  compute(e, t, i) {
    return i;
  }
}
function ue(s, e) {
  return typeof s > "u" ? e : s === "false" ? !1 : !!s;
}
class Ze extends Am {
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "boolean", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return ue(e, this.defaultValue);
  }
}
function Vd(s, e, t, i) {
  if (typeof s > "u")
    return e;
  let n = parseInt(s, 10);
  return isNaN(n) ? e : (n = Math.max(t, n), n = Math.min(i, n), n | 0);
}
class _t extends Am {
  static clampedInt(e, t, i, n) {
    return Vd(e, t, i, n);
  }
  constructor(e, t, i, n, o, r = void 0) {
    typeof r < "u" && (r.type = "integer", r.default = i, r.minimum = n, r.maximum = o), super(e, t, i, r), this.minimum = n, this.maximum = o;
  }
  validate(e) {
    return _t.clampedInt(e, this.defaultValue, this.minimum, this.maximum);
  }
}
function G9(s, e, t, i) {
  if (typeof s > "u")
    return e;
  const n = Qs.float(s, e);
  return Qs.clamp(n, t, i);
}
class Qs extends Am {
  static clamp(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static float(e, t) {
    if (typeof e == "number")
      return e;
    if (typeof e > "u")
      return t;
    const i = parseFloat(e);
    return isNaN(i) ? t : i;
  }
  constructor(e, t, i, n, o) {
    typeof o < "u" && (o.type = "number", o.default = i), super(e, t, i, o), this.validationFn = n;
  }
  validate(e) {
    return this.validationFn(Qs.float(e, this.defaultValue));
  }
}
class wn extends Am {
  static string(e, t) {
    return typeof e != "string" ? t : e;
  }
  constructor(e, t, i, n = void 0) {
    typeof n < "u" && (n.type = "string", n.default = i), super(e, t, i, n);
  }
  validate(e) {
    return wn.string(e, this.defaultValue);
  }
}
function Gt(s, e, t, i) {
  return typeof s != "string" ? e : i && s in i ? i[s] : t.indexOf(s) === -1 ? e : s;
}
class Qt extends Am {
  constructor(e, t, i, n, o = void 0) {
    typeof o < "u" && (o.type = "string", o.enum = n, o.default = i), super(e, t, i, o), this._allowedValues = n;
  }
  validate(e) {
    return Gt(e, this.defaultValue, this._allowedValues);
  }
}
class rb extends Bt {
  constructor(e, t, i, n, o, r, a = void 0) {
    typeof a < "u" && (a.type = "string", a.enum = o, a.default = n), super(e, t, i, a), this._allowedValues = o, this._convert = r;
  }
  validate(e) {
    return typeof e != "string" ? this.defaultValue : this._allowedValues.indexOf(e) === -1 ? this.defaultValue : this._convert(e);
  }
}
function j9(s) {
  switch (s) {
    case "none":
      return 0;
    case "keep":
      return 1;
    case "brackets":
      return 2;
    case "advanced":
      return 3;
    case "full":
      return 4;
  }
}
class Y9 extends Bt {
  constructor() {
    super(2, "accessibilitySupport", 0, {
      type: "string",
      enum: ["auto", "on", "off"],
      enumDescriptions: [
        f("accessibilitySupport.auto", "Use platform APIs to detect when a Screen Reader is attached."),
        f("accessibilitySupport.on", "Optimize for usage with a Screen Reader."),
        f("accessibilitySupport.off", "Assume a screen reader is not attached.")
      ],
      default: "auto",
      tags: ["accessibility"],
      description: f("accessibilitySupport", "Controls if the UI should run in a mode where it is optimized for screen readers.")
    });
  }
  validate(e) {
    switch (e) {
      case "auto":
        return 0;
      case "off":
        return 1;
      case "on":
        return 2;
    }
    return this.defaultValue;
  }
  compute(e, t, i) {
    return i === 0 ? e.accessibilitySupport : i;
  }
}
class K9 extends Bt {
  constructor() {
    const e = {
      insertSpace: !0,
      ignoreEmptyLines: !0
    };
    super(23, "comments", e, {
      "editor.comments.insertSpace": {
        type: "boolean",
        default: e.insertSpace,
        description: f("comments.insertSpace", "Controls whether a space character is inserted when commenting.")
      },
      "editor.comments.ignoreEmptyLines": {
        type: "boolean",
        default: e.ignoreEmptyLines,
        description: f("comments.ignoreEmptyLines", "Controls if empty lines should be ignored with toggle, add or remove actions for line comments.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertSpace: ue(t.insertSpace, this.defaultValue.insertSpace),
      ignoreEmptyLines: ue(t.ignoreEmptyLines, this.defaultValue.ignoreEmptyLines)
    };
  }
}
function J9(s) {
  switch (s) {
    case "blink":
      return 1;
    case "smooth":
      return 2;
    case "phase":
      return 3;
    case "expand":
      return 4;
    case "solid":
      return 5;
  }
}
var zi;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(zi || (zi = {}));
function q9(s) {
  switch (s) {
    case "line":
      return zi.Line;
    case "block":
      return zi.Block;
    case "underline":
      return zi.Underline;
    case "line-thin":
      return zi.LineThin;
    case "block-outline":
      return zi.BlockOutline;
    case "underline-thin":
      return zi.UnderlineThin;
  }
}
class $9 extends L_ {
  constructor() {
    super(
      143
      /* EditorOption.editorClassName */
    );
  }
  compute(e, t, i) {
    const n = ["monaco-editor"];
    return t.get(
      39
      /* EditorOption.extraEditorClassName */
    ) && n.push(t.get(
      39
      /* EditorOption.extraEditorClassName */
    )), e.extraEditorClassName && n.push(e.extraEditorClassName), t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "default" ? n.push("mouse-default") : t.get(
      74
      /* EditorOption.mouseStyle */
    ) === "copy" && n.push("mouse-copy"), t.get(
      112
      /* EditorOption.showUnused */
    ) && n.push("showUnused"), t.get(
      141
      /* EditorOption.showDeprecated */
    ) && n.push("showDeprecated"), n.join(" ");
  }
}
class X9 extends Ze {
  constructor() {
    super(37, "emptySelectionClipboard", !0, { description: f("emptySelectionClipboard", "Controls whether copying without a selection copies the current line.") });
  }
  compute(e, t, i) {
    return i && e.emptySelectionClipboard;
  }
}
class Z9 extends Bt {
  constructor() {
    const e = {
      cursorMoveOnType: !0,
      seedSearchStringFromSelection: "always",
      autoFindInSelection: "never",
      globalFindClipboard: !1,
      addExtraSpaceOnTop: !0,
      loop: !0
    };
    super(41, "find", e, {
      "editor.find.cursorMoveOnType": {
        type: "boolean",
        default: e.cursorMoveOnType,
        description: f("find.cursorMoveOnType", "Controls whether the cursor should jump to find matches while typing.")
      },
      "editor.find.seedSearchStringFromSelection": {
        type: "string",
        enum: ["never", "always", "selection"],
        default: e.seedSearchStringFromSelection,
        enumDescriptions: [
          f("editor.find.seedSearchStringFromSelection.never", "Never seed search string from the editor selection."),
          f("editor.find.seedSearchStringFromSelection.always", "Always seed search string from the editor selection, including word at cursor position."),
          f("editor.find.seedSearchStringFromSelection.selection", "Only seed search string from the editor selection.")
        ],
        description: f("find.seedSearchStringFromSelection", "Controls whether the search string in the Find Widget is seeded from the editor selection.")
      },
      "editor.find.autoFindInSelection": {
        type: "string",
        enum: ["never", "always", "multiline"],
        default: e.autoFindInSelection,
        enumDescriptions: [
          f("editor.find.autoFindInSelection.never", "Never turn on Find in Selection automatically (default)."),
          f("editor.find.autoFindInSelection.always", "Always turn on Find in Selection automatically."),
          f("editor.find.autoFindInSelection.multiline", "Turn on Find in Selection automatically when multiple lines of content are selected.")
        ],
        description: f("find.autoFindInSelection", "Controls the condition for turning on Find in Selection automatically.")
      },
      "editor.find.globalFindClipboard": {
        type: "boolean",
        default: e.globalFindClipboard,
        description: f("find.globalFindClipboard", "Controls whether the Find Widget should read or modify the shared find clipboard on macOS."),
        included: ze
      },
      "editor.find.addExtraSpaceOnTop": {
        type: "boolean",
        default: e.addExtraSpaceOnTop,
        description: f("find.addExtraSpaceOnTop", "Controls whether the Find Widget should add extra lines on top of the editor. When true, you can scroll beyond the first line when the Find Widget is visible.")
      },
      "editor.find.loop": {
        type: "boolean",
        default: e.loop,
        description: f("find.loop", "Controls whether the search automatically restarts from the beginning (or the end) when no further matches can be found.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      cursorMoveOnType: ue(t.cursorMoveOnType, this.defaultValue.cursorMoveOnType),
      seedSearchStringFromSelection: typeof e.seedSearchStringFromSelection == "boolean" ? e.seedSearchStringFromSelection ? "always" : "never" : Gt(t.seedSearchStringFromSelection, this.defaultValue.seedSearchStringFromSelection, ["never", "always", "selection"]),
      autoFindInSelection: typeof e.autoFindInSelection == "boolean" ? e.autoFindInSelection ? "always" : "never" : Gt(t.autoFindInSelection, this.defaultValue.autoFindInSelection, ["never", "always", "multiline"]),
      globalFindClipboard: ue(t.globalFindClipboard, this.defaultValue.globalFindClipboard),
      addExtraSpaceOnTop: ue(t.addExtraSpaceOnTop, this.defaultValue.addExtraSpaceOnTop),
      loop: ue(t.loop, this.defaultValue.loop)
    };
  }
}
const nl = class nl extends Bt {
  constructor() {
    super(51, "fontLigatures", nl.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: f("fontLigatures", "Enables/Disables font ligatures ('calt' and 'liga' font features). Change this to a string for fine-grained control of the 'font-feature-settings' CSS property.")
        },
        {
          type: "string",
          description: f("fontFeatureSettings", "Explicit 'font-feature-settings' CSS property. A boolean can be passed instead if one only needs to turn on/off ligatures.")
        }
      ],
      description: f("fontLigaturesGeneral", "Configures font ligatures or font features. Can be either a boolean to enable/disable ligatures or a string for the value of the CSS 'font-feature-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" || e.length === 0 ? nl.OFF : e === "true" ? nl.ON : e : e ? nl.ON : nl.OFF;
  }
};
nl.OFF = '"liga" off, "calt" off', nl.ON = '"liga" on, "calt" on';
let hu = nl;
const sl = class sl extends Bt {
  constructor() {
    super(54, "fontVariations", sl.OFF, {
      anyOf: [
        {
          type: "boolean",
          description: f("fontVariations", "Enables/Disables the translation from font-weight to font-variation-settings. Change this to a string for fine-grained control of the 'font-variation-settings' CSS property.")
        },
        {
          type: "string",
          description: f("fontVariationSettings", "Explicit 'font-variation-settings' CSS property. A boolean can be passed instead if one only needs to translate font-weight to font-variation-settings.")
        }
      ],
      description: f("fontVariationsGeneral", "Configures font variations. Can be either a boolean to enable/disable the translation from font-weight to font-variation-settings or a string for the value of the CSS 'font-variation-settings' property."),
      default: !1
    });
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e === "false" ? sl.OFF : e === "true" ? sl.TRANSLATE : e : e ? sl.TRANSLATE : sl.OFF;
  }
  compute(e, t, i) {
    return e.fontInfo.fontVariationSettings;
  }
};
sl.OFF = "normal", sl.TRANSLATE = "translate";
let yA = sl;
class ez extends L_ {
  constructor() {
    super(
      50
      /* EditorOption.fontInfo */
    );
  }
  compute(e, t, i) {
    return e.fontInfo;
  }
}
class tz extends Am {
  constructor() {
    super(52, "fontSize", Zn.fontSize, {
      type: "number",
      minimum: 6,
      maximum: 100,
      default: Zn.fontSize,
      description: f("fontSize", "Controls the font size in pixels.")
    });
  }
  validate(e) {
    const t = Qs.float(e, this.defaultValue);
    return t === 0 ? Zn.fontSize : Qs.clamp(t, 6, 100);
  }
  compute(e, t, i) {
    return e.fontInfo.fontSize;
  }
}
const ta = class ta extends Bt {
  constructor() {
    super(53, "fontWeight", Zn.fontWeight, {
      anyOf: [
        {
          type: "number",
          minimum: ta.MINIMUM_VALUE,
          maximum: ta.MAXIMUM_VALUE,
          errorMessage: f("fontWeightErrorMessage", 'Only "normal" and "bold" keywords or numbers between 1 and 1000 are allowed.')
        },
        {
          type: "string",
          pattern: "^(normal|bold|1000|[1-9][0-9]{0,2})$"
        },
        {
          enum: ta.SUGGESTION_VALUES
        }
      ],
      default: Zn.fontWeight,
      description: f("fontWeight", 'Controls the font weight. Accepts "normal" and "bold" keywords or numbers between 1 and 1000.')
    });
  }
  validate(e) {
    return e === "normal" || e === "bold" ? e : String(_t.clampedInt(e, Zn.fontWeight, ta.MINIMUM_VALUE, ta.MAXIMUM_VALUE));
  }
};
ta.SUGGESTION_VALUES = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"], ta.MINIMUM_VALUE = 1, ta.MAXIMUM_VALUE = 1e3;
let Ex = ta;
class iz extends Bt {
  constructor() {
    const e = {
      multiple: "peek",
      multipleDefinitions: "peek",
      multipleTypeDefinitions: "peek",
      multipleDeclarations: "peek",
      multipleImplementations: "peek",
      multipleReferences: "peek",
      multipleTests: "peek",
      alternativeDefinitionCommand: "editor.action.goToReferences",
      alternativeTypeDefinitionCommand: "editor.action.goToReferences",
      alternativeDeclarationCommand: "editor.action.goToReferences",
      alternativeImplementationCommand: "",
      alternativeReferenceCommand: "",
      alternativeTestsCommand: ""
    }, t = {
      type: "string",
      enum: ["peek", "gotoAndPeek", "goto"],
      default: e.multiple,
      enumDescriptions: [
        f("editor.gotoLocation.multiple.peek", "Show Peek view of the results (default)"),
        f("editor.gotoLocation.multiple.gotoAndPeek", "Go to the primary result and show a Peek view"),
        f("editor.gotoLocation.multiple.goto", "Go to the primary result and enable Peek-less navigation to others")
      ]
    }, i = ["", "editor.action.referenceSearch.trigger", "editor.action.goToReferences", "editor.action.peekImplementation", "editor.action.goToImplementation", "editor.action.peekTypeDefinition", "editor.action.goToTypeDefinition", "editor.action.peekDeclaration", "editor.action.revealDeclaration", "editor.action.peekDefinition", "editor.action.revealDefinitionAside", "editor.action.revealDefinition"];
    super(58, "gotoLocation", e, {
      "editor.gotoLocation.multiple": {
        deprecationMessage: f("editor.gotoLocation.multiple.deprecated", "This setting is deprecated, please use separate settings like 'editor.editor.gotoLocation.multipleDefinitions' or 'editor.editor.gotoLocation.multipleImplementations' instead.")
      },
      "editor.gotoLocation.multipleDefinitions": {
        description: f("editor.editor.gotoLocation.multipleDefinitions", "Controls the behavior the 'Go to Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleTypeDefinitions": {
        description: f("editor.editor.gotoLocation.multipleTypeDefinitions", "Controls the behavior the 'Go to Type Definition'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleDeclarations": {
        description: f("editor.editor.gotoLocation.multipleDeclarations", "Controls the behavior the 'Go to Declaration'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleImplementations": {
        description: f("editor.editor.gotoLocation.multipleImplemenattions", "Controls the behavior the 'Go to Implementations'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.multipleReferences": {
        description: f("editor.editor.gotoLocation.multipleReferences", "Controls the behavior the 'Go to References'-command when multiple target locations exist."),
        ...t
      },
      "editor.gotoLocation.alternativeDefinitionCommand": {
        type: "string",
        default: e.alternativeDefinitionCommand,
        enum: i,
        description: f("alternativeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeTypeDefinitionCommand": {
        type: "string",
        default: e.alternativeTypeDefinitionCommand,
        enum: i,
        description: f("alternativeTypeDefinitionCommand", "Alternative command id that is being executed when the result of 'Go to Type Definition' is the current location.")
      },
      "editor.gotoLocation.alternativeDeclarationCommand": {
        type: "string",
        default: e.alternativeDeclarationCommand,
        enum: i,
        description: f("alternativeDeclarationCommand", "Alternative command id that is being executed when the result of 'Go to Declaration' is the current location.")
      },
      "editor.gotoLocation.alternativeImplementationCommand": {
        type: "string",
        default: e.alternativeImplementationCommand,
        enum: i,
        description: f("alternativeImplementationCommand", "Alternative command id that is being executed when the result of 'Go to Implementation' is the current location.")
      },
      "editor.gotoLocation.alternativeReferenceCommand": {
        type: "string",
        default: e.alternativeReferenceCommand,
        enum: i,
        description: f("alternativeReferenceCommand", "Alternative command id that is being executed when the result of 'Go to Reference' is the current location.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      multiple: Gt(t.multiple, this.defaultValue.multiple, ["peek", "gotoAndPeek", "goto"]),
      multipleDefinitions: t.multipleDefinitions ?? Gt(t.multipleDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTypeDefinitions: t.multipleTypeDefinitions ?? Gt(t.multipleTypeDefinitions, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleDeclarations: t.multipleDeclarations ?? Gt(t.multipleDeclarations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleImplementations: t.multipleImplementations ?? Gt(t.multipleImplementations, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleReferences: t.multipleReferences ?? Gt(t.multipleReferences, "peek", ["peek", "gotoAndPeek", "goto"]),
      multipleTests: t.multipleTests ?? Gt(t.multipleTests, "peek", ["peek", "gotoAndPeek", "goto"]),
      alternativeDefinitionCommand: wn.string(t.alternativeDefinitionCommand, this.defaultValue.alternativeDefinitionCommand),
      alternativeTypeDefinitionCommand: wn.string(t.alternativeTypeDefinitionCommand, this.defaultValue.alternativeTypeDefinitionCommand),
      alternativeDeclarationCommand: wn.string(t.alternativeDeclarationCommand, this.defaultValue.alternativeDeclarationCommand),
      alternativeImplementationCommand: wn.string(t.alternativeImplementationCommand, this.defaultValue.alternativeImplementationCommand),
      alternativeReferenceCommand: wn.string(t.alternativeReferenceCommand, this.defaultValue.alternativeReferenceCommand),
      alternativeTestsCommand: wn.string(t.alternativeTestsCommand, this.defaultValue.alternativeTestsCommand)
    };
  }
}
class nz extends Bt {
  constructor() {
    const e = {
      enabled: !0,
      delay: 300,
      hidingDelay: 300,
      sticky: !0,
      above: !0
    };
    super(60, "hover", e, {
      "editor.hover.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("hover.enabled", "Controls whether the hover is shown.")
      },
      "editor.hover.delay": {
        type: "number",
        default: e.delay,
        minimum: 0,
        maximum: 1e4,
        description: f("hover.delay", "Controls the delay in milliseconds after which the hover is shown.")
      },
      "editor.hover.sticky": {
        type: "boolean",
        default: e.sticky,
        description: f("hover.sticky", "Controls whether the hover should remain visible when mouse is moved over it.")
      },
      "editor.hover.hidingDelay": {
        type: "integer",
        minimum: 0,
        default: e.hidingDelay,
        description: f("hover.hidingDelay", "Controls the delay in milliseconds after which the hover is hidden. Requires `editor.hover.sticky` to be enabled.")
      },
      "editor.hover.above": {
        type: "boolean",
        default: e.above,
        description: f("hover.above", "Prefer showing hovers above the line, if there's space.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      delay: _t.clampedInt(t.delay, this.defaultValue.delay, 0, 1e4),
      sticky: ue(t.sticky, this.defaultValue.sticky),
      hidingDelay: _t.clampedInt(t.hidingDelay, this.defaultValue.hidingDelay, 0, 6e5),
      above: ue(t.above, this.defaultValue.above)
    };
  }
}
class df extends L_ {
  constructor() {
    super(
      146
      /* EditorOption.layoutInfo */
    );
  }
  compute(e, t, i) {
    return df.computeLayout(t, {
      memory: e.memory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight,
      isDominatedByLongLines: e.isDominatedByLongLines,
      lineHeight: e.fontInfo.lineHeight,
      viewLineCount: e.viewLineCount,
      lineNumbersDigitCount: e.lineNumbersDigitCount,
      typicalHalfwidthCharacterWidth: e.fontInfo.typicalHalfwidthCharacterWidth,
      maxDigitWidth: e.fontInfo.maxDigitWidth,
      pixelRatio: e.pixelRatio,
      glyphMarginDecorationLaneCount: e.glyphMarginDecorationLaneCount
    });
  }
  static computeContainedMinimapLineCount(e) {
    const t = e.height / e.lineHeight, i = Math.floor(e.paddingTop / e.lineHeight);
    let n = Math.floor(e.paddingBottom / e.lineHeight);
    e.scrollBeyondLastLine && (n = Math.max(n, t - 1));
    const o = (i + e.viewLineCount + n) / (e.pixelRatio * e.height), r = Math.floor(e.viewLineCount / o);
    return { typicalViewportLineCount: t, extraLinesBeforeFirstLine: i, extraLinesBeyondLastLine: n, desiredRatio: o, minimapLineCount: r };
  }
  static _computeMinimapLayout(e, t) {
    const i = e.outerWidth, n = e.outerHeight, o = e.pixelRatio;
    if (!e.minimap.enabled)
      return {
        renderMinimap: 0,
        minimapLeft: 0,
        minimapWidth: 0,
        minimapHeightIsEditorHeight: !1,
        minimapIsSampling: !1,
        minimapScale: 1,
        minimapLineHeight: 1,
        minimapCanvasInnerWidth: 0,
        minimapCanvasInnerHeight: Math.floor(o * n),
        minimapCanvasOuterWidth: 0,
        minimapCanvasOuterHeight: n
      };
    const r = t.stableMinimapLayoutInput, a = r && e.outerHeight === r.outerHeight && e.lineHeight === r.lineHeight && e.typicalHalfwidthCharacterWidth === r.typicalHalfwidthCharacterWidth && e.pixelRatio === r.pixelRatio && e.scrollBeyondLastLine === r.scrollBeyondLastLine && e.paddingTop === r.paddingTop && e.paddingBottom === r.paddingBottom && e.minimap.enabled === r.minimap.enabled && e.minimap.side === r.minimap.side && e.minimap.size === r.minimap.size && e.minimap.showSlider === r.minimap.showSlider && e.minimap.renderCharacters === r.minimap.renderCharacters && e.minimap.maxColumn === r.minimap.maxColumn && e.minimap.scale === r.minimap.scale && e.verticalScrollbarWidth === r.verticalScrollbarWidth && e.isViewportWrapping === r.isViewportWrapping, l = e.lineHeight, c = e.typicalHalfwidthCharacterWidth, d = e.scrollBeyondLastLine, h = e.minimap.renderCharacters;
    let u = o >= 2 ? Math.round(e.minimap.scale * 2) : e.minimap.scale;
    const g = e.minimap.maxColumn, m = e.minimap.size, p = e.minimap.side, A = e.verticalScrollbarWidth, _ = e.viewLineCount, b = e.remainingWidth, C = e.isViewportWrapping, w = h ? 2 : 3;
    let S = Math.floor(o * n);
    const x = S / o;
    let y = !1, D = !1, I = w * u, Q = u / o, P = 1;
    if (m === "fill" || m === "fit") {
      const { typicalViewportLineCount: he, extraLinesBeforeFirstLine: ae, extraLinesBeyondLastLine: be, desiredRatio: Ce, minimapLineCount: Ft } = df.computeContainedMinimapLineCount({
        viewLineCount: _,
        scrollBeyondLastLine: d,
        paddingTop: e.paddingTop,
        paddingBottom: e.paddingBottom,
        height: n,
        lineHeight: l,
        pixelRatio: o
      });
      if (_ / Ft > 1)
        y = !0, D = !0, u = 1, I = 1, Q = u / o;
      else {
        let Ut = !1, ft = u + 1;
        if (m === "fit") {
          const ri = Math.ceil((ae + _ + be) * I);
          C && a && b <= t.stableFitRemainingWidth ? (Ut = !0, ft = t.stableFitMaxMinimapScale) : Ut = ri > S;
        }
        if (m === "fill" || Ut) {
          y = !0;
          const ri = u;
          I = Math.min(l * o, Math.max(1, Math.floor(1 / Ce))), C && a && b <= t.stableFitRemainingWidth && (ft = t.stableFitMaxMinimapScale), u = Math.min(ft, Math.max(1, Math.floor(I / w))), u > ri && (P = Math.min(2, u / ri)), Q = u / o / P, S = Math.ceil(Math.max(he, ae + _ + be) * I), C ? (t.stableMinimapLayoutInput = e, t.stableFitRemainingWidth = b, t.stableFitMaxMinimapScale = u) : (t.stableMinimapLayoutInput = null, t.stableFitRemainingWidth = 0);
        }
      }
    }
    const W = Math.floor(g * Q), j = Math.min(W, Math.max(0, Math.floor((b - A - 2) * Q / (c + Q))) + qr);
    let H = Math.floor(o * j);
    const J = H / o;
    H = Math.floor(H * P);
    const se = h ? 1 : 2, ce = p === "left" ? 0 : i - j - A;
    return {
      renderMinimap: se,
      minimapLeft: ce,
      minimapWidth: j,
      minimapHeightIsEditorHeight: y,
      minimapIsSampling: D,
      minimapScale: u,
      minimapLineHeight: I,
      minimapCanvasInnerWidth: H,
      minimapCanvasInnerHeight: S,
      minimapCanvasOuterWidth: J,
      minimapCanvasOuterHeight: x
    };
  }
  static computeLayout(e, t) {
    const i = t.outerWidth | 0, n = t.outerHeight | 0, o = t.lineHeight | 0, r = t.lineNumbersDigitCount | 0, a = t.typicalHalfwidthCharacterWidth, l = t.maxDigitWidth, c = t.pixelRatio, d = t.viewLineCount, h = e.get(
      138
      /* EditorOption.wordWrapOverride2 */
    ), u = h === "inherit" ? e.get(
      137
      /* EditorOption.wordWrapOverride1 */
    ) : h, g = u === "inherit" ? e.get(
      133
      /* EditorOption.wordWrap */
    ) : u, m = e.get(
      136
      /* EditorOption.wordWrapColumn */
    ), p = t.isDominatedByLongLines, A = e.get(
      57
      /* EditorOption.glyphMargin */
    ), _ = e.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0, b = e.get(
      69
      /* EditorOption.lineNumbersMinChars */
    ), C = e.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), w = e.get(
      84
      /* EditorOption.padding */
    ), S = e.get(
      73
      /* EditorOption.minimap */
    ), x = e.get(
      104
      /* EditorOption.scrollbar */
    ), y = x.verticalScrollbarSize, D = x.verticalHasArrows, I = x.arrowSize, Q = x.horizontalScrollbarSize, P = e.get(
      43
      /* EditorOption.folding */
    ), W = e.get(
      111
      /* EditorOption.showFoldingControls */
    ) !== "never";
    let j = e.get(
      66
      /* EditorOption.lineDecorationsWidth */
    );
    P && W && (j += 16);
    let H = 0;
    if (_) {
      const Ai = Math.max(r, b);
      H = Math.round(Ai * l);
    }
    let J = 0;
    A && (J = o * t.glyphMarginDecorationLaneCount);
    let se = 0, ce = se + J, he = ce + H, ae = he + j;
    const be = i - J - H - j;
    let Ce = !1, Ft = !1, ut = -1;
    u === "inherit" && p ? (Ce = !0, Ft = !0) : g === "on" || g === "bounded" ? Ft = !0 : g === "wordWrapColumn" && (ut = m);
    const Ut = df._computeMinimapLayout({
      outerWidth: i,
      outerHeight: n,
      lineHeight: o,
      typicalHalfwidthCharacterWidth: a,
      pixelRatio: c,
      scrollBeyondLastLine: C,
      paddingTop: w.top,
      paddingBottom: w.bottom,
      minimap: S,
      verticalScrollbarWidth: y,
      viewLineCount: d,
      remainingWidth: be,
      isViewportWrapping: Ft
    }, t.memory || new eH());
    Ut.renderMinimap !== 0 && Ut.minimapLeft === 0 && (se += Ut.minimapWidth, ce += Ut.minimapWidth, he += Ut.minimapWidth, ae += Ut.minimapWidth);
    const ft = be - Ut.minimapWidth, ri = Math.max(1, Math.floor((ft - y - 2) / a)), io = D ? I : 0;
    return Ft && (ut = Math.max(1, ri), g === "bounded" && (ut = Math.min(ut, m))), {
      width: i,
      height: n,
      glyphMarginLeft: se,
      glyphMarginWidth: J,
      glyphMarginDecorationLaneCount: t.glyphMarginDecorationLaneCount,
      lineNumbersLeft: ce,
      lineNumbersWidth: H,
      decorationsLeft: he,
      decorationsWidth: j,
      contentLeft: ae,
      contentWidth: ft,
      minimap: Ut,
      viewportColumn: ri,
      isWordWrapMinified: Ce,
      isViewportWrapping: Ft,
      wrappingColumn: ut,
      verticalScrollbarWidth: y,
      horizontalScrollbarHeight: Q,
      overviewRuler: {
        top: io,
        width: y,
        height: n - 2 * io,
        right: 0
      }
    };
  }
}
class sz extends Bt {
  constructor() {
    super(140, "wrappingStrategy", "simple", {
      "editor.wrappingStrategy": {
        enumDescriptions: [
          f("wrappingStrategy.simple", "Assumes that all characters are of the same width. This is a fast algorithm that works correctly for monospace fonts and certain scripts (like Latin characters) where glyphs are of equal width."),
          f("wrappingStrategy.advanced", "Delegates wrapping points computation to the browser. This is a slow algorithm, that might cause freezes for large files, but it works correctly in all cases.")
        ],
        type: "string",
        enum: ["simple", "advanced"],
        default: "simple",
        description: f("wrappingStrategy", "Controls the algorithm that computes wrapping points. Note that when in accessibility mode, advanced will be used for the best experience.")
      }
    });
  }
  validate(e) {
    return Gt(e, "simple", ["simple", "advanced"]);
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? "advanced" : i;
  }
}
var Ho;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(Ho || (Ho = {}));
class oz extends Bt {
  constructor() {
    const e = { enabled: Ho.OnCode };
    super(65, "lightbulb", e, {
      "editor.lightbulb.enabled": {
        type: "string",
        tags: ["experimental"],
        enum: [Ho.Off, Ho.OnCode, Ho.On],
        default: e.enabled,
        enumDescriptions: [
          f("editor.lightbulb.enabled.off", "Disable the code action menu."),
          f("editor.lightbulb.enabled.onCode", "Show the code action menu when the cursor is on lines with code."),
          f("editor.lightbulb.enabled.on", "Show the code action menu when the cursor is on lines with code or on empty lines.")
        ],
        description: f("enabled", "Enables the Code Action lightbulb in the editor.")
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      enabled: Gt(e.enabled, this.defaultValue.enabled, [Ho.Off, Ho.OnCode, Ho.On])
    };
  }
}
class rz extends Bt {
  constructor() {
    const e = { enabled: !0, maxLineCount: 5, defaultModel: "outlineModel", scrollWithEditor: !0 };
    super(116, "stickyScroll", e, {
      "editor.stickyScroll.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("editor.stickyScroll.enabled", "Shows the nested current scopes during the scroll at the top of the editor."),
        tags: ["experimental"]
      },
      "editor.stickyScroll.maxLineCount": {
        type: "number",
        default: e.maxLineCount,
        minimum: 1,
        maximum: 20,
        description: f("editor.stickyScroll.maxLineCount", "Defines the maximum number of sticky lines to show.")
      },
      "editor.stickyScroll.defaultModel": {
        type: "string",
        enum: ["outlineModel", "foldingProviderModel", "indentationModel"],
        default: e.defaultModel,
        description: f("editor.stickyScroll.defaultModel", "Defines the model to use for determining which lines to stick. If the outline model does not exist, it will fall back on the folding provider model which falls back on the indentation model. This order is respected in all three cases.")
      },
      "editor.stickyScroll.scrollWithEditor": {
        type: "boolean",
        default: e.scrollWithEditor,
        description: f("editor.stickyScroll.scrollWithEditor", "Enable scrolling of Sticky Scroll with the editor's horizontal scrollbar.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      maxLineCount: _t.clampedInt(t.maxLineCount, this.defaultValue.maxLineCount, 1, 20),
      defaultModel: Gt(t.defaultModel, this.defaultValue.defaultModel, ["outlineModel", "foldingProviderModel", "indentationModel"]),
      scrollWithEditor: ue(t.scrollWithEditor, this.defaultValue.scrollWithEditor)
    };
  }
}
class az extends Bt {
  constructor() {
    const e = { enabled: "on", fontSize: 0, fontFamily: "", padding: !1 };
    super(142, "inlayHints", e, {
      "editor.inlayHints.enabled": {
        type: "string",
        default: e.enabled,
        description: f("inlayHints.enable", "Enables the inlay hints in the editor."),
        enum: ["on", "onUnlessPressed", "offUnlessPressed", "off"],
        markdownEnumDescriptions: [
          f("editor.inlayHints.on", "Inlay hints are enabled"),
          f("editor.inlayHints.onUnlessPressed", "Inlay hints are showing by default and hide when holding {0}", ze ? "Ctrl+Option" : "Ctrl+Alt"),
          f("editor.inlayHints.offUnlessPressed", "Inlay hints are hidden by default and show when holding {0}", ze ? "Ctrl+Option" : "Ctrl+Alt"),
          f("editor.inlayHints.off", "Inlay hints are disabled")
        ]
      },
      "editor.inlayHints.fontSize": {
        type: "number",
        default: e.fontSize,
        markdownDescription: f("inlayHints.fontSize", "Controls font size of inlay hints in the editor. As default the {0} is used when the configured value is less than {1} or greater than the editor font size.", "`#editor.fontSize#`", "`5`")
      },
      "editor.inlayHints.fontFamily": {
        type: "string",
        default: e.fontFamily,
        markdownDescription: f("inlayHints.fontFamily", "Controls font family of inlay hints in the editor. When set to empty, the {0} is used.", "`#editor.fontFamily#`")
      },
      "editor.inlayHints.padding": {
        type: "boolean",
        default: e.padding,
        description: f("inlayHints.padding", "Enables the padding around the inlay hints in the editor.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return typeof t.enabled == "boolean" && (t.enabled = t.enabled ? "on" : "off"), {
      enabled: Gt(t.enabled, this.defaultValue.enabled, ["on", "off", "offUnlessPressed", "onUnlessPressed"]),
      fontSize: _t.clampedInt(t.fontSize, this.defaultValue.fontSize, 0, 100),
      fontFamily: wn.string(t.fontFamily, this.defaultValue.fontFamily),
      padding: ue(t.padding, this.defaultValue.padding)
    };
  }
}
class lz extends Bt {
  constructor() {
    super(66, "lineDecorationsWidth", 10);
  }
  validate(e) {
    return typeof e == "string" && /^\d+(\.\d+)?ch$/.test(e) ? -parseFloat(e.substring(0, e.length - 2)) : _t.clampedInt(e, this.defaultValue, 0, 1e3);
  }
  compute(e, t, i) {
    return i < 0 ? _t.clampedInt(-i * e.fontInfo.typicalHalfwidthCharacterWidth, this.defaultValue, 0, 1e3) : i;
  }
}
class cz extends Qs {
  constructor() {
    super(67, "lineHeight", Zn.lineHeight, (e) => Qs.clamp(e, 0, 150), { markdownDescription: f("lineHeight", `Controls the line height. 
 - Use 0 to automatically compute the line height from the font size.
 - Values between 0 and 8 will be used as a multiplier with the font size.
 - Values greater than or equal to 8 will be used as effective values.`) });
  }
  compute(e, t, i) {
    return e.fontInfo.lineHeight;
  }
}
class dz extends Bt {
  constructor() {
    const e = {
      enabled: !0,
      size: "proportional",
      side: "right",
      showSlider: "mouseover",
      autohide: !1,
      renderCharacters: !0,
      maxColumn: 120,
      scale: 1,
      showRegionSectionHeaders: !0,
      showMarkSectionHeaders: !0,
      sectionHeaderFontSize: 9,
      sectionHeaderLetterSpacing: 1
    };
    super(73, "minimap", e, {
      "editor.minimap.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("minimap.enabled", "Controls whether the minimap is shown.")
      },
      "editor.minimap.autohide": {
        type: "boolean",
        default: e.autohide,
        description: f("minimap.autohide", "Controls whether the minimap is hidden automatically.")
      },
      "editor.minimap.size": {
        type: "string",
        enum: ["proportional", "fill", "fit"],
        enumDescriptions: [
          f("minimap.size.proportional", "The minimap has the same size as the editor contents (and might scroll)."),
          f("minimap.size.fill", "The minimap will stretch or shrink as necessary to fill the height of the editor (no scrolling)."),
          f("minimap.size.fit", "The minimap will shrink as necessary to never be larger than the editor (no scrolling).")
        ],
        default: e.size,
        description: f("minimap.size", "Controls the size of the minimap.")
      },
      "editor.minimap.side": {
        type: "string",
        enum: ["left", "right"],
        default: e.side,
        description: f("minimap.side", "Controls the side where to render the minimap.")
      },
      "editor.minimap.showSlider": {
        type: "string",
        enum: ["always", "mouseover"],
        default: e.showSlider,
        description: f("minimap.showSlider", "Controls when the minimap slider is shown.")
      },
      "editor.minimap.scale": {
        type: "number",
        default: e.scale,
        minimum: 1,
        maximum: 3,
        enum: [1, 2, 3],
        description: f("minimap.scale", "Scale of content drawn in the minimap: 1, 2 or 3.")
      },
      "editor.minimap.renderCharacters": {
        type: "boolean",
        default: e.renderCharacters,
        description: f("minimap.renderCharacters", "Render the actual characters on a line as opposed to color blocks.")
      },
      "editor.minimap.maxColumn": {
        type: "number",
        default: e.maxColumn,
        description: f("minimap.maxColumn", "Limit the width of the minimap to render at most a certain number of columns.")
      },
      "editor.minimap.showRegionSectionHeaders": {
        type: "boolean",
        default: e.showRegionSectionHeaders,
        description: f("minimap.showRegionSectionHeaders", "Controls whether named regions are shown as section headers in the minimap.")
      },
      "editor.minimap.showMarkSectionHeaders": {
        type: "boolean",
        default: e.showMarkSectionHeaders,
        description: f("minimap.showMarkSectionHeaders", "Controls whether MARK: comments are shown as section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderFontSize": {
        type: "number",
        default: e.sectionHeaderFontSize,
        description: f("minimap.sectionHeaderFontSize", "Controls the font size of section headers in the minimap.")
      },
      "editor.minimap.sectionHeaderLetterSpacing": {
        type: "number",
        default: e.sectionHeaderLetterSpacing,
        description: f("minimap.sectionHeaderLetterSpacing", "Controls the amount of space (in pixels) between characters of section header. This helps the readability of the header in small font sizes.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      autohide: ue(t.autohide, this.defaultValue.autohide),
      size: Gt(t.size, this.defaultValue.size, ["proportional", "fill", "fit"]),
      side: Gt(t.side, this.defaultValue.side, ["right", "left"]),
      showSlider: Gt(t.showSlider, this.defaultValue.showSlider, ["always", "mouseover"]),
      renderCharacters: ue(t.renderCharacters, this.defaultValue.renderCharacters),
      scale: _t.clampedInt(t.scale, 1, 1, 3),
      maxColumn: _t.clampedInt(t.maxColumn, this.defaultValue.maxColumn, 1, 1e4),
      showRegionSectionHeaders: ue(t.showRegionSectionHeaders, this.defaultValue.showRegionSectionHeaders),
      showMarkSectionHeaders: ue(t.showMarkSectionHeaders, this.defaultValue.showMarkSectionHeaders),
      sectionHeaderFontSize: Qs.clamp(t.sectionHeaderFontSize ?? this.defaultValue.sectionHeaderFontSize, 4, 32),
      sectionHeaderLetterSpacing: Qs.clamp(t.sectionHeaderLetterSpacing ?? this.defaultValue.sectionHeaderLetterSpacing, 0, 5)
    };
  }
}
function hz(s) {
  return s === "ctrlCmd" ? ze ? "metaKey" : "ctrlKey" : "altKey";
}
class uz extends Bt {
  constructor() {
    super(84, "padding", { top: 0, bottom: 0 }, {
      "editor.padding.top": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: f("padding.top", "Controls the amount of space between the top edge of the editor and the first line.")
      },
      "editor.padding.bottom": {
        type: "number",
        default: 0,
        minimum: 0,
        maximum: 1e3,
        description: f("padding.bottom", "Controls the amount of space between the bottom edge of the editor and the last line.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      top: _t.clampedInt(t.top, 0, 0, 1e3),
      bottom: _t.clampedInt(t.bottom, 0, 0, 1e3)
    };
  }
}
class gz extends Bt {
  constructor() {
    const e = {
      enabled: !0,
      cycle: !0
    };
    super(86, "parameterHints", e, {
      "editor.parameterHints.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("parameterHints.enabled", "Enables a pop-up that shows parameter documentation and type information as you type.")
      },
      "editor.parameterHints.cycle": {
        type: "boolean",
        default: e.cycle,
        description: f("parameterHints.cycle", "Controls whether the parameter hints menu cycles or closes when reaching the end of the list.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      cycle: ue(t.cycle, this.defaultValue.cycle)
    };
  }
}
class fz extends L_ {
  constructor() {
    super(
      144
      /* EditorOption.pixelRatio */
    );
  }
  compute(e, t, i) {
    return e.pixelRatio;
  }
}
class mz extends Bt {
  constructor() {
    super(88, "placeholder", void 0);
  }
  validate(e) {
    return typeof e > "u" ? this.defaultValue : typeof e == "string" ? e : this.defaultValue;
  }
}
class pz extends Bt {
  constructor() {
    const e = {
      other: "on",
      comments: "off",
      strings: "off"
    }, t = [
      { type: "boolean" },
      {
        type: "string",
        enum: ["on", "inline", "off"],
        enumDescriptions: [f("on", "Quick suggestions show inside the suggest widget"), f("inline", "Quick suggestions show as ghost text"), f("off", "Quick suggestions are disabled")]
      }
    ];
    super(90, "quickSuggestions", e, {
      type: "object",
      additionalProperties: !1,
      properties: {
        strings: {
          anyOf: t,
          default: e.strings,
          description: f("quickSuggestions.strings", "Enable quick suggestions inside strings.")
        },
        comments: {
          anyOf: t,
          default: e.comments,
          description: f("quickSuggestions.comments", "Enable quick suggestions inside comments.")
        },
        other: {
          anyOf: t,
          default: e.other,
          description: f("quickSuggestions.other", "Enable quick suggestions outside of strings and comments.")
        }
      },
      default: e,
      markdownDescription: f("quickSuggestions", "Controls whether suggestions should automatically show up while typing. This can be controlled for typing in comments, strings, and other code. Quick suggestion can be configured to show as ghost text or with the suggest widget. Also be aware of the {0}-setting which controls if suggestions are triggered by special characters.", "`#editor.suggestOnTriggerCharacters#`")
    }), this.defaultValue = e;
  }
  validate(e) {
    if (typeof e == "boolean") {
      const c = e ? "on" : "off";
      return { comments: c, strings: c, other: c };
    }
    if (!e || typeof e != "object")
      return this.defaultValue;
    const { other: t, comments: i, strings: n } = e, o = ["on", "inline", "off"];
    let r, a, l;
    return typeof t == "boolean" ? r = t ? "on" : "off" : r = Gt(t, this.defaultValue.other, o), typeof i == "boolean" ? a = i ? "on" : "off" : a = Gt(i, this.defaultValue.comments, o), typeof n == "boolean" ? l = n ? "on" : "off" : l = Gt(n, this.defaultValue.strings, o), {
      other: r,
      comments: a,
      strings: l
    };
  }
}
class Az extends Bt {
  constructor() {
    super(68, "lineNumbers", { renderType: 1, renderFn: null }, {
      type: "string",
      enum: ["off", "on", "relative", "interval"],
      enumDescriptions: [
        f("lineNumbers.off", "Line numbers are not rendered."),
        f("lineNumbers.on", "Line numbers are rendered as absolute number."),
        f("lineNumbers.relative", "Line numbers are rendered as distance in lines to cursor position."),
        f("lineNumbers.interval", "Line numbers are rendered every 10 lines.")
      ],
      default: "on",
      description: f("lineNumbers", "Controls the display of line numbers.")
    });
  }
  validate(e) {
    let t = this.defaultValue.renderType, i = this.defaultValue.renderFn;
    return typeof e < "u" && (typeof e == "function" ? (t = 4, i = e) : e === "interval" ? t = 3 : e === "relative" ? t = 2 : e === "on" ? t = 1 : t = 0), {
      renderType: t,
      renderFn: i
    };
  }
}
function Jw(s) {
  const e = s.get(
    99
    /* EditorOption.renderValidationDecorations */
  );
  return e === "editable" ? s.get(
    92
    /* EditorOption.readOnly */
  ) : e !== "on";
}
class _z extends Bt {
  constructor() {
    const e = [], t = { type: "number", description: f("rulers.size", "Number of monospace characters at which this editor ruler will render.") };
    super(103, "rulers", e, {
      type: "array",
      items: {
        anyOf: [
          t,
          {
            type: [
              "object"
            ],
            properties: {
              column: t,
              color: {
                type: "string",
                description: f("rulers.color", "Color of this editor ruler."),
                format: "color-hex"
              }
            }
          }
        ]
      },
      default: e,
      description: f("rulers", "Render vertical rulers after a certain number of monospace characters. Use multiple values for multiple rulers. No rulers are drawn if array is empty.")
    });
  }
  validate(e) {
    if (Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "number")
          t.push({
            column: _t.clampedInt(i, 0, 0, 1e4),
            color: null
          });
        else if (i && typeof i == "object") {
          const n = i;
          t.push({
            column: _t.clampedInt(n.column, 0, 0, 1e4),
            color: n.color
          });
        }
      return t.sort((i, n) => i.column - n.column), t;
    }
    return this.defaultValue;
  }
}
class bz extends Bt {
  constructor() {
    super(93, "readOnlyMessage", void 0);
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : e;
  }
}
function zB(s, e) {
  if (typeof s != "string")
    return e;
  switch (s) {
    case "hidden":
      return 2;
    case "visible":
      return 3;
    default:
      return 1;
  }
}
let wz = class extends Bt {
  constructor() {
    const e = {
      vertical: 1,
      horizontal: 1,
      arrowSize: 11,
      useShadows: !0,
      verticalHasArrows: !1,
      horizontalHasArrows: !1,
      horizontalScrollbarSize: 12,
      horizontalSliderSize: 12,
      verticalScrollbarSize: 14,
      verticalSliderSize: 14,
      handleMouseWheel: !0,
      alwaysConsumeMouseWheel: !0,
      scrollByPage: !1,
      ignoreHorizontalScrollbarInContentHeight: !1
    };
    super(104, "scrollbar", e, {
      "editor.scrollbar.vertical": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          f("scrollbar.vertical.auto", "The vertical scrollbar will be visible only when necessary."),
          f("scrollbar.vertical.visible", "The vertical scrollbar will always be visible."),
          f("scrollbar.vertical.fit", "The vertical scrollbar will always be hidden.")
        ],
        default: "auto",
        description: f("scrollbar.vertical", "Controls the visibility of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontal": {
        type: "string",
        enum: ["auto", "visible", "hidden"],
        enumDescriptions: [
          f("scrollbar.horizontal.auto", "The horizontal scrollbar will be visible only when necessary."),
          f("scrollbar.horizontal.visible", "The horizontal scrollbar will always be visible."),
          f("scrollbar.horizontal.fit", "The horizontal scrollbar will always be hidden.")
        ],
        default: "auto",
        description: f("scrollbar.horizontal", "Controls the visibility of the horizontal scrollbar.")
      },
      "editor.scrollbar.verticalScrollbarSize": {
        type: "number",
        default: e.verticalScrollbarSize,
        description: f("scrollbar.verticalScrollbarSize", "The width of the vertical scrollbar.")
      },
      "editor.scrollbar.horizontalScrollbarSize": {
        type: "number",
        default: e.horizontalScrollbarSize,
        description: f("scrollbar.horizontalScrollbarSize", "The height of the horizontal scrollbar.")
      },
      "editor.scrollbar.scrollByPage": {
        type: "boolean",
        default: e.scrollByPage,
        description: f("scrollbar.scrollByPage", "Controls whether clicks scroll by page or jump to click position.")
      },
      "editor.scrollbar.ignoreHorizontalScrollbarInContentHeight": {
        type: "boolean",
        default: e.ignoreHorizontalScrollbarInContentHeight,
        description: f("scrollbar.ignoreHorizontalScrollbarInContentHeight", "When set, the horizontal scrollbar will not increase the size of the editor's content.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e, i = _t.clampedInt(t.horizontalScrollbarSize, this.defaultValue.horizontalScrollbarSize, 0, 1e3), n = _t.clampedInt(t.verticalScrollbarSize, this.defaultValue.verticalScrollbarSize, 0, 1e3);
    return {
      arrowSize: _t.clampedInt(t.arrowSize, this.defaultValue.arrowSize, 0, 1e3),
      vertical: zB(t.vertical, this.defaultValue.vertical),
      horizontal: zB(t.horizontal, this.defaultValue.horizontal),
      useShadows: ue(t.useShadows, this.defaultValue.useShadows),
      verticalHasArrows: ue(t.verticalHasArrows, this.defaultValue.verticalHasArrows),
      horizontalHasArrows: ue(t.horizontalHasArrows, this.defaultValue.horizontalHasArrows),
      handleMouseWheel: ue(t.handleMouseWheel, this.defaultValue.handleMouseWheel),
      alwaysConsumeMouseWheel: ue(t.alwaysConsumeMouseWheel, this.defaultValue.alwaysConsumeMouseWheel),
      horizontalScrollbarSize: i,
      horizontalSliderSize: _t.clampedInt(t.horizontalSliderSize, i, 0, 1e3),
      verticalScrollbarSize: n,
      verticalSliderSize: _t.clampedInt(t.verticalSliderSize, n, 0, 1e3),
      scrollByPage: ue(t.scrollByPage, this.defaultValue.scrollByPage),
      ignoreHorizontalScrollbarInContentHeight: ue(t.ignoreHorizontalScrollbarInContentHeight, this.defaultValue.ignoreHorizontalScrollbarInContentHeight)
    };
  }
};
const hr = "inUntrustedWorkspace", Id = {
  allowedCharacters: "editor.unicodeHighlight.allowedCharacters",
  invisibleCharacters: "editor.unicodeHighlight.invisibleCharacters",
  nonBasicASCII: "editor.unicodeHighlight.nonBasicASCII",
  ambiguousCharacters: "editor.unicodeHighlight.ambiguousCharacters",
  includeComments: "editor.unicodeHighlight.includeComments",
  includeStrings: "editor.unicodeHighlight.includeStrings",
  allowedLocales: "editor.unicodeHighlight.allowedLocales"
};
class Cz extends Bt {
  constructor() {
    const e = {
      nonBasicASCII: hr,
      invisibleCharacters: !0,
      ambiguousCharacters: !0,
      includeComments: hr,
      includeStrings: !0,
      allowedCharacters: {},
      allowedLocales: { _os: !0, _vscode: !0 }
    };
    super(126, "unicodeHighlight", e, {
      [Id.nonBasicASCII]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, hr],
        default: e.nonBasicASCII,
        description: f("unicodeHighlight.nonBasicASCII", "Controls whether all non-basic ASCII characters are highlighted. Only characters between U+0020 and U+007E, tab, line-feed and carriage-return are considered basic ASCII.")
      },
      [Id.invisibleCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.invisibleCharacters,
        description: f("unicodeHighlight.invisibleCharacters", "Controls whether characters that just reserve space or have no width at all are highlighted.")
      },
      [Id.ambiguousCharacters]: {
        restricted: !0,
        type: "boolean",
        default: e.ambiguousCharacters,
        description: f("unicodeHighlight.ambiguousCharacters", "Controls whether characters are highlighted that can be confused with basic ASCII characters, except those that are common in the current user locale.")
      },
      [Id.includeComments]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, hr],
        default: e.includeComments,
        description: f("unicodeHighlight.includeComments", "Controls whether characters in comments should also be subject to Unicode highlighting.")
      },
      [Id.includeStrings]: {
        restricted: !0,
        type: ["boolean", "string"],
        enum: [!0, !1, hr],
        default: e.includeStrings,
        description: f("unicodeHighlight.includeStrings", "Controls whether characters in strings should also be subject to Unicode highlighting.")
      },
      [Id.allowedCharacters]: {
        restricted: !0,
        type: "object",
        default: e.allowedCharacters,
        description: f("unicodeHighlight.allowedCharacters", "Defines allowed characters that are not being highlighted."),
        additionalProperties: {
          type: "boolean"
        }
      },
      [Id.allowedLocales]: {
        restricted: !0,
        type: "object",
        additionalProperties: {
          type: "boolean"
        },
        default: e.allowedLocales,
        description: f("unicodeHighlight.allowedLocales", "Unicode characters that are common in allowed locales are not being highlighted.")
      }
    });
  }
  applyUpdate(e, t) {
    let i = !1;
    t.allowedCharacters && e && (bs(e.allowedCharacters, t.allowedCharacters) || (e = { ...e, allowedCharacters: t.allowedCharacters }, i = !0)), t.allowedLocales && e && (bs(e.allowedLocales, t.allowedLocales) || (e = { ...e, allowedLocales: t.allowedLocales }, i = !0));
    const n = super.applyUpdate(e, t);
    return i ? new Dp(n.newValue, !0) : n;
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      nonBasicASCII: hf(t.nonBasicASCII, hr, [!0, !1, hr]),
      invisibleCharacters: ue(t.invisibleCharacters, this.defaultValue.invisibleCharacters),
      ambiguousCharacters: ue(t.ambiguousCharacters, this.defaultValue.ambiguousCharacters),
      includeComments: hf(t.includeComments, hr, [!0, !1, hr]),
      includeStrings: hf(t.includeStrings, hr, [!0, !1, hr]),
      allowedCharacters: this.validateBooleanMap(e.allowedCharacters, this.defaultValue.allowedCharacters),
      allowedLocales: this.validateBooleanMap(e.allowedLocales, this.defaultValue.allowedLocales)
    };
  }
  validateBooleanMap(e, t) {
    if (typeof e != "object" || !e)
      return t;
    const i = {};
    for (const [n, o] of Object.entries(e))
      o === !0 && (i[n] = !0);
    return i;
  }
}
class vz extends Bt {
  constructor() {
    const e = {
      enabled: !0,
      mode: "subwordSmart",
      showToolbar: "onHover",
      suppressSuggestions: !1,
      keepOnBlur: !1,
      fontFamily: "default"
    };
    super(62, "inlineSuggest", e, {
      "editor.inlineSuggest.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("inlineSuggest.enabled", "Controls whether to automatically show inline suggestions in the editor.")
      },
      "editor.inlineSuggest.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          f("inlineSuggest.showToolbar.always", "Show the inline suggestion toolbar whenever an inline suggestion is shown."),
          f("inlineSuggest.showToolbar.onHover", "Show the inline suggestion toolbar when hovering over an inline suggestion."),
          f("inlineSuggest.showToolbar.never", "Never show the inline suggestion toolbar.")
        ],
        description: f("inlineSuggest.showToolbar", "Controls when to show the inline suggestion toolbar.")
      },
      "editor.inlineSuggest.suppressSuggestions": {
        type: "boolean",
        default: e.suppressSuggestions,
        description: f("inlineSuggest.suppressSuggestions", "Controls how inline suggestions interact with the suggest widget. If enabled, the suggest widget is not shown automatically when inline suggestions are available.")
      },
      "editor.inlineSuggest.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: f("inlineSuggest.fontFamily", "Controls the font family of the inline suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      mode: Gt(t.mode, this.defaultValue.mode, ["prefix", "subword", "subwordSmart"]),
      showToolbar: Gt(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      suppressSuggestions: ue(t.suppressSuggestions, this.defaultValue.suppressSuggestions),
      keepOnBlur: ue(t.keepOnBlur, this.defaultValue.keepOnBlur),
      fontFamily: wn.string(t.fontFamily, this.defaultValue.fontFamily)
    };
  }
}
class Sz extends Bt {
  constructor() {
    const e = {
      enabled: !1,
      showToolbar: "onHover",
      fontFamily: "default",
      keepOnBlur: !1
    };
    super(63, "experimentalInlineEdit", e, {
      "editor.experimentalInlineEdit.enabled": {
        type: "boolean",
        default: e.enabled,
        description: f("inlineEdit.enabled", "Controls whether to show inline edits in the editor.")
      },
      "editor.experimentalInlineEdit.showToolbar": {
        type: "string",
        default: e.showToolbar,
        enum: ["always", "onHover", "never"],
        enumDescriptions: [
          f("inlineEdit.showToolbar.always", "Show the inline edit toolbar whenever an inline suggestion is shown."),
          f("inlineEdit.showToolbar.onHover", "Show the inline edit toolbar when hovering over an inline suggestion."),
          f("inlineEdit.showToolbar.never", "Never show the inline edit toolbar.")
        ],
        description: f("inlineEdit.showToolbar", "Controls when to show the inline edit toolbar.")
      },
      "editor.experimentalInlineEdit.fontFamily": {
        type: "string",
        default: e.fontFamily,
        description: f("inlineEdit.fontFamily", "Controls the font family of the inline edit.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      showToolbar: Gt(t.showToolbar, this.defaultValue.showToolbar, ["always", "onHover", "never"]),
      fontFamily: wn.string(t.fontFamily, this.defaultValue.fontFamily),
      keepOnBlur: ue(t.keepOnBlur, this.defaultValue.keepOnBlur)
    };
  }
}
class yz extends Bt {
  constructor() {
    const e = {
      enabled: an.bracketPairColorizationOptions.enabled,
      independentColorPoolPerBracketType: an.bracketPairColorizationOptions.independentColorPoolPerBracketType
    };
    super(15, "bracketPairColorization", e, {
      "editor.bracketPairColorization.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: f("bracketPairColorization.enabled", "Controls whether bracket pair colorization is enabled or not. Use {0} to override the bracket highlight colors.", "`#workbench.colorCustomizations#`")
      },
      "editor.bracketPairColorization.independentColorPoolPerBracketType": {
        type: "boolean",
        default: e.independentColorPoolPerBracketType,
        description: f("bracketPairColorization.independentColorPoolPerBracketType", "Controls whether each bracket type has its own independent color pool.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      independentColorPoolPerBracketType: ue(t.independentColorPoolPerBracketType, this.defaultValue.independentColorPoolPerBracketType)
    };
  }
}
class xz extends Bt {
  constructor() {
    const e = {
      bracketPairs: !1,
      bracketPairsHorizontal: "active",
      highlightActiveBracketPair: !0,
      indentation: !0,
      highlightActiveIndentation: !0
    };
    super(16, "guides", e, {
      "editor.guides.bracketPairs": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          f("editor.guides.bracketPairs.true", "Enables bracket pair guides."),
          f("editor.guides.bracketPairs.active", "Enables bracket pair guides only for the active bracket pair."),
          f("editor.guides.bracketPairs.false", "Disables bracket pair guides.")
        ],
        default: e.bracketPairs,
        description: f("editor.guides.bracketPairs", "Controls whether bracket pair guides are enabled or not.")
      },
      "editor.guides.bracketPairsHorizontal": {
        type: ["boolean", "string"],
        enum: [!0, "active", !1],
        enumDescriptions: [
          f("editor.guides.bracketPairsHorizontal.true", "Enables horizontal guides as addition to vertical bracket pair guides."),
          f("editor.guides.bracketPairsHorizontal.active", "Enables horizontal guides only for the active bracket pair."),
          f("editor.guides.bracketPairsHorizontal.false", "Disables horizontal bracket pair guides.")
        ],
        default: e.bracketPairsHorizontal,
        description: f("editor.guides.bracketPairsHorizontal", "Controls whether horizontal bracket pair guides are enabled or not.")
      },
      "editor.guides.highlightActiveBracketPair": {
        type: "boolean",
        default: e.highlightActiveBracketPair,
        description: f("editor.guides.highlightActiveBracketPair", "Controls whether the editor should highlight the active bracket pair.")
      },
      "editor.guides.indentation": {
        type: "boolean",
        default: e.indentation,
        description: f("editor.guides.indentation", "Controls whether the editor should render indent guides.")
      },
      "editor.guides.highlightActiveIndentation": {
        type: ["boolean", "string"],
        enum: [!0, "always", !1],
        enumDescriptions: [
          f("editor.guides.highlightActiveIndentation.true", "Highlights the active indent guide."),
          f("editor.guides.highlightActiveIndentation.always", "Highlights the active indent guide even if bracket guides are highlighted."),
          f("editor.guides.highlightActiveIndentation.false", "Do not highlight the active indent guide.")
        ],
        default: e.highlightActiveIndentation,
        description: f("editor.guides.highlightActiveIndentation", "Controls whether the editor should highlight the active indent guide.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      bracketPairs: hf(t.bracketPairs, this.defaultValue.bracketPairs, [!0, !1, "active"]),
      bracketPairsHorizontal: hf(t.bracketPairsHorizontal, this.defaultValue.bracketPairsHorizontal, [!0, !1, "active"]),
      highlightActiveBracketPair: ue(t.highlightActiveBracketPair, this.defaultValue.highlightActiveBracketPair),
      indentation: ue(t.indentation, this.defaultValue.indentation),
      highlightActiveIndentation: hf(t.highlightActiveIndentation, this.defaultValue.highlightActiveIndentation, [!0, !1, "always"])
    };
  }
}
function hf(s, e, t) {
  const i = t.indexOf(s);
  return i === -1 ? e : t[i];
}
class Ez extends Bt {
  constructor() {
    const e = {
      insertMode: "insert",
      filterGraceful: !0,
      snippetsPreventQuickSuggestions: !1,
      localityBonus: !1,
      shareSuggestSelections: !1,
      selectionMode: "always",
      showIcons: !0,
      showStatusBar: !1,
      preview: !1,
      previewMode: "subwordSmart",
      showInlineDetails: !0,
      showMethods: !0,
      showFunctions: !0,
      showConstructors: !0,
      showDeprecated: !0,
      matchOnWordStartOnly: !0,
      showFields: !0,
      showVariables: !0,
      showClasses: !0,
      showStructs: !0,
      showInterfaces: !0,
      showModules: !0,
      showProperties: !0,
      showEvents: !0,
      showOperators: !0,
      showUnits: !0,
      showValues: !0,
      showConstants: !0,
      showEnums: !0,
      showEnumMembers: !0,
      showKeywords: !0,
      showWords: !0,
      showColors: !0,
      showFiles: !0,
      showReferences: !0,
      showFolders: !0,
      showTypeParameters: !0,
      showSnippets: !0,
      showUsers: !0,
      showIssues: !0
    };
    super(119, "suggest", e, {
      "editor.suggest.insertMode": {
        type: "string",
        enum: ["insert", "replace"],
        enumDescriptions: [
          f("suggest.insertMode.insert", "Insert suggestion without overwriting text right of the cursor."),
          f("suggest.insertMode.replace", "Insert suggestion and overwrite text right of the cursor.")
        ],
        default: e.insertMode,
        description: f("suggest.insertMode", "Controls whether words are overwritten when accepting completions. Note that this depends on extensions opting into this feature.")
      },
      "editor.suggest.filterGraceful": {
        type: "boolean",
        default: e.filterGraceful,
        description: f("suggest.filterGraceful", "Controls whether filtering and sorting suggestions accounts for small typos.")
      },
      "editor.suggest.localityBonus": {
        type: "boolean",
        default: e.localityBonus,
        description: f("suggest.localityBonus", "Controls whether sorting favors words that appear close to the cursor.")
      },
      "editor.suggest.shareSuggestSelections": {
        type: "boolean",
        default: e.shareSuggestSelections,
        markdownDescription: f("suggest.shareSuggestSelections", "Controls whether remembered suggestion selections are shared between multiple workspaces and windows (needs `#editor.suggestSelection#`).")
      },
      "editor.suggest.selectionMode": {
        type: "string",
        enum: ["always", "never", "whenTriggerCharacter", "whenQuickSuggestion"],
        enumDescriptions: [
          f("suggest.insertMode.always", "Always select a suggestion when automatically triggering IntelliSense."),
          f("suggest.insertMode.never", "Never select a suggestion when automatically triggering IntelliSense."),
          f("suggest.insertMode.whenTriggerCharacter", "Select a suggestion only when triggering IntelliSense from a trigger character."),
          f("suggest.insertMode.whenQuickSuggestion", "Select a suggestion only when triggering IntelliSense as you type.")
        ],
        default: e.selectionMode,
        markdownDescription: f("suggest.selectionMode", "Controls whether a suggestion is selected when the widget shows. Note that this only applies to automatically triggered suggestions ({0} and {1}) and that a suggestion is always selected when explicitly invoked, e.g via `Ctrl+Space`.", "`#editor.quickSuggestions#`", "`#editor.suggestOnTriggerCharacters#`")
      },
      "editor.suggest.snippetsPreventQuickSuggestions": {
        type: "boolean",
        default: e.snippetsPreventQuickSuggestions,
        description: f("suggest.snippetsPreventQuickSuggestions", "Controls whether an active snippet prevents quick suggestions.")
      },
      "editor.suggest.showIcons": {
        type: "boolean",
        default: e.showIcons,
        description: f("suggest.showIcons", "Controls whether to show or hide icons in suggestions.")
      },
      "editor.suggest.showStatusBar": {
        type: "boolean",
        default: e.showStatusBar,
        description: f("suggest.showStatusBar", "Controls the visibility of the status bar at the bottom of the suggest widget.")
      },
      "editor.suggest.preview": {
        type: "boolean",
        default: e.preview,
        description: f("suggest.preview", "Controls whether to preview the suggestion outcome in the editor.")
      },
      "editor.suggest.showInlineDetails": {
        type: "boolean",
        default: e.showInlineDetails,
        description: f("suggest.showInlineDetails", "Controls whether suggest details show inline with the label or only in the details widget.")
      },
      "editor.suggest.maxVisibleSuggestions": {
        type: "number",
        deprecationMessage: f("suggest.maxVisibleSuggestions.dep", "This setting is deprecated. The suggest widget can now be resized.")
      },
      "editor.suggest.filteredTypes": {
        type: "object",
        deprecationMessage: f("deprecated", "This setting is deprecated, please use separate settings like 'editor.suggest.showKeywords' or 'editor.suggest.showSnippets' instead.")
      },
      "editor.suggest.showMethods": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showMethods", "When enabled IntelliSense shows `method`-suggestions.")
      },
      "editor.suggest.showFunctions": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showFunctions", "When enabled IntelliSense shows `function`-suggestions.")
      },
      "editor.suggest.showConstructors": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showConstructors", "When enabled IntelliSense shows `constructor`-suggestions.")
      },
      "editor.suggest.showDeprecated": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showDeprecated", "When enabled IntelliSense shows `deprecated`-suggestions.")
      },
      "editor.suggest.matchOnWordStartOnly": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.matchOnWordStartOnly", "When enabled IntelliSense filtering requires that the first character matches on a word start. For example, `c` on `Console` or `WebContext` but _not_ on `description`. When disabled IntelliSense will show more results but still sorts them by match quality.")
      },
      "editor.suggest.showFields": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showFields", "When enabled IntelliSense shows `field`-suggestions.")
      },
      "editor.suggest.showVariables": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showVariables", "When enabled IntelliSense shows `variable`-suggestions.")
      },
      "editor.suggest.showClasses": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showClasss", "When enabled IntelliSense shows `class`-suggestions.")
      },
      "editor.suggest.showStructs": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showStructs", "When enabled IntelliSense shows `struct`-suggestions.")
      },
      "editor.suggest.showInterfaces": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showInterfaces", "When enabled IntelliSense shows `interface`-suggestions.")
      },
      "editor.suggest.showModules": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showModules", "When enabled IntelliSense shows `module`-suggestions.")
      },
      "editor.suggest.showProperties": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showPropertys", "When enabled IntelliSense shows `property`-suggestions.")
      },
      "editor.suggest.showEvents": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showEvents", "When enabled IntelliSense shows `event`-suggestions.")
      },
      "editor.suggest.showOperators": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showOperators", "When enabled IntelliSense shows `operator`-suggestions.")
      },
      "editor.suggest.showUnits": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showUnits", "When enabled IntelliSense shows `unit`-suggestions.")
      },
      "editor.suggest.showValues": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showValues", "When enabled IntelliSense shows `value`-suggestions.")
      },
      "editor.suggest.showConstants": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showConstants", "When enabled IntelliSense shows `constant`-suggestions.")
      },
      "editor.suggest.showEnums": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showEnums", "When enabled IntelliSense shows `enum`-suggestions.")
      },
      "editor.suggest.showEnumMembers": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showEnumMembers", "When enabled IntelliSense shows `enumMember`-suggestions.")
      },
      "editor.suggest.showKeywords": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showKeywords", "When enabled IntelliSense shows `keyword`-suggestions.")
      },
      "editor.suggest.showWords": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showTexts", "When enabled IntelliSense shows `text`-suggestions.")
      },
      "editor.suggest.showColors": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showColors", "When enabled IntelliSense shows `color`-suggestions.")
      },
      "editor.suggest.showFiles": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showFiles", "When enabled IntelliSense shows `file`-suggestions.")
      },
      "editor.suggest.showReferences": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showReferences", "When enabled IntelliSense shows `reference`-suggestions.")
      },
      "editor.suggest.showCustomcolors": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showCustomcolors", "When enabled IntelliSense shows `customcolor`-suggestions.")
      },
      "editor.suggest.showFolders": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showFolders", "When enabled IntelliSense shows `folder`-suggestions.")
      },
      "editor.suggest.showTypeParameters": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showTypeParameters", "When enabled IntelliSense shows `typeParameter`-suggestions.")
      },
      "editor.suggest.showSnippets": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showSnippets", "When enabled IntelliSense shows `snippet`-suggestions.")
      },
      "editor.suggest.showUsers": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showUsers", "When enabled IntelliSense shows `user`-suggestions.")
      },
      "editor.suggest.showIssues": {
        type: "boolean",
        default: !0,
        markdownDescription: f("editor.suggest.showIssues", "When enabled IntelliSense shows `issues`-suggestions.")
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      insertMode: Gt(t.insertMode, this.defaultValue.insertMode, ["insert", "replace"]),
      filterGraceful: ue(t.filterGraceful, this.defaultValue.filterGraceful),
      snippetsPreventQuickSuggestions: ue(t.snippetsPreventQuickSuggestions, this.defaultValue.filterGraceful),
      localityBonus: ue(t.localityBonus, this.defaultValue.localityBonus),
      shareSuggestSelections: ue(t.shareSuggestSelections, this.defaultValue.shareSuggestSelections),
      selectionMode: Gt(t.selectionMode, this.defaultValue.selectionMode, ["always", "never", "whenQuickSuggestion", "whenTriggerCharacter"]),
      showIcons: ue(t.showIcons, this.defaultValue.showIcons),
      showStatusBar: ue(t.showStatusBar, this.defaultValue.showStatusBar),
      preview: ue(t.preview, this.defaultValue.preview),
      previewMode: Gt(t.previewMode, this.defaultValue.previewMode, ["prefix", "subword", "subwordSmart"]),
      showInlineDetails: ue(t.showInlineDetails, this.defaultValue.showInlineDetails),
      showMethods: ue(t.showMethods, this.defaultValue.showMethods),
      showFunctions: ue(t.showFunctions, this.defaultValue.showFunctions),
      showConstructors: ue(t.showConstructors, this.defaultValue.showConstructors),
      showDeprecated: ue(t.showDeprecated, this.defaultValue.showDeprecated),
      matchOnWordStartOnly: ue(t.matchOnWordStartOnly, this.defaultValue.matchOnWordStartOnly),
      showFields: ue(t.showFields, this.defaultValue.showFields),
      showVariables: ue(t.showVariables, this.defaultValue.showVariables),
      showClasses: ue(t.showClasses, this.defaultValue.showClasses),
      showStructs: ue(t.showStructs, this.defaultValue.showStructs),
      showInterfaces: ue(t.showInterfaces, this.defaultValue.showInterfaces),
      showModules: ue(t.showModules, this.defaultValue.showModules),
      showProperties: ue(t.showProperties, this.defaultValue.showProperties),
      showEvents: ue(t.showEvents, this.defaultValue.showEvents),
      showOperators: ue(t.showOperators, this.defaultValue.showOperators),
      showUnits: ue(t.showUnits, this.defaultValue.showUnits),
      showValues: ue(t.showValues, this.defaultValue.showValues),
      showConstants: ue(t.showConstants, this.defaultValue.showConstants),
      showEnums: ue(t.showEnums, this.defaultValue.showEnums),
      showEnumMembers: ue(t.showEnumMembers, this.defaultValue.showEnumMembers),
      showKeywords: ue(t.showKeywords, this.defaultValue.showKeywords),
      showWords: ue(t.showWords, this.defaultValue.showWords),
      showColors: ue(t.showColors, this.defaultValue.showColors),
      showFiles: ue(t.showFiles, this.defaultValue.showFiles),
      showReferences: ue(t.showReferences, this.defaultValue.showReferences),
      showFolders: ue(t.showFolders, this.defaultValue.showFolders),
      showTypeParameters: ue(t.showTypeParameters, this.defaultValue.showTypeParameters),
      showSnippets: ue(t.showSnippets, this.defaultValue.showSnippets),
      showUsers: ue(t.showUsers, this.defaultValue.showUsers),
      showIssues: ue(t.showIssues, this.defaultValue.showIssues)
    };
  }
}
class Lz extends Bt {
  constructor() {
    super(114, "smartSelect", {
      selectLeadingAndTrailingWhitespace: !0,
      selectSubwords: !0
    }, {
      "editor.smartSelect.selectLeadingAndTrailingWhitespace": {
        description: f("selectLeadingAndTrailingWhitespace", "Whether leading and trailing whitespace should always be selected."),
        default: !0,
        type: "boolean"
      },
      "editor.smartSelect.selectSubwords": {
        description: f("selectSubwords", "Whether subwords (like 'foo' in 'fooBar' or 'foo_bar') should be selected."),
        default: !0,
        type: "boolean"
      }
    });
  }
  validate(e) {
    return !e || typeof e != "object" ? this.defaultValue : {
      selectLeadingAndTrailingWhitespace: ue(e.selectLeadingAndTrailingWhitespace, this.defaultValue.selectLeadingAndTrailingWhitespace),
      selectSubwords: ue(e.selectSubwords, this.defaultValue.selectSubwords)
    };
  }
}
class kz extends Bt {
  constructor() {
    const e = [];
    super(131, "wordSegmenterLocales", e, {
      anyOf: [
        {
          description: f("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "string"
        },
        {
          description: f("wordSegmenterLocales", "Locales to be used for word segmentation when doing word related navigations or operations. Specify the BCP 47 language tag of the word you wish to recognize (e.g., ja, zh-CN, zh-Hant-TW, etc.)."),
          type: "array",
          items: {
            type: "string"
          }
        }
      ]
    });
  }
  validate(e) {
    if (typeof e == "string" && (e = [e]), Array.isArray(e)) {
      const t = [];
      for (const i of e)
        if (typeof i == "string")
          try {
            Intl.Segmenter.supportedLocalesOf(i).length > 0 && t.push(i);
          } catch {
          }
      return t;
    }
    return this.defaultValue;
  }
}
class Dz extends Bt {
  constructor() {
    super(139, "wrappingIndent", 1, {
      "editor.wrappingIndent": {
        type: "string",
        enum: ["none", "same", "indent", "deepIndent"],
        enumDescriptions: [
          f("wrappingIndent.none", "No indentation. Wrapped lines begin at column 1."),
          f("wrappingIndent.same", "Wrapped lines get the same indentation as the parent."),
          f("wrappingIndent.indent", "Wrapped lines get +1 indentation toward the parent."),
          f("wrappingIndent.deepIndent", "Wrapped lines get +2 indentation toward the parent.")
        ],
        description: f("wrappingIndent", "Controls the indentation of wrapped lines."),
        default: "same"
      }
    });
  }
  validate(e) {
    switch (e) {
      case "none":
        return 0;
      case "same":
        return 1;
      case "indent":
        return 2;
      case "deepIndent":
        return 3;
    }
    return 1;
  }
  compute(e, t, i) {
    return t.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2 ? 0 : i;
  }
}
class Iz extends L_ {
  constructor() {
    super(
      147
      /* EditorOption.wrappingInfo */
    );
  }
  compute(e, t, i) {
    const n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return {
      isDominatedByLongLines: e.isDominatedByLongLines,
      isWordWrapMinified: n.isWordWrapMinified,
      isViewportWrapping: n.isViewportWrapping,
      wrappingColumn: n.wrappingColumn
    };
  }
}
class Mz extends Bt {
  constructor() {
    const e = { enabled: !0, showDropSelector: "afterDrop" };
    super(36, "dropIntoEditor", e, {
      "editor.dropIntoEditor.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: f("dropIntoEditor.enabled", "Controls whether you can drag and drop a file into a text editor by holding down the `Shift` key (instead of opening the file in an editor).")
      },
      "editor.dropIntoEditor.showDropSelector": {
        type: "string",
        markdownDescription: f("dropIntoEditor.showDropSelector", "Controls if a widget is shown when dropping files into the editor. This widget lets you control how the file is dropped."),
        enum: [
          "afterDrop",
          "never"
        ],
        enumDescriptions: [
          f("dropIntoEditor.showDropSelector.afterDrop", "Show the drop selector widget after a file is dropped into the editor."),
          f("dropIntoEditor.showDropSelector.never", "Never show the drop selector widget. Instead the default drop provider is always used.")
        ],
        default: "afterDrop"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      showDropSelector: Gt(t.showDropSelector, this.defaultValue.showDropSelector, ["afterDrop", "never"])
    };
  }
}
class Nz extends Bt {
  constructor() {
    const e = { enabled: !0, showPasteSelector: "afterPaste" };
    super(85, "pasteAs", e, {
      "editor.pasteAs.enabled": {
        type: "boolean",
        default: e.enabled,
        markdownDescription: f("pasteAs.enabled", "Controls whether you can paste content in different ways.")
      },
      "editor.pasteAs.showPasteSelector": {
        type: "string",
        markdownDescription: f("pasteAs.showPasteSelector", "Controls if a widget is shown when pasting content in to the editor. This widget lets you control how the file is pasted."),
        enum: [
          "afterPaste",
          "never"
        ],
        enumDescriptions: [
          f("pasteAs.showPasteSelector.afterPaste", "Show the paste selector widget after content is pasted into the editor."),
          f("pasteAs.showPasteSelector.never", "Never show the paste selector widget. Instead the default pasting behavior is always used.")
        ],
        default: "afterPaste"
      }
    });
  }
  validate(e) {
    if (!e || typeof e != "object")
      return this.defaultValue;
    const t = e;
    return {
      enabled: ue(t.enabled, this.defaultValue.enabled),
      showPasteSelector: Gt(t.showPasteSelector, this.defaultValue.showPasteSelector, ["afterPaste", "never"])
    };
  }
}
const Tz = "Consolas, 'Courier New', monospace", Bz = "Menlo, Monaco, 'Courier New', monospace", Rz = "'Droid Sans Mono', 'monospace', monospace", Zn = {
  fontFamily: ze ? Bz : Fn ? Rz : Tz,
  fontWeight: "normal",
  fontSize: ze ? 12 : 14,
  lineHeight: 0,
  letterSpacing: 0
}, Dg = [];
function $(s) {
  return Dg[s.id] = s, s;
}
const Hr = {
  acceptSuggestionOnCommitCharacter: $(new Ze(0, "acceptSuggestionOnCommitCharacter", !0, { markdownDescription: f("acceptSuggestionOnCommitCharacter", "Controls whether suggestions should be accepted on commit characters. For example, in JavaScript, the semi-colon (`;`) can be a commit character that accepts a suggestion and types that character.") })),
  acceptSuggestionOnEnter: $(new Qt(1, "acceptSuggestionOnEnter", "on", ["on", "smart", "off"], {
    markdownEnumDescriptions: [
      "",
      f("acceptSuggestionOnEnterSmart", "Only accept a suggestion with `Enter` when it makes a textual change."),
      ""
    ],
    markdownDescription: f("acceptSuggestionOnEnter", "Controls whether suggestions should be accepted on `Enter`, in addition to `Tab`. Helps to avoid ambiguity between inserting new lines or accepting suggestions.")
  })),
  accessibilitySupport: $(new Y9()),
  accessibilityPageSize: $(new _t(3, "accessibilityPageSize", 10, 1, 1073741824, {
    description: f("accessibilityPageSize", "Controls the number of lines in the editor that can be read out by a screen reader at once. When we detect a screen reader we automatically set the default to be 500. Warning: this has a performance implication for numbers larger than the default."),
    tags: ["accessibility"]
  })),
  ariaLabel: $(new wn(4, "ariaLabel", f("editorViewAccessibleLabel", "Editor content"))),
  ariaRequired: $(new Ze(5, "ariaRequired", !1, void 0)),
  screenReaderAnnounceInlineSuggestion: $(new Ze(8, "screenReaderAnnounceInlineSuggestion", !0, {
    description: f("screenReaderAnnounceInlineSuggestion", "Control whether inline suggestions are announced by a screen reader."),
    tags: ["accessibility"]
  })),
  autoClosingBrackets: $(new Qt(6, "autoClosingBrackets", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      f("editor.autoClosingBrackets.languageDefined", "Use language configurations to determine when to autoclose brackets."),
      f("editor.autoClosingBrackets.beforeWhitespace", "Autoclose brackets only when the cursor is to the left of whitespace."),
      ""
    ],
    description: f("autoClosingBrackets", "Controls whether the editor should automatically close brackets after the user adds an opening bracket.")
  })),
  autoClosingComments: $(new Qt(7, "autoClosingComments", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      f("editor.autoClosingComments.languageDefined", "Use language configurations to determine when to autoclose comments."),
      f("editor.autoClosingComments.beforeWhitespace", "Autoclose comments only when the cursor is to the left of whitespace."),
      ""
    ],
    description: f("autoClosingComments", "Controls whether the editor should automatically close comments after the user adds an opening comment.")
  })),
  autoClosingDelete: $(new Qt(9, "autoClosingDelete", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      f("editor.autoClosingDelete.auto", "Remove adjacent closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: f("autoClosingDelete", "Controls whether the editor should remove adjacent closing quotes or brackets when deleting.")
  })),
  autoClosingOvertype: $(new Qt(10, "autoClosingOvertype", "auto", ["always", "auto", "never"], {
    enumDescriptions: [
      "",
      f("editor.autoClosingOvertype.auto", "Type over closing quotes or brackets only if they were automatically inserted."),
      ""
    ],
    description: f("autoClosingOvertype", "Controls whether the editor should type over closing quotes or brackets.")
  })),
  autoClosingQuotes: $(new Qt(11, "autoClosingQuotes", "languageDefined", ["always", "languageDefined", "beforeWhitespace", "never"], {
    enumDescriptions: [
      "",
      f("editor.autoClosingQuotes.languageDefined", "Use language configurations to determine when to autoclose quotes."),
      f("editor.autoClosingQuotes.beforeWhitespace", "Autoclose quotes only when the cursor is to the left of whitespace."),
      ""
    ],
    description: f("autoClosingQuotes", "Controls whether the editor should automatically close quotes after the user adds an opening quote.")
  })),
  autoIndent: $(new rb(12, "autoIndent", 4, "full", ["none", "keep", "brackets", "advanced", "full"], j9, {
    enumDescriptions: [
      f("editor.autoIndent.none", "The editor will not insert indentation automatically."),
      f("editor.autoIndent.keep", "The editor will keep the current line's indentation."),
      f("editor.autoIndent.brackets", "The editor will keep the current line's indentation and honor language defined brackets."),
      f("editor.autoIndent.advanced", "The editor will keep the current line's indentation, honor language defined brackets and invoke special onEnterRules defined by languages."),
      f("editor.autoIndent.full", "The editor will keep the current line's indentation, honor language defined brackets, invoke special onEnterRules defined by languages, and honor indentationRules defined by languages.")
    ],
    description: f("autoIndent", "Controls whether the editor should automatically adjust the indentation when users type, paste, move or indent lines.")
  })),
  automaticLayout: $(new Ze(13, "automaticLayout", !1)),
  autoSurround: $(new Qt(14, "autoSurround", "languageDefined", ["languageDefined", "quotes", "brackets", "never"], {
    enumDescriptions: [
      f("editor.autoSurround.languageDefined", "Use language configurations to determine when to automatically surround selections."),
      f("editor.autoSurround.quotes", "Surround with quotes but not brackets."),
      f("editor.autoSurround.brackets", "Surround with brackets but not quotes."),
      ""
    ],
    description: f("autoSurround", "Controls whether the editor should automatically surround selections when typing quotes or brackets.")
  })),
  bracketPairColorization: $(new yz()),
  bracketPairGuides: $(new xz()),
  stickyTabStops: $(new Ze(117, "stickyTabStops", !1, { description: f("stickyTabStops", "Emulate selection behavior of tab characters when using spaces for indentation. Selection will stick to tab stops.") })),
  codeLens: $(new Ze(17, "codeLens", !0, { description: f("codeLens", "Controls whether the editor shows CodeLens.") })),
  codeLensFontFamily: $(new wn(18, "codeLensFontFamily", "", { description: f("codeLensFontFamily", "Controls the font family for CodeLens.") })),
  codeLensFontSize: $(new _t(19, "codeLensFontSize", 0, 0, 100, {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 100,
    markdownDescription: f("codeLensFontSize", "Controls the font size in pixels for CodeLens. When set to 0, 90% of `#editor.fontSize#` is used.")
  })),
  colorDecorators: $(new Ze(20, "colorDecorators", !0, { description: f("colorDecorators", "Controls whether the editor should render the inline color decorators and color picker.") })),
  colorDecoratorActivatedOn: $(new Qt(149, "colorDecoratorsActivatedOn", "clickAndHover", ["clickAndHover", "hover", "click"], {
    enumDescriptions: [
      f("editor.colorDecoratorActivatedOn.clickAndHover", "Make the color picker appear both on click and hover of the color decorator"),
      f("editor.colorDecoratorActivatedOn.hover", "Make the color picker appear on hover of the color decorator"),
      f("editor.colorDecoratorActivatedOn.click", "Make the color picker appear on click of the color decorator")
    ],
    description: f("colorDecoratorActivatedOn", "Controls the condition to make a color picker appear from a color decorator")
  })),
  colorDecoratorsLimit: $(new _t(21, "colorDecoratorsLimit", 500, 1, 1e6, {
    markdownDescription: f("colorDecoratorsLimit", "Controls the max number of color decorators that can be rendered in an editor at once.")
  })),
  columnSelection: $(new Ze(22, "columnSelection", !1, { description: f("columnSelection", "Enable that the selection with the mouse and keys is doing column selection.") })),
  comments: $(new K9()),
  contextmenu: $(new Ze(24, "contextmenu", !0)),
  copyWithSyntaxHighlighting: $(new Ze(25, "copyWithSyntaxHighlighting", !0, { description: f("copyWithSyntaxHighlighting", "Controls whether syntax highlighting should be copied into the clipboard.") })),
  cursorBlinking: $(new rb(26, "cursorBlinking", 1, "blink", ["blink", "smooth", "phase", "expand", "solid"], J9, { description: f("cursorBlinking", "Control the cursor animation style.") })),
  cursorSmoothCaretAnimation: $(new Qt(27, "cursorSmoothCaretAnimation", "off", ["off", "explicit", "on"], {
    enumDescriptions: [
      f("cursorSmoothCaretAnimation.off", "Smooth caret animation is disabled."),
      f("cursorSmoothCaretAnimation.explicit", "Smooth caret animation is enabled only when the user moves the cursor with an explicit gesture."),
      f("cursorSmoothCaretAnimation.on", "Smooth caret animation is always enabled.")
    ],
    description: f("cursorSmoothCaretAnimation", "Controls whether the smooth caret animation should be enabled.")
  })),
  cursorStyle: $(new rb(28, "cursorStyle", zi.Line, "line", ["line", "block", "underline", "line-thin", "block-outline", "underline-thin"], q9, { description: f("cursorStyle", "Controls the cursor style.") })),
  cursorSurroundingLines: $(new _t(29, "cursorSurroundingLines", 0, 0, 1073741824, { description: f("cursorSurroundingLines", "Controls the minimal number of visible leading lines (minimum 0) and trailing lines (minimum 1) surrounding the cursor. Known as 'scrollOff' or 'scrollOffset' in some other editors.") })),
  cursorSurroundingLinesStyle: $(new Qt(30, "cursorSurroundingLinesStyle", "default", ["default", "all"], {
    enumDescriptions: [
      f("cursorSurroundingLinesStyle.default", "`cursorSurroundingLines` is enforced only when triggered via the keyboard or API."),
      f("cursorSurroundingLinesStyle.all", "`cursorSurroundingLines` is enforced always.")
    ],
    markdownDescription: f("cursorSurroundingLinesStyle", "Controls when `#editor.cursorSurroundingLines#` should be enforced.")
  })),
  cursorWidth: $(new _t(31, "cursorWidth", 0, 0, 1073741824, { markdownDescription: f("cursorWidth", "Controls the width of the cursor when `#editor.cursorStyle#` is set to `line`.") })),
  disableLayerHinting: $(new Ze(32, "disableLayerHinting", !1)),
  disableMonospaceOptimizations: $(new Ze(33, "disableMonospaceOptimizations", !1)),
  domReadOnly: $(new Ze(34, "domReadOnly", !1)),
  dragAndDrop: $(new Ze(35, "dragAndDrop", !0, { description: f("dragAndDrop", "Controls whether the editor should allow moving selections via drag and drop.") })),
  emptySelectionClipboard: $(new X9()),
  dropIntoEditor: $(new Mz()),
  stickyScroll: $(new rz()),
  experimentalWhitespaceRendering: $(new Qt(38, "experimentalWhitespaceRendering", "svg", ["svg", "font", "off"], {
    enumDescriptions: [
      f("experimentalWhitespaceRendering.svg", "Use a new rendering method with svgs."),
      f("experimentalWhitespaceRendering.font", "Use a new rendering method with font characters."),
      f("experimentalWhitespaceRendering.off", "Use the stable rendering method.")
    ],
    description: f("experimentalWhitespaceRendering", "Controls whether whitespace is rendered with a new, experimental method.")
  })),
  extraEditorClassName: $(new wn(39, "extraEditorClassName", "")),
  fastScrollSensitivity: $(new Qs(40, "fastScrollSensitivity", 5, (s) => s <= 0 ? 5 : s, { markdownDescription: f("fastScrollSensitivity", "Scrolling speed multiplier when pressing `Alt`.") })),
  find: $(new Z9()),
  fixedOverflowWidgets: $(new Ze(42, "fixedOverflowWidgets", !1)),
  folding: $(new Ze(43, "folding", !0, { description: f("folding", "Controls whether the editor has code folding enabled.") })),
  foldingStrategy: $(new Qt(44, "foldingStrategy", "auto", ["auto", "indentation"], {
    enumDescriptions: [
      f("foldingStrategy.auto", "Use a language-specific folding strategy if available, else the indentation-based one."),
      f("foldingStrategy.indentation", "Use the indentation-based folding strategy.")
    ],
    description: f("foldingStrategy", "Controls the strategy for computing folding ranges.")
  })),
  foldingHighlight: $(new Ze(45, "foldingHighlight", !0, { description: f("foldingHighlight", "Controls whether the editor should highlight folded ranges.") })),
  foldingImportsByDefault: $(new Ze(46, "foldingImportsByDefault", !1, { description: f("foldingImportsByDefault", "Controls whether the editor automatically collapses import ranges.") })),
  foldingMaximumRegions: $(new _t(
    47,
    "foldingMaximumRegions",
    5e3,
    10,
    65e3,
    // limit must be less than foldingRanges MAX_FOLDING_REGIONS
    { description: f("foldingMaximumRegions", "The maximum number of foldable regions. Increasing this value may result in the editor becoming less responsive when the current source has a large number of foldable regions.") }
  )),
  unfoldOnClickAfterEndOfLine: $(new Ze(48, "unfoldOnClickAfterEndOfLine", !1, { description: f("unfoldOnClickAfterEndOfLine", "Controls whether clicking on the empty content after a folded line will unfold the line.") })),
  fontFamily: $(new wn(49, "fontFamily", Zn.fontFamily, { description: f("fontFamily", "Controls the font family.") })),
  fontInfo: $(new ez()),
  fontLigatures2: $(new hu()),
  fontSize: $(new tz()),
  fontWeight: $(new Ex()),
  fontVariations: $(new yA()),
  formatOnPaste: $(new Ze(55, "formatOnPaste", !1, { description: f("formatOnPaste", "Controls whether the editor should automatically format the pasted content. A formatter must be available and the formatter should be able to format a range in a document.") })),
  formatOnType: $(new Ze(56, "formatOnType", !1, { description: f("formatOnType", "Controls whether the editor should automatically format the line after typing.") })),
  glyphMargin: $(new Ze(57, "glyphMargin", !0, { description: f("glyphMargin", "Controls whether the editor should render the vertical glyph margin. Glyph margin is mostly used for debugging.") })),
  gotoLocation: $(new iz()),
  hideCursorInOverviewRuler: $(new Ze(59, "hideCursorInOverviewRuler", !1, { description: f("hideCursorInOverviewRuler", "Controls whether the cursor should be hidden in the overview ruler.") })),
  hover: $(new nz()),
  inDiffEditor: $(new Ze(61, "inDiffEditor", !1)),
  letterSpacing: $(new Qs(64, "letterSpacing", Zn.letterSpacing, (s) => Qs.clamp(s, -5, 20), { description: f("letterSpacing", "Controls the letter spacing in pixels.") })),
  lightbulb: $(new oz()),
  lineDecorationsWidth: $(new lz()),
  lineHeight: $(new cz()),
  lineNumbers: $(new Az()),
  lineNumbersMinChars: $(new _t(69, "lineNumbersMinChars", 5, 1, 300)),
  linkedEditing: $(new Ze(70, "linkedEditing", !1, { description: f("linkedEditing", "Controls whether the editor has linked editing enabled. Depending on the language, related symbols such as HTML tags, are updated while editing.") })),
  links: $(new Ze(71, "links", !0, { description: f("links", "Controls whether the editor should detect links and make them clickable.") })),
  matchBrackets: $(new Qt(72, "matchBrackets", "always", ["always", "near", "never"], { description: f("matchBrackets", "Highlight matching brackets.") })),
  minimap: $(new dz()),
  mouseStyle: $(new Qt(74, "mouseStyle", "text", ["text", "default", "copy"])),
  mouseWheelScrollSensitivity: $(new Qs(75, "mouseWheelScrollSensitivity", 1, (s) => s === 0 ? 1 : s, { markdownDescription: f("mouseWheelScrollSensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.") })),
  mouseWheelZoom: $(new Ze(76, "mouseWheelZoom", !1, {
    markdownDescription: ze ? f("mouseWheelZoom.mac", "Zoom the font of the editor when using mouse wheel and holding `Cmd`.") : f("mouseWheelZoom", "Zoom the font of the editor when using mouse wheel and holding `Ctrl`.")
  })),
  multiCursorMergeOverlapping: $(new Ze(77, "multiCursorMergeOverlapping", !0, { description: f("multiCursorMergeOverlapping", "Merge multiple cursors when they are overlapping.") })),
  multiCursorModifier: $(new rb(78, "multiCursorModifier", "altKey", "alt", ["ctrlCmd", "alt"], hz, {
    markdownEnumDescriptions: [
      f("multiCursorModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
      f("multiCursorModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
    ],
    markdownDescription: f({
      key: "multiCursorModifier",
      comment: [
        "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
        "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
      ]
    }, "The modifier to be used to add multiple cursors with the mouse. The Go to Definition and Open Link mouse gestures will adapt such that they do not conflict with the [multicursor modifier](https://code.visualstudio.com/docs/editor/codebasics#_multicursor-modifier).")
  })),
  multiCursorPaste: $(new Qt(79, "multiCursorPaste", "spread", ["spread", "full"], {
    markdownEnumDescriptions: [
      f("multiCursorPaste.spread", "Each cursor pastes a single line of the text."),
      f("multiCursorPaste.full", "Each cursor pastes the full text.")
    ],
    markdownDescription: f("multiCursorPaste", "Controls pasting when the line count of the pasted text matches the cursor count.")
  })),
  multiCursorLimit: $(new _t(80, "multiCursorLimit", 1e4, 1, 1e5, {
    markdownDescription: f("multiCursorLimit", "Controls the max number of cursors that can be in an active editor at once.")
  })),
  occurrencesHighlight: $(new Qt(81, "occurrencesHighlight", "singleFile", ["off", "singleFile", "multiFile"], {
    markdownEnumDescriptions: [
      f("occurrencesHighlight.off", "Does not highlight occurrences."),
      f("occurrencesHighlight.singleFile", "Highlights occurrences only in the current file."),
      f("occurrencesHighlight.multiFile", "Experimental: Highlights occurrences across all valid open files.")
    ],
    markdownDescription: f("occurrencesHighlight", "Controls whether occurrences should be highlighted across open files.")
  })),
  overviewRulerBorder: $(new Ze(82, "overviewRulerBorder", !0, { description: f("overviewRulerBorder", "Controls whether a border should be drawn around the overview ruler.") })),
  overviewRulerLanes: $(new _t(83, "overviewRulerLanes", 3, 0, 3)),
  padding: $(new uz()),
  pasteAs: $(new Nz()),
  parameterHints: $(new gz()),
  peekWidgetDefaultFocus: $(new Qt(87, "peekWidgetDefaultFocus", "tree", ["tree", "editor"], {
    enumDescriptions: [
      f("peekWidgetDefaultFocus.tree", "Focus the tree when opening peek"),
      f("peekWidgetDefaultFocus.editor", "Focus the editor when opening peek")
    ],
    description: f("peekWidgetDefaultFocus", "Controls whether to focus the inline editor or the tree in the peek widget.")
  })),
  placeholder: $(new mz()),
  definitionLinkOpensInPeek: $(new Ze(89, "definitionLinkOpensInPeek", !1, { description: f("definitionLinkOpensInPeek", "Controls whether the Go to Definition mouse gesture always opens the peek widget.") })),
  quickSuggestions: $(new pz()),
  quickSuggestionsDelay: $(new _t(91, "quickSuggestionsDelay", 10, 0, 1073741824, { description: f("quickSuggestionsDelay", "Controls the delay in milliseconds after which quick suggestions will show up.") })),
  readOnly: $(new Ze(92, "readOnly", !1)),
  readOnlyMessage: $(new bz()),
  renameOnType: $(new Ze(94, "renameOnType", !1, { description: f("renameOnType", "Controls whether the editor auto renames on type."), markdownDeprecationMessage: f("renameOnTypeDeprecate", "Deprecated, use `editor.linkedEditing` instead.") })),
  renderControlCharacters: $(new Ze(95, "renderControlCharacters", !0, { description: f("renderControlCharacters", "Controls whether the editor should render control characters."), restricted: !0 })),
  renderFinalNewline: $(new Qt(96, "renderFinalNewline", Fn ? "dimmed" : "on", ["off", "on", "dimmed"], { description: f("renderFinalNewline", "Render last line number when the file ends with a newline.") })),
  renderLineHighlight: $(new Qt(97, "renderLineHighlight", "line", ["none", "gutter", "line", "all"], {
    enumDescriptions: [
      "",
      "",
      "",
      f("renderLineHighlight.all", "Highlights both the gutter and the current line.")
    ],
    description: f("renderLineHighlight", "Controls how the editor should render the current line highlight.")
  })),
  renderLineHighlightOnlyWhenFocus: $(new Ze(98, "renderLineHighlightOnlyWhenFocus", !1, { description: f("renderLineHighlightOnlyWhenFocus", "Controls if the editor should render the current line highlight only when the editor is focused.") })),
  renderValidationDecorations: $(new Qt(99, "renderValidationDecorations", "editable", ["editable", "on", "off"])),
  renderWhitespace: $(new Qt(100, "renderWhitespace", "selection", ["none", "boundary", "selection", "trailing", "all"], {
    enumDescriptions: [
      "",
      f("renderWhitespace.boundary", "Render whitespace characters except for single spaces between words."),
      f("renderWhitespace.selection", "Render whitespace characters only on selected text."),
      f("renderWhitespace.trailing", "Render only trailing whitespace characters."),
      ""
    ],
    description: f("renderWhitespace", "Controls how the editor should render whitespace characters.")
  })),
  revealHorizontalRightPadding: $(new _t(101, "revealHorizontalRightPadding", 15, 0, 1e3)),
  roundedSelection: $(new Ze(102, "roundedSelection", !0, { description: f("roundedSelection", "Controls whether selections should have rounded corners.") })),
  rulers: $(new _z()),
  scrollbar: $(new wz()),
  scrollBeyondLastColumn: $(new _t(105, "scrollBeyondLastColumn", 4, 0, 1073741824, { description: f("scrollBeyondLastColumn", "Controls the number of extra characters beyond which the editor will scroll horizontally.") })),
  scrollBeyondLastLine: $(new Ze(106, "scrollBeyondLastLine", !0, { description: f("scrollBeyondLastLine", "Controls whether the editor will scroll beyond the last line.") })),
  scrollPredominantAxis: $(new Ze(107, "scrollPredominantAxis", !0, { description: f("scrollPredominantAxis", "Scroll only along the predominant axis when scrolling both vertically and horizontally at the same time. Prevents horizontal drift when scrolling vertically on a trackpad.") })),
  selectionClipboard: $(new Ze(108, "selectionClipboard", !0, {
    description: f("selectionClipboard", "Controls whether the Linux primary clipboard should be supported."),
    included: Fn
  })),
  selectionHighlight: $(new Ze(109, "selectionHighlight", !0, { description: f("selectionHighlight", "Controls whether the editor should highlight matches similar to the selection.") })),
  selectOnLineNumbers: $(new Ze(110, "selectOnLineNumbers", !0)),
  showFoldingControls: $(new Qt(111, "showFoldingControls", "mouseover", ["always", "never", "mouseover"], {
    enumDescriptions: [
      f("showFoldingControls.always", "Always show the folding controls."),
      f("showFoldingControls.never", "Never show the folding controls and reduce the gutter size."),
      f("showFoldingControls.mouseover", "Only show the folding controls when the mouse is over the gutter.")
    ],
    description: f("showFoldingControls", "Controls when the folding controls on the gutter are shown.")
  })),
  showUnused: $(new Ze(112, "showUnused", !0, { description: f("showUnused", "Controls fading out of unused code.") })),
  showDeprecated: $(new Ze(141, "showDeprecated", !0, { description: f("showDeprecated", "Controls strikethrough deprecated variables.") })),
  inlayHints: $(new az()),
  snippetSuggestions: $(new Qt(113, "snippetSuggestions", "inline", ["top", "bottom", "inline", "none"], {
    enumDescriptions: [
      f("snippetSuggestions.top", "Show snippet suggestions on top of other suggestions."),
      f("snippetSuggestions.bottom", "Show snippet suggestions below other suggestions."),
      f("snippetSuggestions.inline", "Show snippets suggestions with other suggestions."),
      f("snippetSuggestions.none", "Do not show snippet suggestions.")
    ],
    description: f("snippetSuggestions", "Controls whether snippets are shown with other suggestions and how they are sorted.")
  })),
  smartSelect: $(new Lz()),
  smoothScrolling: $(new Ze(115, "smoothScrolling", !1, { description: f("smoothScrolling", "Controls whether the editor will scroll using an animation.") })),
  stopRenderingLineAfter: $(new _t(
    118,
    "stopRenderingLineAfter",
    1e4,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  suggest: $(new Ez()),
  inlineSuggest: $(new vz()),
  inlineEdit: $(new Sz()),
  inlineCompletionsAccessibilityVerbose: $(new Ze(150, "inlineCompletionsAccessibilityVerbose", !1, { description: f("inlineCompletionsAccessibilityVerbose", "Controls whether the accessibility hint should be provided to screen reader users when an inline completion is shown.") })),
  suggestFontSize: $(new _t(120, "suggestFontSize", 0, 0, 1e3, { markdownDescription: f("suggestFontSize", "Font size for the suggest widget. When set to {0}, the value of {1} is used.", "`0`", "`#editor.fontSize#`") })),
  suggestLineHeight: $(new _t(121, "suggestLineHeight", 0, 0, 1e3, { markdownDescription: f("suggestLineHeight", "Line height for the suggest widget. When set to {0}, the value of {1} is used. The minimum value is 8.", "`0`", "`#editor.lineHeight#`") })),
  suggestOnTriggerCharacters: $(new Ze(122, "suggestOnTriggerCharacters", !0, { description: f("suggestOnTriggerCharacters", "Controls whether suggestions should automatically show up when typing trigger characters.") })),
  suggestSelection: $(new Qt(123, "suggestSelection", "first", ["first", "recentlyUsed", "recentlyUsedByPrefix"], {
    markdownEnumDescriptions: [
      f("suggestSelection.first", "Always select the first suggestion."),
      f("suggestSelection.recentlyUsed", "Select recent suggestions unless further typing selects one, e.g. `console.| -> console.log` because `log` has been completed recently."),
      f("suggestSelection.recentlyUsedByPrefix", "Select suggestions based on previous prefixes that have completed those suggestions, e.g. `co -> console` and `con -> const`.")
    ],
    description: f("suggestSelection", "Controls how suggestions are pre-selected when showing the suggest list.")
  })),
  tabCompletion: $(new Qt(124, "tabCompletion", "off", ["on", "off", "onlySnippets"], {
    enumDescriptions: [
      f("tabCompletion.on", "Tab complete will insert the best matching suggestion when pressing tab."),
      f("tabCompletion.off", "Disable tab completions."),
      f("tabCompletion.onlySnippets", "Tab complete snippets when their prefix match. Works best when 'quickSuggestions' aren't enabled.")
    ],
    description: f("tabCompletion", "Enables tab completions.")
  })),
  tabIndex: $(new _t(
    125,
    "tabIndex",
    0,
    -1,
    1073741824
    /* Constants.MAX_SAFE_SMALL_INTEGER */
  )),
  unicodeHighlight: $(new Cz()),
  unusualLineTerminators: $(new Qt(127, "unusualLineTerminators", "prompt", ["auto", "off", "prompt"], {
    enumDescriptions: [
      f("unusualLineTerminators.auto", "Unusual line terminators are automatically removed."),
      f("unusualLineTerminators.off", "Unusual line terminators are ignored."),
      f("unusualLineTerminators.prompt", "Unusual line terminators prompt to be removed.")
    ],
    description: f("unusualLineTerminators", "Remove unusual line terminators that might cause problems.")
  })),
  useShadowDOM: $(new Ze(128, "useShadowDOM", !0)),
  useTabStops: $(new Ze(129, "useTabStops", !0, { description: f("useTabStops", "Spaces and tabs are inserted and deleted in alignment with tab stops.") })),
  wordBreak: $(new Qt(130, "wordBreak", "normal", ["normal", "keepAll"], {
    markdownEnumDescriptions: [
      f("wordBreak.normal", "Use the default line break rule."),
      f("wordBreak.keepAll", "Word breaks should not be used for Chinese/Japanese/Korean (CJK) text. Non-CJK text behavior is the same as for normal.")
    ],
    description: f("wordBreak", "Controls the word break rules used for Chinese/Japanese/Korean (CJK) text.")
  })),
  wordSegmenterLocales: $(new kz()),
  wordSeparators: $(new wn(132, "wordSeparators", $4, { description: f("wordSeparators", "Characters that will be used as word separators when doing word related navigations or operations.") })),
  wordWrap: $(new Qt(133, "wordWrap", "off", ["off", "on", "wordWrapColumn", "bounded"], {
    markdownEnumDescriptions: [
      f("wordWrap.off", "Lines will never wrap."),
      f("wordWrap.on", "Lines will wrap at the viewport width."),
      f({
        key: "wordWrap.wordWrapColumn",
        comment: [
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at `#editor.wordWrapColumn#`."),
      f({
        key: "wordWrap.bounded",
        comment: [
          "- viewport means the edge of the visible window size.",
          "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
        ]
      }, "Lines will wrap at the minimum of viewport and `#editor.wordWrapColumn#`.")
    ],
    description: f({
      key: "wordWrap",
      comment: [
        "- 'off', 'on', 'wordWrapColumn' and 'bounded' refer to values the setting can take and should not be localized.",
        "- `editor.wordWrapColumn` refers to a different setting and should not be localized."
      ]
    }, "Controls how lines should wrap.")
  })),
  wordWrapBreakAfterCharacters: $(new wn(
    134,
    "wordWrapBreakAfterCharacters",
    // allow-any-unicode-next-line
    " 	})]?|/&.,;¢°′″‰℃、。｡､￠，．：；？！％・･ゝゞヽヾーァィゥェォッャュョヮヵヶぁぃぅぇぉっゃゅょゎゕゖㇰㇱㇲㇳㇴㇵㇶㇷㇸㇹㇺㇻㇼㇽㇾㇿ々〻ｧｨｩｪｫｬｭｮｯｰ”〉》」』】〕）］｝｣"
  )),
  wordWrapBreakBeforeCharacters: $(new wn(
    135,
    "wordWrapBreakBeforeCharacters",
    // allow-any-unicode-next-line
    "([{‘“〈《「『【〔（［｛｢£¥＄￡￥+＋"
  )),
  wordWrapColumn: $(new _t(136, "wordWrapColumn", 80, 1, 1073741824, {
    markdownDescription: f({
      key: "wordWrapColumn",
      comment: [
        "- `editor.wordWrap` refers to a different setting and should not be localized.",
        "- 'wordWrapColumn' and 'bounded' refer to values the different setting can take and should not be localized."
      ]
    }, "Controls the wrapping column of the editor when `#editor.wordWrap#` is `wordWrapColumn` or `bounded`.")
  })),
  wordWrapOverride1: $(new Qt(137, "wordWrapOverride1", "inherit", ["off", "on", "inherit"])),
  wordWrapOverride2: $(new Qt(138, "wordWrapOverride2", "inherit", ["off", "on", "inherit"])),
  // Leave these at the end (because they have dependencies!)
  editorClassName: $(new $9()),
  defaultColorDecorators: $(new Ze(148, "defaultColorDecorators", !1, { markdownDescription: f("defaultColorDecorators", "Controls whether inline color decorations should be shown using the default document color provider") })),
  pixelRatio: $(new fz()),
  tabFocusMode: $(new Ze(145, "tabFocusMode", !1, { markdownDescription: f("tabFocusMode", "Controls whether the editor receives tabs or defers them to the workbench for navigation.") })),
  layoutInfo: $(new df()),
  wrappingInfo: $(new Iz()),
  wrappingIndent: $(new Dz()),
  wrappingStrategy: $(new sz())
};
class Fz {
  constructor() {
    this.listeners = [], this.unexpectedErrorHandler = function(e) {
      setTimeout(() => {
        throw e.stack ? Hf.isErrorNoTelemetry(e) ? new Hf(e.message + `

` + e.stack) : new Error(e.message + `

` + e.stack) : e;
      }, 0);
    };
  }
  emit(e) {
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  onUnexpectedError(e) {
    this.unexpectedErrorHandler(e), this.emit(e);
  }
  // For external errors, we don't want the listeners to be called
  onUnexpectedExternalError(e) {
    this.unexpectedErrorHandler(e);
  }
}
const tH = new Fz();
function Pe(s) {
  Ad(s) || tH.onUnexpectedError(s);
}
function xs(s) {
  Ad(s) || tH.onUnexpectedExternalError(s);
}
function UB(s) {
  if (s instanceof Error) {
    const { name: e, message: t } = s, i = s.stacktrace || s.stack;
    return {
      $isError: !0,
      name: e,
      message: t,
      stack: i,
      noTelemetry: Hf.isErrorNoTelemetry(s)
    };
  }
  return s;
}
const qw = "Canceled";
function Ad(s) {
  return s instanceof _d ? !0 : s instanceof Error && s.name === qw && s.message === qw;
}
class _d extends Error {
  constructor() {
    super(qw), this.name = this.message;
  }
}
function Oz() {
  const s = new Error(qw);
  return s.name = s.message, s;
}
function Go(s) {
  return s ? new Error(`Illegal argument: ${s}`) : new Error("Illegal argument");
}
function kM(s) {
  return s ? new Error(`Illegal state: ${s}`) : new Error("Illegal state");
}
class Pz extends Error {
  constructor(e) {
    super("NotSupported"), e && (this.message = e);
  }
}
class Hf extends Error {
  constructor(e) {
    super(e), this.name = "CodeExpectedError";
  }
  static fromError(e) {
    if (e instanceof Hf)
      return e;
    const t = new Hf();
    return t.message = e.message, t.stack = e.stack, t;
  }
  static isErrorNoTelemetry(e) {
    return e.name === "CodeExpectedError";
  }
}
class lt extends Error {
  constructor(e) {
    super(e || "An unexpected bug occurred."), Object.setPrototypeOf(this, lt.prototype);
  }
}
function Wf(s, e) {
  const t = this;
  let i = !1, n;
  return function() {
    return i || (i = !0, n = s.apply(t, arguments)), n;
  };
}
function DM(s) {
  return typeof s == "object" && s !== null && typeof s.dispose == "function" && s.dispose.length === 0;
}
function Ct(s) {
  if (nt.is(s)) {
    const e = [];
    for (const t of s)
      if (t)
        try {
          t.dispose();
        } catch (i) {
          e.push(i);
        }
    if (e.length === 1)
      throw e[0];
    if (e.length > 1)
      throw new AggregateError(e, "Encountered errors while disposing of store");
    return Array.isArray(s) ? [] : s;
  } else if (s)
    return s.dispose(), s;
}
function jo(...s) {
  return we(() => Ct(s));
}
function we(s) {
  return {
    dispose: Wf(() => {
      s();
    })
  };
}
const h1 = class h1 {
  constructor() {
    this._toDispose = /* @__PURE__ */ new Set(), this._isDisposed = !1;
  }
  /**
   * Dispose of all registered disposables and mark this object as disposed.
   *
   * Any future disposables added to this object will be disposed of on `add`.
   */
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this.clear());
  }
  /**
   * @return `true` if this object has been disposed of.
   */
  get isDisposed() {
    return this._isDisposed;
  }
  /**
   * Dispose of all registered disposables but do not mark this object as disposed.
   */
  clear() {
    if (this._toDispose.size !== 0)
      try {
        Ct(this._toDispose);
      } finally {
        this._toDispose.clear();
      }
  }
  /**
   * Add a new {@link IDisposable disposable} to the collection.
   */
  add(e) {
    if (!e)
      return e;
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._isDisposed ? h1.DISABLE_DISPOSED_WARNING || console.warn(new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!").stack) : this._toDispose.add(e), e;
  }
  /**
   * Deletes the value from the store, but does not dispose it.
   */
  deleteAndLeak(e) {
    e && this._toDispose.has(e) && this._toDispose.delete(e);
  }
};
h1.DISABLE_DISPOSED_WARNING = !1;
let X = h1;
const DB = class DB {
  constructor() {
    this._store = new X(), this._store;
  }
  dispose() {
    this._store.dispose();
  }
  /**
   * Adds `o` to the collection of disposables managed by this object.
   */
  _register(e) {
    if (e === this)
      throw new Error("Cannot register a disposable on itself!");
    return this._store.add(e);
  }
};
DB.None = Object.freeze({ dispose() {
} });
let V = DB;
class On {
  constructor() {
    this._isDisposed = !1;
  }
  get value() {
    return this._isDisposed ? void 0 : this._value;
  }
  set value(e) {
    this._isDisposed || e === this._value || (this._value?.dispose(), this._value = e);
  }
  /**
   * Resets the stored value and disposed of the previously stored value.
   */
  clear() {
    this.value = void 0;
  }
  dispose() {
    this._isDisposed = !0, this._value?.dispose(), this._value = void 0;
  }
}
class Hz {
  constructor(e) {
    this._disposable = e, this._counter = 1;
  }
  acquire() {
    return this._counter++, this;
  }
  release() {
    return --this._counter === 0 && this._disposable.dispose(), this;
  }
}
class Wz {
  constructor(e) {
    this.object = e;
  }
  dispose() {
  }
}
class IM {
  constructor() {
    this._store = /* @__PURE__ */ new Map(), this._isDisposed = !1;
  }
  /**
   * Disposes of all stored values and mark this object as disposed.
   *
   * Trying to use this object after it has been disposed of is an error.
   */
  dispose() {
    this._isDisposed = !0, this.clearAndDisposeAll();
  }
  /**
   * Disposes of all stored values and clear the map, but DO NOT mark this object as disposed.
   */
  clearAndDisposeAll() {
    if (this._store.size)
      try {
        Ct(this._store.values());
      } finally {
        this._store.clear();
      }
  }
  get(e) {
    return this._store.get(e);
  }
  set(e, t, i = !1) {
    this._isDisposed && console.warn(new Error("Trying to add a disposable to a DisposableMap that has already been disposed of. The added object will be leaked!").stack), i || this._store.get(e)?.dispose(), this._store.set(e, t);
  }
  /**
   * Delete the value stored for `key` from this map and also dispose of it.
   */
  deleteAndDispose(e) {
    this._store.get(e)?.dispose(), this._store.delete(e);
  }
  [Symbol.iterator]() {
    return this._store[Symbol.iterator]();
  }
}
const Vz = globalThis.performance && typeof globalThis.performance.now == "function";
class es {
  static create(e) {
    return new es(e);
  }
  constructor(e) {
    this._now = Vz && e === !1 ? Date.now : globalThis.performance.now.bind(globalThis.performance), this._startTime = this._now(), this._stopTime = -1;
  }
  stop() {
    this._stopTime = this._now();
  }
  reset() {
    this._startTime = this._now(), this._stopTime = -1;
  }
  elapsed() {
    return this._stopTime !== -1 ? this._stopTime - this._startTime : this._now() - this._startTime;
  }
}
var te;
(function(s) {
  s.None = () => V.None;
  function e(j, H) {
    return u(j, () => {
    }, 0, void 0, !0, void 0, H);
  }
  s.defer = e;
  function t(j) {
    return (H, J = null, se) => {
      let ce = !1, he;
      return he = j((ae) => {
        if (!ce)
          return he ? he.dispose() : ce = !0, H.call(J, ae);
      }, null, se), ce && he.dispose(), he;
    };
  }
  s.once = t;
  function i(j, H) {
    return s.once(s.filter(j, H));
  }
  s.onceIf = i;
  function n(j, H, J) {
    return d((se, ce = null, he) => j((ae) => se.call(ce, H(ae)), null, he), J);
  }
  s.map = n;
  function o(j, H, J) {
    return d((se, ce = null, he) => j((ae) => {
      H(ae), se.call(ce, ae);
    }, null, he), J);
  }
  s.forEach = o;
  function r(j, H, J) {
    return d((se, ce = null, he) => j((ae) => H(ae) && se.call(ce, ae), null, he), J);
  }
  s.filter = r;
  function a(j) {
    return j;
  }
  s.signal = a;
  function l(...j) {
    return (H, J = null, se) => {
      const ce = jo(...j.map((he) => he((ae) => H.call(J, ae))));
      return h(ce, se);
    };
  }
  s.any = l;
  function c(j, H, J, se) {
    let ce = J;
    return n(j, (he) => (ce = H(ce, he), ce), se);
  }
  s.reduce = c;
  function d(j, H) {
    let J;
    const se = {
      onWillAddFirstListener() {
        J = j(ce.fire, ce);
      },
      onDidRemoveLastListener() {
        J?.dispose();
      }
    }, ce = new B(se);
    return H?.add(ce), ce.event;
  }
  function h(j, H) {
    return H instanceof Array ? H.push(j) : H && H.add(j), j;
  }
  function u(j, H, J = 100, se = !1, ce = !1, he, ae) {
    let be, Ce, Ft, ut = 0, Ut;
    const ft = {
      leakWarningThreshold: he,
      onWillAddFirstListener() {
        be = j((io) => {
          ut++, Ce = H(Ce, io), se && !Ft && (ri.fire(Ce), Ce = void 0), Ut = () => {
            const Ai = Ce;
            Ce = void 0, Ft = void 0, (!se || ut > 1) && ri.fire(Ai), ut = 0;
          }, typeof J == "number" ? (clearTimeout(Ft), Ft = setTimeout(Ut, J)) : Ft === void 0 && (Ft = 0, queueMicrotask(Ut));
        });
      },
      onWillRemoveListener() {
        ce && ut > 0 && Ut?.();
      },
      onDidRemoveLastListener() {
        Ut = void 0, be.dispose();
      }
    }, ri = new B(ft);
    return ae?.add(ri), ri.event;
  }
  s.debounce = u;
  function g(j, H = 0, J) {
    return s.debounce(j, (se, ce) => se ? (se.push(ce), se) : [ce], H, void 0, !0, void 0, J);
  }
  s.accumulate = g;
  function m(j, H = (se, ce) => se === ce, J) {
    let se = !0, ce;
    return r(j, (he) => {
      const ae = se || !H(he, ce);
      return se = !1, ce = he, ae;
    }, J);
  }
  s.latch = m;
  function p(j, H, J) {
    return [
      s.filter(j, H, J),
      s.filter(j, (se) => !H(se), J)
    ];
  }
  s.split = p;
  function A(j, H = !1, J = [], se) {
    let ce = J.slice(), he = j((Ce) => {
      ce ? ce.push(Ce) : be.fire(Ce);
    });
    se && se.add(he);
    const ae = () => {
      ce?.forEach((Ce) => be.fire(Ce)), ce = null;
    }, be = new B({
      onWillAddFirstListener() {
        he || (he = j((Ce) => be.fire(Ce)), se && se.add(he));
      },
      onDidAddFirstListener() {
        ce && (H ? setTimeout(ae) : ae());
      },
      onDidRemoveLastListener() {
        he && he.dispose(), he = null;
      }
    });
    return se && se.add(be), be.event;
  }
  s.buffer = A;
  function _(j, H) {
    return (se, ce, he) => {
      const ae = H(new C());
      return j(function(be) {
        const Ce = ae.evaluate(be);
        Ce !== b && se.call(ce, Ce);
      }, void 0, he);
    };
  }
  s.chain = _;
  const b = Symbol("HaltChainable");
  class C {
    constructor() {
      this.steps = [];
    }
    map(H) {
      return this.steps.push(H), this;
    }
    forEach(H) {
      return this.steps.push((J) => (H(J), J)), this;
    }
    filter(H) {
      return this.steps.push((J) => H(J) ? J : b), this;
    }
    reduce(H, J) {
      let se = J;
      return this.steps.push((ce) => (se = H(se, ce), se)), this;
    }
    latch(H = (J, se) => J === se) {
      let J = !0, se;
      return this.steps.push((ce) => {
        const he = J || !H(ce, se);
        return J = !1, se = ce, he ? ce : b;
      }), this;
    }
    evaluate(H) {
      for (const J of this.steps)
        if (H = J(H), H === b)
          break;
      return H;
    }
  }
  function w(j, H, J = (se) => se) {
    const se = (...be) => ae.fire(J(...be)), ce = () => j.on(H, se), he = () => j.removeListener(H, se), ae = new B({ onWillAddFirstListener: ce, onDidRemoveLastListener: he });
    return ae.event;
  }
  s.fromNodeEventEmitter = w;
  function S(j, H, J = (se) => se) {
    const se = (...be) => ae.fire(J(...be)), ce = () => j.addEventListener(H, se), he = () => j.removeEventListener(H, se), ae = new B({ onWillAddFirstListener: ce, onDidRemoveLastListener: he });
    return ae.event;
  }
  s.fromDOMEventEmitter = S;
  function x(j) {
    return new Promise((H) => t(j)(H));
  }
  s.toPromise = x;
  function y(j) {
    const H = new B();
    return j.then((J) => {
      H.fire(J);
    }, () => {
      H.fire(void 0);
    }).finally(() => {
      H.dispose();
    }), H.event;
  }
  s.fromPromise = y;
  function D(j, H) {
    return j((J) => H.fire(J));
  }
  s.forward = D;
  function I(j, H, J) {
    return H(J), j((se) => H(se));
  }
  s.runAndSubscribe = I;
  class Q {
    constructor(H, J) {
      this._observable = H, this._counter = 0, this._hasChanged = !1;
      const se = {
        onWillAddFirstListener: () => {
          H.addObserver(this), this._observable.reportChanges();
        },
        onDidRemoveLastListener: () => {
          H.removeObserver(this);
        }
      };
      this.emitter = new B(se), J && J.add(this.emitter);
    }
    beginUpdate(H) {
      this._counter++;
    }
    handlePossibleChange(H) {
    }
    handleChange(H, J) {
      this._hasChanged = !0;
    }
    endUpdate(H) {
      this._counter--, this._counter === 0 && (this._observable.reportChanges(), this._hasChanged && (this._hasChanged = !1, this.emitter.fire(this._observable.get())));
    }
  }
  function P(j, H) {
    return new Q(j, H).emitter.event;
  }
  s.fromObservable = P;
  function W(j) {
    return (H, J, se) => {
      let ce = 0, he = !1;
      const ae = {
        beginUpdate() {
          ce++;
        },
        endUpdate() {
          ce--, ce === 0 && (j.reportChanges(), he && (he = !1, H.call(J)));
        },
        handlePossibleChange() {
        },
        handleChange() {
          he = !0;
        }
      };
      j.addObserver(ae), j.reportChanges();
      const be = {
        dispose() {
          j.removeObserver(ae);
        }
      };
      return se instanceof X ? se.add(be) : Array.isArray(se) && se.push(be), be;
    };
  }
  s.fromObservableLight = W;
})(te || (te = {}));
const $g = class $g {
  constructor(e) {
    this.listenerCount = 0, this.invocationCount = 0, this.elapsedOverall = 0, this.durations = [], this.name = `${e}_${$g._idPool++}`, $g.all.add(this);
  }
  start(e) {
    this._stopWatch = new es(), this.listenerCount = e;
  }
  stop() {
    if (this._stopWatch) {
      const e = this._stopWatch.elapsed();
      this.durations.push(e), this.elapsedOverall += e, this.invocationCount += 1, this._stopWatch = void 0;
    }
  }
};
$g.all = /* @__PURE__ */ new Set(), $g._idPool = 0;
let Lx = $g, zz = -1;
const u1 = class u1 {
  constructor(e, t, i = (u1._idPool++).toString(16).padStart(3, "0")) {
    this._errorHandler = e, this.threshold = t, this.name = i, this._warnCountdown = 0;
  }
  dispose() {
    this._stacks?.clear();
  }
  check(e, t) {
    const i = this.threshold;
    if (i <= 0 || t < i)
      return;
    this._stacks || (this._stacks = /* @__PURE__ */ new Map());
    const n = this._stacks.get(e.value) || 0;
    if (this._stacks.set(e.value, n + 1), this._warnCountdown -= 1, this._warnCountdown <= 0) {
      this._warnCountdown = i * 0.5;
      const [o, r] = this.getMostFrequentStack(), a = `[${this.name}] potential listener LEAK detected, having ${t} listeners already. MOST frequent listener (${r}):`;
      console.warn(a), console.warn(o);
      const l = new Uz(a, o);
      this._errorHandler(l);
    }
    return () => {
      const o = this._stacks.get(e.value) || 0;
      this._stacks.set(e.value, o - 1);
    };
  }
  getMostFrequentStack() {
    if (!this._stacks)
      return;
    let e, t = 0;
    for (const [i, n] of this._stacks)
      (!e || t < n) && (e = [i, n], t = n);
    return e;
  }
};
u1._idPool = 1;
let kx = u1;
class MM {
  static create() {
    const e = new Error();
    return new MM(e.stack ?? "");
  }
  constructor(e) {
    this.value = e;
  }
  print() {
    console.warn(this.value.split(`
`).slice(2).join(`
`));
  }
}
class Uz extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerLeakError", this.stack = t;
  }
}
class Qz extends Error {
  constructor(e, t) {
    super(e), this.name = "ListenerRefusalError", this.stack = t;
  }
}
class US {
  constructor(e) {
    this.value = e;
  }
}
const Gz = 2;
let B = class {
  constructor(e) {
    this._size = 0, this._options = e, this._leakageMon = this._options?.leakWarningThreshold ? new kx(e?.onListenerError ?? Pe, this._options?.leakWarningThreshold ?? zz) : void 0, this._perfMon = this._options?._profName ? new Lx(this._options._profName) : void 0, this._deliveryQueue = this._options?.deliveryQueue;
  }
  dispose() {
    this._disposed || (this._disposed = !0, this._deliveryQueue?.current === this && this._deliveryQueue.reset(), this._listeners && (this._listeners = void 0, this._size = 0), this._options?.onDidRemoveLastListener?.(), this._leakageMon?.dispose());
  }
  /**
   * For the public to allow to subscribe
   * to events from this Emitter
   */
  get event() {
    return this._event ?? (this._event = (e, t, i) => {
      if (this._leakageMon && this._size > this._leakageMon.threshold ** 2) {
        const a = `[${this._leakageMon.name}] REFUSES to accept new listeners because it exceeded its threshold by far (${this._size} vs ${this._leakageMon.threshold})`;
        console.warn(a);
        const l = this._leakageMon.getMostFrequentStack() ?? ["UNKNOWN stack", -1], c = new Qz(`${a}. HINT: Stack shows most frequent listener (${l[1]}-times)`, l[0]);
        return (this._options?.onListenerError || Pe)(c), V.None;
      }
      if (this._disposed)
        return V.None;
      t && (e = e.bind(t));
      const n = new US(e);
      let o;
      this._leakageMon && this._size >= Math.ceil(this._leakageMon.threshold * 0.2) && (n.stack = MM.create(), o = this._leakageMon.check(n.stack, this._size + 1)), this._listeners ? this._listeners instanceof US ? (this._deliveryQueue ?? (this._deliveryQueue = new iH()), this._listeners = [this._listeners, n]) : this._listeners.push(n) : (this._options?.onWillAddFirstListener?.(this), this._listeners = n, this._options?.onDidAddFirstListener?.(this)), this._size++;
      const r = we(() => {
        o?.(), this._removeListener(n);
      });
      return i instanceof X ? i.add(r) : Array.isArray(i) && i.push(r), r;
    }), this._event;
  }
  _removeListener(e) {
    if (this._options?.onWillRemoveListener?.(this), !this._listeners)
      return;
    if (this._size === 1) {
      this._listeners = void 0, this._options?.onDidRemoveLastListener?.(this), this._size = 0;
      return;
    }
    const t = this._listeners, i = t.indexOf(e);
    if (i === -1)
      throw console.log("disposed?", this._disposed), console.log("size?", this._size), console.log("arr?", JSON.stringify(this._listeners)), new Error("Attempted to dispose unknown listener");
    this._size--, t[i] = void 0;
    const n = this._deliveryQueue.current === this;
    if (this._size * Gz <= t.length) {
      let o = 0;
      for (let r = 0; r < t.length; r++)
        t[r] ? t[o++] = t[r] : n && (this._deliveryQueue.end--, o < this._deliveryQueue.i && this._deliveryQueue.i--);
      t.length = o;
    }
  }
  _deliver(e, t) {
    if (!e)
      return;
    const i = this._options?.onListenerError || Pe;
    if (!i) {
      e.value(t);
      return;
    }
    try {
      e.value(t);
    } catch (n) {
      i(n);
    }
  }
  /** Delivers items in the queue. Assumes the queue is ready to go. */
  _deliverQueue(e) {
    const t = e.current._listeners;
    for (; e.i < e.end; )
      this._deliver(t[e.i++], e.value);
    e.reset();
  }
  /**
   * To be kept private to fire an event to
   * subscribers
   */
  fire(e) {
    if (this._deliveryQueue?.current && (this._deliverQueue(this._deliveryQueue), this._perfMon?.stop()), this._perfMon?.start(this._size), this._listeners) if (this._listeners instanceof US)
      this._deliver(this._listeners, e);
    else {
      const t = this._deliveryQueue;
      t.enqueue(this, e, this._listeners.length), this._deliverQueue(t);
    }
    this._perfMon?.stop();
  }
  hasListeners() {
    return this._size > 0;
  }
};
const jz = () => new iH();
class iH {
  constructor() {
    this.i = -1, this.end = 0;
  }
  enqueue(e, t, i) {
    this.i = 0, this.end = i, this.current = e, this.value = t;
  }
  reset() {
    this.i = this.end, this.current = void 0, this.value = void 0;
  }
}
class uu extends B {
  constructor(e) {
    super(e), this._isPaused = 0, this._eventQueue = new Nn(), this._mergeFn = e?.merge;
  }
  pause() {
    this._isPaused++;
  }
  resume() {
    if (this._isPaused !== 0 && --this._isPaused === 0)
      if (this._mergeFn) {
        if (this._eventQueue.size > 0) {
          const e = Array.from(this._eventQueue);
          this._eventQueue.clear(), super.fire(this._mergeFn(e));
        }
      } else
        for (; !this._isPaused && this._eventQueue.size !== 0; )
          super.fire(this._eventQueue.shift());
  }
  fire(e) {
    this._size && (this._isPaused !== 0 ? this._eventQueue.push(e) : super.fire(e));
  }
}
class nH extends uu {
  constructor(e) {
    super(e), this._delay = e.delay ?? 100;
  }
  fire(e) {
    this._handle || (this.pause(), this._handle = setTimeout(() => {
      this._handle = void 0, this.resume();
    }, this._delay)), super.fire(e);
  }
}
class Yz extends B {
  constructor(e) {
    super(e), this._queuedEvents = [], this._mergeFn = e?.merge;
  }
  fire(e) {
    this.hasListeners() && (this._queuedEvents.push(e), this._queuedEvents.length === 1 && queueMicrotask(() => {
      this._mergeFn ? super.fire(this._mergeFn(this._queuedEvents)) : this._queuedEvents.forEach((t) => super.fire(t)), this._queuedEvents = [];
    }));
  }
}
class Kz {
  constructor() {
    this.hasListeners = !1, this.events = [], this.emitter = new B({
      onWillAddFirstListener: () => this.onFirstListenerAdd(),
      onDidRemoveLastListener: () => this.onLastListenerRemove()
    });
  }
  get event() {
    return this.emitter.event;
  }
  add(e) {
    const t = { event: e, listener: null };
    return this.events.push(t), this.hasListeners && this.hook(t), we(Wf(() => {
      this.hasListeners && this.unhook(t);
      const n = this.events.indexOf(t);
      this.events.splice(n, 1);
    }));
  }
  onFirstListenerAdd() {
    this.hasListeners = !0, this.events.forEach((e) => this.hook(e));
  }
  onLastListenerRemove() {
    this.hasListeners = !1, this.events.forEach((e) => this.unhook(e));
  }
  hook(e) {
    e.listener = e.event((t) => this.emitter.fire(t));
  }
  unhook(e) {
    e.listener?.dispose(), e.listener = null;
  }
  dispose() {
    this.emitter.dispose();
    for (const e of this.events)
      e.listener?.dispose();
    this.events = [];
  }
}
class k_ {
  constructor() {
    this.data = [];
  }
  wrapEvent(e, t, i) {
    return (n, o, r) => e((a) => {
      const l = this.data[this.data.length - 1];
      if (!t) {
        l ? l.buffers.push(() => n.call(o, a)) : n.call(o, a);
        return;
      }
      const c = l;
      if (!c) {
        n.call(o, t(i, a));
        return;
      }
      c.items ?? (c.items = []), c.items.push(a), c.buffers.length === 0 && l.buffers.push(() => {
        c.reducedResult ?? (c.reducedResult = i ? c.items.reduce(t, i) : c.items.reduce(t)), n.call(o, c.reducedResult);
      });
    }, void 0, r);
  }
  bufferEvents(e) {
    const t = { buffers: new Array() };
    this.data.push(t);
    const i = e();
    return this.data.pop(), t.buffers.forEach((n) => n()), i;
  }
}
class QB {
  constructor() {
    this.listening = !1, this.inputEvent = te.None, this.inputEventListener = V.None, this.emitter = new B({
      onDidAddFirstListener: () => {
        this.listening = !0, this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);
      },
      onDidRemoveLastListener: () => {
        this.listening = !1, this.inputEventListener.dispose();
      }
    }), this.event = this.emitter.event;
  }
  set input(e) {
    this.inputEvent = e, this.listening && (this.inputEventListener.dispose(), this.inputEventListener = e(this.emitter.fire, this.emitter));
  }
  dispose() {
    this.inputEventListener.dispose(), this.emitter.dispose();
  }
}
const sH = Object.freeze(function(s, e) {
  const t = setTimeout(s.bind(e), 0);
  return { dispose() {
    clearTimeout(t);
  } };
});
var ct;
(function(s) {
  function e(t) {
    return t === s.None || t === s.Cancelled || t instanceof gw ? !0 : !t || typeof t != "object" ? !1 : typeof t.isCancellationRequested == "boolean" && typeof t.onCancellationRequested == "function";
  }
  s.isCancellationToken = e, s.None = Object.freeze({
    isCancellationRequested: !1,
    onCancellationRequested: te.None
  }), s.Cancelled = Object.freeze({
    isCancellationRequested: !0,
    onCancellationRequested: sH
  });
})(ct || (ct = {}));
class gw {
  constructor() {
    this._isCancelled = !1, this._emitter = null;
  }
  cancel() {
    this._isCancelled || (this._isCancelled = !0, this._emitter && (this._emitter.fire(void 0), this.dispose()));
  }
  get isCancellationRequested() {
    return this._isCancelled;
  }
  get onCancellationRequested() {
    return this._isCancelled ? sH : (this._emitter || (this._emitter = new B()), this._emitter.event);
  }
  dispose() {
    this._emitter && (this._emitter.dispose(), this._emitter = null);
  }
}
let vs = class {
  constructor(e) {
    this._token = void 0, this._parentListener = void 0, this._parentListener = e && e.onCancellationRequested(this.cancel, this);
  }
  get token() {
    return this._token || (this._token = new gw()), this._token;
  }
  cancel() {
    this._token ? this._token instanceof gw && this._token.cancel() : this._token = ct.Cancelled;
  }
  dispose(e = !1) {
    e && this.cancel(), this._parentListener?.dispose(), this._token ? this._token instanceof gw && this._token.dispose() : this._token = ct.None;
  }
};
class NM {
  constructor() {
    this._keyCodeToStr = [], this._strToKeyCode = /* @__PURE__ */ Object.create(null);
  }
  define(e, t) {
    this._keyCodeToStr[e] = t, this._strToKeyCode[t.toLowerCase()] = e;
  }
  keyCodeToStr(e) {
    return this._keyCodeToStr[e];
  }
  strToKeyCode(e) {
    return this._strToKeyCode[e.toLowerCase()] || 0;
  }
}
const fw = new NM(), Dx = new NM(), Ix = new NM(), oH = new Array(230), Jz = /* @__PURE__ */ Object.create(null), qz = /* @__PURE__ */ Object.create(null), TM = [];
for (let s = 0; s <= 193; s++)
  TM[s] = -1;
(function() {
  const s = "", e = [
    // immutable, scanCode, scanCodeStr, keyCode, keyCodeStr, eventKeyCode, vkey, usUserSettingsLabel, generalUserSettingsLabel
    [1, 0, "None", 0, "unknown", 0, "VK_UNKNOWN", s, s],
    [1, 1, "Hyper", 0, s, 0, s, s, s],
    [1, 2, "Super", 0, s, 0, s, s, s],
    [1, 3, "Fn", 0, s, 0, s, s, s],
    [1, 4, "FnLock", 0, s, 0, s, s, s],
    [1, 5, "Suspend", 0, s, 0, s, s, s],
    [1, 6, "Resume", 0, s, 0, s, s, s],
    [1, 7, "Turbo", 0, s, 0, s, s, s],
    [1, 8, "Sleep", 0, s, 0, "VK_SLEEP", s, s],
    [1, 9, "WakeUp", 0, s, 0, s, s, s],
    [0, 10, "KeyA", 31, "A", 65, "VK_A", s, s],
    [0, 11, "KeyB", 32, "B", 66, "VK_B", s, s],
    [0, 12, "KeyC", 33, "C", 67, "VK_C", s, s],
    [0, 13, "KeyD", 34, "D", 68, "VK_D", s, s],
    [0, 14, "KeyE", 35, "E", 69, "VK_E", s, s],
    [0, 15, "KeyF", 36, "F", 70, "VK_F", s, s],
    [0, 16, "KeyG", 37, "G", 71, "VK_G", s, s],
    [0, 17, "KeyH", 38, "H", 72, "VK_H", s, s],
    [0, 18, "KeyI", 39, "I", 73, "VK_I", s, s],
    [0, 19, "KeyJ", 40, "J", 74, "VK_J", s, s],
    [0, 20, "KeyK", 41, "K", 75, "VK_K", s, s],
    [0, 21, "KeyL", 42, "L", 76, "VK_L", s, s],
    [0, 22, "KeyM", 43, "M", 77, "VK_M", s, s],
    [0, 23, "KeyN", 44, "N", 78, "VK_N", s, s],
    [0, 24, "KeyO", 45, "O", 79, "VK_O", s, s],
    [0, 25, "KeyP", 46, "P", 80, "VK_P", s, s],
    [0, 26, "KeyQ", 47, "Q", 81, "VK_Q", s, s],
    [0, 27, "KeyR", 48, "R", 82, "VK_R", s, s],
    [0, 28, "KeyS", 49, "S", 83, "VK_S", s, s],
    [0, 29, "KeyT", 50, "T", 84, "VK_T", s, s],
    [0, 30, "KeyU", 51, "U", 85, "VK_U", s, s],
    [0, 31, "KeyV", 52, "V", 86, "VK_V", s, s],
    [0, 32, "KeyW", 53, "W", 87, "VK_W", s, s],
    [0, 33, "KeyX", 54, "X", 88, "VK_X", s, s],
    [0, 34, "KeyY", 55, "Y", 89, "VK_Y", s, s],
    [0, 35, "KeyZ", 56, "Z", 90, "VK_Z", s, s],
    [0, 36, "Digit1", 22, "1", 49, "VK_1", s, s],
    [0, 37, "Digit2", 23, "2", 50, "VK_2", s, s],
    [0, 38, "Digit3", 24, "3", 51, "VK_3", s, s],
    [0, 39, "Digit4", 25, "4", 52, "VK_4", s, s],
    [0, 40, "Digit5", 26, "5", 53, "VK_5", s, s],
    [0, 41, "Digit6", 27, "6", 54, "VK_6", s, s],
    [0, 42, "Digit7", 28, "7", 55, "VK_7", s, s],
    [0, 43, "Digit8", 29, "8", 56, "VK_8", s, s],
    [0, 44, "Digit9", 30, "9", 57, "VK_9", s, s],
    [0, 45, "Digit0", 21, "0", 48, "VK_0", s, s],
    [1, 46, "Enter", 3, "Enter", 13, "VK_RETURN", s, s],
    [1, 47, "Escape", 9, "Escape", 27, "VK_ESCAPE", s, s],
    [1, 48, "Backspace", 1, "Backspace", 8, "VK_BACK", s, s],
    [1, 49, "Tab", 2, "Tab", 9, "VK_TAB", s, s],
    [1, 50, "Space", 10, "Space", 32, "VK_SPACE", s, s],
    [0, 51, "Minus", 88, "-", 189, "VK_OEM_MINUS", "-", "OEM_MINUS"],
    [0, 52, "Equal", 86, "=", 187, "VK_OEM_PLUS", "=", "OEM_PLUS"],
    [0, 53, "BracketLeft", 92, "[", 219, "VK_OEM_4", "[", "OEM_4"],
    [0, 54, "BracketRight", 94, "]", 221, "VK_OEM_6", "]", "OEM_6"],
    [0, 55, "Backslash", 93, "\\", 220, "VK_OEM_5", "\\", "OEM_5"],
    [0, 56, "IntlHash", 0, s, 0, s, s, s],
    // has been dropped from the w3c spec
    [0, 57, "Semicolon", 85, ";", 186, "VK_OEM_1", ";", "OEM_1"],
    [0, 58, "Quote", 95, "'", 222, "VK_OEM_7", "'", "OEM_7"],
    [0, 59, "Backquote", 91, "`", 192, "VK_OEM_3", "`", "OEM_3"],
    [0, 60, "Comma", 87, ",", 188, "VK_OEM_COMMA", ",", "OEM_COMMA"],
    [0, 61, "Period", 89, ".", 190, "VK_OEM_PERIOD", ".", "OEM_PERIOD"],
    [0, 62, "Slash", 90, "/", 191, "VK_OEM_2", "/", "OEM_2"],
    [1, 63, "CapsLock", 8, "CapsLock", 20, "VK_CAPITAL", s, s],
    [1, 64, "F1", 59, "F1", 112, "VK_F1", s, s],
    [1, 65, "F2", 60, "F2", 113, "VK_F2", s, s],
    [1, 66, "F3", 61, "F3", 114, "VK_F3", s, s],
    [1, 67, "F4", 62, "F4", 115, "VK_F4", s, s],
    [1, 68, "F5", 63, "F5", 116, "VK_F5", s, s],
    [1, 69, "F6", 64, "F6", 117, "VK_F6", s, s],
    [1, 70, "F7", 65, "F7", 118, "VK_F7", s, s],
    [1, 71, "F8", 66, "F8", 119, "VK_F8", s, s],
    [1, 72, "F9", 67, "F9", 120, "VK_F9", s, s],
    [1, 73, "F10", 68, "F10", 121, "VK_F10", s, s],
    [1, 74, "F11", 69, "F11", 122, "VK_F11", s, s],
    [1, 75, "F12", 70, "F12", 123, "VK_F12", s, s],
    [1, 76, "PrintScreen", 0, s, 0, s, s, s],
    [1, 77, "ScrollLock", 84, "ScrollLock", 145, "VK_SCROLL", s, s],
    [1, 78, "Pause", 7, "PauseBreak", 19, "VK_PAUSE", s, s],
    [1, 79, "Insert", 19, "Insert", 45, "VK_INSERT", s, s],
    [1, 80, "Home", 14, "Home", 36, "VK_HOME", s, s],
    [1, 81, "PageUp", 11, "PageUp", 33, "VK_PRIOR", s, s],
    [1, 82, "Delete", 20, "Delete", 46, "VK_DELETE", s, s],
    [1, 83, "End", 13, "End", 35, "VK_END", s, s],
    [1, 84, "PageDown", 12, "PageDown", 34, "VK_NEXT", s, s],
    [1, 85, "ArrowRight", 17, "RightArrow", 39, "VK_RIGHT", "Right", s],
    [1, 86, "ArrowLeft", 15, "LeftArrow", 37, "VK_LEFT", "Left", s],
    [1, 87, "ArrowDown", 18, "DownArrow", 40, "VK_DOWN", "Down", s],
    [1, 88, "ArrowUp", 16, "UpArrow", 38, "VK_UP", "Up", s],
    [1, 89, "NumLock", 83, "NumLock", 144, "VK_NUMLOCK", s, s],
    [1, 90, "NumpadDivide", 113, "NumPad_Divide", 111, "VK_DIVIDE", s, s],
    [1, 91, "NumpadMultiply", 108, "NumPad_Multiply", 106, "VK_MULTIPLY", s, s],
    [1, 92, "NumpadSubtract", 111, "NumPad_Subtract", 109, "VK_SUBTRACT", s, s],
    [1, 93, "NumpadAdd", 109, "NumPad_Add", 107, "VK_ADD", s, s],
    [1, 94, "NumpadEnter", 3, s, 0, s, s, s],
    [1, 95, "Numpad1", 99, "NumPad1", 97, "VK_NUMPAD1", s, s],
    [1, 96, "Numpad2", 100, "NumPad2", 98, "VK_NUMPAD2", s, s],
    [1, 97, "Numpad3", 101, "NumPad3", 99, "VK_NUMPAD3", s, s],
    [1, 98, "Numpad4", 102, "NumPad4", 100, "VK_NUMPAD4", s, s],
    [1, 99, "Numpad5", 103, "NumPad5", 101, "VK_NUMPAD5", s, s],
    [1, 100, "Numpad6", 104, "NumPad6", 102, "VK_NUMPAD6", s, s],
    [1, 101, "Numpad7", 105, "NumPad7", 103, "VK_NUMPAD7", s, s],
    [1, 102, "Numpad8", 106, "NumPad8", 104, "VK_NUMPAD8", s, s],
    [1, 103, "Numpad9", 107, "NumPad9", 105, "VK_NUMPAD9", s, s],
    [1, 104, "Numpad0", 98, "NumPad0", 96, "VK_NUMPAD0", s, s],
    [1, 105, "NumpadDecimal", 112, "NumPad_Decimal", 110, "VK_DECIMAL", s, s],
    [0, 106, "IntlBackslash", 97, "OEM_102", 226, "VK_OEM_102", s, s],
    [1, 107, "ContextMenu", 58, "ContextMenu", 93, s, s, s],
    [1, 108, "Power", 0, s, 0, s, s, s],
    [1, 109, "NumpadEqual", 0, s, 0, s, s, s],
    [1, 110, "F13", 71, "F13", 124, "VK_F13", s, s],
    [1, 111, "F14", 72, "F14", 125, "VK_F14", s, s],
    [1, 112, "F15", 73, "F15", 126, "VK_F15", s, s],
    [1, 113, "F16", 74, "F16", 127, "VK_F16", s, s],
    [1, 114, "F17", 75, "F17", 128, "VK_F17", s, s],
    [1, 115, "F18", 76, "F18", 129, "VK_F18", s, s],
    [1, 116, "F19", 77, "F19", 130, "VK_F19", s, s],
    [1, 117, "F20", 78, "F20", 131, "VK_F20", s, s],
    [1, 118, "F21", 79, "F21", 132, "VK_F21", s, s],
    [1, 119, "F22", 80, "F22", 133, "VK_F22", s, s],
    [1, 120, "F23", 81, "F23", 134, "VK_F23", s, s],
    [1, 121, "F24", 82, "F24", 135, "VK_F24", s, s],
    [1, 122, "Open", 0, s, 0, s, s, s],
    [1, 123, "Help", 0, s, 0, s, s, s],
    [1, 124, "Select", 0, s, 0, s, s, s],
    [1, 125, "Again", 0, s, 0, s, s, s],
    [1, 126, "Undo", 0, s, 0, s, s, s],
    [1, 127, "Cut", 0, s, 0, s, s, s],
    [1, 128, "Copy", 0, s, 0, s, s, s],
    [1, 129, "Paste", 0, s, 0, s, s, s],
    [1, 130, "Find", 0, s, 0, s, s, s],
    [1, 131, "AudioVolumeMute", 117, "AudioVolumeMute", 173, "VK_VOLUME_MUTE", s, s],
    [1, 132, "AudioVolumeUp", 118, "AudioVolumeUp", 175, "VK_VOLUME_UP", s, s],
    [1, 133, "AudioVolumeDown", 119, "AudioVolumeDown", 174, "VK_VOLUME_DOWN", s, s],
    [1, 134, "NumpadComma", 110, "NumPad_Separator", 108, "VK_SEPARATOR", s, s],
    [0, 135, "IntlRo", 115, "ABNT_C1", 193, "VK_ABNT_C1", s, s],
    [1, 136, "KanaMode", 0, s, 0, s, s, s],
    [0, 137, "IntlYen", 0, s, 0, s, s, s],
    [1, 138, "Convert", 0, s, 0, s, s, s],
    [1, 139, "NonConvert", 0, s, 0, s, s, s],
    [1, 140, "Lang1", 0, s, 0, s, s, s],
    [1, 141, "Lang2", 0, s, 0, s, s, s],
    [1, 142, "Lang3", 0, s, 0, s, s, s],
    [1, 143, "Lang4", 0, s, 0, s, s, s],
    [1, 144, "Lang5", 0, s, 0, s, s, s],
    [1, 145, "Abort", 0, s, 0, s, s, s],
    [1, 146, "Props", 0, s, 0, s, s, s],
    [1, 147, "NumpadParenLeft", 0, s, 0, s, s, s],
    [1, 148, "NumpadParenRight", 0, s, 0, s, s, s],
    [1, 149, "NumpadBackspace", 0, s, 0, s, s, s],
    [1, 150, "NumpadMemoryStore", 0, s, 0, s, s, s],
    [1, 151, "NumpadMemoryRecall", 0, s, 0, s, s, s],
    [1, 152, "NumpadMemoryClear", 0, s, 0, s, s, s],
    [1, 153, "NumpadMemoryAdd", 0, s, 0, s, s, s],
    [1, 154, "NumpadMemorySubtract", 0, s, 0, s, s, s],
    [1, 155, "NumpadClear", 131, "Clear", 12, "VK_CLEAR", s, s],
    [1, 156, "NumpadClearEntry", 0, s, 0, s, s, s],
    [1, 0, s, 5, "Ctrl", 17, "VK_CONTROL", s, s],
    [1, 0, s, 4, "Shift", 16, "VK_SHIFT", s, s],
    [1, 0, s, 6, "Alt", 18, "VK_MENU", s, s],
    [1, 0, s, 57, "Meta", 91, "VK_COMMAND", s, s],
    [1, 157, "ControlLeft", 5, s, 0, "VK_LCONTROL", s, s],
    [1, 158, "ShiftLeft", 4, s, 0, "VK_LSHIFT", s, s],
    [1, 159, "AltLeft", 6, s, 0, "VK_LMENU", s, s],
    [1, 160, "MetaLeft", 57, s, 0, "VK_LWIN", s, s],
    [1, 161, "ControlRight", 5, s, 0, "VK_RCONTROL", s, s],
    [1, 162, "ShiftRight", 4, s, 0, "VK_RSHIFT", s, s],
    [1, 163, "AltRight", 6, s, 0, "VK_RMENU", s, s],
    [1, 164, "MetaRight", 57, s, 0, "VK_RWIN", s, s],
    [1, 165, "BrightnessUp", 0, s, 0, s, s, s],
    [1, 166, "BrightnessDown", 0, s, 0, s, s, s],
    [1, 167, "MediaPlay", 0, s, 0, s, s, s],
    [1, 168, "MediaRecord", 0, s, 0, s, s, s],
    [1, 169, "MediaFastForward", 0, s, 0, s, s, s],
    [1, 170, "MediaRewind", 0, s, 0, s, s, s],
    [1, 171, "MediaTrackNext", 124, "MediaTrackNext", 176, "VK_MEDIA_NEXT_TRACK", s, s],
    [1, 172, "MediaTrackPrevious", 125, "MediaTrackPrevious", 177, "VK_MEDIA_PREV_TRACK", s, s],
    [1, 173, "MediaStop", 126, "MediaStop", 178, "VK_MEDIA_STOP", s, s],
    [1, 174, "Eject", 0, s, 0, s, s, s],
    [1, 175, "MediaPlayPause", 127, "MediaPlayPause", 179, "VK_MEDIA_PLAY_PAUSE", s, s],
    [1, 176, "MediaSelect", 128, "LaunchMediaPlayer", 181, "VK_MEDIA_LAUNCH_MEDIA_SELECT", s, s],
    [1, 177, "LaunchMail", 129, "LaunchMail", 180, "VK_MEDIA_LAUNCH_MAIL", s, s],
    [1, 178, "LaunchApp2", 130, "LaunchApp2", 183, "VK_MEDIA_LAUNCH_APP2", s, s],
    [1, 179, "LaunchApp1", 0, s, 0, "VK_MEDIA_LAUNCH_APP1", s, s],
    [1, 180, "SelectTask", 0, s, 0, s, s, s],
    [1, 181, "LaunchScreenSaver", 0, s, 0, s, s, s],
    [1, 182, "BrowserSearch", 120, "BrowserSearch", 170, "VK_BROWSER_SEARCH", s, s],
    [1, 183, "BrowserHome", 121, "BrowserHome", 172, "VK_BROWSER_HOME", s, s],
    [1, 184, "BrowserBack", 122, "BrowserBack", 166, "VK_BROWSER_BACK", s, s],
    [1, 185, "BrowserForward", 123, "BrowserForward", 167, "VK_BROWSER_FORWARD", s, s],
    [1, 186, "BrowserStop", 0, s, 0, "VK_BROWSER_STOP", s, s],
    [1, 187, "BrowserRefresh", 0, s, 0, "VK_BROWSER_REFRESH", s, s],
    [1, 188, "BrowserFavorites", 0, s, 0, "VK_BROWSER_FAVORITES", s, s],
    [1, 189, "ZoomToggle", 0, s, 0, s, s, s],
    [1, 190, "MailReply", 0, s, 0, s, s, s],
    [1, 191, "MailForward", 0, s, 0, s, s, s],
    [1, 192, "MailSend", 0, s, 0, s, s, s],
    // See https://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
    // If an Input Method Editor is processing key input and the event is keydown, return 229.
    [1, 0, s, 114, "KeyInComposition", 229, s, s, s],
    [1, 0, s, 116, "ABNT_C2", 194, "VK_ABNT_C2", s, s],
    [1, 0, s, 96, "OEM_8", 223, "VK_OEM_8", s, s],
    [1, 0, s, 0, s, 0, "VK_KANA", s, s],
    [1, 0, s, 0, s, 0, "VK_HANGUL", s, s],
    [1, 0, s, 0, s, 0, "VK_JUNJA", s, s],
    [1, 0, s, 0, s, 0, "VK_FINAL", s, s],
    [1, 0, s, 0, s, 0, "VK_HANJA", s, s],
    [1, 0, s, 0, s, 0, "VK_KANJI", s, s],
    [1, 0, s, 0, s, 0, "VK_CONVERT", s, s],
    [1, 0, s, 0, s, 0, "VK_NONCONVERT", s, s],
    [1, 0, s, 0, s, 0, "VK_ACCEPT", s, s],
    [1, 0, s, 0, s, 0, "VK_MODECHANGE", s, s],
    [1, 0, s, 0, s, 0, "VK_SELECT", s, s],
    [1, 0, s, 0, s, 0, "VK_PRINT", s, s],
    [1, 0, s, 0, s, 0, "VK_EXECUTE", s, s],
    [1, 0, s, 0, s, 0, "VK_SNAPSHOT", s, s],
    [1, 0, s, 0, s, 0, "VK_HELP", s, s],
    [1, 0, s, 0, s, 0, "VK_APPS", s, s],
    [1, 0, s, 0, s, 0, "VK_PROCESSKEY", s, s],
    [1, 0, s, 0, s, 0, "VK_PACKET", s, s],
    [1, 0, s, 0, s, 0, "VK_DBE_SBCSCHAR", s, s],
    [1, 0, s, 0, s, 0, "VK_DBE_DBCSCHAR", s, s],
    [1, 0, s, 0, s, 0, "VK_ATTN", s, s],
    [1, 0, s, 0, s, 0, "VK_CRSEL", s, s],
    [1, 0, s, 0, s, 0, "VK_EXSEL", s, s],
    [1, 0, s, 0, s, 0, "VK_EREOF", s, s],
    [1, 0, s, 0, s, 0, "VK_PLAY", s, s],
    [1, 0, s, 0, s, 0, "VK_ZOOM", s, s],
    [1, 0, s, 0, s, 0, "VK_NONAME", s, s],
    [1, 0, s, 0, s, 0, "VK_PA1", s, s],
    [1, 0, s, 0, s, 0, "VK_OEM_CLEAR", s, s]
  ], t = [], i = [];
  for (const n of e) {
    const [o, r, a, l, c, d, h, u, g] = n;
    if (i[r] || (i[r] = !0, Jz[a] = r, qz[a.toLowerCase()] = r, o && (TM[r] = l)), !t[l]) {
      if (t[l] = !0, !c)
        throw new Error(`String representation missing for key code ${l} around scan code ${a}`);
      fw.define(l, c), Dx.define(l, u || c), Ix.define(l, g || u || c);
    }
    d && (oH[d] = l);
  }
})();
var ul;
(function(s) {
  function e(a) {
    return fw.keyCodeToStr(a);
  }
  s.toString = e;
  function t(a) {
    return fw.strToKeyCode(a);
  }
  s.fromString = t;
  function i(a) {
    return Dx.keyCodeToStr(a);
  }
  s.toUserSettingsUS = i;
  function n(a) {
    return Ix.keyCodeToStr(a);
  }
  s.toUserSettingsGeneral = n;
  function o(a) {
    return Dx.strToKeyCode(a) || Ix.strToKeyCode(a);
  }
  s.fromUserSettings = o;
  function r(a) {
    if (a >= 98 && a <= 113)
      return null;
    switch (a) {
      case 16:
        return "Up";
      case 18:
        return "Down";
      case 15:
        return "Left";
      case 17:
        return "Right";
    }
    return fw.keyCodeToStr(a);
  }
  s.toElectronAccelerator = r;
})(ul || (ul = {}));
function Qi(s, e) {
  const t = (e & 65535) << 16 >>> 0;
  return (s | t) >>> 0;
}
let uf;
const QS = globalThis.vscode;
if (typeof QS < "u" && typeof QS.process < "u") {
  const s = QS.process;
  uf = {
    get platform() {
      return s.platform;
    },
    get arch() {
      return s.arch;
    },
    get env() {
      return s.env;
    },
    cwd() {
      return s.cwd();
    }
  };
} else typeof process < "u" && typeof process?.versions?.node == "string" ? uf = {
  get platform() {
    return process.platform;
  },
  get arch() {
    return process.arch;
  },
  get env() {
    return process.env;
  },
  cwd() {
    return process.env.VSCODE_CWD || process.cwd();
  }
} : uf = {
  // Supported
  get platform() {
    return yn ? "win32" : ze ? "darwin" : "linux";
  },
  get arch() {
  },
  // Unsupported
  get env() {
    return {};
  },
  cwd() {
    return "/";
  }
};
const $w = uf.cwd, Mx = uf.env, $z = uf.platform, Xz = 65, Zz = 97, e7 = 90, t7 = 122, Oc = 46, pn = 47, Ts = 92, nc = 58, i7 = 63;
class rH extends Error {
  constructor(e, t, i) {
    let n;
    typeof t == "string" && t.indexOf("not ") === 0 ? (n = "must not be", t = t.replace(/^not /, "")) : n = "must be";
    const o = e.indexOf(".") !== -1 ? "property" : "argument";
    let r = `The "${e}" ${o} ${n} of type ${t}`;
    r += `. Received type ${typeof i}`, super(r), this.code = "ERR_INVALID_ARG_TYPE";
  }
}
function n7(s, e) {
  if (s === null || typeof s != "object")
    throw new rH(e, "Object", s);
}
function Di(s, e) {
  if (typeof s != "string")
    throw new rH(e, "string", s);
}
const Ql = $z === "win32";
function dt(s) {
  return s === pn || s === Ts;
}
function Nx(s) {
  return s === pn;
}
function sc(s) {
  return s >= Xz && s <= e7 || s >= Zz && s <= t7;
}
function Xw(s, e, t, i) {
  let n = "", o = 0, r = -1, a = 0, l = 0;
  for (let c = 0; c <= s.length; ++c) {
    if (c < s.length)
      l = s.charCodeAt(c);
    else {
      if (i(l))
        break;
      l = pn;
    }
    if (i(l)) {
      if (!(r === c - 1 || a === 1)) if (a === 2) {
        if (n.length < 2 || o !== 2 || n.charCodeAt(n.length - 1) !== Oc || n.charCodeAt(n.length - 2) !== Oc) {
          if (n.length > 2) {
            const d = n.lastIndexOf(t);
            d === -1 ? (n = "", o = 0) : (n = n.slice(0, d), o = n.length - 1 - n.lastIndexOf(t)), r = c, a = 0;
            continue;
          } else if (n.length !== 0) {
            n = "", o = 0, r = c, a = 0;
            continue;
          }
        }
        e && (n += n.length > 0 ? `${t}..` : "..", o = 2);
      } else
        n.length > 0 ? n += `${t}${s.slice(r + 1, c)}` : n = s.slice(r + 1, c), o = c - r - 1;
      r = c, a = 0;
    } else l === Oc && a !== -1 ? ++a : a = -1;
  }
  return n;
}
function s7(s) {
  return s ? `${s[0] === "." ? "" : "."}${s}` : "";
}
function aH(s, e) {
  n7(e, "pathObject");
  const t = e.dir || e.root, i = e.base || `${e.name || ""}${s7(e.ext)}`;
  return t ? t === e.root ? `${t}${i}` : `${t}${s}${i}` : i;
}
const $n = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = "", i = !1;
    for (let n = s.length - 1; n >= -1; n--) {
      let o;
      if (n >= 0) {
        if (o = s[n], Di(o, `paths[${n}]`), o.length === 0)
          continue;
      } else e.length === 0 ? o = $w() : (o = Mx[`=${e}`] || $w(), (o === void 0 || o.slice(0, 2).toLowerCase() !== e.toLowerCase() && o.charCodeAt(2) === Ts) && (o = `${e}\\`));
      const r = o.length;
      let a = 0, l = "", c = !1;
      const d = o.charCodeAt(0);
      if (r === 1)
        dt(d) && (a = 1, c = !0);
      else if (dt(d))
        if (c = !0, dt(o.charCodeAt(1))) {
          let h = 2, u = h;
          for (; h < r && !dt(o.charCodeAt(h)); )
            h++;
          if (h < r && h !== u) {
            const g = o.slice(u, h);
            for (u = h; h < r && dt(o.charCodeAt(h)); )
              h++;
            if (h < r && h !== u) {
              for (u = h; h < r && !dt(o.charCodeAt(h)); )
                h++;
              (h === r || h !== u) && (l = `\\\\${g}\\${o.slice(u, h)}`, a = h);
            }
          }
        } else
          a = 1;
      else sc(d) && o.charCodeAt(1) === nc && (l = o.slice(0, 2), a = 2, r > 2 && dt(o.charCodeAt(2)) && (c = !0, a = 3));
      if (l.length > 0)
        if (e.length > 0) {
          if (l.toLowerCase() !== e.toLowerCase())
            continue;
        } else
          e = l;
      if (i) {
        if (e.length > 0)
          break;
      } else if (t = `${o.slice(a)}\\${t}`, i = c, c && e.length > 0)
        break;
    }
    return t = Xw(t, !i, "\\", dt), i ? `${e}\\${t}` : `${e}${t}` || ".";
  },
  normalize(s) {
    Di(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = 0, i, n = !1;
    const o = s.charCodeAt(0);
    if (e === 1)
      return Nx(o) ? "\\" : s;
    if (dt(o))
      if (n = !0, dt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !dt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          const c = s.slice(l, a);
          for (l = a; a < e && dt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !dt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return `\\\\${c}\\${s.slice(l)}\\`;
            a !== l && (i = `\\\\${c}\\${s.slice(l, a)}`, t = a);
          }
        }
      } else
        t = 1;
    else sc(o) && s.charCodeAt(1) === nc && (i = s.slice(0, 2), t = 2, e > 2 && dt(s.charCodeAt(2)) && (n = !0, t = 3));
    let r = t < e ? Xw(s.slice(t), !n, "\\", dt) : "";
    return r.length === 0 && !n && (r = "."), r.length > 0 && dt(s.charCodeAt(e - 1)) && (r += "\\"), i === void 0 ? n ? `\\${r}` : r : n ? `${i}\\${r}` : `${i}${r}`;
  },
  isAbsolute(s) {
    Di(s, "path");
    const e = s.length;
    if (e === 0)
      return !1;
    const t = s.charCodeAt(0);
    return dt(t) || // Possible device root
    e > 2 && sc(t) && s.charCodeAt(1) === nc && dt(s.charCodeAt(2));
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e, t;
    for (let o = 0; o < s.length; ++o) {
      const r = s[o];
      Di(r, "path"), r.length > 0 && (e === void 0 ? e = t = r : e += `\\${r}`);
    }
    if (e === void 0)
      return ".";
    let i = !0, n = 0;
    if (typeof t == "string" && dt(t.charCodeAt(0))) {
      ++n;
      const o = t.length;
      o > 1 && dt(t.charCodeAt(1)) && (++n, o > 2 && (dt(t.charCodeAt(2)) ? ++n : i = !1));
    }
    if (i) {
      for (; n < e.length && dt(e.charCodeAt(n)); )
        n++;
      n >= 2 && (e = `\\${e.slice(n)}`);
    }
    return $n.normalize(e);
  },
  // It will solve the relative path from `from` to `to`, for instance:
  //  from = 'C:\\orandea\\test\\aaa'
  //  to = 'C:\\orandea\\impl\\bbb'
  // The output of the function should be: '..\\..\\impl\\bbb'
  relative(s, e) {
    if (Di(s, "from"), Di(e, "to"), s === e)
      return "";
    const t = $n.resolve(s), i = $n.resolve(e);
    if (t === i || (s = t.toLowerCase(), e = i.toLowerCase(), s === e))
      return "";
    let n = 0;
    for (; n < s.length && s.charCodeAt(n) === Ts; )
      n++;
    let o = s.length;
    for (; o - 1 > n && s.charCodeAt(o - 1) === Ts; )
      o--;
    const r = o - n;
    let a = 0;
    for (; a < e.length && e.charCodeAt(a) === Ts; )
      a++;
    let l = e.length;
    for (; l - 1 > a && e.charCodeAt(l - 1) === Ts; )
      l--;
    const c = l - a, d = r < c ? r : c;
    let h = -1, u = 0;
    for (; u < d; u++) {
      const m = s.charCodeAt(n + u);
      if (m !== e.charCodeAt(a + u))
        break;
      m === Ts && (h = u);
    }
    if (u !== d) {
      if (h === -1)
        return i;
    } else {
      if (c > d) {
        if (e.charCodeAt(a + u) === Ts)
          return i.slice(a + u + 1);
        if (u === 2)
          return i.slice(a + u);
      }
      r > d && (s.charCodeAt(n + u) === Ts ? h = u : u === 2 && (h = 3)), h === -1 && (h = 0);
    }
    let g = "";
    for (u = n + h + 1; u <= o; ++u)
      (u === o || s.charCodeAt(u) === Ts) && (g += g.length === 0 ? ".." : "\\..");
    return a += h, g.length > 0 ? `${g}${i.slice(a, l)}` : (i.charCodeAt(a) === Ts && ++a, i.slice(a, l));
  },
  toNamespacedPath(s) {
    if (typeof s != "string" || s.length === 0)
      return s;
    const e = $n.resolve(s);
    if (e.length <= 2)
      return s;
    if (e.charCodeAt(0) === Ts) {
      if (e.charCodeAt(1) === Ts) {
        const t = e.charCodeAt(2);
        if (t !== i7 && t !== Oc)
          return `\\\\?\\UNC\\${e.slice(2)}`;
      }
    } else if (sc(e.charCodeAt(0)) && e.charCodeAt(1) === nc && e.charCodeAt(2) === Ts)
      return `\\\\?\\${e}`;
    return s;
  },
  dirname(s) {
    Di(s, "path");
    const e = s.length;
    if (e === 0)
      return ".";
    let t = -1, i = 0;
    const n = s.charCodeAt(0);
    if (e === 1)
      return dt(n) ? s : ".";
    if (dt(n)) {
      if (t = i = 1, dt(s.charCodeAt(1))) {
        let a = 2, l = a;
        for (; a < e && !dt(s.charCodeAt(a)); )
          a++;
        if (a < e && a !== l) {
          for (l = a; a < e && dt(s.charCodeAt(a)); )
            a++;
          if (a < e && a !== l) {
            for (l = a; a < e && !dt(s.charCodeAt(a)); )
              a++;
            if (a === e)
              return s;
            a !== l && (t = i = a + 1);
          }
        }
      }
    } else sc(n) && s.charCodeAt(1) === nc && (t = e > 2 && dt(s.charCodeAt(2)) ? 3 : 2, i = t);
    let o = -1, r = !0;
    for (let a = e - 1; a >= i; --a)
      if (dt(s.charCodeAt(a))) {
        if (!r) {
          o = a;
          break;
        }
      } else
        r = !1;
    if (o === -1) {
      if (t === -1)
        return ".";
      o = t;
    }
    return s.slice(0, o);
  },
  basename(s, e) {
    e !== void 0 && Di(e, "suffix"), Di(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (s.length >= 2 && sc(s.charCodeAt(0)) && s.charCodeAt(1) === nc && (t = 2), e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= t; --o) {
        const l = s.charCodeAt(o);
        if (dt(l)) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= t; --o)
      if (dt(s.charCodeAt(o))) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    Di(s, "path");
    let e = 0, t = -1, i = 0, n = -1, o = !0, r = 0;
    s.length >= 2 && s.charCodeAt(1) === nc && sc(s.charCodeAt(0)) && (e = i = 2);
    for (let a = s.length - 1; a >= e; --a) {
      const l = s.charCodeAt(a);
      if (dt(l)) {
        if (!o) {
          i = a + 1;
          break;
        }
        continue;
      }
      n === -1 && (o = !1, n = a + 1), l === Oc ? t === -1 ? t = a : r !== 1 && (r = 1) : t !== -1 && (r = -1);
    }
    return t === -1 || n === -1 || // We saw a non-dot character immediately before the dot
    r === 0 || // The (right-most) trimmed path component is exactly '..'
    r === 1 && t === n - 1 && t === i + 1 ? "" : s.slice(t, n);
  },
  format: aH.bind(null, "\\"),
  parse(s) {
    Di(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.length;
    let i = 0, n = s.charCodeAt(0);
    if (t === 1)
      return dt(n) ? (e.root = e.dir = s, e) : (e.base = e.name = s, e);
    if (dt(n)) {
      if (i = 1, dt(s.charCodeAt(1))) {
        let h = 2, u = h;
        for (; h < t && !dt(s.charCodeAt(h)); )
          h++;
        if (h < t && h !== u) {
          for (u = h; h < t && dt(s.charCodeAt(h)); )
            h++;
          if (h < t && h !== u) {
            for (u = h; h < t && !dt(s.charCodeAt(h)); )
              h++;
            h === t ? i = h : h !== u && (i = h + 1);
          }
        }
      }
    } else if (sc(n) && s.charCodeAt(1) === nc) {
      if (t <= 2)
        return e.root = e.dir = s, e;
      if (i = 2, dt(s.charCodeAt(2))) {
        if (t === 3)
          return e.root = e.dir = s, e;
        i = 3;
      }
    }
    i > 0 && (e.root = s.slice(0, i));
    let o = -1, r = i, a = -1, l = !0, c = s.length - 1, d = 0;
    for (; c >= i; --c) {
      if (n = s.charCodeAt(c), dt(n)) {
        if (!l) {
          r = c + 1;
          break;
        }
        continue;
      }
      a === -1 && (l = !1, a = c + 1), n === Oc ? o === -1 ? o = c : d !== 1 && (d = 1) : o !== -1 && (d = -1);
    }
    return a !== -1 && (o === -1 || // We saw a non-dot character immediately before the dot
    d === 0 || // The (right-most) trimmed path component is exactly '..'
    d === 1 && o === a - 1 && o === r + 1 ? e.base = e.name = s.slice(r, a) : (e.name = s.slice(r, o), e.base = s.slice(r, a), e.ext = s.slice(o, a))), r > 0 && r !== i ? e.dir = s.slice(0, r - 1) : e.dir = e.root, e;
  },
  sep: "\\",
  delimiter: ";",
  win32: null,
  posix: null
}, o7 = (() => {
  if (Ql) {
    const s = /\\/g;
    return () => {
      const e = $w().replace(s, "/");
      return e.slice(e.indexOf("/"));
    };
  }
  return () => $w();
})(), di = {
  // path.resolve([from ...], to)
  resolve(...s) {
    let e = "", t = !1;
    for (let i = s.length - 1; i >= -1 && !t; i--) {
      const n = i >= 0 ? s[i] : o7();
      Di(n, `paths[${i}]`), n.length !== 0 && (e = `${n}/${e}`, t = n.charCodeAt(0) === pn);
    }
    return e = Xw(e, !t, "/", Nx), t ? `/${e}` : e.length > 0 ? e : ".";
  },
  normalize(s) {
    if (Di(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === pn, t = s.charCodeAt(s.length - 1) === pn;
    return s = Xw(s, !e, "/", Nx), s.length === 0 ? e ? "/" : t ? "./" : "." : (t && (s += "/"), e ? `/${s}` : s);
  },
  isAbsolute(s) {
    return Di(s, "path"), s.length > 0 && s.charCodeAt(0) === pn;
  },
  join(...s) {
    if (s.length === 0)
      return ".";
    let e;
    for (let t = 0; t < s.length; ++t) {
      const i = s[t];
      Di(i, "path"), i.length > 0 && (e === void 0 ? e = i : e += `/${i}`);
    }
    return e === void 0 ? "." : di.normalize(e);
  },
  relative(s, e) {
    if (Di(s, "from"), Di(e, "to"), s === e || (s = di.resolve(s), e = di.resolve(e), s === e))
      return "";
    const t = 1, i = s.length, n = i - t, o = 1, r = e.length - o, a = n < r ? n : r;
    let l = -1, c = 0;
    for (; c < a; c++) {
      const h = s.charCodeAt(t + c);
      if (h !== e.charCodeAt(o + c))
        break;
      h === pn && (l = c);
    }
    if (c === a)
      if (r > a) {
        if (e.charCodeAt(o + c) === pn)
          return e.slice(o + c + 1);
        if (c === 0)
          return e.slice(o + c);
      } else n > a && (s.charCodeAt(t + c) === pn ? l = c : c === 0 && (l = 0));
    let d = "";
    for (c = t + l + 1; c <= i; ++c)
      (c === i || s.charCodeAt(c) === pn) && (d += d.length === 0 ? ".." : "/..");
    return `${d}${e.slice(o + l)}`;
  },
  toNamespacedPath(s) {
    return s;
  },
  dirname(s) {
    if (Di(s, "path"), s.length === 0)
      return ".";
    const e = s.charCodeAt(0) === pn;
    let t = -1, i = !0;
    for (let n = s.length - 1; n >= 1; --n)
      if (s.charCodeAt(n) === pn) {
        if (!i) {
          t = n;
          break;
        }
      } else
        i = !1;
    return t === -1 ? e ? "/" : "." : e && t === 1 ? "//" : s.slice(0, t);
  },
  basename(s, e) {
    e !== void 0 && Di(e, "ext"), Di(s, "path");
    let t = 0, i = -1, n = !0, o;
    if (e !== void 0 && e.length > 0 && e.length <= s.length) {
      if (e === s)
        return "";
      let r = e.length - 1, a = -1;
      for (o = s.length - 1; o >= 0; --o) {
        const l = s.charCodeAt(o);
        if (l === pn) {
          if (!n) {
            t = o + 1;
            break;
          }
        } else
          a === -1 && (n = !1, a = o + 1), r >= 0 && (l === e.charCodeAt(r) ? --r === -1 && (i = o) : (r = -1, i = a));
      }
      return t === i ? i = a : i === -1 && (i = s.length), s.slice(t, i);
    }
    for (o = s.length - 1; o >= 0; --o)
      if (s.charCodeAt(o) === pn) {
        if (!n) {
          t = o + 1;
          break;
        }
      } else i === -1 && (n = !1, i = o + 1);
    return i === -1 ? "" : s.slice(t, i);
  },
  extname(s) {
    Di(s, "path");
    let e = -1, t = 0, i = -1, n = !0, o = 0;
    for (let r = s.length - 1; r >= 0; --r) {
      const a = s.charCodeAt(r);
      if (a === pn) {
        if (!n) {
          t = r + 1;
          break;
        }
        continue;
      }
      i === -1 && (n = !1, i = r + 1), a === Oc ? e === -1 ? e = r : o !== 1 && (o = 1) : e !== -1 && (o = -1);
    }
    return e === -1 || i === -1 || // We saw a non-dot character immediately before the dot
    o === 0 || // The (right-most) trimmed path component is exactly '..'
    o === 1 && e === i - 1 && e === t + 1 ? "" : s.slice(e, i);
  },
  format: aH.bind(null, "/"),
  parse(s) {
    Di(s, "path");
    const e = { root: "", dir: "", base: "", ext: "", name: "" };
    if (s.length === 0)
      return e;
    const t = s.charCodeAt(0) === pn;
    let i;
    t ? (e.root = "/", i = 1) : i = 0;
    let n = -1, o = 0, r = -1, a = !0, l = s.length - 1, c = 0;
    for (; l >= i; --l) {
      const d = s.charCodeAt(l);
      if (d === pn) {
        if (!a) {
          o = l + 1;
          break;
        }
        continue;
      }
      r === -1 && (a = !1, r = l + 1), d === Oc ? n === -1 ? n = l : c !== 1 && (c = 1) : n !== -1 && (c = -1);
    }
    if (r !== -1) {
      const d = o === 0 && t ? 1 : o;
      n === -1 || // We saw a non-dot character immediately before the dot
      c === 0 || // The (right-most) trimmed path component is exactly '..'
      c === 1 && n === r - 1 && n === o + 1 ? e.base = e.name = s.slice(d, r) : (e.name = s.slice(d, n), e.base = s.slice(d, r), e.ext = s.slice(n, r));
    }
    return o > 0 ? e.dir = s.slice(0, o - 1) : t && (e.dir = "/"), e;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
di.win32 = $n.win32 = $n;
di.posix = $n.posix = di;
const lH = Ql ? $n.normalize : di.normalize, r7 = Ql ? $n.join : di.join, a7 = Ql ? $n.resolve : di.resolve, l7 = Ql ? $n.relative : di.relative, cH = Ql ? $n.dirname : di.dirname, Pc = Ql ? $n.basename : di.basename, c7 = Ql ? $n.extname : di.extname, Hc = Ql ? $n.sep : di.sep, d7 = /^\w[\w\d+.-]*$/, h7 = /^\//, u7 = /^\/\//;
function g7(s, e) {
  if (!s.scheme && e)
    throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${s.authority}", path: "${s.path}", query: "${s.query}", fragment: "${s.fragment}"}`);
  if (s.scheme && !d7.test(s.scheme))
    throw new Error("[UriError]: Scheme contains illegal characters.");
  if (s.path) {
    if (s.authority) {
      if (!h7.test(s.path))
        throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
    } else if (u7.test(s.path))
      throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
  }
}
function f7(s, e) {
  return !s && !e ? "file" : s;
}
function m7(s, e) {
  switch (s) {
    case "https":
    case "http":
    case "file":
      e ? e[0] !== yr && (e = yr + e) : e = yr;
      break;
  }
  return e;
}
const ai = "", yr = "/", p7 = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
class _e {
  static isUri(e) {
    return e instanceof _e ? !0 : e ? typeof e.authority == "string" && typeof e.fragment == "string" && typeof e.path == "string" && typeof e.query == "string" && typeof e.scheme == "string" && typeof e.fsPath == "string" && typeof e.with == "function" && typeof e.toString == "function" : !1;
  }
  /**
   * @internal
   */
  constructor(e, t, i, n, o, r = !1) {
    typeof e == "object" ? (this.scheme = e.scheme || ai, this.authority = e.authority || ai, this.path = e.path || ai, this.query = e.query || ai, this.fragment = e.fragment || ai) : (this.scheme = f7(e, r), this.authority = t || ai, this.path = m7(this.scheme, i || ai), this.query = n || ai, this.fragment = o || ai, g7(this, r));
  }
  // ---- filesystem path -----------------------
  /**
   * Returns a string representing the corresponding file system path of this URI.
   * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
   * platform specific path separator.
   *
   * * Will *not* validate the path for invalid characters and semantics.
   * * Will *not* look at the scheme of this URI.
   * * The result shall *not* be used for display purposes but for accessing a file on disk.
   *
   *
   * The *difference* to `URI#path` is the use of the platform specific separator and the handling
   * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
   *
   * ```ts
      const u = URI.parse('file://server/c$/folder/file.txt')
      u.authority === 'server'
      u.path === '/shares/c$/file.txt'
      u.fsPath === '\\server\c$\folder\file.txt'
  ```
   *
   * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
   * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
   * with URIs that represent files on disk (`file` scheme).
   */
  get fsPath() {
    return Zw(this, !1);
  }
  // ---- modify to new -------------------------
  with(e) {
    if (!e)
      return this;
    let { scheme: t, authority: i, path: n, query: o, fragment: r } = e;
    return t === void 0 ? t = this.scheme : t === null && (t = ai), i === void 0 ? i = this.authority : i === null && (i = ai), n === void 0 ? n = this.path : n === null && (n = ai), o === void 0 ? o = this.query : o === null && (o = ai), r === void 0 ? r = this.fragment : r === null && (r = ai), t === this.scheme && i === this.authority && n === this.path && o === this.query && r === this.fragment ? this : new sg(t, i, n, o, r);
  }
  // ---- parse & validate ------------------------
  /**
   * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,
   * `file:///usr/home`, or `scheme:with/path`.
   *
   * @param value A string which represents an URI (see `URI#toString`).
   */
  static parse(e, t = !1) {
    const i = p7.exec(e);
    return i ? new sg(i[2] || ai, ab(i[4] || ai), ab(i[5] || ai), ab(i[7] || ai), ab(i[9] || ai), t) : new sg(ai, ai, ai, ai, ai);
  }
  /**
   * Creates a new URI from a file system path, e.g. `c:\my\files`,
   * `/usr/home`, or `\\server\share\some\path`.
   *
   * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
   * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
   * `URI.parse('file://' + path)` because the path might contain characters that are
   * interpreted (# and ?). See the following sample:
   * ```ts
  const good = URI.file('/coding/c#/project1');
  good.scheme === 'file';
  good.path === '/coding/c#/project1';
  good.fragment === '';
  const bad = URI.parse('file://' + '/coding/c#/project1');
  bad.scheme === 'file';
  bad.path === '/coding/c'; // path is now broken
  bad.fragment === '/project1';
  ```
   *
   * @param path A file system path (see `URI#fsPath`)
   */
  static file(e) {
    let t = ai;
    if (yn && (e = e.replace(/\\/g, yr)), e[0] === yr && e[1] === yr) {
      const i = e.indexOf(yr, 2);
      i === -1 ? (t = e.substring(2), e = yr) : (t = e.substring(2, i), e = e.substring(i) || yr);
    }
    return new sg("file", t, e, ai, ai);
  }
  /**
   * Creates new URI from uri components.
   *
   * Unless `strict` is `true` the scheme is defaults to be `file`. This function performs
   * validation and should be used for untrusted uri components retrieved from storage,
   * user input, command arguments etc
   */
  static from(e, t) {
    return new sg(e.scheme, e.authority, e.path, e.query, e.fragment, t);
  }
  /**
   * Join a URI path with path fragments and normalizes the resulting path.
   *
   * @param uri The input URI.
   * @param pathFragment The path fragment to add to the URI path.
   * @returns The resulting URI.
   */
  static joinPath(e, ...t) {
    if (!e.path)
      throw new Error("[UriError]: cannot call joinPath on URI without path");
    let i;
    return yn && e.scheme === "file" ? i = _e.file($n.join(Zw(e, !0), ...t)).path : i = di.join(e.path, ...t), e.with({ path: i });
  }
  // ---- printing/externalize ---------------------------
  /**
   * Creates a string representation for this URI. It's guaranteed that calling
   * `URI.parse` with the result of this function creates an URI which is equal
   * to this URI.
   *
   * * The result shall *not* be used for display purposes but for externalization or transport.
   * * The result will be encoded using the percentage encoding and encoding happens mostly
   * ignore the scheme-specific encoding rules.
   *
   * @param skipEncoding Do not encode the result, default is `false`
   */
  toString(e = !1) {
    return Tx(this, e);
  }
  toJSON() {
    return this;
  }
  static revive(e) {
    if (e) {
      if (e instanceof _e)
        return e;
      {
        const t = new sg(e);
        return t._formatted = e.external ?? null, t._fsPath = e._sep === dH ? e.fsPath ?? null : null, t;
      }
    } else return e;
  }
}
const dH = yn ? 1 : void 0;
let sg = class extends _e {
  constructor() {
    super(...arguments), this._formatted = null, this._fsPath = null;
  }
  get fsPath() {
    return this._fsPath || (this._fsPath = Zw(this, !1)), this._fsPath;
  }
  toString(e = !1) {
    return e ? Tx(this, !0) : (this._formatted || (this._formatted = Tx(this, !1)), this._formatted);
  }
  toJSON() {
    const e = {
      $mid: 1
      /* MarshalledId.Uri */
    };
    return this._fsPath && (e.fsPath = this._fsPath, e._sep = dH), this._formatted && (e.external = this._formatted), this.path && (e.path = this.path), this.scheme && (e.scheme = this.scheme), this.authority && (e.authority = this.authority), this.query && (e.query = this.query), this.fragment && (e.fragment = this.fragment), e;
  }
};
const hH = {
  58: "%3A",
  // gen-delims
  47: "%2F",
  63: "%3F",
  35: "%23",
  91: "%5B",
  93: "%5D",
  64: "%40",
  33: "%21",
  // sub-delims
  36: "%24",
  38: "%26",
  39: "%27",
  40: "%28",
  41: "%29",
  42: "%2A",
  43: "%2B",
  44: "%2C",
  59: "%3B",
  61: "%3D",
  32: "%20"
};
function GB(s, e, t) {
  let i, n = -1;
  for (let o = 0; o < s.length; o++) {
    const r = s.charCodeAt(o);
    if (r >= 97 && r <= 122 || r >= 65 && r <= 90 || r >= 48 && r <= 57 || r === 45 || r === 46 || r === 95 || r === 126 || e && r === 47 || t && r === 91 || t && r === 93 || t && r === 58)
      n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i !== void 0 && (i += s.charAt(o));
    else {
      i === void 0 && (i = s.substr(0, o));
      const a = hH[r];
      a !== void 0 ? (n !== -1 && (i += encodeURIComponent(s.substring(n, o)), n = -1), i += a) : n === -1 && (n = o);
    }
  }
  return n !== -1 && (i += encodeURIComponent(s.substring(n))), i !== void 0 ? i : s;
}
function A7(s) {
  let e;
  for (let t = 0; t < s.length; t++) {
    const i = s.charCodeAt(t);
    i === 35 || i === 63 ? (e === void 0 && (e = s.substr(0, t)), e += hH[i]) : e !== void 0 && (e += s[t]);
  }
  return e !== void 0 ? e : s;
}
function Zw(s, e) {
  let t;
  return s.authority && s.path.length > 1 && s.scheme === "file" ? t = `//${s.authority}${s.path}` : s.path.charCodeAt(0) === 47 && (s.path.charCodeAt(1) >= 65 && s.path.charCodeAt(1) <= 90 || s.path.charCodeAt(1) >= 97 && s.path.charCodeAt(1) <= 122) && s.path.charCodeAt(2) === 58 ? e ? t = s.path.substr(1) : t = s.path[1].toLowerCase() + s.path.substr(2) : t = s.path, yn && (t = t.replace(/\//g, "\\")), t;
}
function Tx(s, e) {
  const t = e ? A7 : GB;
  let i = "", { scheme: n, authority: o, path: r, query: a, fragment: l } = s;
  if (n && (i += n, i += ":"), (o || n === "file") && (i += yr, i += yr), o) {
    let c = o.indexOf("@");
    if (c !== -1) {
      const d = o.substr(0, c);
      o = o.substr(c + 1), c = d.lastIndexOf(":"), c === -1 ? i += t(d, !1, !1) : (i += t(d.substr(0, c), !1, !1), i += ":", i += t(d.substr(c + 1), !1, !0)), i += "@";
    }
    o = o.toLowerCase(), c = o.lastIndexOf(":"), c === -1 ? i += t(o, !1, !0) : (i += t(o.substr(0, c), !1, !0), i += o.substr(c));
  }
  if (r) {
    if (r.length >= 3 && r.charCodeAt(0) === 47 && r.charCodeAt(2) === 58) {
      const c = r.charCodeAt(1);
      c >= 65 && c <= 90 && (r = `/${String.fromCharCode(c + 32)}:${r.substr(3)}`);
    } else if (r.length >= 2 && r.charCodeAt(1) === 58) {
      const c = r.charCodeAt(0);
      c >= 65 && c <= 90 && (r = `${String.fromCharCode(c + 32)}:${r.substr(2)}`);
    }
    i += t(r, !0, !1);
  }
  return a && (i += "?", i += t(a, !1, !1)), l && (i += "#", i += e ? l : GB(l, !1, !1)), i;
}
function uH(s) {
  try {
    return decodeURIComponent(s);
  } catch {
    return s.length > 3 ? s.substr(0, 3) + uH(s.substr(3)) : s;
  }
}
const jB = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function ab(s) {
  return s.match(jB) ? s.replace(jB, (e) => uH(e)) : s;
}
let F = class zd {
  constructor(e, t) {
    this.lineNumber = e, this.column = t;
  }
  /**
   * Create a new position from this position.
   *
   * @param newLineNumber new line number
   * @param newColumn new column
   */
  with(e = this.lineNumber, t = this.column) {
    return e === this.lineNumber && t === this.column ? this : new zd(e, t);
  }
  /**
   * Derive a new position from this position.
   *
   * @param deltaLineNumber line number delta
   * @param deltaColumn column delta
   */
  delta(e = 0, t = 0) {
    return this.with(this.lineNumber + e, this.column + t);
  }
  /**
   * Test if this position equals other position
   */
  equals(e) {
    return zd.equals(this, e);
  }
  /**
   * Test if position `a` equals position `b`
   */
  static equals(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.lineNumber === t.lineNumber && e.column === t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be false.
   */
  isBefore(e) {
    return zd.isBefore(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be false.
   */
  static isBefore(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column < t.column;
  }
  /**
   * Test if this position is before other position.
   * If the two positions are equal, the result will be true.
   */
  isBeforeOrEqual(e) {
    return zd.isBeforeOrEqual(this, e);
  }
  /**
   * Test if position `a` is before position `b`.
   * If the two positions are equal, the result will be true.
   */
  static isBeforeOrEqual(e, t) {
    return e.lineNumber < t.lineNumber ? !0 : t.lineNumber < e.lineNumber ? !1 : e.column <= t.column;
  }
  /**
   * A function that compares positions, useful for sorting
   */
  static compare(e, t) {
    const i = e.lineNumber | 0, n = t.lineNumber | 0;
    if (i === n) {
      const o = e.column | 0, r = t.column | 0;
      return o - r;
    }
    return i - n;
  }
  /**
   * Clone this position.
   */
  clone() {
    return new zd(this.lineNumber, this.column);
  }
  /**
   * Convert to a human-readable representation.
   */
  toString() {
    return "(" + this.lineNumber + "," + this.column + ")";
  }
  // ---
  /**
   * Create a `Position` from an `IPosition`.
   */
  static lift(e) {
    return new zd(e.lineNumber, e.column);
  }
  /**
   * Test if `obj` is an `IPosition`.
   */
  static isIPosition(e) {
    return e && typeof e.lineNumber == "number" && typeof e.column == "number";
  }
  toJSON() {
    return {
      lineNumber: this.lineNumber,
      column: this.column
    };
  }
}, E = class Hi {
  constructor(e, t, i, n) {
    e > i || e === i && t > n ? (this.startLineNumber = i, this.startColumn = n, this.endLineNumber = e, this.endColumn = t) : (this.startLineNumber = e, this.startColumn = t, this.endLineNumber = i, this.endColumn = n);
  }
  /**
   * Test if this range is empty.
   */
  isEmpty() {
    return Hi.isEmpty(this);
  }
  /**
   * Test if `range` is empty.
   */
  static isEmpty(e) {
    return e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn;
  }
  /**
   * Test if position is in this range. If the position is at the edges, will return true.
   */
  containsPosition(e) {
    return Hi.containsPosition(this, e);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return true.
   */
  static containsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column < e.startColumn || t.lineNumber === e.endLineNumber && t.column > e.endColumn);
  }
  /**
   * Test if `position` is in `range`. If the position is at the edges, will return false.
   * @internal
   */
  static strictContainsPosition(e, t) {
    return !(t.lineNumber < e.startLineNumber || t.lineNumber > e.endLineNumber || t.lineNumber === e.startLineNumber && t.column <= e.startColumn || t.lineNumber === e.endLineNumber && t.column >= e.endColumn);
  }
  /**
   * Test if range is in this range. If the range is equal to this range, will return true.
   */
  containsRange(e) {
    return Hi.containsRange(this, e);
  }
  /**
   * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
   */
  static containsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn < e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn > e.endColumn);
  }
  /**
   * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
   */
  strictContainsRange(e) {
    return Hi.strictContainsRange(this, e);
  }
  /**
   * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
   */
  static strictContainsRange(e, t) {
    return !(t.startLineNumber < e.startLineNumber || t.endLineNumber < e.startLineNumber || t.startLineNumber > e.endLineNumber || t.endLineNumber > e.endLineNumber || t.startLineNumber === e.startLineNumber && t.startColumn <= e.startColumn || t.endLineNumber === e.endLineNumber && t.endColumn >= e.endColumn);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  plusRange(e) {
    return Hi.plusRange(this, e);
  }
  /**
   * A reunion of the two ranges.
   * The smallest position will be used as the start point, and the largest one as the end point.
   */
  static plusRange(e, t) {
    let i, n, o, r;
    return t.startLineNumber < e.startLineNumber ? (i = t.startLineNumber, n = t.startColumn) : t.startLineNumber === e.startLineNumber ? (i = t.startLineNumber, n = Math.min(t.startColumn, e.startColumn)) : (i = e.startLineNumber, n = e.startColumn), t.endLineNumber > e.endLineNumber ? (o = t.endLineNumber, r = t.endColumn) : t.endLineNumber === e.endLineNumber ? (o = t.endLineNumber, r = Math.max(t.endColumn, e.endColumn)) : (o = e.endLineNumber, r = e.endColumn), new Hi(i, n, o, r);
  }
  /**
   * A intersection of the two ranges.
   */
  intersectRanges(e) {
    return Hi.intersectRanges(this, e);
  }
  /**
   * A intersection of the two ranges.
   */
  static intersectRanges(e, t) {
    let i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    const a = t.startLineNumber, l = t.startColumn, c = t.endLineNumber, d = t.endColumn;
    return i < a ? (i = a, n = l) : i === a && (n = Math.max(n, l)), o > c ? (o = c, r = d) : o === c && (r = Math.min(r, d)), i > o || i === o && n > r ? null : new Hi(i, n, o, r);
  }
  /**
   * Test if this range equals other.
   */
  equalsRange(e) {
    return Hi.equalsRange(this, e);
  }
  /**
   * Test if range `a` equals `b`.
   */
  static equalsRange(e, t) {
    return !e && !t ? !0 : !!e && !!t && e.startLineNumber === t.startLineNumber && e.startColumn === t.startColumn && e.endLineNumber === t.endLineNumber && e.endColumn === t.endColumn;
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  getEndPosition() {
    return Hi.getEndPosition(this);
  }
  /**
   * Return the end position (which will be after or equal to the start position)
   */
  static getEndPosition(e) {
    return new F(e.endLineNumber, e.endColumn);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  getStartPosition() {
    return Hi.getStartPosition(this);
  }
  /**
   * Return the start position (which will be before or equal to the end position)
   */
  static getStartPosition(e) {
    return new F(e.startLineNumber, e.startColumn);
  }
  /**
   * Transform to a user presentable string representation.
   */
  toString() {
    return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
  }
  /**
   * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
   */
  setEndPosition(e, t) {
    return new Hi(this.startLineNumber, this.startColumn, e, t);
  }
  /**
   * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
   */
  setStartPosition(e, t) {
    return new Hi(e, t, this.endLineNumber, this.endColumn);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  collapseToStart() {
    return Hi.collapseToStart(this);
  }
  /**
   * Create a new empty range using this range's start position.
   */
  static collapseToStart(e) {
    return new Hi(e.startLineNumber, e.startColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  collapseToEnd() {
    return Hi.collapseToEnd(this);
  }
  /**
   * Create a new empty range using this range's end position.
   */
  static collapseToEnd(e) {
    return new Hi(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn);
  }
  /**
   * Moves the range by the given amount of lines.
   */
  delta(e) {
    return new Hi(this.startLineNumber + e, this.startColumn, this.endLineNumber + e, this.endColumn);
  }
  // ---
  static fromPositions(e, t = e) {
    return new Hi(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  static lift(e) {
    return e ? new Hi(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : null;
  }
  /**
   * Test if `obj` is an `IRange`.
   */
  static isIRange(e) {
    return e && typeof e.startLineNumber == "number" && typeof e.startColumn == "number" && typeof e.endLineNumber == "number" && typeof e.endColumn == "number";
  }
  /**
   * Test if the two ranges are touching in any way.
   */
  static areIntersectingOrTouching(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn < t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn < e.startColumn);
  }
  /**
   * Test if the two ranges are intersecting. If the ranges are touching it returns true.
   */
  static areIntersecting(e, t) {
    return !(e.endLineNumber < t.startLineNumber || e.endLineNumber === t.startLineNumber && e.endColumn <= t.startColumn || t.endLineNumber < e.startLineNumber || t.endLineNumber === e.startLineNumber && t.endColumn <= e.startColumn);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the startPosition and then on the endPosition
   */
  static compareRangesUsingStarts(e, t) {
    if (e && t) {
      const o = e.startLineNumber | 0, r = t.startLineNumber | 0;
      if (o === r) {
        const a = e.startColumn | 0, l = t.startColumn | 0;
        if (a === l) {
          const c = e.endLineNumber | 0, d = t.endLineNumber | 0;
          if (c === d) {
            const h = e.endColumn | 0, u = t.endColumn | 0;
            return h - u;
          }
          return c - d;
        }
        return a - l;
      }
      return o - r;
    }
    return (e ? 1 : 0) - (t ? 1 : 0);
  }
  /**
   * A function that compares ranges, useful for sorting ranges
   * It will first compare ranges on the endPosition and then on the startPosition
   */
  static compareRangesUsingEnds(e, t) {
    return e.endLineNumber === t.endLineNumber ? e.endColumn === t.endColumn ? e.startLineNumber === t.startLineNumber ? e.startColumn - t.startColumn : e.startLineNumber - t.startLineNumber : e.endColumn - t.endColumn : e.endLineNumber - t.endLineNumber;
  }
  /**
   * Test if the range spans multiple lines.
   */
  static spansMultipleLines(e) {
    return e.endLineNumber > e.startLineNumber;
  }
  toJSON() {
    return this;
  }
}, Ue = class No extends E {
  constructor(e, t, i, n) {
    super(e, t, i, n), this.selectionStartLineNumber = e, this.selectionStartColumn = t, this.positionLineNumber = i, this.positionColumn = n;
  }
  /**
   * Transform to a human-readable representation.
   */
  toString() {
    return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
  }
  /**
   * Test if equals other selection.
   */
  equalsSelection(e) {
    return No.selectionsEqual(this, e);
  }
  /**
   * Test if the two selections are equal.
   */
  static selectionsEqual(e, t) {
    return e.selectionStartLineNumber === t.selectionStartLineNumber && e.selectionStartColumn === t.selectionStartColumn && e.positionLineNumber === t.positionLineNumber && e.positionColumn === t.positionColumn;
  }
  /**
   * Get directions (LTR or RTL).
   */
  getDirection() {
    return this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn ? 0 : 1;
  }
  /**
   * Create a new selection with a different `positionLineNumber` and `positionColumn`.
   */
  setEndPosition(e, t) {
    return this.getDirection() === 0 ? new No(this.startLineNumber, this.startColumn, e, t) : new No(e, t, this.startLineNumber, this.startColumn);
  }
  /**
   * Get the position at `positionLineNumber` and `positionColumn`.
   */
  getPosition() {
    return new F(this.positionLineNumber, this.positionColumn);
  }
  /**
   * Get the position at the start of the selection.
  */
  getSelectionStart() {
    return new F(this.selectionStartLineNumber, this.selectionStartColumn);
  }
  /**
   * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
   */
  setStartPosition(e, t) {
    return this.getDirection() === 0 ? new No(e, t, this.endLineNumber, this.endColumn) : new No(this.endLineNumber, this.endColumn, e, t);
  }
  // ----
  /**
   * Create a `Selection` from one or two positions
   */
  static fromPositions(e, t = e) {
    return new No(e.lineNumber, e.column, t.lineNumber, t.column);
  }
  /**
   * Creates a `Selection` from a range, given a direction.
   */
  static fromRange(e, t) {
    return t === 0 ? new No(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn) : new No(e.endLineNumber, e.endColumn, e.startLineNumber, e.startColumn);
  }
  /**
   * Create a `Selection` from an `ISelection`.
   */
  static liftSelection(e) {
    return new No(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
  }
  /**
   * `a` equals `b`.
   */
  static selectionsArrEqual(e, t) {
    if (e && !t || !e && t)
      return !1;
    if (!e && !t)
      return !0;
    if (e.length !== t.length)
      return !1;
    for (let i = 0, n = e.length; i < n; i++)
      if (!this.selectionsEqual(e[i], t[i]))
        return !1;
    return !0;
  }
  /**
   * Test if `obj` is an `ISelection`.
   */
  static isISelection(e) {
    return e && typeof e.selectionStartLineNumber == "number" && typeof e.selectionStartColumn == "number" && typeof e.positionLineNumber == "number" && typeof e.positionColumn == "number";
  }
  /**
   * Create with a direction.
   */
  static createWithDirection(e, t, i, n, o) {
    return o === 0 ? new No(e, t, i, n) : new No(i, n, e, t);
  }
};
const Bx = /* @__PURE__ */ Object.create(null);
function v(s, e) {
  if (_s(e)) {
    const t = Bx[e];
    if (t === void 0)
      throw new Error(`${s} references an unknown codicon: ${e}`);
    e = t;
  }
  return Bx[s] = e, { id: s };
}
function gH() {
  return Bx;
}
const _7 = {
  add: v("add", 6e4),
  plus: v("plus", 6e4),
  gistNew: v("gist-new", 6e4),
  repoCreate: v("repo-create", 6e4),
  lightbulb: v("lightbulb", 60001),
  lightBulb: v("light-bulb", 60001),
  repo: v("repo", 60002),
  repoDelete: v("repo-delete", 60002),
  gistFork: v("gist-fork", 60003),
  repoForked: v("repo-forked", 60003),
  gitPullRequest: v("git-pull-request", 60004),
  gitPullRequestAbandoned: v("git-pull-request-abandoned", 60004),
  recordKeys: v("record-keys", 60005),
  keyboard: v("keyboard", 60005),
  tag: v("tag", 60006),
  gitPullRequestLabel: v("git-pull-request-label", 60006),
  tagAdd: v("tag-add", 60006),
  tagRemove: v("tag-remove", 60006),
  person: v("person", 60007),
  personFollow: v("person-follow", 60007),
  personOutline: v("person-outline", 60007),
  personFilled: v("person-filled", 60007),
  gitBranch: v("git-branch", 60008),
  gitBranchCreate: v("git-branch-create", 60008),
  gitBranchDelete: v("git-branch-delete", 60008),
  sourceControl: v("source-control", 60008),
  mirror: v("mirror", 60009),
  mirrorPublic: v("mirror-public", 60009),
  star: v("star", 60010),
  starAdd: v("star-add", 60010),
  starDelete: v("star-delete", 60010),
  starEmpty: v("star-empty", 60010),
  comment: v("comment", 60011),
  commentAdd: v("comment-add", 60011),
  alert: v("alert", 60012),
  warning: v("warning", 60012),
  search: v("search", 60013),
  searchSave: v("search-save", 60013),
  logOut: v("log-out", 60014),
  signOut: v("sign-out", 60014),
  logIn: v("log-in", 60015),
  signIn: v("sign-in", 60015),
  eye: v("eye", 60016),
  eyeUnwatch: v("eye-unwatch", 60016),
  eyeWatch: v("eye-watch", 60016),
  circleFilled: v("circle-filled", 60017),
  primitiveDot: v("primitive-dot", 60017),
  closeDirty: v("close-dirty", 60017),
  debugBreakpoint: v("debug-breakpoint", 60017),
  debugBreakpointDisabled: v("debug-breakpoint-disabled", 60017),
  debugHint: v("debug-hint", 60017),
  terminalDecorationSuccess: v("terminal-decoration-success", 60017),
  primitiveSquare: v("primitive-square", 60018),
  edit: v("edit", 60019),
  pencil: v("pencil", 60019),
  info: v("info", 60020),
  issueOpened: v("issue-opened", 60020),
  gistPrivate: v("gist-private", 60021),
  gitForkPrivate: v("git-fork-private", 60021),
  lock: v("lock", 60021),
  mirrorPrivate: v("mirror-private", 60021),
  close: v("close", 60022),
  removeClose: v("remove-close", 60022),
  x: v("x", 60022),
  repoSync: v("repo-sync", 60023),
  sync: v("sync", 60023),
  clone: v("clone", 60024),
  desktopDownload: v("desktop-download", 60024),
  beaker: v("beaker", 60025),
  microscope: v("microscope", 60025),
  vm: v("vm", 60026),
  deviceDesktop: v("device-desktop", 60026),
  file: v("file", 60027),
  fileText: v("file-text", 60027),
  more: v("more", 60028),
  ellipsis: v("ellipsis", 60028),
  kebabHorizontal: v("kebab-horizontal", 60028),
  mailReply: v("mail-reply", 60029),
  reply: v("reply", 60029),
  organization: v("organization", 60030),
  organizationFilled: v("organization-filled", 60030),
  organizationOutline: v("organization-outline", 60030),
  newFile: v("new-file", 60031),
  fileAdd: v("file-add", 60031),
  newFolder: v("new-folder", 60032),
  fileDirectoryCreate: v("file-directory-create", 60032),
  trash: v("trash", 60033),
  trashcan: v("trashcan", 60033),
  history: v("history", 60034),
  clock: v("clock", 60034),
  folder: v("folder", 60035),
  fileDirectory: v("file-directory", 60035),
  symbolFolder: v("symbol-folder", 60035),
  logoGithub: v("logo-github", 60036),
  markGithub: v("mark-github", 60036),
  github: v("github", 60036),
  terminal: v("terminal", 60037),
  console: v("console", 60037),
  repl: v("repl", 60037),
  zap: v("zap", 60038),
  symbolEvent: v("symbol-event", 60038),
  error: v("error", 60039),
  stop: v("stop", 60039),
  variable: v("variable", 60040),
  symbolVariable: v("symbol-variable", 60040),
  array: v("array", 60042),
  symbolArray: v("symbol-array", 60042),
  symbolModule: v("symbol-module", 60043),
  symbolPackage: v("symbol-package", 60043),
  symbolNamespace: v("symbol-namespace", 60043),
  symbolObject: v("symbol-object", 60043),
  symbolMethod: v("symbol-method", 60044),
  symbolFunction: v("symbol-function", 60044),
  symbolConstructor: v("symbol-constructor", 60044),
  symbolBoolean: v("symbol-boolean", 60047),
  symbolNull: v("symbol-null", 60047),
  symbolNumeric: v("symbol-numeric", 60048),
  symbolNumber: v("symbol-number", 60048),
  symbolStructure: v("symbol-structure", 60049),
  symbolStruct: v("symbol-struct", 60049),
  symbolParameter: v("symbol-parameter", 60050),
  symbolTypeParameter: v("symbol-type-parameter", 60050),
  symbolKey: v("symbol-key", 60051),
  symbolText: v("symbol-text", 60051),
  symbolReference: v("symbol-reference", 60052),
  goToFile: v("go-to-file", 60052),
  symbolEnum: v("symbol-enum", 60053),
  symbolValue: v("symbol-value", 60053),
  symbolRuler: v("symbol-ruler", 60054),
  symbolUnit: v("symbol-unit", 60054),
  activateBreakpoints: v("activate-breakpoints", 60055),
  archive: v("archive", 60056),
  arrowBoth: v("arrow-both", 60057),
  arrowDown: v("arrow-down", 60058),
  arrowLeft: v("arrow-left", 60059),
  arrowRight: v("arrow-right", 60060),
  arrowSmallDown: v("arrow-small-down", 60061),
  arrowSmallLeft: v("arrow-small-left", 60062),
  arrowSmallRight: v("arrow-small-right", 60063),
  arrowSmallUp: v("arrow-small-up", 60064),
  arrowUp: v("arrow-up", 60065),
  bell: v("bell", 60066),
  bold: v("bold", 60067),
  book: v("book", 60068),
  bookmark: v("bookmark", 60069),
  debugBreakpointConditionalUnverified: v("debug-breakpoint-conditional-unverified", 60070),
  debugBreakpointConditional: v("debug-breakpoint-conditional", 60071),
  debugBreakpointConditionalDisabled: v("debug-breakpoint-conditional-disabled", 60071),
  debugBreakpointDataUnverified: v("debug-breakpoint-data-unverified", 60072),
  debugBreakpointData: v("debug-breakpoint-data", 60073),
  debugBreakpointDataDisabled: v("debug-breakpoint-data-disabled", 60073),
  debugBreakpointLogUnverified: v("debug-breakpoint-log-unverified", 60074),
  debugBreakpointLog: v("debug-breakpoint-log", 60075),
  debugBreakpointLogDisabled: v("debug-breakpoint-log-disabled", 60075),
  briefcase: v("briefcase", 60076),
  broadcast: v("broadcast", 60077),
  browser: v("browser", 60078),
  bug: v("bug", 60079),
  calendar: v("calendar", 60080),
  caseSensitive: v("case-sensitive", 60081),
  check: v("check", 60082),
  checklist: v("checklist", 60083),
  chevronDown: v("chevron-down", 60084),
  chevronLeft: v("chevron-left", 60085),
  chevronRight: v("chevron-right", 60086),
  chevronUp: v("chevron-up", 60087),
  chromeClose: v("chrome-close", 60088),
  chromeMaximize: v("chrome-maximize", 60089),
  chromeMinimize: v("chrome-minimize", 60090),
  chromeRestore: v("chrome-restore", 60091),
  circleOutline: v("circle-outline", 60092),
  circle: v("circle", 60092),
  debugBreakpointUnverified: v("debug-breakpoint-unverified", 60092),
  terminalDecorationIncomplete: v("terminal-decoration-incomplete", 60092),
  circleSlash: v("circle-slash", 60093),
  circuitBoard: v("circuit-board", 60094),
  clearAll: v("clear-all", 60095),
  clippy: v("clippy", 60096),
  closeAll: v("close-all", 60097),
  cloudDownload: v("cloud-download", 60098),
  cloudUpload: v("cloud-upload", 60099),
  code: v("code", 60100),
  collapseAll: v("collapse-all", 60101),
  colorMode: v("color-mode", 60102),
  commentDiscussion: v("comment-discussion", 60103),
  creditCard: v("credit-card", 60105),
  dash: v("dash", 60108),
  dashboard: v("dashboard", 60109),
  database: v("database", 60110),
  debugContinue: v("debug-continue", 60111),
  debugDisconnect: v("debug-disconnect", 60112),
  debugPause: v("debug-pause", 60113),
  debugRestart: v("debug-restart", 60114),
  debugStart: v("debug-start", 60115),
  debugStepInto: v("debug-step-into", 60116),
  debugStepOut: v("debug-step-out", 60117),
  debugStepOver: v("debug-step-over", 60118),
  debugStop: v("debug-stop", 60119),
  debug: v("debug", 60120),
  deviceCameraVideo: v("device-camera-video", 60121),
  deviceCamera: v("device-camera", 60122),
  deviceMobile: v("device-mobile", 60123),
  diffAdded: v("diff-added", 60124),
  diffIgnored: v("diff-ignored", 60125),
  diffModified: v("diff-modified", 60126),
  diffRemoved: v("diff-removed", 60127),
  diffRenamed: v("diff-renamed", 60128),
  diff: v("diff", 60129),
  diffSidebyside: v("diff-sidebyside", 60129),
  discard: v("discard", 60130),
  editorLayout: v("editor-layout", 60131),
  emptyWindow: v("empty-window", 60132),
  exclude: v("exclude", 60133),
  extensions: v("extensions", 60134),
  eyeClosed: v("eye-closed", 60135),
  fileBinary: v("file-binary", 60136),
  fileCode: v("file-code", 60137),
  fileMedia: v("file-media", 60138),
  filePdf: v("file-pdf", 60139),
  fileSubmodule: v("file-submodule", 60140),
  fileSymlinkDirectory: v("file-symlink-directory", 60141),
  fileSymlinkFile: v("file-symlink-file", 60142),
  fileZip: v("file-zip", 60143),
  files: v("files", 60144),
  filter: v("filter", 60145),
  flame: v("flame", 60146),
  foldDown: v("fold-down", 60147),
  foldUp: v("fold-up", 60148),
  fold: v("fold", 60149),
  folderActive: v("folder-active", 60150),
  folderOpened: v("folder-opened", 60151),
  gear: v("gear", 60152),
  gift: v("gift", 60153),
  gistSecret: v("gist-secret", 60154),
  gist: v("gist", 60155),
  gitCommit: v("git-commit", 60156),
  gitCompare: v("git-compare", 60157),
  compareChanges: v("compare-changes", 60157),
  gitMerge: v("git-merge", 60158),
  githubAction: v("github-action", 60159),
  githubAlt: v("github-alt", 60160),
  globe: v("globe", 60161),
  grabber: v("grabber", 60162),
  graph: v("graph", 60163),
  gripper: v("gripper", 60164),
  heart: v("heart", 60165),
  home: v("home", 60166),
  horizontalRule: v("horizontal-rule", 60167),
  hubot: v("hubot", 60168),
  inbox: v("inbox", 60169),
  issueReopened: v("issue-reopened", 60171),
  issues: v("issues", 60172),
  italic: v("italic", 60173),
  jersey: v("jersey", 60174),
  json: v("json", 60175),
  kebabVertical: v("kebab-vertical", 60176),
  key: v("key", 60177),
  law: v("law", 60178),
  lightbulbAutofix: v("lightbulb-autofix", 60179),
  linkExternal: v("link-external", 60180),
  link: v("link", 60181),
  listOrdered: v("list-ordered", 60182),
  listUnordered: v("list-unordered", 60183),
  liveShare: v("live-share", 60184),
  loading: v("loading", 60185),
  location: v("location", 60186),
  mailRead: v("mail-read", 60187),
  mail: v("mail", 60188),
  markdown: v("markdown", 60189),
  megaphone: v("megaphone", 60190),
  mention: v("mention", 60191),
  milestone: v("milestone", 60192),
  gitPullRequestMilestone: v("git-pull-request-milestone", 60192),
  mortarBoard: v("mortar-board", 60193),
  move: v("move", 60194),
  multipleWindows: v("multiple-windows", 60195),
  mute: v("mute", 60196),
  noNewline: v("no-newline", 60197),
  note: v("note", 60198),
  octoface: v("octoface", 60199),
  openPreview: v("open-preview", 60200),
  package: v("package", 60201),
  paintcan: v("paintcan", 60202),
  pin: v("pin", 60203),
  play: v("play", 60204),
  run: v("run", 60204),
  plug: v("plug", 60205),
  preserveCase: v("preserve-case", 60206),
  preview: v("preview", 60207),
  project: v("project", 60208),
  pulse: v("pulse", 60209),
  question: v("question", 60210),
  quote: v("quote", 60211),
  radioTower: v("radio-tower", 60212),
  reactions: v("reactions", 60213),
  references: v("references", 60214),
  refresh: v("refresh", 60215),
  regex: v("regex", 60216),
  remoteExplorer: v("remote-explorer", 60217),
  remote: v("remote", 60218),
  remove: v("remove", 60219),
  replaceAll: v("replace-all", 60220),
  replace: v("replace", 60221),
  repoClone: v("repo-clone", 60222),
  repoForcePush: v("repo-force-push", 60223),
  repoPull: v("repo-pull", 60224),
  repoPush: v("repo-push", 60225),
  report: v("report", 60226),
  requestChanges: v("request-changes", 60227),
  rocket: v("rocket", 60228),
  rootFolderOpened: v("root-folder-opened", 60229),
  rootFolder: v("root-folder", 60230),
  rss: v("rss", 60231),
  ruby: v("ruby", 60232),
  saveAll: v("save-all", 60233),
  saveAs: v("save-as", 60234),
  save: v("save", 60235),
  screenFull: v("screen-full", 60236),
  screenNormal: v("screen-normal", 60237),
  searchStop: v("search-stop", 60238),
  server: v("server", 60240),
  settingsGear: v("settings-gear", 60241),
  settings: v("settings", 60242),
  shield: v("shield", 60243),
  smiley: v("smiley", 60244),
  sortPrecedence: v("sort-precedence", 60245),
  splitHorizontal: v("split-horizontal", 60246),
  splitVertical: v("split-vertical", 60247),
  squirrel: v("squirrel", 60248),
  starFull: v("star-full", 60249),
  starHalf: v("star-half", 60250),
  symbolClass: v("symbol-class", 60251),
  symbolColor: v("symbol-color", 60252),
  symbolConstant: v("symbol-constant", 60253),
  symbolEnumMember: v("symbol-enum-member", 60254),
  symbolField: v("symbol-field", 60255),
  symbolFile: v("symbol-file", 60256),
  symbolInterface: v("symbol-interface", 60257),
  symbolKeyword: v("symbol-keyword", 60258),
  symbolMisc: v("symbol-misc", 60259),
  symbolOperator: v("symbol-operator", 60260),
  symbolProperty: v("symbol-property", 60261),
  wrench: v("wrench", 60261),
  wrenchSubaction: v("wrench-subaction", 60261),
  symbolSnippet: v("symbol-snippet", 60262),
  tasklist: v("tasklist", 60263),
  telescope: v("telescope", 60264),
  textSize: v("text-size", 60265),
  threeBars: v("three-bars", 60266),
  thumbsdown: v("thumbsdown", 60267),
  thumbsup: v("thumbsup", 60268),
  tools: v("tools", 60269),
  triangleDown: v("triangle-down", 60270),
  triangleLeft: v("triangle-left", 60271),
  triangleRight: v("triangle-right", 60272),
  triangleUp: v("triangle-up", 60273),
  twitter: v("twitter", 60274),
  unfold: v("unfold", 60275),
  unlock: v("unlock", 60276),
  unmute: v("unmute", 60277),
  unverified: v("unverified", 60278),
  verified: v("verified", 60279),
  versions: v("versions", 60280),
  vmActive: v("vm-active", 60281),
  vmOutline: v("vm-outline", 60282),
  vmRunning: v("vm-running", 60283),
  watch: v("watch", 60284),
  whitespace: v("whitespace", 60285),
  wholeWord: v("whole-word", 60286),
  window: v("window", 60287),
  wordWrap: v("word-wrap", 60288),
  zoomIn: v("zoom-in", 60289),
  zoomOut: v("zoom-out", 60290),
  listFilter: v("list-filter", 60291),
  listFlat: v("list-flat", 60292),
  listSelection: v("list-selection", 60293),
  selection: v("selection", 60293),
  listTree: v("list-tree", 60294),
  debugBreakpointFunctionUnverified: v("debug-breakpoint-function-unverified", 60295),
  debugBreakpointFunction: v("debug-breakpoint-function", 60296),
  debugBreakpointFunctionDisabled: v("debug-breakpoint-function-disabled", 60296),
  debugStackframeActive: v("debug-stackframe-active", 60297),
  circleSmallFilled: v("circle-small-filled", 60298),
  debugStackframeDot: v("debug-stackframe-dot", 60298),
  terminalDecorationMark: v("terminal-decoration-mark", 60298),
  debugStackframe: v("debug-stackframe", 60299),
  debugStackframeFocused: v("debug-stackframe-focused", 60299),
  debugBreakpointUnsupported: v("debug-breakpoint-unsupported", 60300),
  symbolString: v("symbol-string", 60301),
  debugReverseContinue: v("debug-reverse-continue", 60302),
  debugStepBack: v("debug-step-back", 60303),
  debugRestartFrame: v("debug-restart-frame", 60304),
  debugAlt: v("debug-alt", 60305),
  callIncoming: v("call-incoming", 60306),
  callOutgoing: v("call-outgoing", 60307),
  menu: v("menu", 60308),
  expandAll: v("expand-all", 60309),
  feedback: v("feedback", 60310),
  gitPullRequestReviewer: v("git-pull-request-reviewer", 60310),
  groupByRefType: v("group-by-ref-type", 60311),
  ungroupByRefType: v("ungroup-by-ref-type", 60312),
  account: v("account", 60313),
  gitPullRequestAssignee: v("git-pull-request-assignee", 60313),
  bellDot: v("bell-dot", 60314),
  debugConsole: v("debug-console", 60315),
  library: v("library", 60316),
  output: v("output", 60317),
  runAll: v("run-all", 60318),
  syncIgnored: v("sync-ignored", 60319),
  pinned: v("pinned", 60320),
  githubInverted: v("github-inverted", 60321),
  serverProcess: v("server-process", 60322),
  serverEnvironment: v("server-environment", 60323),
  pass: v("pass", 60324),
  issueClosed: v("issue-closed", 60324),
  stopCircle: v("stop-circle", 60325),
  playCircle: v("play-circle", 60326),
  record: v("record", 60327),
  debugAltSmall: v("debug-alt-small", 60328),
  vmConnect: v("vm-connect", 60329),
  cloud: v("cloud", 60330),
  merge: v("merge", 60331),
  export: v("export", 60332),
  graphLeft: v("graph-left", 60333),
  magnet: v("magnet", 60334),
  notebook: v("notebook", 60335),
  redo: v("redo", 60336),
  checkAll: v("check-all", 60337),
  pinnedDirty: v("pinned-dirty", 60338),
  passFilled: v("pass-filled", 60339),
  circleLargeFilled: v("circle-large-filled", 60340),
  circleLarge: v("circle-large", 60341),
  circleLargeOutline: v("circle-large-outline", 60341),
  combine: v("combine", 60342),
  gather: v("gather", 60342),
  table: v("table", 60343),
  variableGroup: v("variable-group", 60344),
  typeHierarchy: v("type-hierarchy", 60345),
  typeHierarchySub: v("type-hierarchy-sub", 60346),
  typeHierarchySuper: v("type-hierarchy-super", 60347),
  gitPullRequestCreate: v("git-pull-request-create", 60348),
  runAbove: v("run-above", 60349),
  runBelow: v("run-below", 60350),
  notebookTemplate: v("notebook-template", 60351),
  debugRerun: v("debug-rerun", 60352),
  workspaceTrusted: v("workspace-trusted", 60353),
  workspaceUntrusted: v("workspace-untrusted", 60354),
  workspaceUnknown: v("workspace-unknown", 60355),
  terminalCmd: v("terminal-cmd", 60356),
  terminalDebian: v("terminal-debian", 60357),
  terminalLinux: v("terminal-linux", 60358),
  terminalPowershell: v("terminal-powershell", 60359),
  terminalTmux: v("terminal-tmux", 60360),
  terminalUbuntu: v("terminal-ubuntu", 60361),
  terminalBash: v("terminal-bash", 60362),
  arrowSwap: v("arrow-swap", 60363),
  copy: v("copy", 60364),
  personAdd: v("person-add", 60365),
  filterFilled: v("filter-filled", 60366),
  wand: v("wand", 60367),
  debugLineByLine: v("debug-line-by-line", 60368),
  inspect: v("inspect", 60369),
  layers: v("layers", 60370),
  layersDot: v("layers-dot", 60371),
  layersActive: v("layers-active", 60372),
  compass: v("compass", 60373),
  compassDot: v("compass-dot", 60374),
  compassActive: v("compass-active", 60375),
  azure: v("azure", 60376),
  issueDraft: v("issue-draft", 60377),
  gitPullRequestClosed: v("git-pull-request-closed", 60378),
  gitPullRequestDraft: v("git-pull-request-draft", 60379),
  debugAll: v("debug-all", 60380),
  debugCoverage: v("debug-coverage", 60381),
  runErrors: v("run-errors", 60382),
  folderLibrary: v("folder-library", 60383),
  debugContinueSmall: v("debug-continue-small", 60384),
  beakerStop: v("beaker-stop", 60385),
  graphLine: v("graph-line", 60386),
  graphScatter: v("graph-scatter", 60387),
  pieChart: v("pie-chart", 60388),
  bracket: v("bracket", 60175),
  bracketDot: v("bracket-dot", 60389),
  bracketError: v("bracket-error", 60390),
  lockSmall: v("lock-small", 60391),
  azureDevops: v("azure-devops", 60392),
  verifiedFilled: v("verified-filled", 60393),
  newline: v("newline", 60394),
  layout: v("layout", 60395),
  layoutActivitybarLeft: v("layout-activitybar-left", 60396),
  layoutActivitybarRight: v("layout-activitybar-right", 60397),
  layoutPanelLeft: v("layout-panel-left", 60398),
  layoutPanelCenter: v("layout-panel-center", 60399),
  layoutPanelJustify: v("layout-panel-justify", 60400),
  layoutPanelRight: v("layout-panel-right", 60401),
  layoutPanel: v("layout-panel", 60402),
  layoutSidebarLeft: v("layout-sidebar-left", 60403),
  layoutSidebarRight: v("layout-sidebar-right", 60404),
  layoutStatusbar: v("layout-statusbar", 60405),
  layoutMenubar: v("layout-menubar", 60406),
  layoutCentered: v("layout-centered", 60407),
  target: v("target", 60408),
  indent: v("indent", 60409),
  recordSmall: v("record-small", 60410),
  errorSmall: v("error-small", 60411),
  terminalDecorationError: v("terminal-decoration-error", 60411),
  arrowCircleDown: v("arrow-circle-down", 60412),
  arrowCircleLeft: v("arrow-circle-left", 60413),
  arrowCircleRight: v("arrow-circle-right", 60414),
  arrowCircleUp: v("arrow-circle-up", 60415),
  layoutSidebarRightOff: v("layout-sidebar-right-off", 60416),
  layoutPanelOff: v("layout-panel-off", 60417),
  layoutSidebarLeftOff: v("layout-sidebar-left-off", 60418),
  blank: v("blank", 60419),
  heartFilled: v("heart-filled", 60420),
  map: v("map", 60421),
  mapHorizontal: v("map-horizontal", 60421),
  foldHorizontal: v("fold-horizontal", 60421),
  mapFilled: v("map-filled", 60422),
  mapHorizontalFilled: v("map-horizontal-filled", 60422),
  foldHorizontalFilled: v("fold-horizontal-filled", 60422),
  circleSmall: v("circle-small", 60423),
  bellSlash: v("bell-slash", 60424),
  bellSlashDot: v("bell-slash-dot", 60425),
  commentUnresolved: v("comment-unresolved", 60426),
  gitPullRequestGoToChanges: v("git-pull-request-go-to-changes", 60427),
  gitPullRequestNewChanges: v("git-pull-request-new-changes", 60428),
  searchFuzzy: v("search-fuzzy", 60429),
  commentDraft: v("comment-draft", 60430),
  send: v("send", 60431),
  sparkle: v("sparkle", 60432),
  insert: v("insert", 60433),
  mic: v("mic", 60434),
  thumbsdownFilled: v("thumbsdown-filled", 60435),
  thumbsupFilled: v("thumbsup-filled", 60436),
  coffee: v("coffee", 60437),
  snake: v("snake", 60438),
  game: v("game", 60439),
  vr: v("vr", 60440),
  chip: v("chip", 60441),
  piano: v("piano", 60442),
  music: v("music", 60443),
  micFilled: v("mic-filled", 60444),
  repoFetch: v("repo-fetch", 60445),
  copilot: v("copilot", 60446),
  lightbulbSparkle: v("lightbulb-sparkle", 60447),
  robot: v("robot", 60448),
  sparkleFilled: v("sparkle-filled", 60449),
  diffSingle: v("diff-single", 60450),
  diffMultiple: v("diff-multiple", 60451),
  surroundWith: v("surround-with", 60452),
  share: v("share", 60453),
  gitStash: v("git-stash", 60454),
  gitStashApply: v("git-stash-apply", 60455),
  gitStashPop: v("git-stash-pop", 60456),
  vscode: v("vscode", 60457),
  vscodeInsiders: v("vscode-insiders", 60458),
  codeOss: v("code-oss", 60459),
  runCoverage: v("run-coverage", 60460),
  runAllCoverage: v("run-all-coverage", 60461),
  coverage: v("coverage", 60462),
  githubProject: v("github-project", 60463),
  mapVertical: v("map-vertical", 60464),
  foldVertical: v("fold-vertical", 60464),
  mapVerticalFilled: v("map-vertical-filled", 60465),
  foldVerticalFilled: v("fold-vertical-filled", 60465),
  goToSearch: v("go-to-search", 60466),
  percentage: v("percentage", 60467),
  sortPercentage: v("sort-percentage", 60467),
  attach: v("attach", 60468)
}, b7 = {
  dialogError: v("dialog-error", "error"),
  dialogWarning: v("dialog-warning", "warning"),
  dialogInfo: v("dialog-info", "info"),
  dialogClose: v("dialog-close", "close"),
  treeItemExpanded: v("tree-item-expanded", "chevron-down"),
  // collapsed is done with rotation
  treeFilterOnTypeOn: v("tree-filter-on-type-on", "list-filter"),
  treeFilterOnTypeOff: v("tree-filter-on-type-off", "list-selection"),
  treeFilterClear: v("tree-filter-clear", "close"),
  treeItemLoading: v("tree-item-loading", "loading"),
  menuSelection: v("menu-selection", "check"),
  menuSubmenu: v("menu-submenu", "chevron-right"),
  menuBarMore: v("menubar-more", "more"),
  scrollbarButtonLeft: v("scrollbar-button-left", "triangle-left"),
  scrollbarButtonRight: v("scrollbar-button-right", "triangle-right"),
  scrollbarButtonUp: v("scrollbar-button-up", "triangle-up"),
  scrollbarButtonDown: v("scrollbar-button-down", "triangle-down"),
  toolBarMore: v("toolbar-more", "more"),
  quickInputBack: v("quick-input-back", "arrow-left"),
  dropDownButton: v("drop-down-button", 60084),
  symbolCustomColor: v("symbol-customcolor", 60252),
  exportIcon: v("export", 60332),
  workspaceUnspecified: v("workspace-unspecified", 60355),
  newLine: v("newline", 60394),
  thumbsDownFilled: v("thumbsdown-filled", 60435),
  thumbsUpFilled: v("thumbsup-filled", 60436),
  gitFetch: v("git-fetch", 60445),
  lightbulbSparkleAutofix: v("lightbulb-sparkle-autofix", 60447),
  debugBreakpointPending: v("debug-breakpoint-pending", 60377)
}, Z = {
  ..._7,
  ...b7
};
let fH = class {
  constructor() {
    this._tokenizationSupports = /* @__PURE__ */ new Map(), this._factories = /* @__PURE__ */ new Map(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._colorMap = null;
  }
  handleChange(e) {
    this._onDidChange.fire({
      changedLanguages: e,
      changedColorMap: !1
    });
  }
  register(e, t) {
    return this._tokenizationSupports.set(e, t), this.handleChange([e]), we(() => {
      this._tokenizationSupports.get(e) === t && (this._tokenizationSupports.delete(e), this.handleChange([e]));
    });
  }
  get(e) {
    return this._tokenizationSupports.get(e) || null;
  }
  registerFactory(e, t) {
    this._factories.get(e)?.dispose();
    const i = new w7(this, e, t);
    return this._factories.set(e, i), we(() => {
      const n = this._factories.get(e);
      !n || n !== i || (this._factories.delete(e), n.dispose());
    });
  }
  async getOrCreate(e) {
    const t = this.get(e);
    if (t)
      return t;
    const i = this._factories.get(e);
    return !i || i.isResolved ? null : (await i.resolve(), this.get(e));
  }
  isResolved(e) {
    if (this.get(e))
      return !0;
    const i = this._factories.get(e);
    return !!(!i || i.isResolved);
  }
  setColorMap(e) {
    this._colorMap = e, this._onDidChange.fire({
      changedLanguages: Array.from(this._tokenizationSupports.keys()),
      changedColorMap: !0
    });
  }
  getColorMap() {
    return this._colorMap;
  }
  getDefaultBackground() {
    return this._colorMap && this._colorMap.length > 2 ? this._colorMap[
      2
      /* ColorId.DefaultBackground */
    ] : null;
  }
};
class w7 extends V {
  get isResolved() {
    return this._isResolved;
  }
  constructor(e, t, i) {
    super(), this._registry = e, this._languageId = t, this._factory = i, this._isDisposed = !1, this._resolvePromise = null, this._isResolved = !1;
  }
  dispose() {
    this._isDisposed = !0, super.dispose();
  }
  async resolve() {
    return this._resolvePromise || (this._resolvePromise = this._create()), this._resolvePromise;
  }
  async _create() {
    const e = await this._factory.tokenizationSupport;
    this._isResolved = !0, e && !this._isDisposed && this._register(this._registry.register(this._languageId, e));
  }
}
let xA = class {
  constructor(e, t, i) {
    this.offset = e, this.type = t, this.language = i, this._tokenBrand = void 0;
  }
  toString() {
    return "(" + this.offset + ", " + this.type + ")";
  }
};
class BM {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._tokenizationResultBrand = void 0;
  }
}
class A0 {
  constructor(e, t) {
    this.tokens = e, this.endState = t, this._encodedTokenizationResultBrand = void 0;
  }
}
var fs;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(fs || (fs = {}));
var EA;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, Z.symbolMethod), e.set(1, Z.symbolFunction), e.set(2, Z.symbolConstructor), e.set(3, Z.symbolField), e.set(4, Z.symbolVariable), e.set(5, Z.symbolClass), e.set(6, Z.symbolStruct), e.set(7, Z.symbolInterface), e.set(8, Z.symbolModule), e.set(9, Z.symbolProperty), e.set(10, Z.symbolEvent), e.set(11, Z.symbolOperator), e.set(12, Z.symbolUnit), e.set(13, Z.symbolValue), e.set(15, Z.symbolEnum), e.set(14, Z.symbolConstant), e.set(15, Z.symbolEnum), e.set(16, Z.symbolEnumMember), e.set(17, Z.symbolKeyword), e.set(27, Z.symbolSnippet), e.set(18, Z.symbolText), e.set(19, Z.symbolColor), e.set(20, Z.symbolFile), e.set(21, Z.symbolReference), e.set(22, Z.symbolCustomColor), e.set(23, Z.symbolFolder), e.set(24, Z.symbolTypeParameter), e.set(25, Z.account), e.set(26, Z.issues);
  function t(o) {
    let r = e.get(o);
    return r || (console.info("No codicon found for CompletionItemKind " + o), r = Z.symbolProperty), r;
  }
  s.toIcon = t;
  const i = /* @__PURE__ */ new Map();
  i.set(
    "method",
    0
    /* CompletionItemKind.Method */
  ), i.set(
    "function",
    1
    /* CompletionItemKind.Function */
  ), i.set(
    "constructor",
    2
    /* CompletionItemKind.Constructor */
  ), i.set(
    "field",
    3
    /* CompletionItemKind.Field */
  ), i.set(
    "variable",
    4
    /* CompletionItemKind.Variable */
  ), i.set(
    "class",
    5
    /* CompletionItemKind.Class */
  ), i.set(
    "struct",
    6
    /* CompletionItemKind.Struct */
  ), i.set(
    "interface",
    7
    /* CompletionItemKind.Interface */
  ), i.set(
    "module",
    8
    /* CompletionItemKind.Module */
  ), i.set(
    "property",
    9
    /* CompletionItemKind.Property */
  ), i.set(
    "event",
    10
    /* CompletionItemKind.Event */
  ), i.set(
    "operator",
    11
    /* CompletionItemKind.Operator */
  ), i.set(
    "unit",
    12
    /* CompletionItemKind.Unit */
  ), i.set(
    "value",
    13
    /* CompletionItemKind.Value */
  ), i.set(
    "constant",
    14
    /* CompletionItemKind.Constant */
  ), i.set(
    "enum",
    15
    /* CompletionItemKind.Enum */
  ), i.set(
    "enum-member",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "enumMember",
    16
    /* CompletionItemKind.EnumMember */
  ), i.set(
    "keyword",
    17
    /* CompletionItemKind.Keyword */
  ), i.set(
    "snippet",
    27
    /* CompletionItemKind.Snippet */
  ), i.set(
    "text",
    18
    /* CompletionItemKind.Text */
  ), i.set(
    "color",
    19
    /* CompletionItemKind.Color */
  ), i.set(
    "file",
    20
    /* CompletionItemKind.File */
  ), i.set(
    "reference",
    21
    /* CompletionItemKind.Reference */
  ), i.set(
    "customcolor",
    22
    /* CompletionItemKind.Customcolor */
  ), i.set(
    "folder",
    23
    /* CompletionItemKind.Folder */
  ), i.set(
    "type-parameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "typeParameter",
    24
    /* CompletionItemKind.TypeParameter */
  ), i.set(
    "account",
    25
    /* CompletionItemKind.User */
  ), i.set(
    "issue",
    26
    /* CompletionItemKind.Issue */
  );
  function n(o, r) {
    let a = i.get(o);
    return typeof a > "u" && !r && (a = 9), a;
  }
  s.fromString = n;
})(EA || (EA = {}));
var Rx;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(Rx || (Rx = {}));
class C7 {
  constructor(e, t, i, n) {
    this.range = e, this.text = t, this.completionKind = i, this.isSnippetText = n;
  }
  equals(e) {
    return E.lift(this.range).equalsRange(e.range) && this.text === e.text && this.completionKind === e.completionKind && this.isSnippetText === e.isSnippetText;
  }
}
var YB;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.PasteAs = 1] = "PasteAs";
})(YB || (YB = {}));
var wa;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(wa || (wa = {}));
var KB;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(KB || (KB = {}));
function v7(s) {
  return s && _e.isUri(s.uri) && E.isIRange(s.range) && (E.isIRange(s.originSelectionRange) || E.isIRange(s.targetSelectionRange));
}
f("Array", "array"), f("Boolean", "boolean"), f("Class", "class"), f("Constant", "constant"), f("Constructor", "constructor"), f("Enum", "enumeration"), f("EnumMember", "enumeration member"), f("Event", "event"), f("Field", "field"), f("File", "file"), f("Function", "function"), f("Interface", "interface"), f("Key", "key"), f("Method", "method"), f("Module", "module"), f("Namespace", "namespace"), f("Null", "null"), f("Number", "number"), f("Object", "object"), f("Operator", "operator"), f("Package", "package"), f("Property", "property"), f("String", "string"), f("Struct", "struct"), f("TypeParameter", "type parameter"), f("Variable", "variable");
var Fx;
(function(s) {
  const e = /* @__PURE__ */ new Map();
  e.set(0, Z.symbolFile), e.set(1, Z.symbolModule), e.set(2, Z.symbolNamespace), e.set(3, Z.symbolPackage), e.set(4, Z.symbolClass), e.set(5, Z.symbolMethod), e.set(6, Z.symbolProperty), e.set(7, Z.symbolField), e.set(8, Z.symbolConstructor), e.set(9, Z.symbolEnum), e.set(10, Z.symbolInterface), e.set(11, Z.symbolFunction), e.set(12, Z.symbolVariable), e.set(13, Z.symbolConstant), e.set(14, Z.symbolString), e.set(15, Z.symbolNumber), e.set(16, Z.symbolBoolean), e.set(17, Z.symbolArray), e.set(18, Z.symbolObject), e.set(19, Z.symbolKey), e.set(20, Z.symbolNull), e.set(21, Z.symbolEnumMember), e.set(22, Z.symbolStruct), e.set(23, Z.symbolEvent), e.set(24, Z.symbolOperator), e.set(25, Z.symbolTypeParameter);
  function t(i) {
    let n = e.get(i);
    return n || (console.info("No codicon found for SymbolKind " + i), n = Z.symbolProperty), n;
  }
  s.toIcon = t;
})(Fx || (Fx = {}));
const Bo = class Bo {
  /**
   * Returns a {@link FoldingRangeKind} for the given value.
   *
   * @param value of the kind.
   */
  static fromValue(e) {
    switch (e) {
      case "comment":
        return Bo.Comment;
      case "imports":
        return Bo.Imports;
      case "region":
        return Bo.Region;
    }
    return new Bo(e);
  }
  /**
   * Creates a new {@link FoldingRangeKind}.
   *
   * @param value of the kind.
   */
  constructor(e) {
    this.value = e;
  }
};
Bo.Comment = new Bo("comment"), Bo.Imports = new Bo("imports"), Bo.Region = new Bo("region");
let nd = Bo;
var JB;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(JB || (JB = {}));
var qB;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(qB || (qB = {}));
var Ox;
(function(s) {
  function e(t) {
    return !t || typeof t != "object" ? !1 : typeof t.id == "string" && typeof t.title == "string";
  }
  s.is = e;
})(Ox || (Ox = {}));
var eC;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(eC || (eC = {}));
class S7 {
  constructor(e) {
    this.createSupport = e, this._tokenizationSupport = null;
  }
  dispose() {
    this._tokenizationSupport && this._tokenizationSupport.then((e) => {
      e && e.dispose();
    });
  }
  get tokenizationSupport() {
    return this._tokenizationSupport || (this._tokenizationSupport = this.createSupport()), this._tokenizationSupport;
  }
}
const ci = new fH(), Px = new fH();
var $B;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})($B || ($B = {}));
var Hx;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Disabled = 1] = "Disabled", s[s.Enabled = 2] = "Enabled";
})(Hx || (Hx = {}));
var Wx;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.Auto = 2] = "Auto";
})(Wx || (Wx = {}));
var Vx;
(function(s) {
  s[s.None = 0] = "None", s[s.KeepWhitespace = 1] = "KeepWhitespace", s[s.InsertAsSnippet = 4] = "InsertAsSnippet";
})(Vx || (Vx = {}));
var zx;
(function(s) {
  s[s.Method = 0] = "Method", s[s.Function = 1] = "Function", s[s.Constructor = 2] = "Constructor", s[s.Field = 3] = "Field", s[s.Variable = 4] = "Variable", s[s.Class = 5] = "Class", s[s.Struct = 6] = "Struct", s[s.Interface = 7] = "Interface", s[s.Module = 8] = "Module", s[s.Property = 9] = "Property", s[s.Event = 10] = "Event", s[s.Operator = 11] = "Operator", s[s.Unit = 12] = "Unit", s[s.Value = 13] = "Value", s[s.Constant = 14] = "Constant", s[s.Enum = 15] = "Enum", s[s.EnumMember = 16] = "EnumMember", s[s.Keyword = 17] = "Keyword", s[s.Text = 18] = "Text", s[s.Color = 19] = "Color", s[s.File = 20] = "File", s[s.Reference = 21] = "Reference", s[s.Customcolor = 22] = "Customcolor", s[s.Folder = 23] = "Folder", s[s.TypeParameter = 24] = "TypeParameter", s[s.User = 25] = "User", s[s.Issue = 26] = "Issue", s[s.Snippet = 27] = "Snippet";
})(zx || (zx = {}));
var Ux;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(Ux || (Ux = {}));
var Qx;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.TriggerCharacter = 1] = "TriggerCharacter", s[s.TriggerForIncompleteCompletions = 2] = "TriggerForIncompleteCompletions";
})(Qx || (Qx = {}));
var Gx;
(function(s) {
  s[s.EXACT = 0] = "EXACT", s[s.ABOVE = 1] = "ABOVE", s[s.BELOW = 2] = "BELOW";
})(Gx || (Gx = {}));
var jx;
(function(s) {
  s[s.NotSet = 0] = "NotSet", s[s.ContentFlush = 1] = "ContentFlush", s[s.RecoverFromMarkers = 2] = "RecoverFromMarkers", s[s.Explicit = 3] = "Explicit", s[s.Paste = 4] = "Paste", s[s.Undo = 5] = "Undo", s[s.Redo = 6] = "Redo";
})(jx || (jx = {}));
var Yx;
(function(s) {
  s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})(Yx || (Yx = {}));
var Kx;
(function(s) {
  s[s.Text = 0] = "Text", s[s.Read = 1] = "Read", s[s.Write = 2] = "Write";
})(Kx || (Kx = {}));
var Jx;
(function(s) {
  s[s.None = 0] = "None", s[s.Keep = 1] = "Keep", s[s.Brackets = 2] = "Brackets", s[s.Advanced = 3] = "Advanced", s[s.Full = 4] = "Full";
})(Jx || (Jx = {}));
var qx;
(function(s) {
  s[s.acceptSuggestionOnCommitCharacter = 0] = "acceptSuggestionOnCommitCharacter", s[s.acceptSuggestionOnEnter = 1] = "acceptSuggestionOnEnter", s[s.accessibilitySupport = 2] = "accessibilitySupport", s[s.accessibilityPageSize = 3] = "accessibilityPageSize", s[s.ariaLabel = 4] = "ariaLabel", s[s.ariaRequired = 5] = "ariaRequired", s[s.autoClosingBrackets = 6] = "autoClosingBrackets", s[s.autoClosingComments = 7] = "autoClosingComments", s[s.screenReaderAnnounceInlineSuggestion = 8] = "screenReaderAnnounceInlineSuggestion", s[s.autoClosingDelete = 9] = "autoClosingDelete", s[s.autoClosingOvertype = 10] = "autoClosingOvertype", s[s.autoClosingQuotes = 11] = "autoClosingQuotes", s[s.autoIndent = 12] = "autoIndent", s[s.automaticLayout = 13] = "automaticLayout", s[s.autoSurround = 14] = "autoSurround", s[s.bracketPairColorization = 15] = "bracketPairColorization", s[s.guides = 16] = "guides", s[s.codeLens = 17] = "codeLens", s[s.codeLensFontFamily = 18] = "codeLensFontFamily", s[s.codeLensFontSize = 19] = "codeLensFontSize", s[s.colorDecorators = 20] = "colorDecorators", s[s.colorDecoratorsLimit = 21] = "colorDecoratorsLimit", s[s.columnSelection = 22] = "columnSelection", s[s.comments = 23] = "comments", s[s.contextmenu = 24] = "contextmenu", s[s.copyWithSyntaxHighlighting = 25] = "copyWithSyntaxHighlighting", s[s.cursorBlinking = 26] = "cursorBlinking", s[s.cursorSmoothCaretAnimation = 27] = "cursorSmoothCaretAnimation", s[s.cursorStyle = 28] = "cursorStyle", s[s.cursorSurroundingLines = 29] = "cursorSurroundingLines", s[s.cursorSurroundingLinesStyle = 30] = "cursorSurroundingLinesStyle", s[s.cursorWidth = 31] = "cursorWidth", s[s.disableLayerHinting = 32] = "disableLayerHinting", s[s.disableMonospaceOptimizations = 33] = "disableMonospaceOptimizations", s[s.domReadOnly = 34] = "domReadOnly", s[s.dragAndDrop = 35] = "dragAndDrop", s[s.dropIntoEditor = 36] = "dropIntoEditor", s[s.emptySelectionClipboard = 37] = "emptySelectionClipboard", s[s.experimentalWhitespaceRendering = 38] = "experimentalWhitespaceRendering", s[s.extraEditorClassName = 39] = "extraEditorClassName", s[s.fastScrollSensitivity = 40] = "fastScrollSensitivity", s[s.find = 41] = "find", s[s.fixedOverflowWidgets = 42] = "fixedOverflowWidgets", s[s.folding = 43] = "folding", s[s.foldingStrategy = 44] = "foldingStrategy", s[s.foldingHighlight = 45] = "foldingHighlight", s[s.foldingImportsByDefault = 46] = "foldingImportsByDefault", s[s.foldingMaximumRegions = 47] = "foldingMaximumRegions", s[s.unfoldOnClickAfterEndOfLine = 48] = "unfoldOnClickAfterEndOfLine", s[s.fontFamily = 49] = "fontFamily", s[s.fontInfo = 50] = "fontInfo", s[s.fontLigatures = 51] = "fontLigatures", s[s.fontSize = 52] = "fontSize", s[s.fontWeight = 53] = "fontWeight", s[s.fontVariations = 54] = "fontVariations", s[s.formatOnPaste = 55] = "formatOnPaste", s[s.formatOnType = 56] = "formatOnType", s[s.glyphMargin = 57] = "glyphMargin", s[s.gotoLocation = 58] = "gotoLocation", s[s.hideCursorInOverviewRuler = 59] = "hideCursorInOverviewRuler", s[s.hover = 60] = "hover", s[s.inDiffEditor = 61] = "inDiffEditor", s[s.inlineSuggest = 62] = "inlineSuggest", s[s.inlineEdit = 63] = "inlineEdit", s[s.letterSpacing = 64] = "letterSpacing", s[s.lightbulb = 65] = "lightbulb", s[s.lineDecorationsWidth = 66] = "lineDecorationsWidth", s[s.lineHeight = 67] = "lineHeight", s[s.lineNumbers = 68] = "lineNumbers", s[s.lineNumbersMinChars = 69] = "lineNumbersMinChars", s[s.linkedEditing = 70] = "linkedEditing", s[s.links = 71] = "links", s[s.matchBrackets = 72] = "matchBrackets", s[s.minimap = 73] = "minimap", s[s.mouseStyle = 74] = "mouseStyle", s[s.mouseWheelScrollSensitivity = 75] = "mouseWheelScrollSensitivity", s[s.mouseWheelZoom = 76] = "mouseWheelZoom", s[s.multiCursorMergeOverlapping = 77] = "multiCursorMergeOverlapping", s[s.multiCursorModifier = 78] = "multiCursorModifier", s[s.multiCursorPaste = 79] = "multiCursorPaste", s[s.multiCursorLimit = 80] = "multiCursorLimit", s[s.occurrencesHighlight = 81] = "occurrencesHighlight", s[s.overviewRulerBorder = 82] = "overviewRulerBorder", s[s.overviewRulerLanes = 83] = "overviewRulerLanes", s[s.padding = 84] = "padding", s[s.pasteAs = 85] = "pasteAs", s[s.parameterHints = 86] = "parameterHints", s[s.peekWidgetDefaultFocus = 87] = "peekWidgetDefaultFocus", s[s.placeholder = 88] = "placeholder", s[s.definitionLinkOpensInPeek = 89] = "definitionLinkOpensInPeek", s[s.quickSuggestions = 90] = "quickSuggestions", s[s.quickSuggestionsDelay = 91] = "quickSuggestionsDelay", s[s.readOnly = 92] = "readOnly", s[s.readOnlyMessage = 93] = "readOnlyMessage", s[s.renameOnType = 94] = "renameOnType", s[s.renderControlCharacters = 95] = "renderControlCharacters", s[s.renderFinalNewline = 96] = "renderFinalNewline", s[s.renderLineHighlight = 97] = "renderLineHighlight", s[s.renderLineHighlightOnlyWhenFocus = 98] = "renderLineHighlightOnlyWhenFocus", s[s.renderValidationDecorations = 99] = "renderValidationDecorations", s[s.renderWhitespace = 100] = "renderWhitespace", s[s.revealHorizontalRightPadding = 101] = "revealHorizontalRightPadding", s[s.roundedSelection = 102] = "roundedSelection", s[s.rulers = 103] = "rulers", s[s.scrollbar = 104] = "scrollbar", s[s.scrollBeyondLastColumn = 105] = "scrollBeyondLastColumn", s[s.scrollBeyondLastLine = 106] = "scrollBeyondLastLine", s[s.scrollPredominantAxis = 107] = "scrollPredominantAxis", s[s.selectionClipboard = 108] = "selectionClipboard", s[s.selectionHighlight = 109] = "selectionHighlight", s[s.selectOnLineNumbers = 110] = "selectOnLineNumbers", s[s.showFoldingControls = 111] = "showFoldingControls", s[s.showUnused = 112] = "showUnused", s[s.snippetSuggestions = 113] = "snippetSuggestions", s[s.smartSelect = 114] = "smartSelect", s[s.smoothScrolling = 115] = "smoothScrolling", s[s.stickyScroll = 116] = "stickyScroll", s[s.stickyTabStops = 117] = "stickyTabStops", s[s.stopRenderingLineAfter = 118] = "stopRenderingLineAfter", s[s.suggest = 119] = "suggest", s[s.suggestFontSize = 120] = "suggestFontSize", s[s.suggestLineHeight = 121] = "suggestLineHeight", s[s.suggestOnTriggerCharacters = 122] = "suggestOnTriggerCharacters", s[s.suggestSelection = 123] = "suggestSelection", s[s.tabCompletion = 124] = "tabCompletion", s[s.tabIndex = 125] = "tabIndex", s[s.unicodeHighlighting = 126] = "unicodeHighlighting", s[s.unusualLineTerminators = 127] = "unusualLineTerminators", s[s.useShadowDOM = 128] = "useShadowDOM", s[s.useTabStops = 129] = "useTabStops", s[s.wordBreak = 130] = "wordBreak", s[s.wordSegmenterLocales = 131] = "wordSegmenterLocales", s[s.wordSeparators = 132] = "wordSeparators", s[s.wordWrap = 133] = "wordWrap", s[s.wordWrapBreakAfterCharacters = 134] = "wordWrapBreakAfterCharacters", s[s.wordWrapBreakBeforeCharacters = 135] = "wordWrapBreakBeforeCharacters", s[s.wordWrapColumn = 136] = "wordWrapColumn", s[s.wordWrapOverride1 = 137] = "wordWrapOverride1", s[s.wordWrapOverride2 = 138] = "wordWrapOverride2", s[s.wrappingIndent = 139] = "wrappingIndent", s[s.wrappingStrategy = 140] = "wrappingStrategy", s[s.showDeprecated = 141] = "showDeprecated", s[s.inlayHints = 142] = "inlayHints", s[s.editorClassName = 143] = "editorClassName", s[s.pixelRatio = 144] = "pixelRatio", s[s.tabFocusMode = 145] = "tabFocusMode", s[s.layoutInfo = 146] = "layoutInfo", s[s.wrappingInfo = 147] = "wrappingInfo", s[s.defaultColorDecorators = 148] = "defaultColorDecorators", s[s.colorDecoratorsActivatedOn = 149] = "colorDecoratorsActivatedOn", s[s.inlineCompletionsAccessibilityVerbose = 150] = "inlineCompletionsAccessibilityVerbose";
})(qx || (qx = {}));
var $x;
(function(s) {
  s[s.TextDefined = 0] = "TextDefined", s[s.LF = 1] = "LF", s[s.CRLF = 2] = "CRLF";
})($x || ($x = {}));
var Xx;
(function(s) {
  s[s.LF = 0] = "LF", s[s.CRLF = 1] = "CRLF";
})(Xx || (Xx = {}));
var Zx;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(Zx || (Zx = {}));
var eE;
(function(s) {
  s[s.Increase = 0] = "Increase", s[s.Decrease = 1] = "Decrease";
})(eE || (eE = {}));
var tE;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(tE || (tE = {}));
var iE;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(iE || (iE = {}));
var nE;
(function(s) {
  s[s.Type = 1] = "Type", s[s.Parameter = 2] = "Parameter";
})(nE || (nE = {}));
var sE;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Explicit = 1] = "Explicit";
})(sE || (sE = {}));
var oE;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(oE || (oE = {}));
var rE;
(function(s) {
  s[s.DependsOnKbLayout = -1] = "DependsOnKbLayout", s[s.Unknown = 0] = "Unknown", s[s.Backspace = 1] = "Backspace", s[s.Tab = 2] = "Tab", s[s.Enter = 3] = "Enter", s[s.Shift = 4] = "Shift", s[s.Ctrl = 5] = "Ctrl", s[s.Alt = 6] = "Alt", s[s.PauseBreak = 7] = "PauseBreak", s[s.CapsLock = 8] = "CapsLock", s[s.Escape = 9] = "Escape", s[s.Space = 10] = "Space", s[s.PageUp = 11] = "PageUp", s[s.PageDown = 12] = "PageDown", s[s.End = 13] = "End", s[s.Home = 14] = "Home", s[s.LeftArrow = 15] = "LeftArrow", s[s.UpArrow = 16] = "UpArrow", s[s.RightArrow = 17] = "RightArrow", s[s.DownArrow = 18] = "DownArrow", s[s.Insert = 19] = "Insert", s[s.Delete = 20] = "Delete", s[s.Digit0 = 21] = "Digit0", s[s.Digit1 = 22] = "Digit1", s[s.Digit2 = 23] = "Digit2", s[s.Digit3 = 24] = "Digit3", s[s.Digit4 = 25] = "Digit4", s[s.Digit5 = 26] = "Digit5", s[s.Digit6 = 27] = "Digit6", s[s.Digit7 = 28] = "Digit7", s[s.Digit8 = 29] = "Digit8", s[s.Digit9 = 30] = "Digit9", s[s.KeyA = 31] = "KeyA", s[s.KeyB = 32] = "KeyB", s[s.KeyC = 33] = "KeyC", s[s.KeyD = 34] = "KeyD", s[s.KeyE = 35] = "KeyE", s[s.KeyF = 36] = "KeyF", s[s.KeyG = 37] = "KeyG", s[s.KeyH = 38] = "KeyH", s[s.KeyI = 39] = "KeyI", s[s.KeyJ = 40] = "KeyJ", s[s.KeyK = 41] = "KeyK", s[s.KeyL = 42] = "KeyL", s[s.KeyM = 43] = "KeyM", s[s.KeyN = 44] = "KeyN", s[s.KeyO = 45] = "KeyO", s[s.KeyP = 46] = "KeyP", s[s.KeyQ = 47] = "KeyQ", s[s.KeyR = 48] = "KeyR", s[s.KeyS = 49] = "KeyS", s[s.KeyT = 50] = "KeyT", s[s.KeyU = 51] = "KeyU", s[s.KeyV = 52] = "KeyV", s[s.KeyW = 53] = "KeyW", s[s.KeyX = 54] = "KeyX", s[s.KeyY = 55] = "KeyY", s[s.KeyZ = 56] = "KeyZ", s[s.Meta = 57] = "Meta", s[s.ContextMenu = 58] = "ContextMenu", s[s.F1 = 59] = "F1", s[s.F2 = 60] = "F2", s[s.F3 = 61] = "F3", s[s.F4 = 62] = "F4", s[s.F5 = 63] = "F5", s[s.F6 = 64] = "F6", s[s.F7 = 65] = "F7", s[s.F8 = 66] = "F8", s[s.F9 = 67] = "F9", s[s.F10 = 68] = "F10", s[s.F11 = 69] = "F11", s[s.F12 = 70] = "F12", s[s.F13 = 71] = "F13", s[s.F14 = 72] = "F14", s[s.F15 = 73] = "F15", s[s.F16 = 74] = "F16", s[s.F17 = 75] = "F17", s[s.F18 = 76] = "F18", s[s.F19 = 77] = "F19", s[s.F20 = 78] = "F20", s[s.F21 = 79] = "F21", s[s.F22 = 80] = "F22", s[s.F23 = 81] = "F23", s[s.F24 = 82] = "F24", s[s.NumLock = 83] = "NumLock", s[s.ScrollLock = 84] = "ScrollLock", s[s.Semicolon = 85] = "Semicolon", s[s.Equal = 86] = "Equal", s[s.Comma = 87] = "Comma", s[s.Minus = 88] = "Minus", s[s.Period = 89] = "Period", s[s.Slash = 90] = "Slash", s[s.Backquote = 91] = "Backquote", s[s.BracketLeft = 92] = "BracketLeft", s[s.Backslash = 93] = "Backslash", s[s.BracketRight = 94] = "BracketRight", s[s.Quote = 95] = "Quote", s[s.OEM_8 = 96] = "OEM_8", s[s.IntlBackslash = 97] = "IntlBackslash", s[s.Numpad0 = 98] = "Numpad0", s[s.Numpad1 = 99] = "Numpad1", s[s.Numpad2 = 100] = "Numpad2", s[s.Numpad3 = 101] = "Numpad3", s[s.Numpad4 = 102] = "Numpad4", s[s.Numpad5 = 103] = "Numpad5", s[s.Numpad6 = 104] = "Numpad6", s[s.Numpad7 = 105] = "Numpad7", s[s.Numpad8 = 106] = "Numpad8", s[s.Numpad9 = 107] = "Numpad9", s[s.NumpadMultiply = 108] = "NumpadMultiply", s[s.NumpadAdd = 109] = "NumpadAdd", s[s.NUMPAD_SEPARATOR = 110] = "NUMPAD_SEPARATOR", s[s.NumpadSubtract = 111] = "NumpadSubtract", s[s.NumpadDecimal = 112] = "NumpadDecimal", s[s.NumpadDivide = 113] = "NumpadDivide", s[s.KEY_IN_COMPOSITION = 114] = "KEY_IN_COMPOSITION", s[s.ABNT_C1 = 115] = "ABNT_C1", s[s.ABNT_C2 = 116] = "ABNT_C2", s[s.AudioVolumeMute = 117] = "AudioVolumeMute", s[s.AudioVolumeUp = 118] = "AudioVolumeUp", s[s.AudioVolumeDown = 119] = "AudioVolumeDown", s[s.BrowserSearch = 120] = "BrowserSearch", s[s.BrowserHome = 121] = "BrowserHome", s[s.BrowserBack = 122] = "BrowserBack", s[s.BrowserForward = 123] = "BrowserForward", s[s.MediaTrackNext = 124] = "MediaTrackNext", s[s.MediaTrackPrevious = 125] = "MediaTrackPrevious", s[s.MediaStop = 126] = "MediaStop", s[s.MediaPlayPause = 127] = "MediaPlayPause", s[s.LaunchMediaPlayer = 128] = "LaunchMediaPlayer", s[s.LaunchMail = 129] = "LaunchMail", s[s.LaunchApp2 = 130] = "LaunchApp2", s[s.Clear = 131] = "Clear", s[s.MAX_VALUE = 132] = "MAX_VALUE";
})(rE || (rE = {}));
var aE;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(aE || (aE = {}));
var lE;
(function(s) {
  s[s.Unnecessary = 1] = "Unnecessary", s[s.Deprecated = 2] = "Deprecated";
})(lE || (lE = {}));
var cE;
(function(s) {
  s[s.Inline = 1] = "Inline", s[s.Gutter = 2] = "Gutter";
})(cE || (cE = {}));
var dE;
(function(s) {
  s[s.Normal = 1] = "Normal", s[s.Underlined = 2] = "Underlined";
})(dE || (dE = {}));
var hE;
(function(s) {
  s[s.UNKNOWN = 0] = "UNKNOWN", s[s.TEXTAREA = 1] = "TEXTAREA", s[s.GUTTER_GLYPH_MARGIN = 2] = "GUTTER_GLYPH_MARGIN", s[s.GUTTER_LINE_NUMBERS = 3] = "GUTTER_LINE_NUMBERS", s[s.GUTTER_LINE_DECORATIONS = 4] = "GUTTER_LINE_DECORATIONS", s[s.GUTTER_VIEW_ZONE = 5] = "GUTTER_VIEW_ZONE", s[s.CONTENT_TEXT = 6] = "CONTENT_TEXT", s[s.CONTENT_EMPTY = 7] = "CONTENT_EMPTY", s[s.CONTENT_VIEW_ZONE = 8] = "CONTENT_VIEW_ZONE", s[s.CONTENT_WIDGET = 9] = "CONTENT_WIDGET", s[s.OVERVIEW_RULER = 10] = "OVERVIEW_RULER", s[s.SCROLLBAR = 11] = "SCROLLBAR", s[s.OVERLAY_WIDGET = 12] = "OVERLAY_WIDGET", s[s.OUTSIDE_EDITOR = 13] = "OUTSIDE_EDITOR";
})(hE || (hE = {}));
var uE;
(function(s) {
  s[s.AIGenerated = 1] = "AIGenerated";
})(uE || (uE = {}));
var gE;
(function(s) {
  s[s.Invoke = 0] = "Invoke", s[s.Automatic = 1] = "Automatic";
})(gE || (gE = {}));
var fE;
(function(s) {
  s[s.TOP_RIGHT_CORNER = 0] = "TOP_RIGHT_CORNER", s[s.BOTTOM_RIGHT_CORNER = 1] = "BOTTOM_RIGHT_CORNER", s[s.TOP_CENTER = 2] = "TOP_CENTER";
})(fE || (fE = {}));
var mE;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(mE || (mE = {}));
var pE;
(function(s) {
  s[s.Word = 0] = "Word", s[s.Line = 1] = "Line", s[s.Suggest = 2] = "Suggest";
})(pE || (pE = {}));
var AE;
(function(s) {
  s[s.Left = 0] = "Left", s[s.Right = 1] = "Right", s[s.None = 2] = "None", s[s.LeftOfInjectedText = 3] = "LeftOfInjectedText", s[s.RightOfInjectedText = 4] = "RightOfInjectedText";
})(AE || (AE = {}));
var _E;
(function(s) {
  s[s.Off = 0] = "Off", s[s.On = 1] = "On", s[s.Relative = 2] = "Relative", s[s.Interval = 3] = "Interval", s[s.Custom = 4] = "Custom";
})(_E || (_E = {}));
var bE;
(function(s) {
  s[s.None = 0] = "None", s[s.Text = 1] = "Text", s[s.Blocks = 2] = "Blocks";
})(bE || (bE = {}));
var wE;
(function(s) {
  s[s.Smooth = 0] = "Smooth", s[s.Immediate = 1] = "Immediate";
})(wE || (wE = {}));
var CE;
(function(s) {
  s[s.Auto = 1] = "Auto", s[s.Hidden = 2] = "Hidden", s[s.Visible = 3] = "Visible";
})(CE || (CE = {}));
var vE;
(function(s) {
  s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL";
})(vE || (vE = {}));
var SE;
(function(s) {
  s.Off = "off", s.OnCode = "onCode", s.On = "on";
})(SE || (SE = {}));
var yE;
(function(s) {
  s[s.Invoke = 1] = "Invoke", s[s.TriggerCharacter = 2] = "TriggerCharacter", s[s.ContentChange = 3] = "ContentChange";
})(yE || (yE = {}));
var xE;
(function(s) {
  s[s.File = 0] = "File", s[s.Module = 1] = "Module", s[s.Namespace = 2] = "Namespace", s[s.Package = 3] = "Package", s[s.Class = 4] = "Class", s[s.Method = 5] = "Method", s[s.Property = 6] = "Property", s[s.Field = 7] = "Field", s[s.Constructor = 8] = "Constructor", s[s.Enum = 9] = "Enum", s[s.Interface = 10] = "Interface", s[s.Function = 11] = "Function", s[s.Variable = 12] = "Variable", s[s.Constant = 13] = "Constant", s[s.String = 14] = "String", s[s.Number = 15] = "Number", s[s.Boolean = 16] = "Boolean", s[s.Array = 17] = "Array", s[s.Object = 18] = "Object", s[s.Key = 19] = "Key", s[s.Null = 20] = "Null", s[s.EnumMember = 21] = "EnumMember", s[s.Struct = 22] = "Struct", s[s.Event = 23] = "Event", s[s.Operator = 24] = "Operator", s[s.TypeParameter = 25] = "TypeParameter";
})(xE || (xE = {}));
var EE;
(function(s) {
  s[s.Deprecated = 1] = "Deprecated";
})(EE || (EE = {}));
var LE;
(function(s) {
  s[s.Hidden = 0] = "Hidden", s[s.Blink = 1] = "Blink", s[s.Smooth = 2] = "Smooth", s[s.Phase = 3] = "Phase", s[s.Expand = 4] = "Expand", s[s.Solid = 5] = "Solid";
})(LE || (LE = {}));
var kE;
(function(s) {
  s[s.Line = 1] = "Line", s[s.Block = 2] = "Block", s[s.Underline = 3] = "Underline", s[s.LineThin = 4] = "LineThin", s[s.BlockOutline = 5] = "BlockOutline", s[s.UnderlineThin = 6] = "UnderlineThin";
})(kE || (kE = {}));
var DE;
(function(s) {
  s[s.AlwaysGrowsWhenTypingAtEdges = 0] = "AlwaysGrowsWhenTypingAtEdges", s[s.NeverGrowsWhenTypingAtEdges = 1] = "NeverGrowsWhenTypingAtEdges", s[s.GrowsOnlyWhenTypingBefore = 2] = "GrowsOnlyWhenTypingBefore", s[s.GrowsOnlyWhenTypingAfter = 3] = "GrowsOnlyWhenTypingAfter";
})(DE || (DE = {}));
var IE;
(function(s) {
  s[s.None = 0] = "None", s[s.Same = 1] = "Same", s[s.Indent = 2] = "Indent", s[s.DeepIndent = 3] = "DeepIndent";
})(IE || (IE = {}));
var El;
let y7 = (El = class {
  static chord(e, t) {
    return Qi(e, t);
  }
}, El.CtrlCmd = 2048, El.Shift = 1024, El.Alt = 512, El.WinCtrl = 256, El);
function mH() {
  return {
    editor: void 0,
    // undefined override expected here
    languages: void 0,
    // undefined override expected here
    CancellationTokenSource: vs,
    Emitter: B,
    KeyCode: rE,
    KeyMod: y7,
    Position: F,
    Range: E,
    Selection: Ue,
    SelectionDirection: vE,
    MarkerSeverity: aE,
    MarkerTag: lE,
    Uri: _e,
    Token: xA
  };
}
function x7(s, e) {
  const t = s;
  typeof t.vscodeWindowId != "number" && Object.defineProperty(t, "vscodeWindowId", {
    get: () => e
  });
}
const vt = window;
function pH(s) {
  return s;
}
class E7 {
  constructor(e, t) {
    this.lastCache = void 0, this.lastArgKey = void 0, typeof e == "function" ? (this._fn = e, this._computeKey = pH) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    return this.lastArgKey !== t && (this.lastArgKey = t, this.lastCache = this._fn(e)), this.lastCache;
  }
}
class XB {
  get cachedValues() {
    return this._map;
  }
  constructor(e, t) {
    this._map = /* @__PURE__ */ new Map(), this._map2 = /* @__PURE__ */ new Map(), typeof e == "function" ? (this._fn = e, this._computeKey = pH) : (this._fn = t, this._computeKey = e.getCacheKey);
  }
  get(e) {
    const t = this._computeKey(e);
    if (this._map2.has(t))
      return this._map2.get(t);
    const i = this._fn(e);
    return this._map.set(e, i), this._map2.set(t, i), i;
  }
}
class Br {
  constructor(e) {
    this.executor = e, this._didRun = !1;
  }
  /**
   * Get the wrapped value.
   *
   * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
   * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
   */
  get value() {
    if (!this._didRun)
      try {
        this._value = this.executor();
      } catch (e) {
        this._error = e;
      } finally {
        this._didRun = !0;
      }
    if (this._error)
      throw this._error;
    return this._value;
  }
  /**
   * Get the wrapped value without forcing evaluation.
   */
  get rawValue() {
    return this._value;
  }
}
function AH(s) {
  return !s || typeof s != "string" ? !0 : s.trim().length === 0;
}
const L7 = /{(\d+)}/g;
function Vf(s, ...e) {
  return e.length === 0 ? s : s.replace(L7, function(t, i) {
    const n = parseInt(i, 10);
    return isNaN(n) || n < 0 || n >= e.length ? t : e[n];
  });
}
function k7(s) {
  return s.replace(/[<>"'&]/g, (e) => {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case '"':
        return "&quot;";
      case "'":
        return "&apos;";
      case "&":
        return "&amp;";
    }
    return e;
  });
}
function Ip(s) {
  return s.replace(/[<>&]/g, function(e) {
    switch (e) {
      case "<":
        return "&lt;";
      case ">":
        return "&gt;";
      case "&":
        return "&amp;";
      default:
        return e;
    }
  });
}
function So(s) {
  return s.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function _0(s, e) {
  if (!s || !e)
    return s;
  const t = e.length;
  if (t === 0 || s.length === 0)
    return s;
  let i = 0;
  for (; s.indexOf(e, i) === i; )
    i = i + t;
  return s.substring(i);
}
function D7(s, e) {
  if (!s || !e)
    return s;
  const t = e.length, i = s.length;
  if (t === 0 || i === 0)
    return s;
  let n = i, o = -1;
  for (; o = s.lastIndexOf(e, n - 1), !(o === -1 || o + t !== n); ) {
    if (o === 0)
      return "";
    n = o;
  }
  return s.substring(0, n);
}
function I7(s) {
  return s.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, "\\$&").replace(/[\*]/g, ".*");
}
function _H(s, e, t = {}) {
  if (!s)
    throw new Error("Cannot create regex from empty string");
  e || (s = So(s)), t.wholeWord && (/\B/.test(s.charAt(0)) || (s = "\\b" + s), /\B/.test(s.charAt(s.length - 1)) || (s = s + "\\b"));
  let i = "";
  return t.global && (i += "g"), t.matchCase || (i += "i"), t.multiline && (i += "m"), t.unicode && (i += "u"), new RegExp(s, i);
}
function M7(s) {
  return s.source === "^" || s.source === "^$" || s.source === "$" || s.source === "^\\s*$" ? !1 : !!(s.exec("") && s.lastIndex === 0);
}
function bd(s) {
  return s.split(/\r\n|\r|\n/);
}
function Sn(s) {
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i !== 32 && i !== 9)
      return e;
  }
  return -1;
}
function Ii(s, e = 0, t = s.length) {
  for (let i = e; i < t; i++) {
    const n = s.charCodeAt(i);
    if (n !== 32 && n !== 9)
      return s.substring(e, i);
  }
  return s.substring(e, t);
}
function Ru(s, e = s.length - 1) {
  for (let t = e; t >= 0; t--) {
    const i = s.charCodeAt(t);
    if (i !== 32 && i !== 9)
      return t;
  }
  return -1;
}
function LA(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function RM(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    const l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l < c)
      return -1;
    if (l > c)
      return 1;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function ME(s, e) {
  return D_(s, e, 0, s.length, 0, e.length);
}
function D_(s, e, t = 0, i = s.length, n = 0, o = e.length) {
  for (; t < i && n < o; t++, n++) {
    let l = s.charCodeAt(t), c = e.charCodeAt(n);
    if (l === c)
      continue;
    if (l >= 128 || c >= 128)
      return RM(s.toLowerCase(), e.toLowerCase(), t, i, n, o);
    Ig(l) && (l -= 32), Ig(c) && (c -= 32);
    const d = l - c;
    if (d !== 0)
      return d;
  }
  const r = i - t, a = o - n;
  return r < a ? -1 : r > a ? 1 : 0;
}
function lb(s) {
  return s >= 48 && s <= 57;
}
function Ig(s) {
  return s >= 97 && s <= 122;
}
function hc(s) {
  return s >= 65 && s <= 90;
}
function Mg(s, e) {
  return s.length === e.length && D_(s, e) === 0;
}
function FM(s, e) {
  const t = e.length;
  return e.length > s.length ? !1 : D_(s, e, 0, t) === 0;
}
function kA(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(i) !== e.charCodeAt(i))
      return i;
  return t;
}
function NE(s, e) {
  const t = Math.min(s.length, e.length);
  let i;
  const n = s.length - 1, o = e.length - 1;
  for (i = 0; i < t; i++)
    if (s.charCodeAt(n - i) !== e.charCodeAt(o - i))
      return i;
  return t;
}
function Si(s) {
  return 55296 <= s && s <= 56319;
}
function gu(s) {
  return 56320 <= s && s <= 57343;
}
function OM(s, e) {
  return (s - 55296 << 10) + (e - 56320) + 65536;
}
function tC(s, e, t) {
  const i = s.charCodeAt(t);
  if (Si(i) && t + 1 < e) {
    const n = s.charCodeAt(t + 1);
    if (gu(n))
      return OM(i, n);
  }
  return i;
}
function N7(s, e) {
  const t = s.charCodeAt(e - 1);
  if (gu(t) && e > 1) {
    const i = s.charCodeAt(e - 2);
    if (Si(i))
      return OM(i, t);
  }
  return t;
}
class PM {
  get offset() {
    return this._offset;
  }
  constructor(e, t = 0) {
    this._str = e, this._len = e.length, this._offset = t;
  }
  setOffset(e) {
    this._offset = e;
  }
  prevCodePoint() {
    const e = N7(this._str, this._offset);
    return this._offset -= e >= 65536 ? 2 : 1, e;
  }
  nextCodePoint() {
    const e = tC(this._str, this._len, this._offset);
    return this._offset += e >= 65536 ? 2 : 1, e;
  }
  eol() {
    return this._offset >= this._len;
  }
}
class iC {
  get offset() {
    return this._iterator.offset;
  }
  constructor(e, t = 0) {
    this._iterator = new PM(e, t);
  }
  nextGraphemeLength() {
    const e = nC.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.nextCodePoint());
    for (; !t.eol(); ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.nextCodePoint());
      if (ZB(n, r)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return t.offset - i;
  }
  prevGraphemeLength() {
    const e = nC.getInstance(), t = this._iterator, i = t.offset;
    let n = e.getGraphemeBreakType(t.prevCodePoint());
    for (; t.offset > 0; ) {
      const o = t.offset, r = e.getGraphemeBreakType(t.prevCodePoint());
      if (ZB(r, n)) {
        t.setOffset(o);
        break;
      }
      n = r;
    }
    return i - t.offset;
  }
  eol() {
    return this._iterator.eol();
  }
}
function HM(s, e) {
  return new iC(s, e).nextGraphemeLength();
}
function bH(s, e) {
  return new iC(s, e).prevGraphemeLength();
}
function T7(s, e) {
  e > 0 && gu(s.charCodeAt(e)) && e--;
  const t = e + HM(s, e);
  return [t - bH(s, t), t];
}
let GS;
function B7() {
  return /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA\u07FE-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u088E\u08A0-\u08C9\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDC7\uFDF0-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE35\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDD23\uDE80-\uDEA9\uDEAD-\uDF45\uDF51-\uDF81\uDF86-\uDFF6]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD4B-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
}
function DA(s) {
  return GS || (GS = B7()), GS.test(s);
}
const R7 = /^[\t\n\r\x20-\x7E]*$/;
function WM(s) {
  return R7.test(s);
}
const wH = /[\u2028\u2029]/;
function CH(s) {
  return wH.test(s);
}
function sd(s) {
  return s >= 11904 && s <= 55215 || s >= 63744 && s <= 64255 || s >= 65281 && s <= 65374;
}
function VM(s) {
  return s >= 127462 && s <= 127487 || s === 8986 || s === 8987 || s === 9200 || s === 9203 || s >= 9728 && s <= 10175 || s === 11088 || s === 11093 || s >= 127744 && s <= 128591 || s >= 128640 && s <= 128764 || s >= 128992 && s <= 129008 || s >= 129280 && s <= 129535 || s >= 129648 && s <= 129782;
}
const F7 = "\uFEFF";
function zM(s) {
  return !!(s && s.length > 0 && s.charCodeAt(0) === 65279);
}
function O7(s, e = !1) {
  return s ? (e && (s = s.replace(/\\./g, "")), s.toLowerCase() !== s) : !1;
}
function vH(s) {
  return s = s % (2 * 26), s < 26 ? String.fromCharCode(97 + s) : String.fromCharCode(65 + s - 26);
}
function ZB(s, e) {
  return s === 0 ? e !== 5 && e !== 7 : s === 2 && e === 3 ? !1 : s === 4 || s === 2 || s === 3 || e === 4 || e === 2 || e === 3 ? !0 : !(s === 8 && (e === 8 || e === 9 || e === 11 || e === 12) || (s === 11 || s === 9) && (e === 9 || e === 10) || (s === 12 || s === 10) && e === 10 || e === 5 || e === 13 || e === 7 || s === 1 || s === 13 && e === 14 || s === 6 && e === 6);
}
const hh = class hh {
  static getInstance() {
    return hh._INSTANCE || (hh._INSTANCE = new hh()), hh._INSTANCE;
  }
  constructor() {
    this._data = P7();
  }
  getGraphemeBreakType(e) {
    if (e < 32)
      return e === 10 ? 3 : e === 13 ? 2 : 4;
    if (e < 127)
      return 0;
    const t = this._data, i = t.length / 3;
    let n = 1;
    for (; n <= i; )
      if (e < t[3 * n])
        n = 2 * n;
      else if (e > t[3 * n + 1])
        n = 2 * n + 1;
      else
        return t[3 * n + 2];
    return 0;
  }
};
hh._INSTANCE = null;
let nC = hh;
function P7() {
  return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
function H7(s, e) {
  if (s === 0)
    return 0;
  const t = W7(s, e);
  if (t !== void 0)
    return t;
  const i = new PM(e, s);
  return i.prevCodePoint(), i.offset;
}
function W7(s, e) {
  const t = new PM(e, s);
  let i = t.prevCodePoint();
  for (; V7(i) || i === 65039 || i === 8419; ) {
    if (t.offset === 0)
      return;
    i = t.prevCodePoint();
  }
  if (!VM(i))
    return;
  let n = t.offset;
  return n > 0 && t.prevCodePoint() === 8205 && (n = t.offset), n;
}
function V7(s) {
  return 127995 <= s && s <= 127999;
}
const z7 = " ", ia = class ia {
  static getInstance(e) {
    return ia.cache.get(Array.from(e));
  }
  static getLocales() {
    return ia._locales.value;
  }
  constructor(e) {
    this.confusableDictionary = e;
  }
  isAmbiguous(e) {
    return this.confusableDictionary.has(e);
  }
  /**
   * Returns the non basic ASCII code point that the given code point can be confused,
   * or undefined if such code point does note exist.
   */
  getPrimaryConfusable(e) {
    return this.confusableDictionary.get(e);
  }
  getConfusableCodePoints() {
    return new Set(this.confusableDictionary.keys());
  }
};
ia.ambiguousCharacterData = new Br(() => JSON.parse('{"_common":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125,119846,109],"_default":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"cs":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"de":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"es":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"fr":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"it":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ja":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],"ko":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pl":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"pt-BR":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"qps-ploc":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"ru":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"tr":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],"zh-hans":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],"zh-hant":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}')), ia.cache = new E7({ getCacheKey: JSON.stringify }, (e) => {
  function t(d) {
    const h = /* @__PURE__ */ new Map();
    for (let u = 0; u < d.length; u += 2)
      h.set(d[u], d[u + 1]);
    return h;
  }
  function i(d, h) {
    const u = new Map(d);
    for (const [g, m] of h)
      u.set(g, m);
    return u;
  }
  function n(d, h) {
    if (!d)
      return h;
    const u = /* @__PURE__ */ new Map();
    for (const [g, m] of d)
      h.has(g) && u.set(g, m);
    return u;
  }
  const o = ia.ambiguousCharacterData.value;
  let r = e.filter((d) => !d.startsWith("_") && d in o);
  r.length === 0 && (r = ["_default"]);
  let a;
  for (const d of r) {
    const h = t(o[d]);
    a = n(a, h);
  }
  const l = t(o._common), c = i(l, a);
  return new ia(c);
}), ia._locales = new Br(() => Object.keys(ia.ambiguousCharacterData.value).filter((e) => !e.startsWith("_")));
let IA = ia;
const Xg = class Xg {
  static getRawData() {
    return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
  }
  static getData() {
    return this._data || (this._data = new Set(Xg.getRawData())), this._data;
  }
  static isInvisibleCharacter(e) {
    return Xg.getData().has(e);
  }
  static get codePoints() {
    return Xg.getData();
  }
};
Xg._data = void 0;
let Mp = Xg;
const g1 = class g1 {
  constructor() {
    this.mapWindowIdToZoomFactor = /* @__PURE__ */ new Map();
  }
  getZoomFactor(e) {
    return this.mapWindowIdToZoomFactor.get(this.getWindowId(e)) ?? 1;
  }
  getWindowId(e) {
    return e.vscodeWindowId;
  }
};
g1.INSTANCE = new g1();
let TE = g1;
function SH(s, e, t) {
  typeof e == "string" && (e = s.matchMedia(e)), e.addEventListener("change", t);
}
function U7(s) {
  return TE.INSTANCE.getZoomFactor(s);
}
const _m = navigator.userAgent, Ko = _m.indexOf("Firefox") >= 0, b0 = _m.indexOf("AppleWebKit") >= 0, I_ = _m.indexOf("Chrome") >= 0, od = !I_ && _m.indexOf("Safari") >= 0, yH = !I_ && !od && b0;
_m.indexOf("Electron/") >= 0;
const eR = _m.indexOf("Android") >= 0;
let jS = !1;
if (typeof vt.matchMedia == "function") {
  const s = vt.matchMedia("(display-mode: standalone) or (display-mode: window-controls-overlay)"), e = vt.matchMedia("(display-mode: fullscreen)");
  jS = s.matches, SH(vt, s, ({ matches: t }) => {
    jS && e.matches || (jS = t);
  });
}
const UM = {
  clipboard: {
    writeText: vA || document.queryCommandSupported && document.queryCommandSupported("copy") || !!(navigator && navigator.clipboard && navigator.clipboard.writeText),
    readText: vA || !!(navigator && navigator.clipboard && navigator.clipboard.readText)
  },
  pointerEvents: vt.PointerEvent && ("ontouchstart" in vt || navigator.maxTouchPoints > 0)
};
function BE(s, e) {
  if (typeof s == "number") {
    if (s === 0)
      return null;
    const t = (s & 65535) >>> 0, i = (s & 4294901760) >>> 16;
    return i !== 0 ? new YS([
      cb(t, e),
      cb(i, e)
    ]) : new YS([cb(t, e)]);
  } else {
    const t = [];
    for (let i = 0; i < s.length; i++)
      t.push(cb(s[i], e));
    return new YS(t);
  }
}
function cb(s, e) {
  const t = !!(s & 2048), i = !!(s & 256), n = e === 2 ? i : t, o = !!(s & 1024), r = !!(s & 512), a = e === 2 ? t : i, l = s & 255;
  return new Hl(n, o, r, a, l);
}
class Hl {
  constructor(e, t, i, n, o) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyCode = o;
  }
  equals(e) {
    return e instanceof Hl && this.ctrlKey === e.ctrlKey && this.shiftKey === e.shiftKey && this.altKey === e.altKey && this.metaKey === e.metaKey && this.keyCode === e.keyCode;
  }
  isModifierKey() {
    return this.keyCode === 0 || this.keyCode === 5 || this.keyCode === 57 || this.keyCode === 6 || this.keyCode === 4;
  }
  /**
   * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
   */
  isDuplicateModifierCase() {
    return this.ctrlKey && this.keyCode === 5 || this.shiftKey && this.keyCode === 4 || this.altKey && this.keyCode === 6 || this.metaKey && this.keyCode === 57;
  }
}
class YS {
  constructor(e) {
    if (e.length === 0)
      throw Go("chords");
    this.chords = e;
  }
}
class Q7 {
  constructor(e, t, i, n, o, r) {
    this.ctrlKey = e, this.shiftKey = t, this.altKey = i, this.metaKey = n, this.keyLabel = o, this.keyAriaLabel = r;
  }
}
class G7 {
}
function j7(s) {
  if (s.charCode) {
    const t = String.fromCharCode(s.charCode).toUpperCase();
    return ul.fromString(t);
  }
  const e = s.keyCode;
  if (e === 3)
    return 7;
  if (Ko)
    switch (e) {
      case 59:
        return 85;
      case 60:
        if (Fn)
          return 97;
        break;
      case 61:
        return 86;
      case 107:
        return 109;
      case 109:
        return 111;
      case 173:
        return 88;
      case 224:
        if (ze)
          return 57;
        break;
    }
  else if (b0) {
    if (ze && e === 93)
      return 57;
    if (!ze && e === 92)
      return 57;
  }
  return oH[e] || 0;
}
const Y7 = ze ? 256 : 2048, K7 = 512, J7 = 1024, q7 = ze ? 2048 : 256;
class Mt {
  constructor(e) {
    this._standardKeyboardEventBrand = !0;
    const t = e;
    this.browserEvent = t, this.target = t.target, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, this.altGraphKey = t.getModifierState?.("AltGraph"), this.keyCode = j7(t), this.code = t.code, this.ctrlKey = this.ctrlKey || this.keyCode === 5, this.altKey = this.altKey || this.keyCode === 6, this.shiftKey = this.shiftKey || this.keyCode === 4, this.metaKey = this.metaKey || this.keyCode === 57, this._asKeybinding = this._computeKeybinding(), this._asKeyCodeChord = this._computeKeyCodeChord();
  }
  preventDefault() {
    this.browserEvent && this.browserEvent.preventDefault && this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent && this.browserEvent.stopPropagation && this.browserEvent.stopPropagation();
  }
  toKeyCodeChord() {
    return this._asKeyCodeChord;
  }
  equals(e) {
    return this._asKeybinding === e;
  }
  _computeKeybinding() {
    let e = 0;
    this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode);
    let t = 0;
    return this.ctrlKey && (t |= Y7), this.altKey && (t |= K7), this.shiftKey && (t |= J7), this.metaKey && (t |= q7), t |= e, t;
  }
  _computeKeyCodeChord() {
    let e = 0;
    return this.keyCode !== 5 && this.keyCode !== 4 && this.keyCode !== 6 && this.keyCode !== 57 && (e = this.keyCode), new Hl(this.ctrlKey, this.shiftKey, this.altKey, this.metaKey, e);
  }
}
const tR = /* @__PURE__ */ new WeakMap();
function $7(s) {
  if (!s.parent || s.parent === s)
    return null;
  try {
    const e = s.location, t = s.parent.location;
    if (e.origin !== "null" && t.origin !== "null" && e.origin !== t.origin)
      return null;
  } catch {
    return null;
  }
  return s.parent;
}
class X7 {
  /**
   * Returns a chain of embedded windows with the same origin (which can be accessed programmatically).
   * Having a chain of length 1 might mean that the current execution environment is running outside of an iframe or inside an iframe embedded in a window with a different origin.
   */
  static getSameOriginWindowChain(e) {
    let t = tR.get(e);
    if (!t) {
      t = [], tR.set(e, t);
      let i = e, n;
      do
        n = $7(i), n ? t.push({
          window: new WeakRef(i),
          iframeElement: i.frameElement || null
        }) : t.push({
          window: new WeakRef(i),
          iframeElement: null
        }), i = n;
      while (i);
    }
    return t.slice(0);
  }
  /**
   * Returns the position of `childWindow` relative to `ancestorWindow`
   */
  static getPositionOfChildWindowRelativeToAncestorWindow(e, t) {
    if (!t || e === t)
      return {
        top: 0,
        left: 0
      };
    let i = 0, n = 0;
    const o = this.getSameOriginWindowChain(e);
    for (const r of o) {
      const a = r.window.deref();
      if (i += a?.scrollY ?? 0, n += a?.scrollX ?? 0, a === t || !r.iframeElement)
        break;
      const l = r.iframeElement.getBoundingClientRect();
      i += l.top, n += l.left;
    }
    return {
      top: i,
      left: n
    };
  }
}
class Ir {
  constructor(e, t) {
    this.timestamp = Date.now(), this.browserEvent = t, this.leftButton = t.button === 0, this.middleButton = t.button === 1, this.rightButton = t.button === 2, this.buttons = t.buttons, this.target = t.target, this.detail = t.detail || 1, t.type === "dblclick" && (this.detail = 2), this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.altKey = t.altKey, this.metaKey = t.metaKey, typeof t.pageX == "number" ? (this.posx = t.pageX, this.posy = t.pageY) : (this.posx = t.clientX + this.target.ownerDocument.body.scrollLeft + this.target.ownerDocument.documentElement.scrollLeft, this.posy = t.clientY + this.target.ownerDocument.body.scrollTop + this.target.ownerDocument.documentElement.scrollTop);
    const i = X7.getPositionOfChildWindowRelativeToAncestorWindow(e, t.view);
    this.posx -= i.left, this.posy -= i.top;
  }
  preventDefault() {
    this.browserEvent.preventDefault();
  }
  stopPropagation() {
    this.browserEvent.stopPropagation();
  }
}
class fu {
  constructor(e, t = 0, i = 0) {
    this.browserEvent = e || null, this.target = e ? e.target || e.targetNode || e.srcElement : null, this.deltaY = i, this.deltaX = t;
    let n = !1;
    if (I_) {
      const o = navigator.userAgent.match(/Chrome\/(\d+)/);
      n = (o ? parseInt(o[1]) : 123) <= 122;
    }
    if (e) {
      const o = e, r = e, a = e.view?.devicePixelRatio || 1;
      if (typeof o.wheelDeltaY < "u")
        n ? this.deltaY = o.wheelDeltaY / (120 * a) : this.deltaY = o.wheelDeltaY / 120;
      else if (typeof r.VERTICAL_AXIS < "u" && r.axis === r.VERTICAL_AXIS)
        this.deltaY = -r.detail / 3;
      else if (e.type === "wheel") {
        const l = e;
        l.deltaMode === l.DOM_DELTA_LINE ? Ko && !ze ? this.deltaY = -e.deltaY / 3 : this.deltaY = -e.deltaY : this.deltaY = -e.deltaY / 40;
      }
      if (typeof o.wheelDeltaX < "u")
        od && yn ? this.deltaX = -(o.wheelDeltaX / 120) : n ? this.deltaX = o.wheelDeltaX / (120 * a) : this.deltaX = o.wheelDeltaX / 120;
      else if (typeof r.HORIZONTAL_AXIS < "u" && r.axis === r.HORIZONTAL_AXIS)
        this.deltaX = -e.detail / 3;
      else if (e.type === "wheel") {
        const l = e;
        l.deltaMode === l.DOM_DELTA_LINE ? Ko && !ze ? this.deltaX = -e.deltaX / 3 : this.deltaX = -e.deltaX : this.deltaX = -e.deltaX / 40;
      }
      this.deltaY === 0 && this.deltaX === 0 && e.wheelDelta && (n ? this.deltaY = e.wheelDelta / (120 * a) : this.deltaY = e.wheelDelta / 120);
    }
  }
  preventDefault() {
    this.browserEvent?.preventDefault();
  }
  stopPropagation() {
    this.browserEvent?.stopPropagation();
  }
}
const xH = Symbol("MicrotaskDelay");
function RE(s) {
  return !!s && typeof s.then == "function";
}
function ir(s) {
  const e = new vs(), t = s(e.token), i = new Promise((n, o) => {
    const r = e.token.onCancellationRequested(() => {
      r.dispose(), o(new _d());
    });
    Promise.resolve(t).then((a) => {
      r.dispose(), e.dispose(), n(a);
    }, (a) => {
      r.dispose(), e.dispose(), o(a);
    });
  });
  return new class {
    cancel() {
      e.cancel(), e.dispose();
    }
    then(n, o) {
      return i.then(n, o);
    }
    catch(n) {
      return this.then(void 0, n);
    }
    finally(n) {
      return i.finally(n);
    }
  }();
}
function Z7(s, e, t) {
  return new Promise((i, n) => {
    const o = e.onCancellationRequested(() => {
      o.dispose(), i(t);
    });
    s.then(i, n).finally(() => o.dispose());
  });
}
class e6 {
  constructor() {
    this.isDisposed = !1, this.activePromise = null, this.queuedPromise = null, this.queuedPromiseFactory = null;
  }
  queue(e) {
    if (this.isDisposed)
      return Promise.reject(new Error("Throttler is disposed"));
    if (this.activePromise) {
      if (this.queuedPromiseFactory = e, !this.queuedPromise) {
        const t = () => {
          if (this.queuedPromise = null, this.isDisposed)
            return;
          const i = this.queue(this.queuedPromiseFactory);
          return this.queuedPromiseFactory = null, i;
        };
        this.queuedPromise = new Promise((i) => {
          this.activePromise.then(t, t).then(i);
        });
      }
      return new Promise((t, i) => {
        this.queuedPromise.then(t, i);
      });
    }
    return this.activePromise = e(), new Promise((t, i) => {
      this.activePromise.then((n) => {
        this.activePromise = null, t(n);
      }, (n) => {
        this.activePromise = null, i(n);
      });
    });
  }
  dispose() {
    this.isDisposed = !0;
  }
}
const t6 = (s, e) => {
  let t = !0;
  const i = setTimeout(() => {
    t = !1, e();
  }, s);
  return {
    isTriggered: () => t,
    dispose: () => {
      clearTimeout(i), t = !1;
    }
  };
}, i6 = (s) => {
  let e = !0;
  return queueMicrotask(() => {
    e && (e = !1, s());
  }), {
    isTriggered: () => e,
    dispose: () => {
      e = !1;
    }
  };
};
class Gl {
  constructor(e) {
    this.defaultDelay = e, this.deferred = null, this.completionPromise = null, this.doResolve = null, this.doReject = null, this.task = null;
  }
  trigger(e, t = this.defaultDelay) {
    this.task = e, this.cancelTimeout(), this.completionPromise || (this.completionPromise = new Promise((n, o) => {
      this.doResolve = n, this.doReject = o;
    }).then(() => {
      if (this.completionPromise = null, this.doResolve = null, this.task) {
        const n = this.task;
        return this.task = null, n();
      }
    }));
    const i = () => {
      this.deferred = null, this.doResolve?.(null);
    };
    return this.deferred = t === xH ? i6(i) : t6(t, i), this.completionPromise;
  }
  isTriggered() {
    return !!this.deferred?.isTriggered();
  }
  cancel() {
    this.cancelTimeout(), this.completionPromise && (this.doReject?.(new _d()), this.completionPromise = null);
  }
  cancelTimeout() {
    this.deferred?.dispose(), this.deferred = null;
  }
  dispose() {
    this.cancel();
  }
}
class EH {
  constructor(e) {
    this.delayer = new Gl(e), this.throttler = new e6();
  }
  trigger(e, t) {
    return this.delayer.trigger(() => this.throttler.queue(e), t);
  }
  cancel() {
    this.delayer.cancel();
  }
  dispose() {
    this.delayer.dispose(), this.throttler.dispose();
  }
}
function MA(s, e) {
  return e ? new Promise((t, i) => {
    const n = setTimeout(() => {
      o.dispose(), t();
    }, s), o = e.onCancellationRequested(() => {
      clearTimeout(n), o.dispose(), i(new _d());
    });
  }) : ir((t) => MA(s, t));
}
function zf(s, e = 0, t) {
  const i = setTimeout(() => {
    s(), t && n.dispose();
  }, e), n = we(() => {
    clearTimeout(i), t?.deleteAndLeak(n);
  });
  return t?.add(n), n;
}
class nr {
  constructor(e, t) {
    this._isDisposed = !1, this._token = -1, typeof e == "function" && typeof t == "number" && this.setIfNotSet(e, t);
  }
  dispose() {
    this.cancel(), this._isDisposed = !0;
  }
  cancel() {
    this._token !== -1 && (clearTimeout(this._token), this._token = -1);
  }
  cancelAndSet(e, t) {
    if (this._isDisposed)
      throw new lt("Calling 'cancelAndSet' on a disposed TimeoutTimer");
    this.cancel(), this._token = setTimeout(() => {
      this._token = -1, e();
    }, t);
  }
  setIfNotSet(e, t) {
    if (this._isDisposed)
      throw new lt("Calling 'setIfNotSet' on a disposed TimeoutTimer");
    this._token === -1 && (this._token = setTimeout(() => {
      this._token = -1, e();
    }, t));
  }
}
class QM {
  constructor() {
    this.disposable = void 0, this.isDisposed = !1;
  }
  cancel() {
    this.disposable?.dispose(), this.disposable = void 0;
  }
  cancelAndSet(e, t, i = globalThis) {
    if (this.isDisposed)
      throw new lt("Calling 'cancelAndSet' on a disposed IntervalTimer");
    this.cancel();
    const n = i.setInterval(() => {
      e();
    }, t);
    this.disposable = we(() => {
      i.clearInterval(n), this.disposable = void 0;
    });
  }
  dispose() {
    this.cancel(), this.isDisposed = !0;
  }
}
class zt {
  constructor(e, t) {
    this.timeoutToken = -1, this.runner = e, this.timeout = t, this.timeoutHandler = this.onTimeout.bind(this);
  }
  /**
   * Dispose RunOnceScheduler
   */
  dispose() {
    this.cancel(), this.runner = null;
  }
  /**
   * Cancel current scheduled runner (if any).
   */
  cancel() {
    this.isScheduled() && (clearTimeout(this.timeoutToken), this.timeoutToken = -1);
  }
  /**
   * Cancel previous runner (if any) & schedule a new runner.
   */
  schedule(e = this.timeout) {
    this.cancel(), this.timeoutToken = setTimeout(this.timeoutHandler, e);
  }
  get delay() {
    return this.timeout;
  }
  set delay(e) {
    this.timeout = e;
  }
  /**
   * Returns true if scheduled.
   */
  isScheduled() {
    return this.timeoutToken !== -1;
  }
  onTimeout() {
    this.timeoutToken = -1, this.runner && this.doRun();
  }
  doRun() {
    this.runner?.();
  }
}
let LH, Np;
(function() {
  typeof globalThis.requestIdleCallback != "function" || typeof globalThis.cancelIdleCallback != "function" ? Np = (s, e) => {
    J4(() => {
      if (t)
        return;
      const i = Date.now() + 15;
      e(Object.freeze({
        didTimeout: !0,
        timeRemaining() {
          return Math.max(0, i - Date.now());
        }
      }));
    });
    let t = !1;
    return {
      dispose() {
        t || (t = !0);
      }
    };
  } : Np = (s, e, t) => {
    const i = s.requestIdleCallback(e, typeof t == "number" ? { timeout: t } : void 0);
    let n = !1;
    return {
      dispose() {
        n || (n = !0, s.cancelIdleCallback(i));
      }
    };
  }, LH = (s) => Np(globalThis, s);
})();
class kH {
  constructor(e, t) {
    this._didRun = !1, this._executor = () => {
      try {
        this._value = t();
      } catch (i) {
        this._error = i;
      } finally {
        this._didRun = !0;
      }
    }, this._handle = Np(e, () => this._executor());
  }
  dispose() {
    this._handle.dispose();
  }
  get value() {
    if (this._didRun || (this._handle.dispose(), this._executor()), this._error)
      throw this._error;
    return this._value;
  }
  get isInitialized() {
    return this._didRun;
  }
}
class n6 extends kH {
  constructor(e) {
    super(globalThis, e);
  }
}
class DH {
  get isRejected() {
    return this.outcome?.outcome === 1;
  }
  get isSettled() {
    return !!this.outcome;
  }
  constructor() {
    this.p = new Promise((e, t) => {
      this.completeCallback = e, this.errorCallback = t;
    });
  }
  complete(e) {
    return new Promise((t) => {
      this.completeCallback(e), this.outcome = { outcome: 0, value: e }, t();
    });
  }
  error(e) {
    return new Promise((t) => {
      this.errorCallback(e), this.outcome = { outcome: 1, value: e }, t();
    });
  }
  cancel() {
    return this.error(new _d());
  }
}
var FE;
(function(s) {
  async function e(i) {
    let n;
    const o = await Promise.all(i.map((r) => r.then((a) => a, (a) => {
      n || (n = a);
    })));
    if (typeof n < "u")
      throw n;
    return o;
  }
  s.settled = e;
  function t(i) {
    return new Promise(async (n, o) => {
      try {
        await i(n, o);
      } catch (r) {
        o(r);
      }
    });
  }
  s.withAsyncBody = t;
})(FE || (FE = {}));
const us = class us {
  static fromArray(e) {
    return new us((t) => {
      t.emitMany(e);
    });
  }
  static fromPromise(e) {
    return new us(async (t) => {
      t.emitMany(await e);
    });
  }
  static fromPromises(e) {
    return new us(async (t) => {
      await Promise.all(e.map(async (i) => t.emitOne(await i)));
    });
  }
  static merge(e) {
    return new us(async (t) => {
      await Promise.all(e.map(async (i) => {
        for await (const n of i)
          t.emitOne(n);
      }));
    });
  }
  constructor(e, t) {
    this._state = 0, this._results = [], this._error = null, this._onReturn = t, this._onStateChanged = new B(), queueMicrotask(async () => {
      const i = {
        emitOne: (n) => this.emitOne(n),
        emitMany: (n) => this.emitMany(n),
        reject: (n) => this.reject(n)
      };
      try {
        await Promise.resolve(e(i)), this.resolve();
      } catch (n) {
        this.reject(n);
      } finally {
        i.emitOne = void 0, i.emitMany = void 0, i.reject = void 0;
      }
    });
  }
  [Symbol.asyncIterator]() {
    let e = 0;
    return {
      next: async () => {
        do {
          if (this._state === 2)
            throw this._error;
          if (e < this._results.length)
            return { done: !1, value: this._results[e++] };
          if (this._state === 1)
            return { done: !0, value: void 0 };
          await te.toPromise(this._onStateChanged.event);
        } while (!0);
      },
      return: async () => (this._onReturn?.(), { done: !0, value: void 0 })
    };
  }
  static map(e, t) {
    return new us(async (i) => {
      for await (const n of e)
        i.emitOne(t(n));
    });
  }
  map(e) {
    return us.map(this, e);
  }
  static filter(e, t) {
    return new us(async (i) => {
      for await (const n of e)
        t(n) && i.emitOne(n);
    });
  }
  filter(e) {
    return us.filter(this, e);
  }
  static coalesce(e) {
    return us.filter(e, (t) => !!t);
  }
  coalesce() {
    return us.coalesce(this);
  }
  static async toPromise(e) {
    const t = [];
    for await (const i of e)
      t.push(i);
    return t;
  }
  toPromise() {
    return us.toPromise(this);
  }
  /**
   * The value will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitOne(e) {
    this._state === 0 && (this._results.push(e), this._onStateChanged.fire());
  }
  /**
   * The values will be appended at the end.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  emitMany(e) {
    this._state === 0 && (this._results = this._results.concat(e), this._onStateChanged.fire());
  }
  /**
   * Calling `resolve()` will mark the result array as complete.
   *
   * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  resolve() {
    this._state === 0 && (this._state = 1, this._onStateChanged.fire());
  }
  /**
   * Writing an error will permanently invalidate this iterable.
   * The current users will receive an error thrown, as will all future users.
   *
   * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.
   */
  reject(e) {
    this._state === 0 && (this._state = 2, this._error = e, this._onStateChanged.fire());
  }
};
us.EMPTY = us.fromArray([]);
let Gs = us;
class s6 extends Gs {
  constructor(e, t) {
    super(t), this._source = e;
  }
  cancel() {
    this._source.cancel();
  }
}
function o6(s) {
  const e = new vs(), t = s(e.token);
  return new s6(e, async (i) => {
    const n = e.token.onCancellationRequested(() => {
      n.dispose(), e.dispose(), i.reject(new _d());
    });
    try {
      for await (const o of t) {
        if (e.token.isCancellationRequested)
          return;
        i.emitOne(o);
      }
      n.dispose(), e.dispose();
    } catch (o) {
      n.dispose(), e.dispose(), i.reject(o);
    }
  });
}
/*! @license DOMPurify 3.1.7 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.1.7/LICENSE */
const {
  entries: IH,
  setPrototypeOf: iR,
  isFrozen: r6,
  getPrototypeOf: a6,
  getOwnPropertyDescriptor: l6
} = Object;
let {
  freeze: Ss,
  seal: Jo,
  create: MH
} = Object, {
  apply: OE,
  construct: PE
} = typeof Reflect < "u" && Reflect;
Ss || (Ss = function(e) {
  return e;
});
Jo || (Jo = function(e) {
  return e;
});
OE || (OE = function(e, t, i) {
  return e.apply(t, i);
});
PE || (PE = function(e, t) {
  return new e(...t);
});
const db = yo(Array.prototype.forEach), nR = yo(Array.prototype.pop), Hm = yo(Array.prototype.push), mw = yo(String.prototype.toLowerCase), KS = yo(String.prototype.toString), sR = yo(String.prototype.match), Wm = yo(String.prototype.replace), c6 = yo(String.prototype.indexOf), d6 = yo(String.prototype.trim), Ar = yo(Object.prototype.hasOwnProperty), cs = yo(RegExp.prototype.test), Vm = h6(TypeError);
function yo(s) {
  return function(e) {
    for (var t = arguments.length, i = new Array(t > 1 ? t - 1 : 0), n = 1; n < t; n++)
      i[n - 1] = arguments[n];
    return OE(s, e, i);
  };
}
function h6(s) {
  return function() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
      t[i] = arguments[i];
    return PE(s, t);
  };
}
function At(s, e) {
  let t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : mw;
  iR && iR(s, null);
  let i = e.length;
  for (; i--; ) {
    let n = e[i];
    if (typeof n == "string") {
      const o = t(n);
      o !== n && (r6(e) || (e[i] = o), n = o);
    }
    s[n] = !0;
  }
  return s;
}
function u6(s) {
  for (let e = 0; e < s.length; e++)
    Ar(s, e) || (s[e] = null);
  return s;
}
function Ud(s) {
  const e = MH(null);
  for (const [t, i] of IH(s))
    Ar(s, t) && (Array.isArray(i) ? e[t] = u6(i) : i && typeof i == "object" && i.constructor === Object ? e[t] = Ud(i) : e[t] = i);
  return e;
}
function zm(s, e) {
  for (; s !== null; ) {
    const i = l6(s, e);
    if (i) {
      if (i.get)
        return yo(i.get);
      if (typeof i.value == "function")
        return yo(i.value);
    }
    s = a6(s);
  }
  function t() {
    return null;
  }
  return t;
}
const oR = Ss(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), JS = Ss(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), qS = Ss(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), g6 = Ss(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), $S = Ss(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), f6 = Ss(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), rR = Ss(["#text"]), aR = Ss(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), XS = Ss(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), lR = Ss(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), hb = Ss(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), m6 = Jo(/\{\{[\w\W]*|[\w\W]*\}\}/gm), p6 = Jo(/<%[\w\W]*|[\w\W]*%>/gm), A6 = Jo(/\${[\w\W]*}/gm), _6 = Jo(/^data-[\-\w.\u00B7-\uFFFF]/), b6 = Jo(/^aria-[\-\w]+$/), NH = Jo(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
  // eslint-disable-line no-useless-escape
), w6 = Jo(/^(?:\w+script|data):/i), C6 = Jo(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
  // eslint-disable-line no-control-regex
), TH = Jo(/^html$/i), v6 = Jo(/^[a-z][.\w]*(-[.\w]+)+$/i);
var cR = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  MUSTACHE_EXPR: m6,
  ERB_EXPR: p6,
  TMPLIT_EXPR: A6,
  DATA_ATTR: _6,
  ARIA_ATTR: b6,
  IS_ALLOWED_URI: NH,
  IS_SCRIPT_OR_DATA: w6,
  ATTR_WHITESPACE: C6,
  DOCTYPE_NAME: TH,
  CUSTOM_ELEMENT: v6
});
const Um = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9
}, S6 = function() {
  return typeof window > "u" ? null : window;
}, y6 = function(e, t) {
  if (typeof e != "object" || typeof e.createPolicy != "function")
    return null;
  let i = null;
  const n = "data-tt-policy-suffix";
  t && t.hasAttribute(n) && (i = t.getAttribute(n));
  const o = "dompurify" + (i ? "#" + i : "");
  try {
    return e.createPolicy(o, {
      createHTML(r) {
        return r;
      },
      createScriptURL(r) {
        return r;
      }
    });
  } catch {
    return console.warn("TrustedTypes policy " + o + " could not be created."), null;
  }
};
function BH() {
  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : S6();
  const e = (Fe) => BH(Fe);
  if (e.version = "3.1.7", e.removed = [], !s || !s.document || s.document.nodeType !== Um.document)
    return e.isSupported = !1, e;
  let {
    document: t
  } = s;
  const i = t, n = i.currentScript, {
    DocumentFragment: o,
    HTMLTemplateElement: r,
    Node: a,
    Element: l,
    NodeFilter: c,
    NamedNodeMap: d = s.NamedNodeMap || s.MozNamedAttrMap,
    HTMLFormElement: h,
    DOMParser: u,
    trustedTypes: g
  } = s, m = l.prototype, p = zm(m, "cloneNode"), A = zm(m, "remove"), _ = zm(m, "nextSibling"), b = zm(m, "childNodes"), C = zm(m, "parentNode");
  if (typeof r == "function") {
    const Fe = t.createElement("template");
    Fe.content && Fe.content.ownerDocument && (t = Fe.content.ownerDocument);
  }
  let w, S = "";
  const {
    implementation: x,
    createNodeIterator: y,
    createDocumentFragment: D,
    getElementsByTagName: I
  } = t, {
    importNode: Q
  } = i;
  let P = {};
  e.isSupported = typeof IH == "function" && typeof C == "function" && x && x.createHTMLDocument !== void 0;
  const {
    MUSTACHE_EXPR: W,
    ERB_EXPR: j,
    TMPLIT_EXPR: H,
    DATA_ATTR: J,
    ARIA_ATTR: se,
    IS_SCRIPT_OR_DATA: ce,
    ATTR_WHITESPACE: he,
    CUSTOM_ELEMENT: ae
  } = cR;
  let {
    IS_ALLOWED_URI: be
  } = cR, Ce = null;
  const Ft = At({}, [...oR, ...JS, ...qS, ...$S, ...rR]);
  let ut = null;
  const Ut = At({}, [...aR, ...XS, ...lR, ...hb]);
  let ft = Object.seal(MH(null, {
    tagNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    attributeNameCheck: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: !0,
      configurable: !1,
      enumerable: !0,
      value: !1
    }
  })), ri = null, io = null, Ai = !0, Io = !0, Xl = !1, Z_ = !0, Zl = !1, Tm = !0, Va = !1, Bm = !1, Rm = !1, ec = !1, Zu = !1, eg = !1, Ed = !0, eb = !1;
  const tb = "user-content-";
  let tg = !0, Ld = !1, zr = {}, tc = null;
  const ig = At({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  let ib = null;
  const kd = At({}, ["audio", "video", "img", "source", "image", "track"]);
  let za = null;
  const Is = At({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), Ur = "http://www.w3.org/1998/Math/MathML", Ua = "http://www.w3.org/2000/svg", Pi = "http://www.w3.org/1999/xhtml";
  let no = Pi, ng = !1, dr = null;
  const Pt = At({}, [Ur, Ua, Pi], KS);
  let Dd = null;
  const PS = ["application/xhtml+xml", "text/html"], HS = "text/html";
  let Yi = null, ic = null;
  const WS = t.createElement("form"), nb = function(G) {
    return G instanceof RegExp || G instanceof Function;
  }, Fm = function() {
    let G = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!(ic && ic === G)) {
      if ((!G || typeof G != "object") && (G = {}), G = Ud(G), Dd = // eslint-disable-next-line unicorn/prefer-includes
      PS.indexOf(G.PARSER_MEDIA_TYPE) === -1 ? HS : G.PARSER_MEDIA_TYPE, Yi = Dd === "application/xhtml+xml" ? KS : mw, Ce = Ar(G, "ALLOWED_TAGS") ? At({}, G.ALLOWED_TAGS, Yi) : Ft, ut = Ar(G, "ALLOWED_ATTR") ? At({}, G.ALLOWED_ATTR, Yi) : Ut, dr = Ar(G, "ALLOWED_NAMESPACES") ? At({}, G.ALLOWED_NAMESPACES, KS) : Pt, za = Ar(G, "ADD_URI_SAFE_ATTR") ? At(
        Ud(Is),
        // eslint-disable-line indent
        G.ADD_URI_SAFE_ATTR,
        // eslint-disable-line indent
        Yi
        // eslint-disable-line indent
      ) : Is, ib = Ar(G, "ADD_DATA_URI_TAGS") ? At(
        Ud(kd),
        // eslint-disable-line indent
        G.ADD_DATA_URI_TAGS,
        // eslint-disable-line indent
        Yi
        // eslint-disable-line indent
      ) : kd, tc = Ar(G, "FORBID_CONTENTS") ? At({}, G.FORBID_CONTENTS, Yi) : ig, ri = Ar(G, "FORBID_TAGS") ? At({}, G.FORBID_TAGS, Yi) : {}, io = Ar(G, "FORBID_ATTR") ? At({}, G.FORBID_ATTR, Yi) : {}, zr = Ar(G, "USE_PROFILES") ? G.USE_PROFILES : !1, Ai = G.ALLOW_ARIA_ATTR !== !1, Io = G.ALLOW_DATA_ATTR !== !1, Xl = G.ALLOW_UNKNOWN_PROTOCOLS || !1, Z_ = G.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Zl = G.SAFE_FOR_TEMPLATES || !1, Tm = G.SAFE_FOR_XML !== !1, Va = G.WHOLE_DOCUMENT || !1, ec = G.RETURN_DOM || !1, Zu = G.RETURN_DOM_FRAGMENT || !1, eg = G.RETURN_TRUSTED_TYPE || !1, Rm = G.FORCE_BODY || !1, Ed = G.SANITIZE_DOM !== !1, eb = G.SANITIZE_NAMED_PROPS || !1, tg = G.KEEP_CONTENT !== !1, Ld = G.IN_PLACE || !1, be = G.ALLOWED_URI_REGEXP || NH, no = G.NAMESPACE || Pi, ft = G.CUSTOM_ELEMENT_HANDLING || {}, G.CUSTOM_ELEMENT_HANDLING && nb(G.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (ft.tagNameCheck = G.CUSTOM_ELEMENT_HANDLING.tagNameCheck), G.CUSTOM_ELEMENT_HANDLING && nb(G.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (ft.attributeNameCheck = G.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), G.CUSTOM_ELEMENT_HANDLING && typeof G.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (ft.allowCustomizedBuiltInElements = G.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Zl && (Io = !1), Zu && (ec = !0), zr && (Ce = At({}, rR), ut = [], zr.html === !0 && (At(Ce, oR), At(ut, aR)), zr.svg === !0 && (At(Ce, JS), At(ut, XS), At(ut, hb)), zr.svgFilters === !0 && (At(Ce, qS), At(ut, XS), At(ut, hb)), zr.mathMl === !0 && (At(Ce, $S), At(ut, lR), At(ut, hb))), G.ADD_TAGS && (Ce === Ft && (Ce = Ud(Ce)), At(Ce, G.ADD_TAGS, Yi)), G.ADD_ATTR && (ut === Ut && (ut = Ud(ut)), At(ut, G.ADD_ATTR, Yi)), G.ADD_URI_SAFE_ATTR && At(za, G.ADD_URI_SAFE_ATTR, Yi), G.FORBID_CONTENTS && (tc === ig && (tc = Ud(tc)), At(tc, G.FORBID_CONTENTS, Yi)), tg && (Ce["#text"] = !0), Va && At(Ce, ["html", "head", "body"]), Ce.table && (At(Ce, ["tbody"]), delete ri.tbody), G.TRUSTED_TYPES_POLICY) {
        if (typeof G.TRUSTED_TYPES_POLICY.createHTML != "function")
          throw Vm('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        if (typeof G.TRUSTED_TYPES_POLICY.createScriptURL != "function")
          throw Vm('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        w = G.TRUSTED_TYPES_POLICY, S = w.createHTML("");
      } else
        w === void 0 && (w = y6(g, n)), w !== null && typeof S == "string" && (S = w.createHTML(""));
      Ss && Ss(G), ic = G;
    }
  }, Xe = At({}, ["mi", "mo", "mn", "ms", "mtext"]), M = At({}, ["annotation-xml"]), N = At({}, ["title", "style", "font", "a", "script"]), T = At({}, [...JS, ...qS, ...g6]), O = At({}, [...$S, ...f6]), z = function(G) {
    let ge = C(G);
    (!ge || !ge.tagName) && (ge = {
      namespaceURI: no,
      tagName: "template"
    });
    const Le = mw(G.tagName), gi = mw(ge.tagName);
    return dr[G.namespaceURI] ? G.namespaceURI === Ua ? ge.namespaceURI === Pi ? Le === "svg" : ge.namespaceURI === Ur ? Le === "svg" && (gi === "annotation-xml" || Xe[gi]) : !!T[Le] : G.namespaceURI === Ur ? ge.namespaceURI === Pi ? Le === "math" : ge.namespaceURI === Ua ? Le === "math" && M[gi] : !!O[Le] : G.namespaceURI === Pi ? ge.namespaceURI === Ua && !M[gi] || ge.namespaceURI === Ur && !Xe[gi] ? !1 : !O[Le] && (N[Le] || !T[Le]) : !!(Dd === "application/xhtml+xml" && dr[G.namespaceURI]) : !1;
  }, q = function(G) {
    Hm(e.removed, {
      element: G
    });
    try {
      C(G).removeChild(G);
    } catch {
      A(G);
    }
  }, ie = function(G, ge) {
    try {
      Hm(e.removed, {
        attribute: ge.getAttributeNode(G),
        from: ge
      });
    } catch {
      Hm(e.removed, {
        attribute: null,
        from: ge
      });
    }
    if (ge.removeAttribute(G), G === "is" && !ut[G])
      if (ec || Zu)
        try {
          q(ge);
        } catch {
        }
      else
        try {
          ge.setAttribute(G, "");
        } catch {
        }
  }, me = function(G) {
    let ge = null, Le = null;
    if (Rm)
      G = "<remove></remove>" + G;
    else {
      const En = sR(G, /^[\r\n\t ]+/);
      Le = En && En[0];
    }
    Dd === "application/xhtml+xml" && no === Pi && (G = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + G + "</body></html>");
    const gi = w ? w.createHTML(G) : G;
    if (no === Pi)
      try {
        ge = new u().parseFromString(gi, Dd);
      } catch {
      }
    if (!ge || !ge.documentElement) {
      ge = x.createDocument(no, "template", null);
      try {
        ge.documentElement.innerHTML = ng ? S : gi;
      } catch {
      }
    }
    const Gn = ge.body || ge.documentElement;
    return G && Le && Gn.insertBefore(t.createTextNode(Le), Gn.childNodes[0] || null), no === Pi ? I.call(ge, Va ? "html" : "body")[0] : Va ? ge.documentElement : Gn;
  }, ve = function(G) {
    return y.call(
      G.ownerDocument || G,
      G,
      // eslint-disable-next-line no-bitwise
      c.SHOW_ELEMENT | c.SHOW_COMMENT | c.SHOW_TEXT | c.SHOW_PROCESSING_INSTRUCTION | c.SHOW_CDATA_SECTION,
      null
    );
  }, je = function(G) {
    return G instanceof h && (typeof G.nodeName != "string" || typeof G.textContent != "string" || typeof G.removeChild != "function" || !(G.attributes instanceof d) || typeof G.removeAttribute != "function" || typeof G.setAttribute != "function" || typeof G.namespaceURI != "string" || typeof G.insertBefore != "function" || typeof G.hasChildNodes != "function");
  }, pt = function(G) {
    return typeof a == "function" && G instanceof a;
  }, wt = function(G, ge, Le) {
    P[G] && db(P[G], (gi) => {
      gi.call(e, ge, Le, ic);
    });
  }, Ei = function(G) {
    let ge = null;
    if (wt("beforeSanitizeElements", G, null), je(G))
      return q(G), !0;
    const Le = Yi(G.nodeName);
    if (wt("uponSanitizeElement", G, {
      tagName: Le,
      allowedTags: Ce
    }), G.hasChildNodes() && !pt(G.firstElementChild) && cs(/<[/\w]/g, G.innerHTML) && cs(/<[/\w]/g, G.textContent) || G.nodeType === Um.progressingInstruction || Tm && G.nodeType === Um.comment && cs(/<[/\w]/g, G.data))
      return q(G), !0;
    if (!Ce[Le] || ri[Le]) {
      if (!ri[Le] && as(Le) && (ft.tagNameCheck instanceof RegExp && cs(ft.tagNameCheck, Le) || ft.tagNameCheck instanceof Function && ft.tagNameCheck(Le)))
        return !1;
      if (tg && !tc[Le]) {
        const gi = C(G) || G.parentNode, Gn = b(G) || G.childNodes;
        if (Gn && gi) {
          const En = Gn.length;
          for (let Ms = En - 1; Ms >= 0; --Ms) {
            const Qr = p(Gn[Ms], !0);
            Qr.__removalCount = (G.__removalCount || 0) + 1, gi.insertBefore(Qr, _(G));
          }
        }
      }
      return q(G), !0;
    }
    return G instanceof l && !z(G) || (Le === "noscript" || Le === "noembed" || Le === "noframes") && cs(/<\/no(script|embed|frames)/i, G.innerHTML) ? (q(G), !0) : (Zl && G.nodeType === Um.text && (ge = G.textContent, db([W, j, H], (gi) => {
      ge = Wm(ge, gi, " ");
    }), G.textContent !== ge && (Hm(e.removed, {
      element: G.cloneNode()
    }), G.textContent = ge)), wt("afterSanitizeElements", G, null), !1);
  }, Zt = function(G, ge, Le) {
    if (Ed && (ge === "id" || ge === "name") && (Le in t || Le in WS))
      return !1;
    if (!(Io && !io[ge] && cs(J, ge))) {
      if (!(Ai && cs(se, ge))) {
        if (!ut[ge] || io[ge]) {
          if (
            // First condition does a very basic check if a) it's basically a valid custom element tagname AND
            // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
            !(as(G) && (ft.tagNameCheck instanceof RegExp && cs(ft.tagNameCheck, G) || ft.tagNameCheck instanceof Function && ft.tagNameCheck(G)) && (ft.attributeNameCheck instanceof RegExp && cs(ft.attributeNameCheck, ge) || ft.attributeNameCheck instanceof Function && ft.attributeNameCheck(ge)) || // Alternative, second condition checks if it's an `is`-attribute, AND
            // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
            ge === "is" && ft.allowCustomizedBuiltInElements && (ft.tagNameCheck instanceof RegExp && cs(ft.tagNameCheck, Le) || ft.tagNameCheck instanceof Function && ft.tagNameCheck(Le)))
          ) return !1;
        } else if (!za[ge]) {
          if (!cs(be, Wm(Le, he, ""))) {
            if (!((ge === "src" || ge === "xlink:href" || ge === "href") && G !== "script" && c6(Le, "data:") === 0 && ib[G])) {
              if (!(Xl && !cs(ce, Wm(Le, he, "")))) {
                if (Le)
                  return !1;
              }
            }
          }
        }
      }
    }
    return !0;
  }, as = function(G) {
    return G !== "annotation-xml" && sR(G, ae);
  }, so = function(G) {
    wt("beforeSanitizeAttributes", G, null);
    const {
      attributes: ge
    } = G;
    if (!ge)
      return;
    const Le = {
      attrName: "",
      attrValue: "",
      keepAttr: !0,
      allowedAttributes: ut
    };
    let gi = ge.length;
    for (; gi--; ) {
      const Gn = ge[gi], {
        name: En,
        namespaceURI: Ms,
        value: Qr
      } = Gn, Pm = Yi(En);
      let ls = En === "value" ? Qr : d6(Qr);
      if (Le.attrName = Pm, Le.attrValue = ls, Le.keepAttr = !0, Le.forceKeepAttr = void 0, wt("uponSanitizeAttribute", G, Le), ls = Le.attrValue, Le.forceKeepAttr || (ie(En, G), !Le.keepAttr))
        continue;
      if (!Z_ && cs(/\/>/i, ls)) {
        ie(En, G);
        continue;
      }
      Zl && db([W, j, H], (BB) => {
        ls = Wm(ls, BB, " ");
      });
      const TB = Yi(G.nodeName);
      if (Zt(TB, Pm, ls)) {
        if (eb && (Pm === "id" || Pm === "name") && (ie(En, G), ls = tb + ls), Tm && cs(/((--!?|])>)|<\/(style|title)/i, ls)) {
          ie(En, G);
          continue;
        }
        if (w && typeof g == "object" && typeof g.getAttributeType == "function" && !Ms)
          switch (g.getAttributeType(TB, Pm)) {
            case "TrustedHTML": {
              ls = w.createHTML(ls);
              break;
            }
            case "TrustedScriptURL": {
              ls = w.createScriptURL(ls);
              break;
            }
          }
        try {
          Ms ? G.setAttributeNS(Ms, En, ls) : G.setAttribute(En, ls), je(G) ? q(G) : nR(e.removed);
        } catch {
        }
      }
    }
    wt("afterSanitizeAttributes", G, null);
  }, Om = function Fe(G) {
    let ge = null;
    const Le = ve(G);
    for (wt("beforeSanitizeShadowDOM", G, null); ge = Le.nextNode(); )
      wt("uponSanitizeShadowNode", ge, null), !Ei(ge) && (ge.content instanceof o && Fe(ge.content), so(ge));
    wt("afterSanitizeShadowDOM", G, null);
  };
  return e.sanitize = function(Fe) {
    let G = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, ge = null, Le = null, gi = null, Gn = null;
    if (ng = !Fe, ng && (Fe = "<!-->"), typeof Fe != "string" && !pt(Fe))
      if (typeof Fe.toString == "function") {
        if (Fe = Fe.toString(), typeof Fe != "string")
          throw Vm("dirty is not a string, aborting");
      } else
        throw Vm("toString is not a function");
    if (!e.isSupported)
      return Fe;
    if (Bm || Fm(G), e.removed = [], typeof Fe == "string" && (Ld = !1), Ld) {
      if (Fe.nodeName) {
        const Qr = Yi(Fe.nodeName);
        if (!Ce[Qr] || ri[Qr])
          throw Vm("root node is forbidden and cannot be sanitized in-place");
      }
    } else if (Fe instanceof a)
      ge = me("<!---->"), Le = ge.ownerDocument.importNode(Fe, !0), Le.nodeType === Um.element && Le.nodeName === "BODY" || Le.nodeName === "HTML" ? ge = Le : ge.appendChild(Le);
    else {
      if (!ec && !Zl && !Va && // eslint-disable-next-line unicorn/prefer-includes
      Fe.indexOf("<") === -1)
        return w && eg ? w.createHTML(Fe) : Fe;
      if (ge = me(Fe), !ge)
        return ec ? null : eg ? S : "";
    }
    ge && Rm && q(ge.firstChild);
    const En = ve(Ld ? Fe : ge);
    for (; gi = En.nextNode(); )
      Ei(gi) || (gi.content instanceof o && Om(gi.content), so(gi));
    if (Ld)
      return Fe;
    if (ec) {
      if (Zu)
        for (Gn = D.call(ge.ownerDocument); ge.firstChild; )
          Gn.appendChild(ge.firstChild);
      else
        Gn = ge;
      return (ut.shadowroot || ut.shadowrootmode) && (Gn = Q.call(i, Gn, !0)), Gn;
    }
    let Ms = Va ? ge.outerHTML : ge.innerHTML;
    return Va && Ce["!doctype"] && ge.ownerDocument && ge.ownerDocument.doctype && ge.ownerDocument.doctype.name && cs(TH, ge.ownerDocument.doctype.name) && (Ms = "<!DOCTYPE " + ge.ownerDocument.doctype.name + `>
` + Ms), Zl && db([W, j, H], (Qr) => {
      Ms = Wm(Ms, Qr, " ");
    }), w && eg ? w.createHTML(Ms) : Ms;
  }, e.setConfig = function() {
    let Fe = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    Fm(Fe), Bm = !0;
  }, e.clearConfig = function() {
    ic = null, Bm = !1;
  }, e.isValidAttribute = function(Fe, G, ge) {
    ic || Fm({});
    const Le = Yi(Fe), gi = Yi(G);
    return Zt(Le, gi, ge);
  }, e.addHook = function(Fe, G) {
    typeof G == "function" && (P[Fe] = P[Fe] || [], Hm(P[Fe], G));
  }, e.removeHook = function(Fe) {
    if (P[Fe])
      return nR(P[Fe]);
  }, e.removeHooks = function(Fe) {
    P[Fe] && (P[Fe] = []);
  }, e.removeAllHooks = function() {
    P = {};
  }, e;
}
var Ra = BH();
Ra.version;
Ra.isSupported;
const RH = Ra.sanitize;
Ra.setConfig;
Ra.clearConfig;
Ra.isValidAttribute;
const FH = Ra.addHook, OH = Ra.removeHook;
Ra.removeHooks;
Ra.removeAllHooks;
var Ie;
(function(s) {
  s.inMemory = "inmemory", s.vscode = "vscode", s.internal = "private", s.walkThrough = "walkThrough", s.walkThroughSnippet = "walkThroughSnippet", s.http = "http", s.https = "https", s.file = "file", s.mailto = "mailto", s.untitled = "untitled", s.data = "data", s.command = "command", s.vscodeRemote = "vscode-remote", s.vscodeRemoteResource = "vscode-remote-resource", s.vscodeManagedRemoteResource = "vscode-managed-remote-resource", s.vscodeUserData = "vscode-userdata", s.vscodeCustomEditor = "vscode-custom-editor", s.vscodeNotebookCell = "vscode-notebook-cell", s.vscodeNotebookCellMetadata = "vscode-notebook-cell-metadata", s.vscodeNotebookCellMetadataDiff = "vscode-notebook-cell-metadata-diff", s.vscodeNotebookCellOutput = "vscode-notebook-cell-output", s.vscodeNotebookCellOutputDiff = "vscode-notebook-cell-output-diff", s.vscodeNotebookMetadata = "vscode-notebook-metadata", s.vscodeInteractiveInput = "vscode-interactive-input", s.vscodeSettings = "vscode-settings", s.vscodeWorkspaceTrust = "vscode-workspace-trust", s.vscodeTerminal = "vscode-terminal", s.vscodeChatCodeBlock = "vscode-chat-code-block", s.vscodeChatCodeCompareBlock = "vscode-chat-code-compare-block", s.vscodeChatSesssion = "vscode-chat-editor", s.webviewPanel = "webview-panel", s.vscodeWebview = "vscode-webview", s.extension = "extension", s.vscodeFileResource = "vscode-file", s.tmp = "tmp", s.vsls = "vsls", s.vscodeSourceControl = "vscode-scm", s.commentsInput = "comment", s.codeSetting = "code-setting", s.outputChannel = "output";
})(Ie || (Ie = {}));
function GM(s, e) {
  return _e.isUri(s) ? Mg(s.scheme, e) : FM(s, e + ":");
}
function HE(s, ...e) {
  return e.some((t) => GM(s, t));
}
const x6 = "tkn";
class E6 {
  constructor() {
    this._hosts = /* @__PURE__ */ Object.create(null), this._ports = /* @__PURE__ */ Object.create(null), this._connectionTokens = /* @__PURE__ */ Object.create(null), this._preferredWebSchema = "http", this._delegate = null, this._serverRootPath = "/";
  }
  setPreferredWebSchema(e) {
    this._preferredWebSchema = e;
  }
  get _remoteResourcesPath() {
    return di.join(this._serverRootPath, Ie.vscodeRemoteResource);
  }
  rewrite(e) {
    if (this._delegate)
      try {
        return this._delegate(e);
      } catch (a) {
        return Pe(a), e;
      }
    const t = e.authority;
    let i = this._hosts[t];
    i && i.indexOf(":") !== -1 && i.indexOf("[") === -1 && (i = `[${i}]`);
    const n = this._ports[t], o = this._connectionTokens[t];
    let r = `path=${encodeURIComponent(e.path)}`;
    return typeof o == "string" && (r += `&${x6}=${encodeURIComponent(o)}`), _e.from({
      scheme: pm ? this._preferredWebSchema : Ie.vscodeRemoteResource,
      authority: `${i}:${n}`,
      path: this._remoteResourcesPath,
      query: r
    });
  }
}
const PH = new E6(), L6 = "vscode-app", aA = class aA {
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  asBrowserUri(e) {
    const t = this.toUri(e);
    return this.uriToBrowserUri(t);
  }
  /**
   * Returns a URI to use in contexts where the browser is responsible
   * for loading (e.g. fetch()) or when used within the DOM.
   *
   * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.
   */
  uriToBrowserUri(e) {
    return e.scheme === Ie.vscodeRemote ? PH.rewrite(e) : (
      // ...only ever for `file` resources
      e.scheme === Ie.file && // ...and we run in native environments
      (vA || // ...or web worker extensions on desktop
      F9 === `${Ie.vscodeFileResource}://${aA.FALLBACK_AUTHORITY}`) ? e.with({
        scheme: Ie.vscodeFileResource,
        // We need to provide an authority here so that it can serve
        // as origin for network and loading matters in chromium.
        // If the URI is not coming with an authority already, we
        // add our own
        authority: e.authority || aA.FALLBACK_AUTHORITY,
        query: null,
        fragment: null
      }) : e
    );
  }
  toUri(e, t) {
    if (_e.isUri(e))
      return e;
    if (globalThis._VSCODE_FILE_ROOT) {
      const i = globalThis._VSCODE_FILE_ROOT;
      if (/^\w[\w\d+.-]*:\/\//.test(i))
        return _e.joinPath(_e.parse(i, !0), e);
      const n = r7(i, e);
      return _e.file(n);
    }
    return _e.parse(t.toUrl(e));
  }
};
aA.FALLBACK_AUTHORITY = L6;
let WE = aA;
const w0 = new WE();
var VE;
(function(s) {
  const e = /* @__PURE__ */ new Map([
    ["1", { "Cross-Origin-Opener-Policy": "same-origin" }],
    ["2", { "Cross-Origin-Embedder-Policy": "require-corp" }],
    ["3", { "Cross-Origin-Opener-Policy": "same-origin", "Cross-Origin-Embedder-Policy": "require-corp" }]
  ]);
  s.CoopAndCoep = Object.freeze(e.get("3"));
  const t = "vscode-coi";
  function i(o) {
    let r;
    typeof o == "string" ? r = new URL(o).searchParams : o instanceof URL ? r = o.searchParams : _e.isUri(o) && (r = new URL(o.toString(!0)).searchParams);
    const a = r?.get(t);
    if (a)
      return e.get(a);
  }
  s.getHeadersFromQuery = i;
  function n(o, r, a) {
    if (!globalThis.crossOriginIsolated)
      return;
    const l = r && a ? "3" : a ? "2" : "1";
    o instanceof URLSearchParams ? o.set(t, l) : o[t] = l;
  }
  s.addSearchParam = n;
})(VE || (VE = {}));
function C0(s) {
  return v0(s, 0);
}
function v0(s, e) {
  switch (typeof s) {
    case "object":
      return s === null ? _l(349, e) : Array.isArray(s) ? D6(s, e) : I6(s, e);
    case "string":
      return jM(s, e);
    case "boolean":
      return k6(s, e);
    case "number":
      return _l(s, e);
    case "undefined":
      return _l(937, e);
    default:
      return _l(617, e);
  }
}
function _l(s, e) {
  return (e << 5) - e + s | 0;
}
function k6(s, e) {
  return _l(s ? 433 : 863, e);
}
function jM(s, e) {
  e = _l(149417, e);
  for (let t = 0, i = s.length; t < i; t++)
    e = _l(s.charCodeAt(t), e);
  return e;
}
function D6(s, e) {
  return e = _l(104579, e), s.reduce((t, i) => v0(i, t), e);
}
function I6(s, e) {
  return e = _l(181387, e), Object.keys(s).sort().reduce((t, i) => (t = jM(i, t), v0(s[i], t)), e);
}
function ZS(s, e, t = 32) {
  const i = t - e, n = ~((1 << i) - 1);
  return (s << e | (n & s) >>> i) >>> 0;
}
function dR(s, e = 0, t = s.byteLength, i = 0) {
  for (let n = 0; n < t; n++)
    s[e + n] = i;
}
function M6(s, e, t = "0") {
  for (; s.length < e; )
    s = t + s;
  return s;
}
function Qm(s, e = 32) {
  return s instanceof ArrayBuffer ? Array.from(new Uint8Array(s)).map((t) => t.toString(16).padStart(2, "0")).join("") : M6((s >>> 0).toString(16), e / 4);
}
const f1 = class f1 {
  // 80 * 4 = 320
  constructor() {
    this._h0 = 1732584193, this._h1 = 4023233417, this._h2 = 2562383102, this._h3 = 271733878, this._h4 = 3285377520, this._buff = new Uint8Array(
      67
      /* to fit any utf-8 */
    ), this._buffDV = new DataView(this._buff.buffer), this._buffLen = 0, this._totalLen = 0, this._leftoverHighSurrogate = 0, this._finished = !1;
  }
  update(e) {
    const t = e.length;
    if (t === 0)
      return;
    const i = this._buff;
    let n = this._buffLen, o = this._leftoverHighSurrogate, r, a;
    for (o !== 0 ? (r = o, a = -1, o = 0) : (r = e.charCodeAt(0), a = 0); ; ) {
      let l = r;
      if (Si(r))
        if (a + 1 < t) {
          const c = e.charCodeAt(a + 1);
          gu(c) ? (a++, l = OM(r, c)) : l = 65533;
        } else {
          o = r;
          break;
        }
      else gu(r) && (l = 65533);
      if (n = this._push(i, n, l), a++, a < t)
        r = e.charCodeAt(a);
      else
        break;
    }
    this._buffLen = n, this._leftoverHighSurrogate = o;
  }
  _push(e, t, i) {
    return i < 128 ? e[t++] = i : i < 2048 ? (e[t++] = 192 | (i & 1984) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : i < 65536 ? (e[t++] = 224 | (i & 61440) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0) : (e[t++] = 240 | (i & 1835008) >>> 18, e[t++] = 128 | (i & 258048) >>> 12, e[t++] = 128 | (i & 4032) >>> 6, e[t++] = 128 | (i & 63) >>> 0), t >= 64 && (this._step(), t -= 64, this._totalLen += 64, e[0] = e[64], e[1] = e[65], e[2] = e[66]), t;
  }
  digest() {
    return this._finished || (this._finished = !0, this._leftoverHighSurrogate && (this._leftoverHighSurrogate = 0, this._buffLen = this._push(
      this._buff,
      this._buffLen,
      65533
      /* SHA1Constant.UNICODE_REPLACEMENT */
    )), this._totalLen += this._buffLen, this._wrapUp()), Qm(this._h0) + Qm(this._h1) + Qm(this._h2) + Qm(this._h3) + Qm(this._h4);
  }
  _wrapUp() {
    this._buff[this._buffLen++] = 128, dR(this._buff, this._buffLen), this._buffLen > 56 && (this._step(), dR(this._buff));
    const e = 8 * this._totalLen;
    this._buffDV.setUint32(56, Math.floor(e / 4294967296), !1), this._buffDV.setUint32(60, e % 4294967296, !1), this._step();
  }
  _step() {
    const e = f1._bigBlock32, t = this._buffDV;
    for (let h = 0; h < 64; h += 4)
      e.setUint32(h, t.getUint32(h, !1), !1);
    for (let h = 64; h < 320; h += 4)
      e.setUint32(h, ZS(e.getUint32(h - 12, !1) ^ e.getUint32(h - 32, !1) ^ e.getUint32(h - 56, !1) ^ e.getUint32(h - 64, !1), 1), !1);
    let i = this._h0, n = this._h1, o = this._h2, r = this._h3, a = this._h4, l, c, d;
    for (let h = 0; h < 80; h++)
      h < 20 ? (l = n & o | ~n & r, c = 1518500249) : h < 40 ? (l = n ^ o ^ r, c = 1859775393) : h < 60 ? (l = n & o | n & r | o & r, c = 2400959708) : (l = n ^ o ^ r, c = 3395469782), d = ZS(i, 5) + l + a + c + e.getUint32(h * 4, !1) & 4294967295, a = r, r = o, o = ZS(n, 30), n = i, i = d;
    this._h0 = this._h0 + i & 4294967295, this._h1 = this._h1 + n & 4294967295, this._h2 = this._h2 + o & 4294967295, this._h3 = this._h3 + r & 4294967295, this._h4 = this._h4 + a & 4294967295;
  }
};
f1._bigBlock32 = new DataView(new ArrayBuffer(320));
let zE = f1;
const { getWindow: fe, getWindows: HH, getWindowsCount: N6, getWindowId: sC, getWindowById: hR, onDidRegisterWindow: S0, onWillUnregisterWindow: T6, onDidUnregisterWindow: B6 } = function() {
  const s = /* @__PURE__ */ new Map();
  x7(vt, 1);
  const e = { window: vt, disposables: new X() };
  s.set(vt.vscodeWindowId, e);
  const t = new B(), i = new B(), n = new B();
  function o(r, a) {
    return (typeof r == "number" ? s.get(r) : void 0) ?? (a ? e : void 0);
  }
  return {
    onDidRegisterWindow: t.event,
    onWillUnregisterWindow: n.event,
    onDidUnregisterWindow: i.event,
    registerWindow(r) {
      if (s.has(r.vscodeWindowId))
        return V.None;
      const a = new X(), l = {
        window: r,
        disposables: a.add(new X())
      };
      return s.set(r.vscodeWindowId, l), a.add(we(() => {
        s.delete(r.vscodeWindowId), i.fire(r);
      })), a.add(U(r, ee.BEFORE_UNLOAD, () => {
        n.fire(r);
      })), t.fire(l), a;
    },
    getWindows() {
      return s.values();
    },
    getWindowsCount() {
      return s.size;
    },
    getWindowId(r) {
      return r.vscodeWindowId;
    },
    hasWindow(r) {
      return s.has(r);
    },
    getWindowById: o,
    getWindow(r) {
      const a = r;
      if (a?.ownerDocument?.defaultView)
        return a.ownerDocument.defaultView.window;
      const l = r;
      return l?.view ? l.view.window : vt;
    },
    getDocument(r) {
      return fe(r).document;
    }
  };
}();
function Bn(s) {
  for (; s.firstChild; )
    s.firstChild.remove();
}
class R6 {
  constructor(e, t, i, n) {
    this._node = e, this._type = t, this._handler = i, this._options = n || !1, this._node.addEventListener(this._type, this._handler, this._options);
  }
  dispose() {
    this._handler && (this._node.removeEventListener(this._type, this._handler, this._options), this._node = null, this._handler = null);
  }
}
function U(s, e, t, i) {
  return new R6(s, e, t, i);
}
function WH(s, e) {
  return function(t) {
    return e(new Ir(s, t));
  };
}
function F6(s) {
  return function(e) {
    return s(new Mt(e));
  };
}
const Xt = function(e, t, i, n) {
  let o = i;
  return t === "click" || t === "mousedown" || t === "contextmenu" ? o = WH(fe(e), i) : (t === "keydown" || t === "keypress" || t === "keyup") && (o = F6(i)), U(e, t, o, n);
}, O6 = function(e, t, i) {
  const n = WH(fe(e), t);
  return P6(e, n, i);
};
function P6(s, e, t) {
  return U(s, Ea && UM.pointerEvents ? ee.POINTER_DOWN : ee.MOUSE_DOWN, e, t);
}
function ub(s, e, t) {
  return Np(s, e, t);
}
class ey extends kH {
  constructor(e, t) {
    super(e, t);
  }
}
let oC, ys;
class YM extends QM {
  /**
   *
   * @param node The optional node from which the target window is determined
   */
  constructor(e) {
    super(), this.defaultTarget = e && fe(e);
  }
  cancelAndSet(e, t, i) {
    return super.cancelAndSet(e, t, i ?? this.defaultTarget);
  }
}
class ty {
  constructor(e, t = 0) {
    this._runner = e, this.priority = t, this._canceled = !1;
  }
  dispose() {
    this._canceled = !0;
  }
  execute() {
    if (!this._canceled)
      try {
        this._runner();
      } catch (e) {
        Pe(e);
      }
  }
  // Sort by priority (largest to lowest)
  static sort(e, t) {
    return t.priority - e.priority;
  }
}
(function() {
  const s = /* @__PURE__ */ new Map(), e = /* @__PURE__ */ new Map(), t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Map(), n = (o) => {
    t.set(o, !1);
    const r = s.get(o) ?? [];
    for (e.set(o, r), s.set(o, []), i.set(o, !0); r.length > 0; )
      r.sort(ty.sort), r.shift().execute();
    i.set(o, !1);
  };
  ys = (o, r, a = 0) => {
    const l = sC(o), c = new ty(r, a);
    let d = s.get(l);
    return d || (d = [], s.set(l, d)), d.push(c), t.get(l) || (t.set(l, !0), o.requestAnimationFrame(() => n(l))), c;
  }, oC = (o, r, a) => {
    const l = sC(o);
    if (i.get(l)) {
      const c = new ty(r, a);
      let d = e.get(l);
      return d || (d = [], e.set(l, d)), d.push(c), c;
    } else
      return ys(o, r, a);
  };
})();
function y0(s) {
  return fe(s).getComputedStyle(s, null);
}
function mu(s, e) {
  const t = fe(s), i = t.document;
  if (s !== i.body)
    return new at(s.clientWidth, s.clientHeight);
  if (Ea && t?.visualViewport)
    return new at(t.visualViewport.width, t.visualViewport.height);
  if (t?.innerWidth && t.innerHeight)
    return new at(t.innerWidth, t.innerHeight);
  if (i.body && i.body.clientWidth && i.body.clientHeight)
    return new at(i.body.clientWidth, i.body.clientHeight);
  if (i.documentElement && i.documentElement.clientWidth && i.documentElement.clientHeight)
    return new at(i.documentElement.clientWidth, i.documentElement.clientHeight);
  throw new Error("Unable to figure out browser width and height");
}
class ti {
  // Adapted from WinJS
  // Converts a CSS positioning string for the specified element to pixels.
  static convertToPixels(e, t) {
    return parseFloat(t) || 0;
  }
  static getDimension(e, t, i) {
    const n = y0(e), o = n ? n.getPropertyValue(t) : "0";
    return ti.convertToPixels(e, o);
  }
  static getBorderLeftWidth(e) {
    return ti.getDimension(e, "border-left-width", "borderLeftWidth");
  }
  static getBorderRightWidth(e) {
    return ti.getDimension(e, "border-right-width", "borderRightWidth");
  }
  static getBorderTopWidth(e) {
    return ti.getDimension(e, "border-top-width", "borderTopWidth");
  }
  static getBorderBottomWidth(e) {
    return ti.getDimension(e, "border-bottom-width", "borderBottomWidth");
  }
  static getPaddingLeft(e) {
    return ti.getDimension(e, "padding-left", "paddingLeft");
  }
  static getPaddingRight(e) {
    return ti.getDimension(e, "padding-right", "paddingRight");
  }
  static getPaddingTop(e) {
    return ti.getDimension(e, "padding-top", "paddingTop");
  }
  static getPaddingBottom(e) {
    return ti.getDimension(e, "padding-bottom", "paddingBottom");
  }
  static getMarginLeft(e) {
    return ti.getDimension(e, "margin-left", "marginLeft");
  }
  static getMarginTop(e) {
    return ti.getDimension(e, "margin-top", "marginTop");
  }
  static getMarginRight(e) {
    return ti.getDimension(e, "margin-right", "marginRight");
  }
  static getMarginBottom(e) {
    return ti.getDimension(e, "margin-bottom", "marginBottom");
  }
}
const uh = class uh {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  with(e = this.width, t = this.height) {
    return e !== this.width || t !== this.height ? new uh(e, t) : this;
  }
  static is(e) {
    return typeof e == "object" && typeof e.height == "number" && typeof e.width == "number";
  }
  static lift(e) {
    return e instanceof uh ? e : new uh(e.width, e.height);
  }
  static equals(e, t) {
    return e === t ? !0 : !e || !t ? !1 : e.width === t.width && e.height === t.height;
  }
};
uh.None = new uh(0, 0);
let at = uh;
function VH(s) {
  let e = s.offsetParent, t = s.offsetTop, i = s.offsetLeft;
  for (; (s = s.parentNode) !== null && s !== s.ownerDocument.body && s !== s.ownerDocument.documentElement; ) {
    t -= s.scrollTop;
    const n = UH(s) ? null : y0(s);
    n && (i -= n.direction !== "rtl" ? s.scrollLeft : -s.scrollLeft), s === e && (i += ti.getBorderLeftWidth(s), t += ti.getBorderTopWidth(s), t += s.offsetTop, i += s.offsetLeft, e = s.offsetParent);
  }
  return {
    left: i,
    top: t
  };
}
function H6(s, e, t) {
  typeof e == "number" && (s.style.width = `${e}px`), typeof t == "number" && (s.style.height = `${t}px`);
}
function ui(s) {
  const e = s.getBoundingClientRect(), t = fe(s);
  return {
    left: e.left + t.scrollX,
    top: e.top + t.scrollY,
    width: e.width,
    height: e.height
  };
}
function zH(s) {
  let e = s, t = 1;
  do {
    const i = y0(e).zoom;
    i != null && i !== "1" && (t *= i), e = e.parentElement;
  } while (e !== null && e !== e.ownerDocument.documentElement);
  return t;
}
function Rs(s) {
  const e = ti.getMarginLeft(s) + ti.getMarginRight(s);
  return s.offsetWidth + e;
}
function iy(s) {
  const e = ti.getBorderLeftWidth(s) + ti.getBorderRightWidth(s), t = ti.getPaddingLeft(s) + ti.getPaddingRight(s);
  return s.offsetWidth - e - t;
}
function W6(s) {
  const e = ti.getBorderTopWidth(s) + ti.getBorderBottomWidth(s), t = ti.getPaddingTop(s) + ti.getPaddingBottom(s);
  return s.offsetHeight - e - t;
}
function _h(s) {
  const e = ti.getMarginTop(s) + ti.getMarginBottom(s);
  return s.offsetHeight + e;
}
function yi(s, e) {
  return !!e?.contains(s);
}
function V6(s, e, t) {
  for (; s && s.nodeType === s.ELEMENT_NODE; ) {
    if (s.classList.contains(e))
      return s;
    if (t) {
      if (typeof t == "string") {
        if (s.classList.contains(t))
          return null;
      } else if (s === t)
        return null;
    }
    s = s.parentNode;
  }
  return null;
}
function ny(s, e, t) {
  return !!V6(s, e, t);
}
function UH(s) {
  return s && !!s.host && !!s.mode;
}
function rC(s) {
  return !!pu(s);
}
function pu(s) {
  for (; s.parentNode; ) {
    if (s === s.ownerDocument?.body)
      return null;
    s = s.parentNode;
  }
  return UH(s) ? s : null;
}
function ln() {
  let s = KM().activeElement;
  for (; s?.shadowRoot; )
    s = s.shadowRoot.activeElement;
  return s;
}
function x0(s) {
  return ln() === s;
}
function QH(s) {
  return yi(ln(), s);
}
function KM() {
  return N6() <= 1 ? vt.document : Array.from(HH()).map(({ window: e }) => e.document).find((e) => e.hasFocus()) ?? vt.document;
}
function dp() {
  return KM().defaultView?.window ?? vt;
}
const JM = /* @__PURE__ */ new Map();
function xo(s = vt.document.head, e, t) {
  const i = document.createElement("style");
  if (i.type = "text/css", i.media = "screen", e?.(i), s.appendChild(i), t && t.add(we(() => i.remove())), s === vt.document.head) {
    const n = /* @__PURE__ */ new Set();
    JM.set(i, n);
    for (const { window: o, disposables: r } of HH()) {
      if (o === vt)
        continue;
      const a = r.add(z6(i, n, o));
      t?.add(a);
    }
  }
  return i;
}
function z6(s, e, t) {
  const i = new X(), n = s.cloneNode(!0);
  t.document.head.appendChild(n), i.add(we(() => n.remove()));
  for (const o of jH(s))
    n.sheet?.insertRule(o.cssText, n.sheet?.cssRules.length);
  return i.add(U6.observe(s, i, { childList: !0 })(() => {
    n.textContent = s.textContent;
  })), e.add(n), i.add(we(() => e.delete(n))), i;
}
const U6 = new class {
  constructor() {
    this.mutationObservers = /* @__PURE__ */ new Map();
  }
  observe(s, e, t) {
    let i = this.mutationObservers.get(s);
    i || (i = /* @__PURE__ */ new Map(), this.mutationObservers.set(s, i));
    const n = C0(t);
    let o = i.get(n);
    if (o)
      o.users += 1;
    else {
      const r = new B(), a = new MutationObserver((c) => r.fire(c));
      a.observe(s, t);
      const l = o = {
        users: 1,
        observer: a,
        onDidMutate: r.event
      };
      e.add(we(() => {
        l.users -= 1, l.users === 0 && (r.dispose(), a.disconnect(), i?.delete(n), i?.size === 0 && this.mutationObservers.delete(s));
      })), i.set(n, o);
    }
    return o.onDidMutate;
  }
}();
let sy = null;
function GH() {
  return sy || (sy = xo()), sy;
}
function jH(s) {
  return s?.sheet?.rules ? s.sheet.rules : s?.sheet?.cssRules ? s.sheet.cssRules : [];
}
function aC(s, e, t = GH()) {
  if (!(!t || !e)) {
    t.sheet?.insertRule(`${s} {${e}}`, 0);
    for (const i of JM.get(t) ?? [])
      aC(s, e, i);
  }
}
function UE(s, e = GH()) {
  if (!e)
    return;
  const t = jH(e), i = [];
  for (let n = 0; n < t.length; n++) {
    const o = t[n];
    Q6(o) && o.selectorText.indexOf(s) !== -1 && i.push(n);
  }
  for (let n = i.length - 1; n >= 0; n--)
    e.sheet?.deleteRule(i[n]);
  for (const n of JM.get(e) ?? [])
    UE(s, n);
}
function Q6(s) {
  return typeof s.selectorText == "string";
}
function Bi(s) {
  return s instanceof HTMLElement || s instanceof fe(s).HTMLElement;
}
function uR(s) {
  return s instanceof HTMLAnchorElement || s instanceof fe(s).HTMLAnchorElement;
}
function G6(s) {
  return s instanceof SVGElement || s instanceof fe(s).SVGElement;
}
function qM(s) {
  return s instanceof MouseEvent || s instanceof fe(s).MouseEvent;
}
function cl(s) {
  return s instanceof KeyboardEvent || s instanceof fe(s).KeyboardEvent;
}
const ee = {
  // Mouse
  CLICK: "click",
  AUXCLICK: "auxclick",
  DBLCLICK: "dblclick",
  MOUSE_UP: "mouseup",
  MOUSE_DOWN: "mousedown",
  MOUSE_OVER: "mouseover",
  MOUSE_MOVE: "mousemove",
  MOUSE_OUT: "mouseout",
  MOUSE_ENTER: "mouseenter",
  MOUSE_LEAVE: "mouseleave",
  MOUSE_WHEEL: "wheel",
  POINTER_UP: "pointerup",
  POINTER_DOWN: "pointerdown",
  POINTER_MOVE: "pointermove",
  POINTER_LEAVE: "pointerleave",
  CONTEXT_MENU: "contextmenu",
  // Keyboard
  KEY_DOWN: "keydown",
  KEY_UP: "keyup",
  BEFORE_UNLOAD: "beforeunload",
  CHANGE: "change",
  FOCUS: "focus",
  FOCUS_IN: "focusin",
  FOCUS_OUT: "focusout",
  BLUR: "blur",
  INPUT: "input",
  // Drag
  DRAG_START: "dragstart",
  DRAG: "drag",
  DRAG_ENTER: "dragenter",
  DRAG_LEAVE: "dragleave",
  DRAG_OVER: "dragover",
  DROP: "drop",
  DRAG_END: "dragend"
};
function j6(s) {
  const e = s;
  return !!(e && typeof e.preventDefault == "function" && typeof e.stopPropagation == "function");
}
const Ve = {
  stop: (s, e) => (s.preventDefault(), e && s.stopPropagation(), s)
};
function Y6(s) {
  const e = [];
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    e[t] = s.scrollTop, s = s.parentNode;
  return e;
}
function K6(s, e) {
  for (let t = 0; s && s.nodeType === s.ELEMENT_NODE; t++)
    s.scrollTop !== e[t] && (s.scrollTop = e[t]), s = s.parentNode;
}
class lC extends V {
  static hasFocusWithin(e) {
    if (Bi(e)) {
      const t = pu(e), i = t ? t.activeElement : e.ownerDocument.activeElement;
      return yi(i, e);
    } else {
      const t = e;
      return yi(t.document.activeElement, t.document);
    }
  }
  constructor(e) {
    super(), this._onDidFocus = this._register(new B()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new B()), this.onDidBlur = this._onDidBlur.event;
    let t = lC.hasFocusWithin(e), i = !1;
    const n = () => {
      i = !1, t || (t = !0, this._onDidFocus.fire());
    }, o = () => {
      t && (i = !0, (Bi(e) ? fe(e) : e).setTimeout(() => {
        i && (i = !1, t = !1, this._onDidBlur.fire());
      }, 0));
    };
    this._refreshStateHandler = () => {
      lC.hasFocusWithin(e) !== t && (t ? o() : n());
    }, this._register(U(e, ee.FOCUS, n, !0)), this._register(U(e, ee.BLUR, o, !0)), Bi(e) && (this._register(U(e, ee.FOCUS_IN, () => this._refreshStateHandler())), this._register(U(e, ee.FOCUS_OUT, () => this._refreshStateHandler())));
  }
}
function Wl(s) {
  return new lC(s);
}
function J6(s, e) {
  return s.after(e), e;
}
function K(s, ...e) {
  if (s.append(...e), e.length === 1 && typeof e[0] != "string")
    return e[0];
}
function $M(s, e) {
  return s.insertBefore(e, s.firstChild), e;
}
function Rn(s, ...e) {
  s.innerText = "", K(s, ...e);
}
const q6 = /([\w\-]+)?(#([\w\-]+))?((\.([\w\-]+))*)/;
var NA;
(function(s) {
  s.HTML = "http://www.w3.org/1999/xhtml", s.SVG = "http://www.w3.org/2000/svg";
})(NA || (NA = {}));
function YH(s, e, t, ...i) {
  const n = q6.exec(e);
  if (!n)
    throw new Error("Bad use of emmet");
  const o = n[1] || "div";
  let r;
  return s !== NA.HTML ? r = document.createElementNS(s, o) : r = document.createElement(o), n[3] && (r.id = n[3]), n[4] && (r.className = n[4].replace(/\./g, " ").trim()), t && Object.entries(t).forEach(([a, l]) => {
    typeof l > "u" || (/^on\w+$/.test(a) ? r[a] = l : a === "selected" ? l && r.setAttribute(a, "true") : r.setAttribute(a, l));
  }), r.append(...i), r;
}
function de(s, e, ...t) {
  return YH(NA.HTML, s, e, ...t);
}
de.SVG = function(s, e, ...t) {
  return YH(NA.SVG, s, e, ...t);
};
function $6(s, ...e) {
  s ? ps(...e) : Dn(...e);
}
function ps(...s) {
  for (const e of s)
    e.style.display = "", e.removeAttribute("aria-hidden");
}
function Dn(...s) {
  for (const e of s)
    e.style.display = "none", e.setAttribute("aria-hidden", "true");
}
function gR(s, e) {
  const t = s.devicePixelRatio * e;
  return Math.max(1, Math.floor(t)) / s.devicePixelRatio;
}
function KH(s) {
  vt.open(s, "_blank", "noopener");
}
function X6(s, e) {
  const t = () => {
    e(), i = ys(s, t);
  };
  let i = ys(s, t);
  return we(() => i.dispose());
}
PH.setPreferredWebSchema(/^https:/.test(vt.location.href) ? "https" : "http");
function Vl(s) {
  return s ? `url('${w0.uriToBrowserUri(s).toString(!0).replace(/'/g, "%27")}')` : "url('')";
}
function oy(s) {
  return `'${s.replace(/'/g, "%27")}'`;
}
function Tl(s, e) {
  if (s !== void 0) {
    const t = s.match(/^\s*var\((.+)\)$/);
    if (t) {
      const i = t[1].split(",", 2);
      return i.length === 2 && (e = Tl(i[1].trim(), e)), `var(${i[0]}, ${e})`;
    }
    return s;
  }
  return e;
}
function Z6(s, e = !1) {
  const t = document.createElement("a");
  return FH("afterSanitizeAttributes", (i) => {
    for (const n of ["href", "src"])
      if (i.hasAttribute(n)) {
        const o = i.getAttribute(n);
        if (n === "href" && o.startsWith("#"))
          continue;
        if (t.href = o, !s.includes(t.protocol.replace(/:$/, ""))) {
          if (e && n === "src" && t.href.startsWith("data:"))
            continue;
          i.removeAttribute(n);
        }
      }
  }), we(() => {
    OH("afterSanitizeAttributes");
  });
}
const eU = Object.freeze([
  "a",
  "abbr",
  "b",
  "bdo",
  "blockquote",
  "br",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "i",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "li",
  "mark",
  "ol",
  "p",
  "pre",
  "q",
  "rp",
  "rt",
  "ruby",
  "samp",
  "small",
  "small",
  "source",
  "span",
  "strike",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "time",
  "tr",
  "tt",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
]);
class bl extends B {
  constructor() {
    super(), this._subscriptions = new X(), this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    }, this._subscriptions.add(te.runAndSubscribe(S0, ({ window: e, disposables: t }) => this.registerListeners(e, t), { window: vt, disposables: this._subscriptions }));
  }
  registerListeners(e, t) {
    t.add(U(e, "keydown", (i) => {
      if (i.defaultPrevented)
        return;
      const n = new Mt(i);
      if (!(n.keyCode === 6 && i.repeat)) {
        if (i.altKey && !this._keyStatus.altKey)
          this._keyStatus.lastKeyPressed = "alt";
        else if (i.ctrlKey && !this._keyStatus.ctrlKey)
          this._keyStatus.lastKeyPressed = "ctrl";
        else if (i.metaKey && !this._keyStatus.metaKey)
          this._keyStatus.lastKeyPressed = "meta";
        else if (i.shiftKey && !this._keyStatus.shiftKey)
          this._keyStatus.lastKeyPressed = "shift";
        else if (n.keyCode !== 6)
          this._keyStatus.lastKeyPressed = void 0;
        else
          return;
        this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyPressed && (this._keyStatus.event = i, this.fire(this._keyStatus));
      }
    }, !0)), t.add(U(e, "keyup", (i) => {
      i.defaultPrevented || (!i.altKey && this._keyStatus.altKey ? this._keyStatus.lastKeyReleased = "alt" : !i.ctrlKey && this._keyStatus.ctrlKey ? this._keyStatus.lastKeyReleased = "ctrl" : !i.metaKey && this._keyStatus.metaKey ? this._keyStatus.lastKeyReleased = "meta" : !i.shiftKey && this._keyStatus.shiftKey ? this._keyStatus.lastKeyReleased = "shift" : this._keyStatus.lastKeyReleased = void 0, this._keyStatus.lastKeyPressed !== this._keyStatus.lastKeyReleased && (this._keyStatus.lastKeyPressed = void 0), this._keyStatus.altKey = i.altKey, this._keyStatus.ctrlKey = i.ctrlKey, this._keyStatus.metaKey = i.metaKey, this._keyStatus.shiftKey = i.shiftKey, this._keyStatus.lastKeyReleased && (this._keyStatus.event = i, this.fire(this._keyStatus)));
    }, !0)), t.add(U(e.document.body, "mousedown", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(U(e.document.body, "mouseup", () => {
      this._keyStatus.lastKeyPressed = void 0;
    }, !0)), t.add(U(e.document.body, "mousemove", (i) => {
      i.buttons && (this._keyStatus.lastKeyPressed = void 0);
    }, !0)), t.add(U(e, "blur", () => {
      this.resetKeyStatus();
    }));
  }
  get keyStatus() {
    return this._keyStatus;
  }
  /**
   * Allows to explicitly reset the key status based on more knowledge (#109062)
   */
  resetKeyStatus() {
    this.doResetKeyStatus(), this.fire(this._keyStatus);
  }
  doResetKeyStatus() {
    this._keyStatus = {
      altKey: !1,
      shiftKey: !1,
      ctrlKey: !1,
      metaKey: !1
    };
  }
  static getInstance() {
    return bl.instance || (bl.instance = new bl()), bl.instance;
  }
  dispose() {
    super.dispose(), this._subscriptions.dispose();
  }
}
class tU extends V {
  constructor(e, t) {
    super(), this.element = e, this.callbacks = t, this.counter = 0, this.dragStartTime = 0, this.registerListeners();
  }
  registerListeners() {
    this.callbacks.onDragStart && this._register(U(this.element, ee.DRAG_START, (e) => {
      this.callbacks.onDragStart?.(e);
    })), this.callbacks.onDrag && this._register(U(this.element, ee.DRAG, (e) => {
      this.callbacks.onDrag?.(e);
    })), this._register(U(this.element, ee.DRAG_ENTER, (e) => {
      this.counter++, this.dragStartTime = e.timeStamp, this.callbacks.onDragEnter?.(e);
    })), this._register(U(this.element, ee.DRAG_OVER, (e) => {
      e.preventDefault(), this.callbacks.onDragOver?.(e, e.timeStamp - this.dragStartTime);
    })), this._register(U(this.element, ee.DRAG_LEAVE, (e) => {
      this.counter--, this.counter === 0 && (this.dragStartTime = 0, this.callbacks.onDragLeave?.(e));
    })), this._register(U(this.element, ee.DRAG_END, (e) => {
      this.counter = 0, this.dragStartTime = 0, this.callbacks.onDragEnd?.(e);
    })), this._register(U(this.element, ee.DROP, (e) => {
      this.counter = 0, this.dragStartTime = 0, this.callbacks.onDrop?.(e);
    }));
  }
}
const iU = /(?<tag>[\w\-]+)?(?:#(?<id>[\w\-]+))?(?<class>(?:\.(?:[\w\-]+))*)(?:@(?<name>(?:[\w\_])+))?/;
function it(s, ...e) {
  let t, i;
  Array.isArray(e[0]) ? (t = {}, i = e[0]) : (t = e[0] || {}, i = e[1]);
  const n = iU.exec(s);
  if (!n || !n.groups)
    throw new Error("Bad use of h");
  const o = n.groups.tag || "div", r = document.createElement(o);
  n.groups.id && (r.id = n.groups.id);
  const a = [];
  if (n.groups.class)
    for (const c of n.groups.class.split("."))
      c !== "" && a.push(c);
  if (t.className !== void 0)
    for (const c of t.className.split("."))
      c !== "" && a.push(c);
  a.length > 0 && (r.className = a.join(" "));
  const l = {};
  if (n.groups.name && (l[n.groups.name] = r), i)
    for (const c of i)
      Bi(c) ? r.appendChild(c) : typeof c == "string" ? r.append(c) : "root" in c && (Object.assign(l, c), r.appendChild(c.root));
  for (const [c, d] of Object.entries(t))
    if (c !== "className")
      if (c === "style")
        for (const [h, u] of Object.entries(d))
          r.style.setProperty(fR(h), typeof u == "number" ? u + "px" : "" + u);
      else c === "tabIndex" ? r.tabIndex = d : r.setAttribute(fR(c), d.toString());
  return l.root = r, l;
}
function fR(s) {
  return s.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
class nU extends V {
  constructor(e) {
    super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._listener = () => this._handleChange(e, !0), this._mediaQueryList = null, this._handleChange(e, !1);
  }
  _handleChange(e, t) {
    this._mediaQueryList?.removeEventListener("change", this._listener), this._mediaQueryList = e.matchMedia(`(resolution: ${e.devicePixelRatio}dppx)`), this._mediaQueryList.addEventListener("change", this._listener), t && this._onDidChange.fire();
  }
}
class sU extends V {
  get value() {
    return this._value;
  }
  constructor(e) {
    super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._value = this._getPixelRatio(e);
    const t = this._register(new nU(e));
    this._register(t.onDidChange(() => {
      this._value = this._getPixelRatio(e), this._onDidChange.fire(this._value);
    }));
  }
  _getPixelRatio(e) {
    const t = document.createElement("canvas").getContext("2d"), i = e.devicePixelRatio || 1, n = t.webkitBackingStorePixelRatio || t.mozBackingStorePixelRatio || t.msBackingStorePixelRatio || t.oBackingStorePixelRatio || t.backingStorePixelRatio || 1;
    return i / n;
  }
}
class oU {
  constructor() {
    this.mapWindowIdToPixelRatioMonitor = /* @__PURE__ */ new Map();
  }
  _getOrCreatePixelRatioMonitor(e) {
    const t = sC(e);
    let i = this.mapWindowIdToPixelRatioMonitor.get(t);
    return i || (i = new sU(e), this.mapWindowIdToPixelRatioMonitor.set(t, i), te.once(B6)(({ vscodeWindowId: n }) => {
      n === t && (i?.dispose(), this.mapWindowIdToPixelRatioMonitor.delete(t));
    })), i;
  }
  getInstance(e) {
    return this._getOrCreatePixelRatioMonitor(e);
  }
}
const TA = new oU();
class JH {
  constructor(e) {
    this.domNode = e, this._maxWidth = "", this._width = "", this._height = "", this._top = "", this._left = "", this._bottom = "", this._right = "", this._paddingLeft = "", this._fontFamily = "", this._fontWeight = "", this._fontSize = "", this._fontStyle = "", this._fontFeatureSettings = "", this._fontVariationSettings = "", this._textDecoration = "", this._lineHeight = "", this._letterSpacing = "", this._className = "", this._display = "", this._position = "", this._visibility = "", this._color = "", this._backgroundColor = "", this._layerHint = !1, this._contain = "none", this._boxShadow = "";
  }
  setMaxWidth(e) {
    const t = ur(e);
    this._maxWidth !== t && (this._maxWidth = t, this.domNode.style.maxWidth = this._maxWidth);
  }
  setWidth(e) {
    const t = ur(e);
    this._width !== t && (this._width = t, this.domNode.style.width = this._width);
  }
  setHeight(e) {
    const t = ur(e);
    this._height !== t && (this._height = t, this.domNode.style.height = this._height);
  }
  setTop(e) {
    const t = ur(e);
    this._top !== t && (this._top = t, this.domNode.style.top = this._top);
  }
  setLeft(e) {
    const t = ur(e);
    this._left !== t && (this._left = t, this.domNode.style.left = this._left);
  }
  setBottom(e) {
    const t = ur(e);
    this._bottom !== t && (this._bottom = t, this.domNode.style.bottom = this._bottom);
  }
  setRight(e) {
    const t = ur(e);
    this._right !== t && (this._right = t, this.domNode.style.right = this._right);
  }
  setPaddingLeft(e) {
    const t = ur(e);
    this._paddingLeft !== t && (this._paddingLeft = t, this.domNode.style.paddingLeft = this._paddingLeft);
  }
  setFontFamily(e) {
    this._fontFamily !== e && (this._fontFamily = e, this.domNode.style.fontFamily = this._fontFamily);
  }
  setFontWeight(e) {
    this._fontWeight !== e && (this._fontWeight = e, this.domNode.style.fontWeight = this._fontWeight);
  }
  setFontSize(e) {
    const t = ur(e);
    this._fontSize !== t && (this._fontSize = t, this.domNode.style.fontSize = this._fontSize);
  }
  setFontStyle(e) {
    this._fontStyle !== e && (this._fontStyle = e, this.domNode.style.fontStyle = this._fontStyle);
  }
  setFontFeatureSettings(e) {
    this._fontFeatureSettings !== e && (this._fontFeatureSettings = e, this.domNode.style.fontFeatureSettings = this._fontFeatureSettings);
  }
  setFontVariationSettings(e) {
    this._fontVariationSettings !== e && (this._fontVariationSettings = e, this.domNode.style.fontVariationSettings = this._fontVariationSettings);
  }
  setTextDecoration(e) {
    this._textDecoration !== e && (this._textDecoration = e, this.domNode.style.textDecoration = this._textDecoration);
  }
  setLineHeight(e) {
    const t = ur(e);
    this._lineHeight !== t && (this._lineHeight = t, this.domNode.style.lineHeight = this._lineHeight);
  }
  setLetterSpacing(e) {
    const t = ur(e);
    this._letterSpacing !== t && (this._letterSpacing = t, this.domNode.style.letterSpacing = this._letterSpacing);
  }
  setClassName(e) {
    this._className !== e && (this._className = e, this.domNode.className = this._className);
  }
  toggleClassName(e, t) {
    this.domNode.classList.toggle(e, t), this._className = this.domNode.className;
  }
  setDisplay(e) {
    this._display !== e && (this._display = e, this.domNode.style.display = this._display);
  }
  setPosition(e) {
    this._position !== e && (this._position = e, this.domNode.style.position = this._position);
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this.domNode.style.visibility = this._visibility);
  }
  setColor(e) {
    this._color !== e && (this._color = e, this.domNode.style.color = this._color);
  }
  setBackgroundColor(e) {
    this._backgroundColor !== e && (this._backgroundColor = e, this.domNode.style.backgroundColor = this._backgroundColor);
  }
  setLayerHinting(e) {
    this._layerHint !== e && (this._layerHint = e, this.domNode.style.transform = this._layerHint ? "translate3d(0px, 0px, 0px)" : "");
  }
  setBoxShadow(e) {
    this._boxShadow !== e && (this._boxShadow = e, this.domNode.style.boxShadow = e);
  }
  setContain(e) {
    this._contain !== e && (this._contain = e, this.domNode.style.contain = this._contain);
  }
  setAttribute(e, t) {
    this.domNode.setAttribute(e, t);
  }
  removeAttribute(e) {
    this.domNode.removeAttribute(e);
  }
  appendChild(e) {
    this.domNode.appendChild(e.domNode);
  }
  removeChild(e) {
    this.domNode.removeChild(e.domNode);
  }
}
function ur(s) {
  return typeof s == "number" ? `${s}px` : s;
}
function rt(s) {
  return new JH(s);
}
function cn(s, e) {
  s instanceof JH ? (s.setFontFamily(e.getMassagedFontFamily()), s.setFontWeight(e.fontWeight), s.setFontSize(e.fontSize), s.setFontFeatureSettings(e.fontFeatureSettings), s.setFontVariationSettings(e.fontVariationSettings), s.setLineHeight(e.lineHeight), s.setLetterSpacing(e.letterSpacing)) : (s.style.fontFamily = e.getMassagedFontFamily(), s.style.fontWeight = e.fontWeight, s.style.fontSize = e.fontSize + "px", s.style.fontFeatureSettings = e.fontFeatureSettings, s.style.fontVariationSettings = e.fontVariationSettings, s.style.lineHeight = e.lineHeight + "px", s.style.letterSpacing = e.letterSpacing + "px");
}
class rU {
  constructor(e, t) {
    this.chr = e, this.type = t, this.width = 0;
  }
  fulfill(e) {
    this.width = e;
  }
}
class XM {
  constructor(e, t) {
    this._bareFontInfo = e, this._requests = t, this._container = null, this._testElements = null;
  }
  read(e) {
    this._createDomElements(), e.document.body.appendChild(this._container), this._readFromDomElements(), this._container?.remove(), this._container = null, this._testElements = null;
  }
  _createDomElements() {
    const e = document.createElement("div");
    e.style.position = "absolute", e.style.top = "-50000px", e.style.width = "50000px";
    const t = document.createElement("div");
    cn(t, this._bareFontInfo), e.appendChild(t);
    const i = document.createElement("div");
    cn(i, this._bareFontInfo), i.style.fontWeight = "bold", e.appendChild(i);
    const n = document.createElement("div");
    cn(n, this._bareFontInfo), n.style.fontStyle = "italic", e.appendChild(n);
    const o = [];
    for (const r of this._requests) {
      let a;
      r.type === 0 && (a = t), r.type === 2 && (a = i), r.type === 1 && (a = n), a.appendChild(document.createElement("br"));
      const l = document.createElement("span");
      XM._render(l, r), a.appendChild(l), o.push(l);
    }
    this._container = e, this._testElements = o;
  }
  static _render(e, t) {
    if (t.chr === " ") {
      let i = " ";
      for (let n = 0; n < 8; n++)
        i += i;
      e.innerText = i;
    } else {
      let i = t.chr;
      for (let n = 0; n < 8; n++)
        i += i;
      e.textContent = i;
    }
  }
  _readFromDomElements() {
    for (let e = 0, t = this._requests.length; e < t; e++) {
      const i = this._requests[e], n = this._testElements[e];
      i.fulfill(n.offsetWidth / 256);
    }
  }
}
function aU(s, e, t) {
  new XM(e, t).read(s);
}
const _c = new class {
  constructor() {
    this._zoomLevel = 0, this._onDidChangeZoomLevel = new B(), this.onDidChangeZoomLevel = this._onDidChangeZoomLevel.event;
  }
  getZoomLevel() {
    return this._zoomLevel;
  }
  setZoomLevel(s) {
    s = Math.min(Math.max(-5, s), 20), this._zoomLevel !== s && (this._zoomLevel = s, this._onDidChangeZoomLevel.fire(this._zoomLevel));
  }
}(), lU = ze ? 1.5 : 1.35, ry = 8;
class Lh {
  /**
   * @internal
   */
  static createFromValidatedSettings(e, t, i) {
    const n = e.get(
      49
      /* EditorOption.fontFamily */
    ), o = e.get(
      53
      /* EditorOption.fontWeight */
    ), r = e.get(
      52
      /* EditorOption.fontSize */
    ), a = e.get(
      51
      /* EditorOption.fontLigatures */
    ), l = e.get(
      54
      /* EditorOption.fontVariations */
    ), c = e.get(
      67
      /* EditorOption.lineHeight */
    ), d = e.get(
      64
      /* EditorOption.letterSpacing */
    );
    return Lh._create(n, o, r, a, l, c, d, t, i);
  }
  /**
   * @internal
   */
  static _create(e, t, i, n, o, r, a, l, c) {
    r === 0 ? r = lU * i : r < ry && (r = r * i), r = Math.round(r), r < ry && (r = ry);
    const d = 1 + (c ? 0 : _c.getZoomLevel() * 0.1);
    return i *= d, r *= d, o === yA.TRANSLATE && (t === "normal" || t === "bold" ? o = yA.OFF : (o = `'wght' ${parseInt(t, 10)}`, t = "normal")), new Lh({
      pixelRatio: l,
      fontFamily: e,
      fontWeight: t,
      fontSize: i,
      fontFeatureSettings: n,
      fontVariationSettings: o,
      lineHeight: r,
      letterSpacing: a
    });
  }
  /**
   * @internal
   */
  constructor(e) {
    this._bareFontInfoBrand = void 0, this.pixelRatio = e.pixelRatio, this.fontFamily = String(e.fontFamily), this.fontWeight = String(e.fontWeight), this.fontSize = e.fontSize, this.fontFeatureSettings = e.fontFeatureSettings, this.fontVariationSettings = e.fontVariationSettings, this.lineHeight = e.lineHeight | 0, this.letterSpacing = e.letterSpacing;
  }
  /**
   * @internal
   */
  getId() {
    return `${this.pixelRatio}-${this.fontFamily}-${this.fontWeight}-${this.fontSize}-${this.fontFeatureSettings}-${this.fontVariationSettings}-${this.lineHeight}-${this.letterSpacing}`;
  }
  /**
   * @internal
   */
  getMassagedFontFamily() {
    const e = Zn.fontFamily, t = Lh._wrapInQuotes(this.fontFamily);
    return this.fontFamily !== e ? `${t}, ${e}` : t;
  }
  static _wrapInQuotes(e) {
    return /[,"']/.test(e) ? e : /[+ ]/.test(e) ? `"${e}"` : e;
  }
}
const cU = 2;
class QE extends Lh {
  /**
   * @internal
   */
  constructor(e, t) {
    super(e), this._editorStylingBrand = void 0, this.version = cU, this.isTrusted = t, this.isMonospace = e.isMonospace, this.typicalHalfwidthCharacterWidth = e.typicalHalfwidthCharacterWidth, this.typicalFullwidthCharacterWidth = e.typicalFullwidthCharacterWidth, this.canUseHalfwidthRightwardsArrow = e.canUseHalfwidthRightwardsArrow, this.spaceWidth = e.spaceWidth, this.middotWidth = e.middotWidth, this.wsmiddotWidth = e.wsmiddotWidth, this.maxDigitWidth = e.maxDigitWidth;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.fontFamily === e.fontFamily && this.fontWeight === e.fontWeight && this.fontSize === e.fontSize && this.fontFeatureSettings === e.fontFeatureSettings && this.fontVariationSettings === e.fontVariationSettings && this.lineHeight === e.lineHeight && this.letterSpacing === e.letterSpacing && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.typicalFullwidthCharacterWidth === e.typicalFullwidthCharacterWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.maxDigitWidth === e.maxDigitWidth;
  }
}
class dU extends V {
  constructor() {
    super(...arguments), this._cache = /* @__PURE__ */ new Map(), this._evictUntrustedReadingsTimeout = -1, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event;
  }
  dispose() {
    this._evictUntrustedReadingsTimeout !== -1 && (clearTimeout(this._evictUntrustedReadingsTimeout), this._evictUntrustedReadingsTimeout = -1), super.dispose();
  }
  /**
   * Clear all cached font information and trigger a change event.
   */
  clearAllFontInfos() {
    this._cache.clear(), this._onDidChange.fire();
  }
  _ensureCache(e) {
    const t = sC(e);
    let i = this._cache.get(t);
    return i || (i = new hU(), this._cache.set(t, i)), i;
  }
  _writeToCache(e, t, i) {
    this._ensureCache(e).put(t, i), !i.isTrusted && this._evictUntrustedReadingsTimeout === -1 && (this._evictUntrustedReadingsTimeout = e.setTimeout(() => {
      this._evictUntrustedReadingsTimeout = -1, this._evictUntrustedReadings(e);
    }, 5e3));
  }
  _evictUntrustedReadings(e) {
    const t = this._ensureCache(e), i = t.getValues();
    let n = !1;
    for (const o of i)
      o.isTrusted || (n = !0, t.remove(o));
    n && this._onDidChange.fire();
  }
  /**
   * Read font information.
   */
  readFontInfo(e, t) {
    const i = this._ensureCache(e);
    if (!i.has(t)) {
      let n = this._actualReadFontInfo(e, t);
      (n.typicalHalfwidthCharacterWidth <= 2 || n.typicalFullwidthCharacterWidth <= 2 || n.spaceWidth <= 2 || n.maxDigitWidth <= 2) && (n = new QE({
        pixelRatio: TA.getInstance(e).value,
        fontFamily: n.fontFamily,
        fontWeight: n.fontWeight,
        fontSize: n.fontSize,
        fontFeatureSettings: n.fontFeatureSettings,
        fontVariationSettings: n.fontVariationSettings,
        lineHeight: n.lineHeight,
        letterSpacing: n.letterSpacing,
        isMonospace: n.isMonospace,
        typicalHalfwidthCharacterWidth: Math.max(n.typicalHalfwidthCharacterWidth, 5),
        typicalFullwidthCharacterWidth: Math.max(n.typicalFullwidthCharacterWidth, 5),
        canUseHalfwidthRightwardsArrow: n.canUseHalfwidthRightwardsArrow,
        spaceWidth: Math.max(n.spaceWidth, 5),
        middotWidth: Math.max(n.middotWidth, 5),
        wsmiddotWidth: Math.max(n.wsmiddotWidth, 5),
        maxDigitWidth: Math.max(n.maxDigitWidth, 5)
      }, !1)), this._writeToCache(e, t, n);
    }
    return i.get(t);
  }
  _createRequest(e, t, i, n) {
    const o = new rU(e, t);
    return i.push(o), n?.push(o), o;
  }
  _actualReadFontInfo(e, t) {
    const i = [], n = [], o = this._createRequest("n", 0, i, n), r = this._createRequest("ｍ", 0, i, null), a = this._createRequest(" ", 0, i, n), l = this._createRequest("0", 0, i, n), c = this._createRequest("1", 0, i, n), d = this._createRequest("2", 0, i, n), h = this._createRequest("3", 0, i, n), u = this._createRequest("4", 0, i, n), g = this._createRequest("5", 0, i, n), m = this._createRequest("6", 0, i, n), p = this._createRequest("7", 0, i, n), A = this._createRequest("8", 0, i, n), _ = this._createRequest("9", 0, i, n), b = this._createRequest("→", 0, i, n), C = this._createRequest("￫", 0, i, null), w = this._createRequest("·", 0, i, n), S = this._createRequest("⸱", 0, i, null), x = "|/-_ilm%";
    for (let P = 0, W = x.length; P < W; P++)
      this._createRequest(x.charAt(P), 0, i, n), this._createRequest(x.charAt(P), 1, i, n), this._createRequest(x.charAt(P), 2, i, n);
    aU(e, t, i);
    const y = Math.max(l.width, c.width, d.width, h.width, u.width, g.width, m.width, p.width, A.width, _.width);
    let D = t.fontFeatureSettings === hu.OFF;
    const I = n[0].width;
    for (let P = 1, W = n.length; D && P < W; P++) {
      const j = I - n[P].width;
      if (j < -1e-3 || j > 1e-3) {
        D = !1;
        break;
      }
    }
    let Q = !0;
    return D && C.width !== I && (Q = !1), C.width > b.width && (Q = !1), new QE({
      pixelRatio: TA.getInstance(e).value,
      fontFamily: t.fontFamily,
      fontWeight: t.fontWeight,
      fontSize: t.fontSize,
      fontFeatureSettings: t.fontFeatureSettings,
      fontVariationSettings: t.fontVariationSettings,
      lineHeight: t.lineHeight,
      letterSpacing: t.letterSpacing,
      isMonospace: D,
      typicalHalfwidthCharacterWidth: o.width,
      typicalFullwidthCharacterWidth: r.width,
      canUseHalfwidthRightwardsArrow: Q,
      spaceWidth: a.width,
      middotWidth: w.width,
      wsmiddotWidth: S.width,
      maxDigitWidth: y
    }, !0);
  }
}
class hU {
  constructor() {
    this._keys = /* @__PURE__ */ Object.create(null), this._values = /* @__PURE__ */ Object.create(null);
  }
  has(e) {
    const t = e.getId();
    return !!this._values[t];
  }
  get(e) {
    const t = e.getId();
    return this._values[t];
  }
  put(e, t) {
    const i = e.getId();
    this._keys[i] = e, this._values[i] = t;
  }
  remove(e) {
    const t = e.getId();
    delete this._keys[t], delete this._values[t];
  }
  getValues() {
    return Object.keys(this._keys).map((e) => this._values[e]);
  }
}
const GE = new dU();
var Mr;
(function(s) {
  s.serviceIds = /* @__PURE__ */ new Map(), s.DI_TARGET = "$di$target", s.DI_DEPENDENCIES = "$di$dependencies";
  function e(t) {
    return t[s.DI_DEPENDENCIES] || [];
  }
  s.getServiceDependencies = e;
})(Mr || (Mr = {}));
const ke = We("instantiationService");
function uU(s, e, t) {
  e[Mr.DI_TARGET] === e ? e[Mr.DI_DEPENDENCIES].push({ id: s, index: t }) : (e[Mr.DI_DEPENDENCIES] = [{ id: s, index: t }], e[Mr.DI_TARGET] = e);
}
function We(s) {
  if (Mr.serviceIds.has(s))
    return Mr.serviceIds.get(s);
  const e = function(t, i, n) {
    if (arguments.length !== 3)
      throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
    uU(e, t, n);
  };
  return e.toString = () => s, Mr.serviceIds.set(s, e), e;
}
const Nt = We("codeEditorService"), Fi = We("modelService"), Zs = We("textModelService");
class Ks extends V {
  constructor(e, t = "", i = "", n = !0, o) {
    super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._enabled = !0, this._id = e, this._label = t, this._cssClass = i, this._enabled = n, this._actionCallback = o;
  }
  get id() {
    return this._id;
  }
  get label() {
    return this._label;
  }
  set label(e) {
    this._setLabel(e);
  }
  _setLabel(e) {
    this._label !== e && (this._label = e, this._onDidChange.fire({ label: e }));
  }
  get tooltip() {
    return this._tooltip || "";
  }
  set tooltip(e) {
    this._setTooltip(e);
  }
  _setTooltip(e) {
    this._tooltip !== e && (this._tooltip = e, this._onDidChange.fire({ tooltip: e }));
  }
  get class() {
    return this._cssClass;
  }
  set class(e) {
    this._setClass(e);
  }
  _setClass(e) {
    this._cssClass !== e && (this._cssClass = e, this._onDidChange.fire({ class: e }));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._setEnabled(e);
  }
  _setEnabled(e) {
    this._enabled !== e && (this._enabled = e, this._onDidChange.fire({ enabled: e }));
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._setChecked(e);
  }
  _setChecked(e) {
    this._checked !== e && (this._checked = e, this._onDidChange.fire({ checked: e }));
  }
  async run(e, t) {
    this._actionCallback && await this._actionCallback(e);
  }
}
class Au extends V {
  constructor() {
    super(...arguments), this._onWillRun = this._register(new B()), this.onWillRun = this._onWillRun.event, this._onDidRun = this._register(new B()), this.onDidRun = this._onDidRun.event;
  }
  async run(e, t) {
    if (!e.enabled)
      return;
    this._onWillRun.fire({ action: e });
    let i;
    try {
      await this.runAction(e, t);
    } catch (n) {
      i = n;
    }
    this._onDidRun.fire({ action: e, error: i });
  }
  async runAction(e, t) {
    await e.run(t);
  }
}
const lA = class lA {
  constructor() {
    this.id = lA.ID, this.label = "", this.tooltip = "", this.class = "separator", this.enabled = !1, this.checked = !1;
  }
  /**
   * Joins all non-empty lists of actions with separators.
   */
  static join(...e) {
    let t = [];
    for (const i of e)
      i.length && (t.length ? t = [...t, new lA(), ...i] : t = i);
    return t;
  }
  async run() {
  }
};
lA.ID = "vs.actions.separator";
let Ri = lA;
class Uf {
  get actions() {
    return this._actions;
  }
  constructor(e, t, i, n) {
    this.tooltip = "", this.enabled = !0, this.checked = void 0, this.id = e, this.label = t, this.class = n, this._actions = i;
  }
  async run() {
  }
}
const m1 = class m1 extends Ks {
  constructor() {
    super(m1.ID, f("submenu.empty", "(empty)"), void 0, !1);
  }
};
m1.ID = "vs.actions.empty";
let jE = m1;
function gf(s) {
  return {
    id: s.id,
    label: s.label,
    tooltip: s.tooltip ?? s.label,
    class: s.class,
    enabled: s.enabled ?? !0,
    checked: s.checked,
    run: async (...e) => s.run(...e)
  };
}
var YE;
(function(s) {
  function e(t) {
    return t && typeof t == "object" && typeof t.id == "string";
  }
  s.isThemeColor = e;
})(YE || (YE = {}));
var pe;
(function(s) {
  s.iconNameSegment = "[A-Za-z0-9]+", s.iconNameExpression = "[A-Za-z0-9-]+", s.iconModifierExpression = "~[A-Za-z]+", s.iconNameCharacter = "[A-Za-z0-9~-]";
  const e = new RegExp(`^(${s.iconNameExpression})(${s.iconModifierExpression})?$`);
  function t(u) {
    const g = e.exec(u.id);
    if (!g)
      return t(Z.error);
    const [, m, p] = g, A = ["codicon", "codicon-" + m];
    return p && A.push("codicon-modifier-" + p.substring(1)), A;
  }
  s.asClassNameArray = t;
  function i(u) {
    return t(u).join(" ");
  }
  s.asClassName = i;
  function n(u) {
    return "." + t(u).join(".");
  }
  s.asCSSSelector = n;
  function o(u) {
    return u && typeof u == "object" && typeof u.id == "string" && (typeof u.color > "u" || YE.isThemeColor(u.color));
  }
  s.isThemeIcon = o;
  const r = new RegExp(`^\\$\\((${s.iconNameExpression}(?:${s.iconModifierExpression})?)\\)$`);
  function a(u) {
    const g = r.exec(u);
    if (!g)
      return;
    const [, m] = g;
    return { id: m };
  }
  s.fromString = a;
  function l(u) {
    return { id: u };
  }
  s.fromId = l;
  function c(u, g) {
    let m = u.id;
    const p = m.lastIndexOf("~");
    return p !== -1 && (m = m.substring(0, p)), g && (m = `${m}~${g}`), { id: m };
  }
  s.modify = c;
  function d(u) {
    const g = u.id.lastIndexOf("~");
    if (g !== -1)
      return u.id.substring(g + 1);
  }
  s.getModifier = d;
  function h(u, g) {
    return u.id === g.id && u.color?.id === g.color?.id;
  }
  s.isEqual = h;
})(pe || (pe = {}));
const bi = We("commandService"), mt = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._onDidRegisterCommand = new B(), this.onDidRegisterCommand = this._onDidRegisterCommand.event;
  }
  registerCommand(s, e) {
    if (!s)
      throw new Error("invalid command");
    if (typeof s == "string") {
      if (!e)
        throw new Error("invalid command");
      return this.registerCommand({ id: s, handler: e });
    }
    if (s.metadata && Array.isArray(s.metadata.args)) {
      const r = [];
      for (const l of s.metadata.args)
        r.push(l.constraint);
      const a = s.handler;
      s.handler = function(l, ...c) {
        return E9(c, r), a(l, ...c);
      };
    }
    const { id: t } = s;
    let i = this._commands.get(t);
    i || (i = new Nn(), this._commands.set(t, i));
    const n = i.unshift(s), o = we(() => {
      n(), this._commands.get(t)?.isEmpty() && this._commands.delete(t);
    });
    return this._onDidRegisterCommand.fire(t), o;
  }
  registerCommandAlias(s, e) {
    return mt.registerCommand(s, (t, ...i) => t.get(bi).executeCommand(e, ...i));
  }
  getCommand(s) {
    const e = this._commands.get(s);
    if (!(!e || e.isEmpty()))
      return nt.first(e);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    for (const e of this._commands.keys()) {
      const t = this.getCommand(e);
      t && s.set(e, t);
    }
    return s;
  }
}();
mt.registerCommand("noop", () => {
});
function ay(...s) {
  switch (s.length) {
    case 1:
      return f("contextkey.scanner.hint.didYouMean1", "Did you mean {0}?", s[0]);
    case 2:
      return f("contextkey.scanner.hint.didYouMean2", "Did you mean {0} or {1}?", s[0], s[1]);
    case 3:
      return f("contextkey.scanner.hint.didYouMean3", "Did you mean {0}, {1} or {2}?", s[0], s[1], s[2]);
    default:
      return;
  }
}
const gU = f("contextkey.scanner.hint.didYouForgetToOpenOrCloseQuote", "Did you forget to open or close the quote?"), fU = f("contextkey.scanner.hint.didYouForgetToEscapeSlash", "Did you forget to escape the '/' (slash) character? Put two backslashes before it to escape, e.g., '\\\\/'.");
var Ll;
let Gm = (Ll = class {
  constructor() {
    this._input = "", this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this.stringRe = /[a-zA-Z0-9_<>\-\./\\:\*\?\+\[\]\^,#@;"%\$\p{L}-]+/uy;
  }
  static getLexeme(e) {
    switch (e.type) {
      case 0:
        return "(";
      case 1:
        return ")";
      case 2:
        return "!";
      case 3:
        return e.isTripleEq ? "===" : "==";
      case 4:
        return e.isTripleEq ? "!==" : "!=";
      case 5:
        return "<";
      case 6:
        return "<=";
      case 7:
        return ">=";
      case 8:
        return ">=";
      case 9:
        return "=~";
      case 10:
        return e.lexeme;
      case 11:
        return "true";
      case 12:
        return "false";
      case 13:
        return "in";
      case 14:
        return "not";
      case 15:
        return "&&";
      case 16:
        return "||";
      case 17:
        return e.lexeme;
      case 18:
        return e.lexeme;
      case 19:
        return e.lexeme;
      case 20:
        return "EOF";
      default:
        throw kM(`unhandled token type: ${JSON.stringify(e)}; have you forgotten to add a case?`);
    }
  }
  reset(e) {
    return this._input = e, this._start = 0, this._current = 0, this._tokens = [], this._errors = [], this;
  }
  scan() {
    for (; !this._isAtEnd(); )
      switch (this._start = this._current, this._advance()) {
        case 40:
          this._addToken(
            0
            /* TokenType.LParen */
          );
          break;
        case 41:
          this._addToken(
            1
            /* TokenType.RParen */
          );
          break;
        case 33:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 4, offset: this._start, isTripleEq: t });
          } else
            this._addToken(
              2
              /* TokenType.Neg */
            );
          break;
        case 39:
          this._quotedString();
          break;
        case 47:
          this._regex();
          break;
        case 61:
          if (this._match(
            61
            /* CharCode.Equals */
          )) {
            const t = this._match(
              61
              /* CharCode.Equals */
            );
            this._tokens.push({ type: 3, offset: this._start, isTripleEq: t });
          } else this._match(
            126
            /* CharCode.Tilde */
          ) ? this._addToken(
            9
            /* TokenType.RegexOp */
          ) : this._error(ay("==", "=~"));
          break;
        case 60:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 6 : 5
            /* TokenType.Lt */
          );
          break;
        case 62:
          this._addToken(
            this._match(
              61
              /* CharCode.Equals */
            ) ? 8 : 7
            /* TokenType.Gt */
          );
          break;
        case 38:
          this._match(
            38
            /* CharCode.Ampersand */
          ) ? this._addToken(
            15
            /* TokenType.And */
          ) : this._error(ay("&&"));
          break;
        case 124:
          this._match(
            124
            /* CharCode.Pipe */
          ) ? this._addToken(
            16
            /* TokenType.Or */
          ) : this._error(ay("||"));
          break;
        case 32:
        case 13:
        case 9:
        case 10:
        case 160:
          break;
        default:
          this._string();
      }
    return this._start = this._current, this._addToken(
      20
      /* TokenType.EOF */
    ), Array.from(this._tokens);
  }
  _match(e) {
    return this._isAtEnd() || this._input.charCodeAt(this._current) !== e ? !1 : (this._current++, !0);
  }
  _advance() {
    return this._input.charCodeAt(this._current++);
  }
  _peek() {
    return this._isAtEnd() ? 0 : this._input.charCodeAt(this._current);
  }
  _addToken(e) {
    this._tokens.push({ type: e, offset: this._start });
  }
  _error(e) {
    const t = this._start, i = this._input.substring(this._start, this._current), n = { type: 19, offset: this._start, lexeme: i };
    this._errors.push({ offset: t, lexeme: i, additionalInfo: e }), this._tokens.push(n);
  }
  _string() {
    this.stringRe.lastIndex = this._start;
    const e = this.stringRe.exec(this._input);
    if (e) {
      this._current = this._start + e[0].length;
      const t = this._input.substring(this._start, this._current), i = Ll._keywords.get(t);
      i ? this._addToken(i) : this._tokens.push({ type: 17, lexeme: t, offset: this._start });
    }
  }
  // captures the lexeme without the leading and trailing '
  _quotedString() {
    for (; this._peek() !== 39 && !this._isAtEnd(); )
      this._advance();
    if (this._isAtEnd()) {
      this._error(gU);
      return;
    }
    this._advance(), this._tokens.push({ type: 18, lexeme: this._input.substring(this._start + 1, this._current - 1), offset: this._start + 1 });
  }
  /*
   * Lexing a regex expression: /.../[igsmyu]*
   * Based on https://github.com/microsoft/TypeScript/blob/9247ef115e617805983740ba795d7a8164babf89/src/compiler/scanner.ts#L2129-L2181
   *
   * Note that we want slashes within a regex to be escaped, e.g., /file:\\/\\/\\// should match `file:///`
   */
  _regex() {
    let e = this._current, t = !1, i = !1;
    for (; ; ) {
      if (e >= this._input.length) {
        this._current = e, this._error(fU);
        return;
      }
      const o = this._input.charCodeAt(e);
      if (t)
        t = !1;
      else if (o === 47 && !i) {
        e++;
        break;
      } else o === 91 ? i = !0 : o === 92 ? t = !0 : o === 93 && (i = !1);
      e++;
    }
    for (; e < this._input.length && Ll._regexFlags.has(this._input.charCodeAt(e)); )
      e++;
    this._current = e;
    const n = this._input.substring(this._start, this._current);
    this._tokens.push({ type: 10, lexeme: n, offset: this._start });
  }
  _isAtEnd() {
    return this._current >= this._input.length;
  }
}, Ll._regexFlags = new Set(["i", "g", "s", "m", "y", "u"].map((e) => e.charCodeAt(0))), Ll._keywords = /* @__PURE__ */ new Map([
  [
    "not",
    14
    /* TokenType.Not */
  ],
  [
    "in",
    13
    /* TokenType.In */
  ],
  [
    "false",
    12
    /* TokenType.False */
  ],
  [
    "true",
    11
    /* TokenType.True */
  ]
]), Ll);
const dn = /* @__PURE__ */ new Map();
dn.set("false", !1);
dn.set("true", !0);
dn.set("isMac", ze);
dn.set("isLinux", Fn);
dn.set("isWindows", yn);
dn.set("isWeb", pm);
dn.set("isMacNative", ze && !pm);
dn.set("isEdge", V9);
dn.set("isFirefox", H9);
dn.set("isChrome", q4);
dn.set("isSafari", W9);
const mU = Object.prototype.hasOwnProperty, pU = {
  regexParsingWithErrorRecovery: !0
}, AU = f("contextkey.parser.error.emptyString", "Empty context key expression"), _U = f("contextkey.parser.error.emptyString.hint", "Did you forget to write an expression? You can also put 'false' or 'true' to always evaluate to false or true, respectively."), bU = f("contextkey.parser.error.noInAfterNot", "'in' after 'not'."), mR = f("contextkey.parser.error.closingParenthesis", "closing parenthesis ')'"), wU = f("contextkey.parser.error.unexpectedToken", "Unexpected token"), CU = f("contextkey.parser.error.unexpectedToken.hint", "Did you forget to put && or || before the token?"), vU = f("contextkey.parser.error.unexpectedEOF", "Unexpected end of expression"), SU = f("contextkey.parser.error.unexpectedEOF.hint", "Did you forget to put a context key?");
var ma;
let yU = (ma = class {
  constructor(e = pU) {
    this._config = e, this._scanner = new Gm(), this._tokens = [], this._current = 0, this._parsingErrors = [], this._flagsGYRe = /g|y/g;
  }
  /**
   * Parse a context key expression.
   *
   * @param input the expression to parse
   * @returns the parsed expression or `undefined` if there's an error - call `lexingErrors` and `parsingErrors` to see the errors
   */
  parse(e) {
    if (e === "") {
      this._parsingErrors.push({ message: AU, offset: 0, lexeme: "", additionalInfo: _U });
      return;
    }
    this._tokens = this._scanner.reset(e).scan(), this._current = 0, this._parsingErrors = [];
    try {
      const t = this._expr();
      if (!this._isAtEnd()) {
        const i = this._peek(), n = i.type === 17 ? CU : void 0;
        throw this._parsingErrors.push({ message: wU, offset: i.offset, lexeme: Gm.getLexeme(i), additionalInfo: n }), ma._parseError;
      }
      return t;
    } catch (t) {
      if (t !== ma._parseError)
        throw t;
      return;
    }
  }
  _expr() {
    return this._or();
  }
  _or() {
    const e = [this._and()];
    for (; this._matchOne(
      16
      /* TokenType.Or */
    ); ) {
      const t = this._and();
      e.push(t);
    }
    return e.length === 1 ? e[0] : ne.or(...e);
  }
  _and() {
    const e = [this._term()];
    for (; this._matchOne(
      15
      /* TokenType.And */
    ); ) {
      const t = this._term();
      e.push(t);
    }
    return e.length === 1 ? e[0] : ne.and(...e);
  }
  _term() {
    if (this._matchOne(
      2
      /* TokenType.Neg */
    )) {
      const e = this._peek();
      switch (e.type) {
        case 11:
          return this._advance(), Pn.INSTANCE;
        case 12:
          return this._advance(), ts.INSTANCE;
        case 0: {
          this._advance();
          const t = this._expr();
          return this._consume(1, mR), t?.negate();
        }
        case 17:
          return this._advance(), Ou.create(e.lexeme);
        default:
          throw this._errExpectedButGot("KEY | true | false | '(' expression ')'", e);
      }
    }
    return this._primary();
  }
  _primary() {
    const e = this._peek();
    switch (e.type) {
      case 11:
        return this._advance(), ne.true();
      case 12:
        return this._advance(), ne.false();
      case 0: {
        this._advance();
        const t = this._expr();
        return this._consume(1, mR), t;
      }
      case 17: {
        const t = e.lexeme;
        if (this._advance(), this._matchOne(
          9
          /* TokenType.RegexOp */
        )) {
          const n = this._peek();
          if (!this._config.regexParsingWithErrorRecovery) {
            if (this._advance(), n.type !== 10)
              throw this._errExpectedButGot("REGEX", n);
            const o = n.lexeme, r = o.lastIndexOf("/"), a = r === o.length - 1 ? void 0 : this._removeFlagsGY(o.substring(r + 1));
            let l;
            try {
              l = new RegExp(o.substring(1, r), a);
            } catch {
              throw this._errExpectedButGot("REGEX", n);
            }
            return BA.create(t, l);
          }
          switch (n.type) {
            case 10:
            case 19: {
              const o = [n.lexeme];
              this._advance();
              let r = this._peek(), a = 0;
              for (let u = 0; u < n.lexeme.length; u++)
                n.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
              for (; !this._isAtEnd() && r.type !== 15 && r.type !== 16; ) {
                switch (r.type) {
                  case 0:
                    a++;
                    break;
                  case 1:
                    a--;
                    break;
                  case 10:
                  case 18:
                    for (let u = 0; u < r.lexeme.length; u++)
                      r.lexeme.charCodeAt(u) === 40 ? a++ : n.lexeme.charCodeAt(u) === 41 && a--;
                }
                if (a < 0)
                  break;
                o.push(Gm.getLexeme(r)), this._advance(), r = this._peek();
              }
              const l = o.join(""), c = l.lastIndexOf("/"), d = c === l.length - 1 ? void 0 : this._removeFlagsGY(l.substring(c + 1));
              let h;
              try {
                h = new RegExp(l.substring(1, c), d);
              } catch {
                throw this._errExpectedButGot("REGEX", n);
              }
              return ne.regex(t, h);
            }
            case 18: {
              const o = n.lexeme;
              this._advance();
              let r = null;
              if (!AH(o)) {
                const a = o.indexOf("/"), l = o.lastIndexOf("/");
                if (a !== l && a >= 0) {
                  const c = o.slice(a + 1, l), d = o[l + 1] === "i" ? "i" : "";
                  try {
                    r = new RegExp(c, d);
                  } catch {
                    throw this._errExpectedButGot("REGEX", n);
                  }
                }
              }
              if (r === null)
                throw this._errExpectedButGot("REGEX", n);
              return BA.create(t, r);
            }
            default:
              throw this._errExpectedButGot("REGEX", this._peek());
          }
        }
        if (this._matchOne(
          14
          /* TokenType.Not */
        )) {
          this._consume(13, bU);
          const n = this._value();
          return ne.notIn(t, n);
        }
        switch (this._peek().type) {
          case 3: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return ne.equals(t, n);
            switch (n) {
              case "true":
                return ne.has(t);
              case "false":
                return ne.not(t);
              default:
                return ne.equals(t, n);
            }
          }
          case 4: {
            this._advance();
            const n = this._value();
            if (this._previous().type === 18)
              return ne.notEquals(t, n);
            switch (n) {
              case "true":
                return ne.not(t);
              case "false":
                return ne.has(t);
              default:
                return ne.notEquals(t, n);
            }
          }
          case 5:
            return this._advance(), N0.create(t, this._value());
          case 6:
            return this._advance(), T0.create(t, this._value());
          case 7:
            return this._advance(), I0.create(t, this._value());
          case 8:
            return this._advance(), M0.create(t, this._value());
          case 13:
            return this._advance(), ne.in(t, this._value());
          default:
            return ne.has(t);
        }
      }
      case 20:
        throw this._parsingErrors.push({ message: vU, offset: e.offset, lexeme: "", additionalInfo: SU }), ma._parseError;
      default:
        throw this._errExpectedButGot(`true | false | KEY 
	| KEY '=~' REGEX 
	| KEY ('==' | '!=' | '<' | '<=' | '>' | '>=' | 'in' | 'not' 'in') value`, this._peek());
    }
  }
  _value() {
    const e = this._peek();
    switch (e.type) {
      case 17:
      case 18:
        return this._advance(), e.lexeme;
      case 11:
        return this._advance(), "true";
      case 12:
        return this._advance(), "false";
      case 13:
        return this._advance(), "in";
      default:
        return "";
    }
  }
  _removeFlagsGY(e) {
    return e.replaceAll(this._flagsGYRe, "");
  }
  // careful: this can throw if current token is the initial one (ie index = 0)
  _previous() {
    return this._tokens[this._current - 1];
  }
  _matchOne(e) {
    return this._check(e) ? (this._advance(), !0) : !1;
  }
  _advance() {
    return this._isAtEnd() || this._current++, this._previous();
  }
  _consume(e, t) {
    if (this._check(e))
      return this._advance();
    throw this._errExpectedButGot(t, this._peek());
  }
  _errExpectedButGot(e, t, i) {
    const n = f("contextkey.parser.error.expectedButGot", `Expected: {0}
Received: '{1}'.`, e, Gm.getLexeme(t)), o = t.offset, r = Gm.getLexeme(t);
    return this._parsingErrors.push({ message: n, offset: o, lexeme: r, additionalInfo: i }), ma._parseError;
  }
  _check(e) {
    return this._peek().type === e;
  }
  _peek() {
    return this._tokens[this._current];
  }
  _isAtEnd() {
    return this._peek().type === 20;
  }
}, ma._parseError = new Error(), ma);
const IB = class IB {
  static false() {
    return Pn.INSTANCE;
  }
  static true() {
    return ts.INSTANCE;
  }
  static has(e) {
    return Fu.create(e);
  }
  static equals(e, t) {
    return M_.create(e, t);
  }
  static notEquals(e, t) {
    return k0.create(e, t);
  }
  static regex(e, t) {
    return BA.create(e, t);
  }
  static in(e, t) {
    return E0.create(e, t);
  }
  static notIn(e, t) {
    return L0.create(e, t);
  }
  static not(e) {
    return Ou.create(e);
  }
  static and(...e) {
    return bh.create(e, null, !0);
  }
  static or(...e) {
    return gl.create(e, null, !0);
  }
  static deserialize(e) {
    return e == null ? void 0 : this._parser.parse(e);
  }
};
IB._parser = new yU({ regexParsingWithErrorRecovery: !1 });
let ne = IB;
function xU(s, e) {
  const t = s ? s.substituteConstants() : void 0, i = e ? e.substituteConstants() : void 0;
  return !t && !i ? !0 : !t || !i ? !1 : t.equals(i);
}
function Tp(s, e) {
  return s.cmp(e);
}
const p1 = class p1 {
  constructor() {
    this.type = 0;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !1;
  }
  serialize() {
    return "false";
  }
  keys() {
    return [];
  }
  negate() {
    return ts.INSTANCE;
  }
};
p1.INSTANCE = new p1();
let Pn = p1;
const A1 = class A1 {
  constructor() {
    this.type = 1;
  }
  cmp(e) {
    return this.type - e.type;
  }
  equals(e) {
    return e.type === this.type;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !0;
  }
  serialize() {
    return "true";
  }
  keys() {
    return [];
  }
  negate() {
    return Pn.INSTANCE;
  }
};
A1.INSTANCE = new A1();
let ts = A1;
class Fu {
  static create(e, t = null) {
    const i = dn.get(e);
    return typeof i == "boolean" ? i ? ts.INSTANCE : Pn.INSTANCE : new Fu(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 2;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : $H(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = dn.get(this.key);
    return typeof e == "boolean" ? e ? ts.INSTANCE : Pn.INSTANCE : this;
  }
  evaluate(e) {
    return !!e.getValue(this.key);
  }
  serialize() {
    return this.key;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Ou.create(this.key, this)), this.negated;
  }
}
class M_ {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Fu.create(e, i) : Ou.create(e, i);
    const n = dn.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? ts.INSTANCE : Pn.INSTANCE : new M_(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 4;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = dn.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? ts.INSTANCE : Pn.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) == this.value;
  }
  serialize() {
    return `${this.key} == '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = k0.create(this.key, this.value, this)), this.negated;
  }
}
class E0 {
  static create(e, t) {
    return new E0(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 10, this.negated = null;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.valueKey, e.key, e.valueKey);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.valueKey === e.valueKey : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.valueKey), i = e.getValue(this.key);
    return Array.isArray(t) ? t.includes(i) : typeof i == "string" && typeof t == "object" && t !== null ? mU.call(t, i) : !1;
  }
  serialize() {
    return `${this.key} in '${this.valueKey}'`;
  }
  keys() {
    return [this.key, this.valueKey];
  }
  negate() {
    return this.negated || (this.negated = L0.create(this.key, this.valueKey)), this.negated;
  }
}
class L0 {
  static create(e, t) {
    return new L0(e, t);
  }
  constructor(e, t) {
    this.key = e, this.valueKey = t, this.type = 11, this._negated = E0.create(e, t);
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._negated.cmp(e._negated);
  }
  equals(e) {
    return e.type === this.type ? this._negated.equals(e._negated) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._negated.evaluate(e);
  }
  serialize() {
    return `${this.key} not in '${this.valueKey}'`;
  }
  keys() {
    return this._negated.keys();
  }
  negate() {
    return this._negated;
  }
}
class k0 {
  static create(e, t, i = null) {
    if (typeof t == "boolean")
      return t ? Ou.create(e, i) : Fu.create(e, i);
    const n = dn.get(e);
    return typeof n == "boolean" ? t === (n ? "true" : "false") ? Pn.INSTANCE : ts.INSTANCE : new k0(e, t, i);
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 5;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    const e = dn.get(this.key);
    if (typeof e == "boolean") {
      const t = e ? "true" : "false";
      return this.value === t ? Pn.INSTANCE : ts.INSTANCE;
    }
    return this;
  }
  evaluate(e) {
    return e.getValue(this.key) != this.value;
  }
  serialize() {
    return `${this.key} != '${this.value}'`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = M_.create(this.key, this.value, this)), this.negated;
  }
}
class Ou {
  static create(e, t = null) {
    const i = dn.get(e);
    return typeof i == "boolean" ? i ? Pn.INSTANCE : ts.INSTANCE : new Ou(e, t);
  }
  constructor(e, t) {
    this.key = e, this.negated = t, this.type = 3;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : $H(this.key, e.key);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key : !1;
  }
  substituteConstants() {
    const e = dn.get(this.key);
    return typeof e == "boolean" ? e ? Pn.INSTANCE : ts.INSTANCE : this;
  }
  evaluate(e) {
    return !e.getValue(this.key);
  }
  serialize() {
    return `!${this.key}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = Fu.create(this.key, this)), this.negated;
  }
}
function D0(s, e) {
  if (typeof s == "string") {
    const t = parseFloat(s);
    isNaN(t) || (s = t);
  }
  return typeof s == "string" || typeof s == "number" ? e(s) : Pn.INSTANCE;
}
class I0 {
  static create(e, t, i = null) {
    return D0(t, (n) => new I0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 12;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) > this.value;
  }
  serialize() {
    return `${this.key} > ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = T0.create(this.key, this.value, this)), this.negated;
  }
}
class M0 {
  static create(e, t, i = null) {
    return D0(t, (n) => new M0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 13;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) >= this.value;
  }
  serialize() {
    return `${this.key} >= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = N0.create(this.key, this.value, this)), this.negated;
  }
}
class N0 {
  static create(e, t, i = null) {
    return D0(t, (n) => new N0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 14;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) < this.value;
  }
  serialize() {
    return `${this.key} < ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = M0.create(this.key, this.value, this)), this.negated;
  }
}
class T0 {
  static create(e, t, i = null) {
    return D0(t, (n) => new T0(e, n, i));
  }
  constructor(e, t, i) {
    this.key = e, this.value = t, this.negated = i, this.type = 15;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : Pu(this.key, this.value, e.key, e.value);
  }
  equals(e) {
    return e.type === this.type ? this.key === e.key && this.value === e.value : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return typeof this.value == "string" ? !1 : parseFloat(e.getValue(this.key)) <= this.value;
  }
  serialize() {
    return `${this.key} <= ${this.value}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = I0.create(this.key, this.value, this)), this.negated;
  }
}
class BA {
  static create(e, t) {
    return new BA(e, t);
  }
  constructor(e, t) {
    this.key = e, this.regexp = t, this.type = 7, this.negated = null;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.key < e.key)
      return -1;
    if (this.key > e.key)
      return 1;
    const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
    return t < i ? -1 : t > i ? 1 : 0;
  }
  equals(e) {
    if (e.type === this.type) {
      const t = this.regexp ? this.regexp.source : "", i = e.regexp ? e.regexp.source : "";
      return this.key === e.key && t === i;
    }
    return !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    const t = e.getValue(this.key);
    return this.regexp ? this.regexp.test(t) : !1;
  }
  serialize() {
    const e = this.regexp ? `/${this.regexp.source}/${this.regexp.flags}` : "/invalid/";
    return `${this.key} =~ ${e}`;
  }
  keys() {
    return [this.key];
  }
  negate() {
    return this.negated || (this.negated = ZM.create(this)), this.negated;
  }
}
class ZM {
  static create(e) {
    return new ZM(e);
  }
  constructor(e) {
    this._actual = e, this.type = 8;
  }
  cmp(e) {
    return e.type !== this.type ? this.type - e.type : this._actual.cmp(e._actual);
  }
  equals(e) {
    return e.type === this.type ? this._actual.equals(e._actual) : !1;
  }
  substituteConstants() {
    return this;
  }
  evaluate(e) {
    return !this._actual.evaluate(e);
  }
  serialize() {
    return `!(${this._actual.serialize()})`;
  }
  keys() {
    return this._actual.keys();
  }
  negate() {
    return this._actual;
  }
}
function qH(s) {
  let e = null;
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t].substituteConstants();
    if (s[t] !== n && e === null) {
      e = [];
      for (let o = 0; o < t; o++)
        e[o] = s[o];
    }
    e !== null && (e[t] = n);
  }
  return e === null ? s : e;
}
class bh {
  static create(e, t, i) {
    return bh._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 6;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Tp(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = qH(this.expr);
    return e === this.expr ? this : bh.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (!this.expr[t].evaluate(e))
        return !1;
    return !0;
  }
  static _normalizeArr(e, t, i) {
    const n = [];
    let o = !1;
    for (const r of e)
      if (r) {
        if (r.type === 1) {
          o = !0;
          continue;
        }
        if (r.type === 0)
          return Pn.INSTANCE;
        if (r.type === 6) {
          n.push(...r.expr);
          continue;
        }
        n.push(r);
      }
    if (n.length === 0 && o)
      return ts.INSTANCE;
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      n.sort(Tp);
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      for (; n.length > 1; ) {
        const r = n[n.length - 1];
        if (r.type !== 9)
          break;
        n.pop();
        const a = n.pop(), l = n.length === 0, c = gl.create(r.expr.map((d) => bh.create([d, a], null, i)), null, l);
        c && (n.push(c), n.sort(Tp));
      }
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return Pn.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new bh(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" && ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      this.negated = gl.create(e, this, !0);
    }
    return this.negated;
  }
}
class gl {
  static create(e, t, i) {
    return gl._normalizeArr(e, t, i);
  }
  constructor(e, t) {
    this.expr = e, this.negated = t, this.type = 9;
  }
  cmp(e) {
    if (e.type !== this.type)
      return this.type - e.type;
    if (this.expr.length < e.expr.length)
      return -1;
    if (this.expr.length > e.expr.length)
      return 1;
    for (let t = 0, i = this.expr.length; t < i; t++) {
      const n = Tp(this.expr[t], e.expr[t]);
      if (n !== 0)
        return n;
    }
    return 0;
  }
  equals(e) {
    if (e.type === this.type) {
      if (this.expr.length !== e.expr.length)
        return !1;
      for (let t = 0, i = this.expr.length; t < i; t++)
        if (!this.expr[t].equals(e.expr[t]))
          return !1;
      return !0;
    }
    return !1;
  }
  substituteConstants() {
    const e = qH(this.expr);
    return e === this.expr ? this : gl.create(e, this.negated, !1);
  }
  evaluate(e) {
    for (let t = 0, i = this.expr.length; t < i; t++)
      if (this.expr[t].evaluate(e))
        return !0;
    return !1;
  }
  static _normalizeArr(e, t, i) {
    let n = [], o = !1;
    if (e) {
      for (let r = 0, a = e.length; r < a; r++) {
        const l = e[r];
        if (l) {
          if (l.type === 0) {
            o = !0;
            continue;
          }
          if (l.type === 1)
            return ts.INSTANCE;
          if (l.type === 9) {
            n = n.concat(l.expr);
            continue;
          }
          n.push(l);
        }
      }
      if (n.length === 0 && o)
        return Pn.INSTANCE;
      n.sort(Tp);
    }
    if (n.length !== 0) {
      if (n.length === 1)
        return n[0];
      for (let r = 1; r < n.length; r++)
        n[r - 1].equals(n[r]) && (n.splice(r, 1), r--);
      if (n.length === 1)
        return n[0];
      if (i) {
        for (let r = 0; r < n.length; r++)
          for (let a = r + 1; a < n.length; a++)
            if (n[r].negate().equals(n[a]))
              return ts.INSTANCE;
        if (n.length === 1)
          return n[0];
      }
      return new gl(n, t);
    }
  }
  serialize() {
    return this.expr.map((e) => e.serialize()).join(" || ");
  }
  keys() {
    const e = [];
    for (const t of this.expr)
      e.push(...t.keys());
    return e;
  }
  negate() {
    if (!this.negated) {
      const e = [];
      for (const t of this.expr)
        e.push(t.negate());
      for (; e.length > 1; ) {
        const t = e.shift(), i = e.shift(), n = [];
        for (const o of AR(t))
          for (const r of AR(i))
            n.push(bh.create([o, r], null, !1));
        e.unshift(gl.create(n, null, !1));
      }
      this.negated = gl.create(e, this, !0);
    }
    return this.negated;
  }
}
const Zg = class Zg extends Fu {
  static all() {
    return Zg._info.values();
  }
  constructor(e, t, i) {
    super(e, null), this._defaultValue = t, typeof i == "object" ? Zg._info.push({ ...i, key: e }) : i !== !0 && Zg._info.push({ key: e, description: i, type: t != null ? typeof t : void 0 });
  }
  bindTo(e) {
    return e.createKey(this.key, this._defaultValue);
  }
  getValue(e) {
    return e.getContextKeyValue(this.key);
  }
  toNegated() {
    return this.negate();
  }
  isEqualTo(e) {
    return M_.create(this.key, e);
  }
};
Zg._info = [];
let le = Zg;
const Se = We("contextKeyService");
function $H(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
function Pu(s, e, t, i) {
  return s < t ? -1 : s > t ? 1 : e < i ? -1 : e > i ? 1 : 0;
}
function KE(s, e) {
  if (s.type === 0 || e.type === 1)
    return !0;
  if (s.type === 9)
    return e.type === 9 ? pR(s.expr, e.expr) : !1;
  if (e.type === 9) {
    for (const t of e.expr)
      if (KE(s, t))
        return !0;
    return !1;
  }
  if (s.type === 6) {
    if (e.type === 6)
      return pR(e.expr, s.expr);
    for (const t of s.expr)
      if (KE(t, e))
        return !0;
    return !1;
  }
  return s.equals(e);
}
function pR(s, e) {
  let t = 0, i = 0;
  for (; t < s.length && i < e.length; ) {
    const n = s[t].cmp(e[i]);
    if (n < 0)
      return !1;
    n === 0 && t++, i++;
  }
  return t === s.length;
}
function AR(s) {
  return s.type === 9 ? s.expr : [s];
}
function ly(s, e) {
  if (!s)
    throw new Error(e ? `Assertion failed (${e})` : "Assertion Failed");
}
function eN(s, e = "Unreachable") {
  throw new Error(e);
}
function _R(s) {
  s || Pe(new lt("Soft Assertion Failed"));
}
function _u(s) {
  if (!s()) {
    debugger;
    s(), Pe(new lt("Assertion Failed"));
  }
}
function tN(s, e) {
  let t = 0;
  for (; t < s.length - 1; ) {
    const i = s[t], n = s[t + 1];
    if (!e(i, n))
      return !1;
    t++;
  }
  return !0;
}
class EU {
  constructor() {
    this.data = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    ly(_s(e)), ly(Ti(t)), ly(!this.data.has(e), "There is already an extension with this id"), this.data.set(e, t);
  }
  as(e) {
    return this.data.get(e) || null;
  }
}
const ji = new EU();
class iN {
  constructor() {
    this._coreKeybindings = new Nn(), this._extensionKeybindings = [], this._cachedMergedKeybindings = null;
  }
  /**
   * Take current platform into account and reduce to primary & secondary.
   */
  static bindToCurrentPlatform(e) {
    if (Us === 1) {
      if (e && e.win)
        return e.win;
    } else if (Us === 2) {
      if (e && e.mac)
        return e.mac;
    } else if (e && e.linux)
      return e.linux;
    return e;
  }
  registerKeybindingRule(e) {
    const t = iN.bindToCurrentPlatform(e), i = new X();
    if (t && t.primary) {
      const n = BE(t.primary, Us);
      n && i.add(this._registerDefaultKeybinding(n, e.id, e.args, e.weight, 0, e.when));
    }
    if (t && Array.isArray(t.secondary))
      for (let n = 0, o = t.secondary.length; n < o; n++) {
        const r = t.secondary[n], a = BE(r, Us);
        a && i.add(this._registerDefaultKeybinding(a, e.id, e.args, e.weight, -n - 1, e.when));
      }
    return i;
  }
  registerCommandAndKeybindingRule(e) {
    return jo(this.registerKeybindingRule(e), mt.registerCommand(e));
  }
  _registerDefaultKeybinding(e, t, i, n, o, r) {
    const a = this._coreKeybindings.push({
      keybinding: e,
      command: t,
      commandArgs: i,
      when: r,
      weight1: n,
      weight2: o,
      extensionId: null,
      isBuiltinExtension: !1
    });
    return this._cachedMergedKeybindings = null, we(() => {
      a(), this._cachedMergedKeybindings = null;
    });
  }
  getDefaultKeybindings() {
    return this._cachedMergedKeybindings || (this._cachedMergedKeybindings = Array.from(this._coreKeybindings).concat(this._extensionKeybindings), this._cachedMergedKeybindings.sort(kU)), this._cachedMergedKeybindings.slice(0);
  }
}
const Hn = new iN(), LU = {
  EditorModes: "platform.keybindingsRegistry"
};
ji.add(LU.EditorModes, Hn);
function kU(s, e) {
  if (s.weight1 !== e.weight1)
    return s.weight1 - e.weight1;
  if (s.command && e.command) {
    if (s.command < e.command)
      return -1;
    if (s.command > e.command)
      return 1;
  }
  return s.weight2 - e.weight2;
}
var DU = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, bR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, pw;
function ff(s) {
  return s.command !== void 0;
}
function IU(s) {
  return s.submenu !== void 0;
}
const k = class k {
  /**
   * Create a new `MenuId` with the unique identifier. Will throw if a menu
   * with the identifier already exists, use `MenuId.for(ident)` or a unique
   * identifier
   */
  constructor(e) {
    if (k._instances.has(e))
      throw new TypeError(`MenuId with identifier '${e}' already exists. Use MenuId.for(ident) or a unique identifier`);
    k._instances.set(e, this), this.id = e;
  }
};
k._instances = /* @__PURE__ */ new Map(), k.CommandPalette = new k("CommandPalette"), k.DebugBreakpointsContext = new k("DebugBreakpointsContext"), k.DebugCallStackContext = new k("DebugCallStackContext"), k.DebugConsoleContext = new k("DebugConsoleContext"), k.DebugVariablesContext = new k("DebugVariablesContext"), k.NotebookVariablesContext = new k("NotebookVariablesContext"), k.DebugHoverContext = new k("DebugHoverContext"), k.DebugWatchContext = new k("DebugWatchContext"), k.DebugToolBar = new k("DebugToolBar"), k.DebugToolBarStop = new k("DebugToolBarStop"), k.DebugCallStackToolbar = new k("DebugCallStackToolbar"), k.DebugCreateConfiguration = new k("DebugCreateConfiguration"), k.EditorContext = new k("EditorContext"), k.SimpleEditorContext = new k("SimpleEditorContext"), k.EditorContent = new k("EditorContent"), k.EditorLineNumberContext = new k("EditorLineNumberContext"), k.EditorContextCopy = new k("EditorContextCopy"), k.EditorContextPeek = new k("EditorContextPeek"), k.EditorContextShare = new k("EditorContextShare"), k.EditorTitle = new k("EditorTitle"), k.EditorTitleRun = new k("EditorTitleRun"), k.EditorTitleContext = new k("EditorTitleContext"), k.EditorTitleContextShare = new k("EditorTitleContextShare"), k.EmptyEditorGroup = new k("EmptyEditorGroup"), k.EmptyEditorGroupContext = new k("EmptyEditorGroupContext"), k.EditorTabsBarContext = new k("EditorTabsBarContext"), k.EditorTabsBarShowTabsSubmenu = new k("EditorTabsBarShowTabsSubmenu"), k.EditorTabsBarShowTabsZenModeSubmenu = new k("EditorTabsBarShowTabsZenModeSubmenu"), k.EditorActionsPositionSubmenu = new k("EditorActionsPositionSubmenu"), k.ExplorerContext = new k("ExplorerContext"), k.ExplorerContextShare = new k("ExplorerContextShare"), k.ExtensionContext = new k("ExtensionContext"), k.GlobalActivity = new k("GlobalActivity"), k.CommandCenter = new k("CommandCenter"), k.CommandCenterCenter = new k("CommandCenterCenter"), k.LayoutControlMenuSubmenu = new k("LayoutControlMenuSubmenu"), k.LayoutControlMenu = new k("LayoutControlMenu"), k.MenubarMainMenu = new k("MenubarMainMenu"), k.MenubarAppearanceMenu = new k("MenubarAppearanceMenu"), k.MenubarDebugMenu = new k("MenubarDebugMenu"), k.MenubarEditMenu = new k("MenubarEditMenu"), k.MenubarCopy = new k("MenubarCopy"), k.MenubarFileMenu = new k("MenubarFileMenu"), k.MenubarGoMenu = new k("MenubarGoMenu"), k.MenubarHelpMenu = new k("MenubarHelpMenu"), k.MenubarLayoutMenu = new k("MenubarLayoutMenu"), k.MenubarNewBreakpointMenu = new k("MenubarNewBreakpointMenu"), k.PanelAlignmentMenu = new k("PanelAlignmentMenu"), k.PanelPositionMenu = new k("PanelPositionMenu"), k.ActivityBarPositionMenu = new k("ActivityBarPositionMenu"), k.MenubarPreferencesMenu = new k("MenubarPreferencesMenu"), k.MenubarRecentMenu = new k("MenubarRecentMenu"), k.MenubarSelectionMenu = new k("MenubarSelectionMenu"), k.MenubarShare = new k("MenubarShare"), k.MenubarSwitchEditorMenu = new k("MenubarSwitchEditorMenu"), k.MenubarSwitchGroupMenu = new k("MenubarSwitchGroupMenu"), k.MenubarTerminalMenu = new k("MenubarTerminalMenu"), k.MenubarViewMenu = new k("MenubarViewMenu"), k.MenubarHomeMenu = new k("MenubarHomeMenu"), k.OpenEditorsContext = new k("OpenEditorsContext"), k.OpenEditorsContextShare = new k("OpenEditorsContextShare"), k.ProblemsPanelContext = new k("ProblemsPanelContext"), k.SCMInputBox = new k("SCMInputBox"), k.SCMChangesSeparator = new k("SCMChangesSeparator"), k.SCMChangesContext = new k("SCMChangesContext"), k.SCMIncomingChanges = new k("SCMIncomingChanges"), k.SCMIncomingChangesContext = new k("SCMIncomingChangesContext"), k.SCMIncomingChangesSetting = new k("SCMIncomingChangesSetting"), k.SCMOutgoingChanges = new k("SCMOutgoingChanges"), k.SCMOutgoingChangesContext = new k("SCMOutgoingChangesContext"), k.SCMOutgoingChangesSetting = new k("SCMOutgoingChangesSetting"), k.SCMIncomingChangesAllChangesContext = new k("SCMIncomingChangesAllChangesContext"), k.SCMIncomingChangesHistoryItemContext = new k("SCMIncomingChangesHistoryItemContext"), k.SCMOutgoingChangesAllChangesContext = new k("SCMOutgoingChangesAllChangesContext"), k.SCMOutgoingChangesHistoryItemContext = new k("SCMOutgoingChangesHistoryItemContext"), k.SCMChangeContext = new k("SCMChangeContext"), k.SCMResourceContext = new k("SCMResourceContext"), k.SCMResourceContextShare = new k("SCMResourceContextShare"), k.SCMResourceFolderContext = new k("SCMResourceFolderContext"), k.SCMResourceGroupContext = new k("SCMResourceGroupContext"), k.SCMSourceControl = new k("SCMSourceControl"), k.SCMSourceControlInline = new k("SCMSourceControlInline"), k.SCMSourceControlTitle = new k("SCMSourceControlTitle"), k.SCMHistoryTitle = new k("SCMHistoryTitle"), k.SCMTitle = new k("SCMTitle"), k.SearchContext = new k("SearchContext"), k.SearchActionMenu = new k("SearchActionContext"), k.StatusBarWindowIndicatorMenu = new k("StatusBarWindowIndicatorMenu"), k.StatusBarRemoteIndicatorMenu = new k("StatusBarRemoteIndicatorMenu"), k.StickyScrollContext = new k("StickyScrollContext"), k.TestItem = new k("TestItem"), k.TestItemGutter = new k("TestItemGutter"), k.TestProfilesContext = new k("TestProfilesContext"), k.TestMessageContext = new k("TestMessageContext"), k.TestMessageContent = new k("TestMessageContent"), k.TestPeekElement = new k("TestPeekElement"), k.TestPeekTitle = new k("TestPeekTitle"), k.TestCallStack = new k("TestCallStack"), k.TouchBarContext = new k("TouchBarContext"), k.TitleBarContext = new k("TitleBarContext"), k.TitleBarTitleContext = new k("TitleBarTitleContext"), k.TunnelContext = new k("TunnelContext"), k.TunnelPrivacy = new k("TunnelPrivacy"), k.TunnelProtocol = new k("TunnelProtocol"), k.TunnelPortInline = new k("TunnelInline"), k.TunnelTitle = new k("TunnelTitle"), k.TunnelLocalAddressInline = new k("TunnelLocalAddressInline"), k.TunnelOriginInline = new k("TunnelOriginInline"), k.ViewItemContext = new k("ViewItemContext"), k.ViewContainerTitle = new k("ViewContainerTitle"), k.ViewContainerTitleContext = new k("ViewContainerTitleContext"), k.ViewTitle = new k("ViewTitle"), k.ViewTitleContext = new k("ViewTitleContext"), k.CommentEditorActions = new k("CommentEditorActions"), k.CommentThreadTitle = new k("CommentThreadTitle"), k.CommentThreadActions = new k("CommentThreadActions"), k.CommentThreadAdditionalActions = new k("CommentThreadAdditionalActions"), k.CommentThreadTitleContext = new k("CommentThreadTitleContext"), k.CommentThreadCommentContext = new k("CommentThreadCommentContext"), k.CommentTitle = new k("CommentTitle"), k.CommentActions = new k("CommentActions"), k.CommentsViewThreadActions = new k("CommentsViewThreadActions"), k.InteractiveToolbar = new k("InteractiveToolbar"), k.InteractiveCellTitle = new k("InteractiveCellTitle"), k.InteractiveCellDelete = new k("InteractiveCellDelete"), k.InteractiveCellExecute = new k("InteractiveCellExecute"), k.InteractiveInputExecute = new k("InteractiveInputExecute"), k.InteractiveInputConfig = new k("InteractiveInputConfig"), k.ReplInputExecute = new k("ReplInputExecute"), k.IssueReporter = new k("IssueReporter"), k.NotebookToolbar = new k("NotebookToolbar"), k.NotebookStickyScrollContext = new k("NotebookStickyScrollContext"), k.NotebookCellTitle = new k("NotebookCellTitle"), k.NotebookCellDelete = new k("NotebookCellDelete"), k.NotebookCellInsert = new k("NotebookCellInsert"), k.NotebookCellBetween = new k("NotebookCellBetween"), k.NotebookCellListTop = new k("NotebookCellTop"), k.NotebookCellExecute = new k("NotebookCellExecute"), k.NotebookCellExecuteGoTo = new k("NotebookCellExecuteGoTo"), k.NotebookCellExecutePrimary = new k("NotebookCellExecutePrimary"), k.NotebookDiffCellInputTitle = new k("NotebookDiffCellInputTitle"), k.NotebookDiffCellMetadataTitle = new k("NotebookDiffCellMetadataTitle"), k.NotebookDiffCellOutputsTitle = new k("NotebookDiffCellOutputsTitle"), k.NotebookOutputToolbar = new k("NotebookOutputToolbar"), k.NotebookOutlineFilter = new k("NotebookOutlineFilter"), k.NotebookOutlineActionMenu = new k("NotebookOutlineActionMenu"), k.NotebookEditorLayoutConfigure = new k("NotebookEditorLayoutConfigure"), k.NotebookKernelSource = new k("NotebookKernelSource"), k.BulkEditTitle = new k("BulkEditTitle"), k.BulkEditContext = new k("BulkEditContext"), k.TimelineItemContext = new k("TimelineItemContext"), k.TimelineTitle = new k("TimelineTitle"), k.TimelineTitleContext = new k("TimelineTitleContext"), k.TimelineFilterSubMenu = new k("TimelineFilterSubMenu"), k.AccountsContext = new k("AccountsContext"), k.SidebarTitle = new k("SidebarTitle"), k.PanelTitle = new k("PanelTitle"), k.AuxiliaryBarTitle = new k("AuxiliaryBarTitle"), k.AuxiliaryBarHeader = new k("AuxiliaryBarHeader"), k.TerminalInstanceContext = new k("TerminalInstanceContext"), k.TerminalEditorInstanceContext = new k("TerminalEditorInstanceContext"), k.TerminalNewDropdownContext = new k("TerminalNewDropdownContext"), k.TerminalTabContext = new k("TerminalTabContext"), k.TerminalTabEmptyAreaContext = new k("TerminalTabEmptyAreaContext"), k.TerminalStickyScrollContext = new k("TerminalStickyScrollContext"), k.WebviewContext = new k("WebviewContext"), k.InlineCompletionsActions = new k("InlineCompletionsActions"), k.InlineEditsActions = new k("InlineEditsActions"), k.InlineEditActions = new k("InlineEditActions"), k.NewFile = new k("NewFile"), k.MergeInput1Toolbar = new k("MergeToolbar1Toolbar"), k.MergeInput2Toolbar = new k("MergeToolbar2Toolbar"), k.MergeBaseToolbar = new k("MergeBaseToolbar"), k.MergeInputResultToolbar = new k("MergeToolbarResultToolbar"), k.InlineSuggestionToolbar = new k("InlineSuggestionToolbar"), k.InlineEditToolbar = new k("InlineEditToolbar"), k.ChatContext = new k("ChatContext"), k.ChatCodeBlock = new k("ChatCodeblock"), k.ChatCompareBlock = new k("ChatCompareBlock"), k.ChatMessageTitle = new k("ChatMessageTitle"), k.ChatExecute = new k("ChatExecute"), k.ChatExecuteSecondary = new k("ChatExecuteSecondary"), k.ChatInputSide = new k("ChatInputSide"), k.AccessibleView = new k("AccessibleView"), k.MultiDiffEditorFileToolbar = new k("MultiDiffEditorFileToolbar"), k.DiffEditorHunkToolbar = new k("DiffEditorHunkToolbar"), k.DiffEditorSelectionToolbar = new k("DiffEditorSelectionToolbar");
let Qe = k;
const sr = We("menuService"), cA = class cA {
  static for(e) {
    let t = this._all.get(e);
    return t || (t = new cA(e), this._all.set(e, t)), t;
  }
  static merge(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      i instanceof cA && t.add(i.id);
    return t;
  }
  constructor(e) {
    this.id = e, this.has = (t) => t === e;
  }
};
cA._all = /* @__PURE__ */ new Map();
let qd = cA;
const mo = new class {
  constructor() {
    this._commands = /* @__PURE__ */ new Map(), this._menuItems = /* @__PURE__ */ new Map(), this._onDidChangeMenu = new Yz({
      merge: qd.merge
    }), this.onDidChangeMenu = this._onDidChangeMenu.event;
  }
  addCommand(s) {
    return this._commands.set(s.id, s), this._onDidChangeMenu.fire(qd.for(Qe.CommandPalette)), we(() => {
      this._commands.delete(s.id) && this._onDidChangeMenu.fire(qd.for(Qe.CommandPalette));
    });
  }
  getCommand(s) {
    return this._commands.get(s);
  }
  getCommands() {
    const s = /* @__PURE__ */ new Map();
    return this._commands.forEach((e, t) => s.set(t, e)), s;
  }
  appendMenuItem(s, e) {
    let t = this._menuItems.get(s);
    t || (t = new Nn(), this._menuItems.set(s, t));
    const i = t.push(e);
    return this._onDidChangeMenu.fire(qd.for(s)), we(() => {
      i(), this._onDidChangeMenu.fire(qd.for(s));
    });
  }
  appendMenuItems(s) {
    const e = new X();
    for (const { id: t, item: i } of s)
      e.add(this.appendMenuItem(t, i));
    return e;
  }
  getMenuItems(s) {
    let e;
    return this._menuItems.has(s) ? e = [...this._menuItems.get(s)] : e = [], s === Qe.CommandPalette && this._appendImplicitItems(e), e;
  }
  _appendImplicitItems(s) {
    const e = /* @__PURE__ */ new Set();
    for (const t of s)
      ff(t) && (e.add(t.command.id), t.alt && e.add(t.alt.id));
    this._commands.forEach((t, i) => {
      e.has(i) || s.push({ command: t });
    });
  }
}();
class mf extends Uf {
  constructor(e, t, i) {
    super(`submenuitem.${e.submenu.id}`, typeof e.title == "string" ? e.title : e.title.value, i, "submenu"), this.item = e, this.hideActions = t;
  }
}
let bo = pw = class {
  static label(e, t) {
    return t?.renderShortTitle && e.shortTitle ? typeof e.shortTitle == "string" ? e.shortTitle : e.shortTitle.value : typeof e.title == "string" ? e.title : e.title.value;
  }
  constructor(e, t, i, n, o, r, a) {
    this.hideActions = n, this.menuKeybinding = o, this._commandService = a, this.id = e.id, this.label = pw.label(e, i), this.tooltip = (typeof e.tooltip == "string" ? e.tooltip : e.tooltip?.value) ?? "", this.enabled = !e.precondition || r.contextMatchesRules(e.precondition), this.checked = void 0;
    let l;
    if (e.toggled) {
      const c = e.toggled.condition ? e.toggled : { condition: e.toggled };
      this.checked = r.contextMatchesRules(c.condition), this.checked && c.tooltip && (this.tooltip = typeof c.tooltip == "string" ? c.tooltip : c.tooltip.value), this.checked && pe.isThemeIcon(c.icon) && (l = c.icon), this.checked && c.title && (this.label = typeof c.title == "string" ? c.title : c.title.value);
    }
    l || (l = pe.isThemeIcon(e.icon) ? e.icon : void 0), this.item = e, this.alt = t ? new pw(t, void 0, i, n, void 0, r, a) : void 0, this._options = i, this.class = l && pe.asClassName(l);
  }
  run(...e) {
    let t = [];
    return this._options?.arg && (t = [...t, this._options.arg]), this._options?.shouldForwardArgs && (t = [...t, ...e]), this._commandService.executeCommand(this.id, ...t);
  }
};
bo = pw = DU([
  bR(5, Se),
  bR(6, bi)
], bo);
class bm {
  constructor(e) {
    this.desc = e;
  }
}
function os(s) {
  const e = [], t = new s(), { f1: i, menu: n, keybinding: o, ...r } = t.desc;
  if (mt.getCommand(r.id))
    throw new Error(`Cannot register two commands with the same id: ${r.id}`);
  if (e.push(mt.registerCommand({
    id: r.id,
    handler: (a, ...l) => t.run(a, ...l),
    metadata: r.metadata
  })), Array.isArray(n))
    for (const a of n)
      e.push(mo.appendMenuItem(a.id, { command: { ...r, precondition: a.precondition === null ? void 0 : r.precondition }, ...a }));
  else n && e.push(mo.appendMenuItem(n.id, { command: { ...r, precondition: n.precondition === null ? void 0 : r.precondition }, ...n }));
  if (i && (e.push(mo.appendMenuItem(Qe.CommandPalette, { command: r, when: r.precondition })), e.push(mo.addCommand(r))), Array.isArray(o))
    for (const a of o)
      e.push(Hn.registerKeybindingRule({
        ...a,
        id: r.id,
        when: r.precondition ? ne.and(r.precondition, a.when) : a.when
      }));
  else o && e.push(Hn.registerKeybindingRule({
    ...o,
    id: r.id,
    when: r.precondition ? ne.and(r.precondition, o.when) : o.when
  }));
  return {
    dispose() {
      Ct(e);
    }
  };
}
const eo = We("telemetryService"), Es = We("logService");
var Kn;
(function(s) {
  s[s.Off = 0] = "Off", s[s.Trace = 1] = "Trace", s[s.Debug = 2] = "Debug", s[s.Info = 3] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 5] = "Error";
})(Kn || (Kn = {}));
const XH = Kn.Info;
class ZH extends V {
  constructor() {
    super(...arguments), this.level = XH, this._onDidChangeLogLevel = this._register(new B()), this.onDidChangeLogLevel = this._onDidChangeLogLevel.event;
  }
  setLevel(e) {
    this.level !== e && (this.level = e, this._onDidChangeLogLevel.fire(this.level));
  }
  getLevel() {
    return this.level;
  }
  checkLogLevel(e) {
    return this.level !== Kn.Off && this.level <= e;
  }
}
class MU extends ZH {
  constructor(e = XH, t = !0) {
    super(), this.useColors = t, this.setLevel(e);
  }
  trace(e, ...t) {
    this.checkLogLevel(Kn.Trace) && (this.useColors ? console.log("%cTRACE", "color: #888", e, ...t) : console.log(e, ...t));
  }
  debug(e, ...t) {
    this.checkLogLevel(Kn.Debug) && (this.useColors ? console.log("%cDEBUG", "background: #eee; color: #888", e, ...t) : console.log(e, ...t));
  }
  info(e, ...t) {
    this.checkLogLevel(Kn.Info) && (this.useColors ? console.log("%c INFO", "color: #33f", e, ...t) : console.log(e, ...t));
  }
  warn(e, ...t) {
    this.checkLogLevel(Kn.Warning) && (this.useColors ? console.log("%c WARN", "color: #993", e, ...t) : console.log(e, ...t));
  }
  error(e, ...t) {
    this.checkLogLevel(Kn.Error) && (this.useColors ? console.log("%c  ERR", "color: #f33", e, ...t) : console.error(e, ...t));
  }
}
class NU extends ZH {
  constructor(e) {
    super(), this.loggers = e, e.length && this.setLevel(e[0].getLevel());
  }
  setLevel(e) {
    for (const t of this.loggers)
      t.setLevel(e);
    super.setLevel(e);
  }
  trace(e, ...t) {
    for (const i of this.loggers)
      i.trace(e, ...t);
  }
  debug(e, ...t) {
    for (const i of this.loggers)
      i.debug(e, ...t);
  }
  info(e, ...t) {
    for (const i of this.loggers)
      i.info(e, ...t);
  }
  warn(e, ...t) {
    for (const i of this.loggers)
      i.warn(e, ...t);
  }
  error(e, ...t) {
    for (const i of this.loggers)
      i.error(e, ...t);
  }
  dispose() {
    for (const e of this.loggers)
      e.dispose();
    super.dispose();
  }
}
function TU(s) {
  switch (s) {
    case Kn.Trace:
      return "trace";
    case Kn.Debug:
      return "debug";
    case Kn.Info:
      return "info";
    case Kn.Warning:
      return "warn";
    case Kn.Error:
      return "error";
    case Kn.Off:
      return "off";
  }
}
new le("logLevel", TU(Kn.Info));
class B0 {
  constructor(e) {
    this.id = e.id, this.precondition = e.precondition, this._kbOpts = e.kbOpts, this._menuOpts = e.menuOpts, this.metadata = e.metadata;
  }
  register() {
    if (Array.isArray(this._menuOpts) ? this._menuOpts.forEach(this._registerMenuItem, this) : this._menuOpts && this._registerMenuItem(this._menuOpts), this._kbOpts) {
      const e = Array.isArray(this._kbOpts) ? this._kbOpts : [this._kbOpts];
      for (const t of e) {
        let i = t.kbExpr;
        this.precondition && (i ? i = ne.and(i, this.precondition) : i = this.precondition);
        const n = {
          id: this.id,
          weight: t.weight,
          args: t.args,
          when: i,
          primary: t.primary,
          secondary: t.secondary,
          win: t.win,
          linux: t.linux,
          mac: t.mac
        };
        Hn.registerKeybindingRule(n);
      }
    }
    mt.registerCommand({
      id: this.id,
      handler: (e, t) => this.runCommand(e, t),
      metadata: this.metadata
    });
  }
  _registerMenuItem(e) {
    mo.appendMenuItem(e.menuId, {
      group: e.group,
      command: {
        id: this.id,
        title: e.title,
        icon: e.icon,
        precondition: this.precondition
      },
      when: e.when,
      order: e.order
    });
  }
}
class nN extends B0 {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t, i, n) {
    return this._implementations.push({ priority: e, name: t, implementation: i, when: n }), this._implementations.sort((o, r) => r.priority - o.priority), {
      dispose: () => {
        for (let o = 0; o < this._implementations.length; o++)
          if (this._implementations[o].implementation === i) {
            this._implementations.splice(o, 1);
            return;
          }
      }
    };
  }
  runCommand(e, t) {
    const i = e.get(Es), n = e.get(Se);
    i.trace(`Executing Command '${this.id}' which has ${this._implementations.length} bound.`);
    for (const o of this._implementations) {
      if (o.when) {
        const a = n.getContext(ln());
        if (!o.when.evaluate(a))
          continue;
      }
      const r = o.implementation(e, t);
      if (r)
        return i.trace(`Command '${this.id}' was handled by '${o.name}'.`), typeof r == "boolean" ? void 0 : r;
    }
    i.trace(`The Command '${this.id}' was not handled by any implementation.`);
  }
}
class e5 extends B0 {
  constructor(e, t) {
    super(t), this.command = e;
  }
  runCommand(e, t) {
    return this.command.runCommand(e, t);
  }
}
class Wn extends B0 {
  /**
   * Create a command class that is bound to a certain editor contribution.
   */
  static bindToContribution(e) {
    return class extends Wn {
      constructor(i) {
        super(i), this._callback = i.handler;
      }
      runEditorCommand(i, n, o) {
        const r = e(n);
        r && this._callback(r, o);
      }
    };
  }
  static runEditorCommand(e, t, i, n) {
    const o = e.get(Nt), r = o.getFocusedCodeEditor() || o.getActiveCodeEditor();
    if (r)
      return r.invokeWithinContext((a) => {
        if (a.get(Se).contextMatchesRules(i ?? void 0))
          return n(a, r, t);
      });
  }
  runCommand(e, t) {
    return Wn.runEditorCommand(e, t, this.precondition, (i, n, o) => this.runEditorCommand(i, n, o));
  }
}
class Vt extends Wn {
  static convertOptions(e) {
    let t;
    Array.isArray(e.menuOpts) ? t = e.menuOpts : e.menuOpts ? t = [e.menuOpts] : t = [];
    function i(n) {
      return n.menuId || (n.menuId = Qe.EditorContext), n.title || (n.title = e.label), n.when = ne.and(e.precondition, n.when), n;
    }
    return Array.isArray(e.contextMenuOpts) ? t.push(...e.contextMenuOpts.map(i)) : e.contextMenuOpts && t.push(i(e.contextMenuOpts)), e.menuOpts = t, e;
  }
  constructor(e) {
    super(Vt.convertOptions(e)), this.label = e.label, this.alias = e.alias;
  }
  runEditorCommand(e, t, i) {
    return this.reportTelemetry(e, t), this.run(e, t, i || {});
  }
  reportTelemetry(e, t) {
    e.get(eo).publicLog2("editorActionInvoked", { name: this.label, id: this.id });
  }
}
class t5 extends Vt {
  constructor() {
    super(...arguments), this._implementations = [];
  }
  /**
   * A higher priority gets to be looked at first
   */
  addImplementation(e, t) {
    return this._implementations.push([e, t]), this._implementations.sort((i, n) => n[0] - i[0]), {
      dispose: () => {
        for (let i = 0; i < this._implementations.length; i++)
          if (this._implementations[i][1] === t) {
            this._implementations.splice(i, 1);
            return;
          }
      }
    };
  }
  run(e, t, i) {
    for (const n of this._implementations) {
      const o = n[1](e, t, i);
      if (o)
        return typeof o == "boolean" ? void 0 : o;
    }
  }
}
class BU extends bm {
  run(e, ...t) {
    const i = e.get(Nt), n = i.getFocusedCodeEditor() || i.getActiveCodeEditor();
    if (n)
      return n.invokeWithinContext((o) => {
        const r = o.get(Se), a = o.get(Es);
        if (!r.contextMatchesRules(this.desc.precondition ?? void 0)) {
          a.debug("[EditorAction2] NOT running command because its precondition is FALSE", this.desc.id, this.desc.precondition?.serialize());
          return;
        }
        return this.runEditorCommand(o, n, ...t);
      });
  }
}
function or(s, e) {
  mt.registerCommand(s, function(t, ...i) {
    const n = t.get(ke), [o, r] = i;
    jt(_e.isUri(o)), jt(F.isIPosition(r));
    const a = t.get(Fi).getModel(o);
    if (a) {
      const l = F.lift(r);
      return n.invokeFunction(e, a, l, ...i.slice(2));
    }
    return t.get(Zs).createModelReference(o).then((l) => new Promise((c, d) => {
      try {
        const h = n.invokeFunction(e, l.object.textEditorModel, F.lift(r), i.slice(2));
        c(h);
      } catch (h) {
        d(h);
      }
    }).finally(() => {
      l.dispose();
    }));
  });
}
function re(s) {
  return uo.INSTANCE.registerEditorCommand(s), s;
}
function Ge(s) {
  const e = new s();
  return uo.INSTANCE.registerEditorAction(e), e;
}
function i5(s) {
  return uo.INSTANCE.registerEditorAction(s), s;
}
function RU(s) {
  uo.INSTANCE.registerEditorAction(s);
}
function rs(s, e, t) {
  uo.INSTANCE.registerEditorContribution(s, e, t);
}
var pf;
(function(s) {
  function e(r) {
    return uo.INSTANCE.getEditorCommand(r);
  }
  s.getEditorCommand = e;
  function t() {
    return uo.INSTANCE.getEditorActions();
  }
  s.getEditorActions = t;
  function i() {
    return uo.INSTANCE.getEditorContributions();
  }
  s.getEditorContributions = i;
  function n(r) {
    return uo.INSTANCE.getEditorContributions().filter((a) => r.indexOf(a.id) >= 0);
  }
  s.getSomeEditorContributions = n;
  function o() {
    return uo.INSTANCE.getDiffEditorContributions();
  }
  s.getDiffEditorContributions = o;
})(pf || (pf = {}));
const FU = {
  EditorCommonContributions: "editor.contributions"
}, _1 = class _1 {
  constructor() {
    this.editorContributions = [], this.diffEditorContributions = [], this.editorActions = [], this.editorCommands = /* @__PURE__ */ Object.create(null);
  }
  registerEditorContribution(e, t, i) {
    this.editorContributions.push({ id: e, ctor: t, instantiation: i });
  }
  getEditorContributions() {
    return this.editorContributions.slice(0);
  }
  getDiffEditorContributions() {
    return this.diffEditorContributions.slice(0);
  }
  registerEditorAction(e) {
    e.register(), this.editorActions.push(e);
  }
  getEditorActions() {
    return this.editorActions;
  }
  registerEditorCommand(e) {
    e.register(), this.editorCommands[e.id] = e;
  }
  getEditorCommand(e) {
    return this.editorCommands[e] || null;
  }
};
_1.INSTANCE = new _1();
let uo = _1;
ji.add(FU.EditorCommonContributions, uo.INSTANCE);
function N_(s) {
  return s.register(), s;
}
const n5 = N_(new nN({
  id: "undo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2104
    /* KeyCode.KeyZ */
  },
  menuOpts: [{
    menuId: Qe.MenubarEditMenu,
    group: "1_do",
    title: f({ key: "miUndo", comment: ["&& denotes a mnemonic"] }, "&&Undo"),
    order: 1
  }, {
    menuId: Qe.CommandPalette,
    group: "",
    title: f("undo", "Undo"),
    order: 1
  }]
}));
N_(new e5(n5, { id: "default:undo", precondition: void 0 }));
const s5 = N_(new nN({
  id: "redo",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    primary: 2103,
    secondary: [
      3128
      /* KeyCode.KeyZ */
    ],
    mac: {
      primary: 3128
      /* KeyCode.KeyZ */
    }
  },
  menuOpts: [{
    menuId: Qe.MenubarEditMenu,
    group: "1_do",
    title: f({ key: "miRedo", comment: ["&& denotes a mnemonic"] }, "&&Redo"),
    order: 2
  }, {
    menuId: Qe.CommandPalette,
    group: "",
    title: f("redo", "Redo"),
    order: 1
  }]
}));
N_(new e5(s5, { id: "default:redo", precondition: void 0 }));
const OU = N_(new nN({
  id: "editor.action.selectAll",
  precondition: void 0,
  kbOpts: {
    weight: 0,
    kbExpr: null,
    primary: 2079
    /* KeyCode.KeyA */
  },
  menuOpts: [{
    menuId: Qe.MenubarSelectionMenu,
    group: "1_basic",
    title: f({ key: "miSelectAll", comment: ["&& denotes a mnemonic"] }, "&&Select All"),
    order: 1
  }, {
    menuId: Qe.CommandPalette,
    group: "",
    title: f("selectAll", "Select All"),
    order: 1
  }]
})), wR = "default", PU = "$initialize";
let CR = !1;
function JE(s) {
  pm && (CR || (CR = !0, console.warn("Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/microsoft/monaco-editor#faq")), console.warn(s.message));
}
class HU {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.method = n, this.args = o, this.type = 0;
  }
}
class vR {
  constructor(e, t, i, n) {
    this.vsWorker = e, this.seq = t, this.res = i, this.err = n, this.type = 1;
  }
}
class WU {
  constructor(e, t, i, n, o) {
    this.vsWorker = e, this.req = t, this.channel = i, this.eventName = n, this.arg = o, this.type = 2;
  }
}
class VU {
  constructor(e, t, i) {
    this.vsWorker = e, this.req = t, this.event = i, this.type = 3;
  }
}
class zU {
  constructor(e, t) {
    this.vsWorker = e, this.req = t, this.type = 4;
  }
}
class UU {
  constructor(e) {
    this._workerId = -1, this._handler = e, this._lastSentReq = 0, this._pendingReplies = /* @__PURE__ */ Object.create(null), this._pendingEmitters = /* @__PURE__ */ new Map(), this._pendingEvents = /* @__PURE__ */ new Map();
  }
  setWorkerId(e) {
    this._workerId = e;
  }
  sendMessage(e, t, i) {
    const n = String(++this._lastSentReq);
    return new Promise((o, r) => {
      this._pendingReplies[n] = {
        resolve: o,
        reject: r
      }, this._send(new HU(this._workerId, n, e, t, i));
    });
  }
  listen(e, t, i) {
    let n = null;
    const o = new B({
      onWillAddFirstListener: () => {
        n = String(++this._lastSentReq), this._pendingEmitters.set(n, o), this._send(new WU(this._workerId, n, e, t, i));
      },
      onDidRemoveLastListener: () => {
        this._pendingEmitters.delete(n), this._send(new zU(this._workerId, n)), n = null;
      }
    });
    return o.event;
  }
  handleMessage(e) {
    !e || !e.vsWorker || this._workerId !== -1 && e.vsWorker !== this._workerId || this._handleMessage(e);
  }
  createProxyToRemoteChannel(e, t) {
    const i = {
      get: (n, o) => (typeof o == "string" && !n[o] && (r5(o) ? n[o] = (r) => this.listen(e, o, r) : o5(o) ? n[o] = this.listen(e, o, void 0) : o.charCodeAt(0) === 36 && (n[o] = async (...r) => (await t?.(), this.sendMessage(e, o, r)))), n[o])
    };
    return new Proxy(/* @__PURE__ */ Object.create(null), i);
  }
  _handleMessage(e) {
    switch (e.type) {
      case 1:
        return this._handleReplyMessage(e);
      case 0:
        return this._handleRequestMessage(e);
      case 2:
        return this._handleSubscribeEventMessage(e);
      case 3:
        return this._handleEventMessage(e);
      case 4:
        return this._handleUnsubscribeEventMessage(e);
    }
  }
  _handleReplyMessage(e) {
    if (!this._pendingReplies[e.seq]) {
      console.warn("Got reply to unknown seq");
      return;
    }
    const t = this._pendingReplies[e.seq];
    if (delete this._pendingReplies[e.seq], e.err) {
      let i = e.err;
      e.err.$isError && (i = new Error(), i.name = e.err.name, i.message = e.err.message, i.stack = e.err.stack), t.reject(i);
      return;
    }
    t.resolve(e.res);
  }
  _handleRequestMessage(e) {
    const t = e.req;
    this._handler.handleMessage(e.channel, e.method, e.args).then((n) => {
      this._send(new vR(this._workerId, t, n, void 0));
    }, (n) => {
      n.detail instanceof Error && (n.detail = UB(n.detail)), this._send(new vR(this._workerId, t, void 0, UB(n)));
    });
  }
  _handleSubscribeEventMessage(e) {
    const t = e.req, i = this._handler.handleEvent(e.channel, e.eventName, e.arg)((n) => {
      this._send(new VU(this._workerId, t, n));
    });
    this._pendingEvents.set(t, i);
  }
  _handleEventMessage(e) {
    if (!this._pendingEmitters.has(e.req)) {
      console.warn("Got event for unknown req");
      return;
    }
    this._pendingEmitters.get(e.req).fire(e.event);
  }
  _handleUnsubscribeEventMessage(e) {
    if (!this._pendingEvents.has(e.req)) {
      console.warn("Got unsubscribe for unknown req");
      return;
    }
    this._pendingEvents.get(e.req).dispose(), this._pendingEvents.delete(e.req);
  }
  _send(e) {
    const t = [];
    if (e.type === 0)
      for (let i = 0; i < e.args.length; i++)
        e.args[i] instanceof ArrayBuffer && t.push(e.args[i]);
    else e.type === 1 && e.res instanceof ArrayBuffer && t.push(e.res);
    this._handler.sendMessage(e, t);
  }
}
class QU extends V {
  constructor(e, t) {
    super(), this._localChannels = /* @__PURE__ */ new Map(), this._worker = this._register(e.create({
      amdModuleId: "vs/base/common/worker/simpleWorker",
      esmModuleLocation: t.esmModuleLocation,
      label: t.label
    }, (o) => {
      this._protocol.handleMessage(o);
    }, (o) => {
      Pe(o);
    })), this._protocol = new UU({
      sendMessage: (o, r) => {
        this._worker.postMessage(o, r);
      },
      handleMessage: (o, r, a) => this._handleMessage(o, r, a),
      handleEvent: (o, r, a) => this._handleEvent(o, r, a)
    }), this._protocol.setWorkerId(this._worker.getId());
    let i = null;
    const n = globalThis.require;
    typeof n < "u" && typeof n.getConfig == "function" ? i = n.getConfig() : typeof globalThis.requirejs < "u" && (i = globalThis.requirejs.s.contexts._.config), this._onModuleLoaded = this._protocol.sendMessage(wR, PU, [
      this._worker.getId(),
      JSON.parse(JSON.stringify(i)),
      t.amdModuleId
    ]), this.proxy = this._protocol.createProxyToRemoteChannel(wR, async () => {
      await this._onModuleLoaded;
    }), this._onModuleLoaded.catch((o) => {
      this._onError("Worker failed to load " + t.amdModuleId, o);
    });
  }
  _handleMessage(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      return Promise.reject(new Error(`Missing channel ${e} on main thread`));
    if (typeof n[t] != "function")
      return Promise.reject(new Error(`Missing method ${t} on main thread channel ${e}`));
    try {
      return Promise.resolve(n[t].apply(n, i));
    } catch (o) {
      return Promise.reject(o);
    }
  }
  _handleEvent(e, t, i) {
    const n = this._localChannels.get(e);
    if (!n)
      throw new Error(`Missing channel ${e} on main thread`);
    if (r5(t)) {
      const o = n[t].call(n, i);
      if (typeof o != "function")
        throw new Error(`Missing dynamic event ${t} on main thread channel ${e}.`);
      return o;
    }
    if (o5(t)) {
      const o = n[t];
      if (typeof o != "function")
        throw new Error(`Missing event ${t} on main thread channel ${e}.`);
      return o;
    }
    throw new Error(`Malformed event name ${t}`);
  }
  setChannel(e, t) {
    this._localChannels.set(e, t);
  }
  _onError(e, t) {
    console.error(e), console.info(t);
  }
}
function o5(s) {
  return s[0] === "o" && s[1] === "n" && hc(s.charCodeAt(2));
}
function r5(s) {
  return /^onDynamic/.test(s) && hc(s.charCodeAt(9));
}
function Hu(s, e) {
  const t = globalThis.MonacoEnvironment;
  if (t?.createTrustedTypesPolicy)
    try {
      return t.createTrustedTypesPolicy(s, e);
    } catch (i) {
      Pe(i);
      return;
    }
  try {
    return globalThis.trustedTypes?.createPolicy(s, e);
  } catch (i) {
    Pe(i);
    return;
  }
}
let Ng;
typeof self == "object" && self.constructor && self.constructor.name === "DedicatedWorkerGlobalScope" && globalThis.workerttPolicy !== void 0 ? Ng = globalThis.workerttPolicy : Ng = Hu("defaultWorkerFactory", { createScriptURL: (s) => s });
function GU(s, e) {
  const t = globalThis.MonacoEnvironment;
  if (t) {
    if (typeof t.getWorker == "function")
      return t.getWorker("workerMain.js", e);
    if (typeof t.getWorkerUrl == "function") {
      const i = t.getWorkerUrl("workerMain.js", e);
      return new Worker(Ng ? Ng.createScriptURL(i) : i, { name: e, type: "module" });
    }
  }
  if (s) {
    const i = jU(e, s.toString(!0)), n = new Worker(Ng ? Ng.createScriptURL(i) : i, { name: e, type: "module" });
    return YU(n);
  }
  throw new Error("You must define a function MonacoEnvironment.getWorkerUrl or MonacoEnvironment.getWorker");
}
function jU(s, e, t) {
  if (!(/^((http:)|(https:)|(file:)|(vscode-file:))/.test(e) && e.substring(0, globalThis.origin.length) !== globalThis.origin)) {
    const o = e.lastIndexOf("?"), r = e.lastIndexOf("#", o), a = o > 0 ? new URLSearchParams(e.substring(o + 1, ~r ? r : void 0)) : new URLSearchParams();
    VE.addSearchParam(a, !0, !0), a.toString() ? e = `${e}?${a.toString()}#${s}` : e = `${e}#${s}`;
  }
  const n = new Blob([mm([
    `/*${s}*/`,
    void 0,
    `globalThis._VSCODE_NLS_MESSAGES = ${JSON.stringify(Q4())};`,
    `globalThis._VSCODE_NLS_LANGUAGE = ${JSON.stringify(SM())};`,
    `globalThis._VSCODE_FILE_ROOT = '${globalThis._VSCODE_FILE_ROOT}';`,
    "const ttPolicy = globalThis.trustedTypes?.createPolicy('defaultWorkerFactory', { createScriptURL: value => value });",
    "globalThis.workerttPolicy = ttPolicy;",
    `await import(ttPolicy?.createScriptURL('${e}') ?? '${e}');`,
    "globalThis.postMessage({ type: 'vscode-worker-ready' });",
    // in ESM signal we are ready after the async import
    `/*${s}*/`
  ]).join("")], { type: "application/javascript" });
  return URL.createObjectURL(n);
}
function YU(s) {
  return new Promise((e, t) => {
    s.onmessage = function(i) {
      i.data.type === "vscode-worker-ready" && (s.onmessage = null, e(s));
    }, s.onerror = t;
  });
}
function KU(s) {
  return typeof s.then == "function";
}
class JU extends V {
  constructor(e, t, i, n, o, r) {
    super(), this.id = i, this.label = n;
    const a = GU(e, n);
    KU(a) ? this.worker = a : this.worker = Promise.resolve(a), this.postMessage(t, []), this.worker.then((l) => {
      l.onmessage = function(c) {
        o(c.data);
      }, l.onmessageerror = r, typeof l.addEventListener == "function" && l.addEventListener("error", r);
    }), this._register(we(() => {
      this.worker?.then((l) => {
        l.onmessage = null, l.onmessageerror = null, l.removeEventListener("error", r), l.terminate();
      }), this.worker = null;
    }));
  }
  getId() {
    return this.id;
  }
  postMessage(e, t) {
    this.worker?.then((i) => {
      try {
        i.postMessage(e, t);
      } catch (n) {
        Pe(n), Pe(new Error(`FAILED to post message to '${this.label}'-worker`, { cause: n }));
      }
    });
  }
}
class qU {
  constructor(e, t) {
    this.amdModuleId = e, this.label = t, this.esmModuleLocation = w0.asBrowserUri(`${e}.esm.js`);
  }
}
const b1 = class b1 {
  constructor() {
    this._webWorkerFailedBeforeError = !1;
  }
  create(e, t, i) {
    const n = ++b1.LAST_WORKER_ID;
    if (this._webWorkerFailedBeforeError)
      throw this._webWorkerFailedBeforeError;
    return new JU(e.esmModuleLocation, e.amdModuleId, n, e.label || "anonymous" + n, t, (o) => {
      JE(o), this._webWorkerFailedBeforeError = o, i(o);
    });
  }
};
b1.LAST_WORKER_ID = 0;
let qE = b1;
function $U(s, e) {
  const t = typeof s == "string" ? new qU(s, e) : s;
  return new QU(new qE(), t);
}
var Tn;
(function(s) {
  s[s.None = 0] = "None", s[s.Indent = 1] = "Indent", s[s.IndentOutdent = 2] = "IndentOutdent", s[s.Outdent = 3] = "Outdent";
})(Tn || (Tn = {}));
class cy {
  constructor(e) {
    if (this._neutralCharacter = null, this._neutralCharacterSearched = !1, this.open = e.open, this.close = e.close, this._inString = !0, this._inComment = !0, this._inRegEx = !0, Array.isArray(e.notIn))
      for (let t = 0, i = e.notIn.length; t < i; t++)
        switch (e.notIn[t]) {
          case "string":
            this._inString = !1;
            break;
          case "comment":
            this._inComment = !1;
            break;
          case "regex":
            this._inRegEx = !1;
            break;
        }
  }
  isOK(e) {
    switch (e) {
      case 0:
        return !0;
      case 1:
        return this._inComment;
      case 2:
        return this._inString;
      case 3:
        return this._inRegEx;
    }
  }
  shouldAutoClose(e, t) {
    if (e.getTokenCount() === 0)
      return !0;
    const i = e.findTokenIndexAtOffset(t - 2), n = e.getStandardTokenType(i);
    return this.isOK(n);
  }
  _findNeutralCharacterInRange(e, t) {
    for (let i = e; i <= t; i++) {
      const n = String.fromCharCode(i);
      if (!this.open.includes(n) && !this.close.includes(n))
        return n;
    }
    return null;
  }
  /**
   * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
   */
  findNeutralCharacter() {
    return this._neutralCharacterSearched || (this._neutralCharacterSearched = !0, this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      48,
      57
      /* CharCode.Digit9 */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      97,
      122
      /* CharCode.z */
    )), this._neutralCharacter || (this._neutralCharacter = this._findNeutralCharacterInRange(
      65,
      90
      /* CharCode.Z */
    ))), this._neutralCharacter;
  }
}
class XU {
  constructor(e) {
    this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map(), this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
    for (const t of e)
      jm(this.autoClosingPairsOpenByStart, t.open.charAt(0), t), jm(this.autoClosingPairsOpenByEnd, t.open.charAt(t.open.length - 1), t), jm(this.autoClosingPairsCloseByStart, t.close.charAt(0), t), jm(this.autoClosingPairsCloseByEnd, t.close.charAt(t.close.length - 1), t), t.close.length === 1 && t.open.length === 1 && jm(this.autoClosingPairsCloseSingleChar, t.close, t);
  }
}
function jm(s, e, t) {
  s.has(e) ? s.get(e).push(t) : s.set(e, [t]);
}
const ef = class ef {
  constructor(e) {
    if (e.autoClosingPairs ? this._autoClosingPairs = e.autoClosingPairs.map((t) => new cy(t)) : e.brackets ? this._autoClosingPairs = e.brackets.map((t) => new cy({ open: t[0], close: t[1] })) : this._autoClosingPairs = [], e.__electricCharacterSupport && e.__electricCharacterSupport.docComment) {
      const t = e.__electricCharacterSupport.docComment;
      this._autoClosingPairs.push(new cy({ open: t.open, close: t.close || "" }));
    }
    this._autoCloseBeforeForQuotes = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : ef.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES, this._autoCloseBeforeForBrackets = typeof e.autoCloseBefore == "string" ? e.autoCloseBefore : ef.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS, this._surroundingPairs = e.surroundingPairs || this._autoClosingPairs;
  }
  getAutoClosingPairs() {
    return this._autoClosingPairs;
  }
  getAutoCloseBeforeSet(e) {
    return e ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets;
  }
  getSurroundingPairs() {
    return this._surroundingPairs;
  }
};
ef.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = `;:.,=}])> 
	`, ef.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = `'"\`;:.,=}])> 
	`;
let $E = ef;
function wh(s, e) {
  const t = s.getCount(), i = s.findTokenIndexAtOffset(e), n = s.getLanguageId(i);
  let o = i;
  for (; o + 1 < t && s.getLanguageId(o + 1) === n; )
    o++;
  let r = i;
  for (; r > 0 && s.getLanguageId(r - 1) === n; )
    r--;
  return new ZU(s, n, r, o + 1, s.getStartOffset(r), s.getEndOffset(o));
}
class ZU {
  constructor(e, t, i, n, o, r) {
    this._scopedLineTokensBrand = void 0, this._actual = e, this.languageId = t, this._firstTokenIndex = i, this._lastTokenIndex = n, this.firstCharOffset = o, this._lastCharOffset = r, this.languageIdCodec = e.languageIdCodec;
  }
  getLineContent() {
    return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
  }
  getLineLength() {
    return this._lastCharOffset - this.firstCharOffset;
  }
  getActualLineContentBefore(e) {
    return this._actual.getLineContent().substring(0, this.firstCharOffset + e);
  }
  getTokenCount() {
    return this._lastTokenIndex - this._firstTokenIndex;
  }
  findTokenIndexAtOffset(e) {
    return this._actual.findTokenIndexAtOffset(e + this.firstCharOffset) - this._firstTokenIndex;
  }
  getStandardTokenType(e) {
    return this._actual.getStandardTokenType(e + this._firstTokenIndex);
  }
  toIViewLineTokens() {
    return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);
  }
}
function $r(s) {
  return (s & 3) !== 0;
}
const SR = typeof Buffer < "u";
let dy;
class sN {
  /**
   * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for
   * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,
   * which is not transferrable.
   */
  static wrap(e) {
    return SR && !Buffer.isBuffer(e) && (e = Buffer.from(e.buffer, e.byteOffset, e.byteLength)), new sN(e);
  }
  constructor(e) {
    this.buffer = e, this.byteLength = this.buffer.byteLength;
  }
  toString() {
    return SR ? this.buffer.toString() : (dy || (dy = new TextDecoder()), dy.decode(this.buffer));
  }
}
function eQ(s, e) {
  return s[e + 0] << 0 >>> 0 | s[e + 1] << 8 >>> 0;
}
function tQ(s, e, t) {
  s[t + 0] = e & 255, e = e >>> 8, s[t + 1] = e & 255;
}
function wr(s, e) {
  return s[e] * 2 ** 24 + s[e + 1] * 2 ** 16 + s[e + 2] * 2 ** 8 + s[e + 3];
}
function Cr(s, e, t) {
  s[t + 3] = e, e = e >>> 8, s[t + 2] = e, e = e >>> 8, s[t + 1] = e, e = e >>> 8, s[t] = e;
}
function yR(s, e) {
  return s[e];
}
function xR(s, e, t) {
  s[t] = e;
}
let hy;
function a5() {
  return hy || (hy = new TextDecoder("UTF-16LE")), hy;
}
let uy;
function iQ() {
  return uy || (uy = new TextDecoder("UTF-16BE")), uy;
}
let gy;
function l5() {
  return gy || (gy = P9() ? a5() : iQ()), gy;
}
function nQ(s, e, t) {
  const i = new Uint16Array(s.buffer, e, t);
  return t > 0 && (i[0] === 65279 || i[0] === 65534) ? sQ(s, e, t) : a5().decode(i);
}
function sQ(s, e, t) {
  const i = [];
  let n = 0;
  for (let o = 0; o < t; o++) {
    const r = eQ(s, e);
    e += 2, i[n++] = String.fromCharCode(r);
  }
  return i.join("");
}
class R0 {
  constructor(e) {
    this._capacity = e | 0, this._buffer = new Uint16Array(this._capacity), this._completedStrings = null, this._bufferLength = 0;
  }
  reset() {
    this._completedStrings = null, this._bufferLength = 0;
  }
  build() {
    return this._completedStrings !== null ? (this._flushBuffer(), this._completedStrings.join("")) : this._buildBuffer();
  }
  _buildBuffer() {
    if (this._bufferLength === 0)
      return "";
    const e = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
    return l5().decode(e);
  }
  _flushBuffer() {
    const e = this._buildBuffer();
    this._bufferLength = 0, this._completedStrings === null ? this._completedStrings = [e] : this._completedStrings[this._completedStrings.length] = e;
  }
  /**
   * Append a char code (<2^16)
   */
  appendCharCode(e) {
    const t = this._capacity - this._bufferLength;
    t <= 1 && (t === 0 || Si(e)) && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  /**
   * Append an ASCII char code (<2^8)
   */
  appendASCIICharCode(e) {
    this._bufferLength === this._capacity && this._flushBuffer(), this._buffer[this._bufferLength++] = e;
  }
  appendString(e) {
    const t = e.length;
    if (this._bufferLength + t >= this._capacity) {
      this._flushBuffer(), this._completedStrings[this._completedStrings.length] = e;
      return;
    }
    for (let i = 0; i < t; i++)
      this._buffer[this._bufferLength++] = e.charCodeAt(i);
  }
}
class cC {
  constructor(e, t, i, n, o, r) {
    this._richEditBracketBrand = void 0, this.languageId = e, this.index = t, this.open = i, this.close = n, this.forwardRegex = o, this.reversedRegex = r, this._openSet = cC._toSet(this.open), this._closeSet = cC._toSet(this.close);
  }
  /**
   * Check if the provided `text` is an open bracket in this group.
   */
  isOpen(e) {
    return this._openSet.has(e);
  }
  /**
   * Check if the provided `text` is a close bracket in this group.
   */
  isClose(e) {
    return this._closeSet.has(e);
  }
  static _toSet(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of e)
      t.add(i);
    return t;
  }
}
function oQ(s) {
  const e = s.length;
  s = s.map((r) => [r[0].toLowerCase(), r[1].toLowerCase()]);
  const t = [];
  for (let r = 0; r < e; r++)
    t[r] = r;
  const i = (r, a) => {
    const [l, c] = r, [d, h] = a;
    return l === d || l === h || c === d || c === h;
  }, n = (r, a) => {
    const l = Math.min(r, a), c = Math.max(r, a);
    for (let d = 0; d < e; d++)
      t[d] === c && (t[d] = l);
  };
  for (let r = 0; r < e; r++) {
    const a = s[r];
    for (let l = r + 1; l < e; l++) {
      const c = s[l];
      i(a, c) && n(t[r], t[l]);
    }
  }
  const o = [];
  for (let r = 0; r < e; r++) {
    const a = [], l = [];
    for (let c = 0; c < e; c++)
      if (t[c] === r) {
        const [d, h] = s[c];
        a.push(d), l.push(h);
      }
    a.length > 0 && o.push({
      open: a,
      close: l
    });
  }
  return o;
}
class rQ {
  constructor(e, t) {
    this._richEditBracketsBrand = void 0;
    const i = oQ(t);
    this.brackets = i.map((n, o) => new cC(e, o, n.open, n.close, aQ(n.open, n.close, i, o), lQ(n.open, n.close, i, o))), this.forwardRegex = cQ(this.brackets), this.reversedRegex = dQ(this.brackets), this.textIsBracket = {}, this.textIsOpenBracket = {}, this.maxBracketLength = 0;
    for (const n of this.brackets) {
      for (const o of n.open)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !0, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
      for (const o of n.close)
        this.textIsBracket[o] = n, this.textIsOpenBracket[o] = !1, this.maxBracketLength = Math.max(this.maxBracketLength, o.length);
    }
  }
}
function c5(s, e, t, i) {
  for (let n = 0, o = e.length; n < o; n++) {
    if (n === t)
      continue;
    const r = e[n];
    for (const a of r.open)
      a.indexOf(s) >= 0 && i.push(a);
    for (const a of r.close)
      a.indexOf(s) >= 0 && i.push(a);
  }
}
function d5(s, e) {
  return s.length - e.length;
}
function F0(s) {
  if (s.length <= 1)
    return s;
  const e = [], t = /* @__PURE__ */ new Set();
  for (const i of s)
    t.has(i) || (e.push(i), t.add(i));
  return e;
}
function aQ(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    c5(n[o], t, i, n);
  return n = F0(n), n.sort(d5), n.reverse(), T_(n);
}
function lQ(s, e, t, i) {
  let n = [];
  n = n.concat(s), n = n.concat(e);
  for (let o = 0, r = n.length; o < r; o++)
    c5(n[o], t, i, n);
  return n = F0(n), n.sort(d5), n.reverse(), T_(n.map(oN));
}
function cQ(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = F0(e), T_(e);
}
function dQ(s) {
  let e = [];
  for (const t of s) {
    for (const i of t.open)
      e.push(i);
    for (const i of t.close)
      e.push(i);
  }
  return e = F0(e), T_(e.map(oN));
}
function hQ(s) {
  const e = /^[\w ]+$/.test(s);
  return s = So(s), e ? `\\b${s}\\b` : s;
}
function T_(s, e) {
  const t = `(${s.map(hQ).join(")|(")})`;
  return _H(t, !0, e);
}
const oN = /* @__PURE__ */ function() {
  function s(i) {
    const n = new Uint16Array(i.length);
    let o = 0;
    for (let r = i.length - 1; r >= 0; r--)
      n[o++] = i.charCodeAt(r);
    return l5().decode(n);
  }
  let e = null, t = null;
  return function(n) {
    return e !== n && (e = n, t = s(e)), t;
  };
}();
class To {
  static _findPrevBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = i.length - (o.index || 0), a = o[0].length, l = n + r;
    return new E(t, l - a + 1, t, l + 1);
  }
  static findPrevBracketInRange(e, t, i, n, o) {
    const a = oN(i).substring(i.length - o, i.length - n);
    return this._findPrevBracketInText(e, t, a, n);
  }
  static findNextBracketInText(e, t, i, n) {
    const o = i.match(e);
    if (!o)
      return null;
    const r = o.index || 0, a = o[0].length;
    if (a === 0)
      return null;
    const l = n + r;
    return new E(t, l + 1, t, l + 1 + a);
  }
  static findNextBracketInRange(e, t, i, n, o) {
    const r = i.substring(n, o);
    return this.findNextBracketInText(e, t, r, n);
  }
}
class uQ {
  constructor(e) {
    this._richEditBrackets = e;
  }
  getElectricCharacters() {
    const e = [];
    if (this._richEditBrackets)
      for (const t of this._richEditBrackets.brackets)
        for (const i of t.close) {
          const n = i.charAt(i.length - 1);
          e.push(n);
        }
    return du(e);
  }
  onElectricCharacter(e, t, i) {
    if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0)
      return null;
    const n = t.findTokenIndexAtOffset(i - 1);
    if ($r(t.getStandardTokenType(n)))
      return null;
    const o = this._richEditBrackets.reversedRegex, r = t.getLineContent().substring(0, i - 1) + e, a = To.findPrevBracketInRange(o, 1, r, 0, r.length);
    if (!a)
      return null;
    const l = r.substring(a.startColumn - 1, a.endColumn - 1).toLowerCase();
    if (this._richEditBrackets.textIsOpenBracket[l])
      return null;
    const d = t.getActualLineContentBefore(a.startColumn - 1);
    return /^\s*$/.test(d) ? {
      matchOpenBracket: l
    } : null;
  }
}
function gb(s) {
  return s.global && (s.lastIndex = 0), !0;
}
class gQ {
  constructor(e) {
    this._indentationRules = e;
  }
  shouldIncrease(e) {
    return !!(this._indentationRules && this._indentationRules.increaseIndentPattern && gb(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(e));
  }
  shouldDecrease(e) {
    return !!(this._indentationRules && this._indentationRules.decreaseIndentPattern && gb(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(e));
  }
  shouldIndentNextLine(e) {
    return !!(this._indentationRules && this._indentationRules.indentNextLinePattern && gb(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(e));
  }
  shouldIgnore(e) {
    return !!(this._indentationRules && this._indentationRules.unIndentedLinePattern && gb(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(e));
  }
  getIndentMetadata(e) {
    let t = 0;
    return this.shouldIncrease(e) && (t += 1), this.shouldDecrease(e) && (t += 2), this.shouldIndentNextLine(e) && (t += 4), this.shouldIgnore(e) && (t += 8), t;
  }
}
class Tg {
  constructor(e) {
    e = e || {}, e.brackets = e.brackets || [
      ["(", ")"],
      ["{", "}"],
      ["[", "]"]
    ], this._brackets = [], e.brackets.forEach((t) => {
      const i = Tg._createOpenBracketRegExp(t[0]), n = Tg._createCloseBracketRegExp(t[1]);
      i && n && this._brackets.push({
        open: t[0],
        openRegExp: i,
        close: t[1],
        closeRegExp: n
      });
    }), this._regExpRules = e.onEnterRules || [];
  }
  onEnter(e, t, i, n) {
    if (e >= 3)
      for (let o = 0, r = this._regExpRules.length; o < r; o++) {
        const a = this._regExpRules[o];
        if ([{
          reg: a.beforeText,
          text: i
        }, {
          reg: a.afterText,
          text: n
        }, {
          reg: a.previousLineText,
          text: t
        }].every((c) => c.reg ? (c.reg.lastIndex = 0, c.reg.test(c.text)) : !0))
          return a.action;
      }
    if (e >= 2 && i.length > 0 && n.length > 0)
      for (let o = 0, r = this._brackets.length; o < r; o++) {
        const a = this._brackets[o];
        if (a.openRegExp.test(i) && a.closeRegExp.test(n))
          return { indentAction: Tn.IndentOutdent };
      }
    if (e >= 2 && i.length > 0) {
      for (let o = 0, r = this._brackets.length; o < r; o++)
        if (this._brackets[o].openRegExp.test(i))
          return { indentAction: Tn.Indent };
    }
    return null;
  }
  static _createOpenBracketRegExp(e) {
    let t = So(e);
    return /\B/.test(t.charAt(0)) || (t = "\\b" + t), t += "\\s*$", Tg._safeRegExp(t);
  }
  static _createCloseBracketRegExp(e) {
    let t = So(e);
    return /\B/.test(t.charAt(t.length - 1)) || (t = t + "\\b"), t = "^\\s*" + t, Tg._safeRegExp(t);
  }
  static _safeRegExp(e) {
    try {
      return new RegExp(e);
    } catch (t) {
      return Pe(t), null;
    }
  }
}
const ht = We("configurationService");
function XE(s, e) {
  const t = /* @__PURE__ */ Object.create(null);
  for (const i in s)
    h5(t, i, s[i], e);
  return t;
}
function h5(s, e, t, i) {
  const n = e.split("."), o = n.pop();
  let r = s;
  for (let a = 0; a < n.length; a++) {
    const l = n[a];
    let c = r[l];
    switch (typeof c) {
      case "undefined":
        c = r[l] = /* @__PURE__ */ Object.create(null);
        break;
      case "object":
        if (c === null) {
          i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is null`);
          return;
        }
        break;
      default:
        i(`Ignoring ${e} as ${n.slice(0, a + 1).join(".")} is ${JSON.stringify(c)}`);
        return;
    }
    r = c;
  }
  if (typeof r == "object" && r !== null)
    try {
      r[o] = t;
    } catch {
      i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
    }
  else
    i(`Ignoring ${e} as ${n.join(".")} is ${JSON.stringify(r)}`);
}
function fQ(s, e) {
  const t = e.split(".");
  u5(s, t);
}
function u5(s, e) {
  const t = e.shift();
  if (e.length === 0) {
    delete s[t];
    return;
  }
  if (Object.keys(s).indexOf(t) !== -1) {
    const i = s[t];
    typeof i == "object" && !Array.isArray(i) && (u5(i, e), Object.keys(i).length === 0 && delete s[t]);
  }
}
function ER(s, e, t) {
  function i(r, a) {
    let l = r;
    for (const c of a) {
      if (typeof l != "object" || l === null)
        return;
      l = l[c];
    }
    return l;
  }
  const n = e.split("."), o = i(s, n);
  return typeof o > "u" ? t : o;
}
function mQ(s) {
  return s.replace(/[\[\]]/g, "");
}
const si = We("languageService");
class ha {
  constructor(e, t = [], i = !1) {
    this.ctor = e, this.staticArguments = t, this.supportsDelayedInstantiation = i;
  }
}
const g5 = [];
function $e(s, e, t) {
  e instanceof ha || (e = new ha(e, [], !!t)), g5.push([s, e]);
}
function LR() {
  return g5;
}
const fl = Object.freeze({
  text: "text/plain",
  binary: "application/octet-stream",
  unknown: "application/unknown",
  markdown: "text/markdown",
  latex: "text/latex",
  uriList: "text/uri-list"
}), O0 = {
  JSONContribution: "base.contributions.json"
};
function pQ(s) {
  return s.length > 0 && s.charAt(s.length - 1) === "#" ? s.substring(0, s.length - 1) : s;
}
class AQ {
  constructor() {
    this._onDidChangeSchema = new B(), this.schemasById = {};
  }
  registerSchema(e, t) {
    this.schemasById[pQ(e)] = t, this._onDidChangeSchema.fire(e);
  }
  notifySchemaChanged(e) {
    this._onDidChangeSchema.fire(e);
  }
}
const _Q = new AQ();
ji.add(O0.JSONContribution, _Q);
const Wu = {
  Configuration: "base.contributions.configuration"
}, fb = "vscode://schemas/settings/resourceLanguage", kR = ji.as(O0.JSONContribution);
class bQ {
  constructor() {
    this.registeredConfigurationDefaults = [], this.overrideIdentifiers = /* @__PURE__ */ new Set(), this._onDidSchemaChange = new B(), this._onDidUpdateConfiguration = new B(), this.configurationDefaultsOverrides = /* @__PURE__ */ new Map(), this.defaultLanguageConfigurationOverridesNode = {
      id: "defaultOverrides",
      title: f("defaultLanguageConfigurationOverrides.title", "Default Language Configuration Overrides"),
      properties: {}
    }, this.configurationContributors = [this.defaultLanguageConfigurationOverridesNode], this.resourceLanguageSettingsSchema = {
      properties: {},
      patternProperties: {},
      additionalProperties: !0,
      allowTrailingCommas: !0,
      allowComments: !0
    }, this.configurationProperties = {}, this.policyConfigurations = /* @__PURE__ */ new Map(), this.excludedConfigurationProperties = {}, kR.registerSchema(fb, this.resourceLanguageSettingsSchema), this.registerOverridePropertyPatternKey();
  }
  registerConfiguration(e, t = !0) {
    this.registerConfigurations([e], t);
  }
  registerConfigurations(e, t = !0) {
    const i = /* @__PURE__ */ new Set();
    this.doRegisterConfigurations(e, t, i), kR.registerSchema(fb, this.resourceLanguageSettingsSchema), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: i });
  }
  registerDefaultConfigurations(e) {
    const t = /* @__PURE__ */ new Set();
    this.doRegisterDefaultConfigurations(e, t), this._onDidSchemaChange.fire(), this._onDidUpdateConfiguration.fire({ properties: t, defaultsOverrides: !0 });
  }
  doRegisterDefaultConfigurations(e, t) {
    this.registeredConfigurationDefaults.push(...e);
    const i = [];
    for (const { overrides: n, source: o } of e)
      for (const r in n) {
        t.add(r);
        const a = this.configurationDefaultsOverrides.get(r) ?? this.configurationDefaultsOverrides.set(r, { configurationDefaultOverrides: [] }).get(r), l = n[r];
        if (a.configurationDefaultOverrides.push({ value: l, source: o }), rd.test(r)) {
          const c = this.mergeDefaultConfigurationsForOverrideIdentifier(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c, this.updateDefaultOverrideProperty(r, c, o), i.push(...dC(r));
        } else {
          const c = this.mergeDefaultConfigurationsForConfigurationProperty(r, l, o, a.configurationDefaultOverrideValue);
          if (!c)
            continue;
          a.configurationDefaultOverrideValue = c;
          const d = this.configurationProperties[r];
          d && (this.updatePropertyDefaultValue(r, d), this.updateSchema(r, d));
        }
      }
    this.doRegisterOverrideIdentifiers(i);
  }
  updateDefaultOverrideProperty(e, t, i) {
    const n = {
      type: "object",
      default: t.value,
      description: f("defaultLanguageConfiguration.description", "Configure settings to be overridden for the {0} language.", mQ(e)),
      $ref: fb,
      defaultDefaultValue: t.value,
      source: i,
      defaultValueSource: i
    };
    this.configurationProperties[e] = n, this.defaultLanguageConfigurationOverridesNode.properties[e] = n;
  }
  mergeDefaultConfigurationsForOverrideIdentifier(e, t, i, n) {
    const o = n?.value || {}, r = n?.source ?? /* @__PURE__ */ new Map();
    if (!(r instanceof Map)) {
      console.error("objectConfigurationSources is not a Map");
      return;
    }
    for (const a of Object.keys(t)) {
      const l = t[a];
      if (Ti(l) && (Mn(o[a]) || Ti(o[a]))) {
        if (o[a] = { ...o[a] ?? {}, ...l }, i)
          for (const d in l)
            r.set(`${a}.${d}`, i);
      } else
        o[a] = l, i ? r.set(a, i) : r.delete(a);
    }
    return { value: o, source: r };
  }
  mergeDefaultConfigurationsForConfigurationProperty(e, t, i, n) {
    const o = this.configurationProperties[e], r = n?.value ?? o?.defaultDefaultValue;
    let a = i;
    if (Ti(t) && (o !== void 0 && o.type === "object" || o === void 0 && (Mn(r) || Ti(r)))) {
      if (a = n?.source ?? /* @__PURE__ */ new Map(), !(a instanceof Map)) {
        console.error("defaultValueSource is not a Map");
        return;
      }
      for (const c in t)
        i && a.set(`${e}.${c}`, i);
      t = { ...Ti(r) ? r : {}, ...t };
    }
    return { value: t, source: a };
  }
  registerOverrideIdentifiers(e) {
    this.doRegisterOverrideIdentifiers(e), this._onDidSchemaChange.fire();
  }
  doRegisterOverrideIdentifiers(e) {
    for (const t of e)
      this.overrideIdentifiers.add(t);
    this.updateOverridePropertyPatternKey();
  }
  doRegisterConfigurations(e, t, i) {
    e.forEach((n) => {
      this.validateAndRegisterProperties(n, t, n.extensionInfo, n.restrictedProperties, void 0, i), this.configurationContributors.push(n), this.registerJSONConfiguration(n);
    });
  }
  validateAndRegisterProperties(e, t = !0, i, n, o = 3, r) {
    o = Ws(e.scope) ? o : e.scope;
    const a = e.properties;
    if (a)
      for (const c in a) {
        const d = a[c];
        if (t && vQ(c, d)) {
          delete a[c];
          continue;
        }
        if (d.source = i, d.defaultDefaultValue = a[c].default, this.updatePropertyDefaultValue(c, d), rd.test(c) ? d.scope = void 0 : (d.scope = Ws(d.scope) ? o : d.scope, d.restricted = Ws(d.restricted) ? !!n?.includes(c) : d.restricted), a[c].hasOwnProperty("included") && !a[c].included) {
          this.excludedConfigurationProperties[c] = a[c], delete a[c];
          continue;
        } else
          this.configurationProperties[c] = a[c], a[c].policy?.name && this.policyConfigurations.set(a[c].policy.name, c);
        !a[c].deprecationMessage && a[c].markdownDeprecationMessage && (a[c].deprecationMessage = a[c].markdownDeprecationMessage), r.add(c);
      }
    const l = e.allOf;
    if (l)
      for (const c of l)
        this.validateAndRegisterProperties(c, t, i, n, o, r);
  }
  getConfigurationProperties() {
    return this.configurationProperties;
  }
  getPolicyConfigurations() {
    return this.policyConfigurations;
  }
  registerJSONConfiguration(e) {
    const t = (i) => {
      const n = i.properties;
      if (n)
        for (const r in n)
          this.updateSchema(r, n[r]);
      i.allOf?.forEach(t);
    };
    t(e);
  }
  updateSchema(e, t) {
    switch (t.scope) {
      case 1:
        break;
      case 2:
        break;
      case 6:
        break;
      case 3:
        break;
      case 4:
        break;
      case 5:
        this.resourceLanguageSettingsSchema.properties[e] = t;
        break;
    }
  }
  updateOverridePropertyPatternKey() {
    for (const e of this.overrideIdentifiers.values()) {
      const t = `[${e}]`, i = {
        type: "object",
        description: f("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."),
        errorMessage: f("overrideSettings.errorMessage", "This setting does not support per-language configuration."),
        $ref: fb
      };
      this.updatePropertyDefaultValue(t, i);
    }
  }
  registerOverridePropertyPatternKey() {
    f("overrideSettings.defaultDescription", "Configure editor settings to be overridden for a language."), f("overrideSettings.errorMessage", "This setting does not support per-language configuration."), this._onDidSchemaChange.fire();
  }
  updatePropertyDefaultValue(e, t) {
    const i = this.configurationDefaultsOverrides.get(e)?.configurationDefaultOverrideValue;
    let n, o;
    i && (!t.disallowConfigurationDefault || !i.source) && (n = i.value, o = i.source), Mn(n) && (n = t.defaultDefaultValue, o = void 0), Mn(n) && (n = CQ(t.type)), t.default = n, t.defaultValueSource = o;
  }
}
const f5 = "\\[([^\\]]+)\\]", DR = new RegExp(f5, "g"), wQ = `^(${f5})+$`, rd = new RegExp(wQ);
function dC(s) {
  const e = [];
  if (rd.test(s)) {
    let t = DR.exec(s);
    for (; t?.length; ) {
      const i = t[1].trim();
      i && e.push(i), t = DR.exec(s);
    }
  }
  return du(e);
}
function CQ(s) {
  switch (Array.isArray(s) ? s[0] : s) {
    case "boolean":
      return !1;
    case "integer":
    case "number":
      return 0;
    case "string":
      return "";
    case "array":
      return [];
    case "object":
      return {};
    default:
      return null;
  }
}
const Aw = new bQ();
ji.add(Wu.Configuration, Aw);
function vQ(s, e) {
  return s.trim() ? rd.test(s) ? f("config.property.languageDefault", "Cannot register '{0}'. This matches property pattern '\\\\[.*\\\\]$' for describing language specific editor settings. Use 'configurationDefaults' contribution.", s) : Aw.getConfigurationProperties()[s] !== void 0 ? f("config.property.duplicate", "Cannot register '{0}'. This property is already registered.", s) : e.policy?.name && Aw.getPolicyConfigurations().get(e.policy?.name) !== void 0 ? f("config.policy.duplicate", "Cannot register '{0}'. The associated policy {1} is already registered with {2}.", s, e.policy?.name, Aw.getPolicyConfigurations().get(e.policy?.name)) : null : f("config.property.empty", "Cannot register an empty property");
}
const SQ = {
  ModesRegistry: "editor.modesRegistry"
};
class yQ {
  constructor() {
    this._onDidChangeLanguages = new B(), this.onDidChangeLanguages = this._onDidChangeLanguages.event, this._languages = [];
  }
  registerLanguage(e) {
    return this._languages.push(e), this._onDidChangeLanguages.fire(void 0), {
      dispose: () => {
        for (let t = 0, i = this._languages.length; t < i; t++)
          if (this._languages[t] === e) {
            this._languages.splice(t, 1);
            return;
          }
      }
    };
  }
  getLanguages() {
    return this._languages;
  }
}
const Qf = new yQ();
ji.add(SQ.ModesRegistry, Qf);
const Js = "plaintext", xQ = ".txt";
Qf.registerLanguage({
  id: Js,
  extensions: [xQ],
  aliases: [f("plainText.alias", "Plain Text"), "text"],
  mimetypes: [fl.text]
});
ji.as(Wu.Configuration).registerDefaultConfigurations([{
  overrides: {
    "[plaintext]": {
      "editor.unicodeHighlight.ambiguousCharacters": !1,
      "editor.unicodeHighlight.invisibleCharacters": !1
    }
  }
}]);
class EQ {
  constructor(e, t) {
    this.languageId = e;
    const i = t.brackets ? IR(t.brackets) : [], n = new XB((a) => {
      const l = /* @__PURE__ */ new Set();
      return {
        info: new LQ(this, a, l),
        closing: l
      };
    }), o = new XB((a) => {
      const l = /* @__PURE__ */ new Set(), c = /* @__PURE__ */ new Set();
      return {
        info: new kQ(this, a, l, c),
        opening: l,
        openingColorized: c
      };
    });
    for (const [a, l] of i) {
      const c = n.get(a), d = o.get(l);
      c.closing.add(d.info), d.opening.add(c.info);
    }
    const r = t.colorizedBracketPairs ? IR(t.colorizedBracketPairs) : i.filter((a) => !(a[0] === "<" && a[1] === ">"));
    for (const [a, l] of r) {
      const c = n.get(a), d = o.get(l);
      c.closing.add(d.info), d.openingColorized.add(c.info), d.opening.add(c.info);
    }
    this._openingBrackets = new Map([...n.cachedValues].map(([a, l]) => [a, l.info])), this._closingBrackets = new Map([...o.cachedValues].map(([a, l]) => [a, l.info]));
  }
  /**
   * No two brackets have the same bracket text.
  */
  get openingBrackets() {
    return [...this._openingBrackets.values()];
  }
  /**
   * No two brackets have the same bracket text.
  */
  get closingBrackets() {
    return [...this._closingBrackets.values()];
  }
  getOpeningBracketInfo(e) {
    return this._openingBrackets.get(e);
  }
  getClosingBracketInfo(e) {
    return this._closingBrackets.get(e);
  }
  getBracketInfo(e) {
    return this.getOpeningBracketInfo(e) || this.getClosingBracketInfo(e);
  }
  getBracketRegExp(e) {
    const t = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);
    return T_(t, e);
  }
}
function IR(s) {
  return s.filter(([e, t]) => e !== "" && t !== "");
}
class m5 {
  constructor(e, t) {
    this.config = e, this.bracketText = t;
  }
  get languageId() {
    return this.config.languageId;
  }
}
class LQ extends m5 {
  constructor(e, t, i) {
    super(e, t), this.openedBrackets = i, this.isOpeningBracket = !0;
  }
}
class kQ extends m5 {
  constructor(e, t, i, n) {
    super(e, t), this.openingBrackets = i, this.openingColorizedBrackets = n, this.isOpeningBracket = !1;
  }
  /**
   * Checks if this bracket closes the given other bracket.
   * If the bracket infos come from different configurations, this method will return false.
  */
  closes(e) {
    return e.config !== this.config ? !1 : this.openingBrackets.has(e);
  }
  closesColorized(e) {
    return e.config !== this.config ? !1 : this.openingColorizedBrackets.has(e);
  }
  getOpeningBrackets() {
    return [...this.openingBrackets];
  }
}
var DQ = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, MR = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class fy {
  constructor(e) {
    this.languageId = e;
  }
  affects(e) {
    return this.languageId ? this.languageId === e : !0;
  }
}
const tn = We("languageConfigurationService");
let ZE = class extends V {
  constructor(e, t) {
    super(), this.configurationService = e, this.languageService = t, this._registry = this._register(new TQ()), this.onDidChangeEmitter = this._register(new B()), this.onDidChange = this.onDidChangeEmitter.event, this.configurations = /* @__PURE__ */ new Map();
    const i = new Set(Object.values(eL));
    this._register(this.configurationService.onDidChangeConfiguration((n) => {
      const o = n.change.keys.some((a) => i.has(a)), r = n.change.overrides.filter(([a, l]) => l.some((c) => i.has(c))).map(([a]) => a);
      if (o)
        this.configurations.clear(), this.onDidChangeEmitter.fire(new fy(void 0));
      else
        for (const a of r)
          this.languageService.isRegisteredLanguageId(a) && (this.configurations.delete(a), this.onDidChangeEmitter.fire(new fy(a)));
    })), this._register(this._registry.onDidChange((n) => {
      this.configurations.delete(n.languageId), this.onDidChangeEmitter.fire(new fy(n.languageId));
    }));
  }
  register(e, t, i) {
    return this._registry.register(e, t, i);
  }
  getLanguageConfiguration(e) {
    let t = this.configurations.get(e);
    return t || (t = IQ(e, this._registry, this.configurationService, this.languageService), this.configurations.set(e, t)), t;
  }
};
ZE = DQ([
  MR(0, ht),
  MR(1, si)
], ZE);
function IQ(s, e, t, i) {
  let n = e.getLanguageConfiguration(s);
  if (!n) {
    if (!i.isRegisteredLanguageId(s))
      return new Af(s, {});
    n = new Af(s, {});
  }
  const o = MQ(n.languageId, t), r = A5([n.underlyingConfig, o]);
  return new Af(n.languageId, r);
}
const eL = {
  brackets: "editor.language.brackets",
  colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function MQ(s, e) {
  const t = e.getValue(eL.brackets, {
    overrideIdentifier: s
  }), i = e.getValue(eL.colorizedBracketPairs, {
    overrideIdentifier: s
  });
  return {
    brackets: NR(t),
    colorizedBracketPairs: NR(i)
  };
}
function NR(s) {
  if (Array.isArray(s))
    return s.map((e) => {
      if (!(!Array.isArray(e) || e.length !== 2))
        return [e[0], e[1]];
    }).filter((e) => !!e);
}
function p5(s, e, t) {
  const i = s.getLineContent(e);
  let n = Ii(i);
  return n.length > t - 1 && (n = n.substring(0, t - 1)), n;
}
class NQ {
  constructor(e) {
    this.languageId = e, this._resolved = null, this._entries = [], this._order = 0, this._resolved = null;
  }
  register(e, t) {
    const i = new TR(e, t, ++this._order);
    return this._entries.push(i), this._resolved = null, we(() => {
      for (let n = 0; n < this._entries.length; n++)
        if (this._entries[n] === i) {
          this._entries.splice(n, 1), this._resolved = null;
          break;
        }
    });
  }
  getResolvedConfiguration() {
    if (!this._resolved) {
      const e = this._resolve();
      e && (this._resolved = new Af(this.languageId, e));
    }
    return this._resolved;
  }
  _resolve() {
    return this._entries.length === 0 ? null : (this._entries.sort(TR.cmp), A5(this._entries.map((e) => e.configuration)));
  }
}
function A5(s) {
  let e = {
    comments: void 0,
    brackets: void 0,
    wordPattern: void 0,
    indentationRules: void 0,
    onEnterRules: void 0,
    autoClosingPairs: void 0,
    surroundingPairs: void 0,
    autoCloseBefore: void 0,
    folding: void 0,
    colorizedBracketPairs: void 0,
    __electricCharacterSupport: void 0
  };
  for (const t of s)
    e = {
      comments: t.comments || e.comments,
      brackets: t.brackets || e.brackets,
      wordPattern: t.wordPattern || e.wordPattern,
      indentationRules: t.indentationRules || e.indentationRules,
      onEnterRules: t.onEnterRules || e.onEnterRules,
      autoClosingPairs: t.autoClosingPairs || e.autoClosingPairs,
      surroundingPairs: t.surroundingPairs || e.surroundingPairs,
      autoCloseBefore: t.autoCloseBefore || e.autoCloseBefore,
      folding: t.folding || e.folding,
      colorizedBracketPairs: t.colorizedBracketPairs || e.colorizedBracketPairs,
      __electricCharacterSupport: t.__electricCharacterSupport || e.__electricCharacterSupport
    };
  return e;
}
class TR {
  constructor(e, t, i) {
    this.configuration = e, this.priority = t, this.order = i;
  }
  static cmp(e, t) {
    return e.priority === t.priority ? e.order - t.order : e.priority - t.priority;
  }
}
class BR {
  constructor(e) {
    this.languageId = e;
  }
}
class TQ extends V {
  constructor() {
    super(), this._entries = /* @__PURE__ */ new Map(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._register(this.register(Js, {
      brackets: [
        ["(", ")"],
        ["[", "]"],
        ["{", "}"]
      ],
      surroundingPairs: [
        { open: "{", close: "}" },
        { open: "[", close: "]" },
        { open: "(", close: ")" },
        { open: "<", close: ">" },
        { open: '"', close: '"' },
        { open: "'", close: "'" },
        { open: "`", close: "`" }
      ],
      colorizedBracketPairs: [],
      folding: {
        offSide: !0
      }
    }, 0));
  }
  /**
   * @param priority Use a higher number for higher priority
   */
  register(e, t, i = 0) {
    let n = this._entries.get(e);
    n || (n = new NQ(e), this._entries.set(e, n));
    const o = n.register(t, i);
    return this._onDidChange.fire(new BR(e)), we(() => {
      o.dispose(), this._onDidChange.fire(new BR(e));
    });
  }
  getLanguageConfiguration(e) {
    return this._entries.get(e)?.getResolvedConfiguration() || null;
  }
}
class Af {
  constructor(e, t) {
    this.languageId = e, this.underlyingConfig = t, this._brackets = null, this._electricCharacter = null, this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new Tg(this.underlyingConfig) : null, this.comments = Af._handleComments(this.underlyingConfig), this.characterPair = new $E(this.underlyingConfig), this.wordDefinition = this.underlyingConfig.wordPattern || EM, this.indentationRules = this.underlyingConfig.indentationRules, this.underlyingConfig.indentationRules ? this.indentRulesSupport = new gQ(this.underlyingConfig.indentationRules) : this.indentRulesSupport = null, this.foldingRules = this.underlyingConfig.folding || {}, this.bracketsNew = new EQ(e, this.underlyingConfig);
  }
  getWordDefinition() {
    return LM(this.wordDefinition);
  }
  get brackets() {
    return !this._brackets && this.underlyingConfig.brackets && (this._brackets = new rQ(this.languageId, this.underlyingConfig.brackets)), this._brackets;
  }
  get electricCharacter() {
    return this._electricCharacter || (this._electricCharacter = new uQ(this.brackets)), this._electricCharacter;
  }
  onEnter(e, t, i, n) {
    return this._onEnterSupport ? this._onEnterSupport.onEnter(e, t, i, n) : null;
  }
  getAutoClosingPairs() {
    return new XU(this.characterPair.getAutoClosingPairs());
  }
  getAutoCloseBeforeSet(e) {
    return this.characterPair.getAutoCloseBeforeSet(e);
  }
  getSurroundingPairs() {
    return this.characterPair.getSurroundingPairs();
  }
  static _handleComments(e) {
    const t = e.comments;
    if (!t)
      return null;
    const i = {};
    if (t.lineComment && (i.lineCommentToken = t.lineComment), t.blockComment) {
      const [n, o] = t.blockComment;
      i.blockCommentStartToken = n, i.blockCommentEndToken = o;
    }
    return i;
  }
}
$e(
  tn,
  ZE,
  1
  /* InstantiationType.Delayed */
);
class lc {
  /**
   * Constructs a new DiffChange with the given sequence information
   * and content.
   */
  constructor(e, t, i, n) {
    this.originalStart = e, this.originalLength = t, this.modifiedStart = i, this.modifiedLength = n;
  }
  /**
   * The end point (exclusive) of the change in the original sequence.
   */
  getOriginalEnd() {
    return this.originalStart + this.originalLength;
  }
  /**
   * The end point (exclusive) of the change in the modified sequence.
   */
  getModifiedEnd() {
    return this.modifiedStart + this.modifiedLength;
  }
}
class RR {
  constructor(e) {
    this.source = e;
  }
  getElements() {
    const e = this.source, t = new Int32Array(e.length);
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = e.charCodeAt(i);
    return t;
  }
}
function BQ(s, e, t) {
  return new ml(new RR(s), new RR(e)).ComputeDiff(t).changes;
}
class og {
  static Assert(e, t) {
    if (!e)
      throw new Error(t);
  }
}
class rg {
  /**
   * Copies a range of elements from an Array starting at the specified source index and pastes
   * them to another Array starting at the specified destination index. The length and the indexes
   * are specified as 64-bit integers.
   * sourceArray:
   *		The Array that contains the data to copy.
   * sourceIndex:
   *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
   * destinationArray:
   *		The Array that receives the data.
   * destinationIndex:
   *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
   * length:
   *		A 64-bit integer that represents the number of elements to copy.
   */
  static Copy(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
  static Copy2(e, t, i, n, o) {
    for (let r = 0; r < o; r++)
      i[n + r] = e[t + r];
  }
}
class FR {
  /**
   * Constructs a new DiffChangeHelper for the given DiffSequences.
   */
  constructor() {
    this.m_changes = [], this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824, this.m_originalCount = 0, this.m_modifiedCount = 0;
  }
  /**
   * Marks the beginning of the next change in the set of differences.
   */
  MarkNextChange() {
    (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.m_changes.push(new lc(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount)), this.m_originalCount = 0, this.m_modifiedCount = 0, this.m_originalStart = 1073741824, this.m_modifiedStart = 1073741824;
  }
  /**
   * Adds the original element at the given position to the elements
   * affected by the current change. The modified index gives context
   * to the change position with respect to the original sequence.
   * @param originalIndex The index of the original element to add.
   * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
   */
  AddOriginalElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_originalCount++;
  }
  /**
   * Adds the modified element at the given position to the elements
   * affected by the current change. The original index gives context
   * to the change position with respect to the modified sequence.
   * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
   * @param modifiedIndex The index of the modified element to add.
   */
  AddModifiedElement(e, t) {
    this.m_originalStart = Math.min(this.m_originalStart, e), this.m_modifiedStart = Math.min(this.m_modifiedStart, t), this.m_modifiedCount++;
  }
  /**
   * Retrieves all of the changes marked by the class.
   */
  getChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes;
  }
  /**
   * Retrieves all of the changes marked by the class in the reverse order
   */
  getReverseChanges() {
    return (this.m_originalCount > 0 || this.m_modifiedCount > 0) && this.MarkNextChange(), this.m_changes.reverse(), this.m_changes;
  }
}
class ml {
  /**
   * Constructs the DiffFinder
   */
  constructor(e, t, i = null) {
    this.ContinueProcessingPredicate = i, this._originalSequence = e, this._modifiedSequence = t;
    const [n, o, r] = ml._getElements(e), [a, l, c] = ml._getElements(t);
    this._hasStrings = r && c, this._originalStringElements = n, this._originalElementsOrHash = o, this._modifiedStringElements = a, this._modifiedElementsOrHash = l, this.m_forwardHistory = [], this.m_reverseHistory = [];
  }
  static _isStringArray(e) {
    return e.length > 0 && typeof e[0] == "string";
  }
  static _getElements(e) {
    const t = e.getElements();
    if (ml._isStringArray(t)) {
      const i = new Int32Array(t.length);
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = jM(t[n], 0);
      return [t, i, !0];
    }
    return t instanceof Int32Array ? [[], t, !1] : [[], new Int32Array(t), !1];
  }
  ElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ElementsAreStrictEqual(e, t) {
    if (!this.ElementsAreEqual(e, t))
      return !1;
    const i = ml._getStrictElement(this._originalSequence, e), n = ml._getStrictElement(this._modifiedSequence, t);
    return i === n;
  }
  static _getStrictElement(e, t) {
    return typeof e.getStrictElement == "function" ? e.getStrictElement(t) : null;
  }
  OriginalElementsAreEqual(e, t) {
    return this._originalElementsOrHash[e] !== this._originalElementsOrHash[t] ? !1 : this._hasStrings ? this._originalStringElements[e] === this._originalStringElements[t] : !0;
  }
  ModifiedElementsAreEqual(e, t) {
    return this._modifiedElementsOrHash[e] !== this._modifiedElementsOrHash[t] ? !1 : this._hasStrings ? this._modifiedStringElements[e] === this._modifiedStringElements[t] : !0;
  }
  ComputeDiff(e) {
    return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, e);
  }
  /**
   * Computes the differences between the original and modified input
   * sequences on the bounded range.
   * @returns An array of the differences between the two input sequences.
   */
  _ComputeDiff(e, t, i, n, o) {
    const r = [!1];
    let a = this.ComputeDiffRecursive(e, t, i, n, r);
    return o && (a = this.PrettifyChanges(a)), {
      quitEarly: r[0],
      changes: a
    };
  }
  /**
   * Private helper method which computes the differences on the bounded range
   * recursively.
   * @returns An array of the differences between the two input sequences.
   */
  ComputeDiffRecursive(e, t, i, n, o) {
    for (o[0] = !1; e <= t && i <= n && this.ElementsAreEqual(e, i); )
      e++, i++;
    for (; t >= e && n >= i && this.ElementsAreEqual(t, n); )
      t--, n--;
    if (e > t || i > n) {
      let h;
      return i <= n ? (og.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), h = [
        new lc(e, 0, i, n - i + 1)
      ]) : e <= t ? (og.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), h = [
        new lc(e, t - e + 1, i, 0)
      ]) : (og.Assert(e === t + 1, "originalStart should only be one more than originalEnd"), og.Assert(i === n + 1, "modifiedStart should only be one more than modifiedEnd"), h = []), h;
    }
    const r = [0], a = [0], l = this.ComputeRecursionPoint(e, t, i, n, r, a, o), c = r[0], d = a[0];
    if (l !== null)
      return l;
    if (!o[0]) {
      const h = this.ComputeDiffRecursive(e, c, i, d, o);
      let u = [];
      return o[0] ? u = [
        new lc(c + 1, t - (c + 1) + 1, d + 1, n - (d + 1) + 1)
      ] : u = this.ComputeDiffRecursive(c + 1, t, d + 1, n, o), this.ConcatenateChanges(h, u);
    }
    return [
      new lc(e, t - e + 1, i, n - i + 1)
    ];
  }
  WALKTRACE(e, t, i, n, o, r, a, l, c, d, h, u, g, m, p, A, _, b) {
    let C = null, w = null, S = new FR(), x = t, y = i, D = g[0] - A[0] - n, I = -1073741824, Q = this.m_forwardHistory.length - 1;
    do {
      const P = D + e;
      P === x || P < y && c[P - 1] < c[P + 1] ? (h = c[P + 1], m = h - D - n, h < I && S.MarkNextChange(), I = h, S.AddModifiedElement(h + 1, m), D = P + 1 - e) : (h = c[P - 1] + 1, m = h - D - n, h < I && S.MarkNextChange(), I = h - 1, S.AddOriginalElement(h, m + 1), D = P - 1 - e), Q >= 0 && (c = this.m_forwardHistory[Q], e = c[0], x = 1, y = c.length - 1);
    } while (--Q >= -1);
    if (C = S.getReverseChanges(), b[0]) {
      let P = g[0] + 1, W = A[0] + 1;
      if (C !== null && C.length > 0) {
        const j = C[C.length - 1];
        P = Math.max(P, j.getOriginalEnd()), W = Math.max(W, j.getModifiedEnd());
      }
      w = [
        new lc(P, u - P + 1, W, p - W + 1)
      ];
    } else {
      S = new FR(), x = r, y = a, D = g[0] - A[0] - l, I = 1073741824, Q = _ ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
      do {
        const P = D + o;
        P === x || P < y && d[P - 1] >= d[P + 1] ? (h = d[P + 1] - 1, m = h - D - l, h > I && S.MarkNextChange(), I = h + 1, S.AddOriginalElement(h + 1, m + 1), D = P + 1 - o) : (h = d[P - 1], m = h - D - l, h > I && S.MarkNextChange(), I = h, S.AddModifiedElement(h + 1, m + 1), D = P - 1 - o), Q >= 0 && (d = this.m_reverseHistory[Q], o = d[0], x = 1, y = d.length - 1);
      } while (--Q >= -1);
      w = S.getChanges();
    }
    return this.ConcatenateChanges(C, w);
  }
  /**
   * Given the range to compute the diff on, this method finds the point:
   * (midOriginal, midModified)
   * that exists in the middle of the LCS of the two sequences and
   * is the point at which the LCS problem may be broken down recursively.
   * This method will try to keep the LCS trace in memory. If the LCS recursion
   * point is calculated and the full trace is available in memory, then this method
   * will return the change list.
   * @param originalStart The start bound of the original sequence range
   * @param originalEnd The end bound of the original sequence range
   * @param modifiedStart The start bound of the modified sequence range
   * @param modifiedEnd The end bound of the modified sequence range
   * @param midOriginal The middle point of the original sequence range
   * @param midModified The middle point of the modified sequence range
   * @returns The diff changes, if available, otherwise null
   */
  ComputeRecursionPoint(e, t, i, n, o, r, a) {
    let l = 0, c = 0, d = 0, h = 0, u = 0, g = 0;
    e--, i--, o[0] = 0, r[0] = 0, this.m_forwardHistory = [], this.m_reverseHistory = [];
    const m = t - e + (n - i), p = m + 1, A = new Int32Array(p), _ = new Int32Array(p), b = n - i, C = t - e, w = e - i, S = t - n, y = (C - b) % 2 === 0;
    A[b] = e, _[C] = t, a[0] = !1;
    for (let D = 1; D <= m / 2 + 1; D++) {
      let I = 0, Q = 0;
      d = this.ClipDiagonalBound(b - D, D, b, p), h = this.ClipDiagonalBound(b + D, D, b, p);
      for (let W = d; W <= h; W += 2) {
        W === d || W < h && A[W - 1] < A[W + 1] ? l = A[W + 1] : l = A[W - 1] + 1, c = l - (W - b) - w;
        const j = l;
        for (; l < t && c < n && this.ElementsAreEqual(l + 1, c + 1); )
          l++, c++;
        if (A[W] = l, l + c > I + Q && (I = l, Q = c), !y && Math.abs(W - C) <= D - 1 && l >= _[W])
          return o[0] = l, r[0] = c, j <= _[W] && D <= 1448 ? this.WALKTRACE(b, d, h, w, C, u, g, S, A, _, l, t, o, c, n, r, y, a) : null;
      }
      const P = (I - e + (Q - i) - D) / 2;
      if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(I, P))
        return a[0] = !0, o[0] = I, r[0] = Q, P > 0 && D <= 1448 ? this.WALKTRACE(b, d, h, w, C, u, g, S, A, _, l, t, o, c, n, r, y, a) : (e++, i++, [
          new lc(e, t - e + 1, i, n - i + 1)
        ]);
      u = this.ClipDiagonalBound(C - D, D, C, p), g = this.ClipDiagonalBound(C + D, D, C, p);
      for (let W = u; W <= g; W += 2) {
        W === u || W < g && _[W - 1] >= _[W + 1] ? l = _[W + 1] - 1 : l = _[W - 1], c = l - (W - C) - S;
        const j = l;
        for (; l > e && c > i && this.ElementsAreEqual(l, c); )
          l--, c--;
        if (_[W] = l, y && Math.abs(W - b) <= D && l <= A[W])
          return o[0] = l, r[0] = c, j >= A[W] && D <= 1448 ? this.WALKTRACE(b, d, h, w, C, u, g, S, A, _, l, t, o, c, n, r, y, a) : null;
      }
      if (D <= 1447) {
        let W = new Int32Array(h - d + 2);
        W[0] = b - d + 1, rg.Copy2(A, d, W, 1, h - d + 1), this.m_forwardHistory.push(W), W = new Int32Array(g - u + 2), W[0] = C - u + 1, rg.Copy2(_, u, W, 1, g - u + 1), this.m_reverseHistory.push(W);
      }
    }
    return this.WALKTRACE(b, d, h, w, C, u, g, S, A, _, l, t, o, c, n, r, y, a);
  }
  /**
   * Shifts the given changes to provide a more intuitive diff.
   * While the first element in a diff matches the first element after the diff,
   * we shift the diff down.
   *
   * @param changes The list of changes to shift
   * @returns The shifted changes
   */
  PrettifyChanges(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t], n = t < e.length - 1 ? e[t + 1].originalStart : this._originalElementsOrHash.length, o = t < e.length - 1 ? e[t + 1].modifiedStart : this._modifiedElementsOrHash.length, r = i.originalLength > 0, a = i.modifiedLength > 0;
      for (; i.originalStart + i.originalLength < n && i.modifiedStart + i.modifiedLength < o && (!r || this.OriginalElementsAreEqual(i.originalStart, i.originalStart + i.originalLength)) && (!a || this.ModifiedElementsAreEqual(i.modifiedStart, i.modifiedStart + i.modifiedLength)); ) {
        const c = this.ElementsAreStrictEqual(i.originalStart, i.modifiedStart);
        if (this.ElementsAreStrictEqual(i.originalStart + i.originalLength, i.modifiedStart + i.modifiedLength) && !c)
          break;
        i.originalStart++, i.modifiedStart++;
      }
      const l = [null];
      if (t < e.length - 1 && this.ChangesOverlap(e[t], e[t + 1], l)) {
        e[t] = l[0], e.splice(t + 1, 1), t--;
        continue;
      }
    }
    for (let t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      let n = 0, o = 0;
      if (t > 0) {
        const h = e[t - 1];
        n = h.originalStart + h.originalLength, o = h.modifiedStart + h.modifiedLength;
      }
      const r = i.originalLength > 0, a = i.modifiedLength > 0;
      let l = 0, c = this._boundaryScore(i.originalStart, i.originalLength, i.modifiedStart, i.modifiedLength);
      for (let h = 1; ; h++) {
        const u = i.originalStart - h, g = i.modifiedStart - h;
        if (u < n || g < o || r && !this.OriginalElementsAreEqual(u, u + i.originalLength) || a && !this.ModifiedElementsAreEqual(g, g + i.modifiedLength))
          break;
        const p = (u === n && g === o ? 5 : 0) + this._boundaryScore(u, i.originalLength, g, i.modifiedLength);
        p > c && (c = p, l = h);
      }
      i.originalStart -= l, i.modifiedStart -= l;
      const d = [null];
      if (t > 0 && this.ChangesOverlap(e[t - 1], e[t], d)) {
        e[t - 1] = d[0], e.splice(t, 1), t++;
        continue;
      }
    }
    if (this._hasStrings)
      for (let t = 1, i = e.length; t < i; t++) {
        const n = e[t - 1], o = e[t], r = o.originalStart - n.originalStart - n.originalLength, a = n.originalStart, l = o.originalStart + o.originalLength, c = l - a, d = n.modifiedStart, h = o.modifiedStart + o.modifiedLength, u = h - d;
        if (r < 5 && c < 20 && u < 20) {
          const g = this._findBetterContiguousSequence(a, c, d, u, r);
          if (g) {
            const [m, p] = g;
            (m !== n.originalStart + n.originalLength || p !== n.modifiedStart + n.modifiedLength) && (n.originalLength = m - n.originalStart, n.modifiedLength = p - n.modifiedStart, o.originalStart = m + r, o.modifiedStart = p + r, o.originalLength = l - o.originalStart, o.modifiedLength = h - o.modifiedStart);
          }
        }
      }
    return e;
  }
  _findBetterContiguousSequence(e, t, i, n, o) {
    if (t < o || n < o)
      return null;
    const r = e + t - o + 1, a = i + n - o + 1;
    let l = 0, c = 0, d = 0;
    for (let h = e; h < r; h++)
      for (let u = i; u < a; u++) {
        const g = this._contiguousSequenceScore(h, u, o);
        g > 0 && g > l && (l = g, c = h, d = u);
      }
    return l > 0 ? [c, d] : null;
  }
  _contiguousSequenceScore(e, t, i) {
    let n = 0;
    for (let o = 0; o < i; o++) {
      if (!this.ElementsAreEqual(e + o, t + o))
        return 0;
      n += this._originalStringElements[e + o].length;
    }
    return n;
  }
  _OriginalIsBoundary(e) {
    return e <= 0 || e >= this._originalElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._originalStringElements[e]);
  }
  _OriginalRegionIsBoundary(e, t) {
    if (this._OriginalIsBoundary(e) || this._OriginalIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._OriginalIsBoundary(i - 1) || this._OriginalIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _ModifiedIsBoundary(e) {
    return e <= 0 || e >= this._modifiedElementsOrHash.length - 1 ? !0 : this._hasStrings && /^\s*$/.test(this._modifiedStringElements[e]);
  }
  _ModifiedRegionIsBoundary(e, t) {
    if (this._ModifiedIsBoundary(e) || this._ModifiedIsBoundary(e - 1))
      return !0;
    if (t > 0) {
      const i = e + t;
      if (this._ModifiedIsBoundary(i - 1) || this._ModifiedIsBoundary(i))
        return !0;
    }
    return !1;
  }
  _boundaryScore(e, t, i, n) {
    const o = this._OriginalRegionIsBoundary(e, t) ? 1 : 0, r = this._ModifiedRegionIsBoundary(i, n) ? 1 : 0;
    return o + r;
  }
  /**
   * Concatenates the two input DiffChange lists and returns the resulting
   * list.
   * @param The left changes
   * @param The right changes
   * @returns The concatenated list
   */
  ConcatenateChanges(e, t) {
    const i = [];
    if (e.length === 0 || t.length === 0)
      return t.length > 0 ? t : e;
    if (this.ChangesOverlap(e[e.length - 1], t[0], i)) {
      const n = new Array(e.length + t.length - 1);
      return rg.Copy(e, 0, n, 0, e.length - 1), n[e.length - 1] = i[0], rg.Copy(t, 1, n, e.length, t.length - 1), n;
    } else {
      const n = new Array(e.length + t.length);
      return rg.Copy(e, 0, n, 0, e.length), rg.Copy(t, 0, n, e.length, t.length), n;
    }
  }
  /**
   * Returns true if the two changes overlap and can be merged into a single
   * change
   * @param left The left change
   * @param right The right change
   * @param mergedChange The merged change if the two overlap, null otherwise
   * @returns True if the two changes overlap
   */
  ChangesOverlap(e, t, i) {
    if (og.Assert(e.originalStart <= t.originalStart, "Left change is not less than or equal to right change"), og.Assert(e.modifiedStart <= t.modifiedStart, "Left change is not less than or equal to right change"), e.originalStart + e.originalLength >= t.originalStart || e.modifiedStart + e.modifiedLength >= t.modifiedStart) {
      const n = e.originalStart;
      let o = e.originalLength;
      const r = e.modifiedStart;
      let a = e.modifiedLength;
      return e.originalStart + e.originalLength >= t.originalStart && (o = t.originalStart + t.originalLength - e.originalStart), e.modifiedStart + e.modifiedLength >= t.modifiedStart && (a = t.modifiedStart + t.modifiedLength - e.modifiedStart), i[0] = new lc(n, o, r, a), !0;
    } else
      return i[0] = null, !1;
  }
  /**
   * Helper method used to clip a diagonal index to the range of valid
   * diagonals. This also decides whether or not the diagonal index,
   * if it exceeds the boundary, should be clipped to the boundary or clipped
   * one inside the boundary depending on the Even/Odd status of the boundary
   * and numDifferences.
   * @param diagonal The index of the diagonal to clip.
   * @param numDifferences The current number of differences being iterated upon.
   * @param diagonalBaseIndex The base reference diagonal.
   * @param numDiagonals The total number of diagonals.
   * @returns The clipped diagonal index.
   */
  ClipDiagonalBound(e, t, i, n) {
    if (e >= 0 && e < n)
      return e;
    const o = i, r = n - i - 1, a = t % 2 === 0;
    if (e < 0) {
      const l = o % 2 === 0;
      return a === l ? 0 : 1;
    } else {
      const l = r % 2 === 0;
      return a === l ? n - 1 : n - 2;
    }
  }
}
function hC(s) {
  return s < 0 ? 0 : s > 255 ? 255 : s | 0;
}
function ag(s) {
  return s < 0 ? 0 : s > 4294967295 ? 4294967295 : s | 0;
}
class wm {
  constructor(e) {
    const t = hC(e);
    this._defaultValue = t, this._asciiMap = wm._createAsciiMap(t), this._map = /* @__PURE__ */ new Map();
  }
  static _createAsciiMap(e) {
    const t = new Uint8Array(256);
    return t.fill(e), t;
  }
  set(e, t) {
    const i = hC(t);
    e >= 0 && e < 256 ? this._asciiMap[e] = i : this._map.set(e, i);
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : this._map.get(e) || this._defaultValue;
  }
  clear() {
    this._asciiMap.fill(this._defaultValue), this._map.clear();
  }
}
class tL {
  constructor() {
    this._actual = new wm(
      0
      /* Boolean.False */
    );
  }
  add(e) {
    this._actual.set(
      e,
      1
      /* Boolean.True */
    );
  }
  has(e) {
    return this._actual.get(e) === 1;
  }
  clear() {
    return this._actual.clear();
  }
}
class RQ {
  constructor(e, t, i) {
    const n = new Uint8Array(e * t);
    for (let o = 0, r = e * t; o < r; o++)
      n[o] = i;
    this._data = n, this.rows = e, this.cols = t;
  }
  get(e, t) {
    return this._data[e * this.cols + t];
  }
  set(e, t, i) {
    this._data[e * this.cols + t] = i;
  }
}
class FQ {
  constructor(e) {
    let t = 0, i = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      l > t && (t = l), a > i && (i = a), c > i && (i = c);
    }
    t++, i++;
    const n = new RQ(
      i,
      t,
      0
      /* State.Invalid */
    );
    for (let o = 0, r = e.length; o < r; o++) {
      const [a, l, c] = e[o];
      n.set(a, l, c);
    }
    this._states = n, this._maxCharCode = t;
  }
  nextState(e, t) {
    return t < 0 || t >= this._maxCharCode ? 0 : this._states.get(e, t);
  }
}
let my = null;
function OQ() {
  return my === null && (my = new FQ([
    [
      1,
      104,
      2
      /* State.H */
    ],
    [
      1,
      72,
      2
      /* State.H */
    ],
    [
      1,
      102,
      6
      /* State.F */
    ],
    [
      1,
      70,
      6
      /* State.F */
    ],
    [
      2,
      116,
      3
      /* State.HT */
    ],
    [
      2,
      84,
      3
      /* State.HT */
    ],
    [
      3,
      116,
      4
      /* State.HTT */
    ],
    [
      3,
      84,
      4
      /* State.HTT */
    ],
    [
      4,
      112,
      5
      /* State.HTTP */
    ],
    [
      4,
      80,
      5
      /* State.HTTP */
    ],
    [
      5,
      115,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      83,
      9
      /* State.BeforeColon */
    ],
    [
      5,
      58,
      10
      /* State.AfterColon */
    ],
    [
      6,
      105,
      7
      /* State.FI */
    ],
    [
      6,
      73,
      7
      /* State.FI */
    ],
    [
      7,
      108,
      8
      /* State.FIL */
    ],
    [
      7,
      76,
      8
      /* State.FIL */
    ],
    [
      8,
      101,
      9
      /* State.BeforeColon */
    ],
    [
      8,
      69,
      9
      /* State.BeforeColon */
    ],
    [
      9,
      58,
      10
      /* State.AfterColon */
    ],
    [
      10,
      47,
      11
      /* State.AlmostThere */
    ],
    [
      11,
      47,
      12
      /* State.End */
    ]
  ])), my;
}
let Ym = null;
function PQ() {
  if (Ym === null) {
    Ym = new wm(
      0
      /* CharacterClass.None */
    );
    const s = ` 	<>'"、。｡､，．：；‘〈「『〔（［｛｢｣｝］）〕』」〉’｀～…`;
    for (let t = 0; t < s.length; t++)
      Ym.set(
        s.charCodeAt(t),
        1
        /* CharacterClass.ForceTermination */
      );
    const e = ".,;:";
    for (let t = 0; t < e.length; t++)
      Ym.set(
        e.charCodeAt(t),
        2
        /* CharacterClass.CannotEndIn */
      );
  }
  return Ym;
}
class uC {
  static _createLink(e, t, i, n, o) {
    let r = o - 1;
    do {
      const a = t.charCodeAt(r);
      if (e.get(a) !== 2)
        break;
      r--;
    } while (r > n);
    if (n > 0) {
      const a = t.charCodeAt(n - 1), l = t.charCodeAt(r);
      (a === 40 && l === 41 || a === 91 && l === 93 || a === 123 && l === 125) && r--;
    }
    return {
      range: {
        startLineNumber: i,
        startColumn: n + 1,
        endLineNumber: i,
        endColumn: r + 2
      },
      url: t.substring(n, r + 1)
    };
  }
  static computeLinks(e, t = OQ()) {
    const i = PQ(), n = [];
    for (let o = 1, r = e.getLineCount(); o <= r; o++) {
      const a = e.getLineContent(o), l = a.length;
      let c = 0, d = 0, h = 0, u = 1, g = !1, m = !1, p = !1, A = !1;
      for (; c < l; ) {
        let _ = !1;
        const b = a.charCodeAt(c);
        if (u === 13) {
          let C;
          switch (b) {
            case 40:
              g = !0, C = 0;
              break;
            case 41:
              C = g ? 0 : 1;
              break;
            case 91:
              p = !0, m = !0, C = 0;
              break;
            case 93:
              p = !1, C = m ? 0 : 1;
              break;
            case 123:
              A = !0, C = 0;
              break;
            case 125:
              C = A ? 0 : 1;
              break;
            case 39:
            case 34:
            case 96:
              h === b ? C = 1 : h === 39 || h === 34 || h === 96 ? C = 0 : C = 1;
              break;
            case 42:
              C = h === 42 ? 1 : 0;
              break;
            case 124:
              C = h === 124 ? 1 : 0;
              break;
            case 32:
              C = p ? 0 : 1;
              break;
            default:
              C = i.get(b);
          }
          C === 1 && (n.push(uC._createLink(i, a, o, d, c)), _ = !0);
        } else if (u === 12) {
          let C;
          b === 91 ? (m = !0, C = 0) : C = i.get(b), C === 1 ? _ = !0 : u = 13;
        } else
          u = t.nextState(u, b), u === 0 && (_ = !0);
        _ && (u = 1, g = !1, m = !1, A = !1, d = c + 1, h = b), c++;
      }
      u === 13 && n.push(uC._createLink(i, a, o, d, l));
    }
    return n;
  }
}
function HQ(s) {
  return !s || typeof s.getLineCount != "function" || typeof s.getLineContent != "function" ? [] : uC.computeLinks(s);
}
const w1 = class w1 {
  constructor() {
    this._defaultValueSet = [
      ["true", "false"],
      ["True", "False"],
      ["Private", "Public", "Friend", "ReadOnly", "Partial", "Protected", "WriteOnly"],
      ["public", "protected", "private"]
    ];
  }
  navigateValueSet(e, t, i, n, o) {
    if (e && t) {
      const r = this.doNavigateValueSet(t, o);
      if (r)
        return {
          range: e,
          value: r
        };
    }
    if (i && n) {
      const r = this.doNavigateValueSet(n, o);
      if (r)
        return {
          range: i,
          value: r
        };
    }
    return null;
  }
  doNavigateValueSet(e, t) {
    const i = this.numberReplace(e, t);
    return i !== null ? i : this.textReplace(e, t);
  }
  numberReplace(e, t) {
    const i = Math.pow(10, e.length - (e.lastIndexOf(".") + 1));
    let n = Number(e);
    const o = parseFloat(e);
    return !isNaN(n) && !isNaN(o) && n === o ? n === 0 && !t ? null : (n = Math.floor(n * i), n += t ? i : -i, String(n / i)) : null;
  }
  textReplace(e, t) {
    return this.valueSetsReplace(this._defaultValueSet, e, t);
  }
  valueSetsReplace(e, t, i) {
    let n = null;
    for (let o = 0, r = e.length; n === null && o < r; o++)
      n = this.valueSetReplace(e[o], t, i);
    return n;
  }
  valueSetReplace(e, t, i) {
    let n = e.indexOf(t);
    return n >= 0 ? (n += i ? 1 : -1, n < 0 ? n = e.length - 1 : n %= e.length, e[n]) : null;
  }
};
w1.INSTANCE = new w1();
let iL = w1;
const dA = class dA {
  static getChannel(e) {
    return e.getChannel(dA.CHANNEL_NAME);
  }
  static setChannel(e, t) {
    e.setChannel(dA.CHANNEL_NAME, t);
  }
};
dA.CHANNEL_NAME = "editorWorkerHost";
let nL = dA;
var OR, PR;
class WQ {
  constructor(e, t) {
    this.uri = e, this.value = t;
  }
}
function VQ(s) {
  return Array.isArray(s);
}
const gh = class gh {
  constructor(e, t) {
    if (this[OR] = "ResourceMap", e instanceof gh)
      this.map = new Map(e.map), this.toKey = t ?? gh.defaultToKey;
    else if (VQ(e)) {
      this.map = /* @__PURE__ */ new Map(), this.toKey = t ?? gh.defaultToKey;
      for (const [i, n] of e)
        this.set(i, n);
    } else
      this.map = /* @__PURE__ */ new Map(), this.toKey = e ?? gh.defaultToKey;
  }
  set(e, t) {
    return this.map.set(this.toKey(e), new WQ(e, t)), this;
  }
  get(e) {
    return this.map.get(this.toKey(e))?.value;
  }
  has(e) {
    return this.map.has(this.toKey(e));
  }
  get size() {
    return this.map.size;
  }
  clear() {
    this.map.clear();
  }
  delete(e) {
    return this.map.delete(this.toKey(e));
  }
  forEach(e, t) {
    typeof t < "u" && (e = e.bind(t));
    for (const [i, n] of this.map)
      e(n.value, n.uri, this);
  }
  *values() {
    for (const e of this.map.values())
      yield e.value;
  }
  *keys() {
    for (const e of this.map.values())
      yield e.uri;
  }
  *entries() {
    for (const e of this.map.values())
      yield [e.uri, e.value];
  }
  *[(OR = Symbol.toStringTag, Symbol.iterator)]() {
    for (const [, e] of this.map)
      yield [e.uri, e.value];
  }
};
gh.defaultToKey = (e) => e.toString();
let ws = gh;
class zQ {
  constructor() {
    this[PR] = "LinkedMap", this._map = /* @__PURE__ */ new Map(), this._head = void 0, this._tail = void 0, this._size = 0, this._state = 0;
  }
  clear() {
    this._map.clear(), this._head = void 0, this._tail = void 0, this._size = 0, this._state++;
  }
  isEmpty() {
    return !this._head && !this._tail;
  }
  get size() {
    return this._size;
  }
  get first() {
    return this._head?.value;
  }
  get last() {
    return this._tail?.value;
  }
  has(e) {
    return this._map.has(e);
  }
  get(e, t = 0) {
    const i = this._map.get(e);
    if (i)
      return t !== 0 && this.touch(i, t), i.value;
  }
  set(e, t, i = 0) {
    let n = this._map.get(e);
    if (n)
      n.value = t, i !== 0 && this.touch(n, i);
    else {
      switch (n = { key: e, value: t, next: void 0, previous: void 0 }, i) {
        case 0:
          this.addItemLast(n);
          break;
        case 1:
          this.addItemFirst(n);
          break;
        case 2:
          this.addItemLast(n);
          break;
        default:
          this.addItemLast(n);
          break;
      }
      this._map.set(e, n), this._size++;
    }
    return this;
  }
  delete(e) {
    return !!this.remove(e);
  }
  remove(e) {
    const t = this._map.get(e);
    if (t)
      return this._map.delete(e), this.removeItem(t), this._size--, t.value;
  }
  shift() {
    if (!this._head && !this._tail)
      return;
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    const e = this._head;
    return this._map.delete(e.key), this.removeItem(e), this._size--, e.value;
  }
  forEach(e, t) {
    const i = this._state;
    let n = this._head;
    for (; n; ) {
      if (t ? e.bind(t)(n.value, n.key, this) : e(n.value, n.key, this), this._state !== i)
        throw new Error("LinkedMap got modified during iteration.");
      n = n.next;
    }
  }
  keys() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.key, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  values() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: i.value, done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  entries() {
    const e = this, t = this._state;
    let i = this._head;
    const n = {
      [Symbol.iterator]() {
        return n;
      },
      next() {
        if (e._state !== t)
          throw new Error("LinkedMap got modified during iteration.");
        if (i) {
          const o = { value: [i.key, i.value], done: !1 };
          return i = i.next, o;
        } else
          return { value: void 0, done: !0 };
      }
    };
    return n;
  }
  [(PR = Symbol.toStringTag, Symbol.iterator)]() {
    return this.entries();
  }
  trimOld(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._head, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.next, i--;
    this._head = t, this._size = i, t && (t.previous = void 0), this._state++;
  }
  trimNew(e) {
    if (e >= this.size)
      return;
    if (e === 0) {
      this.clear();
      return;
    }
    let t = this._tail, i = this.size;
    for (; t && i > e; )
      this._map.delete(t.key), t = t.previous, i--;
    this._tail = t, this._size = i, t && (t.next = void 0), this._state++;
  }
  addItemFirst(e) {
    if (!this._head && !this._tail)
      this._tail = e;
    else if (this._head)
      e.next = this._head, this._head.previous = e;
    else
      throw new Error("Invalid list");
    this._head = e, this._state++;
  }
  addItemLast(e) {
    if (!this._head && !this._tail)
      this._head = e;
    else if (this._tail)
      e.previous = this._tail, this._tail.next = e;
    else
      throw new Error("Invalid list");
    this._tail = e, this._state++;
  }
  removeItem(e) {
    if (e === this._head && e === this._tail)
      this._head = void 0, this._tail = void 0;
    else if (e === this._head) {
      if (!e.next)
        throw new Error("Invalid list");
      e.next.previous = void 0, this._head = e.next;
    } else if (e === this._tail) {
      if (!e.previous)
        throw new Error("Invalid list");
      e.previous.next = void 0, this._tail = e.previous;
    } else {
      const t = e.next, i = e.previous;
      if (!t || !i)
        throw new Error("Invalid list");
      t.previous = i, i.next = t;
    }
    e.next = void 0, e.previous = void 0, this._state++;
  }
  touch(e, t) {
    if (!this._head || !this._tail)
      throw new Error("Invalid list");
    if (!(t !== 1 && t !== 2)) {
      if (t === 1) {
        if (e === this._head)
          return;
        const i = e.next, n = e.previous;
        e === this._tail ? (n.next = void 0, this._tail = n) : (i.previous = n, n.next = i), e.previous = void 0, e.next = this._head, this._head.previous = e, this._head = e, this._state++;
      } else if (t === 2) {
        if (e === this._tail)
          return;
        const i = e.next, n = e.previous;
        e === this._head ? (i.previous = void 0, this._head = i) : (i.previous = n, n.next = i), e.next = void 0, e.previous = this._tail, this._tail.next = e, this._tail = e, this._state++;
      }
    }
  }
  toJSON() {
    const e = [];
    return this.forEach((t, i) => {
      e.push([i, t]);
    }), e;
  }
  fromJSON(e) {
    this.clear();
    for (const [t, i] of e)
      this.set(t, i);
  }
}
class UQ extends zQ {
  constructor(e, t = 1) {
    super(), this._limit = e, this._ratio = Math.min(Math.max(0, t), 1);
  }
  get limit() {
    return this._limit;
  }
  set limit(e) {
    this._limit = e, this.checkTrim();
  }
  get(e, t = 2) {
    return super.get(e, t);
  }
  peek(e) {
    return super.get(
      e,
      0
      /* Touch.None */
    );
  }
  set(e, t) {
    return super.set(
      e,
      t,
      2
      /* Touch.AsNew */
    ), this;
  }
  checkTrim() {
    this.size > this._limit && this.trim(Math.round(this._limit * this._ratio));
  }
}
class Vu extends UQ {
  constructor(e, t = 1) {
    super(e, t);
  }
  trim(e) {
    this.trimOld(e);
  }
  set(e, t) {
    return super.set(e, t), this.checkTrim(), this;
  }
}
class QQ {
  constructor(e) {
    if (this._m1 = /* @__PURE__ */ new Map(), this._m2 = /* @__PURE__ */ new Map(), e)
      for (const [t, i] of e)
        this.set(t, i);
  }
  clear() {
    this._m1.clear(), this._m2.clear();
  }
  set(e, t) {
    this._m1.set(e, t), this._m2.set(t, e);
  }
  get(e) {
    return this._m1.get(e);
  }
  getKey(e) {
    return this._m2.get(e);
  }
  delete(e) {
    const t = this._m1.get(e);
    return t === void 0 ? !1 : (this._m1.delete(e), this._m2.delete(t), !0);
  }
  keys() {
    return this._m1.keys();
  }
  values() {
    return this._m1.values();
  }
}
class _5 {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(e, t) {
    let i = this.map.get(e);
    i || (i = /* @__PURE__ */ new Set(), this.map.set(e, i)), i.add(t);
  }
  delete(e, t) {
    const i = this.map.get(e);
    i && (i.delete(t), i.size === 0 && this.map.delete(e));
  }
  forEach(e, t) {
    const i = this.map.get(e);
    i && i.forEach(t);
  }
  get(e) {
    const t = this.map.get(e);
    return t || /* @__PURE__ */ new Set();
  }
}
class GQ extends wm {
  constructor(e, t) {
    super(
      0
      /* WordCharacterClass.Regular */
    ), this._segmenter = null, this._cachedLine = null, this._cachedSegments = [], this.intlSegmenterLocales = t, this.intlSegmenterLocales.length > 0 ? this._segmenter = new Intl.Segmenter(this.intlSegmenterLocales, { granularity: "word" }) : this._segmenter = null;
    for (let i = 0, n = e.length; i < n; i++)
      this.set(
        e.charCodeAt(i),
        2
        /* WordCharacterClass.WordSeparator */
      );
    this.set(
      32,
      1
      /* WordCharacterClass.Whitespace */
    ), this.set(
      9,
      1
      /* WordCharacterClass.Whitespace */
    );
  }
  findPrevIntlWordBeforeOrAtOffset(e, t) {
    let i = null;
    for (const n of this._getIntlSegmenterWordsOnLine(e)) {
      if (n.index > t)
        break;
      i = n;
    }
    return i;
  }
  findNextIntlWordAtOrAfterOffset(e, t) {
    for (const i of this._getIntlSegmenterWordsOnLine(e))
      if (!(i.index < t))
        return i;
    return null;
  }
  _getIntlSegmenterWordsOnLine(e) {
    return this._segmenter ? this._cachedLine === e ? this._cachedSegments : (this._cachedLine = e, this._cachedSegments = this._filterWordSegments(this._segmenter.segment(e)), this._cachedSegments) : [];
  }
  _filterWordSegments(e) {
    const t = [];
    for (const i of e)
      this._isWordLike(i) && t.push(i);
    return t;
  }
  _isWordLike(e) {
    return !!e.isWordLike;
  }
}
const HR = new Vu(10);
function Eo(s, e) {
  const t = `${s}/${e.join(",")}`;
  let i = HR.get(t);
  return i || (i = new GQ(s, e), HR.set(t, i)), i;
}
var Bl;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 4] = "Right", s[s.Full = 7] = "Full";
})(Bl || (Bl = {}));
var qo;
(function(s) {
  s[s.Left = 1] = "Left", s[s.Center = 2] = "Center", s[s.Right = 3] = "Right";
})(qo || (qo = {}));
var Aa;
(function(s) {
  s[s.Both = 0] = "Both", s[s.Right = 1] = "Right", s[s.Left = 2] = "Left", s[s.None = 3] = "None";
})(Aa || (Aa = {}));
class _w {
  get originalIndentSize() {
    return this._indentSizeIsTabSize ? "tabSize" : this.indentSize;
  }
  /**
   * @internal
   */
  constructor(e) {
    this._textModelResolvedOptionsBrand = void 0, this.tabSize = Math.max(1, e.tabSize | 0), e.indentSize === "tabSize" ? (this.indentSize = this.tabSize, this._indentSizeIsTabSize = !0) : (this.indentSize = Math.max(1, e.indentSize | 0), this._indentSizeIsTabSize = !1), this.insertSpaces = !!e.insertSpaces, this.defaultEOL = e.defaultEOL | 0, this.trimAutoWhitespace = !!e.trimAutoWhitespace, this.bracketPairColorizationOptions = e.bracketPairColorizationOptions;
  }
  /**
   * @internal
   */
  equals(e) {
    return this.tabSize === e.tabSize && this._indentSizeIsTabSize === e._indentSizeIsTabSize && this.indentSize === e.indentSize && this.insertSpaces === e.insertSpaces && this.defaultEOL === e.defaultEOL && this.trimAutoWhitespace === e.trimAutoWhitespace && bs(this.bracketPairColorizationOptions, e.bracketPairColorizationOptions);
  }
  /**
   * @internal
   */
  createChangeEvent(e) {
    return {
      tabSize: this.tabSize !== e.tabSize,
      indentSize: this.indentSize !== e.indentSize,
      insertSpaces: this.insertSpaces !== e.insertSpaces,
      trimAutoWhitespace: this.trimAutoWhitespace !== e.trimAutoWhitespace
    };
  }
}
class RA {
  /**
   * @internal
   */
  constructor(e, t) {
    this._findMatchBrand = void 0, this.range = e, this.matches = t;
  }
}
function jQ(s) {
  return s && typeof s.read == "function";
}
class py {
  constructor(e, t, i, n, o, r) {
    this.identifier = e, this.range = t, this.text = i, this.forceMoveMarkers = n, this.isAutoWhitespaceEdit = o, this._isTracked = r;
  }
}
class YQ {
  constructor(e, t, i) {
    this.regex = e, this.wordSeparators = t, this.simpleSearch = i;
  }
}
class KQ {
  constructor(e, t, i) {
    this.reverseEdits = e, this.changes = t, this.trimAutoWhitespaceLineNumbers = i;
  }
}
function JQ(s) {
  return !s.isTooLargeForSyncing() && !s.isForSimpleWidget;
}
const qQ = 999;
class Qd {
  constructor(e, t, i, n) {
    this.searchString = e, this.isRegex = t, this.matchCase = i, this.wordSeparators = n;
  }
  parseSearchRequest() {
    if (this.searchString === "")
      return null;
    let e;
    this.isRegex ? e = $Q(this.searchString) : e = this.searchString.indexOf(`
`) >= 0;
    let t = null;
    try {
      t = _H(this.searchString, this.isRegex, {
        matchCase: this.matchCase,
        wholeWord: !1,
        multiline: e,
        global: !0,
        unicode: !0
      });
    } catch {
      return null;
    }
    if (!t)
      return null;
    let i = !this.isRegex && !e;
    return i && this.searchString.toLowerCase() !== this.searchString.toUpperCase() && (i = this.matchCase), new YQ(t, this.wordSeparators ? Eo(this.wordSeparators, []) : null, i ? this.searchString : null);
  }
}
function $Q(s) {
  if (!s || s.length === 0)
    return !1;
  for (let e = 0, t = s.length; e < t; e++) {
    const i = s.charCodeAt(e);
    if (i === 10)
      return !0;
    if (i === 92) {
      if (e++, e >= t)
        break;
      const n = s.charCodeAt(e);
      if (n === 110 || n === 114 || n === 87)
        return !0;
    }
  }
  return !1;
}
function $d(s, e, t) {
  if (!t)
    return new RA(s, null);
  const i = [];
  for (let n = 0, o = e.length; n < o; n++)
    i[n] = e[n];
  return new RA(s, i);
}
class WR {
  constructor(e) {
    const t = [];
    let i = 0;
    for (let n = 0, o = e.length; n < o; n++)
      e.charCodeAt(n) === 10 && (t[i++] = n);
    this._lineFeedsOffsets = t;
  }
  findLineFeedCountBeforeOffset(e) {
    const t = this._lineFeedsOffsets;
    let i = 0, n = t.length - 1;
    if (n === -1 || e <= t[0])
      return 0;
    for (; i < n; ) {
      const o = i + ((n - i) / 2 >> 0);
      t[o] >= e ? n = o - 1 : t[o + 1] >= e ? (i = o, n = o) : i = o + 1;
    }
    return i + 1;
  }
}
class mb {
  static findMatches(e, t, i, n, o) {
    const r = t.parseSearchRequest();
    return r ? r.regex.multiline ? this._doFindMatchesMultiline(e, i, new Bg(r.wordSeparators, r.regex), n, o) : this._doFindMatchesLineByLine(e, i, r, n, o) : [];
  }
  /**
   * Multiline search always executes on the lines concatenated with \n.
   * We must therefore compensate for the count of \n in case the model is CRLF
   */
  static _getMultilineMatchRange(e, t, i, n, o, r) {
    let a, l = 0;
    n ? (l = n.findLineFeedCountBeforeOffset(o), a = t + o + l) : a = t + o;
    let c;
    if (n) {
      const g = n.findLineFeedCountBeforeOffset(o + r.length) - l;
      c = a + r.length + g;
    } else
      c = a + r.length;
    const d = e.getPositionAt(a), h = e.getPositionAt(c);
    return new E(d.lineNumber, d.column, h.lineNumber, h.column);
  }
  static _doFindMatchesMultiline(e, t, i, n, o) {
    const r = e.getOffsetAt(t.getStartPosition()), a = e.getValueInRange(
      t,
      1
      /* EndOfLinePreference.LF */
    ), l = e.getEOL() === `\r
` ? new WR(a) : null, c = [];
    let d = 0, h;
    for (i.reset(0); h = i.next(a); )
      if (c[d++] = $d(this._getMultilineMatchRange(e, r, a, l, h.index, h[0]), h, n), d >= o)
        return c;
    return c;
  }
  static _doFindMatchesLineByLine(e, t, i, n, o) {
    const r = [];
    let a = 0;
    if (t.startLineNumber === t.endLineNumber) {
      const c = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1, t.endColumn - 1);
      return a = this._findMatchesInLine(i, c, t.startLineNumber, t.startColumn - 1, a, r, n, o), r;
    }
    const l = e.getLineContent(t.startLineNumber).substring(t.startColumn - 1);
    a = this._findMatchesInLine(i, l, t.startLineNumber, t.startColumn - 1, a, r, n, o);
    for (let c = t.startLineNumber + 1; c < t.endLineNumber && a < o; c++)
      a = this._findMatchesInLine(i, e.getLineContent(c), c, 0, a, r, n, o);
    if (a < o) {
      const c = e.getLineContent(t.endLineNumber).substring(0, t.endColumn - 1);
      a = this._findMatchesInLine(i, c, t.endLineNumber, 0, a, r, n, o);
    }
    return r;
  }
  static _findMatchesInLine(e, t, i, n, o, r, a, l) {
    const c = e.wordSeparators;
    if (!a && e.simpleSearch) {
      const u = e.simpleSearch, g = u.length, m = t.length;
      let p = -g;
      for (; (p = t.indexOf(u, p + g)) !== -1; )
        if ((!c || rN(c, t, m, p, g)) && (r[o++] = new RA(new E(i, p + 1 + n, i, p + 1 + g + n), null), o >= l))
          return o;
      return o;
    }
    const d = new Bg(e.wordSeparators, e.regex);
    let h;
    d.reset(0);
    do
      if (h = d.next(t), h && (r[o++] = $d(new E(i, h.index + 1 + n, i, h.index + 1 + h[0].length + n), h, a), o >= l))
        return o;
    while (h);
    return o;
  }
  static findNextMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new Bg(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindNextMatchMultiline(e, i, r, n) : this._doFindNextMatchLineByLine(e, i, r, n);
  }
  static _doFindNextMatchMultiline(e, t, i, n) {
    const o = new F(t.lineNumber, 1), r = e.getOffsetAt(o), a = e.getLineCount(), l = e.getValueInRange(
      new E(o.lineNumber, o.column, a, e.getLineMaxColumn(a)),
      1
      /* EndOfLinePreference.LF */
    ), c = e.getEOL() === `\r
` ? new WR(l) : null;
    i.reset(t.column - 1);
    const d = i.next(l);
    return d ? $d(this._getMultilineMatchRange(e, r, l, c, d.index, d[0]), d, n) : t.lineNumber !== 1 || t.column !== 1 ? this._doFindNextMatchMultiline(e, new F(1, 1), i, n) : null;
  }
  static _doFindNextMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r), l = this._findFirstMatchInLine(i, a, r, t.column, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const d = (r + c - 1) % o, h = e.getLineContent(d + 1), u = this._findFirstMatchInLine(i, h, d + 1, 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findFirstMatchInLine(e, t, i, n, o) {
    e.reset(n - 1);
    const r = e.next(t);
    return r ? $d(new E(i, r.index + 1, i, r.index + 1 + r[0].length), r, o) : null;
  }
  static findPreviousMatch(e, t, i, n) {
    const o = t.parseSearchRequest();
    if (!o)
      return null;
    const r = new Bg(o.wordSeparators, o.regex);
    return o.regex.multiline ? this._doFindPreviousMatchMultiline(e, i, r, n) : this._doFindPreviousMatchLineByLine(e, i, r, n);
  }
  static _doFindPreviousMatchMultiline(e, t, i, n) {
    const o = this._doFindMatchesMultiline(e, new E(1, 1, t.lineNumber, t.column), i, n, 10 * qQ);
    if (o.length > 0)
      return o[o.length - 1];
    const r = e.getLineCount();
    return t.lineNumber !== r || t.column !== e.getLineMaxColumn(r) ? this._doFindPreviousMatchMultiline(e, new F(r, e.getLineMaxColumn(r)), i, n) : null;
  }
  static _doFindPreviousMatchLineByLine(e, t, i, n) {
    const o = e.getLineCount(), r = t.lineNumber, a = e.getLineContent(r).substring(0, t.column - 1), l = this._findLastMatchInLine(i, a, r, n);
    if (l)
      return l;
    for (let c = 1; c <= o; c++) {
      const d = (o + r - c - 1) % o, h = e.getLineContent(d + 1), u = this._findLastMatchInLine(i, h, d + 1, n);
      if (u)
        return u;
    }
    return null;
  }
  static _findLastMatchInLine(e, t, i, n) {
    let o = null, r;
    for (e.reset(0); r = e.next(t); )
      o = $d(new E(i, r.index + 1, i, r.index + 1 + r[0].length), r, n);
    return o;
  }
}
function XQ(s, e, t, i, n) {
  if (i === 0)
    return !0;
  const o = e.charCodeAt(i - 1);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function ZQ(s, e, t, i, n) {
  if (i + n === t)
    return !0;
  const o = e.charCodeAt(i + n);
  if (s.get(o) !== 0 || o === 13 || o === 10)
    return !0;
  if (n > 0) {
    const r = e.charCodeAt(i + n - 1);
    if (s.get(r) !== 0)
      return !0;
  }
  return !1;
}
function rN(s, e, t, i, n) {
  return XQ(s, e, t, i, n) && ZQ(s, e, t, i, n);
}
class Bg {
  constructor(e, t) {
    this._wordSeparators = e, this._searchRegex = t, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  reset(e) {
    this._searchRegex.lastIndex = e, this._prevMatchStartIndex = -1, this._prevMatchLength = 0;
  }
  next(e) {
    const t = e.length;
    let i;
    do {
      if (this._prevMatchStartIndex + this._prevMatchLength === t || (i = this._searchRegex.exec(e), !i))
        return null;
      const n = i.index, o = i[0].length;
      if (n === this._prevMatchStartIndex && o === this._prevMatchLength) {
        if (o === 0) {
          tC(e, t, this._searchRegex.lastIndex) > 65535 ? this._searchRegex.lastIndex += 2 : this._searchRegex.lastIndex += 1;
          continue;
        }
        return null;
      }
      if (this._prevMatchStartIndex = n, this._prevMatchLength = o, !this._wordSeparators || rN(this._wordSeparators, e, t, n, o))
        return i;
    } while (i);
    return null;
  }
}
class eG {
  static computeUnicodeHighlights(e, t, i) {
    const n = i ? i.startLineNumber : 1, o = i ? i.endLineNumber : e.getLineCount(), r = new VR(t), a = r.getCandidateCodePoints();
    let l;
    a === "allNonBasicAscii" ? l = new RegExp("[^\\t\\n\\r\\x20-\\x7E]", "g") : l = new RegExp(`${tG(Array.from(a))}`, "g");
    const c = new Bg(null, l), d = [];
    let h = !1, u, g = 0, m = 0, p = 0;
    e: for (let A = n, _ = o; A <= _; A++) {
      const b = e.getLineContent(A), C = b.length;
      c.reset(0);
      do
        if (u = c.next(b), u) {
          let w = u.index, S = u.index + u[0].length;
          if (w > 0) {
            const I = b.charCodeAt(w - 1);
            Si(I) && w--;
          }
          if (S + 1 < C) {
            const I = b.charCodeAt(S - 1);
            Si(I) && S++;
          }
          const x = b.substring(w, S);
          let y = SA(w + 1, EM, b, 0);
          y && y.endColumn <= w + 1 && (y = null);
          const D = r.shouldHighlightNonBasicASCII(x, y ? y.word : null);
          if (D !== 0) {
            if (D === 3 ? g++ : D === 2 ? m++ : D === 1 ? p++ : eN(), d.length >= 1e3) {
              h = !0;
              break e;
            }
            d.push(new E(A, w + 1, A, S + 1));
          }
        }
      while (u);
    }
    return {
      ranges: d,
      hasMore: h,
      ambiguousCharacterCount: g,
      invisibleCharacterCount: m,
      nonBasicAsciiCharacterCount: p
    };
  }
  static computeUnicodeHighlightReason(e, t) {
    const i = new VR(t);
    switch (i.shouldHighlightNonBasicASCII(e, null)) {
      case 0:
        return null;
      case 2:
        return {
          kind: 1
          /* UnicodeHighlighterReasonKind.Invisible */
        };
      case 3: {
        const o = e.codePointAt(0), r = i.ambiguousCharacters.getPrimaryConfusable(o), a = IA.getLocales().filter((l) => !IA.getInstance(/* @__PURE__ */ new Set([...t.allowedLocales, l])).isAmbiguous(o));
        return { kind: 0, confusableWith: String.fromCodePoint(r), notAmbiguousInLocales: a };
      }
      case 1:
        return {
          kind: 2
          /* UnicodeHighlighterReasonKind.NonBasicAscii */
        };
    }
  }
}
function tG(s, e) {
  return `[${So(s.map((i) => String.fromCodePoint(i)).join(""))}]`;
}
class VR {
  constructor(e) {
    this.options = e, this.allowedCodePoints = new Set(e.allowedCodePoints), this.ambiguousCharacters = IA.getInstance(new Set(e.allowedLocales));
  }
  getCandidateCodePoints() {
    if (this.options.nonBasicASCII)
      return "allNonBasicAscii";
    const e = /* @__PURE__ */ new Set();
    if (this.options.invisibleCharacters)
      for (const t of Mp.codePoints)
        zR(String.fromCodePoint(t)) || e.add(t);
    if (this.options.ambiguousCharacters)
      for (const t of this.ambiguousCharacters.getConfusableCodePoints())
        e.add(t);
    for (const t of this.allowedCodePoints)
      e.delete(t);
    return e;
  }
  shouldHighlightNonBasicASCII(e, t) {
    const i = e.codePointAt(0);
    if (this.allowedCodePoints.has(i))
      return 0;
    if (this.options.nonBasicASCII)
      return 1;
    let n = !1, o = !1;
    if (t)
      for (const r of t) {
        const a = r.codePointAt(0), l = WM(r);
        n = n || l, !l && !this.ambiguousCharacters.isAmbiguous(a) && !Mp.isInvisibleCharacter(a) && (o = !0);
      }
    return (
      /* Don't allow mixing weird looking characters with ASCII */
      !n && /* Is there an obviously weird looking character? */
      o ? 0 : this.options.invisibleCharacters && !zR(e) && Mp.isInvisibleCharacter(i) ? 2 : this.options.ambiguousCharacters && this.ambiguousCharacters.isAmbiguous(i) ? 3 : 0
    );
  }
}
function zR(s) {
  return s === " " || s === `
` || s === "	";
}
class bw {
  constructor(e, t, i) {
    this.changes = e, this.moves = t, this.hitTimeout = i;
  }
}
class b5 {
  constructor(e, t) {
    this.lineRangeMapping = e, this.changes = t;
  }
}
class Be {
  static addRange(e, t) {
    let i = 0;
    for (; i < t.length && t[i].endExclusive < e.start; )
      i++;
    let n = i;
    for (; n < t.length && t[n].start <= e.endExclusive; )
      n++;
    if (i === n)
      t.splice(i, 0, e);
    else {
      const o = Math.min(e.start, t[i].start), r = Math.max(e.endExclusive, t[n - 1].endExclusive);
      t.splice(i, n - i, new Be(o, r));
    }
  }
  static tryCreate(e, t) {
    if (!(e > t))
      return new Be(e, t);
  }
  static ofLength(e) {
    return new Be(0, e);
  }
  static ofStartAndLength(e, t) {
    return new Be(e, e + t);
  }
  constructor(e, t) {
    if (this.start = e, this.endExclusive = t, e > t)
      throw new lt(`Invalid range: ${this.toString()}`);
  }
  get isEmpty() {
    return this.start === this.endExclusive;
  }
  delta(e) {
    return new Be(this.start + e, this.endExclusive + e);
  }
  deltaStart(e) {
    return new Be(this.start + e, this.endExclusive);
  }
  deltaEnd(e) {
    return new Be(this.start, this.endExclusive + e);
  }
  get length() {
    return this.endExclusive - this.start;
  }
  toString() {
    return `[${this.start}, ${this.endExclusive})`;
  }
  contains(e) {
    return this.start <= e && e < this.endExclusive;
  }
  /**
   * for all numbers n: range1.contains(n) or range2.contains(n) => range1.join(range2).contains(n)
   * The joined range is the smallest range that contains both ranges.
   */
  join(e) {
    return new Be(Math.min(this.start, e.start), Math.max(this.endExclusive, e.endExclusive));
  }
  /**
   * for all numbers n: range1.contains(n) and range2.contains(n) <=> range1.intersect(range2).contains(n)
   *
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    if (t <= i)
      return new Be(t, i);
  }
  intersects(e) {
    const t = Math.max(this.start, e.start), i = Math.min(this.endExclusive, e.endExclusive);
    return t < i;
  }
  isBefore(e) {
    return this.endExclusive <= e.start;
  }
  isAfter(e) {
    return this.start >= e.endExclusive;
  }
  slice(e) {
    return e.slice(this.start, this.endExclusive);
  }
  substring(e) {
    return e.substring(this.start, this.endExclusive);
  }
  /**
   * Returns the given value if it is contained in this instance, otherwise the closest value that is contained.
   * The range must not be empty.
   */
  clip(e) {
    if (this.isEmpty)
      throw new lt(`Invalid clipping range: ${this.toString()}`);
    return Math.max(this.start, Math.min(this.endExclusive - 1, e));
  }
  /**
   * Returns `r := value + k * length` such that `r` is contained in this range.
   * The range must not be empty.
   *
   * E.g. `[5, 10).clipCyclic(10) === 5`, `[5, 10).clipCyclic(11) === 6` and `[5, 10).clipCyclic(4) === 9`.
   */
  clipCyclic(e) {
    if (this.isEmpty)
      throw new lt(`Invalid clipping range: ${this.toString()}`);
    return e < this.start ? this.endExclusive - (this.start - e) % this.length : e >= this.endExclusive ? this.start + (e - this.start) % this.length : e;
  }
  forEach(e) {
    for (let t = this.start; t < this.endExclusive; t++)
      e(t);
  }
}
class aN {
  constructor() {
    this._sortedRanges = [];
  }
  addRange(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive < e.start; )
      t++;
    let i = t;
    for (; i < this._sortedRanges.length && this._sortedRanges[i].start <= e.endExclusive; )
      i++;
    if (t === i)
      this._sortedRanges.splice(t, 0, e);
    else {
      const n = Math.min(e.start, this._sortedRanges[t].start), o = Math.max(e.endExclusive, this._sortedRanges[i - 1].endExclusive);
      this._sortedRanges.splice(t, i - t, new Be(n, o));
    }
  }
  toString() {
    return this._sortedRanges.map((e) => e.toString()).join(", ");
  }
  /**
   * Returns of there is a value that is contained in this instance and the given range.
   */
  intersectsStrict(e) {
    let t = 0;
    for (; t < this._sortedRanges.length && this._sortedRanges[t].endExclusive <= e.start; )
      t++;
    return t < this._sortedRanges.length && this._sortedRanges[t].start < e.endExclusive;
  }
  intersectWithRange(e) {
    const t = new aN();
    for (const i of this._sortedRanges) {
      const n = i.intersect(e);
      n && t.addRange(n);
    }
    return t;
  }
  intersectWithRangeLength(e) {
    return this.intersectWithRange(e).length;
  }
  get length() {
    return this._sortedRanges.reduce((e, t) => e + t.length, 0);
  }
}
function gC(s, e) {
  const t = iG(s, e);
  if (t !== -1)
    return s[t];
}
function iG(s, e, t = s.length - 1) {
  for (let i = t; i >= 0; i--) {
    const n = s[i];
    if (e(n))
      return i;
  }
  return -1;
}
function Gf(s, e) {
  const t = FA(s, e);
  return t === -1 ? void 0 : s[t];
}
function FA(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? n = r + 1 : o = r;
  }
  return n - 1;
}
function nG(s, e) {
  const t = OA(s, e);
  return t === s.length ? void 0 : s[t];
}
function OA(s, e, t = 0, i = s.length) {
  let n = t, o = i;
  for (; n < o; ) {
    const r = Math.floor((n + o) / 2);
    e(s[r]) ? o = r : n = r + 1;
  }
  return n;
}
const C1 = class C1 {
  constructor(e) {
    this._array = e, this._findLastMonotonousLastIdx = 0;
  }
  /**
   * The predicate must be monotonous, i.e. `arr.map(predicate)` must be like `[true, ..., true, false, ..., false]`!
   * For subsequent calls, current predicate must be weaker than (or equal to) the previous predicate, i.e. more entries must be `true`.
   */
  findLastMonotonous(e) {
    if (C1.assertInvariants) {
      if (this._prevFindLastPredicate) {
        for (const i of this._array)
          if (this._prevFindLastPredicate(i) && !e(i))
            throw new Error("MonotonousArray: current predicate must be weaker than (or equal to) the previous predicate.");
      }
      this._prevFindLastPredicate = e;
    }
    const t = FA(this._array, e, this._findLastMonotonousLastIdx);
    return this._findLastMonotonousLastIdx = t + 1, t === -1 ? void 0 : this._array[t];
  }
};
C1.assertInvariants = !1;
let fC = C1;
function w5(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) > 0 && (t = n);
  }
  return t;
}
function sG(s, e) {
  if (s.length === 0)
    return;
  let t = s[0];
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, t) >= 0 && (t = n);
  }
  return t;
}
function oG(s, e) {
  return w5(s, (t, i) => -e(t, i));
}
function rG(s, e) {
  if (s.length === 0)
    return -1;
  let t = 0;
  for (let i = 1; i < s.length; i++) {
    const n = s[i];
    e(n, s[t]) > 0 && (t = i);
  }
  return t;
}
let Ee = class $a {
  static fromRangeInclusive(e) {
    return new $a(e.startLineNumber, e.endLineNumber + 1);
  }
  /**
   * @param lineRanges An array of sorted line ranges.
   */
  static joinMany(e) {
    if (e.length === 0)
      return [];
    let t = new go(e[0].slice());
    for (let i = 1; i < e.length; i++)
      t = t.getUnion(new go(e[i].slice()));
    return t.ranges;
  }
  static join(e) {
    if (e.length === 0)
      throw new lt("lineRanges cannot be empty");
    let t = e[0].startLineNumber, i = e[0].endLineNumberExclusive;
    for (let n = 1; n < e.length; n++)
      t = Math.min(t, e[n].startLineNumber), i = Math.max(i, e[n].endLineNumberExclusive);
    return new $a(t, i);
  }
  static ofLength(e, t) {
    return new $a(e, e + t);
  }
  /**
   * @internal
   */
  static deserialize(e) {
    return new $a(e[0], e[1]);
  }
  constructor(e, t) {
    if (e > t)
      throw new lt(`startLineNumber ${e} cannot be after endLineNumberExclusive ${t}`);
    this.startLineNumber = e, this.endLineNumberExclusive = t;
  }
  /**
   * Indicates if this line range contains the given line number.
   */
  contains(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Indicates if this line range is empty.
   */
  get isEmpty() {
    return this.startLineNumber === this.endLineNumberExclusive;
  }
  /**
   * Moves this line range by the given offset of line numbers.
   */
  delta(e) {
    return new $a(this.startLineNumber + e, this.endLineNumberExclusive + e);
  }
  deltaLength(e) {
    return new $a(this.startLineNumber, this.endLineNumberExclusive + e);
  }
  /**
   * The number of lines this line range spans.
   */
  get length() {
    return this.endLineNumberExclusive - this.startLineNumber;
  }
  /**
   * Creates a line range that combines this and the given line range.
   */
  join(e) {
    return new $a(Math.min(this.startLineNumber, e.startLineNumber), Math.max(this.endLineNumberExclusive, e.endLineNumberExclusive));
  }
  toString() {
    return `[${this.startLineNumber},${this.endLineNumberExclusive})`;
  }
  /**
   * The resulting range is empty if the ranges do not intersect, but touch.
   * If the ranges don't even touch, the result is undefined.
   */
  intersect(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumberExclusive, e.endLineNumberExclusive);
    if (t <= i)
      return new $a(t, i);
  }
  intersectsStrict(e) {
    return this.startLineNumber < e.endLineNumberExclusive && e.startLineNumber < this.endLineNumberExclusive;
  }
  overlapOrTouch(e) {
    return this.startLineNumber <= e.endLineNumberExclusive && e.startLineNumber <= this.endLineNumberExclusive;
  }
  equals(e) {
    return this.startLineNumber === e.startLineNumber && this.endLineNumberExclusive === e.endLineNumberExclusive;
  }
  toInclusiveRange() {
    return this.isEmpty ? null : new E(this.startLineNumber, 1, this.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER);
  }
  /**
   * @deprecated Using this function is discouraged because it might lead to bugs: The end position is not guaranteed to be a valid position!
  */
  toExclusiveRange() {
    return new E(this.startLineNumber, 1, this.endLineNumberExclusive, 1);
  }
  mapToLineArray(e) {
    const t = [];
    for (let i = this.startLineNumber; i < this.endLineNumberExclusive; i++)
      t.push(e(i));
    return t;
  }
  forEach(e) {
    for (let t = this.startLineNumber; t < this.endLineNumberExclusive; t++)
      e(t);
  }
  /**
   * @internal
   */
  serialize() {
    return [this.startLineNumber, this.endLineNumberExclusive];
  }
  includes(e) {
    return this.startLineNumber <= e && e < this.endLineNumberExclusive;
  }
  /**
   * Converts this 1-based line range to a 0-based offset range (subtracts 1!).
   * @internal
   */
  toOffsetRange() {
    return new Be(this.startLineNumber - 1, this.endLineNumberExclusive - 1);
  }
};
class go {
  constructor(e = []) {
    this._normalizedRanges = e;
  }
  get ranges() {
    return this._normalizedRanges;
  }
  addRange(e) {
    if (e.length === 0)
      return;
    const t = OA(this._normalizedRanges, (n) => n.endLineNumberExclusive >= e.startLineNumber), i = FA(this._normalizedRanges, (n) => n.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      this._normalizedRanges.splice(t, 0, e);
    else if (t === i - 1) {
      const n = this._normalizedRanges[t];
      this._normalizedRanges[t] = n.join(e);
    } else {
      const n = this._normalizedRanges[t].join(this._normalizedRanges[i - 1]).join(e);
      this._normalizedRanges.splice(t, i - t, n);
    }
  }
  contains(e) {
    const t = Gf(this._normalizedRanges, (i) => i.startLineNumber <= e);
    return !!t && t.endLineNumberExclusive > e;
  }
  intersects(e) {
    const t = Gf(this._normalizedRanges, (i) => i.startLineNumber < e.endLineNumberExclusive);
    return !!t && t.endLineNumberExclusive > e.startLineNumber;
  }
  getUnion(e) {
    if (this._normalizedRanges.length === 0)
      return e;
    if (e._normalizedRanges.length === 0)
      return this;
    const t = [];
    let i = 0, n = 0, o = null;
    for (; i < this._normalizedRanges.length || n < e._normalizedRanges.length; ) {
      let r = null;
      if (i < this._normalizedRanges.length && n < e._normalizedRanges.length) {
        const a = this._normalizedRanges[i], l = e._normalizedRanges[n];
        a.startLineNumber < l.startLineNumber ? (r = a, i++) : (r = l, n++);
      } else i < this._normalizedRanges.length ? (r = this._normalizedRanges[i], i++) : (r = e._normalizedRanges[n], n++);
      o === null ? o = r : o.endLineNumberExclusive >= r.startLineNumber ? o = new Ee(o.startLineNumber, Math.max(o.endLineNumberExclusive, r.endLineNumberExclusive)) : (t.push(o), o = r);
    }
    return o !== null && t.push(o), new go(t);
  }
  /**
   * Subtracts all ranges in this set from `range` and returns the result.
   */
  subtractFrom(e) {
    const t = OA(this._normalizedRanges, (r) => r.endLineNumberExclusive >= e.startLineNumber), i = FA(this._normalizedRanges, (r) => r.startLineNumber <= e.endLineNumberExclusive) + 1;
    if (t === i)
      return new go([e]);
    const n = [];
    let o = e.startLineNumber;
    for (let r = t; r < i; r++) {
      const a = this._normalizedRanges[r];
      a.startLineNumber > o && n.push(new Ee(o, a.startLineNumber)), o = a.endLineNumberExclusive;
    }
    return o < e.endLineNumberExclusive && n.push(new Ee(o, e.endLineNumberExclusive)), new go(n);
  }
  toString() {
    return this._normalizedRanges.map((e) => e.toString()).join(", ");
  }
  getIntersection(e) {
    const t = [];
    let i = 0, n = 0;
    for (; i < this._normalizedRanges.length && n < e._normalizedRanges.length; ) {
      const o = this._normalizedRanges[i], r = e._normalizedRanges[n], a = o.intersect(r);
      a && !a.isEmpty && t.push(a), o.endLineNumberExclusive < r.endLineNumberExclusive ? i++ : n++;
    }
    return new go(t);
  }
  getWithDelta(e) {
    return new go(this._normalizedRanges.map((t) => t.delta(e)));
  }
}
const fc = class fc {
  static betweenPositions(e, t) {
    return e.lineNumber === t.lineNumber ? new fc(0, t.column - e.column) : new fc(t.lineNumber - e.lineNumber, t.column - 1);
  }
  static ofRange(e) {
    return fc.betweenPositions(e.getStartPosition(), e.getEndPosition());
  }
  static ofText(e) {
    let t = 0, i = 0;
    for (const n of e)
      n === `
` ? (t++, i = 0) : i++;
    return new fc(t, i);
  }
  constructor(e, t) {
    this.lineCount = e, this.columnCount = t;
  }
  isGreaterThanOrEqualTo(e) {
    return this.lineCount !== e.lineCount ? this.lineCount > e.lineCount : this.columnCount >= e.columnCount;
  }
  createRange(e) {
    return this.lineCount === 0 ? new E(e.lineNumber, e.column, e.lineNumber, e.column + this.columnCount) : new E(e.lineNumber, e.column, e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  addToPosition(e) {
    return this.lineCount === 0 ? new F(e.lineNumber, e.column + this.columnCount) : new F(e.lineNumber + this.lineCount, this.columnCount + 1);
  }
  toString() {
    return `${this.lineCount},${this.columnCount}`;
  }
};
fc.zero = new fc(0, 0);
let ad = fc;
class aG {
  constructor(e) {
    this.text = e, this.lineStartOffsetByLineIdx = [], this.lineStartOffsetByLineIdx.push(0);
    for (let t = 0; t < e.length; t++)
      e.charAt(t) === `
` && this.lineStartOffsetByLineIdx.push(t + 1);
  }
  getOffset(e) {
    return this.lineStartOffsetByLineIdx[e.lineNumber - 1] + e.column - 1;
  }
  getOffsetRange(e) {
    return new Be(this.getOffset(e.getStartPosition()), this.getOffset(e.getEndPosition()));
  }
  get textLength() {
    const e = this.lineStartOffsetByLineIdx.length - 1;
    return new ad(e, this.text.length - this.lineStartOffsetByLineIdx[e]);
  }
}
class lG {
  constructor(e) {
    this.edits = e, _u(() => tN(e, (t, i) => t.range.getEndPosition().isBeforeOrEqual(i.range.getStartPosition())));
  }
  apply(e) {
    let t = "", i = new F(1, 1);
    for (const o of this.edits) {
      const r = o.range, a = r.getStartPosition(), l = r.getEndPosition(), c = UR(i, a);
      c.isEmpty() || (t += e.getValueOfRange(c)), t += o.text, i = l;
    }
    const n = UR(i, e.endPositionExclusive);
    return n.isEmpty() || (t += e.getValueOfRange(n)), t;
  }
  applyToString(e) {
    const t = new dG(e);
    return this.apply(t);
  }
  getNewRanges() {
    const e = [];
    let t = 0, i = 0, n = 0;
    for (const o of this.edits) {
      const r = ad.ofText(o.text), a = F.lift({
        lineNumber: o.range.startLineNumber + i,
        column: o.range.startColumn + (o.range.startLineNumber === t ? n : 0)
      }), l = r.createRange(a);
      e.push(l), i = l.endLineNumber - o.range.endLineNumber, n = l.endColumn - o.range.endColumn, t = o.range.endLineNumber;
    }
    return e;
  }
}
class cG {
  constructor(e, t) {
    this.range = e, this.text = t;
  }
  toSingleEditOperation() {
    return {
      range: this.range,
      text: this.text
    };
  }
}
function UR(s, e) {
  if (s.lineNumber === e.lineNumber && s.column === Number.MAX_SAFE_INTEGER)
    return E.fromPositions(e, e);
  if (!s.isBeforeOrEqual(e))
    throw new lt("start must be before end");
  return new E(s.lineNumber, s.column, e.lineNumber, e.column);
}
class C5 {
  get endPositionExclusive() {
    return this.length.addToPosition(new F(1, 1));
  }
}
class dG extends C5 {
  constructor(e) {
    super(), this.value = e, this._t = new aG(this.value);
  }
  getValueOfRange(e) {
    return this._t.getOffsetRange(e).substring(this.value);
  }
  get length() {
    return this._t.textLength;
  }
}
class Cn {
  static inverse(e, t, i) {
    const n = [];
    let o = 1, r = 1;
    for (const l of e) {
      const c = new Cn(new Ee(o, l.original.startLineNumber), new Ee(r, l.modified.startLineNumber));
      c.modified.isEmpty || n.push(c), o = l.original.endLineNumberExclusive, r = l.modified.endLineNumberExclusive;
    }
    const a = new Cn(new Ee(o, t + 1), new Ee(r, i + 1));
    return a.modified.isEmpty || n.push(a), n;
  }
  static clip(e, t, i) {
    const n = [];
    for (const o of e) {
      const r = o.original.intersect(t), a = o.modified.intersect(i);
      r && !r.isEmpty && a && !a.isEmpty && n.push(new Cn(r, a));
    }
    return n;
  }
  constructor(e, t) {
    this.original = e, this.modified = t;
  }
  toString() {
    return `{${this.original.toString()}->${this.modified.toString()}}`;
  }
  flip() {
    return new Cn(this.modified, this.original);
  }
  join(e) {
    return new Cn(this.original.join(e.original), this.modified.join(e.modified));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping() {
    const e = this.original.toInclusiveRange(), t = this.modified.toInclusiveRange();
    if (e && t)
      return new Ps(e, t);
    if (this.original.startLineNumber === 1 || this.modified.startLineNumber === 1) {
      if (!(this.modified.startLineNumber === 1 && this.original.startLineNumber === 1))
        throw new lt("not a valid diff");
      return new Ps(new E(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new E(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    } else
      return new Ps(new E(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), new E(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER, this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER));
  }
  /**
   * This method assumes that the LineRangeMapping describes a valid diff!
   * I.e. if one range is empty, the other range cannot be the entire document.
   * It avoids various problems when the line range points to non-existing line-numbers.
  */
  toRangeMapping2(e, t) {
    if (QR(this.original.endLineNumberExclusive, e) && QR(this.modified.endLineNumberExclusive, t))
      return new Ps(new E(this.original.startLineNumber, 1, this.original.endLineNumberExclusive, 1), new E(this.modified.startLineNumber, 1, this.modified.endLineNumberExclusive, 1));
    if (!this.original.isEmpty && !this.modified.isEmpty)
      return new Ps(E.fromPositions(new F(this.original.startLineNumber, 1), lg(new F(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), E.fromPositions(new F(this.modified.startLineNumber, 1), lg(new F(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    if (this.original.startLineNumber > 1 && this.modified.startLineNumber > 1)
      return new Ps(E.fromPositions(lg(new F(this.original.startLineNumber - 1, Number.MAX_SAFE_INTEGER), e), lg(new F(this.original.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), e)), E.fromPositions(lg(new F(this.modified.startLineNumber - 1, Number.MAX_SAFE_INTEGER), t), lg(new F(this.modified.endLineNumberExclusive - 1, Number.MAX_SAFE_INTEGER), t)));
    throw new lt();
  }
}
function lg(s, e) {
  if (s.lineNumber < 1)
    return new F(1, 1);
  if (s.lineNumber > e.length)
    return new F(e.length, e[e.length - 1].length + 1);
  const t = e[s.lineNumber - 1];
  return s.column > t.length + 1 ? new F(s.lineNumber, t.length + 1) : s;
}
function QR(s, e) {
  return s >= 1 && s <= e.length;
}
class qs extends Cn {
  static fromRangeMappings(e) {
    const t = Ee.join(e.map((n) => Ee.fromRangeInclusive(n.originalRange))), i = Ee.join(e.map((n) => Ee.fromRangeInclusive(n.modifiedRange)));
    return new qs(t, i, e);
  }
  constructor(e, t, i) {
    super(e, t), this.innerChanges = i;
  }
  flip() {
    return new qs(this.modified, this.original, this.innerChanges?.map((e) => e.flip()));
  }
  withInnerChangesFromLineRanges() {
    return new qs(this.original, this.modified, [this.toRangeMapping()]);
  }
}
class Ps {
  static assertSorted(e) {
    for (let t = 1; t < e.length; t++) {
      const i = e[t - 1], n = e[t];
      if (!(i.originalRange.getEndPosition().isBeforeOrEqual(n.originalRange.getStartPosition()) && i.modifiedRange.getEndPosition().isBeforeOrEqual(n.modifiedRange.getStartPosition())))
        throw new lt("Range mappings must be sorted");
    }
  }
  constructor(e, t) {
    this.originalRange = e, this.modifiedRange = t;
  }
  toString() {
    return `{${this.originalRange.toString()}->${this.modifiedRange.toString()}}`;
  }
  flip() {
    return new Ps(this.modifiedRange, this.originalRange);
  }
  /**
   * Creates a single text edit that describes the change from the original to the modified text.
  */
  toTextEdit(e) {
    const t = e.getValueOfRange(this.modifiedRange);
    return new cG(this.originalRange, t);
  }
}
const hG = 3;
class uG {
  computeDiff(e, t, i) {
    const o = new mG(e, t, {
      maxComputationTime: i.maxComputationTimeMs,
      shouldIgnoreTrimWhitespace: i.ignoreTrimWhitespace,
      shouldComputeCharChanges: !0,
      shouldMakePrettyDiff: !0,
      shouldPostProcessCharChanges: !0
    }).computeDiff(), r = [];
    let a = null;
    for (const l of o.changes) {
      let c;
      l.originalEndLineNumber === 0 ? c = new Ee(l.originalStartLineNumber + 1, l.originalStartLineNumber + 1) : c = new Ee(l.originalStartLineNumber, l.originalEndLineNumber + 1);
      let d;
      l.modifiedEndLineNumber === 0 ? d = new Ee(l.modifiedStartLineNumber + 1, l.modifiedStartLineNumber + 1) : d = new Ee(l.modifiedStartLineNumber, l.modifiedEndLineNumber + 1);
      let h = new qs(c, d, l.charChanges?.map((u) => new Ps(new E(u.originalStartLineNumber, u.originalStartColumn, u.originalEndLineNumber, u.originalEndColumn), new E(u.modifiedStartLineNumber, u.modifiedStartColumn, u.modifiedEndLineNumber, u.modifiedEndColumn))));
      a && (a.modified.endLineNumberExclusive === h.modified.startLineNumber || a.original.endLineNumberExclusive === h.original.startLineNumber) && (h = new qs(a.original.join(h.original), a.modified.join(h.modified), a.innerChanges && h.innerChanges ? a.innerChanges.concat(h.innerChanges) : void 0), r.pop()), r.push(h), a = h;
    }
    return _u(() => tN(r, (l, c) => c.original.startLineNumber - l.original.endLineNumberExclusive === c.modified.startLineNumber - l.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
    l.original.endLineNumberExclusive < c.original.startLineNumber && l.modified.endLineNumberExclusive < c.modified.startLineNumber)), new bw(r, [], o.quitEarly);
  }
}
function v5(s, e, t, i) {
  return new ml(s, e, t).ComputeDiff(i);
}
let GR = class {
  constructor(e) {
    const t = [], i = [];
    for (let n = 0, o = e.length; n < o; n++)
      t[n] = sL(e[n], 1), i[n] = oL(e[n], 1);
    this.lines = e, this._startColumns = t, this._endColumns = i;
  }
  getElements() {
    const e = [];
    for (let t = 0, i = this.lines.length; t < i; t++)
      e[t] = this.lines[t].substring(this._startColumns[t] - 1, this._endColumns[t] - 1);
    return e;
  }
  getStrictElement(e) {
    return this.lines[e];
  }
  getStartLineNumber(e) {
    return e + 1;
  }
  getEndLineNumber(e) {
    return e + 1;
  }
  createCharSequence(e, t, i) {
    const n = [], o = [], r = [];
    let a = 0;
    for (let l = t; l <= i; l++) {
      const c = this.lines[l], d = e ? this._startColumns[l] : 1, h = e ? this._endColumns[l] : c.length + 1;
      for (let u = d; u < h; u++)
        n[a] = c.charCodeAt(u - 1), o[a] = l + 1, r[a] = u, a++;
      !e && l < i && (n[a] = 10, o[a] = l + 1, r[a] = c.length + 1, a++);
    }
    return new gG(n, o, r);
  }
};
class gG {
  constructor(e, t, i) {
    this._charCodes = e, this._lineNumbers = t, this._columns = i;
  }
  toString() {
    return "[" + this._charCodes.map((e, t) => (e === 10 ? "\\n" : String.fromCharCode(e)) + `-(${this._lineNumbers[t]},${this._columns[t]})`).join(", ") + "]";
  }
  _assertIndex(e, t) {
    if (e < 0 || e >= t.length)
      throw new Error("Illegal index");
  }
  getElements() {
    return this._charCodes;
  }
  getStartLineNumber(e) {
    return e > 0 && e === this._lineNumbers.length ? this.getEndLineNumber(e - 1) : (this._assertIndex(e, this._lineNumbers), this._lineNumbers[e]);
  }
  getEndLineNumber(e) {
    return e === -1 ? this.getStartLineNumber(e + 1) : (this._assertIndex(e, this._lineNumbers), this._charCodes[e] === 10 ? this._lineNumbers[e] + 1 : this._lineNumbers[e]);
  }
  getStartColumn(e) {
    return e > 0 && e === this._columns.length ? this.getEndColumn(e - 1) : (this._assertIndex(e, this._columns), this._columns[e]);
  }
  getEndColumn(e) {
    return e === -1 ? this.getStartColumn(e + 1) : (this._assertIndex(e, this._columns), this._charCodes[e] === 10 ? 1 : this._columns[e] + 1);
  }
}
class _f {
  constructor(e, t, i, n, o, r, a, l) {
    this.originalStartLineNumber = e, this.originalStartColumn = t, this.originalEndLineNumber = i, this.originalEndColumn = n, this.modifiedStartLineNumber = o, this.modifiedStartColumn = r, this.modifiedEndLineNumber = a, this.modifiedEndColumn = l;
  }
  static createFromDiffChange(e, t, i) {
    const n = t.getStartLineNumber(e.originalStart), o = t.getStartColumn(e.originalStart), r = t.getEndLineNumber(e.originalStart + e.originalLength - 1), a = t.getEndColumn(e.originalStart + e.originalLength - 1), l = i.getStartLineNumber(e.modifiedStart), c = i.getStartColumn(e.modifiedStart), d = i.getEndLineNumber(e.modifiedStart + e.modifiedLength - 1), h = i.getEndColumn(e.modifiedStart + e.modifiedLength - 1);
    return new _f(n, o, r, a, l, c, d, h);
  }
}
function fG(s) {
  if (s.length <= 1)
    return s;
  const e = [s[0]];
  let t = e[0];
  for (let i = 1, n = s.length; i < n; i++) {
    const o = s[i], r = o.originalStart - (t.originalStart + t.originalLength), a = o.modifiedStart - (t.modifiedStart + t.modifiedLength);
    Math.min(r, a) < hG ? (t.originalLength = o.originalStart + o.originalLength - t.originalStart, t.modifiedLength = o.modifiedStart + o.modifiedLength - t.modifiedStart) : (e.push(o), t = o);
  }
  return e;
}
class Bp {
  constructor(e, t, i, n, o) {
    this.originalStartLineNumber = e, this.originalEndLineNumber = t, this.modifiedStartLineNumber = i, this.modifiedEndLineNumber = n, this.charChanges = o;
  }
  static createFromDiffResult(e, t, i, n, o, r, a) {
    let l, c, d, h, u;
    if (t.originalLength === 0 ? (l = i.getStartLineNumber(t.originalStart) - 1, c = 0) : (l = i.getStartLineNumber(t.originalStart), c = i.getEndLineNumber(t.originalStart + t.originalLength - 1)), t.modifiedLength === 0 ? (d = n.getStartLineNumber(t.modifiedStart) - 1, h = 0) : (d = n.getStartLineNumber(t.modifiedStart), h = n.getEndLineNumber(t.modifiedStart + t.modifiedLength - 1)), r && t.originalLength > 0 && t.originalLength < 20 && t.modifiedLength > 0 && t.modifiedLength < 20 && o()) {
      const g = i.createCharSequence(e, t.originalStart, t.originalStart + t.originalLength - 1), m = n.createCharSequence(e, t.modifiedStart, t.modifiedStart + t.modifiedLength - 1);
      if (g.getElements().length > 0 && m.getElements().length > 0) {
        let p = v5(g, m, o, !0).changes;
        a && (p = fG(p)), u = [];
        for (let A = 0, _ = p.length; A < _; A++)
          u.push(_f.createFromDiffChange(p[A], g, m));
      }
    }
    return new Bp(l, c, d, h, u);
  }
}
class mG {
  constructor(e, t, i) {
    this.shouldComputeCharChanges = i.shouldComputeCharChanges, this.shouldPostProcessCharChanges = i.shouldPostProcessCharChanges, this.shouldIgnoreTrimWhitespace = i.shouldIgnoreTrimWhitespace, this.shouldMakePrettyDiff = i.shouldMakePrettyDiff, this.originalLines = e, this.modifiedLines = t, this.original = new GR(e), this.modified = new GR(t), this.continueLineDiff = jR(i.maxComputationTime), this.continueCharDiff = jR(i.maxComputationTime === 0 ? 0 : Math.min(i.maxComputationTime, 5e3));
  }
  computeDiff() {
    if (this.original.lines.length === 1 && this.original.lines[0].length === 0)
      return this.modified.lines.length === 1 && this.modified.lines[0].length === 0 ? {
        quitEarly: !1,
        changes: []
      } : {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: 1,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: this.modified.lines.length,
          charChanges: void 0
        }]
      };
    if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0)
      return {
        quitEarly: !1,
        changes: [{
          originalStartLineNumber: 1,
          originalEndLineNumber: this.original.lines.length,
          modifiedStartLineNumber: 1,
          modifiedEndLineNumber: 1,
          charChanges: void 0
        }]
      };
    const e = v5(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff), t = e.changes, i = e.quitEarly;
    if (this.shouldIgnoreTrimWhitespace) {
      const a = [];
      for (let l = 0, c = t.length; l < c; l++)
        a.push(Bp.createFromDiffResult(this.shouldIgnoreTrimWhitespace, t[l], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
      return {
        quitEarly: i,
        changes: a
      };
    }
    const n = [];
    let o = 0, r = 0;
    for (let a = -1, l = t.length; a < l; a++) {
      const c = a + 1 < l ? t[a + 1] : null, d = c ? c.originalStart : this.originalLines.length, h = c ? c.modifiedStart : this.modifiedLines.length;
      for (; o < d && r < h; ) {
        const u = this.originalLines[o], g = this.modifiedLines[r];
        if (u !== g) {
          {
            let m = sL(u, 1), p = sL(g, 1);
            for (; m > 1 && p > 1; ) {
              const A = u.charCodeAt(m - 2), _ = g.charCodeAt(p - 2);
              if (A !== _)
                break;
              m--, p--;
            }
            (m > 1 || p > 1) && this._pushTrimWhitespaceCharChange(n, o + 1, 1, m, r + 1, 1, p);
          }
          {
            let m = oL(u, 1), p = oL(g, 1);
            const A = u.length + 1, _ = g.length + 1;
            for (; m < A && p < _; ) {
              const b = u.charCodeAt(m - 1), C = u.charCodeAt(p - 1);
              if (b !== C)
                break;
              m++, p++;
            }
            (m < A || p < _) && this._pushTrimWhitespaceCharChange(n, o + 1, m, A, r + 1, p, _);
          }
        }
        o++, r++;
      }
      c && (n.push(Bp.createFromDiffResult(this.shouldIgnoreTrimWhitespace, c, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges)), o += c.originalLength, r += c.modifiedLength);
    }
    return {
      quitEarly: i,
      changes: n
    };
  }
  _pushTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    if (this._mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a))
      return;
    let l;
    this.shouldComputeCharChanges && (l = [new _f(t, i, t, n, o, r, o, a)]), e.push(new Bp(t, t, o, o, l));
  }
  _mergeTrimWhitespaceCharChange(e, t, i, n, o, r, a) {
    const l = e.length;
    if (l === 0)
      return !1;
    const c = e[l - 1];
    return c.originalEndLineNumber === 0 || c.modifiedEndLineNumber === 0 ? !1 : c.originalEndLineNumber === t && c.modifiedEndLineNumber === o ? (this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new _f(t, i, t, n, o, r, o, a)), !0) : c.originalEndLineNumber + 1 === t && c.modifiedEndLineNumber + 1 === o ? (c.originalEndLineNumber = t, c.modifiedEndLineNumber = o, this.shouldComputeCharChanges && c.charChanges && c.charChanges.push(new _f(t, i, t, n, o, r, o, a)), !0) : !1;
  }
}
function sL(s, e) {
  const t = Sn(s);
  return t === -1 ? e : t + 1;
}
function oL(s, e) {
  const t = Ru(s);
  return t === -1 ? e : t + 2;
}
function jR(s) {
  if (s === 0)
    return () => !0;
  const e = Date.now();
  return () => Date.now() - e < s;
}
class Rl {
  static trivial(e, t) {
    return new Rl([new vi(Be.ofLength(e.length), Be.ofLength(t.length))], !1);
  }
  static trivialTimedOut(e, t) {
    return new Rl([new vi(Be.ofLength(e.length), Be.ofLength(t.length))], !0);
  }
  constructor(e, t) {
    this.diffs = e, this.hitTimeout = t;
  }
}
class vi {
  static invert(e, t) {
    const i = [];
    return O4(e, (n, o) => {
      i.push(vi.fromOffsetPairs(n ? n.getEndExclusives() : wl.zero, o ? o.getStarts() : new wl(t, (n ? n.seq2Range.endExclusive - n.seq1Range.endExclusive : 0) + t)));
    }), i;
  }
  static fromOffsetPairs(e, t) {
    return new vi(new Be(e.offset1, t.offset1), new Be(e.offset2, t.offset2));
  }
  static assertSorted(e) {
    let t;
    for (const i of e) {
      if (t && !(t.seq1Range.endExclusive <= i.seq1Range.start && t.seq2Range.endExclusive <= i.seq2Range.start))
        throw new lt("Sequence diffs must be sorted");
      t = i;
    }
  }
  constructor(e, t) {
    this.seq1Range = e, this.seq2Range = t;
  }
  swap() {
    return new vi(this.seq2Range, this.seq1Range);
  }
  toString() {
    return `${this.seq1Range} <-> ${this.seq2Range}`;
  }
  join(e) {
    return new vi(this.seq1Range.join(e.seq1Range), this.seq2Range.join(e.seq2Range));
  }
  delta(e) {
    return e === 0 ? this : new vi(this.seq1Range.delta(e), this.seq2Range.delta(e));
  }
  deltaStart(e) {
    return e === 0 ? this : new vi(this.seq1Range.deltaStart(e), this.seq2Range.deltaStart(e));
  }
  deltaEnd(e) {
    return e === 0 ? this : new vi(this.seq1Range.deltaEnd(e), this.seq2Range.deltaEnd(e));
  }
  intersect(e) {
    const t = this.seq1Range.intersect(e.seq1Range), i = this.seq2Range.intersect(e.seq2Range);
    if (!(!t || !i))
      return new vi(t, i);
  }
  getStarts() {
    return new wl(this.seq1Range.start, this.seq2Range.start);
  }
  getEndExclusives() {
    return new wl(this.seq1Range.endExclusive, this.seq2Range.endExclusive);
  }
}
const fh = class fh {
  constructor(e, t) {
    this.offset1 = e, this.offset2 = t;
  }
  toString() {
    return `${this.offset1} <-> ${this.offset2}`;
  }
  delta(e) {
    return e === 0 ? this : new fh(this.offset1 + e, this.offset2 + e);
  }
  equals(e) {
    return this.offset1 === e.offset1 && this.offset2 === e.offset2;
  }
};
fh.zero = new fh(0, 0), fh.max = new fh(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
let wl = fh;
const v1 = class v1 {
  isValid() {
    return !0;
  }
};
v1.instance = new v1();
let PA = v1;
class pG {
  constructor(e) {
    if (this.timeout = e, this.startTime = Date.now(), this.valid = !0, e <= 0)
      throw new lt("timeout must be positive");
  }
  // Recommendation: Set a log-point `{this.disable()}` in the body
  isValid() {
    if (!(Date.now() - this.startTime < this.timeout) && this.valid) {
      this.valid = !1;
      debugger;
    }
    return this.valid;
  }
}
class Ay {
  constructor(e, t) {
    this.width = e, this.height = t, this.array = [], this.array = new Array(e * t);
  }
  get(e, t) {
    return this.array[e + t * this.width];
  }
  set(e, t, i) {
    this.array[e + t * this.width] = i;
  }
}
function rL(s) {
  return s === 32 || s === 9;
}
const hA = class hA {
  static getKey(e) {
    let t = this.chrKeys.get(e);
    return t === void 0 && (t = this.chrKeys.size, this.chrKeys.set(e, t)), t;
  }
  constructor(e, t, i) {
    this.range = e, this.lines = t, this.source = i, this.histogram = [];
    let n = 0;
    for (let o = e.startLineNumber - 1; o < e.endLineNumberExclusive - 1; o++) {
      const r = t[o];
      for (let l = 0; l < r.length; l++) {
        n++;
        const c = r[l], d = hA.getKey(c);
        this.histogram[d] = (this.histogram[d] || 0) + 1;
      }
      n++;
      const a = hA.getKey(`
`);
      this.histogram[a] = (this.histogram[a] || 0) + 1;
    }
    this.totalCount = n;
  }
  computeSimilarity(e) {
    let t = 0;
    const i = Math.max(this.histogram.length, e.histogram.length);
    for (let n = 0; n < i; n++)
      t += Math.abs((this.histogram[n] ?? 0) - (e.histogram[n] ?? 0));
    return 1 - t / (this.totalCount + e.totalCount);
  }
};
hA.chrKeys = /* @__PURE__ */ new Map();
let mC = hA;
class AG {
  compute(e, t, i = PA.instance, n) {
    if (e.length === 0 || t.length === 0)
      return Rl.trivial(e, t);
    const o = new Ay(e.length, t.length), r = new Ay(e.length, t.length), a = new Ay(e.length, t.length);
    for (let m = 0; m < e.length; m++)
      for (let p = 0; p < t.length; p++) {
        if (!i.isValid())
          return Rl.trivialTimedOut(e, t);
        const A = m === 0 ? 0 : o.get(m - 1, p), _ = p === 0 ? 0 : o.get(m, p - 1);
        let b;
        e.getElement(m) === t.getElement(p) ? (m === 0 || p === 0 ? b = 0 : b = o.get(m - 1, p - 1), m > 0 && p > 0 && r.get(m - 1, p - 1) === 3 && (b += a.get(m - 1, p - 1)), b += n ? n(m, p) : 1) : b = -1;
        const C = Math.max(A, _, b);
        if (C === b) {
          const w = m > 0 && p > 0 ? a.get(m - 1, p - 1) : 0;
          a.set(m, p, w + 1), r.set(m, p, 3);
        } else C === A ? (a.set(m, p, 0), r.set(m, p, 1)) : C === _ && (a.set(m, p, 0), r.set(m, p, 2));
        o.set(m, p, C);
      }
    const l = [];
    let c = e.length, d = t.length;
    function h(m, p) {
      (m + 1 !== c || p + 1 !== d) && l.push(new vi(new Be(m + 1, c), new Be(p + 1, d))), c = m, d = p;
    }
    let u = e.length - 1, g = t.length - 1;
    for (; u >= 0 && g >= 0; )
      r.get(u, g) === 3 ? (h(u, g), u--, g--) : r.get(u, g) === 1 ? u-- : g--;
    return h(-1, -1), l.reverse(), new Rl(l, !1);
  }
}
class S5 {
  compute(e, t, i = PA.instance) {
    if (e.length === 0 || t.length === 0)
      return Rl.trivial(e, t);
    const n = e, o = t;
    function r(p, A) {
      for (; p < n.length && A < o.length && n.getElement(p) === o.getElement(A); )
        p++, A++;
      return p;
    }
    let a = 0;
    const l = new _G();
    l.set(0, r(0, 0));
    const c = new bG();
    c.set(0, l.get(0) === 0 ? null : new YR(null, 0, 0, l.get(0)));
    let d = 0;
    e: for (; ; ) {
      if (a++, !i.isValid())
        return Rl.trivialTimedOut(n, o);
      const p = -Math.min(a, o.length + a % 2), A = Math.min(a, n.length + a % 2);
      for (d = p; d <= A; d += 2) {
        const _ = d === A ? -1 : l.get(d + 1), b = d === p ? -1 : l.get(d - 1) + 1, C = Math.min(Math.max(_, b), n.length), w = C - d;
        if (C > n.length || w > o.length)
          continue;
        const S = r(C, w);
        l.set(d, S);
        const x = C === _ ? c.get(d + 1) : c.get(d - 1);
        if (c.set(d, S !== C ? new YR(x, C, w, S - C) : x), l.get(d) === n.length && l.get(d) - d === o.length)
          break e;
      }
    }
    let h = c.get(d);
    const u = [];
    let g = n.length, m = o.length;
    for (; ; ) {
      const p = h ? h.x + h.length : 0, A = h ? h.y + h.length : 0;
      if ((p !== g || A !== m) && u.push(new vi(new Be(p, g), new Be(A, m))), !h)
        break;
      g = h.x, m = h.y, h = h.prev;
    }
    return u.reverse(), new Rl(u, !1);
  }
}
class YR {
  constructor(e, t, i, n) {
    this.prev = e, this.x = t, this.y = i, this.length = n;
  }
}
class _G {
  constructor() {
    this.positiveArr = new Int32Array(10), this.negativeArr = new Int32Array(10);
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    if (e < 0) {
      if (e = -e - 1, e >= this.negativeArr.length) {
        const i = this.negativeArr;
        this.negativeArr = new Int32Array(i.length * 2), this.negativeArr.set(i);
      }
      this.negativeArr[e] = t;
    } else {
      if (e >= this.positiveArr.length) {
        const i = this.positiveArr;
        this.positiveArr = new Int32Array(i.length * 2), this.positiveArr.set(i);
      }
      this.positiveArr[e] = t;
    }
  }
}
class bG {
  constructor() {
    this.positiveArr = [], this.negativeArr = [];
  }
  get(e) {
    return e < 0 ? (e = -e - 1, this.negativeArr[e]) : this.positiveArr[e];
  }
  set(e, t) {
    e < 0 ? (e = -e - 1, this.negativeArr[e] = t) : this.positiveArr[e] = t;
  }
}
class pC {
  constructor(e, t, i) {
    this.lines = e, this.range = t, this.considerWhitespaceChanges = i, this.elements = [], this.firstElementOffsetByLineIdx = [], this.lineStartOffsets = [], this.trimmedWsLengthsByLineIdx = [], this.firstElementOffsetByLineIdx.push(0);
    for (let n = this.range.startLineNumber; n <= this.range.endLineNumber; n++) {
      let o = e[n - 1], r = 0;
      n === this.range.startLineNumber && this.range.startColumn > 1 && (r = this.range.startColumn - 1, o = o.substring(r)), this.lineStartOffsets.push(r);
      let a = 0;
      if (!i) {
        const c = o.trimStart();
        a = o.length - c.length, o = c.trimEnd();
      }
      this.trimmedWsLengthsByLineIdx.push(a);
      const l = n === this.range.endLineNumber ? Math.min(this.range.endColumn - 1 - r - a, o.length) : o.length;
      for (let c = 0; c < l; c++)
        this.elements.push(o.charCodeAt(c));
      n < this.range.endLineNumber && (this.elements.push(10), this.firstElementOffsetByLineIdx.push(this.elements.length));
    }
  }
  toString() {
    return `Slice: "${this.text}"`;
  }
  get text() {
    return this.getText(new Be(0, this.length));
  }
  getText(e) {
    return this.elements.slice(e.start, e.endExclusive).map((t) => String.fromCharCode(t)).join("");
  }
  getElement(e) {
    return this.elements[e];
  }
  get length() {
    return this.elements.length;
  }
  getBoundaryScore(e) {
    const t = JR(e > 0 ? this.elements[e - 1] : -1), i = JR(e < this.elements.length ? this.elements[e] : -1);
    if (t === 7 && i === 8)
      return 0;
    if (t === 8)
      return 150;
    let n = 0;
    return t !== i && (n += 10, t === 0 && i === 1 && (n += 1)), n += KR(t), n += KR(i), n;
  }
  translateOffset(e, t = "right") {
    const i = FA(this.firstElementOffsetByLineIdx, (o) => o <= e), n = e - this.firstElementOffsetByLineIdx[i];
    return new F(this.range.startLineNumber + i, 1 + this.lineStartOffsets[i] + n + (n === 0 && t === "left" ? 0 : this.trimmedWsLengthsByLineIdx[i]));
  }
  translateRange(e) {
    const t = this.translateOffset(e.start, "right"), i = this.translateOffset(e.endExclusive, "left");
    return i.isBefore(t) ? E.fromPositions(i, i) : E.fromPositions(t, i);
  }
  /**
   * Finds the word that contains the character at the given offset
   */
  findWordContaining(e) {
    if (e < 0 || e >= this.elements.length || !_y(this.elements[e]))
      return;
    let t = e;
    for (; t > 0 && _y(this.elements[t - 1]); )
      t--;
    let i = e;
    for (; i < this.elements.length && _y(this.elements[i]); )
      i++;
    return new Be(t, i);
  }
  countLinesIn(e) {
    return this.translateOffset(e.endExclusive).lineNumber - this.translateOffset(e.start).lineNumber;
  }
  isStronglyEqual(e, t) {
    return this.elements[e] === this.elements[t];
  }
  extendToFullLines(e) {
    const t = Gf(this.firstElementOffsetByLineIdx, (n) => n <= e.start) ?? 0, i = nG(this.firstElementOffsetByLineIdx, (n) => e.endExclusive <= n) ?? this.elements.length;
    return new Be(t, i);
  }
}
function _y(s) {
  return s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57;
}
const wG = {
  0: 0,
  1: 0,
  2: 0,
  3: 10,
  4: 2,
  5: 30,
  6: 3,
  7: 10,
  8: 10
};
function KR(s) {
  return wG[s];
}
function JR(s) {
  return s === 10 ? 8 : s === 13 ? 7 : rL(s) ? 6 : s >= 97 && s <= 122 ? 0 : s >= 65 && s <= 90 ? 1 : s >= 48 && s <= 57 ? 2 : s === -1 ? 3 : s === 44 || s === 59 ? 5 : 4;
}
function CG(s, e, t, i, n, o) {
  let { moves: r, excludedChanges: a } = SG(s, e, t, o);
  if (!o.isValid())
    return [];
  const l = s.filter((d) => !a.has(d)), c = yG(l, i, n, e, t, o);
  return Sx(r, c), r = xG(r), r = r.filter((d) => {
    const h = d.original.toOffsetRange().slice(e).map((g) => g.trim());
    return h.join(`
`).length >= 15 && vG(h, (g) => g.length >= 2) >= 2;
  }), r = EG(s, r), r;
}
function vG(s, e) {
  let t = 0;
  for (const i of s)
    e(i) && t++;
  return t;
}
function SG(s, e, t, i) {
  const n = [], o = s.filter((l) => l.modified.isEmpty && l.original.length >= 3).map((l) => new mC(l.original, e, l)), r = new Set(s.filter((l) => l.original.isEmpty && l.modified.length >= 3).map((l) => new mC(l.modified, t, l))), a = /* @__PURE__ */ new Set();
  for (const l of o) {
    let c = -1, d;
    for (const h of r) {
      const u = l.computeSimilarity(h);
      u > c && (c = u, d = h);
    }
    if (c > 0.9 && d && (r.delete(d), n.push(new Cn(l.range, d.range)), a.add(l.source), a.add(d.source)), !i.isValid())
      return { moves: n, excludedChanges: a };
  }
  return { moves: n, excludedChanges: a };
}
function yG(s, e, t, i, n, o) {
  const r = [], a = new _5();
  for (const u of s)
    for (let g = u.original.startLineNumber; g < u.original.endLineNumberExclusive - 2; g++) {
      const m = `${e[g - 1]}:${e[g + 1 - 1]}:${e[g + 2 - 1]}`;
      a.add(m, { range: new Ee(g, g + 3) });
    }
  const l = [];
  s.sort(_o((u) => u.modified.startLineNumber, Ml));
  for (const u of s) {
    let g = [];
    for (let m = u.modified.startLineNumber; m < u.modified.endLineNumberExclusive - 2; m++) {
      const p = `${t[m - 1]}:${t[m + 1 - 1]}:${t[m + 2 - 1]}`, A = new Ee(m, m + 3), _ = [];
      a.forEach(p, ({ range: b }) => {
        for (const w of g)
          if (w.originalLineRange.endLineNumberExclusive + 1 === b.endLineNumberExclusive && w.modifiedLineRange.endLineNumberExclusive + 1 === A.endLineNumberExclusive) {
            w.originalLineRange = new Ee(w.originalLineRange.startLineNumber, b.endLineNumberExclusive), w.modifiedLineRange = new Ee(w.modifiedLineRange.startLineNumber, A.endLineNumberExclusive), _.push(w);
            return;
          }
        const C = {
          modifiedLineRange: A,
          originalLineRange: b
        };
        l.push(C), _.push(C);
      }), g = _;
    }
    if (!o.isValid())
      return [];
  }
  l.sort(y9(_o((u) => u.modifiedLineRange.length, Ml)));
  const c = new go(), d = new go();
  for (const u of l) {
    const g = u.modifiedLineRange.startLineNumber - u.originalLineRange.startLineNumber, m = c.subtractFrom(u.modifiedLineRange), p = d.subtractFrom(u.originalLineRange).getWithDelta(g), A = m.getIntersection(p);
    for (const _ of A.ranges) {
      if (_.length < 3)
        continue;
      const b = _, C = _.delta(-g);
      r.push(new Cn(C, b)), c.addRange(b), d.addRange(C);
    }
  }
  r.sort(_o((u) => u.original.startLineNumber, Ml));
  const h = new fC(s);
  for (let u = 0; u < r.length; u++) {
    const g = r[u], m = h.findLastMonotonous((x) => x.original.startLineNumber <= g.original.startLineNumber), p = Gf(s, (x) => x.modified.startLineNumber <= g.modified.startLineNumber), A = Math.max(g.original.startLineNumber - m.original.startLineNumber, g.modified.startLineNumber - p.modified.startLineNumber), _ = h.findLastMonotonous((x) => x.original.startLineNumber < g.original.endLineNumberExclusive), b = Gf(s, (x) => x.modified.startLineNumber < g.modified.endLineNumberExclusive), C = Math.max(_.original.endLineNumberExclusive - g.original.endLineNumberExclusive, b.modified.endLineNumberExclusive - g.modified.endLineNumberExclusive);
    let w;
    for (w = 0; w < A; w++) {
      const x = g.original.startLineNumber - w - 1, y = g.modified.startLineNumber - w - 1;
      if (x > i.length || y > n.length || c.contains(y) || d.contains(x) || !qR(i[x - 1], n[y - 1], o))
        break;
    }
    w > 0 && (d.addRange(new Ee(g.original.startLineNumber - w, g.original.startLineNumber)), c.addRange(new Ee(g.modified.startLineNumber - w, g.modified.startLineNumber)));
    let S;
    for (S = 0; S < C; S++) {
      const x = g.original.endLineNumberExclusive + S, y = g.modified.endLineNumberExclusive + S;
      if (x > i.length || y > n.length || c.contains(y) || d.contains(x) || !qR(i[x - 1], n[y - 1], o))
        break;
    }
    S > 0 && (d.addRange(new Ee(g.original.endLineNumberExclusive, g.original.endLineNumberExclusive + S)), c.addRange(new Ee(g.modified.endLineNumberExclusive, g.modified.endLineNumberExclusive + S))), (w > 0 || S > 0) && (r[u] = new Cn(new Ee(g.original.startLineNumber - w, g.original.endLineNumberExclusive + S), new Ee(g.modified.startLineNumber - w, g.modified.endLineNumberExclusive + S)));
  }
  return r;
}
function qR(s, e, t) {
  if (s.trim() === e.trim())
    return !0;
  if (s.length > 300 && e.length > 300)
    return !1;
  const n = new S5().compute(new pC([s], new E(1, 1, 1, s.length), !1), new pC([e], new E(1, 1, 1, e.length), !1), t);
  let o = 0;
  const r = vi.invert(n.diffs, s.length);
  for (const d of r)
    d.seq1Range.forEach((h) => {
      rL(s.charCodeAt(h)) || o++;
    });
  function a(d) {
    let h = 0;
    for (let u = 0; u < s.length; u++)
      rL(d.charCodeAt(u)) || h++;
    return h;
  }
  const l = a(s.length > e.length ? s : e);
  return o / l > 0.6 && l > 10;
}
function xG(s) {
  if (s.length === 0)
    return s;
  s.sort(_o((t) => t.original.startLineNumber, Ml));
  const e = [s[0]];
  for (let t = 1; t < s.length; t++) {
    const i = e[e.length - 1], n = s[t], o = n.original.startLineNumber - i.original.endLineNumberExclusive, r = n.modified.startLineNumber - i.modified.endLineNumberExclusive;
    if (o >= 0 && r >= 0 && o + r <= 2) {
      e[e.length - 1] = i.join(n);
      continue;
    }
    e.push(n);
  }
  return e;
}
function EG(s, e) {
  const t = new fC(s);
  return e = e.filter((i) => {
    const n = t.findLastMonotonous((a) => a.original.startLineNumber < i.original.endLineNumberExclusive) || new Cn(new Ee(1, 1), new Ee(1, 1)), o = Gf(s, (a) => a.modified.startLineNumber < i.modified.endLineNumberExclusive);
    return n !== o;
  }), e;
}
function aL(s, e, t) {
  let i = t;
  return i = $R(s, e, i), i = $R(s, e, i), i = LG(s, e, i), i;
}
function $R(s, e, t) {
  if (t.length === 0)
    return t;
  const i = [];
  i.push(t[0]);
  for (let o = 1; o < t.length; o++) {
    const r = i[i.length - 1];
    let a = t[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = a.seq1Range.start - r.seq1Range.endExclusive;
      let c;
      for (c = 1; c <= l && !(s.getElement(a.seq1Range.start - c) !== s.getElement(a.seq1Range.endExclusive - c) || e.getElement(a.seq2Range.start - c) !== e.getElement(a.seq2Range.endExclusive - c)); c++)
        ;
      if (c--, c === l) {
        i[i.length - 1] = new vi(new Be(r.seq1Range.start, a.seq1Range.endExclusive - l), new Be(r.seq2Range.start, a.seq2Range.endExclusive - l));
        continue;
      }
      a = a.delta(-c);
    }
    i.push(a);
  }
  const n = [];
  for (let o = 0; o < i.length - 1; o++) {
    const r = i[o + 1];
    let a = i[o];
    if (a.seq1Range.isEmpty || a.seq2Range.isEmpty) {
      const l = r.seq1Range.start - a.seq1Range.endExclusive;
      let c;
      for (c = 0; c < l && !(!s.isStronglyEqual(a.seq1Range.start + c, a.seq1Range.endExclusive + c) || !e.isStronglyEqual(a.seq2Range.start + c, a.seq2Range.endExclusive + c)); c++)
        ;
      if (c === l) {
        i[o + 1] = new vi(new Be(a.seq1Range.start + l, r.seq1Range.endExclusive), new Be(a.seq2Range.start + l, r.seq2Range.endExclusive));
        continue;
      }
      c > 0 && (a = a.delta(c));
    }
    n.push(a);
  }
  return i.length > 0 && n.push(i[i.length - 1]), n;
}
function LG(s, e, t) {
  if (!s.getBoundaryScore || !e.getBoundaryScore)
    return t;
  for (let i = 0; i < t.length; i++) {
    const n = i > 0 ? t[i - 1] : void 0, o = t[i], r = i + 1 < t.length ? t[i + 1] : void 0, a = new Be(n ? n.seq1Range.endExclusive + 1 : 0, r ? r.seq1Range.start - 1 : s.length), l = new Be(n ? n.seq2Range.endExclusive + 1 : 0, r ? r.seq2Range.start - 1 : e.length);
    o.seq1Range.isEmpty ? t[i] = XR(o, s, e, a, l) : o.seq2Range.isEmpty && (t[i] = XR(o.swap(), e, s, l, a).swap());
  }
  return t;
}
function XR(s, e, t, i, n) {
  let r = 1;
  for (; s.seq1Range.start - r >= i.start && s.seq2Range.start - r >= n.start && t.isStronglyEqual(s.seq2Range.start - r, s.seq2Range.endExclusive - r) && r < 100; )
    r++;
  r--;
  let a = 0;
  for (; s.seq1Range.start + a < i.endExclusive && s.seq2Range.endExclusive + a < n.endExclusive && t.isStronglyEqual(s.seq2Range.start + a, s.seq2Range.endExclusive + a) && a < 100; )
    a++;
  if (r === 0 && a === 0)
    return s;
  let l = 0, c = -1;
  for (let d = -r; d <= a; d++) {
    const h = s.seq2Range.start + d, u = s.seq2Range.endExclusive + d, g = s.seq1Range.start + d, m = e.getBoundaryScore(g) + t.getBoundaryScore(h) + t.getBoundaryScore(u);
    m > c && (c = m, l = d);
  }
  return s.delta(l);
}
function kG(s, e, t) {
  const i = [];
  for (const n of t) {
    const o = i[i.length - 1];
    if (!o) {
      i.push(n);
      continue;
    }
    n.seq1Range.start - o.seq1Range.endExclusive <= 2 || n.seq2Range.start - o.seq2Range.endExclusive <= 2 ? i[i.length - 1] = new vi(o.seq1Range.join(n.seq1Range), o.seq2Range.join(n.seq2Range)) : i.push(n);
  }
  return i;
}
function DG(s, e, t) {
  const i = vi.invert(t, s.length), n = [];
  let o = new wl(0, 0);
  function r(l, c) {
    if (l.offset1 < o.offset1 || l.offset2 < o.offset2)
      return;
    const d = s.findWordContaining(l.offset1), h = e.findWordContaining(l.offset2);
    if (!d || !h)
      return;
    let u = new vi(d, h);
    const g = u.intersect(c);
    let m = g.seq1Range.length, p = g.seq2Range.length;
    for (; i.length > 0; ) {
      const A = i[0];
      if (!(A.seq1Range.intersects(u.seq1Range) || A.seq2Range.intersects(u.seq2Range)))
        break;
      const b = s.findWordContaining(A.seq1Range.start), C = e.findWordContaining(A.seq2Range.start), w = new vi(b, C), S = w.intersect(A);
      if (m += S.seq1Range.length, p += S.seq2Range.length, u = u.join(w), u.seq1Range.endExclusive >= A.seq1Range.endExclusive)
        i.shift();
      else
        break;
    }
    m + p < (u.seq1Range.length + u.seq2Range.length) * 2 / 3 && n.push(u), o = u.getEndExclusives();
  }
  for (; i.length > 0; ) {
    const l = i.shift();
    l.seq1Range.isEmpty || (r(l.getStarts(), l), r(l.getEndExclusives().delta(-1), l));
  }
  return IG(t, n);
}
function IG(s, e) {
  const t = [];
  for (; s.length > 0 || e.length > 0; ) {
    const i = s[0], n = e[0];
    let o;
    i && (!n || i.seq1Range.start < n.seq1Range.start) ? o = s.shift() : o = e.shift(), t.length > 0 && t[t.length - 1].seq1Range.endExclusive >= o.seq1Range.start ? t[t.length - 1] = t[t.length - 1].join(o) : t.push(o);
  }
  return t;
}
function MG(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const r = [
      i[0]
    ];
    for (let a = 1; a < i.length; a++) {
      let d = function(u, g) {
        const m = new Be(c.seq1Range.endExclusive, l.seq1Range.start);
        return s.getText(m).replace(/\s/g, "").length <= 4 && (u.seq1Range.length + u.seq2Range.length > 5 || g.seq1Range.length + g.seq2Range.length > 5);
      };
      const l = i[a], c = r[r.length - 1];
      d(c, l) ? (o = !0, r[r.length - 1] = r[r.length - 1].join(l)) : r.push(l);
    }
    i = r;
  } while (n++ < 10 && o);
  return i;
}
function NG(s, e, t) {
  let i = t;
  if (i.length === 0)
    return i;
  let n = 0, o;
  do {
    o = !1;
    const a = [
      i[0]
    ];
    for (let l = 1; l < i.length; l++) {
      let h = function(g, m) {
        const p = new Be(d.seq1Range.endExclusive, c.seq1Range.start);
        if (s.countLinesIn(p) > 5 || p.length > 500)
          return !1;
        const _ = s.getText(p).trim();
        if (_.length > 20 || _.split(/\r\n|\r|\n/).length > 1)
          return !1;
        const b = s.countLinesIn(g.seq1Range), C = g.seq1Range.length, w = e.countLinesIn(g.seq2Range), S = g.seq2Range.length, x = s.countLinesIn(m.seq1Range), y = m.seq1Range.length, D = e.countLinesIn(m.seq2Range), I = m.seq2Range.length, Q = 2 * 40 + 50;
        function P(W) {
          return Math.min(W, Q);
        }
        return Math.pow(Math.pow(P(b * 40 + C), 1.5) + Math.pow(P(w * 40 + S), 1.5), 1.5) + Math.pow(Math.pow(P(x * 40 + y), 1.5) + Math.pow(P(D * 40 + I), 1.5), 1.5) > (Q ** 1.5) ** 1.5 * 1.3;
      };
      const c = i[l], d = a[a.length - 1];
      h(d, c) ? (o = !0, a[a.length - 1] = a[a.length - 1].join(c)) : a.push(c);
    }
    i = a;
  } while (n++ < 10 && o);
  const r = [];
  return w9(i, (a, l, c) => {
    let d = l;
    function h(_) {
      return _.length > 0 && _.trim().length <= 3 && l.seq1Range.length + l.seq2Range.length > 100;
    }
    const u = s.extendToFullLines(l.seq1Range), g = s.getText(new Be(u.start, l.seq1Range.start));
    h(g) && (d = d.deltaStart(-g.length));
    const m = s.getText(new Be(l.seq1Range.endExclusive, u.endExclusive));
    h(m) && (d = d.deltaEnd(m.length));
    const p = vi.fromOffsetPairs(a ? a.getEndExclusives() : wl.zero, c ? c.getStarts() : wl.max), A = d.intersect(p);
    r.length > 0 && A.getStarts().equals(r[r.length - 1].getEndExclusives()) ? r[r.length - 1] = r[r.length - 1].join(A) : r.push(A);
  }), r;
}
class ZR {
  constructor(e, t) {
    this.trimmedHash = e, this.lines = t;
  }
  getElement(e) {
    return this.trimmedHash[e];
  }
  get length() {
    return this.trimmedHash.length;
  }
  getBoundaryScore(e) {
    const t = e === 0 ? 0 : e2(this.lines[e - 1]), i = e === this.lines.length ? 0 : e2(this.lines[e]);
    return 1e3 - (t + i);
  }
  getText(e) {
    return this.lines.slice(e.start, e.endExclusive).join(`
`);
  }
  isStronglyEqual(e, t) {
    return this.lines[e] === this.lines[t];
  }
}
function e2(s) {
  let e = 0;
  for (; e < s.length && (s.charCodeAt(e) === 32 || s.charCodeAt(e) === 9); )
    e++;
  return e;
}
class y5 {
  constructor() {
    this.dynamicProgrammingDiffing = new AG(), this.myersDiffingAlgorithm = new S5();
  }
  computeDiff(e, t, i) {
    if (e.length <= 1 && pi(e, t, (S, x) => S === x))
      return new bw([], [], !1);
    if (e.length === 1 && e[0].length === 0 || t.length === 1 && t[0].length === 0)
      return new bw([
        new qs(new Ee(1, e.length + 1), new Ee(1, t.length + 1), [
          new Ps(new E(1, 1, e.length, e[e.length - 1].length + 1), new E(1, 1, t.length, t[t.length - 1].length + 1))
        ])
      ], [], !1);
    const n = i.maxComputationTimeMs === 0 ? PA.instance : new pG(i.maxComputationTimeMs), o = !i.ignoreTrimWhitespace, r = /* @__PURE__ */ new Map();
    function a(S) {
      let x = r.get(S);
      return x === void 0 && (x = r.size, r.set(S, x)), x;
    }
    const l = e.map((S) => a(S.trim())), c = t.map((S) => a(S.trim())), d = new ZR(l, e), h = new ZR(c, t), u = d.length + h.length < 1700 ? this.dynamicProgrammingDiffing.compute(d, h, n, (S, x) => e[S] === t[x] ? t[x].length === 0 ? 0.1 : 1 + Math.log(1 + t[x].length) : 0.99) : this.myersDiffingAlgorithm.compute(d, h, n);
    let g = u.diffs, m = u.hitTimeout;
    g = aL(d, h, g), g = MG(d, h, g);
    const p = [], A = (S) => {
      if (o)
        for (let x = 0; x < S; x++) {
          const y = _ + x, D = b + x;
          if (e[y] !== t[D]) {
            const I = this.refineDiff(e, t, new vi(new Be(y, y + 1), new Be(D, D + 1)), n, o);
            for (const Q of I.mappings)
              p.push(Q);
            I.hitTimeout && (m = !0);
          }
        }
    };
    let _ = 0, b = 0;
    for (const S of g) {
      _u(() => S.seq1Range.start - _ === S.seq2Range.start - b);
      const x = S.seq1Range.start - _;
      A(x), _ = S.seq1Range.endExclusive, b = S.seq2Range.endExclusive;
      const y = this.refineDiff(e, t, S, n, o);
      y.hitTimeout && (m = !0);
      for (const D of y.mappings)
        p.push(D);
    }
    A(e.length - _);
    const C = t2(p, e, t);
    let w = [];
    return i.computeMoves && (w = this.computeMoves(C, e, t, l, c, n, o)), _u(() => {
      function S(y, D) {
        if (y.lineNumber < 1 || y.lineNumber > D.length)
          return !1;
        const I = D[y.lineNumber - 1];
        return !(y.column < 1 || y.column > I.length + 1);
      }
      function x(y, D) {
        return !(y.startLineNumber < 1 || y.startLineNumber > D.length + 1 || y.endLineNumberExclusive < 1 || y.endLineNumberExclusive > D.length + 1);
      }
      for (const y of C) {
        if (!y.innerChanges)
          return !1;
        for (const D of y.innerChanges)
          if (!(S(D.modifiedRange.getStartPosition(), t) && S(D.modifiedRange.getEndPosition(), t) && S(D.originalRange.getStartPosition(), e) && S(D.originalRange.getEndPosition(), e)))
            return !1;
        if (!x(y.modified, t) || !x(y.original, e))
          return !1;
      }
      return !0;
    }), new bw(C, w, m);
  }
  computeMoves(e, t, i, n, o, r, a) {
    return CG(e, t, i, n, o, r).map((d) => {
      const h = this.refineDiff(t, i, new vi(d.original.toOffsetRange(), d.modified.toOffsetRange()), r, a), u = t2(h.mappings, t, i, !0);
      return new b5(d, u);
    });
  }
  refineDiff(e, t, i, n, o) {
    const a = BG(i).toRangeMapping2(e, t), l = new pC(e, a.originalRange, o), c = new pC(t, a.modifiedRange, o), d = l.length + c.length < 500 ? this.dynamicProgrammingDiffing.compute(l, c, n) : this.myersDiffingAlgorithm.compute(l, c, n);
    let h = d.diffs;
    return h = aL(l, c, h), h = DG(l, c, h), h = kG(l, c, h), h = NG(l, c, h), {
      mappings: h.map((g) => new Ps(l.translateRange(g.seq1Range), c.translateRange(g.seq2Range))),
      hitTimeout: d.hitTimeout
    };
  }
}
function t2(s, e, t, i = !1) {
  const n = [];
  for (const o of CM(s.map((r) => TG(r, e, t)), (r, a) => r.original.overlapOrTouch(a.original) || r.modified.overlapOrTouch(a.modified))) {
    const r = o[0], a = o[o.length - 1];
    n.push(new qs(r.original.join(a.original), r.modified.join(a.modified), o.map((l) => l.innerChanges[0])));
  }
  return _u(() => !i && n.length > 0 && (n[0].modified.startLineNumber !== n[0].original.startLineNumber || t.length - n[n.length - 1].modified.endLineNumberExclusive !== e.length - n[n.length - 1].original.endLineNumberExclusive) ? !1 : tN(n, (o, r) => r.original.startLineNumber - o.original.endLineNumberExclusive === r.modified.startLineNumber - o.modified.endLineNumberExclusive && // There has to be an unchanged line in between (otherwise both diffs should have been joined)
  o.original.endLineNumberExclusive < r.original.startLineNumber && o.modified.endLineNumberExclusive < r.modified.startLineNumber)), n;
}
function TG(s, e, t) {
  let i = 0, n = 0;
  s.modifiedRange.endColumn === 1 && s.originalRange.endColumn === 1 && s.originalRange.startLineNumber + i <= s.originalRange.endLineNumber && s.modifiedRange.startLineNumber + i <= s.modifiedRange.endLineNumber && (n = -1), s.modifiedRange.startColumn - 1 >= t[s.modifiedRange.startLineNumber - 1].length && s.originalRange.startColumn - 1 >= e[s.originalRange.startLineNumber - 1].length && s.originalRange.startLineNumber <= s.originalRange.endLineNumber + n && s.modifiedRange.startLineNumber <= s.modifiedRange.endLineNumber + n && (i = 1);
  const o = new Ee(s.originalRange.startLineNumber + i, s.originalRange.endLineNumber + 1 + n), r = new Ee(s.modifiedRange.startLineNumber + i, s.modifiedRange.endLineNumber + 1 + n);
  return new qs(o, r, [s]);
}
function BG(s) {
  return new Cn(new Ee(s.seq1Range.start + 1, s.seq1Range.endExclusive + 1), new Ee(s.seq2Range.start + 1, s.seq2Range.endExclusive + 1));
}
const i2 = {
  getLegacy: () => new uG(),
  getDefault: () => new y5()
};
function Wc(s, e) {
  const t = Math.pow(10, e);
  return Math.round(s * t) / t;
}
class qe {
  constructor(e, t, i, n = 1) {
    this._rgbaBrand = void 0, this.r = Math.min(255, Math.max(0, e)) | 0, this.g = Math.min(255, Math.max(0, t)) | 0, this.b = Math.min(255, Math.max(0, i)) | 0, this.a = Wc(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.r === t.r && e.g === t.g && e.b === t.b && e.a === t.a;
  }
}
class Wo {
  constructor(e, t, i, n) {
    this._hslaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Wc(Math.max(Math.min(1, t), 0), 3), this.l = Wc(Math.max(Math.min(1, i), 0), 3), this.a = Wc(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.l === t.l && e.a === t.a;
  }
  /**
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h in the set [0, 360], s, and l in the set [0, 1].
   */
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = e.a, r = Math.max(t, i, n), a = Math.min(t, i, n);
    let l = 0, c = 0;
    const d = (a + r) / 2, h = r - a;
    if (h > 0) {
      switch (c = Math.min(d <= 0.5 ? h / (2 * d) : h / (2 - 2 * d), 1), r) {
        case t:
          l = (i - n) / h + (i < n ? 6 : 0);
          break;
        case i:
          l = (n - t) / h + 2;
          break;
        case n:
          l = (t - i) / h + 4;
          break;
      }
      l *= 60, l = Math.round(l);
    }
    return new Wo(l, c, d, o);
  }
  static _hue2rgb(e, t, i) {
    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (t - e) * 6 * i : i < 1 / 2 ? t : i < 2 / 3 ? e + (t - e) * (2 / 3 - i) * 6 : e;
  }
  /**
   * Converts an HSL color value to RGB. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes h in the set [0, 360] s, and l are contained in the set [0, 1] and
   * returns r, g, and b in the set [0, 255].
   */
  static toRGBA(e) {
    const t = e.h / 360, { s: i, l: n, a: o } = e;
    let r, a, l;
    if (i === 0)
      r = a = l = n;
    else {
      const c = n < 0.5 ? n * (1 + i) : n + i - n * i, d = 2 * n - c;
      r = Wo._hue2rgb(d, c, t + 1 / 3), a = Wo._hue2rgb(d, c, t), l = Wo._hue2rgb(d, c, t - 1 / 3);
    }
    return new qe(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), o);
  }
}
class _a {
  constructor(e, t, i, n) {
    this._hsvaBrand = void 0, this.h = Math.max(Math.min(360, e), 0) | 0, this.s = Wc(Math.max(Math.min(1, t), 0), 3), this.v = Wc(Math.max(Math.min(1, i), 0), 3), this.a = Wc(Math.max(Math.min(1, n), 0), 3);
  }
  static equals(e, t) {
    return e.h === t.h && e.s === t.s && e.v === t.v && e.a === t.a;
  }
  // from http://www.rapidtables.com/convert/color/rgb-to-hsv.htm
  static fromRGBA(e) {
    const t = e.r / 255, i = e.g / 255, n = e.b / 255, o = Math.max(t, i, n), r = Math.min(t, i, n), a = o - r, l = o === 0 ? 0 : a / o;
    let c;
    return a === 0 ? c = 0 : o === t ? c = ((i - n) / a % 6 + 6) % 6 : o === i ? c = (n - t) / a + 2 : c = (t - i) / a + 4, new _a(Math.round(c * 60), l, o, e.a);
  }
  // from http://www.rapidtables.com/convert/color/hsv-to-rgb.htm
  static toRGBA(e) {
    const { h: t, s: i, v: n, a: o } = e, r = n * i, a = r * (1 - Math.abs(t / 60 % 2 - 1)), l = n - r;
    let [c, d, h] = [0, 0, 0];
    return t < 60 ? (c = r, d = a) : t < 120 ? (c = a, d = r) : t < 180 ? (d = r, h = a) : t < 240 ? (d = a, h = r) : t < 300 ? (c = a, h = r) : t <= 360 && (c = r, h = a), c = Math.round((c + l) * 255), d = Math.round((d + l) * 255), h = Math.round((h + l) * 255), new qe(c, d, h, o);
  }
}
const qt = class qt {
  static fromHex(e) {
    return qt.Format.CSS.parseHex(e) || qt.red;
  }
  static equals(e, t) {
    return !e && !t ? !0 : !e || !t ? !1 : e.equals(t);
  }
  get hsla() {
    return this._hsla ? this._hsla : Wo.fromRGBA(this.rgba);
  }
  get hsva() {
    return this._hsva ? this._hsva : _a.fromRGBA(this.rgba);
  }
  constructor(e) {
    if (e)
      if (e instanceof qe)
        this.rgba = e;
      else if (e instanceof Wo)
        this._hsla = e, this.rgba = Wo.toRGBA(e);
      else if (e instanceof _a)
        this._hsva = e, this.rgba = _a.toRGBA(e);
      else
        throw new Error("Invalid color ctor argument");
    else throw new Error("Color needs a value");
  }
  equals(e) {
    return !!e && qe.equals(this.rgba, e.rgba) && Wo.equals(this.hsla, e.hsla) && _a.equals(this.hsva, e.hsva);
  }
  /**
   * http://www.w3.org/TR/WCAG20/#relativeluminancedef
   * Returns the number in the set [0, 1]. O => Darkest Black. 1 => Lightest white.
   */
  getRelativeLuminance() {
    const e = qt._relativeLuminanceForComponent(this.rgba.r), t = qt._relativeLuminanceForComponent(this.rgba.g), i = qt._relativeLuminanceForComponent(this.rgba.b), n = 0.2126 * e + 0.7152 * t + 0.0722 * i;
    return Wc(n, 4);
  }
  static _relativeLuminanceForComponent(e) {
    const t = e / 255;
    return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
  }
  /**
   *	http://24ways.org/2010/calculating-color-contrast
   *  Return 'true' if lighter color otherwise 'false'
   */
  isLighter() {
    return (this.rgba.r * 299 + this.rgba.g * 587 + this.rgba.b * 114) / 1e3 >= 128;
  }
  isLighterThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t > i;
  }
  isDarkerThan(e) {
    const t = this.getRelativeLuminance(), i = e.getRelativeLuminance();
    return t < i;
  }
  lighten(e) {
    return new qt(new Wo(this.hsla.h, this.hsla.s, this.hsla.l + this.hsla.l * e, this.hsla.a));
  }
  darken(e) {
    return new qt(new Wo(this.hsla.h, this.hsla.s, this.hsla.l - this.hsla.l * e, this.hsla.a));
  }
  transparent(e) {
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new qt(new qe(t, i, n, o * e));
  }
  isTransparent() {
    return this.rgba.a === 0;
  }
  isOpaque() {
    return this.rgba.a === 1;
  }
  opposite() {
    return new qt(new qe(255 - this.rgba.r, 255 - this.rgba.g, 255 - this.rgba.b, this.rgba.a));
  }
  makeOpaque(e) {
    if (this.isOpaque() || e.rgba.a !== 1)
      return this;
    const { r: t, g: i, b: n, a: o } = this.rgba;
    return new qt(new qe(e.rgba.r - o * (e.rgba.r - t), e.rgba.g - o * (e.rgba.g - i), e.rgba.b - o * (e.rgba.b - n), 1));
  }
  toString() {
    return this._toString || (this._toString = qt.Format.CSS.format(this)), this._toString;
  }
  static getLighterColor(e, t, i) {
    if (e.isLighterThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (o - n) / o, e.lighten(i);
  }
  static getDarkerColor(e, t, i) {
    if (e.isDarkerThan(t))
      return e;
    i = i || 0.5;
    const n = e.getRelativeLuminance(), o = t.getRelativeLuminance();
    return i = i * (n - o) / n, e.darken(i);
  }
};
qt.white = new qt(new qe(255, 255, 255, 1)), qt.black = new qt(new qe(0, 0, 0, 1)), qt.red = new qt(new qe(255, 0, 0, 1)), qt.blue = new qt(new qe(0, 0, 255, 1)), qt.green = new qt(new qe(0, 255, 0, 1)), qt.cyan = new qt(new qe(0, 255, 255, 1)), qt.lightgrey = new qt(new qe(211, 211, 211, 1)), qt.transparent = new qt(new qe(0, 0, 0, 0));
let Y = qt;
(function(s) {
  (function(e) {
    (function(t) {
      function i(g) {
        return g.rgba.a === 1 ? `rgb(${g.rgba.r}, ${g.rgba.g}, ${g.rgba.b})` : s.Format.CSS.formatRGBA(g);
      }
      t.formatRGB = i;
      function n(g) {
        return `rgba(${g.rgba.r}, ${g.rgba.g}, ${g.rgba.b}, ${+g.rgba.a.toFixed(2)})`;
      }
      t.formatRGBA = n;
      function o(g) {
        return g.hsla.a === 1 ? `hsl(${g.hsla.h}, ${(g.hsla.s * 100).toFixed(2)}%, ${(g.hsla.l * 100).toFixed(2)}%)` : s.Format.CSS.formatHSLA(g);
      }
      t.formatHSL = o;
      function r(g) {
        return `hsla(${g.hsla.h}, ${(g.hsla.s * 100).toFixed(2)}%, ${(g.hsla.l * 100).toFixed(2)}%, ${g.hsla.a.toFixed(2)})`;
      }
      t.formatHSLA = r;
      function a(g) {
        const m = g.toString(16);
        return m.length !== 2 ? "0" + m : m;
      }
      function l(g) {
        return `#${a(g.rgba.r)}${a(g.rgba.g)}${a(g.rgba.b)}`;
      }
      t.formatHex = l;
      function c(g, m = !1) {
        return m && g.rgba.a === 1 ? s.Format.CSS.formatHex(g) : `#${a(g.rgba.r)}${a(g.rgba.g)}${a(g.rgba.b)}${a(Math.round(g.rgba.a * 255))}`;
      }
      t.formatHexA = c;
      function d(g) {
        return g.isOpaque() ? s.Format.CSS.formatHex(g) : s.Format.CSS.formatRGBA(g);
      }
      t.format = d;
      function h(g) {
        const m = g.length;
        if (m === 0 || g.charCodeAt(0) !== 35)
          return null;
        if (m === 7) {
          const p = 16 * u(g.charCodeAt(1)) + u(g.charCodeAt(2)), A = 16 * u(g.charCodeAt(3)) + u(g.charCodeAt(4)), _ = 16 * u(g.charCodeAt(5)) + u(g.charCodeAt(6));
          return new s(new qe(p, A, _, 1));
        }
        if (m === 9) {
          const p = 16 * u(g.charCodeAt(1)) + u(g.charCodeAt(2)), A = 16 * u(g.charCodeAt(3)) + u(g.charCodeAt(4)), _ = 16 * u(g.charCodeAt(5)) + u(g.charCodeAt(6)), b = 16 * u(g.charCodeAt(7)) + u(g.charCodeAt(8));
          return new s(new qe(p, A, _, b / 255));
        }
        if (m === 4) {
          const p = u(g.charCodeAt(1)), A = u(g.charCodeAt(2)), _ = u(g.charCodeAt(3));
          return new s(new qe(16 * p + p, 16 * A + A, 16 * _ + _));
        }
        if (m === 5) {
          const p = u(g.charCodeAt(1)), A = u(g.charCodeAt(2)), _ = u(g.charCodeAt(3)), b = u(g.charCodeAt(4));
          return new s(new qe(16 * p + p, 16 * A + A, 16 * _ + _, (16 * b + b) / 255));
        }
        return null;
      }
      t.parseHex = h;
      function u(g) {
        switch (g) {
          case 48:
            return 0;
          case 49:
            return 1;
          case 50:
            return 2;
          case 51:
            return 3;
          case 52:
            return 4;
          case 53:
            return 5;
          case 54:
            return 6;
          case 55:
            return 7;
          case 56:
            return 8;
          case 57:
            return 9;
          case 97:
            return 10;
          case 65:
            return 10;
          case 98:
            return 11;
          case 66:
            return 11;
          case 99:
            return 12;
          case 67:
            return 12;
          case 100:
            return 13;
          case 68:
            return 13;
          case 101:
            return 14;
          case 69:
            return 14;
          case 102:
            return 15;
          case 70:
            return 15;
        }
        return 0;
      }
    })(e.CSS || (e.CSS = {}));
  })(s.Format || (s.Format = {}));
})(Y || (Y = {}));
function x5(s) {
  const e = [];
  for (const t of s) {
    const i = Number(t);
    (i || i === 0 && t.replace(/\s/g, "") !== "") && e.push(i);
  }
  return e;
}
function lN(s, e, t, i) {
  return {
    red: s / 255,
    blue: t / 255,
    green: e / 255,
    alpha: i
  };
}
function Km(s, e) {
  const t = e.index, i = e[0].length;
  if (!t)
    return;
  const n = s.positionAt(t);
  return {
    startLineNumber: n.lineNumber,
    startColumn: n.column,
    endLineNumber: n.lineNumber,
    endColumn: n.column + i
  };
}
function RG(s, e) {
  if (!s)
    return;
  const t = Y.Format.CSS.parseHex(e);
  if (t)
    return {
      range: s,
      color: lN(t.rgba.r, t.rgba.g, t.rgba.b, t.rgba.a)
    };
}
function n2(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = x5(n);
  return {
    range: s,
    color: lN(o[0], o[1], o[2], t ? o[3] : 1)
  };
}
function s2(s, e, t) {
  if (!s || e.length !== 1)
    return;
  const n = e[0].values(), o = x5(n), r = new Y(new Wo(o[0], o[1] / 100, o[2] / 100, t ? o[3] : 1));
  return {
    range: s,
    color: lN(r.rgba.r, r.rgba.g, r.rgba.b, r.rgba.a)
  };
}
function Jm(s, e) {
  return typeof s == "string" ? [...s.matchAll(e)] : s.findMatches(e);
}
function FG(s) {
  const e = [], i = Jm(s, /\b(rgb|rgba|hsl|hsla)(\([0-9\s,.\%]*\))|(#)([A-Fa-f0-9]{3})\b|(#)([A-Fa-f0-9]{4})\b|(#)([A-Fa-f0-9]{6})\b|(#)([A-Fa-f0-9]{8})\b/gm);
  if (i.length > 0)
    for (const n of i) {
      const o = n.filter((c) => c !== void 0), r = o[1], a = o[2];
      if (!a)
        continue;
      let l;
      if (r === "rgb") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*\)$/gm;
        l = n2(Km(s, n), Jm(a, c), !1);
      } else if (r === "rgba") {
        const c = /^\(\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = n2(Km(s, n), Jm(a, c), !0);
      } else if (r === "hsl") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*\)$/gm;
        l = s2(Km(s, n), Jm(a, c), !1);
      } else if (r === "hsla") {
        const c = /^\(\s*(36[0]|3[0-5][0-9]|[12][0-9][0-9]|[1-9]?[0-9])\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(100|\d{1,2}[.]\d*|\d{1,2})%\s*,\s*(0[.][0-9]+|[.][0-9]+|[01][.]|[01])\s*\)$/gm;
        l = s2(Km(s, n), Jm(a, c), !0);
      } else r === "#" && (l = RG(Km(s, n), r + a));
      l && e.push(l);
    }
  return e;
}
function OG(s) {
  return !s || typeof s.getValue != "function" || typeof s.positionAt != "function" ? [] : FG(s);
}
const o2 = new RegExp("\\bMARK:\\s*(.*)$", "d"), PG = /^-+|-+$/g;
function HG(s, e) {
  let t = [];
  if (e.findRegionSectionHeaders && e.foldingRules?.markers) {
    const i = WG(s, e);
    t = t.concat(i);
  }
  if (e.findMarkSectionHeaders) {
    const i = VG(s);
    t = t.concat(i);
  }
  return t;
}
function WG(s, e) {
  const t = [], i = s.getLineCount();
  for (let n = 1; n <= i; n++) {
    const o = s.getLineContent(n), r = o.match(e.foldingRules.markers.start);
    if (r) {
      const a = { startLineNumber: n, startColumn: r[0].length + 1, endLineNumber: n, endColumn: o.length + 1 };
      if (a.endColumn > a.startColumn) {
        const l = {
          range: a,
          ...E5(o.substring(r[0].length)),
          shouldBeInComments: !1
        };
        (l.text || l.hasSeparatorLine) && t.push(l);
      }
    }
  }
  return t;
}
function VG(s) {
  const e = [], t = s.getLineCount();
  for (let i = 1; i <= t; i++) {
    const n = s.getLineContent(i);
    zG(n, i, e);
  }
  return e;
}
function zG(s, e, t) {
  o2.lastIndex = 0;
  const i = o2.exec(s);
  if (i) {
    const n = i.indices[1][0] + 1, o = i.indices[1][1] + 1, r = { startLineNumber: e, startColumn: n, endLineNumber: e, endColumn: o };
    if (r.endColumn > r.startColumn) {
      const a = {
        range: r,
        ...E5(i[1]),
        shouldBeInComments: !0
      };
      (a.text || a.hasSeparatorLine) && t.push(a);
    }
  }
}
function E5(s) {
  s = s.trim();
  const e = s.startsWith("-");
  return s = s.replace(PG, ""), { text: s, hasSeparatorLine: e };
}
class UG {
  constructor(e) {
    this.values = e, this.prefixSum = new Uint32Array(e.length), this.prefixSumValidIndex = new Int32Array(1), this.prefixSumValidIndex[0] = -1;
  }
  insertValues(e, t) {
    e = ag(e);
    const i = this.values, n = this.prefixSum, o = t.length;
    return o === 0 ? !1 : (this.values = new Uint32Array(i.length + o), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e), e + o), this.values.set(t, e), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSum = new Uint32Array(this.values.length), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  setValue(e, t) {
    return e = ag(e), t = ag(t), this.values[e] === t ? !1 : (this.values[e] = t, e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), !0);
  }
  removeValues(e, t) {
    e = ag(e), t = ag(t);
    const i = this.values, n = this.prefixSum;
    if (e >= i.length)
      return !1;
    const o = i.length - e;
    return t >= o && (t = o), t === 0 ? !1 : (this.values = new Uint32Array(i.length - t), this.values.set(i.subarray(0, e), 0), this.values.set(i.subarray(e + t), e), this.prefixSum = new Uint32Array(this.values.length), e - 1 < this.prefixSumValidIndex[0] && (this.prefixSumValidIndex[0] = e - 1), this.prefixSumValidIndex[0] >= 0 && this.prefixSum.set(n.subarray(0, this.prefixSumValidIndex[0] + 1)), !0);
  }
  getTotalSum() {
    return this.values.length === 0 ? 0 : this._getPrefixSum(this.values.length - 1);
  }
  /**
   * Returns the sum of the first `index + 1` many items.
   * @returns `SUM(0 <= j <= index, values[j])`.
   */
  getPrefixSum(e) {
    return e < 0 ? 0 : (e = ag(e), this._getPrefixSum(e));
  }
  _getPrefixSum(e) {
    if (e <= this.prefixSumValidIndex[0])
      return this.prefixSum[e];
    let t = this.prefixSumValidIndex[0] + 1;
    t === 0 && (this.prefixSum[0] = this.values[0], t++), e >= this.values.length && (e = this.values.length - 1);
    for (let i = t; i <= e; i++)
      this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
    return this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], e), this.prefixSum[e];
  }
  getIndexOf(e) {
    e = Math.floor(e), this.getTotalSum();
    let t = 0, i = this.values.length - 1, n = 0, o = 0, r = 0;
    for (; t <= i; )
      if (n = t + (i - t) / 2 | 0, o = this.prefixSum[n], r = o - this.values[n], e < r)
        i = n - 1;
      else if (e >= o)
        t = n + 1;
      else
        break;
    return new L5(n, e - r);
  }
}
class QG {
  constructor(e) {
    this._values = e, this._isValid = !1, this._validEndIndex = -1, this._prefixSum = [], this._indexBySum = [];
  }
  /**
   * @returns SUM(0 <= j < values.length, values[j])
   */
  getTotalSum() {
    return this._ensureValid(), this._indexBySum.length;
  }
  /**
   * Returns the sum of the first `count` many items.
   * @returns `SUM(0 <= j < count, values[j])`.
   */
  getPrefixSum(e) {
    return this._ensureValid(), e === 0 ? 0 : this._prefixSum[e - 1];
  }
  /**
   * @returns `result`, such that `getPrefixSum(result.index) + result.remainder = sum`
   */
  getIndexOf(e) {
    this._ensureValid();
    const t = this._indexBySum[e], i = t > 0 ? this._prefixSum[t - 1] : 0;
    return new L5(t, e - i);
  }
  removeValues(e, t) {
    this._values.splice(e, t), this._invalidate(e);
  }
  insertValues(e, t) {
    this._values = f0(this._values, e, t), this._invalidate(e);
  }
  _invalidate(e) {
    this._isValid = !1, this._validEndIndex = Math.min(this._validEndIndex, e - 1);
  }
  _ensureValid() {
    if (!this._isValid) {
      for (let e = this._validEndIndex + 1, t = this._values.length; e < t; e++) {
        const i = this._values[e], n = e > 0 ? this._prefixSum[e - 1] : 0;
        this._prefixSum[e] = n + i;
        for (let o = 0; o < i; o++)
          this._indexBySum[n + o] = e;
      }
      this._prefixSum.length = this._values.length, this._indexBySum.length = this._prefixSum[this._prefixSum.length - 1], this._isValid = !0, this._validEndIndex = this._values.length - 1;
    }
  }
  setValue(e, t) {
    this._values[e] !== t && (this._values[e] = t, this._invalidate(e));
  }
}
class L5 {
  constructor(e, t) {
    this.index = e, this.remainder = t, this._prefixSumIndexOfResultBrand = void 0, this.index = e, this.remainder = t;
  }
}
class GG {
  constructor(e, t, i, n) {
    this._uri = e, this._lines = t, this._eol = i, this._versionId = n, this._lineStarts = null, this._cachedTextValue = null;
  }
  dispose() {
    this._lines.length = 0;
  }
  get version() {
    return this._versionId;
  }
  getText() {
    return this._cachedTextValue === null && (this._cachedTextValue = this._lines.join(this._eol)), this._cachedTextValue;
  }
  onEvents(e) {
    e.eol && e.eol !== this._eol && (this._eol = e.eol, this._lineStarts = null);
    const t = e.changes;
    for (const i of t)
      this._acceptDeleteRange(i.range), this._acceptInsertText(new F(i.range.startLineNumber, i.range.startColumn), i.text);
    this._versionId = e.versionId, this._cachedTextValue = null;
  }
  _ensureLineStarts() {
    if (!this._lineStarts) {
      const e = this._eol.length, t = this._lines.length, i = new Uint32Array(t);
      for (let n = 0; n < t; n++)
        i[n] = this._lines[n].length + e;
      this._lineStarts = new UG(i);
    }
  }
  /**
   * All changes to a line's text go through this method
   */
  _setLineText(e, t) {
    this._lines[e] = t, this._lineStarts && this._lineStarts.setValue(e, this._lines[e].length + this._eol.length);
  }
  _acceptDeleteRange(e) {
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.startLineNumber - 1].substring(e.endColumn - 1));
      return;
    }
    this._setLineText(e.startLineNumber - 1, this._lines[e.startLineNumber - 1].substring(0, e.startColumn - 1) + this._lines[e.endLineNumber - 1].substring(e.endColumn - 1)), this._lines.splice(e.startLineNumber, e.endLineNumber - e.startLineNumber), this._lineStarts && this._lineStarts.removeValues(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t) {
    if (t.length === 0)
      return;
    const i = bd(t);
    if (i.length === 1) {
      this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0] + this._lines[e.lineNumber - 1].substring(e.column - 1));
      return;
    }
    i[i.length - 1] += this._lines[e.lineNumber - 1].substring(e.column - 1), this._setLineText(e.lineNumber - 1, this._lines[e.lineNumber - 1].substring(0, e.column - 1) + i[0]);
    const n = new Uint32Array(i.length - 1);
    for (let o = 1; o < i.length; o++)
      this._lines.splice(e.lineNumber + o - 1, 0, i[o]), n[o - 1] = i[o].length + this._eol.length;
    this._lineStarts && this._lineStarts.insertValues(e.lineNumber, n);
  }
}
const r2 = 60 * 1e3;
class jG extends V {
  constructor(e, t, i = !1) {
    if (super(), this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), this._proxy = e, this._modelService = t, !i) {
      const n = new QM();
      n.cancelAndSet(() => this._checkStopModelSync(), Math.round(r2 / 2)), this._register(n);
    }
  }
  dispose() {
    for (const e in this._syncedModels)
      Ct(this._syncedModels[e]);
    this._syncedModels = /* @__PURE__ */ Object.create(null), this._syncedModelsLastUsedTime = /* @__PURE__ */ Object.create(null), super.dispose();
  }
  ensureSyncedResources(e, t = !1) {
    for (const i of e) {
      const n = i.toString();
      this._syncedModels[n] || this._beginModelSync(i, t), this._syncedModels[n] && (this._syncedModelsLastUsedTime[n] = (/* @__PURE__ */ new Date()).getTime());
    }
  }
  _checkStopModelSync() {
    const e = (/* @__PURE__ */ new Date()).getTime(), t = [];
    for (const i in this._syncedModelsLastUsedTime)
      e - this._syncedModelsLastUsedTime[i] > r2 && t.push(i);
    for (const i of t)
      this._stopModelSync(i);
  }
  _beginModelSync(e, t) {
    const i = this._modelService.getModel(e);
    if (!i || !t && i.isTooLargeForSyncing())
      return;
    const n = e.toString();
    this._proxy.$acceptNewModel({
      url: i.uri.toString(),
      lines: i.getLinesContent(),
      EOL: i.getEOL(),
      versionId: i.getVersionId()
    });
    const o = new X();
    o.add(i.onDidChangeContent((r) => {
      this._proxy.$acceptModelChanged(n.toString(), r);
    })), o.add(i.onWillDispose(() => {
      this._stopModelSync(n);
    })), o.add(we(() => {
      this._proxy.$acceptRemovedModel(n);
    })), this._syncedModels[n] = o;
  }
  _stopModelSync(e) {
    const t = this._syncedModels[e];
    delete this._syncedModels[e], delete this._syncedModelsLastUsedTime[e], Ct(t);
  }
}
class YG {
  constructor() {
    this._models = /* @__PURE__ */ Object.create(null);
  }
  getModel(e) {
    return this._models[e];
  }
  getModels() {
    const e = [];
    return Object.keys(this._models).forEach((t) => e.push(this._models[t])), e;
  }
  $acceptNewModel(e) {
    this._models[e.url] = new KG(_e.parse(e.url), e.lines, e.EOL, e.versionId);
  }
  $acceptModelChanged(e, t) {
    if (!this._models[e])
      return;
    this._models[e].onEvents(t);
  }
  $acceptRemovedModel(e) {
    this._models[e] && delete this._models[e];
  }
}
class KG extends GG {
  get uri() {
    return this._uri;
  }
  get eol() {
    return this._eol;
  }
  getValue() {
    return this.getText();
  }
  findMatches(e) {
    const t = [];
    for (let i = 0; i < this._lines.length; i++) {
      const n = this._lines[i], o = this.offsetAt(new F(i + 1, 1)), r = n.matchAll(e);
      for (const a of r)
        (a.index || a.index === 0) && (a.index = a.index + o), t.push(a);
    }
    return t;
  }
  getLinesContent() {
    return this._lines.slice(0);
  }
  getLineCount() {
    return this._lines.length;
  }
  getLineContent(e) {
    return this._lines[e - 1];
  }
  getWordAtPosition(e, t) {
    const i = SA(e.column, LM(t), this._lines[e.lineNumber - 1], 0);
    return i ? new E(e.lineNumber, i.startColumn, e.lineNumber, i.endColumn) : null;
  }
  words(e) {
    const t = this._lines, i = this._wordenize.bind(this);
    let n = 0, o = "", r = 0, a = [];
    return {
      *[Symbol.iterator]() {
        for (; ; )
          if (r < a.length) {
            const l = o.substring(a[r].start, a[r].end);
            r += 1, yield l;
          } else if (n < t.length)
            o = t[n], a = i(o, e), r = 0, n += 1;
          else
            break;
      }
    };
  }
  getLineWords(e, t) {
    const i = this._lines[e - 1], n = this._wordenize(i, t), o = [];
    for (const r of n)
      o.push({
        word: i.substring(r.start, r.end),
        startColumn: r.start + 1,
        endColumn: r.end + 1
      });
    return o;
  }
  _wordenize(e, t) {
    const i = [];
    let n;
    for (t.lastIndex = 0; (n = t.exec(e)) && n[0].length !== 0; )
      i.push({ start: n.index, end: n.index + n[0].length });
    return i;
  }
  getValueInRange(e) {
    if (e = this._validateRange(e), e.startLineNumber === e.endLineNumber)
      return this._lines[e.startLineNumber - 1].substring(e.startColumn - 1, e.endColumn - 1);
    const t = this._eol, i = e.startLineNumber - 1, n = e.endLineNumber - 1, o = [];
    o.push(this._lines[i].substring(e.startColumn - 1));
    for (let r = i + 1; r < n; r++)
      o.push(this._lines[r]);
    return o.push(this._lines[n].substring(0, e.endColumn - 1)), o.join(t);
  }
  offsetAt(e) {
    return e = this._validatePosition(e), this._ensureLineStarts(), this._lineStarts.getPrefixSum(e.lineNumber - 2) + (e.column - 1);
  }
  positionAt(e) {
    e = Math.floor(e), e = Math.max(0, e), this._ensureLineStarts();
    const t = this._lineStarts.getIndexOf(e), i = this._lines[t.index].length;
    return {
      lineNumber: 1 + t.index,
      column: 1 + Math.min(t.remainder, i)
    };
  }
  _validateRange(e) {
    const t = this._validatePosition({ lineNumber: e.startLineNumber, column: e.startColumn }), i = this._validatePosition({ lineNumber: e.endLineNumber, column: e.endColumn });
    return t.lineNumber !== e.startLineNumber || t.column !== e.startColumn || i.lineNumber !== e.endLineNumber || i.column !== e.endColumn ? {
      startLineNumber: t.lineNumber,
      startColumn: t.column,
      endLineNumber: i.lineNumber,
      endColumn: i.column
    } : e;
  }
  _validatePosition(e) {
    if (!F.isIPosition(e))
      throw new Error("bad position");
    let { lineNumber: t, column: i } = e, n = !1;
    if (t < 1)
      t = 1, i = 1, n = !0;
    else if (t > this._lines.length)
      t = this._lines.length, i = this._lines[t - 1].length + 1, n = !0;
    else {
      const o = this._lines[t - 1].length + 1;
      i < 1 ? (i = 1, n = !0) : i > o && (i = o, n = !0);
    }
    return n ? { lineNumber: t, column: i } : e;
  }
}
const S1 = class S1 {
  constructor() {
    this._workerTextModelSyncServer = new YG();
  }
  dispose() {
  }
  _getModel(e) {
    return this._workerTextModelSyncServer.getModel(e);
  }
  _getModels() {
    return this._workerTextModelSyncServer.getModels();
  }
  $acceptNewModel(e) {
    this._workerTextModelSyncServer.$acceptNewModel(e);
  }
  $acceptModelChanged(e, t) {
    this._workerTextModelSyncServer.$acceptModelChanged(e, t);
  }
  $acceptRemovedModel(e) {
    this._workerTextModelSyncServer.$acceptRemovedModel(e);
  }
  async $computeUnicodeHighlights(e, t, i) {
    const n = this._getModel(e);
    return n ? eG.computeUnicodeHighlights(n, t, i) : { ranges: [], hasMore: !1, ambiguousCharacterCount: 0, invisibleCharacterCount: 0, nonBasicAsciiCharacterCount: 0 };
  }
  async $findSectionHeaders(e, t) {
    const i = this._getModel(e);
    return i ? HG(i, t) : [];
  }
  // ---- BEGIN diff --------------------------------------------------------------------------
  async $computeDiff(e, t, i, n) {
    const o = this._getModel(e), r = this._getModel(t);
    return !o || !r ? null : ww.computeDiff(o, r, i, n);
  }
  static computeDiff(e, t, i, n) {
    const o = n === "advanced" ? i2.getDefault() : i2.getLegacy(), r = e.getLinesContent(), a = t.getLinesContent(), l = o.computeDiff(r, a, i), c = l.changes.length > 0 ? !1 : this._modelsAreIdentical(e, t);
    function d(h) {
      return h.map((u) => [u.original.startLineNumber, u.original.endLineNumberExclusive, u.modified.startLineNumber, u.modified.endLineNumberExclusive, u.innerChanges?.map((g) => [
        g.originalRange.startLineNumber,
        g.originalRange.startColumn,
        g.originalRange.endLineNumber,
        g.originalRange.endColumn,
        g.modifiedRange.startLineNumber,
        g.modifiedRange.startColumn,
        g.modifiedRange.endLineNumber,
        g.modifiedRange.endColumn
      ])]);
    }
    return {
      identical: c,
      quitEarly: l.hitTimeout,
      changes: d(l.changes),
      moves: l.moves.map((h) => [
        h.lineRangeMapping.original.startLineNumber,
        h.lineRangeMapping.original.endLineNumberExclusive,
        h.lineRangeMapping.modified.startLineNumber,
        h.lineRangeMapping.modified.endLineNumberExclusive,
        d(h.changes)
      ])
    };
  }
  static _modelsAreIdentical(e, t) {
    const i = e.getLineCount(), n = t.getLineCount();
    if (i !== n)
      return !1;
    for (let o = 1; o <= i; o++) {
      const r = e.getLineContent(o), a = t.getLineContent(o);
      if (r !== a)
        return !1;
    }
    return !0;
  }
  async $computeMoreMinimalEdits(e, t, i) {
    const n = this._getModel(e);
    if (!n)
      return t;
    const o = [];
    let r;
    t = t.slice(0).sort((l, c) => {
      if (l.range && c.range)
        return E.compareRangesUsingStarts(l.range, c.range);
      const d = l.range ? 0 : 1, h = c.range ? 0 : 1;
      return d - h;
    });
    let a = 0;
    for (let l = 1; l < t.length; l++)
      E.getEndPosition(t[a].range).equals(E.getStartPosition(t[l].range)) ? (t[a].range = E.fromPositions(E.getStartPosition(t[a].range), E.getEndPosition(t[l].range)), t[a].text += t[l].text) : (a++, t[a] = t[l]);
    t.length = a + 1;
    for (let { range: l, text: c, eol: d } of t) {
      if (typeof d == "number" && (r = d), E.isEmpty(l) && !c)
        continue;
      const h = n.getValueInRange(l);
      if (c = c.replace(/\r\n|\n|\r/g, n.eol), h === c)
        continue;
      if (Math.max(c.length, h.length) > ww._diffLimit) {
        o.push({ range: l, text: c });
        continue;
      }
      const u = BQ(h, c, i), g = n.offsetAt(E.lift(l).getStartPosition());
      for (const m of u) {
        const p = n.positionAt(g + m.originalStart), A = n.positionAt(g + m.originalStart + m.originalLength), _ = {
          text: c.substr(m.modifiedStart, m.modifiedLength),
          range: { startLineNumber: p.lineNumber, startColumn: p.column, endLineNumber: A.lineNumber, endColumn: A.column }
        };
        n.getValueInRange(_.range) !== _.text && o.push(_);
      }
    }
    return typeof r == "number" && o.push({ eol: r, text: "", range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } }), o;
  }
  // ---- END minimal edits ---------------------------------------------------------------
  async $computeLinks(e) {
    const t = this._getModel(e);
    return t ? HQ(t) : null;
  }
  // --- BEGIN default document colors -----------------------------------------------------------
  async $computeDefaultDocumentColors(e) {
    const t = this._getModel(e);
    return t ? OG(t) : null;
  }
  async $textualSuggest(e, t, i, n) {
    const o = new es(), r = new RegExp(i, n), a = /* @__PURE__ */ new Set();
    e: for (const l of e) {
      const c = this._getModel(l);
      if (c) {
        for (const d of c.words(r))
          if (!(d === t || !isNaN(Number(d))) && (a.add(d), a.size > ww._suggestionsLimit))
            break e;
      }
    }
    return { words: Array.from(a), duration: o.elapsed() };
  }
  // ---- END suggest --------------------------------------------------------------------------
  //#region -- word ranges --
  async $computeWordRanges(e, t, i, n) {
    const o = this._getModel(e);
    if (!o)
      return /* @__PURE__ */ Object.create(null);
    const r = new RegExp(i, n), a = /* @__PURE__ */ Object.create(null);
    for (let l = t.startLineNumber; l < t.endLineNumber; l++) {
      const c = o.getLineWords(l, r);
      for (const d of c) {
        if (!isNaN(Number(d.word)))
          continue;
        let h = a[d.word];
        h || (h = [], a[d.word] = h), h.push({
          startLineNumber: l,
          startColumn: d.startColumn,
          endLineNumber: l,
          endColumn: d.endColumn
        });
      }
    }
    return a;
  }
  //#endregion
  async $navigateValueSet(e, t, i, n, o) {
    const r = this._getModel(e);
    if (!r)
      return null;
    const a = new RegExp(n, o);
    t.startColumn === t.endColumn && (t = {
      startLineNumber: t.startLineNumber,
      startColumn: t.startColumn,
      endLineNumber: t.endLineNumber,
      endColumn: t.endColumn + 1
    });
    const l = r.getValueInRange(t), c = r.getWordAtPosition({ lineNumber: t.startLineNumber, column: t.startColumn }, a);
    if (!c)
      return null;
    const d = r.getValueInRange(c);
    return iL.INSTANCE.navigateValueSet(t, l, c, d, i);
  }
};
S1._diffLimit = 1e5, S1._suggestionsLimit = 1e4;
let lL = S1;
class ww extends lL {
  constructor(e, t) {
    super(), this._host = e, this._foreignModuleFactory = t, this._foreignModule = null;
  }
  async $ping() {
    return "pong";
  }
  // ---- BEGIN foreign module support --------------------------------------------------------------------------
  $loadForeignModule(e, t, i) {
    const r = {
      host: I9(i, (a, l) => this._host.$fhr(a, l)),
      getMirrorModels: () => this._getModels()
    };
    return this._foreignModuleFactory ? (this._foreignModule = this._foreignModuleFactory(r, t), Promise.resolve(xx(this._foreignModule))) : new Promise((a, l) => {
      const c = (d) => {
        this._foreignModule = d.create(r, t), a(xx(this._foreignModule));
      };
      import(`${w0.asBrowserUri(`${e}.js`).toString(!0)}`).then(c).catch(l);
    });
  }
  // foreign method request
  $fmr(e, t) {
    if (!this._foreignModule || typeof this._foreignModule[e] != "function")
      return Promise.reject(new Error("Missing requestHandler or method: " + e));
    try {
      return Promise.resolve(this._foreignModule[e].apply(this._foreignModule, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
}
typeof importScripts == "function" && (globalThis.monaco = mH());
const cN = We("textResourceConfigurationService"), k5 = We("textResourcePropertiesService"), ye = We("ILanguageFeaturesService");
var dN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Xd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const a2 = 5 * 60 * 1e3;
function Zd(s, e) {
  const t = s.getModel(e);
  return !(!t || t.isTooLargeForSyncing());
}
let cL = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._languageConfigurationService = o, this._modelService = t, this._workerManager = this._register(new dL(e, this._modelService)), this._logService = n, this._register(r.linkProvider.register({ language: "*", hasAccessToAllModels: !0 }, {
      provideLinks: async (a, l) => {
        if (!Zd(this._modelService, a.uri))
          return Promise.resolve({ links: [] });
        const d = await (await this._workerWithResources([a.uri])).$computeLinks(a.uri.toString());
        return d && { links: d };
      }
    })), this._register(r.completionProvider.register("*", new JG(this._workerManager, i, this._modelService, this._languageConfigurationService)));
  }
  dispose() {
    super.dispose();
  }
  canComputeUnicodeHighlights(e) {
    return Zd(this._modelService, e);
  }
  async computedUnicodeHighlights(e, t, i) {
    return (await this._workerWithResources([e])).$computeUnicodeHighlights(e.toString(), t, i);
  }
  async computeDiff(e, t, i, n) {
    const r = await (await this._workerWithResources(
      [e, t],
      /* forceLargeModels */
      !0
    )).$computeDiff(e.toString(), t.toString(), i, n);
    if (!r)
      return null;
    return {
      identical: r.identical,
      quitEarly: r.quitEarly,
      changes: l(r.changes),
      moves: r.moves.map((c) => new b5(new Cn(new Ee(c[0], c[1]), new Ee(c[2], c[3])), l(c[4])))
    };
    function l(c) {
      return c.map((d) => new qs(new Ee(d[0], d[1]), new Ee(d[2], d[3]), d[4]?.map((h) => new Ps(new E(h[0], h[1], h[2], h[3]), new E(h[4], h[5], h[6], h[7])))));
    }
  }
  async computeMoreMinimalEdits(e, t, i = !1) {
    if (Ys(t)) {
      if (!Zd(this._modelService, e))
        return Promise.resolve(t);
      const n = es.create(), o = this._workerWithResources([e]).then((r) => r.$computeMoreMinimalEdits(e.toString(), t, i));
      return o.finally(() => this._logService.trace("FORMAT#computeMoreMinimalEdits", e.toString(!0), n.elapsed())), Promise.race([o, MA(1e3).then(() => t)]);
    } else
      return Promise.resolve(void 0);
  }
  canNavigateValueSet(e) {
    return Zd(this._modelService, e);
  }
  async navigateValueSet(e, t, i) {
    const n = this._modelService.getModel(e);
    if (!n)
      return null;
    const o = this._languageConfigurationService.getLanguageConfiguration(n.getLanguageId()).getWordDefinition(), r = o.source, a = o.flags;
    return (await this._workerWithResources([e])).$navigateValueSet(e.toString(), t, i, r, a);
  }
  canComputeWordRanges(e) {
    return Zd(this._modelService, e);
  }
  async computeWordRanges(e, t) {
    const i = this._modelService.getModel(e);
    if (!i)
      return Promise.resolve(null);
    const n = this._languageConfigurationService.getLanguageConfiguration(i.getLanguageId()).getWordDefinition(), o = n.source, r = n.flags;
    return (await this._workerWithResources([e])).$computeWordRanges(e.toString(), t, o, r);
  }
  async findSectionHeaders(e, t) {
    return (await this._workerWithResources([e])).$findSectionHeaders(e.toString(), t);
  }
  async computeDefaultDocumentColors(e) {
    return (await this._workerWithResources([e])).$computeDefaultDocumentColors(e.toString());
  }
  async _workerWithResources(e, t = !1) {
    return await (await this._workerManager.withWorker()).workerWithSyncedResources(e, t);
  }
};
cL = dN([
  Xd(1, Fi),
  Xd(2, cN),
  Xd(3, Es),
  Xd(4, tn),
  Xd(5, ye)
], cL);
class JG {
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._debugDisplayName = "wordbasedCompletions", this._workerManager = e, this._configurationService = t, this._modelService = i;
  }
  async provideCompletionItems(e, t) {
    const i = this._configurationService.getValue(e.uri, t, "editor");
    if (i.wordBasedSuggestions === "off")
      return;
    const n = [];
    if (i.wordBasedSuggestions === "currentDocument")
      Zd(this._modelService, e.uri) && n.push(e.uri);
    else
      for (const h of this._modelService.getModels())
        Zd(this._modelService, h.uri) && (h === e ? n.unshift(h.uri) : (i.wordBasedSuggestions === "allDocuments" || h.getLanguageId() === e.getLanguageId()) && n.push(h.uri));
    if (n.length === 0)
      return;
    const o = this.languageConfigurationService.getLanguageConfiguration(e.getLanguageId()).getWordDefinition(), r = e.getWordAtPosition(t), a = r ? new E(t.lineNumber, r.startColumn, t.lineNumber, r.endColumn) : E.fromPositions(t), l = a.setEndPosition(t.lineNumber, t.column), d = await (await this._workerManager.withWorker()).textualSuggest(n, r?.word, o);
    if (d)
      return {
        duration: d.duration,
        suggestions: d.words.map((h) => ({
          kind: 18,
          label: h,
          insertText: h,
          range: { insert: l, replace: a }
        }))
      };
  }
}
let dL = class extends V {
  constructor(e, t) {
    super(), this._workerDescriptor = e, this._modelService = t, this._editorWorkerClient = null, this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._register(new YM()).cancelAndSet(() => this._checkStopIdleWorker(), Math.round(a2 / 2), vt), this._register(this._modelService.onModelRemoved((n) => this._checkStopEmptyWorker()));
  }
  dispose() {
    this._editorWorkerClient && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null), super.dispose();
  }
  /**
   * Check if the model service has no more models and stop the worker if that is the case.
   */
  _checkStopEmptyWorker() {
    if (!this._editorWorkerClient)
      return;
    this._modelService.getModels().length === 0 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  /**
   * Check if the worker has been idle for a while and then stop it.
   */
  _checkStopIdleWorker() {
    if (!this._editorWorkerClient)
      return;
    (/* @__PURE__ */ new Date()).getTime() - this._lastWorkerUsedTime > a2 && (this._editorWorkerClient.dispose(), this._editorWorkerClient = null);
  }
  withWorker() {
    return this._lastWorkerUsedTime = (/* @__PURE__ */ new Date()).getTime(), this._editorWorkerClient || (this._editorWorkerClient = new AC(this._workerDescriptor, !1, this._modelService)), Promise.resolve(this._editorWorkerClient);
  }
};
dL = dN([
  Xd(1, Fi)
], dL);
class qG {
  constructor(e) {
    this._instance = e, this.proxy = this._instance;
  }
  dispose() {
    this._instance.dispose();
  }
  setChannel(e, t) {
    throw new Error("Not supported");
  }
}
let AC = class extends V {
  constructor(e, t, i) {
    super(), this._workerDescriptor = e, this._disposed = !1, this._modelService = i, this._keepIdleModels = t, this._worker = null, this._modelManager = null;
  }
  // foreign host request
  fhr(e, t) {
    throw new Error("Not implemented!");
  }
  _getOrCreateWorker() {
    if (!this._worker)
      try {
        this._worker = this._register($U(this._workerDescriptor)), nL.setChannel(this._worker, this._createEditorWorkerHost());
      } catch (e) {
        JE(e), this._worker = this._createFallbackLocalWorker();
      }
    return this._worker;
  }
  async _getProxy() {
    try {
      const e = this._getOrCreateWorker().proxy;
      return await e.$ping(), e;
    } catch (e) {
      return JE(e), this._worker = this._createFallbackLocalWorker(), this._worker.proxy;
    }
  }
  _createFallbackLocalWorker() {
    return new qG(new ww(this._createEditorWorkerHost(), null));
  }
  _createEditorWorkerHost() {
    return {
      $fhr: (e, t) => this.fhr(e, t)
    };
  }
  _getOrCreateModelManager(e) {
    return this._modelManager || (this._modelManager = this._register(new jG(e, this._modelService, this._keepIdleModels))), this._modelManager;
  }
  async workerWithSyncedResources(e, t = !1) {
    if (this._disposed)
      return Promise.reject(Oz());
    const i = await this._getProxy();
    return this._getOrCreateModelManager(i).ensureSyncedResources(e, t), i;
  }
  async textualSuggest(e, t, i) {
    const n = await this.workerWithSyncedResources(e), o = i.source, r = i.flags;
    return n.$textualSuggest(e.map((a) => a.toString()), t, o, r);
  }
  dispose() {
    super.dispose(), this._disposed = !0;
  }
};
AC = dN([
  Xd(2, Fi)
], AC);
var po;
(function(s) {
  s.DARK = "dark", s.LIGHT = "light", s.HIGH_CONTRAST_DARK = "hcDark", s.HIGH_CONTRAST_LIGHT = "hcLight";
})(po || (po = {}));
function Ca(s) {
  return s === po.HIGH_CONTRAST_DARK || s === po.HIGH_CONTRAST_LIGHT;
}
function P0(s) {
  return s === po.DARK || s === po.HIGH_CONTRAST_DARK;
}
const nn = We("themeService");
function Wi(s) {
  return { id: s };
}
function hL(s) {
  switch (s) {
    case po.DARK:
      return "vs-dark";
    case po.HIGH_CONTRAST_DARK:
      return "hc-black";
    case po.HIGH_CONTRAST_LIGHT:
      return "hc-light";
    default:
      return "vs";
  }
}
const D5 = {
  ThemingContribution: "base.contributions.theming"
};
class $G {
  constructor() {
    this.themingParticipants = [], this.themingParticipants = [], this.onThemingParticipantAddedEmitter = new B();
  }
  onColorThemeChange(e) {
    return this.themingParticipants.push(e), this.onThemingParticipantAddedEmitter.fire(e), we(() => {
      const t = this.themingParticipants.indexOf(e);
      this.themingParticipants.splice(t, 1);
    });
  }
  getThemingParticipants() {
    return this.themingParticipants;
  }
}
const I5 = new $G();
ji.add(D5.ThemingContribution, I5);
function rr(s) {
  return I5.onColorThemeChange(s);
}
class XG extends V {
  constructor(e) {
    super(), this.themeService = e, this.theme = e.getColorTheme(), this._register(this.themeService.onDidColorThemeChange((t) => this.onThemeChange(t)));
  }
  onThemeChange(e) {
    this.theme = e, this.updateStyles();
  }
  updateStyles() {
  }
}
var ZG = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ej = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let uL = class extends V {
  constructor(e) {
    super(), this._themeService = e, this._onWillCreateCodeEditor = this._register(new B()), this._onCodeEditorAdd = this._register(new B()), this.onCodeEditorAdd = this._onCodeEditorAdd.event, this._onCodeEditorRemove = this._register(new B()), this.onCodeEditorRemove = this._onCodeEditorRemove.event, this._onWillCreateDiffEditor = this._register(new B()), this._onDiffEditorAdd = this._register(new B()), this.onDiffEditorAdd = this._onDiffEditorAdd.event, this._onDiffEditorRemove = this._register(new B()), this.onDiffEditorRemove = this._onDiffEditorRemove.event, this._decorationOptionProviders = /* @__PURE__ */ new Map(), this._codeEditorOpenHandlers = new Nn(), this._modelProperties = /* @__PURE__ */ new Map(), this._codeEditors = /* @__PURE__ */ Object.create(null), this._diffEditors = /* @__PURE__ */ Object.create(null), this._globalStyleSheet = null;
  }
  willCreateCodeEditor() {
    this._onWillCreateCodeEditor.fire();
  }
  addCodeEditor(e) {
    this._codeEditors[e.getId()] = e, this._onCodeEditorAdd.fire(e);
  }
  removeCodeEditor(e) {
    delete this._codeEditors[e.getId()] && this._onCodeEditorRemove.fire(e);
  }
  listCodeEditors() {
    return Object.keys(this._codeEditors).map((e) => this._codeEditors[e]);
  }
  willCreateDiffEditor() {
    this._onWillCreateDiffEditor.fire();
  }
  addDiffEditor(e) {
    this._diffEditors[e.getId()] = e, this._onDiffEditorAdd.fire(e);
  }
  listDiffEditors() {
    return Object.keys(this._diffEditors).map((e) => this._diffEditors[e]);
  }
  getFocusedCodeEditor() {
    let e = null;
    const t = this.listCodeEditors();
    for (const i of t) {
      if (i.hasTextFocus())
        return i;
      i.hasWidgetFocus() && (e = i);
    }
    return e;
  }
  removeDecorationType(e) {
    const t = this._decorationOptionProviders.get(e);
    t && (t.refCount--, t.refCount <= 0 && (this._decorationOptionProviders.delete(e), t.dispose(), this.listCodeEditors().forEach((i) => i.removeDecorationsByType(e))));
  }
  setModelProperty(e, t, i) {
    const n = e.toString();
    let o;
    this._modelProperties.has(n) ? o = this._modelProperties.get(n) : (o = /* @__PURE__ */ new Map(), this._modelProperties.set(n, o)), o.set(t, i);
  }
  getModelProperty(e, t) {
    const i = e.toString();
    if (this._modelProperties.has(i))
      return this._modelProperties.get(i).get(t);
  }
  async openCodeEditor(e, t, i) {
    for (const n of this._codeEditorOpenHandlers) {
      const o = await n(e, t, i);
      if (o !== null)
        return o;
    }
    return null;
  }
  registerCodeEditorOpenHandler(e) {
    const t = this._codeEditorOpenHandlers.unshift(e);
    return we(t);
  }
};
uL = ZG([
  ej(0, nn)
], uL);
var tj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, l2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let _C = class extends uL {
  constructor(e, t) {
    super(t), this._register(this.onCodeEditorAdd(() => this._checkContextKey())), this._register(this.onCodeEditorRemove(() => this._checkContextKey())), this._editorIsOpen = e.createKey("editorIsOpen", !1), this._activeCodeEditor = null, this._register(this.registerCodeEditorOpenHandler(async (i, n, o) => n ? this.doOpenEditor(n, i) : null));
  }
  _checkContextKey() {
    let e = !1;
    for (const t of this.listCodeEditors())
      if (!t.isSimpleWidget) {
        e = !0;
        break;
      }
    this._editorIsOpen.set(e);
  }
  setActiveCodeEditor(e) {
    this._activeCodeEditor = e;
  }
  getActiveCodeEditor() {
    return this._activeCodeEditor;
  }
  doOpenEditor(e, t) {
    if (!this.findModel(e, t.resource)) {
      if (t.resource) {
        const o = t.resource.scheme;
        if (o === Ie.http || o === Ie.https)
          return KH(t.resource.toString()), e;
      }
      return null;
    }
    const n = t.options ? t.options.selection : null;
    if (n)
      if (typeof n.endLineNumber == "number" && typeof n.endColumn == "number")
        e.setSelection(n), e.revealRangeInCenter(
          n,
          1
          /* ScrollType.Immediate */
        );
      else {
        const o = {
          lineNumber: n.startLineNumber,
          column: n.startColumn
        };
        e.setPosition(o), e.revealPositionInCenter(
          o,
          1
          /* ScrollType.Immediate */
        );
      }
    return e;
  }
  findModel(e, t) {
    const i = e.getModel();
    return i && i.uri.toString() !== t.toString() ? null : i;
  }
};
_C = tj([
  l2(0, Se),
  l2(1, nn)
], _C);
$e(
  Nt,
  _C,
  0
  /* InstantiationType.Eager */
);
const wd = We("layoutService");
var M5 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, N5 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let bC = class {
  get mainContainer() {
    return vM(this._codeEditorService.listCodeEditors())?.getContainerDomNode() ?? vt.document.body;
  }
  get activeContainer() {
    return (this._codeEditorService.getFocusedCodeEditor() ?? this._codeEditorService.getActiveCodeEditor())?.getContainerDomNode() ?? this.mainContainer;
  }
  get mainContainerDimension() {
    return mu(this.mainContainer);
  }
  get activeContainerDimension() {
    return mu(this.activeContainer);
  }
  get containers() {
    return mm(this._codeEditorService.listCodeEditors().map((e) => e.getContainerDomNode()));
  }
  getContainer() {
    return this.activeContainer;
  }
  whenContainerStylesLoaded() {
  }
  focus() {
    this._codeEditorService.getFocusedCodeEditor()?.focus();
  }
  constructor(e) {
    this._codeEditorService = e, this.onDidLayoutMainContainer = te.None, this.onDidLayoutActiveContainer = te.None, this.onDidLayoutContainer = te.None, this.onDidChangeActiveContainer = te.None, this.onDidAddContainer = te.None, this.mainContainerOffset = { top: 0, quickPickTop: 0 }, this.activeContainerOffset = { top: 0, quickPickTop: 0 };
  }
};
bC = M5([
  N5(0, Nt)
], bC);
let gL = class extends bC {
  get mainContainer() {
    return this._container;
  }
  constructor(e, t) {
    super(t), this._container = e;
  }
};
gL = M5([
  N5(1, Nt)
], gL);
$e(
  wd,
  bC,
  1
  /* InstantiationType.Delayed */
);
var HA;
(function(s) {
  s[s.Ignore = 0] = "Ignore", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error";
})(HA || (HA = {}));
(function(s) {
  const e = "error", t = "warning", i = "warn", n = "info", o = "ignore";
  function r(l) {
    return l ? Mg(e, l) ? s.Error : Mg(t, l) || Mg(i, l) ? s.Warning : Mg(n, l) ? s.Info : s.Ignore : s.Ignore;
  }
  s.fromValue = r;
  function a(l) {
    switch (l) {
      case s.Error:
        return e;
      case s.Warning:
        return t;
      case s.Info:
        return n;
      default:
        return o;
    }
  }
  s.toString = a;
})(HA || (HA = {}));
const ii = HA, T5 = We("dialogService");
var H0 = ii;
const Oi = We("notificationService");
class ij {
}
const hN = We("undoRedoService");
class B5 {
  constructor(e, t) {
    this.resource = e, this.elements = t;
  }
}
const tf = class tf {
  constructor() {
    this.id = tf._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
tf._ID = 0, tf.None = new tf();
let fL = tf;
const nf = class nf {
  constructor() {
    this.id = nf._ID++, this.order = 1;
  }
  nextOrder() {
    return this.id === 0 ? 0 : this.order++;
  }
};
nf._ID = 0, nf.None = new nf();
let eh = nf;
var nj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, c2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function pb(s) {
  return s.scheme === Ie.file ? s.fsPath : s.path;
}
let R5 = 0;
class Ab {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++R5, this.type = 0, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabel = t, this.strResource = i, this.resourceLabels = [this.resourceLabel], this.strResources = [this.strResource], this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.isValid = !0;
  }
  setValid(e) {
    this.isValid = e;
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.isValid ? "  VALID" : "INVALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class d2 {
  constructor(e, t) {
    this.resourceLabel = e, this.reason = t;
  }
}
class h2 {
  constructor() {
    this.elements = /* @__PURE__ */ new Map();
  }
  createMessage() {
    const e = [], t = [];
    for (const [, n] of this.elements)
      (n.reason === 0 ? e : t).push(n.resourceLabel);
    const i = [];
    return e.length > 0 && i.push(f({ key: "externalRemoval", comment: ["{0} is a list of filenames"] }, "The following files have been closed and modified on disk: {0}.", e.join(", "))), t.length > 0 && i.push(f({ key: "noParallelUniverses", comment: ["{0} is a list of filenames"] }, "The following files have been modified in an incompatible way: {0}.", t.join(", "))), i.join(`
`);
  }
  get size() {
    return this.elements.size;
  }
  has(e) {
    return this.elements.has(e);
  }
  set(e, t) {
    this.elements.set(e, t);
  }
  delete(e) {
    return this.elements.delete(e);
  }
}
class sj {
  constructor(e, t, i, n, o, r, a) {
    this.id = ++R5, this.type = 1, this.actual = e, this.label = e.label, this.confirmBeforeUndo = e.confirmBeforeUndo || !1, this.resourceLabels = t, this.strResources = i, this.groupId = n, this.groupOrder = o, this.sourceId = r, this.sourceOrder = a, this.removedResources = null, this.invalidatedResources = null;
  }
  canSplit() {
    return typeof this.actual.split == "function";
  }
  removeResource(e, t, i) {
    this.removedResources || (this.removedResources = new h2()), this.removedResources.has(t) || this.removedResources.set(t, new d2(e, i));
  }
  setValid(e, t, i) {
    i ? this.invalidatedResources && (this.invalidatedResources.delete(t), this.invalidatedResources.size === 0 && (this.invalidatedResources = null)) : (this.invalidatedResources || (this.invalidatedResources = new h2()), this.invalidatedResources.has(t) || this.invalidatedResources.set(t, new d2(
      e,
      0
      /* RemovedResourceReason.ExternalRemoval */
    )));
  }
  toString() {
    return `[id:${this.id}] [group:${this.groupId}] [${this.invalidatedResources ? "INVALID" : "  VALID"}] ${this.actual.constructor.name} - ${this.actual}`;
  }
}
class F5 {
  constructor(e, t) {
    this.resourceLabel = e, this.strResource = t, this._past = [], this._future = [], this.locked = !1, this.versionId = 1;
  }
  dispose() {
    for (const e of this._past)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    for (const e of this._future)
      e.type === 1 && e.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    this.versionId++;
  }
  toString() {
    const e = [];
    e.push(`* ${this.strResource}:`);
    for (let t = 0; t < this._past.length; t++)
      e.push(`   * [UNDO] ${this._past[t]}`);
    for (let t = this._future.length - 1; t >= 0; t--)
      e.push(`   * [REDO] ${this._future[t]}`);
    return e.join(`
`);
  }
  flushAllElements() {
    this._past = [], this._future = [], this.versionId++;
  }
  _setElementValidFlag(e, t) {
    e.type === 1 ? e.setValid(this.resourceLabel, this.strResource, t) : e.setValid(t);
  }
  setElementsValidFlag(e, t) {
    for (const i of this._past)
      t(i.actual) && this._setElementValidFlag(i, e);
    for (const i of this._future)
      t(i.actual) && this._setElementValidFlag(i, e);
  }
  pushElement(e) {
    for (const t of this._future)
      t.type === 1 && t.removeResource(
        this.resourceLabel,
        this.strResource,
        1
        /* RemovedResourceReason.NoParallelUniverses */
      );
    this._future = [], this._past.push(e), this.versionId++;
  }
  createSnapshot(e) {
    const t = [];
    for (let i = 0, n = this._past.length; i < n; i++)
      t.push(this._past[i].id);
    for (let i = this._future.length - 1; i >= 0; i--)
      t.push(this._future[i].id);
    return new B5(e, t);
  }
  restoreSnapshot(e) {
    const t = e.elements.length;
    let i = !0, n = 0, o = -1;
    for (let a = 0, l = this._past.length; a < l; a++, n++) {
      const c = this._past[a];
      i && (n >= t || c.id !== e.elements[n]) && (i = !1, o = 0), !i && c.type === 1 && c.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    let r = -1;
    for (let a = this._future.length - 1; a >= 0; a--, n++) {
      const l = this._future[a];
      i && (n >= t || l.id !== e.elements[n]) && (i = !1, r = a), !i && l.type === 1 && l.removeResource(
        this.resourceLabel,
        this.strResource,
        0
        /* RemovedResourceReason.ExternalRemoval */
      );
    }
    o !== -1 && (this._past = this._past.slice(0, o)), r !== -1 && (this._future = this._future.slice(r + 1)), this.versionId++;
  }
  getElements() {
    const e = [], t = [];
    for (const i of this._past)
      e.push(i.actual);
    for (const i of this._future)
      t.push(i.actual);
    return { past: e, future: t };
  }
  getClosestPastElement() {
    return this._past.length === 0 ? null : this._past[this._past.length - 1];
  }
  getSecondClosestPastElement() {
    return this._past.length < 2 ? null : this._past[this._past.length - 2];
  }
  getClosestFutureElement() {
    return this._future.length === 0 ? null : this._future[this._future.length - 1];
  }
  hasPastElements() {
    return this._past.length > 0;
  }
  hasFutureElements() {
    return this._future.length > 0;
  }
  splitPastWorkspaceElement(e, t) {
    for (let i = this._past.length - 1; i >= 0; i--)
      if (this._past[i] === e) {
        t.has(this.strResource) ? this._past[i] = t.get(this.strResource) : this._past.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  splitFutureWorkspaceElement(e, t) {
    for (let i = this._future.length - 1; i >= 0; i--)
      if (this._future[i] === e) {
        t.has(this.strResource) ? this._future[i] = t.get(this.strResource) : this._future.splice(i, 1);
        break;
      }
    this.versionId++;
  }
  moveBackward(e) {
    this._past.pop(), this._future.push(e), this.versionId++;
  }
  moveForward(e) {
    this._future.pop(), this._past.push(e), this.versionId++;
  }
}
class by {
  constructor(e) {
    this.editStacks = e, this._versionIds = [];
    for (let t = 0, i = this.editStacks.length; t < i; t++)
      this._versionIds[t] = this.editStacks[t].versionId;
  }
  isValid() {
    for (let e = 0, t = this.editStacks.length; e < t; e++)
      if (this._versionIds[e] !== this.editStacks[e].versionId)
        return !1;
    return !0;
  }
}
const O5 = new F5("", "");
O5.locked = !0;
let mL = class {
  constructor(e, t) {
    this._dialogService = e, this._notificationService = t, this._editStacks = /* @__PURE__ */ new Map(), this._uriComparisonKeyComputers = [];
  }
  getUriComparisonKey(e) {
    for (const t of this._uriComparisonKeyComputers)
      if (t[0] === e.scheme)
        return t[1].getComparisonKey(e);
    return e.toString();
  }
  _print(e) {
    console.log("------------------------------------"), console.log(`AFTER ${e}: `);
    const t = [];
    for (const i of this._editStacks)
      t.push(i[1].toString());
    console.log(t.join(`
`));
  }
  pushElement(e, t = fL.None, i = eh.None) {
    if (e.type === 0) {
      const n = pb(e.resource), o = this.getUriComparisonKey(e.resource);
      this._pushElement(new Ab(e, n, o, t.id, t.nextOrder(), i.id, i.nextOrder()));
    } else {
      const n = /* @__PURE__ */ new Set(), o = [], r = [];
      for (const a of e.resources) {
        const l = pb(a), c = this.getUriComparisonKey(a);
        n.has(c) || (n.add(c), o.push(l), r.push(c));
      }
      o.length === 1 ? this._pushElement(new Ab(e, o[0], r[0], t.id, t.nextOrder(), i.id, i.nextOrder())) : this._pushElement(new sj(e, o, r, t.id, t.nextOrder(), i.id, i.nextOrder()));
    }
  }
  _pushElement(e) {
    for (let t = 0, i = e.strResources.length; t < i; t++) {
      const n = e.resourceLabels[t], o = e.strResources[t];
      let r;
      this._editStacks.has(o) ? r = this._editStacks.get(o) : (r = new F5(n, o), this._editStacks.set(o, r)), r.pushElement(e);
    }
  }
  getLastElement(e) {
    const t = this.getUriComparisonKey(e);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      if (i.hasFutureElements())
        return null;
      const n = i.getClosestPastElement();
      return n ? n.actual : null;
    }
    return null;
  }
  _splitPastWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = pb(o.resource), a = this.getUriComparisonKey(o.resource), l = new Ab(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitPastWorkspaceElement(e, n);
    }
  }
  _splitFutureWorkspaceElement(e, t) {
    const i = e.actual.split(), n = /* @__PURE__ */ new Map();
    for (const o of i) {
      const r = pb(o.resource), a = this.getUriComparisonKey(o.resource), l = new Ab(o, r, a, 0, 0, 0, 0);
      n.set(l.strResource, l);
    }
    for (const o of e.strResources) {
      if (t && t.has(o))
        continue;
      this._editStacks.get(o).splitFutureWorkspaceElement(e, n);
    }
  }
  removeElements(e) {
    const t = typeof e == "string" ? e : this.getUriComparisonKey(e);
    this._editStacks.has(t) && (this._editStacks.get(t).dispose(), this._editStacks.delete(t));
  }
  setElementsValidFlag(e, t, i) {
    const n = this.getUriComparisonKey(e);
    this._editStacks.has(n) && this._editStacks.get(n).setElementsValidFlag(t, i);
  }
  createSnapshot(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).createSnapshot(e) : new B5(e, []);
  }
  restoreSnapshot(e) {
    const t = this.getUriComparisonKey(e.resource);
    if (this._editStacks.has(t)) {
      const i = this._editStacks.get(t);
      i.restoreSnapshot(e), !i.hasPastElements() && !i.hasFutureElements() && (i.dispose(), this._editStacks.delete(t));
    }
  }
  getElements(e) {
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).getElements() : { past: [], future: [] };
  }
  _findClosestUndoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.sourceId === e && (!t || r.sourceOrder > t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canUndo(e) {
    if (e instanceof eh) {
      const [, i] = this._findClosestUndoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasPastElements() : !1;
  }
  _onError(e, t) {
    Pe(e);
    for (const i of t.strResources)
      this.removeElements(i);
    this._notificationService.error(e);
  }
  _acquireLocks(e) {
    for (const t of e.editStacks)
      if (t.locked)
        throw new Error("Cannot acquire edit stack lock");
    for (const t of e.editStacks)
      t.locked = !0;
    return () => {
      for (const t of e.editStacks)
        t.locked = !1;
    };
  }
  _safeInvokeWithLocks(e, t, i, n, o) {
    const r = this._acquireLocks(i);
    let a;
    try {
      a = t();
    } catch (l) {
      return r(), n.dispose(), this._onError(l, e);
    }
    return a ? a.then(() => (r(), n.dispose(), o()), (l) => (r(), n.dispose(), this._onError(l, e))) : (r(), n.dispose(), o());
  }
  async _invokeWorkspacePrepare(e) {
    if (typeof e.actual.prepareUndoRedo > "u")
      return V.None;
    const t = e.actual.prepareUndoRedo();
    return typeof t > "u" ? V.None : t;
  }
  _invokeResourcePrepare(e, t) {
    if (e.actual.type !== 1 || typeof e.actual.prepareUndoRedo > "u")
      return t(V.None);
    const i = e.actual.prepareUndoRedo();
    return i ? DM(i) ? t(i) : i.then((n) => t(n)) : t(V.None);
  }
  _getAffectedEditStacks(e) {
    const t = [];
    for (const i of e.strResources)
      t.push(this._editStacks.get(i) || O5);
    return new by(t);
  }
  _tryToSplitAndUndo(e, t, i, n) {
    if (t.canSplit())
      return this._splitPastWorkspaceElement(t, i), this._notificationService.warn(n), new _b(this._undo(e, 0, !0));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new _b();
  }
  _checkWorkspaceUndo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndUndo(e, t, t.removedResources, f({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndUndo(e, t, t.invalidatedResources, f({ key: "cannotWorkspaceUndo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not undo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestPastElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndUndo(e, t, null, f({ key: "cannotWorkspaceUndoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndUndo(e, t, null, f({ key: "cannotWorkspaceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndUndo(e, t, null, f({ key: "cannotWorkspaceUndoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not undo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceUndo(e, t, i) {
    const n = this._getAffectedEditStacks(t), o = this._checkWorkspaceUndo(
      e,
      t,
      n,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return o ? o.returnValue : this._confirmAndExecuteWorkspaceUndo(e, t, n, i);
  }
  _isPartOfUndoGroup(e) {
    if (!e.groupId)
      return !1;
    for (const [, t] of this._editStacks) {
      const i = t.getClosestPastElement();
      if (i) {
        if (i === e) {
          const n = t.getSecondClosestPastElement();
          if (n && n.groupId === e.groupId)
            return !0;
        }
        if (i.groupId === e.groupId)
          return !0;
      }
    }
    return !1;
  }
  async _confirmAndExecuteWorkspaceUndo(e, t, i, n) {
    if (t.canSplit() && !this._isPartOfUndoGroup(t)) {
      let a;
      (function(d) {
        d[d.All = 0] = "All", d[d.This = 1] = "This", d[d.Cancel = 2] = "Cancel";
      })(a || (a = {}));
      const { result: l } = await this._dialogService.prompt({
        type: ii.Info,
        message: f("confirmWorkspace", "Would you like to undo '{0}' across all files?", t.label),
        buttons: [
          {
            label: f({ key: "ok", comment: ["{0} denotes a number that is > 1, && denotes a mnemonic"] }, "&&Undo in {0} Files", i.editStacks.length),
            run: () => a.All
          },
          {
            label: f({ key: "nok", comment: ["&& denotes a mnemonic"] }, "Undo this &&File"),
            run: () => a.This
          }
        ],
        cancelButton: {
          run: () => a.Cancel
        }
      });
      if (l === a.Cancel)
        return;
      if (l === a.This)
        return this._splitPastWorkspaceElement(t, null), this._undo(e, 0, !0);
      const c = this._checkWorkspaceUndo(
        e,
        t,
        i,
        /*invalidated resources will be checked after the prepare call*/
        !1
      );
      if (c)
        return c.returnValue;
      n = !0;
    }
    let o;
    try {
      o = await this._invokeWorkspacePrepare(t);
    } catch (a) {
      return this._onError(a, t);
    }
    const r = this._checkWorkspaceUndo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (r)
      return o.dispose(), r.returnValue;
    for (const a of i.editStacks)
      a.moveBackward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.undo(), i, o, () => this._continueUndoInGroup(t.groupId, n));
  }
  _resourceUndo(e, t, i) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const n = f({ key: "cannotResourceUndoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not undo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(n);
      return;
    }
    return this._invokeResourcePrepare(t, (n) => (e.moveBackward(t), this._safeInvokeWithLocks(t, () => t.actual.undo(), new by([e]), n, () => this._continueUndoInGroup(t.groupId, i))));
  }
  _findClosestUndoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestPastElement();
      r && r.groupId === e && (!t || r.groupOrder > t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueUndoInGroup(e, t) {
    if (!e)
      return;
    const [, i] = this._findClosestUndoElementInGroup(e);
    if (i)
      return this._undo(i, 0, t);
  }
  undo(e) {
    if (e instanceof eh) {
      const [, t] = this._findClosestUndoElementWithSource(e.id);
      return t ? this._undo(t, e.id, !1) : void 0;
    }
    return typeof e == "string" ? this._undo(e, 0, !1) : this._undo(this.getUriComparisonKey(e), 0, !1);
  }
  _undo(e, t = 0, i) {
    if (!this._editStacks.has(e))
      return;
    const n = this._editStacks.get(e), o = n.getClosestPastElement();
    if (!o)
      return;
    if (o.groupId) {
      const [a, l] = this._findClosestUndoElementInGroup(o.groupId);
      if (o !== a && l)
        return this._undo(l, t, i);
    }
    if ((o.sourceId !== t || o.confirmBeforeUndo) && !i)
      return this._confirmAndContinueUndo(e, t, o);
    try {
      return o.type === 1 ? this._workspaceUndo(e, o, i) : this._resourceUndo(n, o, i);
    } finally {
    }
  }
  async _confirmAndContinueUndo(e, t, i) {
    if ((await this._dialogService.confirm({
      message: f("confirmDifferentSource", "Would you like to undo '{0}'?", i.label),
      primaryButton: f({ key: "confirmDifferentSource.yes", comment: ["&& denotes a mnemonic"] }, "&&Yes"),
      cancelButton: f("confirmDifferentSource.no", "No")
    })).confirmed)
      return this._undo(e, t, !0);
  }
  _findClosestRedoElementWithSource(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.sourceId === e && (!t || r.sourceOrder < t.sourceOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  canRedo(e) {
    if (e instanceof eh) {
      const [, i] = this._findClosestRedoElementWithSource(e.id);
      return !!i;
    }
    const t = this.getUriComparisonKey(e);
    return this._editStacks.has(t) ? this._editStacks.get(t).hasFutureElements() : !1;
  }
  _tryToSplitAndRedo(e, t, i, n) {
    if (t.canSplit())
      return this._splitFutureWorkspaceElement(t, i), this._notificationService.warn(n), new _b(this._redo(e));
    for (const o of t.strResources)
      this.removeElements(o);
    return this._notificationService.warn(n), new _b();
  }
  _checkWorkspaceRedo(e, t, i, n) {
    if (t.removedResources)
      return this._tryToSplitAndRedo(e, t, t.removedResources, f({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.removedResources.createMessage()));
    if (n && t.invalidatedResources)
      return this._tryToSplitAndRedo(e, t, t.invalidatedResources, f({ key: "cannotWorkspaceRedo", comment: ["{0} is a label for an operation. {1} is another message."] }, "Could not redo '{0}' across all files. {1}", t.label, t.invalidatedResources.createMessage()));
    const o = [];
    for (const a of i.editStacks)
      a.getClosestFutureElement() !== t && o.push(a.resourceLabel);
    if (o.length > 0)
      return this._tryToSplitAndRedo(e, t, null, f({ key: "cannotWorkspaceRedoDueToChanges", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because changes were made to {1}", t.label, o.join(", ")));
    const r = [];
    for (const a of i.editStacks)
      a.locked && r.push(a.resourceLabel);
    return r.length > 0 ? this._tryToSplitAndRedo(e, t, null, f({ key: "cannotWorkspaceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because there is already an undo or redo operation running on {1}", t.label, r.join(", "))) : i.isValid() ? null : this._tryToSplitAndRedo(e, t, null, f({ key: "cannotWorkspaceRedoDueToInMeantimeUndoRedo", comment: ["{0} is a label for an operation. {1} is a list of filenames."] }, "Could not redo '{0}' across all files because an undo or redo operation occurred in the meantime", t.label));
  }
  _workspaceRedo(e, t) {
    const i = this._getAffectedEditStacks(t), n = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*invalidated resources will be checked after the prepare call*/
      !1
    );
    return n ? n.returnValue : this._executeWorkspaceRedo(e, t, i);
  }
  async _executeWorkspaceRedo(e, t, i) {
    let n;
    try {
      n = await this._invokeWorkspacePrepare(t);
    } catch (r) {
      return this._onError(r, t);
    }
    const o = this._checkWorkspaceRedo(
      e,
      t,
      i,
      /*now also check that there are no more invalidated resources*/
      !0
    );
    if (o)
      return n.dispose(), o.returnValue;
    for (const r of i.editStacks)
      r.moveForward(t);
    return this._safeInvokeWithLocks(t, () => t.actual.redo(), i, n, () => this._continueRedoInGroup(t.groupId));
  }
  _resourceRedo(e, t) {
    if (!t.isValid) {
      e.flushAllElements();
      return;
    }
    if (e.locked) {
      const i = f({ key: "cannotResourceRedoDueToInProgressUndoRedo", comment: ["{0} is a label for an operation."] }, "Could not redo '{0}' because there is already an undo or redo operation running.", t.label);
      this._notificationService.warn(i);
      return;
    }
    return this._invokeResourcePrepare(t, (i) => (e.moveForward(t), this._safeInvokeWithLocks(t, () => t.actual.redo(), new by([e]), i, () => this._continueRedoInGroup(t.groupId))));
  }
  _findClosestRedoElementInGroup(e) {
    if (!e)
      return [null, null];
    let t = null, i = null;
    for (const [n, o] of this._editStacks) {
      const r = o.getClosestFutureElement();
      r && r.groupId === e && (!t || r.groupOrder < t.groupOrder) && (t = r, i = n);
    }
    return [t, i];
  }
  _continueRedoInGroup(e) {
    if (!e)
      return;
    const [, t] = this._findClosestRedoElementInGroup(e);
    if (t)
      return this._redo(t);
  }
  redo(e) {
    if (e instanceof eh) {
      const [, t] = this._findClosestRedoElementWithSource(e.id);
      return t ? this._redo(t) : void 0;
    }
    return typeof e == "string" ? this._redo(e) : this._redo(this.getUriComparisonKey(e));
  }
  _redo(e) {
    if (!this._editStacks.has(e))
      return;
    const t = this._editStacks.get(e), i = t.getClosestFutureElement();
    if (i) {
      if (i.groupId) {
        const [n, o] = this._findClosestRedoElementInGroup(i.groupId);
        if (i !== n && o)
          return this._redo(o);
      }
      try {
        return i.type === 1 ? this._workspaceRedo(e, i) : this._resourceRedo(t, i);
      } finally {
      }
    }
  }
};
mL = nj([
  c2(0, T5),
  c2(1, Oi)
], mL);
class _b {
  constructor(e) {
    this.returnValue = e;
  }
}
$e(
  hN,
  mL,
  1
  /* InstantiationType.Delayed */
);
function kn(s, e, t) {
  return Math.min(Math.max(s, e), t);
}
class P5 {
  constructor() {
    this._n = 1, this._val = 0;
  }
  update(e) {
    return this._val = this._val + (e - this._val) / this._n, this._n += 1, this._val;
  }
  get value() {
    return this._val;
  }
}
class oj {
  constructor(e) {
    this._n = 0, this._val = 0, this._values = [], this._index = 0, this._sum = 0, this._values = new Array(e), this._values.fill(0, 0, e);
  }
  update(e) {
    const t = this._values[this._index];
    return this._values[this._index] = e, this._index = (this._index + 1) % this._values.length, this._sum -= t, this._sum += e, this._n < this._values.length && (this._n += 1), this._val = this._sum / this._n, this._val;
  }
  get value() {
    return this._val;
  }
}
const uN = We("environmentService");
var rj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, u2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const W0 = We("ILanguageFeatureDebounceService");
var wC;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  let t = 0;
  function i(n) {
    let o = e.get(n);
    return o === void 0 && (o = ++t, e.set(n, o)), o;
  }
  s.of = i;
})(wC || (wC = {}));
class aj {
  constructor(e) {
    this._default = e;
  }
  get(e) {
    return this._default;
  }
  update(e, t) {
    return this._default;
  }
  default() {
    return this._default;
  }
}
class lj {
  constructor(e, t, i, n, o, r) {
    this._logService = e, this._name = t, this._registry = i, this._default = n, this._min = o, this._max = r, this._cache = new Vu(50, 0.7);
  }
  _key(e) {
    return e.id + this._registry.all(e).reduce((t, i) => v0(wC.of(i), t), 0);
  }
  get(e) {
    const t = this._key(e), i = this._cache.get(t);
    return i ? kn(i.value, this._min, this._max) : this.default();
  }
  update(e, t) {
    const i = this._key(e);
    let n = this._cache.get(i);
    n || (n = new oj(6), this._cache.set(i, n));
    const o = kn(n.update(t), this._min, this._max);
    return GM(e.uri, "output") || this._logService.trace(`[DEBOUNCE: ${this._name}] for ${e.uri.toString()} is ${o}ms`), o;
  }
  _overall() {
    const e = new P5();
    for (const [, t] of this._cache)
      e.update(t.value);
    return e.value;
  }
  default() {
    const e = this._overall() | 0 || this._default;
    return kn(e, this._min, this._max);
  }
}
let pL = class {
  constructor(e, t) {
    this._logService = e, this._data = /* @__PURE__ */ new Map(), this._isDev = t.isExtensionDevelopment || !t.isBuilt;
  }
  for(e, t, i) {
    const n = i?.min ?? 50, o = i?.max ?? n ** 2, r = i?.key ?? void 0, a = `${wC.of(e)},${n}${r ? "," + r : ""}`;
    let l = this._data.get(a);
    return l || (this._isDev ? (this._logService.debug(`[DEBOUNCE: ${t}] is disabled in developed mode`), l = new aj(n * 1.5)) : l = new lj(
      this._logService,
      t,
      e,
      this._overallAverage() | 0 || n * 1.5,
      // default is overall default or derived from min-value
      n,
      o
    ), this._data.set(a, l)), l;
  }
  _overallAverage() {
    const e = new P5();
    for (const t of this._data.values())
      e.update(t.default());
    return e.value;
  }
};
pL = rj([
  u2(0, Es),
  u2(1, uN)
], pL);
$e(
  W0,
  pL,
  1
  /* InstantiationType.Delayed */
);
class xr {
  static getLanguageId(e) {
    return (e & 255) >>> 0;
  }
  static getTokenType(e) {
    return (e & 768) >>> 8;
  }
  static containsBalancedBrackets(e) {
    return (e & 1024) !== 0;
  }
  static getFontStyle(e) {
    return (e & 30720) >>> 11;
  }
  static getForeground(e) {
    return (e & 16744448) >>> 15;
  }
  static getBackground(e) {
    return (e & 4278190080) >>> 24;
  }
  static getClassNameFromMetadata(e) {
    let i = "mtk" + this.getForeground(e);
    const n = this.getFontStyle(e);
    return n & 1 && (i += " mtki"), n & 2 && (i += " mtkb"), n & 4 && (i += " mtku"), n & 8 && (i += " mtks"), i;
  }
  static getInlineStyleFromMetadata(e, t) {
    const i = this.getForeground(e), n = this.getFontStyle(e);
    let o = `color: ${t[i]};`;
    n & 1 && (o += "font-style: italic;"), n & 2 && (o += "font-weight: bold;");
    let r = "";
    return n & 4 && (r += " underline"), n & 8 && (r += " line-through"), r && (o += `text-decoration:${r};`), o;
  }
  static getPresentationFromMetadata(e) {
    const t = this.getForeground(e), i = this.getFontStyle(e);
    return {
      foreground: t,
      italic: !!(i & 1),
      bold: !!(i & 2),
      underline: !!(i & 4),
      strikethrough: !!(i & 8)
    };
  }
}
function bu(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0, r = s.length; o < r; o++) {
    const a = s.charCodeAt(o);
    a === 13 ? (e === 0 && (t = o), e++, o + 1 < r && s.charCodeAt(o + 1) === 10 ? (n |= 2, o++) : n |= 3, i = o + 1) : a === 10 && (n |= 1, e === 0 && (t = o), e++, i = o + 1);
  }
  return e === 0 && (t = s.length), [e, t, s.length - i, n];
}
var cj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, wy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let AL = class {
  constructor(e, t, i, n) {
    this._legend = e, this._themeService = t, this._languageService = i, this._logService = n, this._hasWarnedOverlappingTokens = !1, this._hasWarnedInvalidLengthTokens = !1, this._hasWarnedInvalidEditStart = !1, this._hashTable = new _L();
  }
  getMetadata(e, t, i) {
    const n = this._languageService.languageIdCodec.encodeLanguageId(i), o = this._hashTable.get(e, t, n);
    let r;
    if (o)
      r = o.metadata;
    else {
      let a = this._legend.tokenTypes[e];
      const l = [];
      if (a) {
        let c = t;
        for (let h = 0; c > 0 && h < this._legend.tokenModifiers.length; h++)
          c & 1 && l.push(this._legend.tokenModifiers[h]), c = c >> 1;
        const d = this._themeService.getColorTheme().getTokenStyleMetadata(a, l, i);
        if (typeof d > "u")
          r = 2147483647;
        else {
          if (r = 0, typeof d.italic < "u") {
            const h = (d.italic ? 1 : 0) << 11;
            r |= h | 1;
          }
          if (typeof d.bold < "u") {
            const h = (d.bold ? 2 : 0) << 11;
            r |= h | 2;
          }
          if (typeof d.underline < "u") {
            const h = (d.underline ? 4 : 0) << 11;
            r |= h | 4;
          }
          if (typeof d.strikethrough < "u") {
            const h = (d.strikethrough ? 8 : 0) << 11;
            r |= h | 8;
          }
          if (d.foreground) {
            const h = d.foreground << 15;
            r |= h | 16;
          }
          r === 0 && (r = 2147483647);
        }
      } else
        r = 2147483647, a = "not-in-legend";
      this._hashTable.add(e, t, n, r);
    }
    return r;
  }
  warnOverlappingSemanticTokens(e, t) {
    this._hasWarnedOverlappingTokens || (this._hasWarnedOverlappingTokens = !0, this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidLengthSemanticTokens(e, t) {
    this._hasWarnedInvalidLengthTokens || (this._hasWarnedInvalidLengthTokens = !0, this._logService.warn(`Semantic token with invalid length detected at lineNumber ${e}, column ${t}`));
  }
  warnInvalidEditStart(e, t, i, n, o) {
    this._hasWarnedInvalidEditStart || (this._hasWarnedInvalidEditStart = !0, this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${e}, resultId: ${t}) at edit #${i}: The provided start offset ${n} is outside the previous data (length ${o}).`));
  }
};
AL = cj([
  wy(1, nn),
  wy(2, si),
  wy(3, Es)
], AL);
class dj {
  constructor(e, t, i, n) {
    this.tokenTypeIndex = e, this.tokenModifierSet = t, this.languageId = i, this.metadata = n, this.next = null;
  }
}
const ol = class ol {
  constructor() {
    this._elementsCount = 0, this._currentLengthIndex = 0, this._currentLength = ol._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < ol._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], ol._nullOutEntries(this._elements, this._currentLength);
  }
  static _nullOutEntries(e, t) {
    for (let i = 0; i < t; i++)
      e[i] = null;
  }
  _hash2(e, t) {
    return (e << 5) - e + t | 0;
  }
  _hashFunc(e, t, i) {
    return this._hash2(this._hash2(e, t), i) % this._currentLength;
  }
  get(e, t, i) {
    const n = this._hashFunc(e, t, i);
    let o = this._elements[n];
    for (; o; ) {
      if (o.tokenTypeIndex === e && o.tokenModifierSet === t && o.languageId === i)
        return o;
      o = o.next;
    }
    return null;
  }
  add(e, t, i, n) {
    if (this._elementsCount++, this._growCount !== 0 && this._elementsCount >= this._growCount) {
      const o = this._elements;
      this._currentLengthIndex++, this._currentLength = ol._SIZES[this._currentLengthIndex], this._growCount = Math.round(this._currentLengthIndex + 1 < ol._SIZES.length ? 2 / 3 * this._currentLength : 0), this._elements = [], ol._nullOutEntries(this._elements, this._currentLength);
      for (const r of o) {
        let a = r;
        for (; a; ) {
          const l = a.next;
          a.next = null, this._add(a), a = l;
        }
      }
    }
    this._add(new dj(e, t, i, n));
  }
  _add(e) {
    const t = this._hashFunc(e.tokenTypeIndex, e.tokenModifierSet, e.languageId);
    e.next = this._elements[t], this._elements[t] = e;
  }
};
ol._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143];
let _L = ol;
const hj = We("semanticTokensStylingService");
var uj = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Cy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let bL = class extends V {
  constructor(e, t, i) {
    super(), this._themeService = e, this._logService = t, this._languageService = i, this._caches = /* @__PURE__ */ new WeakMap(), this._register(this._themeService.onDidColorThemeChange(() => {
      this._caches = /* @__PURE__ */ new WeakMap();
    }));
  }
  getStyling(e) {
    return this._caches.has(e) || this._caches.set(e, new AL(e.getLegend(), this._themeService, this._languageService, this._logService)), this._caches.get(e);
  }
};
bL = uj([
  Cy(0, nn),
  Cy(1, Es),
  Cy(2, si)
], bL);
$e(
  hj,
  bL,
  1
  /* InstantiationType.Delayed */
);
function oc(s) {
  return s === 47 || s === 92;
}
function H5(s) {
  return s.replace(/[\\/]/g, di.sep);
}
function gj(s) {
  return s.indexOf("/") === -1 && (s = H5(s)), /^[a-zA-Z]:(\/|$)/.test(s) && (s = "/" + s), s;
}
function g2(s, e = di.sep) {
  if (!s)
    return "";
  const t = s.length, i = s.charCodeAt(0);
  if (oc(i)) {
    if (oc(s.charCodeAt(1)) && !oc(s.charCodeAt(2))) {
      let o = 3;
      const r = o;
      for (; o < t && !oc(s.charCodeAt(o)); o++)
        ;
      if (r !== o && !oc(s.charCodeAt(o + 1))) {
        for (o += 1; o < t; o++)
          if (oc(s.charCodeAt(o)))
            return s.slice(0, o + 1).replace(/[\\/]/g, e);
      }
    }
    return e;
  } else if (W5(i) && s.charCodeAt(1) === 58)
    return oc(s.charCodeAt(2)) ? s.slice(0, 2) + e : s.slice(0, 2);
  let n = s.indexOf("://");
  if (n !== -1) {
    for (n += 3; n < t; n++)
      if (oc(s.charCodeAt(n)))
        return s.slice(0, n + 1);
  }
  return "";
}
function wL(s, e, t, i = Hc) {
  if (s === e)
    return !0;
  if (!s || !e || e.length > s.length)
    return !1;
  if (t) {
    if (!FM(s, e))
      return !1;
    if (e.length === s.length)
      return !0;
    let o = e.length;
    return e.charAt(e.length - 1) === i && o--, s.charAt(o) === i;
  }
  return e.charAt(e.length - 1) !== i && (e += i), s.indexOf(e) === 0;
}
function W5(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122;
}
function fj(s, e = yn) {
  return e ? W5(s.charCodeAt(0)) && s.charCodeAt(1) === 58 : !1;
}
const bb = "**", f2 = "/", Cw = "[/\\\\]", vw = "[^/\\\\]", mj = /\//g;
function m2(s, e) {
  switch (s) {
    case 0:
      return "";
    case 1:
      return `${vw}*?`;
    default:
      return `(?:${Cw}|${vw}+${Cw}${e ? `|${Cw}${vw}+` : ""})*?`;
  }
}
function p2(s, e) {
  if (!s)
    return [];
  const t = [];
  let i = !1, n = !1, o = "";
  for (const r of s) {
    switch (r) {
      case e:
        if (!i && !n) {
          t.push(o), o = "";
          continue;
        }
        break;
      case "{":
        i = !0;
        break;
      case "}":
        i = !1;
        break;
      case "[":
        n = !0;
        break;
      case "]":
        n = !1;
        break;
    }
    o += r;
  }
  return o && t.push(o), t;
}
function V5(s) {
  if (!s)
    return "";
  let e = "";
  const t = p2(s, f2);
  if (t.every((i) => i === bb))
    e = ".*";
  else {
    let i = !1;
    t.forEach((n, o) => {
      if (n === bb) {
        if (i)
          return;
        e += m2(2, o === t.length - 1);
      } else {
        let r = !1, a = "", l = !1, c = "";
        for (const d of n) {
          if (d !== "}" && r) {
            a += d;
            continue;
          }
          if (l && (d !== "]" || !c)) {
            let h;
            d === "-" ? h = d : (d === "^" || d === "!") && !c ? h = "^" : d === f2 ? h = "" : h = So(d), c += h;
            continue;
          }
          switch (d) {
            case "{":
              r = !0;
              continue;
            case "[":
              l = !0;
              continue;
            case "}": {
              const u = `(?:${p2(a, ",").map((g) => V5(g)).join("|")})`;
              e += u, r = !1, a = "";
              break;
            }
            case "]": {
              e += "[" + c + "]", l = !1, c = "";
              break;
            }
            case "?":
              e += vw;
              continue;
            case "*":
              e += m2(1);
              continue;
            default:
              e += So(d);
          }
        }
        o < t.length - 1 && // more segments to come after this
        (t[o + 1] !== bb || // next segment is not **, or...
        o + 2 < t.length) && (e += Cw);
      }
      i = n === bb;
    });
  }
  return e;
}
const pj = /^\*\*\/\*\.[\w\.-]+$/, Aj = /^\*\*\/([\w\.-]+)\/?$/, _j = /^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/, bj = /^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/, wj = /^\*\*((\/[\w\.-]+)+)\/?$/, Cj = /^([\w\.-]+(\/[\w\.-]+)*)\/?$/, A2 = new Vu(1e4), _2 = function() {
  return !1;
}, va = function() {
  return null;
};
function gN(s, e) {
  if (!s)
    return va;
  let t;
  typeof s != "string" ? t = s.pattern : t = s, t = t.trim();
  const i = `${t}_${!!e.trimForExclusions}`;
  let n = A2.get(i);
  if (n)
    return b2(n, s);
  let o;
  return pj.test(t) ? n = vj(t.substr(4), t) : (o = Aj.exec(vy(t, e))) ? n = Sj(o[1], t) : (e.trimForExclusions ? bj : _j).test(t) ? n = yj(t, e) : (o = wj.exec(vy(t, e))) ? n = w2(o[1].substr(1), t, !0) : (o = Cj.exec(vy(t, e))) ? n = w2(o[1], t, !1) : n = xj(t), A2.set(i, n), b2(n, s);
}
function b2(s, e) {
  if (typeof e == "string")
    return s;
  const t = function(i, n) {
    return wL(i, e.base, !Fn) ? s(_0(i.substr(e.base.length), Hc), n) : null;
  };
  return t.allBasenames = s.allBasenames, t.allPaths = s.allPaths, t.basenames = s.basenames, t.patterns = s.patterns, t;
}
function vy(s, e) {
  return e.trimForExclusions && s.endsWith("/**") ? s.substr(0, s.length - 2) : s;
}
function vj(s, e) {
  return function(t, i) {
    return typeof t == "string" && t.endsWith(s) ? e : null;
  };
}
function Sj(s, e) {
  const t = `/${s}`, i = `\\${s}`, n = function(r, a) {
    return typeof r != "string" ? null : a ? a === s ? e : null : r === s || r.endsWith(t) || r.endsWith(i) ? e : null;
  }, o = [s];
  return n.basenames = o, n.patterns = [e], n.allBasenames = o, n;
}
function yj(s, e) {
  const t = U5(s.slice(1, -1).split(",").map((a) => gN(a, e)).filter((a) => a !== va), s), i = t.length;
  if (!i)
    return va;
  if (i === 1)
    return t[0];
  const n = function(a, l) {
    for (let c = 0, d = t.length; c < d; c++)
      if (t[c](a, l))
        return s;
    return null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function w2(s, e, t) {
  const i = Hc === di.sep, n = i ? s : s.replace(mj, Hc), o = Hc + n, r = di.sep + s;
  let a;
  return t ? a = function(l, c) {
    return typeof l == "string" && (l === n || l.endsWith(o) || !i && (l === s || l.endsWith(r))) ? e : null;
  } : a = function(l, c) {
    return typeof l == "string" && (l === n || !i && l === s) ? e : null;
  }, a.allPaths = [(t ? "*/" : "./") + s], a;
}
function xj(s) {
  try {
    const e = new RegExp(`^${V5(s)}$`);
    return function(t) {
      return e.lastIndex = 0, typeof t == "string" && e.test(t) ? s : null;
    };
  } catch {
    return va;
  }
}
function Ej(s, e, t) {
  return !s || typeof e != "string" ? !1 : z5(s)(e, void 0, t);
}
function z5(s, e = {}) {
  if (!s)
    return _2;
  if (typeof s == "string" || Lj(s)) {
    const t = gN(s, e);
    if (t === va)
      return _2;
    const i = function(n, o) {
      return !!t(n, o);
    };
    return t.allBasenames && (i.allBasenames = t.allBasenames), t.allPaths && (i.allPaths = t.allPaths), i;
  }
  return kj(s, e);
}
function Lj(s) {
  const e = s;
  return e ? typeof e.base == "string" && typeof e.pattern == "string" : !1;
}
function kj(s, e) {
  const t = U5(Object.getOwnPropertyNames(s).map((a) => Dj(a, s[a], e)).filter((a) => a !== va)), i = t.length;
  if (!i)
    return va;
  if (!t.some((a) => !!a.requiresSiblings)) {
    if (i === 1)
      return t[0];
    const a = function(d, h) {
      let u;
      for (let g = 0, m = t.length; g < m; g++) {
        const p = t[g](d, h);
        if (typeof p == "string")
          return p;
        RE(p) && (u || (u = []), u.push(p));
      }
      return u ? (async () => {
        for (const g of u) {
          const m = await g;
          if (typeof m == "string")
            return m;
        }
        return null;
      })() : null;
    }, l = t.find((d) => !!d.allBasenames);
    l && (a.allBasenames = l.allBasenames);
    const c = t.reduce((d, h) => h.allPaths ? d.concat(h.allPaths) : d, []);
    return c.length && (a.allPaths = c), a;
  }
  const n = function(a, l, c) {
    let d, h;
    for (let u = 0, g = t.length; u < g; u++) {
      const m = t[u];
      m.requiresSiblings && c && (l || (l = Pc(a)), d || (d = l.substr(0, l.length - c7(a).length)));
      const p = m(a, l, d, c);
      if (typeof p == "string")
        return p;
      RE(p) && (h || (h = []), h.push(p));
    }
    return h ? (async () => {
      for (const u of h) {
        const g = await u;
        if (typeof g == "string")
          return g;
      }
      return null;
    })() : null;
  }, o = t.find((a) => !!a.allBasenames);
  o && (n.allBasenames = o.allBasenames);
  const r = t.reduce((a, l) => l.allPaths ? a.concat(l.allPaths) : a, []);
  return r.length && (n.allPaths = r), n;
}
function Dj(s, e, t) {
  if (e === !1)
    return va;
  const i = gN(s, t);
  if (i === va)
    return va;
  if (typeof e == "boolean")
    return i;
  if (e) {
    const n = e.when;
    if (typeof n == "string") {
      const o = (r, a, l, c) => {
        if (!c || !i(r, a))
          return null;
        const d = n.replace("$(basename)", () => l), h = c(d);
        return RE(h) ? h.then((u) => u ? s : null) : h ? s : null;
      };
      return o.requiresSiblings = !0, o;
    }
  }
  return i;
}
function U5(s, e) {
  const t = s.filter((a) => !!a.basenames);
  if (t.length < 2)
    return s;
  const i = t.reduce((a, l) => {
    const c = l.basenames;
    return c ? a.concat(c) : a;
  }, []);
  let n;
  if (e) {
    n = [];
    for (let a = 0, l = i.length; a < l; a++)
      n.push(e);
  } else
    n = t.reduce((a, l) => {
      const c = l.patterns;
      return c ? a.concat(c) : a;
    }, []);
  const o = function(a, l) {
    if (typeof a != "string")
      return null;
    if (!l) {
      let d;
      for (d = a.length; d > 0; d--) {
        const h = a.charCodeAt(d - 1);
        if (h === 47 || h === 92)
          break;
      }
      l = a.substr(d);
    }
    const c = i.indexOf(l);
    return c !== -1 ? n[c] : null;
  };
  o.basenames = i, o.patterns = n, o.allBasenames = i;
  const r = s.filter((a) => !a.basenames);
  return r.push(o), r;
}
function Q5(s, e, t, i, n, o) {
  if (Array.isArray(s)) {
    let r = 0;
    for (const a of s) {
      const l = Q5(a, e, t, i, n, o);
      if (l === 10)
        return l;
      l > r && (r = l);
    }
    return r;
  } else {
    if (typeof s == "string")
      return i ? s === "*" ? 5 : s === t ? 10 : 0 : 0;
    if (s) {
      const { language: r, pattern: a, scheme: l, hasAccessToAllModels: c, notebookType: d } = s;
      if (!i && !c)
        return 0;
      d && n && (e = n);
      let h = 0;
      if (l)
        if (l === e.scheme)
          h = 10;
        else if (l === "*")
          h = 5;
        else
          return 0;
      if (r)
        if (r === t)
          h = 10;
        else if (r === "*")
          h = Math.max(h, 5);
        else
          return 0;
      if (d)
        if (d === o)
          h = 10;
        else if (d === "*" && o !== void 0)
          h = Math.max(h, 5);
        else
          return 0;
      if (a) {
        let u;
        if (typeof a == "string" ? u = a : u = { ...a, base: lH(a.base) }, u === e.fsPath || Ej(u, e.fsPath))
          h = 10;
        else
          return 0;
      }
      return h;
    } else
      return 0;
  }
}
function G5(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.every(G5) : !!s.exclusive;
}
class C2 {
  constructor(e, t, i, n, o) {
    this.uri = e, this.languageId = t, this.notebookUri = i, this.notebookType = n, this.recursive = o;
  }
  equals(e) {
    return this.notebookType === e.notebookType && this.languageId === e.languageId && this.uri.toString() === e.uri.toString() && this.notebookUri?.toString() === e.notebookUri?.toString() && this.recursive === e.recursive;
  }
}
class Ht {
  constructor(e) {
    this._notebookInfoResolver = e, this._clock = 0, this._entries = [], this._onDidChange = new B(), this.onDidChange = this._onDidChange.event;
  }
  register(e, t) {
    let i = {
      selector: e,
      provider: t,
      _score: -1,
      _time: this._clock++
    };
    return this._entries.push(i), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), we(() => {
      if (i) {
        const n = this._entries.indexOf(i);
        n >= 0 && (this._entries.splice(n, 1), this._lastCandidate = void 0, this._onDidChange.fire(this._entries.length), i = void 0);
      }
    });
  }
  has(e) {
    return this.all(e).length > 0;
  }
  all(e) {
    if (!e)
      return [];
    this._updateScores(e, !1);
    const t = [];
    for (const i of this._entries)
      i._score > 0 && t.push(i.provider);
    return t;
  }
  ordered(e, t = !1) {
    const i = [];
    return this._orderedForEach(e, t, (n) => i.push(n.provider)), i;
  }
  orderedGroups(e) {
    const t = [];
    let i, n;
    return this._orderedForEach(e, !1, (o) => {
      i && n === o._score ? i.push(o.provider) : (n = o._score, i = [o.provider], t.push(i));
    }), t;
  }
  _orderedForEach(e, t, i) {
    this._updateScores(e, t);
    for (const n of this._entries)
      n._score > 0 && i(n);
  }
  _updateScores(e, t) {
    const i = this._notebookInfoResolver?.(e.uri), n = i ? new C2(e.uri, e.getLanguageId(), i.uri, i.type, t) : new C2(e.uri, e.getLanguageId(), void 0, void 0, t);
    if (!this._lastCandidate?.equals(n)) {
      this._lastCandidate = n;
      for (const o of this._entries)
        if (o._score = Q5(o.selector, n.uri, n.languageId, JQ(e), n.notebookUri, n.notebookType), G5(o.selector) && o._score > 0)
          if (t)
            o._score = 0;
          else {
            for (const r of this._entries)
              r._score = 0;
            o._score = 1e3;
            break;
          }
      this._entries.sort(Ht._compareByScoreAndTime);
    }
  }
  static _compareByScoreAndTime(e, t) {
    return e._score < t._score ? 1 : e._score > t._score ? -1 : hp(e.selector) && !hp(t.selector) ? 1 : !hp(e.selector) && hp(t.selector) ? -1 : e._time < t._time ? 1 : e._time > t._time ? -1 : 0;
  }
}
function hp(s) {
  return typeof s == "string" ? !1 : Array.isArray(s) ? s.some(hp) : !!s.isBuiltin;
}
class Ij {
  constructor() {
    this.referenceProvider = new Ht(this._score.bind(this)), this.renameProvider = new Ht(this._score.bind(this)), this.newSymbolNamesProvider = new Ht(this._score.bind(this)), this.codeActionProvider = new Ht(this._score.bind(this)), this.definitionProvider = new Ht(this._score.bind(this)), this.typeDefinitionProvider = new Ht(this._score.bind(this)), this.declarationProvider = new Ht(this._score.bind(this)), this.implementationProvider = new Ht(this._score.bind(this)), this.documentSymbolProvider = new Ht(this._score.bind(this)), this.inlayHintsProvider = new Ht(this._score.bind(this)), this.colorProvider = new Ht(this._score.bind(this)), this.codeLensProvider = new Ht(this._score.bind(this)), this.documentFormattingEditProvider = new Ht(this._score.bind(this)), this.documentRangeFormattingEditProvider = new Ht(this._score.bind(this)), this.onTypeFormattingEditProvider = new Ht(this._score.bind(this)), this.signatureHelpProvider = new Ht(this._score.bind(this)), this.hoverProvider = new Ht(this._score.bind(this)), this.documentHighlightProvider = new Ht(this._score.bind(this)), this.multiDocumentHighlightProvider = new Ht(this._score.bind(this)), this.selectionRangeProvider = new Ht(this._score.bind(this)), this.foldingRangeProvider = new Ht(this._score.bind(this)), this.linkProvider = new Ht(this._score.bind(this)), this.inlineCompletionsProvider = new Ht(this._score.bind(this)), this.inlineEditProvider = new Ht(this._score.bind(this)), this.completionProvider = new Ht(this._score.bind(this)), this.linkedEditingRangeProvider = new Ht(this._score.bind(this)), this.documentRangeSemanticTokensProvider = new Ht(this._score.bind(this)), this.documentSemanticTokensProvider = new Ht(this._score.bind(this)), this.documentDropEditProvider = new Ht(this._score.bind(this)), this.documentPasteEditProvider = new Ht(this._score.bind(this));
  }
  _score(e) {
    return this._notebookTypeResolver?.(e);
  }
}
$e(
  ye,
  Ij,
  1
  /* InstantiationType.Delayed */
);
function fN(s) {
  return `--vscode-${s.replace(/\./g, "-")}`;
}
function oe(s) {
  return `var(${fN(s)})`;
}
function Mj(s, e) {
  return `var(${fN(s)}, ${e})`;
}
function Nj(s) {
  return s !== null && typeof s == "object" && "light" in s && "dark" in s;
}
const j5 = {
  ColorContribution: "base.contributions.colors"
}, Tj = "default";
class Bj {
  constructor() {
    this._onDidChangeSchema = new B(), this.onDidChangeSchema = this._onDidChangeSchema.event, this.colorSchema = { type: "object", properties: {} }, this.colorReferenceSchema = { type: "string", enum: [], enumDescriptions: [] }, this.colorsById = {};
  }
  registerColor(e, t, i, n = !1, o) {
    const r = { id: e, description: i, defaults: t, needsTransparency: n, deprecationMessage: o };
    this.colorsById[e] = r;
    const a = { type: "string", format: "color-hex", defaultSnippets: [{ body: "${1:#ff0000}" }] };
    return o && (a.deprecationMessage = o), n && (a.pattern = "^#(?:(?<rgba>[0-9a-fA-f]{3}[0-9a-eA-E])|(?:[0-9a-fA-F]{6}(?:(?![fF]{2})(?:[0-9a-fA-F]{2}))))?$", a.patternErrorMessage = f("transparecyRequired", "This color must be transparent or it will obscure content")), this.colorSchema.properties[e] = {
      description: i,
      oneOf: [
        a,
        { type: "string", const: Tj, description: f("useDefault", "Use the default color.") }
      ]
    }, this.colorReferenceSchema.enum.push(e), this.colorReferenceSchema.enumDescriptions.push(i), this._onDidChangeSchema.fire(), e;
  }
  getColors() {
    return Object.keys(this.colorsById).map((e) => this.colorsById[e]);
  }
  resolveDefaultColor(e, t) {
    const i = this.colorsById[e];
    if (i?.defaults) {
      const n = Nj(i.defaults) ? i.defaults[t.type] : i.defaults;
      return gr(n, t);
    }
  }
  getColorSchema() {
    return this.colorSchema;
  }
  toString() {
    const e = (t, i) => {
      const n = t.indexOf(".") === -1 ? 0 : 1, o = i.indexOf(".") === -1 ? 0 : 1;
      return n !== o ? n - o : t.localeCompare(i);
    };
    return Object.keys(this.colorsById).sort(e).map((t) => `- \`${t}\`: ${this.colorsById[t].description}`).join(`
`);
  }
}
const V0 = new Bj();
ji.add(j5.ColorContribution, V0);
function L(s, e, t, i, n) {
  return V0.registerColor(s, e, t, i, n);
}
function Rj(s, e) {
  switch (s.op) {
    case 0:
      return gr(s.value, e)?.darken(s.factor);
    case 1:
      return gr(s.value, e)?.lighten(s.factor);
    case 2:
      return gr(s.value, e)?.transparent(s.factor);
    case 3: {
      const t = gr(s.background, e);
      return t ? gr(s.value, e)?.makeOpaque(t) : gr(s.value, e);
    }
    case 4:
      for (const t of s.values) {
        const i = gr(t, e);
        if (i)
          return i;
      }
      return;
    case 6:
      return gr(e.defines(s.if) ? s.then : s.else, e);
    case 5: {
      const t = gr(s.value, e);
      if (!t)
        return;
      const i = gr(s.background, e);
      return i ? t.isDarkerThan(i) ? Y.getLighterColor(t, i, s.factor).transparent(s.transparency) : Y.getDarkerColor(t, i, s.factor).transparent(s.transparency) : t.transparent(s.factor * s.transparency);
    }
    default:
      throw eN();
  }
}
function zu(s, e) {
  return { op: 0, value: s, factor: e };
}
function Nr(s, e) {
  return { op: 1, value: s, factor: e };
}
function Me(s, e) {
  return { op: 2, value: s, factor: e };
}
function WA(...s) {
  return { op: 4, values: s };
}
function Fj(s, e, t) {
  return { op: 6, if: s, then: e, else: t };
}
function v2(s, e, t, i) {
  return { op: 5, value: s, background: e, factor: t, transparency: i };
}
function gr(s, e) {
  if (s !== null) {
    if (typeof s == "string")
      return s[0] === "#" ? Y.fromHex(s) : e.getColor(s);
    if (s instanceof Y)
      return s;
    if (typeof s == "object")
      return Rj(s, e);
  }
}
const Y5 = "vscode://schemas/workbench-colors", K5 = ji.as(O0.JSONContribution);
K5.registerSchema(Y5, V0.getColorSchema());
const S2 = new zt(() => K5.notifySchemaChanged(Y5), 200);
V0.onDidChangeSchema(() => {
  S2.isScheduled() || S2.schedule();
});
const Re = L("foreground", { dark: "#CCCCCC", light: "#616161", hcDark: "#FFFFFF", hcLight: "#292929" }, f("foreground", "Overall foreground color. This color is only used if not overridden by a component."));
L("disabledForeground", { dark: "#CCCCCC80", light: "#61616180", hcDark: "#A5A5A5", hcLight: "#7F7F7F" }, f("disabledForeground", "Overall foreground for disabled elements. This color is only used if not overridden by a component."));
L("errorForeground", { dark: "#F48771", light: "#A1260D", hcDark: "#F48771", hcLight: "#B5200D" }, f("errorForeground", "Overall foreground color for error messages. This color is only used if not overridden by a component."));
L("descriptionForeground", { light: "#717171", dark: Me(Re, 0.7), hcDark: Me(Re, 0.7), hcLight: Me(Re, 0.7) }, f("descriptionForeground", "Foreground color for description text providing additional information, for example for a label."));
const CC = L("icon.foreground", { dark: "#C5C5C5", light: "#424242", hcDark: "#FFFFFF", hcLight: "#292929" }, f("iconForeground", "The default color for icons in the workbench.")), ka = L("focusBorder", { dark: "#007FD4", light: "#0090F1", hcDark: "#F38518", hcLight: "#006BBD" }, f("focusBorder", "Overall border color for focused elements. This color is only used if not overridden by a component.")), Je = L("contrastBorder", { light: null, dark: null, hcDark: "#6FC3DF", hcLight: "#0F4A85" }, f("contrastBorder", "An extra border around elements to separate them from others for greater contrast.")), Kt = L("contrastActiveBorder", { light: null, dark: null, hcDark: ka, hcLight: ka }, f("activeContrastBorder", "An extra border around active elements to separate them from others for greater contrast."));
L("selection.background", null, f("selectionBackground", "The background color of text selections in the workbench (e.g. for input fields or text areas). Note that this does not apply to selections within the editor."));
const Oj = L("textLink.foreground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, f("textLinkForeground", "Foreground color for links in text."));
L("textLink.activeForeground", { light: "#006AB1", dark: "#3794FF", hcDark: "#21A6FF", hcLight: "#0F4A85" }, f("textLinkActiveForeground", "Foreground color for links in text when clicked on and on mouse hover."));
L("textSeparator.foreground", { light: "#0000002e", dark: "#ffffff2e", hcDark: Y.black, hcLight: "#292929" }, f("textSeparatorForeground", "Color for text separators."));
L("textPreformat.foreground", { light: "#A31515", dark: "#D7BA7D", hcDark: "#000000", hcLight: "#FFFFFF" }, f("textPreformatForeground", "Foreground color for preformatted text segments."));
L("textPreformat.background", { light: "#0000001A", dark: "#FFFFFF1A", hcDark: "#FFFFFF", hcLight: "#09345f" }, f("textPreformatBackground", "Background color for preformatted text segments."));
L("textBlockQuote.background", { light: "#f2f2f2", dark: "#222222", hcDark: null, hcLight: "#F2F2F2" }, f("textBlockQuoteBackground", "Background color for block quotes in text."));
L("textBlockQuote.border", { light: "#007acc80", dark: "#007acc80", hcDark: Y.white, hcLight: "#292929" }, f("textBlockQuoteBorder", "Border color for block quotes in text."));
L("textCodeBlock.background", { light: "#dcdcdc66", dark: "#0a0a0a66", hcDark: Y.black, hcLight: "#F2F2F2" }, f("textCodeBlockBackground", "Background color for code blocks in text."));
L("sash.hoverBorder", ka, f("sashActiveBorder", "Border color of active sashes."));
const Sw = L("badge.background", { dark: "#4D4D4D", light: "#C4C4C4", hcDark: Y.black, hcLight: "#0F4A85" }, f("badgeBackground", "Badge background color. Badges are small information labels, e.g. for search results count.")), Pj = L("badge.foreground", { dark: Y.white, light: "#333", hcDark: Y.white, hcLight: Y.white }, f("badgeForeground", "Badge foreground color. Badges are small information labels, e.g. for search results count.")), mN = L("scrollbar.shadow", { dark: "#000000", light: "#DDDDDD", hcDark: null, hcLight: null }, f("scrollbarShadow", "Scrollbar shadow to indicate that the view is scrolled.")), J5 = L("scrollbarSlider.background", { dark: Y.fromHex("#797979").transparent(0.4), light: Y.fromHex("#646464").transparent(0.4), hcDark: Me(Je, 0.6), hcLight: Me(Je, 0.4) }, f("scrollbarSliderBackground", "Scrollbar slider background color.")), q5 = L("scrollbarSlider.hoverBackground", { dark: Y.fromHex("#646464").transparent(0.7), light: Y.fromHex("#646464").transparent(0.7), hcDark: Me(Je, 0.8), hcLight: Me(Je, 0.8) }, f("scrollbarSliderHoverBackground", "Scrollbar slider background color when hovering.")), $5 = L("scrollbarSlider.activeBackground", { dark: Y.fromHex("#BFBFBF").transparent(0.4), light: Y.fromHex("#000000").transparent(0.6), hcDark: Je, hcLight: Je }, f("scrollbarSliderActiveBackground", "Scrollbar slider background color when clicked on.")), Hj = L("progressBar.background", { dark: Y.fromHex("#0E70C0"), light: Y.fromHex("#0E70C0"), hcDark: Je, hcLight: Je }, f("progressBarBackground", "Background color of the progress bar that can show for long running operations.")), $o = L("editor.background", { light: "#ffffff", dark: "#1E1E1E", hcDark: Y.black, hcLight: Y.white }, f("editorBackground", "Editor background color.")), Fa = L("editor.foreground", { light: "#333333", dark: "#BBBBBB", hcDark: Y.white, hcLight: Re }, f("editorForeground", "Editor default foreground color."));
L("editorStickyScroll.background", $o, f("editorStickyScrollBackground", "Background color of sticky scroll in the editor"));
L("editorStickyScrollHover.background", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: null, hcLight: Y.fromHex("#0F4A85").transparent(0.1) }, f("editorStickyScrollHoverBackground", "Background color of sticky scroll on hover in the editor"));
L("editorStickyScroll.border", { dark: null, light: null, hcDark: Je, hcLight: Je }, f("editorStickyScrollBorder", "Border color of sticky scroll in the editor"));
L("editorStickyScroll.shadow", mN, f("editorStickyScrollShadow", " Shadow color of sticky scroll in the editor"));
const Ao = L("editorWidget.background", { dark: "#252526", light: "#F3F3F3", hcDark: "#0C141F", hcLight: Y.white }, f("editorWidgetBackground", "Background color of editor widgets, such as find/replace.")), z0 = L("editorWidget.foreground", Re, f("editorWidgetForeground", "Foreground color of editor widgets, such as find/replace.")), pN = L("editorWidget.border", { dark: "#454545", light: "#C8C8C8", hcDark: Je, hcLight: Je }, f("editorWidgetBorder", "Border color of editor widgets. The color is only used if the widget chooses to have a border and if the color is not overridden by a widget."));
L("editorWidget.resizeBorder", null, f("editorWidgetResizeBorder", "Border color of the resize bar of editor widgets. The color is only used if the widget chooses to have a resize border and if the color is not overridden by a widget."));
L("editorError.background", null, f("editorError.background", "Background color of error text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const U0 = L("editorError.foreground", { dark: "#F14C4C", light: "#E51400", hcDark: "#F48771", hcLight: "#B5200D" }, f("editorError.foreground", "Foreground color of error squigglies in the editor.")), Wj = L("editorError.border", { dark: null, light: null, hcDark: Y.fromHex("#E47777").transparent(0.8), hcLight: "#B5200D" }, f("errorBorder", "If set, color of double underlines for errors in the editor.")), Vj = L("editorWarning.background", null, f("editorWarning.background", "Background color of warning text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0), zl = L("editorWarning.foreground", { dark: "#CCA700", light: "#BF8803", hcDark: "#FFD370", hcLight: "#895503" }, f("editorWarning.foreground", "Foreground color of warning squigglies in the editor.")), VA = L("editorWarning.border", { dark: null, light: null, hcDark: Y.fromHex("#FFCC00").transparent(0.8), hcLight: Y.fromHex("#FFCC00").transparent(0.8) }, f("warningBorder", "If set, color of double underlines for warnings in the editor."));
L("editorInfo.background", null, f("editorInfo.background", "Background color of info text in the editor. The color must not be opaque so as not to hide underlying decorations."), !0);
const Da = L("editorInfo.foreground", { dark: "#3794FF", light: "#1a85ff", hcDark: "#3794FF", hcLight: "#1a85ff" }, f("editorInfo.foreground", "Foreground color of info squigglies in the editor.")), zA = L("editorInfo.border", { dark: null, light: null, hcDark: Y.fromHex("#3794FF").transparent(0.8), hcLight: "#292929" }, f("infoBorder", "If set, color of double underlines for infos in the editor.")), zj = L("editorHint.foreground", { dark: Y.fromHex("#eeeeee").transparent(0.7), light: "#6c6c6c", hcDark: null, hcLight: null }, f("editorHint.foreground", "Foreground color of hint squigglies in the editor."));
L("editorHint.border", { dark: null, light: null, hcDark: Y.fromHex("#eeeeee").transparent(0.8), hcLight: "#292929" }, f("hintBorder", "If set, color of double underlines for hints in the editor."));
const Uj = L("editorLink.activeForeground", { dark: "#4E94CE", light: Y.blue, hcDark: Y.cyan, hcLight: "#292929" }, f("activeLinkForeground", "Color of active links.")), Ec = L("editor.selectionBackground", { light: "#ADD6FF", dark: "#264F78", hcDark: "#f3f518", hcLight: "#0F4A85" }, f("editorSelectionBackground", "Color of the editor selection.")), Qj = L("editor.selectionForeground", { light: null, dark: null, hcDark: "#000000", hcLight: Y.white }, f("editorSelectionForeground", "Color of the selected text for high contrast.")), X5 = L("editor.inactiveSelectionBackground", { light: Me(Ec, 0.5), dark: Me(Ec, 0.5), hcDark: Me(Ec, 0.7), hcLight: Me(Ec, 0.5) }, f("editorInactiveSelection", "Color of the selection in an inactive editor. The color must not be opaque so as not to hide underlying decorations."), !0), Z5 = L("editor.selectionHighlightBackground", { light: v2(Ec, $o, 0.3, 0.6), dark: v2(Ec, $o, 0.3, 0.6), hcDark: null, hcLight: null }, f("editorSelectionHighlight", "Color for regions with the same content as the selection. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.selectionHighlightBorder", { light: null, dark: null, hcDark: Kt, hcLight: Kt }, f("editorSelectionHighlightBorder", "Border color for regions with the same content as the selection."));
L("editor.findMatchBackground", { light: "#A8AC94", dark: "#515C6A", hcDark: null, hcLight: null }, f("editorFindMatch", "Color of the current search match."));
const Gj = L("editor.findMatchForeground", null, f("editorFindMatchForeground", "Text color of the current search match.")), Cl = L("editor.findMatchHighlightBackground", { light: "#EA5C0055", dark: "#EA5C0055", hcDark: null, hcLight: null }, f("findMatchHighlight", "Color of the other search matches. The color must not be opaque so as not to hide underlying decorations."), !0), jj = L("editor.findMatchHighlightForeground", null, f("findMatchHighlightForeground", "Foreground color of the other search matches."), !0);
L("editor.findRangeHighlightBackground", { dark: "#3a3d4166", light: "#b4b4b44d", hcDark: null, hcLight: null }, f("findRangeHighlight", "Color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.findMatchBorder", { light: null, dark: null, hcDark: Kt, hcLight: Kt }, f("editorFindMatchBorder", "Border color of the current search match."));
const Lc = L("editor.findMatchHighlightBorder", { light: null, dark: null, hcDark: Kt, hcLight: Kt }, f("findMatchHighlightBorder", "Border color of the other search matches.")), Yj = L("editor.findRangeHighlightBorder", { dark: null, light: null, hcDark: Me(Kt, 0.4), hcLight: Me(Kt, 0.4) }, f("findRangeHighlightBorder", "Border color of the range limiting the search. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.hoverHighlightBackground", { light: "#ADD6FF26", dark: "#264f7840", hcDark: "#ADD6FF26", hcLight: null }, f("hoverHighlight", "Highlight below the word for which a hover is shown. The color must not be opaque so as not to hide underlying decorations."), !0);
const vC = L("editorHoverWidget.background", Ao, f("hoverBackground", "Background color of the editor hover."));
L("editorHoverWidget.foreground", z0, f("hoverForeground", "Foreground color of the editor hover."));
const e3 = L("editorHoverWidget.border", pN, f("hoverBorder", "Border color of the editor hover."));
L("editorHoverWidget.statusBarBackground", { dark: Nr(vC, 0.2), light: zu(vC, 0.05), hcDark: Ao, hcLight: Ao }, f("statusBarBackground", "Background color of the editor hover status bar."));
const AN = L("editorInlayHint.foreground", { dark: "#969696", light: "#969696", hcDark: Y.white, hcLight: Y.black }, f("editorInlayHintForeground", "Foreground color of inline hints")), _N = L("editorInlayHint.background", { dark: Me(Sw, 0.1), light: Me(Sw, 0.1), hcDark: Me(Y.white, 0.1), hcLight: Me(Sw, 0.1) }, f("editorInlayHintBackground", "Background color of inline hints")), Kj = L("editorInlayHint.typeForeground", AN, f("editorInlayHintForegroundTypes", "Foreground color of inline hints for types")), Jj = L("editorInlayHint.typeBackground", _N, f("editorInlayHintBackgroundTypes", "Background color of inline hints for types")), qj = L("editorInlayHint.parameterForeground", AN, f("editorInlayHintForegroundParameter", "Foreground color of inline hints for parameters")), $j = L("editorInlayHint.parameterBackground", _N, f("editorInlayHintBackgroundParameter", "Background color of inline hints for parameters")), Xj = L("editorLightBulb.foreground", { dark: "#FFCC00", light: "#DDB100", hcDark: "#FFCC00", hcLight: "#007ACC" }, f("editorLightBulbForeground", "The color used for the lightbulb actions icon."));
L("editorLightBulbAutoFix.foreground", { dark: "#75BEFF", light: "#007ACC", hcDark: "#75BEFF", hcLight: "#007ACC" }, f("editorLightBulbAutoFixForeground", "The color used for the lightbulb auto fix actions icon."));
L("editorLightBulbAi.foreground", Xj, f("editorLightBulbAiForeground", "The color used for the lightbulb AI icon."));
L("editor.snippetTabstopHighlightBackground", { dark: new Y(new qe(124, 124, 124, 0.3)), light: new Y(new qe(10, 50, 100, 0.2)), hcDark: new Y(new qe(124, 124, 124, 0.3)), hcLight: new Y(new qe(10, 50, 100, 0.2)) }, f("snippetTabstopHighlightBackground", "Highlight background color of a snippet tabstop."));
L("editor.snippetTabstopHighlightBorder", null, f("snippetTabstopHighlightBorder", "Highlight border color of a snippet tabstop."));
L("editor.snippetFinalTabstopHighlightBackground", null, f("snippetFinalTabstopHighlightBackground", "Highlight background color of the final tabstop of a snippet."));
L("editor.snippetFinalTabstopHighlightBorder", { dark: "#525252", light: new Y(new qe(10, 50, 100, 0.5)), hcDark: "#525252", hcLight: "#292929" }, f("snippetFinalTabstopHighlightBorder", "Highlight border color of the final tabstop of a snippet."));
const CL = new Y(new qe(155, 185, 85, 0.2)), vL = new Y(new qe(255, 0, 0, 0.2)), Zj = L("diffEditor.insertedTextBackground", { dark: "#9ccc2c33", light: "#9ccc2c40", hcDark: null, hcLight: null }, f("diffEditorInserted", "Background color for text that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0), eY = L("diffEditor.removedTextBackground", { dark: "#ff000033", light: "#ff000033", hcDark: null, hcLight: null }, f("diffEditorRemoved", "Background color for text that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
L("diffEditor.insertedLineBackground", { dark: CL, light: CL, hcDark: null, hcLight: null }, f("diffEditorInsertedLines", "Background color for lines that got inserted. The color must not be opaque so as not to hide underlying decorations."), !0);
L("diffEditor.removedLineBackground", { dark: vL, light: vL, hcDark: null, hcLight: null }, f("diffEditorRemovedLines", "Background color for lines that got removed. The color must not be opaque so as not to hide underlying decorations."), !0);
L("diffEditorGutter.insertedLineBackground", null, f("diffEditorInsertedLineGutter", "Background color for the margin where lines got inserted."));
L("diffEditorGutter.removedLineBackground", null, f("diffEditorRemovedLineGutter", "Background color for the margin where lines got removed."));
const tY = L("diffEditorOverview.insertedForeground", null, f("diffEditorOverviewInserted", "Diff overview ruler foreground for inserted content.")), iY = L("diffEditorOverview.removedForeground", null, f("diffEditorOverviewRemoved", "Diff overview ruler foreground for removed content."));
L("diffEditor.insertedTextBorder", { dark: null, light: null, hcDark: "#33ff2eff", hcLight: "#374E06" }, f("diffEditorInsertedOutline", "Outline color for the text that got inserted."));
L("diffEditor.removedTextBorder", { dark: null, light: null, hcDark: "#FF008F", hcLight: "#AD0707" }, f("diffEditorRemovedOutline", "Outline color for text that got removed."));
L("diffEditor.border", { dark: null, light: null, hcDark: Je, hcLight: Je }, f("diffEditorBorder", "Border color between the two text editors."));
L("diffEditor.diagonalFill", { dark: "#cccccc33", light: "#22222233", hcDark: null, hcLight: null }, f("diffDiagonalFill", "Color of the diff editor's diagonal fill. The diagonal fill is used in side-by-side diff views."));
L("diffEditor.unchangedRegionBackground", "sideBar.background", f("diffEditor.unchangedRegionBackground", "The background color of unchanged blocks in the diff editor."));
L("diffEditor.unchangedRegionForeground", "foreground", f("diffEditor.unchangedRegionForeground", "The foreground color of unchanged blocks in the diff editor."));
L("diffEditor.unchangedCodeBackground", { dark: "#74747429", light: "#b8b8b829", hcDark: null, hcLight: null }, f("diffEditor.unchangedCodeBackground", "The background color of unchanged code in the diff editor."));
const B_ = L("widget.shadow", { dark: Me(Y.black, 0.36), light: Me(Y.black, 0.16), hcDark: null, hcLight: null }, f("widgetShadow", "Shadow color of widgets such as find/replace inside the editor.")), nY = L("widget.border", { dark: null, light: null, hcDark: Je, hcLight: Je }, f("widgetBorder", "Border color of widgets such as find/replace inside the editor.")), y2 = L("toolbar.hoverBackground", { dark: "#5a5d5e50", light: "#b8b8b850", hcDark: null, hcLight: null }, f("toolbarHoverBackground", "Toolbar background when hovering over actions using the mouse"));
L("toolbar.hoverOutline", { dark: null, light: null, hcDark: Kt, hcLight: Kt }, f("toolbarHoverOutline", "Toolbar outline when hovering over actions using the mouse"));
L("toolbar.activeBackground", { dark: Nr(y2, 0.1), light: zu(y2, 0.1), hcDark: null, hcLight: null }, f("toolbarActiveBackground", "Toolbar background when holding the mouse over actions"));
const sY = L("breadcrumb.foreground", Me(Re, 0.8), f("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), oY = L("breadcrumb.background", $o, f("breadcrumbsBackground", "Background color of breadcrumb items.")), x2 = L("breadcrumb.focusForeground", { light: zu(Re, 0.2), dark: Nr(Re, 0.1), hcDark: Nr(Re, 0.1), hcLight: Nr(Re, 0.1) }, f("breadcrumbsFocusForeground", "Color of focused breadcrumb items.")), rY = L("breadcrumb.activeSelectionForeground", { light: zu(Re, 0.2), dark: Nr(Re, 0.1), hcDark: Nr(Re, 0.1), hcLight: Nr(Re, 0.1) }, f("breadcrumbsSelectedForeground", "Color of selected breadcrumb items."));
L("breadcrumbPicker.background", Ao, f("breadcrumbsSelectedBackground", "Background color of breadcrumb item picker."));
const t3 = 0.5, E2 = Y.fromHex("#40C8AE").transparent(t3), L2 = Y.fromHex("#40A6FF").transparent(t3), k2 = Y.fromHex("#606060").transparent(0.4), bN = 0.4, jf = 1, SL = L("merge.currentHeaderBackground", { dark: E2, light: E2, hcDark: null, hcLight: null }, f("mergeCurrentHeaderBackground", "Current header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
L("merge.currentContentBackground", Me(SL, bN), f("mergeCurrentContentBackground", "Current content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const yL = L("merge.incomingHeaderBackground", { dark: L2, light: L2, hcDark: null, hcLight: null }, f("mergeIncomingHeaderBackground", "Incoming header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
L("merge.incomingContentBackground", Me(yL, bN), f("mergeIncomingContentBackground", "Incoming content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const xL = L("merge.commonHeaderBackground", { dark: k2, light: k2, hcDark: null, hcLight: null }, f("mergeCommonHeaderBackground", "Common ancestor header background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
L("merge.commonContentBackground", Me(xL, bN), f("mergeCommonContentBackground", "Common ancestor content background in inline merge-conflicts. The color must not be opaque so as not to hide underlying decorations."), !0);
const Yf = L("merge.border", { dark: null, light: null, hcDark: "#C3DF6F", hcLight: "#007ACC" }, f("mergeBorder", "Border color on headers and the splitter in inline merge-conflicts."));
L("editorOverviewRuler.currentContentForeground", { dark: Me(SL, jf), light: Me(SL, jf), hcDark: Yf, hcLight: Yf }, f("overviewRulerCurrentContentForeground", "Current overview ruler foreground for inline merge-conflicts."));
L("editorOverviewRuler.incomingContentForeground", { dark: Me(yL, jf), light: Me(yL, jf), hcDark: Yf, hcLight: Yf }, f("overviewRulerIncomingContentForeground", "Incoming overview ruler foreground for inline merge-conflicts."));
L("editorOverviewRuler.commonContentForeground", { dark: Me(xL, jf), light: Me(xL, jf), hcDark: Yf, hcLight: Yf }, f("overviewRulerCommonContentForeground", "Common ancestor overview ruler foreground for inline merge-conflicts."));
const Sy = L("editorOverviewRuler.findMatchForeground", { dark: "#d186167e", light: "#d186167e", hcDark: "#AB5A00", hcLight: "#AB5A00" }, f("overviewRulerFindMatchForeground", "Overview ruler marker color for find matches. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editorOverviewRuler.selectionHighlightForeground", "#A0A0A0CC", f("overviewRulerSelectionHighlightForeground", "Overview ruler marker color for selection highlights. The color must not be opaque so as not to hide underlying decorations."), !0);
const aY = L("problemsErrorIcon.foreground", U0, f("problemsErrorIconForeground", "The color used for the problems error icon.")), lY = L("problemsWarningIcon.foreground", zl, f("problemsWarningIconForeground", "The color used for the problems warning icon.")), cY = L("problemsInfoIcon.foreground", Da, f("problemsInfoIconForeground", "The color used for the problems info icon.")), EL = L("minimap.findMatchHighlight", { light: "#d18616", dark: "#d18616", hcDark: "#AB5A00", hcLight: "#0F4A85" }, f("minimapFindMatchHighlight", "Minimap marker color for find matches."), !0);
L("minimap.selectionOccurrenceHighlight", { light: "#c9c9c9", dark: "#676767", hcDark: "#ffffff", hcLight: "#0F4A85" }, f("minimapSelectionOccurrenceHighlight", "Minimap marker color for repeating editor selections."), !0);
const D2 = L("minimap.selectionHighlight", { light: "#ADD6FF", dark: "#264F78", hcDark: "#ffffff", hcLight: "#0F4A85" }, f("minimapSelectionHighlight", "Minimap marker color for the editor selection."), !0), dY = L("minimap.infoHighlight", { dark: Da, light: Da, hcDark: zA, hcLight: zA }, f("minimapInfo", "Minimap marker color for infos.")), hY = L("minimap.warningHighlight", { dark: zl, light: zl, hcDark: VA, hcLight: VA }, f("overviewRuleWarning", "Minimap marker color for warnings.")), uY = L("minimap.errorHighlight", { dark: new Y(new qe(255, 18, 18, 0.7)), light: new Y(new qe(255, 18, 18, 0.7)), hcDark: new Y(new qe(255, 50, 50, 1)), hcLight: "#B5200D" }, f("minimapError", "Minimap marker color for errors.")), gY = L("minimap.background", null, f("minimapBackground", "Minimap background color.")), fY = L("minimap.foregroundOpacity", Y.fromHex("#000f"), f("minimapForegroundOpacity", 'Opacity of foreground elements rendered in the minimap. For example, "#000000c0" will render the elements with 75% opacity.'));
L("minimapSlider.background", Me(J5, 0.5), f("minimapSliderBackground", "Minimap slider background color."));
L("minimapSlider.hoverBackground", Me(q5, 0.5), f("minimapSliderHoverBackground", "Minimap slider background color when hovering."));
L("minimapSlider.activeBackground", Me($5, 0.5), f("minimapSliderActiveBackground", "Minimap slider background color when clicked on."));
L("charts.foreground", Re, f("chartsForeground", "The foreground color used in charts."));
L("charts.lines", Me(Re, 0.5), f("chartsLines", "The color used for horizontal lines in charts."));
L("charts.red", U0, f("chartsRed", "The red color used in chart visualizations."));
L("charts.blue", Da, f("chartsBlue", "The blue color used in chart visualizations."));
L("charts.yellow", zl, f("chartsYellow", "The yellow color used in chart visualizations."));
L("charts.orange", EL, f("chartsOrange", "The orange color used in chart visualizations."));
L("charts.green", { dark: "#89D185", light: "#388A34", hcDark: "#89D185", hcLight: "#374e06" }, f("chartsGreen", "The green color used in chart visualizations."));
L("charts.purple", { dark: "#B180D7", light: "#652D90", hcDark: "#B180D7", hcLight: "#652D90" }, f("chartsPurple", "The purple color used in chart visualizations."));
const mY = L("input.background", { dark: "#3C3C3C", light: Y.white, hcDark: Y.black, hcLight: Y.white }, f("inputBoxBackground", "Input box background.")), pY = L("input.foreground", Re, f("inputBoxForeground", "Input box foreground.")), AY = L("input.border", { dark: null, light: null, hcDark: Je, hcLight: Je }, f("inputBoxBorder", "Input box border.")), Q0 = L("inputOption.activeBorder", { dark: "#007ACC", light: "#007ACC", hcDark: Je, hcLight: Je }, f("inputBoxActiveOptionBorder", "Border color of activated options in input fields.")), _Y = L("inputOption.hoverBackground", { dark: "#5a5d5e80", light: "#b8b8b850", hcDark: null, hcLight: null }, f("inputOption.hoverBackground", "Background color of activated options in input fields.")), R_ = L("inputOption.activeBackground", { dark: Me(ka, 0.4), light: Me(ka, 0.2), hcDark: Y.transparent, hcLight: Y.transparent }, f("inputOption.activeBackground", "Background hover color of options in input fields.")), G0 = L("inputOption.activeForeground", { dark: Y.white, light: Y.black, hcDark: Re, hcLight: Re }, f("inputOption.activeForeground", "Foreground color of activated options in input fields."));
L("input.placeholderForeground", { light: Me(Re, 0.5), dark: Me(Re, 0.5), hcDark: Me(Re, 0.7), hcLight: Me(Re, 0.7) }, f("inputPlaceholderForeground", "Input box foreground color for placeholder text."));
const bY = L("inputValidation.infoBackground", { dark: "#063B49", light: "#D6ECF2", hcDark: Y.black, hcLight: Y.white }, f("inputValidationInfoBackground", "Input validation background color for information severity.")), wY = L("inputValidation.infoForeground", { dark: null, light: null, hcDark: null, hcLight: Re }, f("inputValidationInfoForeground", "Input validation foreground color for information severity.")), CY = L("inputValidation.infoBorder", { dark: "#007acc", light: "#007acc", hcDark: Je, hcLight: Je }, f("inputValidationInfoBorder", "Input validation border color for information severity.")), vY = L("inputValidation.warningBackground", { dark: "#352A05", light: "#F6F5D2", hcDark: Y.black, hcLight: Y.white }, f("inputValidationWarningBackground", "Input validation background color for warning severity.")), SY = L("inputValidation.warningForeground", { dark: null, light: null, hcDark: null, hcLight: Re }, f("inputValidationWarningForeground", "Input validation foreground color for warning severity.")), yY = L("inputValidation.warningBorder", { dark: "#B89500", light: "#B89500", hcDark: Je, hcLight: Je }, f("inputValidationWarningBorder", "Input validation border color for warning severity.")), xY = L("inputValidation.errorBackground", { dark: "#5A1D1D", light: "#F2DEDE", hcDark: Y.black, hcLight: Y.white }, f("inputValidationErrorBackground", "Input validation background color for error severity.")), EY = L("inputValidation.errorForeground", { dark: null, light: null, hcDark: null, hcLight: Re }, f("inputValidationErrorForeground", "Input validation foreground color for error severity.")), LY = L("inputValidation.errorBorder", { dark: "#BE1100", light: "#BE1100", hcDark: Je, hcLight: Je }, f("inputValidationErrorBorder", "Input validation border color for error severity.")), j0 = L("dropdown.background", { dark: "#3C3C3C", light: Y.white, hcDark: Y.black, hcLight: Y.white }, f("dropdownBackground", "Dropdown background.")), kY = L("dropdown.listBackground", { dark: null, light: null, hcDark: Y.black, hcLight: Y.white }, f("dropdownListBackground", "Dropdown list background.")), wN = L("dropdown.foreground", { dark: "#F0F0F0", light: Re, hcDark: Y.white, hcLight: Re }, f("dropdownForeground", "Dropdown foreground.")), CN = L("dropdown.border", { dark: j0, light: "#CECECE", hcDark: Je, hcLight: Je }, f("dropdownBorder", "Dropdown border.")), i3 = L("button.foreground", Y.white, f("buttonForeground", "Button foreground color.")), DY = L("button.separator", Me(i3, 0.4), f("buttonSeparator", "Button separator color.")), up = L("button.background", { dark: "#0E639C", light: "#007ACC", hcDark: null, hcLight: "#0F4A85" }, f("buttonBackground", "Button background color.")), IY = L("button.hoverBackground", { dark: Nr(up, 0.2), light: zu(up, 0.2), hcDark: up, hcLight: up }, f("buttonHoverBackground", "Button background color when hovering.")), MY = L("button.border", Je, f("buttonBorder", "Button border color.")), NY = L("button.secondaryForeground", { dark: Y.white, light: Y.white, hcDark: Y.white, hcLight: Re }, f("buttonSecondaryForeground", "Secondary button foreground color.")), LL = L("button.secondaryBackground", { dark: "#3A3D41", light: "#5F6A79", hcDark: null, hcLight: Y.white }, f("buttonSecondaryBackground", "Secondary button background color.")), TY = L("button.secondaryHoverBackground", { dark: Nr(LL, 0.2), light: zu(LL, 0.2), hcDark: null, hcLight: null }, f("buttonSecondaryHoverBackground", "Secondary button background color when hovering.")), gp = L("radio.activeForeground", G0, f("radioActiveForeground", "Foreground color of active radio option.")), BY = L("radio.activeBackground", R_, f("radioBackground", "Background color of active radio option.")), RY = L("radio.activeBorder", Q0, f("radioActiveBorder", "Border color of the active radio option.")), FY = L("radio.inactiveForeground", null, f("radioInactiveForeground", "Foreground color of inactive radio option.")), OY = L("radio.inactiveBackground", null, f("radioInactiveBackground", "Background color of inactive radio option.")), PY = L("radio.inactiveBorder", { light: Me(gp, 0.2), dark: Me(gp, 0.2), hcDark: Me(gp, 0.4), hcLight: Me(gp, 0.2) }, f("radioInactiveBorder", "Border color of the inactive radio option.")), HY = L("radio.inactiveHoverBackground", _Y, f("radioHoverBackground", "Background color of inactive active radio option when hovering.")), WY = L("checkbox.background", j0, f("checkbox.background", "Background color of checkbox widget."));
L("checkbox.selectBackground", Ao, f("checkbox.select.background", "Background color of checkbox widget when the element it's in is selected."));
const VY = L("checkbox.foreground", wN, f("checkbox.foreground", "Foreground color of checkbox widget.")), zY = L("checkbox.border", CN, f("checkbox.border", "Border color of checkbox widget."));
L("checkbox.selectBorder", CC, f("checkbox.select.border", "Border color of checkbox widget when the element it's in is selected."));
const UY = L("keybindingLabel.background", { dark: new Y(new qe(128, 128, 128, 0.17)), light: new Y(new qe(221, 221, 221, 0.4)), hcDark: Y.transparent, hcLight: Y.transparent }, f("keybindingLabelBackground", "Keybinding label background color. The keybinding label is used to represent a keyboard shortcut.")), QY = L("keybindingLabel.foreground", { dark: Y.fromHex("#CCCCCC"), light: Y.fromHex("#555555"), hcDark: Y.white, hcLight: Re }, f("keybindingLabelForeground", "Keybinding label foreground color. The keybinding label is used to represent a keyboard shortcut.")), GY = L("keybindingLabel.border", { dark: new Y(new qe(51, 51, 51, 0.6)), light: new Y(new qe(204, 204, 204, 0.4)), hcDark: new Y(new qe(111, 195, 223)), hcLight: Je }, f("keybindingLabelBorder", "Keybinding label border color. The keybinding label is used to represent a keyboard shortcut.")), jY = L("keybindingLabel.bottomBorder", { dark: new Y(new qe(68, 68, 68, 0.6)), light: new Y(new qe(187, 187, 187, 0.4)), hcDark: new Y(new qe(111, 195, 223)), hcLight: Re }, f("keybindingLabelBottomBorder", "Keybinding label border bottom color. The keybinding label is used to represent a keyboard shortcut.")), YY = L("list.focusBackground", null, f("listFocusBackground", "List/Tree background color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), KY = L("list.focusForeground", null, f("listFocusForeground", "List/Tree foreground color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), JY = L("list.focusOutline", { dark: ka, light: ka, hcDark: Kt, hcLight: Kt }, f("listFocusOutline", "List/Tree outline color for the focused item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), qY = L("list.focusAndSelectionOutline", null, f("listFocusAndSelectionOutline", "List/Tree outline color for the focused item when the list/tree is active and selected. An active list/tree has keyboard focus, an inactive does not.")), wu = L("list.activeSelectionBackground", { dark: "#04395E", light: "#0060C0", hcDark: null, hcLight: Y.fromHex("#0F4A85").transparent(0.1) }, f("listActiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), UA = L("list.activeSelectionForeground", { dark: Y.white, light: Y.white, hcDark: null, hcLight: null }, f("listActiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), n3 = L("list.activeSelectionIconForeground", null, f("listActiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is active. An active list/tree has keyboard focus, an inactive does not.")), $Y = L("list.inactiveSelectionBackground", { dark: "#37373D", light: "#E4E6F1", hcDark: null, hcLight: Y.fromHex("#0F4A85").transparent(0.1) }, f("listInactiveSelectionBackground", "List/Tree background color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), XY = L("list.inactiveSelectionForeground", null, f("listInactiveSelectionForeground", "List/Tree foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), ZY = L("list.inactiveSelectionIconForeground", null, f("listInactiveSelectionIconForeground", "List/Tree icon foreground color for the selected item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), eK = L("list.inactiveFocusBackground", null, f("listInactiveFocusBackground", "List/Tree background color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), tK = L("list.inactiveFocusOutline", null, f("listInactiveFocusOutline", "List/Tree outline color for the focused item when the list/tree is inactive. An active list/tree has keyboard focus, an inactive does not.")), s3 = L("list.hoverBackground", { dark: "#2A2D2E", light: "#F0F0F0", hcDark: Y.white.transparent(0.1), hcLight: Y.fromHex("#0F4A85").transparent(0.1) }, f("listHoverBackground", "List/Tree background when hovering over items using the mouse.")), o3 = L("list.hoverForeground", null, f("listHoverForeground", "List/Tree foreground when hovering over items using the mouse.")), iK = L("list.dropBackground", { dark: "#062F4A", light: "#D6EBFF", hcDark: null, hcLight: null }, f("listDropBackground", "List/Tree drag and drop background when moving items over other items when using the mouse.")), nK = L("list.dropBetweenBackground", { dark: CC, light: CC, hcDark: null, hcLight: null }, f("listDropBetweenBackground", "List/Tree drag and drop border color when moving items between items when using the mouse.")), Rg = L("list.highlightForeground", { dark: "#2AAAFF", light: "#0066BF", hcDark: ka, hcLight: ka }, f("highlight", "List/Tree foreground color of the match highlights when searching inside the list/tree.")), sK = L("list.focusHighlightForeground", { dark: Rg, light: Fj(wu, Rg, "#BBE7FF"), hcDark: Rg, hcLight: Rg }, f("listFocusHighlightForeground", "List/Tree foreground color of the match highlights on actively focused items when searching inside the list/tree."));
L("list.invalidItemForeground", { dark: "#B89500", light: "#B89500", hcDark: "#B89500", hcLight: "#B5200D" }, f("invalidItemForeground", "List/Tree foreground color for invalid items, for example an unresolved root in explorer."));
L("list.errorForeground", { dark: "#F88070", light: "#B01011", hcDark: null, hcLight: null }, f("listErrorForeground", "Foreground color of list items containing errors."));
L("list.warningForeground", { dark: "#CCA700", light: "#855F00", hcDark: null, hcLight: null }, f("listWarningForeground", "Foreground color of list items containing warnings."));
const oK = L("listFilterWidget.background", { light: zu(Ao, 0), dark: Nr(Ao, 0), hcDark: Ao, hcLight: Ao }, f("listFilterWidgetBackground", "Background color of the type filter widget in lists and trees.")), rK = L("listFilterWidget.outline", { dark: Y.transparent, light: Y.transparent, hcDark: "#f38518", hcLight: "#007ACC" }, f("listFilterWidgetOutline", "Outline color of the type filter widget in lists and trees.")), aK = L("listFilterWidget.noMatchesOutline", { dark: "#BE1100", light: "#BE1100", hcDark: Je, hcLight: Je }, f("listFilterWidgetNoMatchesOutline", "Outline color of the type filter widget in lists and trees, when there are no matches.")), lK = L("listFilterWidget.shadow", B_, f("listFilterWidgetShadow", "Shadow color of the type filter widget in lists and trees."));
L("list.filterMatchBackground", { dark: Cl, light: Cl, hcDark: null, hcLight: null }, f("listFilterMatchHighlight", "Background color of the filtered match."));
L("list.filterMatchBorder", { dark: Lc, light: Lc, hcDark: Je, hcLight: Kt }, f("listFilterMatchHighlightBorder", "Border color of the filtered match."));
L("list.deemphasizedForeground", { dark: "#8C8C8C", light: "#8E8E90", hcDark: "#A7A8A9", hcLight: "#666666" }, f("listDeemphasizedForeground", "List/Tree foreground color for items that are deemphasized."));
const r3 = L("tree.indentGuidesStroke", { dark: "#585858", light: "#a9a9a9", hcDark: "#a9a9a9", hcLight: "#a5a5a5" }, f("treeIndentGuidesStroke", "Tree stroke color for the indentation guides.")), cK = L("tree.inactiveIndentGuidesStroke", Me(r3, 0.4), f("treeInactiveIndentGuidesStroke", "Tree stroke color for the indentation guides that are not active.")), dK = L("tree.tableColumnsBorder", { dark: "#CCCCCC20", light: "#61616120", hcDark: null, hcLight: null }, f("tableColumnsBorder", "Table border color between columns.")), hK = L("tree.tableOddRowsBackground", { dark: Me(Re, 0.04), light: Me(Re, 0.04), hcDark: null, hcLight: null }, f("tableOddRowsBackgroundColor", "Background color for odd table rows."));
L("editorActionList.background", Ao, f("editorActionListBackground", "Action List background color."));
L("editorActionList.foreground", z0, f("editorActionListForeground", "Action List foreground color."));
L("editorActionList.focusForeground", UA, f("editorActionListFocusForeground", "Action List foreground color for the focused item."));
L("editorActionList.focusBackground", wu, f("editorActionListFocusBackground", "Action List background color for the focused item."));
const uK = L("menu.border", { dark: null, light: null, hcDark: Je, hcLight: Je }, f("menuBorder", "Border color of menus.")), gK = L("menu.foreground", wN, f("menuForeground", "Foreground color of menu items.")), fK = L("menu.background", j0, f("menuBackground", "Background color of menu items.")), mK = L("menu.selectionForeground", UA, f("menuSelectionForeground", "Foreground color of the selected menu item in menus.")), pK = L("menu.selectionBackground", wu, f("menuSelectionBackground", "Background color of the selected menu item in menus.")), AK = L("menu.selectionBorder", { dark: null, light: null, hcDark: Kt, hcLight: Kt }, f("menuSelectionBorder", "Border color of the selected menu item in menus.")), _K = L("menu.separatorBackground", { dark: "#606060", light: "#D4D4D4", hcDark: Je, hcLight: Je }, f("menuSeparatorBackground", "Color of a separator menu item in menus.")), I2 = L("quickInput.background", Ao, f("pickerBackground", "Quick picker background color. The quick picker widget is the container for pickers like the command palette.")), bK = L("quickInput.foreground", z0, f("pickerForeground", "Quick picker foreground color. The quick picker widget is the container for pickers like the command palette.")), wK = L("quickInputTitle.background", { dark: new Y(new qe(255, 255, 255, 0.105)), light: new Y(new qe(0, 0, 0, 0.06)), hcDark: "#000000", hcLight: Y.white }, f("pickerTitleBackground", "Quick picker title background color. The quick picker widget is the container for pickers like the command palette.")), a3 = L("pickerGroup.foreground", { dark: "#3794FF", light: "#0066BF", hcDark: Y.white, hcLight: "#0F4A85" }, f("pickerGroupForeground", "Quick picker color for grouping labels.")), CK = L("pickerGroup.border", { dark: "#3F3F46", light: "#CCCEDB", hcDark: Y.white, hcLight: "#0F4A85" }, f("pickerGroupBorder", "Quick picker color for grouping borders.")), M2 = L("quickInput.list.focusBackground", null, "", void 0, f("quickInput.list.focusBackground deprecation", "Please use quickInputList.focusBackground instead")), SC = L("quickInputList.focusForeground", UA, f("quickInput.listFocusForeground", "Quick picker foreground color for the focused item.")), vN = L("quickInputList.focusIconForeground", n3, f("quickInput.listFocusIconForeground", "Quick picker icon foreground color for the focused item.")), yC = L("quickInputList.focusBackground", { dark: WA(M2, wu), light: WA(M2, wu), hcDark: null, hcLight: null }, f("quickInput.listFocusBackground", "Quick picker background color for the focused item."));
L("search.resultsInfoForeground", { light: Re, dark: Me(Re, 0.65), hcDark: Re, hcLight: Re }, f("search.resultsInfoForeground", "Color of the text in the search viewlet's completion message."));
L("searchEditor.findMatchBackground", { light: Me(Cl, 0.66), dark: Me(Cl, 0.66), hcDark: Cl, hcLight: Cl }, f("searchEditor.queryMatch", "Color of the Search Editor query matches."));
L("searchEditor.findMatchBorder", { light: Me(Lc, 0.66), dark: Me(Lc, 0.66), hcDark: Lc, hcLight: Lc }, f("searchEditor.editorFindMatchBorder", "Border color of the Search Editor query matches."));
var vK = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, N2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const jl = We("hoverService");
let Kf = class extends V {
  get delay() {
    return this.isInstantlyHovering() ? 0 : this._delay;
  }
  constructor(e, t, i = {}, n, o) {
    super(), this.placement = e, this.instantHover = t, this.overrideOptions = i, this.configurationService = n, this.hoverService = o, this.lastHoverHideTime = 0, this.timeLimit = 200, this.hoverDisposables = this._register(new X()), this._delay = this.configurationService.getValue("workbench.hover.delay"), this._register(this.configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("workbench.hover.delay") && (this._delay = this.configurationService.getValue("workbench.hover.delay"));
    }));
  }
  showHover(e, t) {
    const i = typeof this.overrideOptions == "function" ? this.overrideOptions(e, t) : this.overrideOptions;
    this.hoverDisposables.clear();
    const n = Bi(e.target) ? [e.target] : e.target.targetElements;
    for (const r of n)
      this.hoverDisposables.add(Xt(r, "keydown", (a) => {
        a.equals(
          9
          /* KeyCode.Escape */
        ) && this.hoverService.hideHover();
      }));
    const o = Bi(e.content) ? void 0 : e.content.toString();
    return this.hoverService.showHover({
      ...e,
      ...i,
      persistence: {
        hideOnKeyDown: !0,
        ...i.persistence
      },
      id: o,
      appearance: {
        ...e.appearance,
        compact: !0,
        skipFadeInAnimation: this.isInstantlyHovering(),
        ...i.appearance
      }
    }, t);
  }
  isInstantlyHovering() {
    return this.instantHover && Date.now() - this.lastHoverHideTime < this.timeLimit;
  }
  onDidHideHover() {
    this.hoverDisposables.clear(), this.instantHover && (this.lastHoverHideTime = Date.now());
  }
};
Kf = vK([
  N2(3, ht),
  N2(4, jl)
], Kf);
const Yl = We("contextViewService"), ar = We("contextMenuService"), bt = We("keybindingService");
class Cm {
  constructor() {
    this._hooks = new X(), this._pointerMoveCallback = null, this._onStopCallback = null;
  }
  dispose() {
    this.stopMonitoring(!1), this._hooks.dispose();
  }
  stopMonitoring(e, t) {
    if (!this.isMonitoring())
      return;
    this._hooks.clear(), this._pointerMoveCallback = null;
    const i = this._onStopCallback;
    this._onStopCallback = null, e && i && i(t);
  }
  isMonitoring() {
    return !!this._pointerMoveCallback;
  }
  startMonitoring(e, t, i, n, o) {
    this.isMonitoring() && this.stopMonitoring(!1), this._pointerMoveCallback = n, this._onStopCallback = o;
    let r = e;
    try {
      e.setPointerCapture(t), this._hooks.add(we(() => {
        try {
          e.releasePointerCapture(t);
        } catch {
        }
      }));
    } catch {
      r = fe(e);
    }
    this._hooks.add(U(r, ee.POINTER_MOVE, (a) => {
      if (a.buttons !== i) {
        this.stopMonitoring(!0);
        return;
      }
      a.preventDefault(), this._pointerMoveCallback(a);
    })), this._hooks.add(U(r, ee.POINTER_UP, (a) => this.stopMonitoring(!0)));
  }
}
function oi(s, e, t) {
  let i = null, n = null;
  if (typeof t.value == "function" ? (i = "value", n = t.value, n.length !== 0 && console.warn("Memoize should only be used in functions with zero parameters")) : typeof t.get == "function" && (i = "get", n = t.get), !n)
    throw new Error("not supported");
  const o = `$memoize$${e}`;
  t[i] = function(...r) {
    return this.hasOwnProperty(o) || Object.defineProperty(this, o, {
      configurable: !1,
      enumerable: !1,
      writable: !1,
      value: n.apply(this, r)
    }), this[o];
  };
}
var SK = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Et;
(function(s) {
  s.Tap = "-monaco-gesturetap", s.Change = "-monaco-gesturechange", s.Start = "-monaco-gesturestart", s.End = "-monaco-gesturesend", s.Contextmenu = "-monaco-gesturecontextmenu";
})(Et || (Et = {}));
const $i = class $i extends V {
  // ms
  constructor() {
    super(), this.dispatched = !1, this.targets = new Nn(), this.ignoreTargets = new Nn(), this.activeTouches = {}, this.handle = null, this._lastSetTapCountTime = 0, this._register(te.runAndSubscribe(S0, ({ window: e, disposables: t }) => {
      t.add(U(e.document, "touchstart", (i) => this.onTouchStart(i), { passive: !1 })), t.add(U(e.document, "touchend", (i) => this.onTouchEnd(e, i))), t.add(U(e.document, "touchmove", (i) => this.onTouchMove(i), { passive: !1 }));
    }, { window: vt, disposables: this._store }));
  }
  static addTarget(e) {
    if (!$i.isTouchDevice())
      return V.None;
    $i.INSTANCE || ($i.INSTANCE = new $i());
    const t = $i.INSTANCE.targets.push(e);
    return we(t);
  }
  static ignoreTarget(e) {
    if (!$i.isTouchDevice())
      return V.None;
    $i.INSTANCE || ($i.INSTANCE = new $i());
    const t = $i.INSTANCE.ignoreTargets.push(e);
    return we(t);
  }
  static isTouchDevice() {
    return "ontouchstart" in vt || navigator.maxTouchPoints > 0;
  }
  dispose() {
    this.handle && (this.handle.dispose(), this.handle = null), super.dispose();
  }
  onTouchStart(e) {
    const t = Date.now();
    this.handle && (this.handle.dispose(), this.handle = null);
    for (let i = 0, n = e.targetTouches.length; i < n; i++) {
      const o = e.targetTouches.item(i);
      this.activeTouches[o.identifier] = {
        id: o.identifier,
        initialTarget: o.target,
        initialTimeStamp: t,
        initialPageX: o.pageX,
        initialPageY: o.pageY,
        rollingTimestamps: [t],
        rollingPageX: [o.pageX],
        rollingPageY: [o.pageY]
      };
      const r = this.newGestureEvent(Et.Start, o.target);
      r.pageX = o.pageX, r.pageY = o.pageY, this.dispatchEvent(r);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
  onTouchEnd(e, t) {
    const i = Date.now(), n = Object.keys(this.activeTouches).length;
    for (let o = 0, r = t.changedTouches.length; o < r; o++) {
      const a = t.changedTouches.item(o);
      if (!this.activeTouches.hasOwnProperty(String(a.identifier))) {
        console.warn("move of an UNKNOWN touch", a);
        continue;
      }
      const l = this.activeTouches[a.identifier], c = Date.now() - l.initialTimeStamp;
      if (c < $i.HOLD_DELAY && Math.abs(l.initialPageX - oo(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - oo(l.rollingPageY)) < 30) {
        const d = this.newGestureEvent(Et.Tap, l.initialTarget);
        d.pageX = oo(l.rollingPageX), d.pageY = oo(l.rollingPageY), this.dispatchEvent(d);
      } else if (c >= $i.HOLD_DELAY && Math.abs(l.initialPageX - oo(l.rollingPageX)) < 30 && Math.abs(l.initialPageY - oo(l.rollingPageY)) < 30) {
        const d = this.newGestureEvent(Et.Contextmenu, l.initialTarget);
        d.pageX = oo(l.rollingPageX), d.pageY = oo(l.rollingPageY), this.dispatchEvent(d);
      } else if (n === 1) {
        const d = oo(l.rollingPageX), h = oo(l.rollingPageY), u = oo(l.rollingTimestamps) - l.rollingTimestamps[0], g = d - l.rollingPageX[0], m = h - l.rollingPageY[0], p = [...this.targets].filter((A) => l.initialTarget instanceof Node && A.contains(l.initialTarget));
        this.inertia(
          e,
          p,
          i,
          // time now
          Math.abs(g) / u,
          // speed
          g > 0 ? 1 : -1,
          // x direction
          d,
          // x now
          Math.abs(m) / u,
          // y speed
          m > 0 ? 1 : -1,
          // y direction
          h
          // y now
        );
      }
      this.dispatchEvent(this.newGestureEvent(Et.End, l.initialTarget)), delete this.activeTouches[a.identifier];
    }
    this.dispatched && (t.preventDefault(), t.stopPropagation(), this.dispatched = !1);
  }
  newGestureEvent(e, t) {
    const i = document.createEvent("CustomEvent");
    return i.initEvent(e, !1, !0), i.initialTarget = t, i.tapCount = 0, i;
  }
  dispatchEvent(e) {
    if (e.type === Et.Tap) {
      const t = (/* @__PURE__ */ new Date()).getTime();
      let i = 0;
      t - this._lastSetTapCountTime > $i.CLEAR_TAP_COUNT_TIME ? i = 1 : i = 2, this._lastSetTapCountTime = t, e.tapCount = i;
    } else (e.type === Et.Change || e.type === Et.Contextmenu) && (this._lastSetTapCountTime = 0);
    if (e.initialTarget instanceof Node) {
      for (const i of this.ignoreTargets)
        if (i.contains(e.initialTarget))
          return;
      const t = [];
      for (const i of this.targets)
        if (i.contains(e.initialTarget)) {
          let n = 0, o = e.initialTarget;
          for (; o && o !== i; )
            n++, o = o.parentElement;
          t.push([n, i]);
        }
      t.sort((i, n) => i[0] - n[0]);
      for (const [i, n] of t)
        n.dispatchEvent(e), this.dispatched = !0;
    }
  }
  inertia(e, t, i, n, o, r, a, l, c) {
    this.handle = ys(e, () => {
      const d = Date.now(), h = d - i;
      let u = 0, g = 0, m = !0;
      n += $i.SCROLL_FRICTION * h, a += $i.SCROLL_FRICTION * h, n > 0 && (m = !1, u = o * n * h), a > 0 && (m = !1, g = l * a * h);
      const p = this.newGestureEvent(Et.Change);
      p.translationX = u, p.translationY = g, t.forEach((A) => A.dispatchEvent(p)), m || this.inertia(e, t, d, n, o, r + u, a, l, c + g);
    });
  }
  onTouchMove(e) {
    const t = Date.now();
    for (let i = 0, n = e.changedTouches.length; i < n; i++) {
      const o = e.changedTouches.item(i);
      if (!this.activeTouches.hasOwnProperty(String(o.identifier))) {
        console.warn("end of an UNKNOWN touch", o);
        continue;
      }
      const r = this.activeTouches[o.identifier], a = this.newGestureEvent(Et.Change, r.initialTarget);
      a.translationX = o.pageX - oo(r.rollingPageX), a.translationY = o.pageY - oo(r.rollingPageY), a.pageX = o.pageX, a.pageY = o.pageY, this.dispatchEvent(a), r.rollingPageX.length > 3 && (r.rollingPageX.shift(), r.rollingPageY.shift(), r.rollingTimestamps.shift()), r.rollingPageX.push(o.pageX), r.rollingPageY.push(o.pageY), r.rollingTimestamps.push(t);
    }
    this.dispatched && (e.preventDefault(), e.stopPropagation(), this.dispatched = !1);
  }
};
$i.SCROLL_FRICTION = -5e-3, $i.HOLD_DELAY = 700, $i.CLEAR_TAP_COUNT_TIME = 400;
let xn = $i;
SK([
  oi
], xn, "isTouchDevice", null);
let to = class extends V {
  onclick(e, t) {
    this._register(U(e, ee.CLICK, (i) => t(new Ir(fe(e), i))));
  }
  onmousedown(e, t) {
    this._register(U(e, ee.MOUSE_DOWN, (i) => t(new Ir(fe(e), i))));
  }
  onmouseover(e, t) {
    this._register(U(e, ee.MOUSE_OVER, (i) => t(new Ir(fe(e), i))));
  }
  onmouseleave(e, t) {
    this._register(U(e, ee.MOUSE_LEAVE, (i) => t(new Ir(fe(e), i))));
  }
  onkeydown(e, t) {
    this._register(U(e, ee.KEY_DOWN, (i) => t(new Mt(i))));
  }
  onkeyup(e, t) {
    this._register(U(e, ee.KEY_UP, (i) => t(new Mt(i))));
  }
  oninput(e, t) {
    this._register(U(e, ee.INPUT, t));
  }
  onblur(e, t) {
    this._register(U(e, ee.BLUR, t));
  }
  onfocus(e, t) {
    this._register(U(e, ee.FOCUS, t));
  }
  ignoreGesture(e) {
    return xn.ignoreTarget(e);
  }
};
const Jf = 11;
class yK extends to {
  constructor(e) {
    super(), this._onActivate = e.onActivate, this.bgDomNode = document.createElement("div"), this.bgDomNode.className = "arrow-background", this.bgDomNode.style.position = "absolute", this.bgDomNode.style.width = e.bgWidth + "px", this.bgDomNode.style.height = e.bgHeight + "px", typeof e.top < "u" && (this.bgDomNode.style.top = "0px"), typeof e.left < "u" && (this.bgDomNode.style.left = "0px"), typeof e.bottom < "u" && (this.bgDomNode.style.bottom = "0px"), typeof e.right < "u" && (this.bgDomNode.style.right = "0px"), this.domNode = document.createElement("div"), this.domNode.className = e.className, this.domNode.classList.add(...pe.asClassNameArray(e.icon)), this.domNode.style.position = "absolute", this.domNode.style.width = Jf + "px", this.domNode.style.height = Jf + "px", typeof e.top < "u" && (this.domNode.style.top = e.top + "px"), typeof e.left < "u" && (this.domNode.style.left = e.left + "px"), typeof e.bottom < "u" && (this.domNode.style.bottom = e.bottom + "px"), typeof e.right < "u" && (this.domNode.style.right = e.right + "px"), this._pointerMoveMonitor = this._register(new Cm()), this._register(Xt(this.bgDomNode, ee.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._register(Xt(this.domNode, ee.POINTER_DOWN, (t) => this._arrowPointerDown(t))), this._pointerdownRepeatTimer = this._register(new YM()), this._pointerdownScheduleRepeatTimer = this._register(new nr());
  }
  _arrowPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = () => {
      this._pointerdownRepeatTimer.cancelAndSet(() => this._onActivate(), 1e3 / 24, fe(e));
    };
    this._onActivate(), this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancelAndSet(t, 200), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (i) => {
    }, () => {
      this._pointerdownRepeatTimer.cancel(), this._pointerdownScheduleRepeatTimer.cancel();
    }), e.preventDefault();
  }
}
class xK extends V {
  constructor(e, t, i) {
    super(), this._visibility = e, this._visibleClassName = t, this._invisibleClassName = i, this._domNode = null, this._isVisible = !1, this._isNeeded = !1, this._rawShouldBeVisible = !1, this._shouldBeVisible = !1, this._revealTimer = this._register(new nr());
  }
  setVisibility(e) {
    this._visibility !== e && (this._visibility = e, this._updateShouldBeVisible());
  }
  // ----------------- Hide / Reveal
  setShouldBeVisible(e) {
    this._rawShouldBeVisible = e, this._updateShouldBeVisible();
  }
  _applyVisibilitySetting() {
    return this._visibility === 2 ? !1 : this._visibility === 3 ? !0 : this._rawShouldBeVisible;
  }
  _updateShouldBeVisible() {
    const e = this._applyVisibilitySetting();
    this._shouldBeVisible !== e && (this._shouldBeVisible = e, this.ensureVisibility());
  }
  setIsNeeded(e) {
    this._isNeeded !== e && (this._isNeeded = e, this.ensureVisibility());
  }
  setDomNode(e) {
    this._domNode = e, this._domNode.setClassName(this._invisibleClassName), this.setShouldBeVisible(!1);
  }
  ensureVisibility() {
    if (!this._isNeeded) {
      this._hide(!1);
      return;
    }
    this._shouldBeVisible ? this._reveal() : this._hide(!0);
  }
  _reveal() {
    this._isVisible || (this._isVisible = !0, this._revealTimer.setIfNotSet(() => {
      this._domNode?.setClassName(this._visibleClassName);
    }, 0));
  }
  _hide(e) {
    this._revealTimer.cancel(), this._isVisible && (this._isVisible = !1, this._domNode?.setClassName(this._invisibleClassName + (e ? " fade" : "")));
  }
}
const EK = 140;
class l3 extends to {
  constructor(e) {
    super(), this._lazyRender = e.lazyRender, this._host = e.host, this._scrollable = e.scrollable, this._scrollByPage = e.scrollByPage, this._scrollbarState = e.scrollbarState, this._visibilityController = this._register(new xK(e.visibility, "visible scrollbar " + e.extraScrollbarClassName, "invisible scrollbar " + e.extraScrollbarClassName)), this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._pointerMoveMonitor = this._register(new Cm()), this._shouldRender = !0, this.domNode = rt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this._visibilityController.setDomNode(this.domNode), this.domNode.setPosition("absolute"), this._register(U(this.domNode.domNode, ee.POINTER_DOWN, (t) => this._domNodePointerDown(t)));
  }
  // ----------------- creation
  /**
   * Creates the dom node for an arrow & adds it to the container
   */
  _createArrow(e) {
    const t = this._register(new yK(e));
    this.domNode.domNode.appendChild(t.bgDomNode), this.domNode.domNode.appendChild(t.domNode);
  }
  /**
   * Creates the slider dom node, adds it to the container & hooks up the events
   */
  _createSlider(e, t, i, n) {
    this.slider = rt(document.createElement("div")), this.slider.setClassName("slider"), this.slider.setPosition("absolute"), this.slider.setTop(e), this.slider.setLeft(t), typeof i == "number" && this.slider.setWidth(i), typeof n == "number" && this.slider.setHeight(n), this.slider.setLayerHinting(!0), this.slider.setContain("strict"), this.domNode.domNode.appendChild(this.slider.domNode), this._register(U(this.slider.domNode, ee.POINTER_DOWN, (o) => {
      o.button === 0 && (o.preventDefault(), this._sliderPointerDown(o));
    })), this.onclick(this.slider.domNode, (o) => {
      o.leftButton && o.stopPropagation();
    });
  }
  // ----------------- Update state
  _onElementSize(e) {
    return this._scrollbarState.setVisibleSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollSize(e) {
    return this._scrollbarState.setScrollSize(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  _onElementScrollPosition(e) {
    return this._scrollbarState.setScrollPosition(e) && (this._visibilityController.setIsNeeded(this._scrollbarState.isNeeded()), this._shouldRender = !0, this._lazyRender || this.render()), this._shouldRender;
  }
  // ----------------- rendering
  beginReveal() {
    this._visibilityController.setShouldBeVisible(!0);
  }
  beginHide() {
    this._visibilityController.setShouldBeVisible(!1);
  }
  render() {
    this._shouldRender && (this._shouldRender = !1, this._renderDomNode(this._scrollbarState.getRectangleLargeSize(), this._scrollbarState.getRectangleSmallSize()), this._updateSlider(this._scrollbarState.getSliderSize(), this._scrollbarState.getArrowSize() + this._scrollbarState.getSliderPosition()));
  }
  // ----------------- DOM events
  _domNodePointerDown(e) {
    e.target === this.domNode.domNode && this._onPointerDown(e);
  }
  delegatePointerDown(e) {
    const t = this.domNode.domNode.getClientRects()[0].top, i = t + this._scrollbarState.getSliderPosition(), n = t + this._scrollbarState.getSliderPosition() + this._scrollbarState.getSliderSize(), o = this._sliderPointerPosition(e);
    i <= o && o <= n ? e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e)) : this._onPointerDown(e);
  }
  _onPointerDown(e) {
    let t, i;
    if (e.target === this.domNode.domNode && typeof e.offsetX == "number" && typeof e.offsetY == "number")
      t = e.offsetX, i = e.offsetY;
    else {
      const o = ui(this.domNode.domNode);
      t = e.pageX - o.left, i = e.pageY - o.top;
    }
    const n = this._pointerDownRelativePosition(t, i);
    this._setDesiredScrollPositionNow(this._scrollByPage ? this._scrollbarState.getDesiredScrollPositionFromOffsetPaged(n) : this._scrollbarState.getDesiredScrollPositionFromOffset(n)), e.button === 0 && (e.preventDefault(), this._sliderPointerDown(e));
  }
  _sliderPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._sliderPointerPosition(e), i = this._sliderOrthogonalPointerPosition(e), n = this._scrollbarState.clone();
    this.slider.toggleClassName("active", !0), this._pointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (o) => {
      const r = this._sliderOrthogonalPointerPosition(o), a = Math.abs(r - i);
      if (yn && a > EK) {
        this._setDesiredScrollPositionNow(n.getScrollPosition());
        return;
      }
      const c = this._sliderPointerPosition(o) - t;
      this._setDesiredScrollPositionNow(n.getDesiredScrollPositionFromDelta(c));
    }, () => {
      this.slider.toggleClassName("active", !1), this._host.onDragEnd();
    }), this._host.onDragStart();
  }
  _setDesiredScrollPositionNow(e) {
    const t = {};
    this.writeScrollPosition(t, e), this._scrollable.setScrollPositionNow(t);
  }
  updateScrollbarSize(e) {
    this._updateScrollbarSize(e), this._scrollbarState.setScrollbarSize(e), this._shouldRender = !0, this._lazyRender || this.render();
  }
  isNeeded() {
    return this._scrollbarState.isNeeded();
  }
}
const LK = 20;
class qf {
  constructor(e, t, i, n, o, r) {
    this._scrollbarSize = Math.round(t), this._oppositeScrollbarSize = Math.round(i), this._arrowSize = Math.round(e), this._visibleSize = n, this._scrollSize = o, this._scrollPosition = r, this._computedAvailableSize = 0, this._computedIsNeeded = !1, this._computedSliderSize = 0, this._computedSliderRatio = 0, this._computedSliderPosition = 0, this._refreshComputedValues();
  }
  clone() {
    return new qf(this._arrowSize, this._scrollbarSize, this._oppositeScrollbarSize, this._visibleSize, this._scrollSize, this._scrollPosition);
  }
  setVisibleSize(e) {
    const t = Math.round(e);
    return this._visibleSize !== t ? (this._visibleSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollSize(e) {
    const t = Math.round(e);
    return this._scrollSize !== t ? (this._scrollSize = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollPosition(e) {
    const t = Math.round(e);
    return this._scrollPosition !== t ? (this._scrollPosition = t, this._refreshComputedValues(), !0) : !1;
  }
  setScrollbarSize(e) {
    this._scrollbarSize = Math.round(e);
  }
  setOppositeScrollbarSize(e) {
    this._oppositeScrollbarSize = Math.round(e);
  }
  static _computeValues(e, t, i, n, o) {
    const r = Math.max(0, i - e), a = Math.max(0, r - 2 * t), l = n > 0 && n > i;
    if (!l)
      return {
        computedAvailableSize: Math.round(r),
        computedIsNeeded: l,
        computedSliderSize: Math.round(a),
        computedSliderRatio: 0,
        computedSliderPosition: 0
      };
    const c = Math.round(Math.max(LK, Math.floor(i * a / n))), d = (a - c) / (n - i), h = o * d;
    return {
      computedAvailableSize: Math.round(r),
      computedIsNeeded: l,
      computedSliderSize: Math.round(c),
      computedSliderRatio: d,
      computedSliderPosition: Math.round(h)
    };
  }
  _refreshComputedValues() {
    const e = qf._computeValues(this._oppositeScrollbarSize, this._arrowSize, this._visibleSize, this._scrollSize, this._scrollPosition);
    this._computedAvailableSize = e.computedAvailableSize, this._computedIsNeeded = e.computedIsNeeded, this._computedSliderSize = e.computedSliderSize, this._computedSliderRatio = e.computedSliderRatio, this._computedSliderPosition = e.computedSliderPosition;
  }
  getArrowSize() {
    return this._arrowSize;
  }
  getScrollPosition() {
    return this._scrollPosition;
  }
  getRectangleLargeSize() {
    return this._computedAvailableSize;
  }
  getRectangleSmallSize() {
    return this._scrollbarSize;
  }
  isNeeded() {
    return this._computedIsNeeded;
  }
  getSliderSize() {
    return this._computedSliderSize;
  }
  getSliderPosition() {
    return this._computedSliderPosition;
  }
  /**
   * Compute a desired `scrollPosition` such that `offset` ends up in the center of the slider.
   * `offset` is based on the same coordinate system as the `sliderPosition`.
   */
  getDesiredScrollPositionFromOffset(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize - this._computedSliderSize / 2;
    return Math.round(t / this._computedSliderRatio);
  }
  /**
   * Compute a desired `scrollPosition` from if offset is before or after the slider position.
   * If offset is before slider, treat as a page up (or left).  If after, page down (or right).
   * `offset` and `_computedSliderPosition` are based on the same coordinate system.
   * `_visibleSize` corresponds to a "page" of lines in the returned coordinate system.
   */
  getDesiredScrollPositionFromOffsetPaged(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = e - this._arrowSize;
    let i = this._scrollPosition;
    return t < this._computedSliderPosition ? i -= this._visibleSize : i += this._visibleSize, i;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollPositionFromDelta(e) {
    if (!this._computedIsNeeded)
      return 0;
    const t = this._computedSliderPosition + e;
    return Math.round(t / this._computedSliderRatio);
  }
}
class kK extends l3 {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new qf(t.horizontalHasArrows ? t.arrowSize : 0, t.horizontal === 2 ? 0 : t.horizontalScrollbarSize, t.vertical === 2 ? 0 : t.verticalScrollbarSize, n.width, n.scrollWidth, o.scrollLeft),
      visibility: t.horizontal,
      extraScrollbarClassName: "horizontal",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.horizontalHasArrows) {
      const r = (t.arrowSize - Jf) / 2, a = (t.horizontalScrollbarSize - Jf) / 2;
      this._createArrow({
        className: "scra",
        icon: Z.scrollbarButtonLeft,
        top: a,
        left: r,
        bottom: void 0,
        right: void 0,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new fu(null, 1, 0))
      }), this._createArrow({
        className: "scra",
        icon: Z.scrollbarButtonRight,
        top: a,
        left: void 0,
        bottom: void 0,
        right: r,
        bgWidth: t.arrowSize,
        bgHeight: t.horizontalScrollbarSize,
        onActivate: () => this._host.onMouseWheel(new fu(null, -1, 0))
      });
    }
    this._createSlider(Math.floor((t.horizontalScrollbarSize - t.horizontalSliderSize) / 2), 0, void 0, t.horizontalSliderSize);
  }
  _updateSlider(e, t) {
    this.slider.setWidth(e), this.slider.setLeft(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(e), this.domNode.setHeight(t), this.domNode.setLeft(0), this.domNode.setBottom(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollWidth) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollLeft) || this._shouldRender, this._shouldRender = this._onElementSize(e.width) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return e;
  }
  _sliderPointerPosition(e) {
    return e.pageX;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageY;
  }
  _updateScrollbarSize(e) {
    this.slider.setHeight(e);
  }
  writeScrollPosition(e, t) {
    e.scrollLeft = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.horizontal === 2 ? 0 : e.horizontalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._visibilityController.setVisibility(e.horizontal), this._scrollByPage = e.scrollByPage;
  }
}
class DK extends l3 {
  constructor(e, t, i) {
    const n = e.getScrollDimensions(), o = e.getCurrentScrollPosition();
    if (super({
      lazyRender: t.lazyRender,
      host: i,
      scrollbarState: new qf(
        t.verticalHasArrows ? t.arrowSize : 0,
        t.vertical === 2 ? 0 : t.verticalScrollbarSize,
        // give priority to vertical scroll bar over horizontal and let it scroll all the way to the bottom
        0,
        n.height,
        n.scrollHeight,
        o.scrollTop
      ),
      visibility: t.vertical,
      extraScrollbarClassName: "vertical",
      scrollable: e,
      scrollByPage: t.scrollByPage
    }), t.verticalHasArrows) {
      const r = (t.arrowSize - Jf) / 2, a = (t.verticalScrollbarSize - Jf) / 2;
      this._createArrow({
        className: "scra",
        icon: Z.scrollbarButtonUp,
        top: r,
        left: a,
        bottom: void 0,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new fu(null, 0, 1))
      }), this._createArrow({
        className: "scra",
        icon: Z.scrollbarButtonDown,
        top: void 0,
        left: a,
        bottom: r,
        right: void 0,
        bgWidth: t.verticalScrollbarSize,
        bgHeight: t.arrowSize,
        onActivate: () => this._host.onMouseWheel(new fu(null, 0, -1))
      });
    }
    this._createSlider(0, Math.floor((t.verticalScrollbarSize - t.verticalSliderSize) / 2), t.verticalSliderSize, void 0);
  }
  _updateSlider(e, t) {
    this.slider.setHeight(e), this.slider.setTop(t);
  }
  _renderDomNode(e, t) {
    this.domNode.setWidth(t), this.domNode.setHeight(e), this.domNode.setRight(0), this.domNode.setTop(0);
  }
  onDidScroll(e) {
    return this._shouldRender = this._onElementScrollSize(e.scrollHeight) || this._shouldRender, this._shouldRender = this._onElementScrollPosition(e.scrollTop) || this._shouldRender, this._shouldRender = this._onElementSize(e.height) || this._shouldRender, this._shouldRender;
  }
  _pointerDownRelativePosition(e, t) {
    return t;
  }
  _sliderPointerPosition(e) {
    return e.pageY;
  }
  _sliderOrthogonalPointerPosition(e) {
    return e.pageX;
  }
  _updateScrollbarSize(e) {
    this.slider.setWidth(e);
  }
  writeScrollPosition(e, t) {
    e.scrollTop = t;
  }
  updateOptions(e) {
    this.updateScrollbarSize(e.vertical === 2 ? 0 : e.verticalScrollbarSize), this._scrollbarState.setOppositeScrollbarSize(0), this._visibilityController.setVisibility(e.vertical), this._scrollByPage = e.scrollByPage;
  }
}
class xC {
  constructor(e, t, i, n, o, r, a) {
    this._forceIntegerValues = e, this._scrollStateBrand = void 0, this._forceIntegerValues && (t = t | 0, i = i | 0, n = n | 0, o = o | 0, r = r | 0, a = a | 0), this.rawScrollLeft = n, this.rawScrollTop = a, t < 0 && (t = 0), n + t > i && (n = i - t), n < 0 && (n = 0), o < 0 && (o = 0), a + o > r && (a = r - o), a < 0 && (a = 0), this.width = t, this.scrollWidth = i, this.scrollLeft = n, this.height = o, this.scrollHeight = r, this.scrollTop = a;
  }
  equals(e) {
    return this.rawScrollLeft === e.rawScrollLeft && this.rawScrollTop === e.rawScrollTop && this.width === e.width && this.scrollWidth === e.scrollWidth && this.scrollLeft === e.scrollLeft && this.height === e.height && this.scrollHeight === e.scrollHeight && this.scrollTop === e.scrollTop;
  }
  withScrollDimensions(e, t) {
    return new xC(this._forceIntegerValues, typeof e.width < "u" ? e.width : this.width, typeof e.scrollWidth < "u" ? e.scrollWidth : this.scrollWidth, t ? this.rawScrollLeft : this.scrollLeft, typeof e.height < "u" ? e.height : this.height, typeof e.scrollHeight < "u" ? e.scrollHeight : this.scrollHeight, t ? this.rawScrollTop : this.scrollTop);
  }
  withScrollPosition(e) {
    return new xC(this._forceIntegerValues, this.width, this.scrollWidth, typeof e.scrollLeft < "u" ? e.scrollLeft : this.rawScrollLeft, this.height, this.scrollHeight, typeof e.scrollTop < "u" ? e.scrollTop : this.rawScrollTop);
  }
  createScrollEvent(e, t) {
    const i = this.width !== e.width, n = this.scrollWidth !== e.scrollWidth, o = this.scrollLeft !== e.scrollLeft, r = this.height !== e.height, a = this.scrollHeight !== e.scrollHeight, l = this.scrollTop !== e.scrollTop;
    return {
      inSmoothScrolling: t,
      oldWidth: e.width,
      oldScrollWidth: e.scrollWidth,
      oldScrollLeft: e.scrollLeft,
      width: this.width,
      scrollWidth: this.scrollWidth,
      scrollLeft: this.scrollLeft,
      oldHeight: e.height,
      oldScrollHeight: e.scrollHeight,
      oldScrollTop: e.scrollTop,
      height: this.height,
      scrollHeight: this.scrollHeight,
      scrollTop: this.scrollTop,
      widthChanged: i,
      scrollWidthChanged: n,
      scrollLeftChanged: o,
      heightChanged: r,
      scrollHeightChanged: a,
      scrollTopChanged: l
    };
  }
}
class vm extends V {
  constructor(e) {
    super(), this._scrollableBrand = void 0, this._onScroll = this._register(new B()), this.onScroll = this._onScroll.event, this._smoothScrollDuration = e.smoothScrollDuration, this._scheduleAtNextAnimationFrame = e.scheduleAtNextAnimationFrame, this._state = new xC(e.forceIntegerValues, 0, 0, 0, 0, 0, 0), this._smoothScrolling = null;
  }
  dispose() {
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), super.dispose();
  }
  setSmoothScrollDuration(e) {
    this._smoothScrollDuration = e;
  }
  validateScrollPosition(e) {
    return this._state.withScrollPosition(e);
  }
  getScrollDimensions() {
    return this._state;
  }
  setScrollDimensions(e, t) {
    const i = this._state.withScrollDimensions(e, t);
    this._setState(i, !!this._smoothScrolling), this._smoothScrolling?.acceptScrollDimensions(this._state);
  }
  /**
   * Returns the final scroll position that the instance will have once the smooth scroll animation concludes.
   * If no scroll animation is occurring, it will return the current scroll position instead.
   */
  getFutureScrollPosition() {
    return this._smoothScrolling ? this._smoothScrolling.to : this._state;
  }
  /**
   * Returns the current scroll position.
   * Note: This result might be an intermediate scroll position, as there might be an ongoing smooth scroll animation.
   */
  getCurrentScrollPosition() {
    return this._state;
  }
  setScrollPositionNow(e) {
    const t = this._state.withScrollPosition(e);
    this._smoothScrolling && (this._smoothScrolling.dispose(), this._smoothScrolling = null), this._setState(t, !1);
  }
  setScrollPositionSmooth(e, t) {
    if (this._smoothScrollDuration === 0)
      return this.setScrollPositionNow(e);
    if (this._smoothScrolling) {
      e = {
        scrollLeft: typeof e.scrollLeft > "u" ? this._smoothScrolling.to.scrollLeft : e.scrollLeft,
        scrollTop: typeof e.scrollTop > "u" ? this._smoothScrolling.to.scrollTop : e.scrollTop
      };
      const i = this._state.withScrollPosition(e);
      if (this._smoothScrolling.to.scrollLeft === i.scrollLeft && this._smoothScrolling.to.scrollTop === i.scrollTop)
        return;
      let n;
      t ? n = new QA(this._smoothScrolling.from, i, this._smoothScrolling.startTime, this._smoothScrolling.duration) : n = this._smoothScrolling.combine(this._state, i, this._smoothScrollDuration), this._smoothScrolling.dispose(), this._smoothScrolling = n;
    } else {
      const i = this._state.withScrollPosition(e);
      this._smoothScrolling = QA.start(this._state, i, this._smoothScrollDuration);
    }
    this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
      this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
    });
  }
  hasPendingScrollAnimation() {
    return !!this._smoothScrolling;
  }
  _performSmoothScrolling() {
    if (!this._smoothScrolling)
      return;
    const e = this._smoothScrolling.tick(), t = this._state.withScrollPosition(e);
    if (this._setState(t, !0), !!this._smoothScrolling) {
      if (e.isDone) {
        this._smoothScrolling.dispose(), this._smoothScrolling = null;
        return;
      }
      this._smoothScrolling.animationFrameDisposable = this._scheduleAtNextAnimationFrame(() => {
        this._smoothScrolling && (this._smoothScrolling.animationFrameDisposable = null, this._performSmoothScrolling());
      });
    }
  }
  _setState(e, t) {
    const i = this._state;
    i.equals(e) || (this._state = e, this._onScroll.fire(this._state.createScrollEvent(i, t)));
  }
}
class T2 {
  constructor(e, t, i) {
    this.scrollLeft = e, this.scrollTop = t, this.isDone = i;
  }
}
function yy(s, e) {
  const t = e - s;
  return function(i) {
    return s + t * NK(i);
  };
}
function IK(s, e, t) {
  return function(i) {
    return i < t ? s(i / t) : e((i - t) / (1 - t));
  };
}
class QA {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.duration = n, this.startTime = i, this.animationFrameDisposable = null, this._initAnimations();
  }
  _initAnimations() {
    this.scrollLeft = this._initAnimation(this.from.scrollLeft, this.to.scrollLeft, this.to.width), this.scrollTop = this._initAnimation(this.from.scrollTop, this.to.scrollTop, this.to.height);
  }
  _initAnimation(e, t, i) {
    if (Math.abs(e - t) > 2.5 * i) {
      let o, r;
      return e < t ? (o = e + 0.75 * i, r = t - 0.75 * i) : (o = e - 0.75 * i, r = t + 0.75 * i), IK(yy(e, o), yy(r, t), 0.33);
    }
    return yy(e, t);
  }
  dispose() {
    this.animationFrameDisposable !== null && (this.animationFrameDisposable.dispose(), this.animationFrameDisposable = null);
  }
  acceptScrollDimensions(e) {
    this.to = e.withScrollPosition(this.to), this._initAnimations();
  }
  tick() {
    return this._tick(Date.now());
  }
  _tick(e) {
    const t = (e - this.startTime) / this.duration;
    if (t < 1) {
      const i = this.scrollLeft(t), n = this.scrollTop(t);
      return new T2(i, n, !1);
    }
    return new T2(this.to.scrollLeft, this.to.scrollTop, !0);
  }
  combine(e, t, i) {
    return QA.start(e, t, i);
  }
  static start(e, t, i) {
    i = i + 10;
    const n = Date.now() - 10;
    return new QA(e, t, n, i);
  }
}
function MK(s) {
  return Math.pow(s, 3);
}
function NK(s) {
  return 1 - MK(1 - s);
}
const TK = 500, B2 = 50;
class BK {
  constructor(e, t, i) {
    this.timestamp = e, this.deltaX = t, this.deltaY = i, this.score = 0;
  }
}
const y1 = class y1 {
  constructor() {
    this._capacity = 5, this._memory = [], this._front = -1, this._rear = -1;
  }
  isPhysicalMouseWheel() {
    if (this._front === -1 && this._rear === -1)
      return !1;
    let e = 1, t = 0, i = 1, n = this._rear;
    do {
      const o = n === this._front ? e : Math.pow(2, -i);
      if (e -= o, t += this._memory[n].score * o, n === this._front)
        break;
      n = (this._capacity + n - 1) % this._capacity, i++;
    } while (!0);
    return t <= 0.5;
  }
  acceptStandardWheelEvent(e) {
    if (I_) {
      const t = fe(e.browserEvent), i = U7(t);
      this.accept(Date.now(), e.deltaX * i, e.deltaY * i);
    } else
      this.accept(Date.now(), e.deltaX, e.deltaY);
  }
  accept(e, t, i) {
    let n = null;
    const o = new BK(e, t, i);
    this._front === -1 && this._rear === -1 ? (this._memory[0] = o, this._front = 0, this._rear = 0) : (n = this._memory[this._rear], this._rear = (this._rear + 1) % this._capacity, this._rear === this._front && (this._front = (this._front + 1) % this._capacity), this._memory[this._rear] = o), o.score = this._computeScore(o, n);
  }
  /**
   * A score between 0 and 1 for `item`.
   *  - a score towards 0 indicates that the source appears to be a physical mouse wheel
   *  - a score towards 1 indicates that the source appears to be a touchpad or magic mouse, etc.
   */
  _computeScore(e, t) {
    if (Math.abs(e.deltaX) > 0 && Math.abs(e.deltaY) > 0)
      return 1;
    let i = 0.5;
    if ((!this._isAlmostInt(e.deltaX) || !this._isAlmostInt(e.deltaY)) && (i += 0.25), t) {
      const n = Math.abs(e.deltaX), o = Math.abs(e.deltaY), r = Math.abs(t.deltaX), a = Math.abs(t.deltaY), l = Math.max(Math.min(n, r), 1), c = Math.max(Math.min(o, a), 1), d = Math.max(n, r), h = Math.max(o, a);
      d % l === 0 && h % c === 0 && (i -= 0.5);
    }
    return Math.min(Math.max(i, 0), 1);
  }
  _isAlmostInt(e) {
    return Math.abs(Math.round(e) - e) < 0.01;
  }
};
y1.INSTANCE = new y1();
let EC = y1;
class SN extends to {
  get options() {
    return this._options;
  }
  constructor(e, t, i) {
    super(), this._onScroll = this._register(new B()), this.onScroll = this._onScroll.event, this._onWillScroll = this._register(new B()), e.style.overflow = "hidden", this._options = RK(t), this._scrollable = i, this._register(this._scrollable.onScroll((o) => {
      this._onWillScroll.fire(o), this._onDidScroll(o), this._onScroll.fire(o);
    }));
    const n = {
      onMouseWheel: (o) => this._onMouseWheel(o),
      onDragStart: () => this._onDragStart(),
      onDragEnd: () => this._onDragEnd()
    };
    this._verticalScrollbar = this._register(new DK(this._scrollable, this._options, n)), this._horizontalScrollbar = this._register(new kK(this._scrollable, this._options, n)), this._domNode = document.createElement("div"), this._domNode.className = "monaco-scrollable-element " + this._options.className, this._domNode.setAttribute("role", "presentation"), this._domNode.style.position = "relative", this._domNode.style.overflow = "hidden", this._domNode.appendChild(e), this._domNode.appendChild(this._horizontalScrollbar.domNode.domNode), this._domNode.appendChild(this._verticalScrollbar.domNode.domNode), this._options.useShadows ? (this._leftShadowDomNode = rt(document.createElement("div")), this._leftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._leftShadowDomNode.domNode), this._topShadowDomNode = rt(document.createElement("div")), this._topShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topShadowDomNode.domNode), this._topLeftShadowDomNode = rt(document.createElement("div")), this._topLeftShadowDomNode.setClassName("shadow"), this._domNode.appendChild(this._topLeftShadowDomNode.domNode)) : (this._leftShadowDomNode = null, this._topShadowDomNode = null, this._topLeftShadowDomNode = null), this._listenOnDomNode = this._options.listenOnDomNode || this._domNode, this._mouseWheelToDispose = [], this._setListeningToMouseWheel(this._options.handleMouseWheel), this.onmouseover(this._listenOnDomNode, (o) => this._onMouseOver(o)), this.onmouseleave(this._listenOnDomNode, (o) => this._onMouseLeave(o)), this._hideTimeout = this._register(new nr()), this._isDragging = !1, this._mouseIsOver = !1, this._shouldRender = !0, this._revealOnScroll = !0;
  }
  dispose() {
    this._mouseWheelToDispose = Ct(this._mouseWheelToDispose), super.dispose();
  }
  /**
   * Get the generated 'scrollable' dom node
   */
  getDomNode() {
    return this._domNode;
  }
  getOverviewRulerLayoutInfo() {
    return {
      parent: this._domNode,
      insertBefore: this._verticalScrollbar.domNode.domNode
    };
  }
  /**
   * Delegate a pointer down event to the vertical scrollbar.
   * This is to help with clicking somewhere else and having the scrollbar react.
   */
  delegateVerticalScrollbarPointerDown(e) {
    this._verticalScrollbar.delegatePointerDown(e);
  }
  getScrollDimensions() {
    return this._scrollable.getScrollDimensions();
  }
  setScrollDimensions(e) {
    this._scrollable.setScrollDimensions(e, !1);
  }
  /**
   * Update the class name of the scrollable element.
   */
  updateClassName(e) {
    this._options.className = e, ze && (this._options.className += " mac"), this._domNode.className = "monaco-scrollable-element " + this._options.className;
  }
  /**
   * Update configuration options for the scrollbar.
   */
  updateOptions(e) {
    typeof e.handleMouseWheel < "u" && (this._options.handleMouseWheel = e.handleMouseWheel, this._setListeningToMouseWheel(this._options.handleMouseWheel)), typeof e.mouseWheelScrollSensitivity < "u" && (this._options.mouseWheelScrollSensitivity = e.mouseWheelScrollSensitivity), typeof e.fastScrollSensitivity < "u" && (this._options.fastScrollSensitivity = e.fastScrollSensitivity), typeof e.scrollPredominantAxis < "u" && (this._options.scrollPredominantAxis = e.scrollPredominantAxis), typeof e.horizontal < "u" && (this._options.horizontal = e.horizontal), typeof e.vertical < "u" && (this._options.vertical = e.vertical), typeof e.horizontalScrollbarSize < "u" && (this._options.horizontalScrollbarSize = e.horizontalScrollbarSize), typeof e.verticalScrollbarSize < "u" && (this._options.verticalScrollbarSize = e.verticalScrollbarSize), typeof e.scrollByPage < "u" && (this._options.scrollByPage = e.scrollByPage), this._horizontalScrollbar.updateOptions(this._options), this._verticalScrollbar.updateOptions(this._options), this._options.lazyRender || this._render();
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._onMouseWheel(new fu(e));
  }
  // -------------------- mouse wheel scrolling --------------------
  _setListeningToMouseWheel(e) {
    if (this._mouseWheelToDispose.length > 0 !== e && (this._mouseWheelToDispose = Ct(this._mouseWheelToDispose), e)) {
      const i = (n) => {
        this._onMouseWheel(new fu(n));
      };
      this._mouseWheelToDispose.push(U(this._listenOnDomNode, ee.MOUSE_WHEEL, i, { passive: !1 }));
    }
  }
  _onMouseWheel(e) {
    if (e.browserEvent?.defaultPrevented)
      return;
    const t = EC.INSTANCE;
    t.acceptStandardWheelEvent(e);
    let i = !1;
    if (e.deltaY || e.deltaX) {
      let o = e.deltaY * this._options.mouseWheelScrollSensitivity, r = e.deltaX * this._options.mouseWheelScrollSensitivity;
      this._options.scrollPredominantAxis && (this._options.scrollYToX && r + o === 0 ? r = o = 0 : Math.abs(o) >= Math.abs(r) ? r = 0 : o = 0), this._options.flipAxes && ([o, r] = [r, o]);
      const a = !ze && e.browserEvent && e.browserEvent.shiftKey;
      (this._options.scrollYToX || a) && !r && (r = o, o = 0), e.browserEvent && e.browserEvent.altKey && (r = r * this._options.fastScrollSensitivity, o = o * this._options.fastScrollSensitivity);
      const l = this._scrollable.getFutureScrollPosition();
      let c = {};
      if (o) {
        const d = B2 * o, h = l.scrollTop - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._verticalScrollbar.writeScrollPosition(c, h);
      }
      if (r) {
        const d = B2 * r, h = l.scrollLeft - (d < 0 ? Math.floor(d) : Math.ceil(d));
        this._horizontalScrollbar.writeScrollPosition(c, h);
      }
      c = this._scrollable.validateScrollPosition(c), (l.scrollLeft !== c.scrollLeft || l.scrollTop !== c.scrollTop) && (this._options.mouseWheelSmoothScroll && t.isPhysicalMouseWheel() ? this._scrollable.setScrollPositionSmooth(c) : this._scrollable.setScrollPositionNow(c), i = !0);
    }
    let n = i;
    !n && this._options.alwaysConsumeMouseWheel && (n = !0), !n && this._options.consumeMouseWheelIfScrollbarIsNeeded && (this._verticalScrollbar.isNeeded() || this._horizontalScrollbar.isNeeded()) && (n = !0), n && (e.preventDefault(), e.stopPropagation());
  }
  _onDidScroll(e) {
    this._shouldRender = this._horizontalScrollbar.onDidScroll(e) || this._shouldRender, this._shouldRender = this._verticalScrollbar.onDidScroll(e) || this._shouldRender, this._options.useShadows && (this._shouldRender = !0), this._revealOnScroll && this._reveal(), this._options.lazyRender || this._render();
  }
  /**
   * Render / mutate the DOM now.
   * Should be used together with the ctor option `lazyRender`.
   */
  renderNow() {
    if (!this._options.lazyRender)
      throw new Error("Please use `lazyRender` together with `renderNow`!");
    this._render();
  }
  _render() {
    if (this._shouldRender && (this._shouldRender = !1, this._horizontalScrollbar.render(), this._verticalScrollbar.render(), this._options.useShadows)) {
      const e = this._scrollable.getCurrentScrollPosition(), t = e.scrollTop > 0, i = e.scrollLeft > 0, n = i ? " left" : "", o = t ? " top" : "", r = i || t ? " top-left-corner" : "";
      this._leftShadowDomNode.setClassName(`shadow${n}`), this._topShadowDomNode.setClassName(`shadow${o}`), this._topLeftShadowDomNode.setClassName(`shadow${r}${o}${n}`);
    }
  }
  // -------------------- fade in / fade out --------------------
  _onDragStart() {
    this._isDragging = !0, this._reveal();
  }
  _onDragEnd() {
    this._isDragging = !1, this._hide();
  }
  _onMouseLeave(e) {
    this._mouseIsOver = !1, this._hide();
  }
  _onMouseOver(e) {
    this._mouseIsOver = !0, this._reveal();
  }
  _reveal() {
    this._verticalScrollbar.beginReveal(), this._horizontalScrollbar.beginReveal(), this._scheduleHide();
  }
  _hide() {
    !this._mouseIsOver && !this._isDragging && (this._verticalScrollbar.beginHide(), this._horizontalScrollbar.beginHide());
  }
  _scheduleHide() {
    !this._mouseIsOver && !this._isDragging && this._hideTimeout.cancelAndSet(() => this._hide(), TK);
  }
}
class c3 extends SN {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new vm({
      forceIntegerValues: !0,
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => ys(fe(e), n)
    });
    super(e, t, i), this._register(i);
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
}
class Y0 extends SN {
  constructor(e, t, i) {
    super(e, t, i);
  }
  setScrollPosition(e) {
    e.reuseAnimation ? this._scrollable.setScrollPositionSmooth(e, e.reuseAnimation) : this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
}
class F_ extends SN {
  constructor(e, t) {
    t = t || {}, t.mouseWheelSmoothScroll = !1;
    const i = new vm({
      forceIntegerValues: !1,
      // See https://github.com/microsoft/vscode/issues/139877
      smoothScrollDuration: 0,
      scheduleAtNextAnimationFrame: (n) => ys(fe(e), n)
    });
    super(e, t, i), this._register(i), this._element = e, this._register(this.onScroll((n) => {
      n.scrollTopChanged && (this._element.scrollTop = n.scrollTop), n.scrollLeftChanged && (this._element.scrollLeft = n.scrollLeft);
    })), this.scanDomNode();
  }
  setScrollPosition(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  getScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  scanDomNode() {
    this.setScrollDimensions({
      width: this._element.clientWidth,
      scrollWidth: this._element.scrollWidth,
      height: this._element.clientHeight,
      scrollHeight: this._element.scrollHeight
    }), this.setScrollPosition({
      scrollLeft: this._element.scrollLeft,
      scrollTop: this._element.scrollTop
    });
  }
}
function RK(s) {
  const e = {
    lazyRender: typeof s.lazyRender < "u" ? s.lazyRender : !1,
    className: typeof s.className < "u" ? s.className : "",
    useShadows: typeof s.useShadows < "u" ? s.useShadows : !0,
    handleMouseWheel: typeof s.handleMouseWheel < "u" ? s.handleMouseWheel : !0,
    flipAxes: typeof s.flipAxes < "u" ? s.flipAxes : !1,
    consumeMouseWheelIfScrollbarIsNeeded: typeof s.consumeMouseWheelIfScrollbarIsNeeded < "u" ? s.consumeMouseWheelIfScrollbarIsNeeded : !1,
    alwaysConsumeMouseWheel: typeof s.alwaysConsumeMouseWheel < "u" ? s.alwaysConsumeMouseWheel : !1,
    scrollYToX: typeof s.scrollYToX < "u" ? s.scrollYToX : !1,
    mouseWheelScrollSensitivity: typeof s.mouseWheelScrollSensitivity < "u" ? s.mouseWheelScrollSensitivity : 1,
    fastScrollSensitivity: typeof s.fastScrollSensitivity < "u" ? s.fastScrollSensitivity : 5,
    scrollPredominantAxis: typeof s.scrollPredominantAxis < "u" ? s.scrollPredominantAxis : !0,
    mouseWheelSmoothScroll: typeof s.mouseWheelSmoothScroll < "u" ? s.mouseWheelSmoothScroll : !0,
    arrowSize: typeof s.arrowSize < "u" ? s.arrowSize : 11,
    listenOnDomNode: typeof s.listenOnDomNode < "u" ? s.listenOnDomNode : null,
    horizontal: typeof s.horizontal < "u" ? s.horizontal : 1,
    horizontalScrollbarSize: typeof s.horizontalScrollbarSize < "u" ? s.horizontalScrollbarSize : 10,
    horizontalSliderSize: typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : 0,
    horizontalHasArrows: typeof s.horizontalHasArrows < "u" ? s.horizontalHasArrows : !1,
    vertical: typeof s.vertical < "u" ? s.vertical : 1,
    verticalScrollbarSize: typeof s.verticalScrollbarSize < "u" ? s.verticalScrollbarSize : 10,
    verticalHasArrows: typeof s.verticalHasArrows < "u" ? s.verticalHasArrows : !1,
    verticalSliderSize: typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : 0,
    scrollByPage: typeof s.scrollByPage < "u" ? s.scrollByPage : !1
  };
  return e.horizontalSliderSize = typeof s.horizontalSliderSize < "u" ? s.horizontalSliderSize : e.horizontalScrollbarSize, e.verticalSliderSize = typeof s.verticalSliderSize < "u" ? s.verticalSliderSize : e.verticalScrollbarSize, ze && (e.className += " mac"), e;
}
const wb = de;
let yN = class extends V {
  constructor() {
    super(), this.containerDomNode = document.createElement("div"), this.containerDomNode.className = "monaco-hover", this.containerDomNode.tabIndex = 0, this.containerDomNode.setAttribute("role", "tooltip"), this.contentsDomNode = document.createElement("div"), this.contentsDomNode.className = "monaco-hover-content", this.scrollbar = this._register(new F_(this.contentsDomNode, {
      consumeMouseWheelIfScrollbarIsNeeded: !0
    })), this.containerDomNode.appendChild(this.scrollbar.getDomNode());
  }
  onContentsChanged() {
    this.scrollbar.scanDomNode();
  }
};
class K0 extends V {
  static render(e, t, i) {
    return new K0(e, t, i);
  }
  constructor(e, t, i) {
    super(), this.actionLabel = t.label, this.actionKeybindingLabel = i, this.actionContainer = K(e, wb("div.action-container")), this.actionContainer.setAttribute("tabindex", "0"), this.action = K(this.actionContainer, wb("a.action")), this.action.setAttribute("role", "button"), t.iconClass && K(this.action, wb(`span.icon.${t.iconClass}`));
    const n = K(this.action, wb("span"));
    n.textContent = i ? `${t.label} (${i})` : t.label, this._store.add(new h3(this.actionContainer, t.run)), this._store.add(new u3(this.actionContainer, t.run, [
      3,
      10
      /* KeyCode.Space */
    ])), this.setEnabled(!0);
  }
  setEnabled(e) {
    e ? (this.actionContainer.classList.remove("disabled"), this.actionContainer.removeAttribute("aria-disabled")) : (this.actionContainer.classList.add("disabled"), this.actionContainer.setAttribute("aria-disabled", "true"));
  }
}
function d3(s, e) {
  return s && e ? f("acessibleViewHint", "Inspect this in the accessible view with {0}.", e) : s ? f("acessibleViewHintNoKbOpen", "Inspect this in the accessible view via the command Open Accessible View which is currently not triggerable via keybinding.") : "";
}
class h3 extends V {
  constructor(e, t) {
    super(), this._register(U(e, ee.CLICK, (i) => {
      i.stopPropagation(), i.preventDefault(), t(e);
    }));
  }
}
class u3 extends V {
  constructor(e, t, i) {
    super(), this._register(U(e, ee.KEY_DOWN, (n) => {
      const o = new Mt(n);
      i.some((r) => o.equals(r)) && (n.stopPropagation(), n.preventDefault(), t(e));
    }));
  }
}
const lr = We("openerService");
function FK(s) {
  let e;
  const t = /^L?(\d+)(?:,(\d+))?(-L?(\d+)(?:,(\d+))?)?/.exec(s.fragment);
  return t && (e = {
    startLineNumber: parseInt(t[1]),
    startColumn: t[2] ? parseInt(t[2]) : 1,
    endLineNumber: t[4] ? parseInt(t[4]) : void 0,
    endColumn: t[4] ? t[5] ? parseInt(t[5]) : 1 : void 0
  }, s = s.with({ fragment: "" })), { selection: e, uri: s };
}
class Ke {
  get event() {
    return this.emitter.event;
  }
  constructor(e, t, i) {
    const n = (o) => this.emitter.fire(o);
    this.emitter = new B({
      onWillAddFirstListener: () => e.addEventListener(t, n, i),
      onDidRemoveLastListener: () => e.removeEventListener(t, n, i)
    });
  }
  dispose() {
    this.emitter.dispose();
  }
}
function OK(s, e = {}) {
  const t = xN(e);
  return t.textContent = s, t;
}
function PK(s, e = {}) {
  const t = xN(e);
  return g3(t, WK(s, !!e.renderCodeSegments), e.actionHandler, e.renderCodeSegments), t;
}
function xN(s) {
  const e = s.inline ? "span" : "div", t = document.createElement(e);
  return s.className && (t.className = s.className), t;
}
class HK {
  constructor(e) {
    this.source = e, this.index = 0;
  }
  eos() {
    return this.index >= this.source.length;
  }
  next() {
    const e = this.peek();
    return this.advance(), e;
  }
  peek() {
    return this.source[this.index];
  }
  advance() {
    this.index++;
  }
}
function g3(s, e, t, i) {
  let n;
  if (e.type === 2)
    n = document.createTextNode(e.content || "");
  else if (e.type === 3)
    n = document.createElement("b");
  else if (e.type === 4)
    n = document.createElement("i");
  else if (e.type === 7 && i)
    n = document.createElement("code");
  else if (e.type === 5 && t) {
    const o = document.createElement("a");
    t.disposables.add(Xt(o, "click", (r) => {
      t.callback(String(e.index), r);
    })), n = o;
  } else e.type === 8 ? n = document.createElement("br") : e.type === 1 && (n = s);
  n && s !== n && s.appendChild(n), n && Array.isArray(e.children) && e.children.forEach((o) => {
    g3(n, o, t, i);
  });
}
function WK(s, e) {
  const t = {
    type: 1,
    children: []
  };
  let i = 0, n = t;
  const o = [], r = new HK(s);
  for (; !r.eos(); ) {
    let a = r.next();
    const l = a === "\\" && kL(r.peek(), e) !== 0;
    if (l && (a = r.next()), !l && VK(a, e) && a === r.peek()) {
      r.advance(), n.type === 2 && (n = o.pop());
      const c = kL(a, e);
      if (n.type === c || n.type === 5 && c === 6)
        n = o.pop();
      else {
        const d = {
          type: c,
          children: []
        };
        c === 5 && (d.index = i, i++), n.children.push(d), o.push(n), n = d;
      }
    } else if (a === `
`)
      n.type === 2 && (n = o.pop()), n.children.push({
        type: 8
        /* FormatType.NewLine */
      });
    else if (n.type !== 2) {
      const c = {
        type: 2,
        content: a
      };
      n.children.push(c), o.push(n), n = c;
    } else
      n.content += a;
  }
  return n.type === 2 && (n = o.pop()), t;
}
function VK(s, e) {
  return kL(s, e) !== 0;
}
function kL(s, e) {
  switch (s) {
    case "*":
      return 3;
    case "_":
      return 4;
    case "[":
      return 5;
    case "]":
      return 6;
    case "`":
      return e ? 7 : 0;
    default:
      return 0;
  }
}
const zK = new RegExp(`(\\\\)?\\$\\((${pe.iconNameExpression}(?:${pe.iconModifierExpression})?)\\)`, "g");
function kh(s) {
  const e = new Array();
  let t, i = 0, n = 0;
  for (; (t = zK.exec(s)) !== null; ) {
    n = t.index || 0, i < n && e.push(s.substring(i, n)), i = (t.index || 0) + t[0].length;
    const [, o, r] = t;
    e.push(o ? `$(${r})` : LC({ id: r }));
  }
  return i < s.length && e.push(s.substring(i)), e;
}
function LC(s) {
  const e = de("span");
  return e.classList.add(...pe.asClassNameArray(s)), e;
}
function f3(...s) {
  return function(e, t) {
    for (let i = 0, n = s.length; i < n; i++) {
      const o = s[i](e, t);
      if (o)
        return o;
    }
    return null;
  };
}
m3.bind(void 0, !1);
const kC = m3.bind(void 0, !0);
function m3(s, e, t) {
  if (!t || t.length < e.length)
    return null;
  let i;
  return s ? i = FM(t, e) : i = t.indexOf(e) === 0, i ? e.length > 0 ? [{ start: 0, end: e.length }] : [] : null;
}
function UK(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t === -1 ? null : [{ start: t, end: t + s.length }];
}
function QK(s, e) {
  return DL(s.toLowerCase(), e.toLowerCase(), 0, 0);
}
function DL(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] === e[i]) {
    let n = null;
    return (n = DL(s, e, t + 1, i + 1)) ? A3({ start: i, end: i + 1 }, n) : null;
  }
  return DL(s, e, t, i + 1);
}
function EN(s) {
  return 97 <= s && s <= 122;
}
function J0(s) {
  return 65 <= s && s <= 90;
}
function LN(s) {
  return 48 <= s && s <= 57;
}
function GK(s) {
  return s === 32 || s === 9 || s === 10 || s === 13;
}
const jK = /* @__PURE__ */ new Set();
"()[]{}<>`'\"-/;:,.?!".split("").forEach((s) => jK.add(s.charCodeAt(0)));
function p3(s) {
  return EN(s) || J0(s) || LN(s);
}
function A3(s, e) {
  return e.length === 0 ? e = [s] : s.end === e[0].start ? e[0].start = s.start : e.unshift(s), e;
}
function _3(s, e) {
  for (let t = e; t < s.length; t++) {
    const i = s.charCodeAt(t);
    if (J0(i) || LN(i) || t > 0 && !p3(s.charCodeAt(t - 1)))
      return t;
  }
  return s.length;
}
function IL(s, e, t, i) {
  if (t === s.length)
    return [];
  if (i === e.length)
    return null;
  if (s[t] !== e[i].toLowerCase())
    return null;
  {
    let n = null, o = i + 1;
    for (n = IL(s, e, t + 1, i + 1); !n && (o = _3(e, o)) < e.length; )
      n = IL(s, e, t + 1, o), o++;
    return n === null ? null : A3({ start: i, end: i + 1 }, n);
  }
}
function YK(s) {
  let e = 0, t = 0, i = 0, n = 0, o = 0;
  for (let d = 0; d < s.length; d++)
    o = s.charCodeAt(d), J0(o) && e++, EN(o) && t++, p3(o) && i++, LN(o) && n++;
  const r = e / s.length, a = t / s.length, l = i / s.length, c = n / s.length;
  return { upperPercent: r, lowerPercent: a, alphaPercent: l, numericPercent: c };
}
function KK(s) {
  const { upperPercent: e, lowerPercent: t } = s;
  return t === 0 && e > 0.6;
}
function JK(s) {
  const { upperPercent: e, lowerPercent: t, alphaPercent: i, numericPercent: n } = s;
  return t > 0.2 && e < 0.8 && i > 0.6 && n < 0.2;
}
function qK(s) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let o = 0; o < s.length; o++)
    i = s.charCodeAt(o), J0(i) && e++, EN(i) && t++, GK(i) && n++;
  return (e === 0 || t === 0) && n === 0 ? s.length <= 30 : e <= 5;
}
function b3(s, e) {
  if (!e || (e = e.trim(), e.length === 0) || !qK(s))
    return null;
  e.length > 60 && (e = e.substring(0, 60));
  const t = YK(e);
  if (!JK(t)) {
    if (!KK(t))
      return null;
    e = e.toLowerCase();
  }
  let i = null, n = 0;
  for (s = s.toLowerCase(); n < e.length && (i = IL(s, e, 0, n)) === null; )
    n = _3(e, n + 1);
  return i;
}
const $K = f3(kC, b3, UK), XK = f3(kC, b3, QK), R2 = new Vu(1e4);
function F2(s, e, t = !1) {
  if (typeof s != "string" || typeof e != "string")
    return null;
  let i = R2.get(s);
  i || (i = new RegExp(I7(s), "i"), R2.set(s, i));
  const n = i.exec(e);
  return n ? [{ start: n.index, end: n.index + n[0].length }] : t ? XK(s, e) : $K(s, e);
}
function ZK(s, e) {
  const t = $f(s, s.toLowerCase(), 0, e, e.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
  return t ? q0(t) : null;
}
function eJ(s, e, t, i, n, o) {
  const r = Math.min(13, s.length);
  for (; t < r; t++) {
    const a = $f(s, e, t, i, n, o, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
    if (a)
      return a;
  }
  return [0, o];
}
function q0(s) {
  if (typeof s > "u")
    return [];
  const e = [], t = s[1];
  for (let i = s.length - 1; i > 1; i--) {
    const n = s[i] + t, o = e[e.length - 1];
    o && o.end === n ? o.end = n + 1 : e.push({ start: n, end: n + 1 });
  }
  return e;
}
const kc = 128;
function kN() {
  const s = [], e = [];
  for (let t = 0; t <= kc; t++)
    e[t] = 0;
  for (let t = 0; t <= kc; t++)
    s.push(e.slice(0));
  return s;
}
function w3(s) {
  const e = [];
  for (let t = 0; t <= s; t++)
    e[t] = 0;
  return e;
}
const C3 = w3(2 * kc), ML = w3(2 * kc), Qa = kN(), Md = kN(), Cb = kN();
function vb(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  const t = s.codePointAt(e);
  switch (t) {
    case 95:
    case 45:
    case 46:
    case 32:
    case 47:
    case 92:
    case 39:
    case 34:
    case 58:
    case 36:
    case 60:
    case 62:
    case 40:
    case 41:
    case 91:
    case 93:
    case 123:
    case 125:
      return !0;
    case void 0:
      return !1;
    default:
      return !!VM(t);
  }
}
function O2(s, e) {
  if (e < 0 || e >= s.length)
    return !1;
  switch (s.charCodeAt(e)) {
    case 32:
    case 9:
      return !0;
    default:
      return !1;
  }
}
function yw(s, e, t) {
  return e[s] !== t[s];
}
function tJ(s, e, t, i, n, o, r = !1) {
  for (; e < t && n < o; )
    s[e] === i[n] && (r && (C3[e] = n), e += 1), n += 1;
  return e === t;
}
var Tr;
(function(s) {
  s.Default = [-100, 0];
  function e(t) {
    return !t || t.length === 2 && t[0] === -100 && t[1] === 0;
  }
  s.isDefault = e;
})(Tr || (Tr = {}));
const MB = class MB {
  constructor(e, t) {
    this.firstMatchCanBeWeak = e, this.boostFullMatch = t;
  }
};
MB.default = { boostFullMatch: !0, firstMatchCanBeWeak: !1 };
let GA = MB;
function $f(s, e, t, i, n, o, r = GA.default) {
  const a = s.length > kc ? kc : s.length, l = i.length > kc ? kc : i.length;
  if (t >= a || o >= l || a - t > l - o || !tJ(e, t, a, n, o, l, !0))
    return;
  iJ(a, l, t, o, e, n);
  let c = 1, d = 1, h = t, u = o;
  const g = [!1];
  for (c = 1, h = t; h < a; c++, h++) {
    const b = C3[h], C = ML[h], w = h + 1 < a ? ML[h + 1] : l;
    for (d = b - o + 1, u = b; u < w; d++, u++) {
      let S = Number.MIN_SAFE_INTEGER, x = !1;
      u <= C && (S = nJ(s, e, h, t, i, n, u, l, o, Qa[c - 1][d - 1] === 0, g));
      let y = 0;
      S !== Number.MAX_SAFE_INTEGER && (x = !0, y = S + Md[c - 1][d - 1]);
      const D = u > b, I = D ? Md[c][d - 1] + (Qa[c][d - 1] > 0 ? -5 : 0) : 0, Q = u > b + 1 && Qa[c][d - 1] > 0, P = Q ? Md[c][d - 2] + (Qa[c][d - 2] > 0 ? -5 : 0) : 0;
      if (Q && (!D || P >= I) && (!x || P >= y))
        Md[c][d] = P, Cb[c][d] = 3, Qa[c][d] = 0;
      else if (D && (!x || I >= y))
        Md[c][d] = I, Cb[c][d] = 2, Qa[c][d] = 0;
      else if (x)
        Md[c][d] = y, Cb[c][d] = 1, Qa[c][d] = Qa[c - 1][d - 1] + 1;
      else
        throw new Error("not possible");
    }
  }
  if (!g[0] && !r.firstMatchCanBeWeak)
    return;
  c--, d--;
  const m = [Md[c][d], o];
  let p = 0, A = 0;
  for (; c >= 1; ) {
    let b = d;
    do {
      const C = Cb[c][b];
      if (C === 3)
        b = b - 2;
      else if (C === 2)
        b = b - 1;
      else
        break;
    } while (b >= 1);
    p > 1 && e[t + c - 1] === n[o + d - 1] && !yw(b + o - 1, i, n) && p + 1 > Qa[c][b] && (b = d), b === d ? p++ : p = 1, A || (A = b), c--, d = b - 1, m.push(d);
  }
  l - o === a && r.boostFullMatch && (m[0] += 2);
  const _ = A - a;
  return m[0] -= _, m;
}
function iJ(s, e, t, i, n, o) {
  let r = s - 1, a = e - 1;
  for (; r >= t && a >= i; )
    n[r] === o[a] && (ML[r] = a, r--), a--;
}
function nJ(s, e, t, i, n, o, r, a, l, c, d) {
  if (e[t] !== o[r])
    return Number.MIN_SAFE_INTEGER;
  let h = 1, u = !1;
  return r === t - i ? h = s[t] === n[r] ? 7 : 5 : yw(r, n, o) && (r === 0 || !yw(r - 1, n, o)) ? (h = s[t] === n[r] ? 7 : 5, u = !0) : vb(o, r) && (r === 0 || !vb(o, r - 1)) ? h = 5 : (vb(o, r - 1) || O2(o, r - 1)) && (h = 5, u = !0), h > 1 && t === i && (d[0] = !0), u || (u = yw(r, n, o) || vb(o, r - 1) || O2(o, r - 1)), t === i ? r > l && (h -= u ? 3 : 5) : c ? h += u ? 2 : 0 : h += u ? 0 : 1, r + 1 === a && (h -= u ? 3 : 5), h;
}
function sJ(s, e, t, i, n, o, r) {
  return oJ(s, e, t, i, n, o, !0, r);
}
function oJ(s, e, t, i, n, o, r, a) {
  let l = $f(s, e, t, i, n, o, a);
  if (s.length >= 3) {
    const c = Math.min(7, s.length - 1);
    for (let d = t + 1; d < c; d++) {
      const h = rJ(s, d);
      if (h) {
        const u = $f(h, h.toLowerCase(), t, i, n, o, a);
        u && (u[0] -= 3, (!l || u[0] > l[0]) && (l = u));
      }
    }
  }
  return l;
}
function rJ(s, e) {
  if (e + 1 >= s.length)
    return;
  const t = s[e], i = s[e + 1];
  if (t !== i)
    return s.slice(0, e) + i + t + s.slice(e + 2);
}
const aJ = "$(", DN = new RegExp(`\\$\\(${pe.iconNameExpression}(?:${pe.iconModifierExpression})?\\)`, "g"), lJ = new RegExp(`(\\\\)?${DN.source}`, "g");
function cJ(s) {
  return s.replace(lJ, (e, t) => t ? e : `\\${e}`);
}
const dJ = new RegExp(`\\\\${DN.source}`, "g");
function hJ(s) {
  return s.replace(dJ, (e) => `\\${e}`);
}
const uJ = new RegExp(`(\\s)?(\\\\)?${DN.source}(\\s)?`, "g");
function v3(s) {
  return s.indexOf(aJ) === -1 ? s : s.replace(uJ, (e, t, i, n) => i ? e : t || n || "");
}
function gJ(s) {
  return s ? s.replace(/\$\((.*?)\)/g, (e, t) => ` ${t} `).trim() : "";
}
const xy = new RegExp(`\\$\\(${pe.iconNameCharacter}+\\)`, "g");
function fp(s) {
  xy.lastIndex = 0;
  let e = "";
  const t = [];
  let i = 0;
  for (; ; ) {
    const n = xy.lastIndex, o = xy.exec(s), r = s.substring(n, o?.index);
    if (r.length > 0) {
      e += r;
      for (let a = 0; a < r.length; a++)
        t.push(i);
    }
    if (!o)
      break;
    i += o[0].length;
  }
  return { text: e, iconOffsets: t };
}
function Ey(s, e, t = !1) {
  const { text: i, iconOffsets: n } = e;
  if (!n || n.length === 0)
    return F2(s, i, t);
  const o = _0(i, " "), r = i.length - o.length, a = F2(s, o, t);
  if (a)
    for (const l of a) {
      const c = n[l.start + r] + r;
      l.start += c, l.end += c;
    }
  return a;
}
function Ga(s) {
  return Zw(s, !0);
}
class fJ {
  constructor(e) {
    this._ignorePathCasing = e;
  }
  compare(e, t, i = !1) {
    return e === t ? 0 : LA(this.getComparisonKey(e, i), this.getComparisonKey(t, i));
  }
  isEqual(e, t, i = !1) {
    return e === t ? !0 : !e || !t ? !1 : this.getComparisonKey(e, i) === this.getComparisonKey(t, i);
  }
  getComparisonKey(e, t = !1) {
    return e.with({
      path: this._ignorePathCasing(e) ? e.path.toLowerCase() : void 0,
      fragment: t ? null : void 0
    }).toString();
  }
  isEqualOrParent(e, t, i = !1) {
    if (e.scheme === t.scheme) {
      if (e.scheme === Ie.file)
        return wL(Ga(e), Ga(t), this._ignorePathCasing(e)) && e.query === t.query && (i || e.fragment === t.fragment);
      if (H2(e.authority, t.authority))
        return wL(e.path, t.path, this._ignorePathCasing(e), "/") && e.query === t.query && (i || e.fragment === t.fragment);
    }
    return !1;
  }
  // --- path math
  joinPath(e, ...t) {
    return _e.joinPath(e, ...t);
  }
  basenameOrAuthority(e) {
    return Xo(e) || e.authority;
  }
  basename(e) {
    return di.basename(e.path);
  }
  extname(e) {
    return di.extname(e.path);
  }
  dirname(e) {
    if (e.path.length === 0)
      return e;
    let t;
    return e.scheme === Ie.file ? t = _e.file(cH(Ga(e))).path : (t = di.dirname(e.path), e.authority && t.length && t.charCodeAt(0) !== 47 && (console.error(`dirname("${e.toString})) resulted in a relative path`), t = "/")), e.with({
      path: t
    });
  }
  normalizePath(e) {
    if (!e.path.length)
      return e;
    let t;
    return e.scheme === Ie.file ? t = _e.file(lH(Ga(e))).path : t = di.normalize(e.path), e.with({
      path: t
    });
  }
  relativePath(e, t) {
    if (e.scheme !== t.scheme || !H2(e.authority, t.authority))
      return;
    if (e.scheme === Ie.file) {
      const o = l7(Ga(e), Ga(t));
      return yn ? H5(o) : o;
    }
    let i = e.path || "/";
    const n = t.path || "/";
    if (this._ignorePathCasing(e)) {
      let o = 0;
      for (const r = Math.min(i.length, n.length); o < r && !(i.charCodeAt(o) !== n.charCodeAt(o) && i.charAt(o).toLowerCase() !== n.charAt(o).toLowerCase()); o++)
        ;
      i = n.substr(0, o) + i.substr(o);
    }
    return di.relative(i, n);
  }
  resolvePath(e, t) {
    if (e.scheme === Ie.file) {
      const i = _e.file(a7(Ga(e), t));
      return e.with({
        authority: i.authority,
        path: i.path
      });
    }
    return t = gj(t), e.with({
      path: di.resolve(e.path, t)
    });
  }
  // --- misc
  isAbsolutePath(e) {
    return !!e.path && e.path[0] === "/";
  }
  isEqualAuthority(e, t) {
    return e === t || e !== void 0 && t !== void 0 && Mg(e, t);
  }
  hasTrailingPathSeparator(e, t = Hc) {
    if (e.scheme === Ie.file) {
      const i = Ga(e);
      return i.length > g2(i).length && i[i.length - 1] === t;
    } else {
      const i = e.path;
      return i.length > 1 && i.charCodeAt(i.length - 1) === 47 && !/^[a-zA-Z]:(\/$|\\$)/.test(e.fsPath);
    }
  }
  removeTrailingPathSeparator(e, t = Hc) {
    return W2(e, t) ? e.with({ path: e.path.substr(0, e.path.length - 1) }) : e;
  }
  addTrailingPathSeparator(e, t = Hc) {
    let i = !1;
    if (e.scheme === Ie.file) {
      const n = Ga(e);
      i = n !== void 0 && n.length === g2(n).length && n[n.length - 1] === t;
    } else {
      t = "/";
      const n = e.path;
      i = n.length === 1 && n.charCodeAt(n.length - 1) === 47;
    }
    return !i && !W2(e, t) ? e.with({ path: e.path + "/" }) : e;
  }
}
const Tt = new fJ(() => !1), IN = Tt.isEqual.bind(Tt);
Tt.isEqualOrParent.bind(Tt);
Tt.getComparisonKey.bind(Tt);
const mJ = Tt.basenameOrAuthority.bind(Tt), Xo = Tt.basename.bind(Tt), pJ = Tt.extname.bind(Tt), $0 = Tt.dirname.bind(Tt);
Tt.joinPath.bind(Tt);
const AJ = Tt.normalizePath.bind(Tt);
Tt.relativePath.bind(Tt);
const P2 = Tt.resolvePath.bind(Tt);
Tt.isAbsolutePath.bind(Tt);
const H2 = Tt.isEqualAuthority.bind(Tt), W2 = Tt.hasTrailingPathSeparator.bind(Tt);
Tt.removeTrailingPathSeparator.bind(Tt);
Tt.addTrailingPathSeparator.bind(Tt);
var ld;
(function(s) {
  s.META_DATA_LABEL = "label", s.META_DATA_DESCRIPTION = "description", s.META_DATA_SIZE = "size", s.META_DATA_MIME = "mime";
  function e(t) {
    const i = /* @__PURE__ */ new Map();
    t.path.substring(t.path.indexOf(";") + 1, t.path.lastIndexOf(";")).split(";").forEach((r) => {
      const [a, l] = r.split(":");
      a && l && i.set(a, l);
    });
    const o = t.path.substring(0, t.path.indexOf(";"));
    return o && i.set(s.META_DATA_MIME, o), i;
  }
  s.parseMetaData = e;
})(ld || (ld = {}));
class Vo {
  constructor(e = "", t = !1) {
    if (this.value = e, typeof this.value != "string")
      throw Go("value");
    typeof t == "boolean" ? (this.isTrusted = t, this.supportThemeIcons = !1, this.supportHtml = !1) : (this.isTrusted = t.isTrusted ?? void 0, this.supportThemeIcons = t.supportThemeIcons ?? !1, this.supportHtml = t.supportHtml ?? !1);
  }
  appendText(e, t = 0) {
    return this.value += bJ(this.supportThemeIcons ? cJ(e) : e).replace(/([ \t]+)/g, (i, n) => "&nbsp;".repeat(n.length)).replace(/\>/gm, "\\>").replace(/\n/g, t === 1 ? `\\
` : `

`), this;
  }
  appendMarkdown(e) {
    return this.value += e, this;
  }
  appendCodeblock(e, t) {
    return this.value += `
${wJ(t, e)}
`, this;
  }
  appendLink(e, t, i) {
    return this.value += "[", this.value += this._escape(t, "]"), this.value += "](", this.value += this._escape(String(e), ")"), i && (this.value += ` "${this._escape(this._escape(i, '"'), ")")}"`), this.value += ")", this;
  }
  _escape(e, t) {
    const i = new RegExp(So(t), "g");
    return e.replace(i, (n, o) => e.charAt(o - 1) !== "\\" ? `\\${n}` : n);
  }
}
function Xf(s) {
  return Sa(s) ? !s.value : Array.isArray(s) ? s.every(Xf) : !0;
}
function Sa(s) {
  return s instanceof Vo ? !0 : s && typeof s == "object" ? typeof s.value == "string" && (typeof s.isTrusted == "boolean" || typeof s.isTrusted == "object" || s.isTrusted === void 0) && (typeof s.supportThemeIcons == "boolean" || s.supportThemeIcons === void 0) : !1;
}
function _J(s, e) {
  return s === e ? !0 : !s || !e ? !1 : s.value === e.value && s.isTrusted === e.isTrusted && s.supportThemeIcons === e.supportThemeIcons && s.supportHtml === e.supportHtml && (s.baseUri === e.baseUri || !!s.baseUri && !!e.baseUri && IN(_e.from(s.baseUri), _e.from(e.baseUri)));
}
function bJ(s) {
  return s.replace(/[\\`*_{}[\]()#+\-!~]/g, "\\$&");
}
function wJ(s, e) {
  const t = s.match(/^`+/gm)?.reduce((n, o) => n.length > o.length ? n : o).length ?? 0, i = t >= 3 ? t + 1 : 3;
  return [
    `${"`".repeat(i)}${e}`,
    s,
    `${"`".repeat(i)}`
  ].join(`
`);
}
function Sb(s) {
  return s.replace(/"/g, "&quot;");
}
function Ly(s) {
  return s && s.replace(/\\([\\`*_{}[\]()#+\-.!~])/g, "$1");
}
function CJ(s) {
  const e = [], t = s.split("|").map((n) => n.trim());
  s = t[0];
  const i = t[1];
  if (i) {
    const n = /height=(\d+)/.exec(i), o = /width=(\d+)/.exec(i), r = n ? n[1] : "", a = o ? o[1] : "", l = isFinite(parseInt(a)), c = isFinite(parseInt(r));
    l && e.push(`width="${a}"`), c && e.push(`height="${r}"`);
  }
  return { href: s, dimensions: e };
}
class MN {
  constructor(e) {
    this._prefix = e, this._lastId = 0;
  }
  nextId() {
    return this._prefix + ++this._lastId;
  }
}
const NL = new MN("id#");
let hn = {};
(function() {
  function s(e, t) {
    t(hn);
  }
  s.amd = !0, function(e, t) {
    typeof s == "function" && s.amd ? s(["exports"], t) : typeof exports == "object" && typeof module < "u" ? t(exports) : (e = typeof globalThis < "u" ? globalThis : e || self, t(e.marked = {}));
  }(this, function(e) {
    function t() {
      return {
        async: !1,
        breaks: !1,
        extensions: null,
        gfm: !0,
        hooks: null,
        pedantic: !1,
        renderer: null,
        silent: !1,
        tokenizer: null,
        walkTokens: null
      };
    }
    e.defaults = t();
    function i(Xe) {
      e.defaults = Xe;
    }
    const n = /[&<>"']/, o = new RegExp(n.source, "g"), r = /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, a = new RegExp(r.source, "g"), l = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, c = (Xe) => l[Xe];
    function d(Xe, M) {
      if (M) {
        if (n.test(Xe))
          return Xe.replace(o, c);
      } else if (r.test(Xe))
        return Xe.replace(a, c);
      return Xe;
    }
    const h = /(^|[^\[])\^/g;
    function u(Xe, M) {
      let N = typeof Xe == "string" ? Xe : Xe.source;
      M = M || "";
      const T = {
        replace: (O, z) => {
          let q = typeof z == "string" ? z : z.source;
          return q = q.replace(h, "$1"), N = N.replace(O, q), T;
        },
        getRegex: () => new RegExp(N, M)
      };
      return T;
    }
    function g(Xe) {
      try {
        Xe = encodeURI(Xe).replace(/%25/g, "%");
      } catch {
        return null;
      }
      return Xe;
    }
    const m = { exec: () => null };
    function p(Xe, M) {
      const N = Xe.replace(/\|/g, (z, q, ie) => {
        let me = !1, ve = q;
        for (; --ve >= 0 && ie[ve] === "\\"; )
          me = !me;
        return me ? "|" : " |";
      }), T = N.split(/ \|/);
      let O = 0;
      if (T[0].trim() || T.shift(), T.length > 0 && !T[T.length - 1].trim() && T.pop(), M)
        if (T.length > M)
          T.splice(M);
        else
          for (; T.length < M; )
            T.push("");
      for (; O < T.length; O++)
        T[O] = T[O].trim().replace(/\\\|/g, "|");
      return T;
    }
    function A(Xe, M, N) {
      const T = Xe.length;
      if (T === 0)
        return "";
      let O = 0;
      for (; O < T && Xe.charAt(T - O - 1) === M; )
        O++;
      return Xe.slice(0, T - O);
    }
    function _(Xe, M) {
      if (Xe.indexOf(M[1]) === -1)
        return -1;
      let N = 0;
      for (let T = 0; T < Xe.length; T++)
        if (Xe[T] === "\\")
          T++;
        else if (Xe[T] === M[0])
          N++;
        else if (Xe[T] === M[1] && (N--, N < 0))
          return T;
      return -1;
    }
    function b(Xe, M, N, T) {
      const O = M.href, z = M.title ? d(M.title) : null, q = Xe[1].replace(/\\([\[\]])/g, "$1");
      if (Xe[0].charAt(0) !== "!") {
        T.state.inLink = !0;
        const ie = {
          type: "link",
          raw: N,
          href: O,
          title: z,
          text: q,
          tokens: T.inlineTokens(q)
        };
        return T.state.inLink = !1, ie;
      }
      return {
        type: "image",
        raw: N,
        href: O,
        title: z,
        text: d(q)
      };
    }
    function C(Xe, M) {
      const N = Xe.match(/^(\s+)(?:```)/);
      if (N === null)
        return M;
      const T = N[1];
      return M.split(`
`).map((O) => {
        const z = O.match(/^\s+/);
        if (z === null)
          return O;
        const [q] = z;
        return q.length >= T.length ? O.slice(T.length) : O;
      }).join(`
`);
    }
    class w {
      // set by the lexer
      constructor(M) {
        fi(this, "options");
        fi(this, "rules");
        // set by the lexer
        fi(this, "lexer");
        this.options = M || e.defaults;
      }
      space(M) {
        const N = this.rules.block.newline.exec(M);
        if (N && N[0].length > 0)
          return {
            type: "space",
            raw: N[0]
          };
      }
      code(M) {
        const N = this.rules.block.code.exec(M);
        if (N) {
          const T = N[0].replace(/^ {1,4}/gm, "");
          return {
            type: "code",
            raw: N[0],
            codeBlockStyle: "indented",
            text: this.options.pedantic ? T : A(T, `
`)
          };
        }
      }
      fences(M) {
        const N = this.rules.block.fences.exec(M);
        if (N) {
          const T = N[0], O = C(T, N[3] || "");
          return {
            type: "code",
            raw: T,
            lang: N[2] ? N[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : N[2],
            text: O
          };
        }
      }
      heading(M) {
        const N = this.rules.block.heading.exec(M);
        if (N) {
          let T = N[2].trim();
          if (/#$/.test(T)) {
            const O = A(T, "#");
            (this.options.pedantic || !O || / $/.test(O)) && (T = O.trim());
          }
          return {
            type: "heading",
            raw: N[0],
            depth: N[1].length,
            text: T,
            tokens: this.lexer.inline(T)
          };
        }
      }
      hr(M) {
        const N = this.rules.block.hr.exec(M);
        if (N)
          return {
            type: "hr",
            raw: A(N[0], `
`)
          };
      }
      blockquote(M) {
        const N = this.rules.block.blockquote.exec(M);
        if (N) {
          let T = A(N[0], `
`).split(`
`), O = "", z = "";
          const q = [];
          for (; T.length > 0; ) {
            let ie = !1;
            const me = [];
            let ve;
            for (ve = 0; ve < T.length; ve++)
              if (/^ {0,3}>/.test(T[ve]))
                me.push(T[ve]), ie = !0;
              else if (!ie)
                me.push(T[ve]);
              else
                break;
            T = T.slice(ve);
            const je = me.join(`
`), pt = je.replace(/\n {0,3}((?:=+|-+) *)(?=\n|$)/g, `
    $1`).replace(/^ {0,3}>[ \t]?/gm, "");
            O = O ? `${O}
${je}` : je, z = z ? `${z}
${pt}` : pt;
            const wt = this.lexer.state.top;
            if (this.lexer.state.top = !0, this.lexer.blockTokens(pt, q, !0), this.lexer.state.top = wt, T.length === 0)
              break;
            const Ei = q[q.length - 1];
            if (Ei?.type === "code")
              break;
            if (Ei?.type === "blockquote") {
              const Zt = Ei, as = Zt.raw + `
` + T.join(`
`), so = this.blockquote(as);
              q[q.length - 1] = so, O = O.substring(0, O.length - Zt.raw.length) + so.raw, z = z.substring(0, z.length - Zt.text.length) + so.text;
              break;
            } else if (Ei?.type === "list") {
              const Zt = Ei, as = Zt.raw + `
` + T.join(`
`), so = this.list(as);
              q[q.length - 1] = so, O = O.substring(0, O.length - Ei.raw.length) + so.raw, z = z.substring(0, z.length - Zt.raw.length) + so.raw, T = as.substring(q[q.length - 1].raw.length).split(`
`);
              continue;
            }
          }
          return {
            type: "blockquote",
            raw: O,
            tokens: q,
            text: z
          };
        }
      }
      list(M) {
        let N = this.rules.block.list.exec(M);
        if (N) {
          let T = N[1].trim();
          const O = T.length > 1, z = {
            type: "list",
            raw: "",
            ordered: O,
            start: O ? +T.slice(0, -1) : "",
            loose: !1,
            items: []
          };
          T = O ? `\\d{1,9}\\${T.slice(-1)}` : `\\${T}`, this.options.pedantic && (T = O ? T : "[*+-]");
          const q = new RegExp(`^( {0,3}${T})((?:[	 ][^\\n]*)?(?:\\n|$))`);
          let ie = !1;
          for (; M; ) {
            let me = !1, ve = "", je = "";
            if (!(N = q.exec(M)) || this.rules.block.hr.test(M))
              break;
            ve = N[0], M = M.substring(ve.length);
            let pt = N[2].split(`
`, 1)[0].replace(/^\t+/, (Om) => " ".repeat(3 * Om.length)), wt = M.split(`
`, 1)[0], Ei = !pt.trim(), Zt = 0;
            if (this.options.pedantic ? (Zt = 2, je = pt.trimStart()) : Ei ? Zt = N[1].length + 1 : (Zt = N[2].search(/[^ ]/), Zt = Zt > 4 ? 1 : Zt, je = pt.slice(Zt), Zt += N[1].length), Ei && /^ *$/.test(wt) && (ve += wt + `
`, M = M.substring(wt.length + 1), me = !0), !me) {
              const Om = new RegExp(`^ {0,${Math.min(3, Zt - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), Fe = new RegExp(`^ {0,${Math.min(3, Zt - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), G = new RegExp(`^ {0,${Math.min(3, Zt - 1)}}(?:\`\`\`|~~~)`), ge = new RegExp(`^ {0,${Math.min(3, Zt - 1)}}#`);
              for (; M; ) {
                const Le = M.split(`
`, 1)[0];
                if (wt = Le, this.options.pedantic && (wt = wt.replace(/^ {1,4}(?=( {4})*[^ ])/g, "  ")), G.test(wt) || ge.test(wt) || Om.test(wt) || Fe.test(M))
                  break;
                if (wt.search(/[^ ]/) >= Zt || !wt.trim())
                  je += `
` + wt.slice(Zt);
                else {
                  if (Ei || pt.search(/[^ ]/) >= 4 || G.test(pt) || ge.test(pt) || Fe.test(pt))
                    break;
                  je += `
` + wt;
                }
                !Ei && !wt.trim() && (Ei = !0), ve += Le + `
`, M = M.substring(Le.length + 1), pt = wt.slice(Zt);
              }
            }
            z.loose || (ie ? z.loose = !0 : /\n *\n *$/.test(ve) && (ie = !0));
            let as = null, so;
            this.options.gfm && (as = /^\[[ xX]\] /.exec(je), as && (so = as[0] !== "[ ] ", je = je.replace(/^\[[ xX]\] +/, ""))), z.items.push({
              type: "list_item",
              raw: ve,
              task: !!as,
              checked: so,
              loose: !1,
              text: je,
              tokens: []
            }), z.raw += ve;
          }
          z.items[z.items.length - 1].raw = z.items[z.items.length - 1].raw.trimEnd(), z.items[z.items.length - 1].text = z.items[z.items.length - 1].text.trimEnd(), z.raw = z.raw.trimEnd();
          for (let me = 0; me < z.items.length; me++)
            if (this.lexer.state.top = !1, z.items[me].tokens = this.lexer.blockTokens(z.items[me].text, []), !z.loose) {
              const ve = z.items[me].tokens.filter((pt) => pt.type === "space"), je = ve.length > 0 && ve.some((pt) => /\n.*\n/.test(pt.raw));
              z.loose = je;
            }
          if (z.loose)
            for (let me = 0; me < z.items.length; me++)
              z.items[me].loose = !0;
          return z;
        }
      }
      html(M) {
        const N = this.rules.block.html.exec(M);
        if (N)
          return {
            type: "html",
            block: !0,
            raw: N[0],
            pre: N[1] === "pre" || N[1] === "script" || N[1] === "style",
            text: N[0]
          };
      }
      def(M) {
        const N = this.rules.block.def.exec(M);
        if (N) {
          const T = N[1].toLowerCase().replace(/\s+/g, " "), O = N[2] ? N[2].replace(/^<(.*)>$/, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", z = N[3] ? N[3].substring(1, N[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : N[3];
          return {
            type: "def",
            tag: T,
            raw: N[0],
            href: O,
            title: z
          };
        }
      }
      table(M) {
        const N = this.rules.block.table.exec(M);
        if (!N || !/[:|]/.test(N[2]))
          return;
        const T = p(N[1]), O = N[2].replace(/^\||\| *$/g, "").split("|"), z = N[3] && N[3].trim() ? N[3].replace(/\n[ \t]*$/, "").split(`
`) : [], q = {
          type: "table",
          raw: N[0],
          header: [],
          align: [],
          rows: []
        };
        if (T.length === O.length) {
          for (const ie of O)
            /^ *-+: *$/.test(ie) ? q.align.push("right") : /^ *:-+: *$/.test(ie) ? q.align.push("center") : /^ *:-+ *$/.test(ie) ? q.align.push("left") : q.align.push(null);
          for (let ie = 0; ie < T.length; ie++)
            q.header.push({
              text: T[ie],
              tokens: this.lexer.inline(T[ie]),
              header: !0,
              align: q.align[ie]
            });
          for (const ie of z)
            q.rows.push(p(ie, q.header.length).map((me, ve) => ({
              text: me,
              tokens: this.lexer.inline(me),
              header: !1,
              align: q.align[ve]
            })));
          return q;
        }
      }
      lheading(M) {
        const N = this.rules.block.lheading.exec(M);
        if (N)
          return {
            type: "heading",
            raw: N[0],
            depth: N[2].charAt(0) === "=" ? 1 : 2,
            text: N[1],
            tokens: this.lexer.inline(N[1])
          };
      }
      paragraph(M) {
        const N = this.rules.block.paragraph.exec(M);
        if (N) {
          const T = N[1].charAt(N[1].length - 1) === `
` ? N[1].slice(0, -1) : N[1];
          return {
            type: "paragraph",
            raw: N[0],
            text: T,
            tokens: this.lexer.inline(T)
          };
        }
      }
      text(M) {
        const N = this.rules.block.text.exec(M);
        if (N)
          return {
            type: "text",
            raw: N[0],
            text: N[0],
            tokens: this.lexer.inline(N[0])
          };
      }
      escape(M) {
        const N = this.rules.inline.escape.exec(M);
        if (N)
          return {
            type: "escape",
            raw: N[0],
            text: d(N[1])
          };
      }
      tag(M) {
        const N = this.rules.inline.tag.exec(M);
        if (N)
          return !this.lexer.state.inLink && /^<a /i.test(N[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && /^<\/a>/i.test(N[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && /^<(pre|code|kbd|script)(\s|>)/i.test(N[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && /^<\/(pre|code|kbd|script)(\s|>)/i.test(N[0]) && (this.lexer.state.inRawBlock = !1), {
            type: "html",
            raw: N[0],
            inLink: this.lexer.state.inLink,
            inRawBlock: this.lexer.state.inRawBlock,
            block: !1,
            text: N[0]
          };
      }
      link(M) {
        const N = this.rules.inline.link.exec(M);
        if (N) {
          const T = N[2].trim();
          if (!this.options.pedantic && /^</.test(T)) {
            if (!/>$/.test(T))
              return;
            const q = A(T.slice(0, -1), "\\");
            if ((T.length - q.length) % 2 === 0)
              return;
          } else {
            const q = _(N[2], "()");
            if (q > -1) {
              const me = (N[0].indexOf("!") === 0 ? 5 : 4) + N[1].length + q;
              N[2] = N[2].substring(0, q), N[0] = N[0].substring(0, me).trim(), N[3] = "";
            }
          }
          let O = N[2], z = "";
          if (this.options.pedantic) {
            const q = /^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(O);
            q && (O = q[1], z = q[3]);
          } else
            z = N[3] ? N[3].slice(1, -1) : "";
          return O = O.trim(), /^</.test(O) && (this.options.pedantic && !/>$/.test(T) ? O = O.slice(1) : O = O.slice(1, -1)), b(N, {
            href: O && O.replace(this.rules.inline.anyPunctuation, "$1"),
            title: z && z.replace(this.rules.inline.anyPunctuation, "$1")
          }, N[0], this.lexer);
        }
      }
      reflink(M, N) {
        let T;
        if ((T = this.rules.inline.reflink.exec(M)) || (T = this.rules.inline.nolink.exec(M))) {
          const O = (T[2] || T[1]).replace(/\s+/g, " "), z = N[O.toLowerCase()];
          if (!z) {
            const q = T[0].charAt(0);
            return {
              type: "text",
              raw: q,
              text: q
            };
          }
          return b(T, z, T[0], this.lexer);
        }
      }
      emStrong(M, N, T = "") {
        let O = this.rules.inline.emStrongLDelim.exec(M);
        if (!O || O[3] && T.match(/[\p{L}\p{N}]/u))
          return;
        if (!(O[1] || O[2] || "") || !T || this.rules.inline.punctuation.exec(T)) {
          const q = [...O[0]].length - 1;
          let ie, me, ve = q, je = 0;
          const pt = O[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
          for (pt.lastIndex = 0, N = N.slice(-1 * M.length + q); (O = pt.exec(N)) != null; ) {
            if (ie = O[1] || O[2] || O[3] || O[4] || O[5] || O[6], !ie)
              continue;
            if (me = [...ie].length, O[3] || O[4]) {
              ve += me;
              continue;
            } else if ((O[5] || O[6]) && q % 3 && !((q + me) % 3)) {
              je += me;
              continue;
            }
            if (ve -= me, ve > 0)
              continue;
            me = Math.min(me, me + ve + je);
            const wt = [...O[0]][0].length, Ei = M.slice(0, q + O.index + wt + me);
            if (Math.min(q, me) % 2) {
              const as = Ei.slice(1, -1);
              return {
                type: "em",
                raw: Ei,
                text: as,
                tokens: this.lexer.inlineTokens(as)
              };
            }
            const Zt = Ei.slice(2, -2);
            return {
              type: "strong",
              raw: Ei,
              text: Zt,
              tokens: this.lexer.inlineTokens(Zt)
            };
          }
        }
      }
      codespan(M) {
        const N = this.rules.inline.code.exec(M);
        if (N) {
          let T = N[2].replace(/\n/g, " ");
          const O = /[^ ]/.test(T), z = /^ /.test(T) && / $/.test(T);
          return O && z && (T = T.substring(1, T.length - 1)), T = d(T, !0), {
            type: "codespan",
            raw: N[0],
            text: T
          };
        }
      }
      br(M) {
        const N = this.rules.inline.br.exec(M);
        if (N)
          return {
            type: "br",
            raw: N[0]
          };
      }
      del(M) {
        const N = this.rules.inline.del.exec(M);
        if (N)
          return {
            type: "del",
            raw: N[0],
            text: N[2],
            tokens: this.lexer.inlineTokens(N[2])
          };
      }
      autolink(M) {
        const N = this.rules.inline.autolink.exec(M);
        if (N) {
          let T, O;
          return N[2] === "@" ? (T = d(N[1]), O = "mailto:" + T) : (T = d(N[1]), O = T), {
            type: "link",
            raw: N[0],
            text: T,
            href: O,
            tokens: [
              {
                type: "text",
                raw: T,
                text: T
              }
            ]
          };
        }
      }
      url(M) {
        let N;
        if (N = this.rules.inline.url.exec(M)) {
          let T, O;
          if (N[2] === "@")
            T = d(N[0]), O = "mailto:" + T;
          else {
            let z;
            do
              z = N[0], N[0] = this.rules.inline._backpedal.exec(N[0])?.[0] ?? "";
            while (z !== N[0]);
            T = d(N[0]), N[1] === "www." ? O = "http://" + N[0] : O = N[0];
          }
          return {
            type: "link",
            raw: N[0],
            text: T,
            href: O,
            tokens: [
              {
                type: "text",
                raw: T,
                text: T
              }
            ]
          };
        }
      }
      inlineText(M) {
        const N = this.rules.inline.text.exec(M);
        if (N) {
          let T;
          return this.lexer.state.inRawBlock ? T = N[0] : T = d(N[0]), {
            type: "text",
            raw: N[0],
            text: T
          };
        }
      }
    }
    const S = /^(?: *(?:\n|$))+/, x = /^( {4}[^\n]+(?:\n(?: *(?:\n|$))*)?)+/, y = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/, D = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/, I = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/, Q = /(?:[*+-]|\d{1,9}[.)])/, P = u(/^(?!bull |blockCode|fences|blockquote|heading|html)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html))+?)\n {0,3}(=+|-+) *(?:\n+|$)/).replace(/bull/g, Q).replace(/blockCode/g, / {4}/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).getRegex(), W = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/, j = /^[^\n]+/, H = /(?!\s*\])(?:\\.|[^\[\]\\])+/, J = u(/^ {0,3}\[(label)\]: *(?:\n *)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n *)?| *\n *)(title))? *(?:\n+|$)/).replace("label", H).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(), se = u(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, Q).getRegex(), ce = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul", he = /<!--(?:-?>|[\s\S]*?(?:-->|$))/, ae = u("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n *)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n *)+\\n|$))", "i").replace("comment", he).replace("tag", ce).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(), be = u(W).replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ce).getRegex(), Ft = {
      blockquote: u(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", be).getRegex(),
      code: x,
      def: J,
      fences: y,
      heading: I,
      hr: D,
      html: ae,
      lheading: P,
      list: se,
      newline: S,
      paragraph: be,
      table: m,
      text: j
    }, ut = u("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", " {4}[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ce).getRegex(), Ut = {
      ...Ft,
      table: ut,
      paragraph: u(W).replace("hr", D).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", ut).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", ce).getRegex()
    }, ft = {
      ...Ft,
      html: u(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", he).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),
      def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
      heading: /^(#{1,6})(.*)(?:\n+|$)/,
      fences: m,
      // fences not supported
      lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
      paragraph: u(W).replace("hr", D).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", P).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex()
    }, ri = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/, io = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/, Ai = /^( {2,}|\\)\n(?!\s*$)/, Io = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/, Xl = "\\p{P}\\p{S}", Z_ = u(/^((?![*_])[\spunctuation])/, "u").replace(/punctuation/g, Xl).getRegex(), Zl = /\[[^[\]]*?\]\([^\(\)]*?\)|`[^`]*?`|<[^<>]*?>/g, Tm = u(/^(?:\*+(?:((?!\*)[punct])|[^\s*]))|^_+(?:((?!_)[punct])|([^\s_]))/, "u").replace(/punct/g, Xl).getRegex(), Va = u("^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)[punct](\\*+)(?=[\\s]|$)|[^punct\\s](\\*+)(?!\\*)(?=[punct\\s]|$)|(?!\\*)[punct\\s](\\*+)(?=[^punct\\s])|[\\s](\\*+)(?!\\*)(?=[punct])|(?!\\*)[punct](\\*+)(?!\\*)(?=[punct])|[^punct\\s](\\*+)(?=[^punct\\s])", "gu").replace(/punct/g, Xl).getRegex(), Bm = u("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)[punct](_+)(?=[\\s]|$)|[^punct\\s](_+)(?!_)(?=[punct\\s]|$)|(?!_)[punct\\s](_+)(?=[^punct\\s])|[\\s](_+)(?!_)(?=[punct])|(?!_)[punct](_+)(?!_)(?=[punct])", "gu").replace(/punct/g, Xl).getRegex(), Rm = u(/\\([punct])/, "gu").replace(/punct/g, Xl).getRegex(), ec = u(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Zu = u(he).replace("(?:-->|$)", "-->").getRegex(), eg = u("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", Zu).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(), Ed = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/, eb = u(/^!?\[(label)\]\(\s*(href)(?:\s+(title))?\s*\)/).replace("label", Ed).replace("href", /<(?:\\.|[^\n<>\\])+>|[^\s\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(), tb = u(/^!?\[(label)\]\[(ref)\]/).replace("label", Ed).replace("ref", H).getRegex(), tg = u(/^!?\[(ref)\](?:\[\])?/).replace("ref", H).getRegex(), Ld = u("reflink|nolink(?!\\()", "g").replace("reflink", tb).replace("nolink", tg).getRegex(), zr = {
      _backpedal: m,
      // only used for GFM url
      anyPunctuation: Rm,
      autolink: ec,
      blockSkip: Zl,
      br: Ai,
      code: io,
      del: m,
      emStrongLDelim: Tm,
      emStrongRDelimAst: Va,
      emStrongRDelimUnd: Bm,
      escape: ri,
      link: eb,
      nolink: tg,
      punctuation: Z_,
      reflink: tb,
      reflinkSearch: Ld,
      tag: eg,
      text: Io,
      url: m
    }, tc = {
      ...zr,
      link: u(/^!?\[(label)\]\((.*?)\)/).replace("label", Ed).getRegex(),
      reflink: u(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", Ed).getRegex()
    }, ig = {
      ...zr,
      escape: u(ri).replace("])", "~|])").getRegex(),
      url: u(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/, "i").replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),
      _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
      del: /^(~~?)(?=[^\s~])([\s\S]*?[^\s~])\1(?=[^~]|$)/,
      text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/
    }, ib = {
      ...ig,
      br: u(Ai).replace("{2,}", "*").getRegex(),
      text: u(ig.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex()
    }, kd = {
      normal: Ft,
      gfm: Ut,
      pedantic: ft
    }, za = {
      normal: zr,
      gfm: ig,
      breaks: ib,
      pedantic: tc
    };
    class Is {
      constructor(M) {
        fi(this, "tokens");
        fi(this, "options");
        fi(this, "state");
        fi(this, "tokenizer");
        fi(this, "inlineQueue");
        this.tokens = [], this.tokens.links = /* @__PURE__ */ Object.create(null), this.options = M || e.defaults, this.options.tokenizer = this.options.tokenizer || new w(), this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {
          inLink: !1,
          inRawBlock: !1,
          top: !0
        };
        const N = {
          block: kd.normal,
          inline: za.normal
        };
        this.options.pedantic ? (N.block = kd.pedantic, N.inline = za.pedantic) : this.options.gfm && (N.block = kd.gfm, this.options.breaks ? N.inline = za.breaks : N.inline = za.gfm), this.tokenizer.rules = N;
      }
      /**
       * Expose Rules
       */
      static get rules() {
        return {
          block: kd,
          inline: za
        };
      }
      /**
       * Static Lex Method
       */
      static lex(M, N) {
        return new Is(N).lex(M);
      }
      /**
       * Static Lex Inline Method
       */
      static lexInline(M, N) {
        return new Is(N).inlineTokens(M);
      }
      /**
       * Preprocessing
       */
      lex(M) {
        M = M.replace(/\r\n|\r/g, `
`), this.blockTokens(M, this.tokens);
        for (let N = 0; N < this.inlineQueue.length; N++) {
          const T = this.inlineQueue[N];
          this.inlineTokens(T.src, T.tokens);
        }
        return this.inlineQueue = [], this.tokens;
      }
      blockTokens(M, N = [], T = !1) {
        this.options.pedantic ? M = M.replace(/\t/g, "    ").replace(/^ +$/gm, "") : M = M.replace(/^( *)(\t+)/gm, (ie, me, ve) => me + "    ".repeat(ve.length));
        let O, z, q;
        for (; M; )
          if (!(this.options.extensions && this.options.extensions.block && this.options.extensions.block.some((ie) => (O = ie.call({ lexer: this }, M, N)) ? (M = M.substring(O.raw.length), N.push(O), !0) : !1))) {
            if (O = this.tokenizer.space(M)) {
              M = M.substring(O.raw.length), O.raw.length === 1 && N.length > 0 ? N[N.length - 1].raw += `
` : N.push(O);
              continue;
            }
            if (O = this.tokenizer.code(M)) {
              M = M.substring(O.raw.length), z = N[N.length - 1], z && (z.type === "paragraph" || z.type === "text") ? (z.raw += `
` + O.raw, z.text += `
` + O.text, this.inlineQueue[this.inlineQueue.length - 1].src = z.text) : N.push(O);
              continue;
            }
            if (O = this.tokenizer.fences(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.heading(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.hr(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.blockquote(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.list(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.html(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.def(M)) {
              M = M.substring(O.raw.length), z = N[N.length - 1], z && (z.type === "paragraph" || z.type === "text") ? (z.raw += `
` + O.raw, z.text += `
` + O.raw, this.inlineQueue[this.inlineQueue.length - 1].src = z.text) : this.tokens.links[O.tag] || (this.tokens.links[O.tag] = {
                href: O.href,
                title: O.title
              });
              continue;
            }
            if (O = this.tokenizer.table(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (O = this.tokenizer.lheading(M)) {
              M = M.substring(O.raw.length), N.push(O);
              continue;
            }
            if (q = M, this.options.extensions && this.options.extensions.startBlock) {
              let ie = 1 / 0;
              const me = M.slice(1);
              let ve;
              this.options.extensions.startBlock.forEach((je) => {
                ve = je.call({ lexer: this }, me), typeof ve == "number" && ve >= 0 && (ie = Math.min(ie, ve));
              }), ie < 1 / 0 && ie >= 0 && (q = M.substring(0, ie + 1));
            }
            if (this.state.top && (O = this.tokenizer.paragraph(q))) {
              z = N[N.length - 1], T && z?.type === "paragraph" ? (z.raw += `
` + O.raw, z.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = z.text) : N.push(O), T = q.length !== M.length, M = M.substring(O.raw.length);
              continue;
            }
            if (O = this.tokenizer.text(M)) {
              M = M.substring(O.raw.length), z = N[N.length - 1], z && z.type === "text" ? (z.raw += `
` + O.raw, z.text += `
` + O.text, this.inlineQueue.pop(), this.inlineQueue[this.inlineQueue.length - 1].src = z.text) : N.push(O);
              continue;
            }
            if (M) {
              const ie = "Infinite loop on byte: " + M.charCodeAt(0);
              if (this.options.silent) {
                console.error(ie);
                break;
              } else
                throw new Error(ie);
            }
          }
        return this.state.top = !0, N;
      }
      inline(M, N = []) {
        return this.inlineQueue.push({ src: M, tokens: N }), N;
      }
      /**
       * Lexing/Compiling
       */
      inlineTokens(M, N = []) {
        let T, O, z, q = M, ie, me, ve;
        if (this.tokens.links) {
          const je = Object.keys(this.tokens.links);
          if (je.length > 0)
            for (; (ie = this.tokenizer.rules.inline.reflinkSearch.exec(q)) != null; )
              je.includes(ie[0].slice(ie[0].lastIndexOf("[") + 1, -1)) && (q = q.slice(0, ie.index) + "[" + "a".repeat(ie[0].length - 2) + "]" + q.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
        }
        for (; (ie = this.tokenizer.rules.inline.blockSkip.exec(q)) != null; )
          q = q.slice(0, ie.index) + "[" + "a".repeat(ie[0].length - 2) + "]" + q.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
        for (; (ie = this.tokenizer.rules.inline.anyPunctuation.exec(q)) != null; )
          q = q.slice(0, ie.index) + "++" + q.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
        for (; M; )
          if (me || (ve = ""), me = !1, !(this.options.extensions && this.options.extensions.inline && this.options.extensions.inline.some((je) => (T = je.call({ lexer: this }, M, N)) ? (M = M.substring(T.raw.length), N.push(T), !0) : !1))) {
            if (T = this.tokenizer.escape(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.tag(M)) {
              M = M.substring(T.raw.length), O = N[N.length - 1], O && T.type === "text" && O.type === "text" ? (O.raw += T.raw, O.text += T.text) : N.push(T);
              continue;
            }
            if (T = this.tokenizer.link(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.reflink(M, this.tokens.links)) {
              M = M.substring(T.raw.length), O = N[N.length - 1], O && T.type === "text" && O.type === "text" ? (O.raw += T.raw, O.text += T.text) : N.push(T);
              continue;
            }
            if (T = this.tokenizer.emStrong(M, q, ve)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.codespan(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.br(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.del(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (T = this.tokenizer.autolink(M)) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (!this.state.inLink && (T = this.tokenizer.url(M))) {
              M = M.substring(T.raw.length), N.push(T);
              continue;
            }
            if (z = M, this.options.extensions && this.options.extensions.startInline) {
              let je = 1 / 0;
              const pt = M.slice(1);
              let wt;
              this.options.extensions.startInline.forEach((Ei) => {
                wt = Ei.call({ lexer: this }, pt), typeof wt == "number" && wt >= 0 && (je = Math.min(je, wt));
              }), je < 1 / 0 && je >= 0 && (z = M.substring(0, je + 1));
            }
            if (T = this.tokenizer.inlineText(z)) {
              M = M.substring(T.raw.length), T.raw.slice(-1) !== "_" && (ve = T.raw.slice(-1)), me = !0, O = N[N.length - 1], O && O.type === "text" ? (O.raw += T.raw, O.text += T.text) : N.push(T);
              continue;
            }
            if (M) {
              const je = "Infinite loop on byte: " + M.charCodeAt(0);
              if (this.options.silent) {
                console.error(je);
                break;
              } else
                throw new Error(je);
            }
          }
        return N;
      }
    }
    class Ur {
      // set by the parser
      constructor(M) {
        fi(this, "options");
        fi(this, "parser");
        this.options = M || e.defaults;
      }
      space(M) {
        return "";
      }
      code({ text: M, lang: N, escaped: T }) {
        const O = (N || "").match(/^\S*/)?.[0], z = M.replace(/\n$/, "") + `
`;
        return O ? '<pre><code class="language-' + d(O) + '">' + (T ? z : d(z, !0)) + `</code></pre>
` : "<pre><code>" + (T ? z : d(z, !0)) + `</code></pre>
`;
      }
      blockquote({ tokens: M }) {
        return `<blockquote>
${this.parser.parse(M)}</blockquote>
`;
      }
      html({ text: M }) {
        return M;
      }
      heading({ tokens: M, depth: N }) {
        return `<h${N}>${this.parser.parseInline(M)}</h${N}>
`;
      }
      hr(M) {
        return `<hr>
`;
      }
      list(M) {
        const N = M.ordered, T = M.start;
        let O = "";
        for (let ie = 0; ie < M.items.length; ie++) {
          const me = M.items[ie];
          O += this.listitem(me);
        }
        const z = N ? "ol" : "ul", q = N && T !== 1 ? ' start="' + T + '"' : "";
        return "<" + z + q + `>
` + O + "</" + z + `>
`;
      }
      listitem(M) {
        let N = "";
        if (M.task) {
          const T = this.checkbox({ checked: !!M.checked });
          M.loose ? M.tokens.length > 0 && M.tokens[0].type === "paragraph" ? (M.tokens[0].text = T + " " + M.tokens[0].text, M.tokens[0].tokens && M.tokens[0].tokens.length > 0 && M.tokens[0].tokens[0].type === "text" && (M.tokens[0].tokens[0].text = T + " " + M.tokens[0].tokens[0].text)) : M.tokens.unshift({
            type: "text",
            raw: T + " ",
            text: T + " "
          }) : N += T + " ";
        }
        return N += this.parser.parse(M.tokens, !!M.loose), `<li>${N}</li>
`;
      }
      checkbox({ checked: M }) {
        return "<input " + (M ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
      }
      paragraph({ tokens: M }) {
        return `<p>${this.parser.parseInline(M)}</p>
`;
      }
      table(M) {
        let N = "", T = "";
        for (let z = 0; z < M.header.length; z++)
          T += this.tablecell(M.header[z]);
        N += this.tablerow({ text: T });
        let O = "";
        for (let z = 0; z < M.rows.length; z++) {
          const q = M.rows[z];
          T = "";
          for (let ie = 0; ie < q.length; ie++)
            T += this.tablecell(q[ie]);
          O += this.tablerow({ text: T });
        }
        return O && (O = `<tbody>${O}</tbody>`), `<table>
<thead>
` + N + `</thead>
` + O + `</table>
`;
      }
      tablerow({ text: M }) {
        return `<tr>
${M}</tr>
`;
      }
      tablecell(M) {
        const N = this.parser.parseInline(M.tokens), T = M.header ? "th" : "td";
        return (M.align ? `<${T} align="${M.align}">` : `<${T}>`) + N + `</${T}>
`;
      }
      /**
       * span level renderer
       */
      strong({ tokens: M }) {
        return `<strong>${this.parser.parseInline(M)}</strong>`;
      }
      em({ tokens: M }) {
        return `<em>${this.parser.parseInline(M)}</em>`;
      }
      codespan({ text: M }) {
        return `<code>${M}</code>`;
      }
      br(M) {
        return "<br>";
      }
      del({ tokens: M }) {
        return `<del>${this.parser.parseInline(M)}</del>`;
      }
      link({ href: M, title: N, tokens: T }) {
        const O = this.parser.parseInline(T), z = g(M);
        if (z === null)
          return O;
        M = z;
        let q = '<a href="' + M + '"';
        return N && (q += ' title="' + N + '"'), q += ">" + O + "</a>", q;
      }
      image({ href: M, title: N, text: T }) {
        const O = g(M);
        if (O === null)
          return T;
        M = O;
        let z = `<img src="${M}" alt="${T}"`;
        return N && (z += ` title="${N}"`), z += ">", z;
      }
      text(M) {
        return "tokens" in M && M.tokens ? this.parser.parseInline(M.tokens) : M.text;
      }
    }
    class Ua {
      // no need for block level renderers
      strong({ text: M }) {
        return M;
      }
      em({ text: M }) {
        return M;
      }
      codespan({ text: M }) {
        return M;
      }
      del({ text: M }) {
        return M;
      }
      html({ text: M }) {
        return M;
      }
      text({ text: M }) {
        return M;
      }
      link({ text: M }) {
        return "" + M;
      }
      image({ text: M }) {
        return "" + M;
      }
      br() {
        return "";
      }
    }
    class Pi {
      constructor(M) {
        fi(this, "options");
        fi(this, "renderer");
        fi(this, "textRenderer");
        this.options = M || e.defaults, this.options.renderer = this.options.renderer || new Ur(), this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new Ua();
      }
      /**
       * Static Parse Method
       */
      static parse(M, N) {
        return new Pi(N).parse(M);
      }
      /**
       * Static Parse Inline Method
       */
      static parseInline(M, N) {
        return new Pi(N).parseInline(M);
      }
      /**
       * Parse Loop
       */
      parse(M, N = !0) {
        let T = "";
        for (let O = 0; O < M.length; O++) {
          const z = M[O];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[z.type]) {
            const ie = z, me = this.options.extensions.renderers[ie.type].call({ parser: this }, ie);
            if (me !== !1 || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "paragraph", "text"].includes(ie.type)) {
              T += me || "";
              continue;
            }
          }
          const q = z;
          switch (q.type) {
            case "space": {
              T += this.renderer.space(q);
              continue;
            }
            case "hr": {
              T += this.renderer.hr(q);
              continue;
            }
            case "heading": {
              T += this.renderer.heading(q);
              continue;
            }
            case "code": {
              T += this.renderer.code(q);
              continue;
            }
            case "table": {
              T += this.renderer.table(q);
              continue;
            }
            case "blockquote": {
              T += this.renderer.blockquote(q);
              continue;
            }
            case "list": {
              T += this.renderer.list(q);
              continue;
            }
            case "html": {
              T += this.renderer.html(q);
              continue;
            }
            case "paragraph": {
              T += this.renderer.paragraph(q);
              continue;
            }
            case "text": {
              let ie = q, me = this.renderer.text(ie);
              for (; O + 1 < M.length && M[O + 1].type === "text"; )
                ie = M[++O], me += `
` + this.renderer.text(ie);
              N ? T += this.renderer.paragraph({
                type: "paragraph",
                raw: me,
                text: me,
                tokens: [{ type: "text", raw: me, text: me }]
              }) : T += me;
              continue;
            }
            default: {
              const ie = 'Token with "' + q.type + '" type was not found.';
              if (this.options.silent)
                return console.error(ie), "";
              throw new Error(ie);
            }
          }
        }
        return T;
      }
      /**
       * Parse Inline Tokens
       */
      parseInline(M, N) {
        N = N || this.renderer;
        let T = "";
        for (let O = 0; O < M.length; O++) {
          const z = M[O];
          if (this.options.extensions && this.options.extensions.renderers && this.options.extensions.renderers[z.type]) {
            const ie = this.options.extensions.renderers[z.type].call({ parser: this }, z);
            if (ie !== !1 || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(z.type)) {
              T += ie || "";
              continue;
            }
          }
          const q = z;
          switch (q.type) {
            case "escape": {
              T += N.text(q);
              break;
            }
            case "html": {
              T += N.html(q);
              break;
            }
            case "link": {
              T += N.link(q);
              break;
            }
            case "image": {
              T += N.image(q);
              break;
            }
            case "strong": {
              T += N.strong(q);
              break;
            }
            case "em": {
              T += N.em(q);
              break;
            }
            case "codespan": {
              T += N.codespan(q);
              break;
            }
            case "br": {
              T += N.br(q);
              break;
            }
            case "del": {
              T += N.del(q);
              break;
            }
            case "text": {
              T += N.text(q);
              break;
            }
            default: {
              const ie = 'Token with "' + q.type + '" type was not found.';
              if (this.options.silent)
                return console.error(ie), "";
              throw new Error(ie);
            }
          }
        }
        return T;
      }
    }
    class no {
      constructor(M) {
        fi(this, "options");
        this.options = M || e.defaults;
      }
      /**
       * Process markdown before marked
       */
      preprocess(M) {
        return M;
      }
      /**
       * Process HTML after marked is finished
       */
      postprocess(M) {
        return M;
      }
      /**
       * Process all tokens before walk tokens
       */
      processAllTokens(M) {
        return M;
      }
    }
    fi(no, "passThroughHooks", /* @__PURE__ */ new Set([
      "preprocess",
      "postprocess",
      "processAllTokens"
    ]));
    class ng {
      constructor(...M) {
        fi(this, "defaults", t());
        fi(this, "options", this.setOptions);
        fi(this, "parse", this.parseMarkdown(Is.lex, Pi.parse));
        fi(this, "parseInline", this.parseMarkdown(Is.lexInline, Pi.parseInline));
        fi(this, "Parser", Pi);
        fi(this, "Renderer", Ur);
        fi(this, "TextRenderer", Ua);
        fi(this, "Lexer", Is);
        fi(this, "Tokenizer", w);
        fi(this, "Hooks", no);
        this.use(...M);
      }
      /**
       * Run callback for every token
       */
      walkTokens(M, N) {
        let T = [];
        for (const O of M)
          switch (T = T.concat(N.call(this, O)), O.type) {
            case "table": {
              const z = O;
              for (const q of z.header)
                T = T.concat(this.walkTokens(q.tokens, N));
              for (const q of z.rows)
                for (const ie of q)
                  T = T.concat(this.walkTokens(ie.tokens, N));
              break;
            }
            case "list": {
              const z = O;
              T = T.concat(this.walkTokens(z.items, N));
              break;
            }
            default: {
              const z = O;
              this.defaults.extensions?.childTokens?.[z.type] ? this.defaults.extensions.childTokens[z.type].forEach((q) => {
                const ie = z[q].flat(1 / 0);
                T = T.concat(this.walkTokens(ie, N));
              }) : z.tokens && (T = T.concat(this.walkTokens(z.tokens, N)));
            }
          }
        return T;
      }
      use(...M) {
        const N = this.defaults.extensions || { renderers: {}, childTokens: {} };
        return M.forEach((T) => {
          const O = { ...T };
          if (O.async = this.defaults.async || O.async || !1, T.extensions && (T.extensions.forEach((z) => {
            if (!z.name)
              throw new Error("extension name required");
            if ("renderer" in z) {
              const q = N.renderers[z.name];
              q ? N.renderers[z.name] = function(...ie) {
                let me = z.renderer.apply(this, ie);
                return me === !1 && (me = q.apply(this, ie)), me;
              } : N.renderers[z.name] = z.renderer;
            }
            if ("tokenizer" in z) {
              if (!z.level || z.level !== "block" && z.level !== "inline")
                throw new Error("extension level must be 'block' or 'inline'");
              const q = N[z.level];
              q ? q.unshift(z.tokenizer) : N[z.level] = [z.tokenizer], z.start && (z.level === "block" ? N.startBlock ? N.startBlock.push(z.start) : N.startBlock = [z.start] : z.level === "inline" && (N.startInline ? N.startInline.push(z.start) : N.startInline = [z.start]));
            }
            "childTokens" in z && z.childTokens && (N.childTokens[z.name] = z.childTokens);
          }), O.extensions = N), T.renderer) {
            const z = this.defaults.renderer || new Ur(this.defaults);
            for (const q in T.renderer) {
              if (!(q in z))
                throw new Error(`renderer '${q}' does not exist`);
              if (["options", "parser"].includes(q))
                continue;
              const ie = q, me = T.renderer[ie], ve = z[ie];
              z[ie] = (...je) => {
                let pt = me.apply(z, je);
                return pt === !1 && (pt = ve.apply(z, je)), pt || "";
              };
            }
            O.renderer = z;
          }
          if (T.tokenizer) {
            const z = this.defaults.tokenizer || new w(this.defaults);
            for (const q in T.tokenizer) {
              if (!(q in z))
                throw new Error(`tokenizer '${q}' does not exist`);
              if (["options", "rules", "lexer"].includes(q))
                continue;
              const ie = q, me = T.tokenizer[ie], ve = z[ie];
              z[ie] = (...je) => {
                let pt = me.apply(z, je);
                return pt === !1 && (pt = ve.apply(z, je)), pt;
              };
            }
            O.tokenizer = z;
          }
          if (T.hooks) {
            const z = this.defaults.hooks || new no();
            for (const q in T.hooks) {
              if (!(q in z))
                throw new Error(`hook '${q}' does not exist`);
              if (q === "options")
                continue;
              const ie = q, me = T.hooks[ie], ve = z[ie];
              no.passThroughHooks.has(q) ? z[ie] = (je) => {
                if (this.defaults.async)
                  return Promise.resolve(me.call(z, je)).then((wt) => ve.call(z, wt));
                const pt = me.call(z, je);
                return ve.call(z, pt);
              } : z[ie] = (...je) => {
                let pt = me.apply(z, je);
                return pt === !1 && (pt = ve.apply(z, je)), pt;
              };
            }
            O.hooks = z;
          }
          if (T.walkTokens) {
            const z = this.defaults.walkTokens, q = T.walkTokens;
            O.walkTokens = function(ie) {
              let me = [];
              return me.push(q.call(this, ie)), z && (me = me.concat(z.call(this, ie))), me;
            };
          }
          this.defaults = { ...this.defaults, ...O };
        }), this;
      }
      setOptions(M) {
        return this.defaults = { ...this.defaults, ...M }, this;
      }
      lexer(M, N) {
        return Is.lex(M, N ?? this.defaults);
      }
      parser(M, N) {
        return Pi.parse(M, N ?? this.defaults);
      }
      parseMarkdown(M, N) {
        return (O, z) => {
          const q = { ...z }, ie = { ...this.defaults, ...q }, me = this.onError(!!ie.silent, !!ie.async);
          if (this.defaults.async === !0 && q.async === !1)
            return me(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
          if (typeof O > "u" || O === null)
            return me(new Error("marked(): input parameter is undefined or null"));
          if (typeof O != "string")
            return me(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(O) + ", string expected"));
          if (ie.hooks && (ie.hooks.options = ie), ie.async)
            return Promise.resolve(ie.hooks ? ie.hooks.preprocess(O) : O).then((ve) => M(ve, ie)).then((ve) => ie.hooks ? ie.hooks.processAllTokens(ve) : ve).then((ve) => ie.walkTokens ? Promise.all(this.walkTokens(ve, ie.walkTokens)).then(() => ve) : ve).then((ve) => N(ve, ie)).then((ve) => ie.hooks ? ie.hooks.postprocess(ve) : ve).catch(me);
          try {
            ie.hooks && (O = ie.hooks.preprocess(O));
            let ve = M(O, ie);
            ie.hooks && (ve = ie.hooks.processAllTokens(ve)), ie.walkTokens && this.walkTokens(ve, ie.walkTokens);
            let je = N(ve, ie);
            return ie.hooks && (je = ie.hooks.postprocess(je)), je;
          } catch (ve) {
            return me(ve);
          }
        };
      }
      onError(M, N) {
        return (T) => {
          if (T.message += `
Please report this to https://github.com/markedjs/marked.`, M) {
            const O = "<p>An error occurred:</p><pre>" + d(T.message + "", !0) + "</pre>";
            return N ? Promise.resolve(O) : O;
          }
          if (N)
            return Promise.reject(T);
          throw T;
        };
      }
    }
    const dr = new ng();
    function Pt(Xe, M) {
      return dr.parse(Xe, M);
    }
    Pt.options = Pt.setOptions = function(Xe) {
      return dr.setOptions(Xe), Pt.defaults = dr.defaults, i(Pt.defaults), Pt;
    }, Pt.getDefaults = t, Pt.defaults = e.defaults, Pt.use = function(...Xe) {
      return dr.use(...Xe), Pt.defaults = dr.defaults, i(Pt.defaults), Pt;
    }, Pt.walkTokens = function(Xe, M) {
      return dr.walkTokens(Xe, M);
    }, Pt.parseInline = dr.parseInline, Pt.Parser = Pi, Pt.parser = Pi.parse, Pt.Renderer = Ur, Pt.TextRenderer = Ua, Pt.Lexer = Is, Pt.lexer = Is.lex, Pt.Tokenizer = w, Pt.Hooks = no, Pt.parse = Pt;
    const Dd = Pt.options, PS = Pt.setOptions, HS = Pt.use, Yi = Pt.walkTokens, ic = Pt.parseInline, WS = Pt, nb = Pi.parse, Fm = Is.lex;
    e.Hooks = no, e.Lexer = Is, e.Marked = ng, e.Parser = Pi, e.Renderer = Ur, e.TextRenderer = Ua, e.Tokenizer = w, e.getDefaults = t, e.lexer = Fm, e.marked = Pt, e.options = Dd, e.parse = WS, e.parseInline = ic, e.parser = nb, e.setOptions = PS, e.use = HS, e.walkTokens = Yi;
  });
})();
hn.Hooks || exports.Hooks;
hn.Lexer || exports.Lexer;
hn.Marked || exports.Marked;
hn.Parser || exports.Parser;
var S3 = hn.Renderer || exports.Renderer;
hn.TextRenderer || exports.TextRenderer;
hn.Tokenizer || exports.Tokenizer;
var vJ = hn.defaults || exports.defaults;
hn.getDefaults || exports.getDefaults;
var X0 = hn.lexer || exports.lexer;
hn.marked || exports.marked;
hn.options || exports.options;
var y3 = hn.parse || exports.parse;
hn.parseInline || exports.parseInline;
var SJ = hn.parser || exports.parser;
hn.setOptions || exports.setOptions;
hn.use || exports.use;
hn.walkTokens || exports.walkTokens;
function yJ(s) {
  return JSON.stringify(s, xJ);
}
function TL(s) {
  let e = JSON.parse(s);
  return e = BL(e), e;
}
function xJ(s, e) {
  return e instanceof RegExp ? {
    $mid: 2,
    source: e.source,
    flags: e.flags
  } : e;
}
function BL(s, e = 0) {
  if (!s || e > 200)
    return s;
  if (typeof s == "object") {
    switch (s.$mid) {
      case 1:
        return _e.revive(s);
      case 2:
        return new RegExp(s.source, s.flags);
      case 17:
        return new Date(s.source);
    }
    if (s instanceof sN || s instanceof Uint8Array)
      return s;
    if (Array.isArray(s))
      for (let t = 0; t < s.length; ++t)
        s[t] = BL(s[t], e + 1);
    else
      for (const t in s)
        Object.hasOwnProperty.call(s, t) && (s[t] = BL(s[t], e + 1));
  }
  return s;
}
const ky = Object.freeze({
  image: ({ href: s, title: e, text: t }) => {
    let i = [], n = [];
    return s && ({ href: s, dimensions: i } = CJ(s), n.push(`src="${Sb(s)}"`)), t && n.push(`alt="${Sb(t)}"`), e && n.push(`title="${Sb(e)}"`), i.length && (n = n.concat(i)), "<img " + n.join(" ") + ">";
  },
  paragraph({ tokens: s }) {
    return `<p>${this.parser.parseInline(s)}</p>`;
  },
  link({ href: s, title: e, tokens: t }) {
    let i = this.parser.parseInline(t);
    return typeof s != "string" ? "" : (s === i && (i = Ly(i)), e = typeof e == "string" ? Sb(Ly(e)) : "", s = Ly(s), s = s.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;"), `<a href="${s}" title="${e || s}" draggable="false">${i}</a>`);
  }
});
function Z0(s, e = {}, t = {}) {
  const i = new X();
  let n = !1;
  const o = xN(e), r = function(p) {
    let A;
    try {
      A = TL(decodeURIComponent(p));
    } catch {
    }
    return A ? (A = U4(A, (_) => {
      if (s.uris && s.uris[_])
        return _e.revive(s.uris[_]);
    }), encodeURIComponent(JSON.stringify(A))) : p;
  }, a = function(p, A) {
    const _ = s.uris && s.uris[p];
    let b = _e.revive(_);
    return A ? p.startsWith(Ie.data + ":") ? p : (b || (b = _e.parse(p)), w0.uriToBrowserUri(b).toString(!0)) : !b || _e.parse(p).toString() === b.toString() ? p : (b.query && (b = b.with({ query: r(b.query) })), b.toString());
  }, l = new S3();
  l.image = ky.image, l.link = ky.link, l.paragraph = ky.paragraph;
  const c = [], d = [];
  if (e.codeBlockRendererSync ? l.code = ({ text: p, lang: A }) => {
    const _ = NL.nextId(), b = e.codeBlockRendererSync(V2(A), p);
    return d.push([_, b]), `<div class="code" data-code="${_}">${Ip(p)}</div>`;
  } : e.codeBlockRenderer && (l.code = ({ text: p, lang: A }) => {
    const _ = NL.nextId(), b = e.codeBlockRenderer(V2(A), p);
    return c.push(b.then((C) => [_, C])), `<div class="code" data-code="${_}">${Ip(p)}</div>`;
  }), e.actionHandler) {
    const p = function(b) {
      let C = b.target;
      if (!(C.tagName !== "A" && (C = C.parentElement, !C || C.tagName !== "A")))
        try {
          let w = C.dataset.href;
          w && (s.baseUri && (w = Dy(_e.from(s.baseUri), w)), e.actionHandler.callback(w, b));
        } catch (w) {
          Pe(w);
        } finally {
          b.preventDefault();
        }
    }, A = e.actionHandler.disposables.add(new Ke(o, "click")), _ = e.actionHandler.disposables.add(new Ke(o, "auxclick"));
    e.actionHandler.disposables.add(te.any(A.event, _.event)((b) => {
      const C = new Ir(fe(o), b);
      !C.leftButton && !C.middleButton || p(C);
    })), e.actionHandler.disposables.add(U(o, "keydown", (b) => {
      const C = new Mt(b);
      !C.equals(
        10
        /* KeyCode.Space */
      ) && !C.equals(
        3
        /* KeyCode.Enter */
      ) || p(C);
    }));
  }
  s.supportHtml || (l.html = ({ text: p }) => e.sanitizerOptions?.replaceWithPlaintext ? Ip(p) : (s.isTrusted ? p.match(/^(<span[^>]+>)|(<\/\s*span>)$/) : void 0) ? p : ""), t.renderer = l;
  let h = s.value ?? "";
  h.length > 1e5 && (h = `${h.substr(0, 1e5)}…`), s.supportThemeIcons && (h = hJ(h));
  let u;
  if (e.fillInIncompleteTokens) {
    const p = {
      ...vJ,
      ...t
    }, A = X0(h, p), _ = PJ(A);
    u = SJ(_, p);
  } else
    u = y3(h, { ...t, async: !1 });
  s.supportThemeIcons && (u = kh(u).map((A) => typeof A == "string" ? A : A.outerHTML).join(""));
  const m = new DOMParser().parseFromString(RL({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, u), "text/html");
  if (m.body.querySelectorAll("img, audio, video, source").forEach((p) => {
    const A = p.getAttribute("src");
    if (A) {
      let _ = A;
      try {
        s.baseUri && (_ = Dy(_e.from(s.baseUri), _));
      } catch {
      }
      if (p.setAttribute("src", a(_, !0)), e.remoteImageIsAllowed) {
        const b = _e.parse(_);
        b.scheme !== Ie.file && b.scheme !== Ie.data && !e.remoteImageIsAllowed(b) && p.replaceWith(de("", void 0, p.outerHTML));
      }
    }
  }), m.body.querySelectorAll("a").forEach((p) => {
    const A = p.getAttribute("href");
    if (p.setAttribute("href", ""), !A || /^data:|javascript:/i.test(A) || /^command:/i.test(A) && !s.isTrusted || /^command:(\/\/\/)?_workbench\.downloadResource/i.test(A))
      p.replaceWith(...p.childNodes);
    else {
      let _ = a(A, !1);
      s.baseUri && (_ = Dy(_e.from(s.baseUri), A)), p.dataset.href = _;
    }
  }), o.innerHTML = RL({ isTrusted: s.isTrusted, ...e.sanitizerOptions }, m.body.innerHTML), c.length > 0)
    Promise.all(c).then((p) => {
      if (n)
        return;
      const A = new Map(p), _ = o.querySelectorAll("div[data-code]");
      for (const b of _) {
        const C = A.get(b.dataset.code ?? "");
        C && Rn(b, C);
      }
      e.asyncRenderCallback?.();
    });
  else if (d.length > 0) {
    const p = new Map(d), A = o.querySelectorAll("div[data-code]");
    for (const _ of A) {
      const b = p.get(_.dataset.code ?? "");
      b && Rn(_, b);
    }
  }
  if (e.asyncRenderCallback)
    for (const p of o.getElementsByTagName("img")) {
      const A = i.add(U(p, "load", () => {
        A.dispose(), e.asyncRenderCallback();
      }));
    }
  return {
    element: o,
    dispose: () => {
      n = !0, i.dispose();
    }
  };
}
function V2(s) {
  if (!s)
    return "";
  const e = s.split(/[\s+|:|,|\{|\?]/, 1);
  return e.length ? e[0] : s;
}
function Dy(s, e) {
  return /^\w[\w\d+.-]*:/.test(e) ? e : s.path.endsWith("/") ? P2(s, e).toString() : P2($0(s), e).toString();
}
const EJ = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"];
function RL(s, e) {
  const { config: t, allowedSchemes: i } = kJ(s), n = new X();
  n.add(z2("uponSanitizeAttribute", (o, r) => {
    if (r.attrName === "style" || r.attrName === "class") {
      if (o.tagName === "SPAN") {
        if (r.attrName === "style") {
          r.keepAttr = /^(color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(background-color\:(#[0-9a-fA-F]+|var\(--vscode(-[a-zA-Z]+)+\));)?(border-radius:[0-9]+px;)?$/.test(r.attrValue);
          return;
        } else if (r.attrName === "class") {
          r.keepAttr = /^codicon codicon-[a-z\-]+( codicon-modifier-[a-z\-]+)?$/.test(r.attrValue);
          return;
        }
      }
      r.keepAttr = !1;
      return;
    } else if (o.tagName === "INPUT" && o.attributes.getNamedItem("type")?.value === "checkbox") {
      if (r.attrName === "type" && r.attrValue === "checkbox" || r.attrName === "disabled" || r.attrName === "checked") {
        r.keepAttr = !0;
        return;
      }
      r.keepAttr = !1;
    }
  })), n.add(z2("uponSanitizeElement", (o, r) => {
    if (r.tagName === "input" && (o.attributes.getNamedItem("type")?.value === "checkbox" ? o.setAttribute("disabled", "") : s.replaceWithPlaintext || o.remove()), s.replaceWithPlaintext && !r.allowedTags[r.tagName] && r.tagName !== "body" && o.parentElement) {
      let a, l;
      if (r.tagName === "#comment")
        a = `<!--${o.textContent}-->`;
      else {
        const u = EJ.includes(r.tagName), g = o.attributes.length ? " " + Array.from(o.attributes).map((m) => `${m.name}="${m.value}"`).join(" ") : "";
        a = `<${r.tagName}${g}>`, u || (l = `</${r.tagName}>`);
      }
      const c = document.createDocumentFragment(), d = o.parentElement.ownerDocument.createTextNode(a);
      c.appendChild(d);
      const h = l ? o.parentElement.ownerDocument.createTextNode(l) : void 0;
      for (; o.firstChild; )
        c.appendChild(o.firstChild);
      h && c.appendChild(h), o.nodeType === Node.COMMENT_NODE ? o.parentElement.insertBefore(c, o) : o.parentElement.replaceChild(c, o);
    }
  })), n.add(Z6(i));
  try {
    return RH(e, { ...t, RETURN_TRUSTED_TYPE: !0 });
  } finally {
    n.dispose();
  }
}
const LJ = [
  "align",
  "autoplay",
  "alt",
  "checked",
  "class",
  "colspan",
  "controls",
  "data-code",
  "data-href",
  "disabled",
  "draggable",
  "height",
  "href",
  "loop",
  "muted",
  "playsinline",
  "poster",
  "rowspan",
  "src",
  "style",
  "target",
  "title",
  "type",
  "width",
  "start"
];
function kJ(s) {
  const e = [
    Ie.http,
    Ie.https,
    Ie.mailto,
    Ie.data,
    Ie.file,
    Ie.vscodeFileResource,
    Ie.vscodeRemote,
    Ie.vscodeRemoteResource
  ];
  return s.isTrusted && e.push(Ie.command), {
    config: {
      // allowedTags should included everything that markdown renders to.
      // Since we have our own sanitize function for marked, it's possible we missed some tag so let dompurify make sure.
      // HTML tags that can result from markdown are from reading https://spec.commonmark.org/0.29/
      // HTML table tags that can result from markdown are from https://github.github.com/gfm/#tables-extension-
      ALLOWED_TAGS: s.allowedTags ?? [...eU],
      ALLOWED_ATTR: LJ,
      ALLOW_UNKNOWN_PROTOCOLS: !0
    },
    allowedSchemes: e
  };
}
function DJ(s) {
  return typeof s == "string" ? s : IJ(s);
}
function IJ(s, e) {
  let t = s.value ?? "";
  t.length > 1e5 && (t = `${t.substr(0, 1e5)}…`);
  const i = y3(t, { async: !1, renderer: TJ.value }).replace(/&(#\d+|[a-zA-Z]+);/g, (n) => MJ.get(n) ?? n);
  return RL({ isTrusted: !1 }, i).toString();
}
const MJ = /* @__PURE__ */ new Map([
  ["&quot;", '"'],
  ["&nbsp;", " "],
  ["&amp;", "&"],
  ["&#39;", "'"],
  ["&lt;", "<"],
  ["&gt;", ">"]
]);
function NJ() {
  const s = new S3();
  return s.code = ({ text: e }) => e, s.blockquote = ({ text: e }) => e + `
`, s.html = (e) => "", s.heading = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.hr = () => "", s.list = function({ items: e }) {
    return e.map((t) => this.listitem(t)).join(`
`) + `
`;
  }, s.listitem = ({ text: e }) => e + `
`, s.paragraph = function({ tokens: e }) {
    return this.parser.parseInline(e) + `
`;
  }, s.table = function({ header: e, rows: t }) {
    return e.map((i) => this.tablecell(i)).join(" ") + `
` + t.map((i) => i.map((n) => this.tablecell(n)).join(" ")).join(`
`) + `
`;
  }, s.tablerow = ({ text: e }) => e, s.tablecell = function({ tokens: e }) {
    return this.parser.parseInline(e);
  }, s.strong = ({ text: e }) => e, s.em = ({ text: e }) => e, s.codespan = ({ text: e }) => e, s.br = (e) => `
`, s.del = ({ text: e }) => e, s.image = (e) => "", s.text = ({ text: e }) => e, s.link = ({ text: e }) => e, s;
}
const TJ = new Br((s) => NJ());
function DC(s) {
  let e = "";
  return s.forEach((t) => {
    e += t.raw;
  }), e;
}
function x3(s) {
  if (s.tokens)
    for (let e = s.tokens.length - 1; e >= 0; e--) {
      const t = s.tokens[e];
      if (t.type === "text") {
        const i = t.raw.split(`
`), n = i[i.length - 1];
        if (n.includes("`"))
          return WJ(s);
        if (n.includes("**"))
          return jJ(s);
        if (n.match(/\*\w/))
          return VJ(s);
        if (n.match(/(^|\s)__\w/))
          return YJ(s);
        if (n.match(/(^|\s)_\w/))
          return zJ(s);
        if (
          // Text with start of link target
          BJ(n) || // This token doesn't have the link text, eg if it contains other markdown constructs that are in other subtokens.
          // But some preceding token does have an unbalanced [ at least
          RJ(n) && s.tokens.slice(0, e).some((o) => o.type === "text" && o.raw.match(/\[[^\]]*$/))
        ) {
          const o = s.tokens.slice(e + 1);
          return (
            // If the link was parsed as a link, then look for a link token and a text token with a quote
            o[0]?.type === "link" && o[1]?.type === "text" && o[1].raw.match(/^ *"[^"]*$/) || // And if the link was not parsed as a link (eg command link), just look for a single quote in this token
            n.match(/^[^"]* +"[^"]*$/) ? QJ(s) : UJ(s)
          );
        } else if (n.match(/(^|\s)\[\w*/))
          return GJ(s);
      }
    }
}
function BJ(s) {
  return !!s.match(/(^|\s)\[.*\]\(\w*/);
}
function RJ(s) {
  return !!s.match(/^[^\[]*\]\([^\)]*$/);
}
function FJ(s) {
  const e = s.items[s.items.length - 1], t = e.tokens ? e.tokens[e.tokens.length - 1] : void 0;
  let i;
  if (t?.type === "text" && !("inRawBlock" in e) && (i = x3(t)), !i || i.type !== "paragraph")
    return;
  const n = DC(s.items.slice(0, -1)), o = e.raw.match(/^(\s*(-|\d+\.|\*) +)/)?.[0];
  if (!o)
    return;
  const r = o + DC(e.tokens.slice(0, -1)) + i.raw, a = X0(n + r)[0];
  if (a.type === "list")
    return a;
}
const OJ = 3;
function PJ(s) {
  for (let e = 0; e < OJ; e++) {
    const t = HJ(s);
    if (t)
      s = t;
    else
      break;
  }
  return s;
}
function HJ(s) {
  let e, t;
  for (e = 0; e < s.length; e++) {
    const i = s[e];
    if (i.type === "paragraph" && i.raw.match(/(\n|^)\|/)) {
      t = KJ(s.slice(e));
      break;
    }
    if (e === s.length - 1 && i.type === "list") {
      const n = FJ(i);
      if (n) {
        t = [n];
        break;
      }
    }
    if (e === s.length - 1 && i.type === "paragraph") {
      const n = x3(i);
      if (n) {
        t = [n];
        break;
      }
    }
  }
  if (t) {
    const i = [
      ...s.slice(0, e),
      ...t
    ];
    return i.links = s.links, i;
  }
  return null;
}
function WJ(s) {
  return Cd(s, "`");
}
function VJ(s) {
  return Cd(s, "*");
}
function zJ(s) {
  return Cd(s, "_");
}
function UJ(s) {
  return Cd(s, ")");
}
function QJ(s) {
  return Cd(s, '")');
}
function GJ(s) {
  return Cd(s, "](https://microsoft.com)");
}
function jJ(s) {
  return Cd(s, "**");
}
function YJ(s) {
  return Cd(s, "__");
}
function Cd(s, e) {
  const t = DC(Array.isArray(s) ? s : [s]);
  return X0(t + e)[0];
}
function KJ(s) {
  const e = DC(s), t = e.split(`
`);
  let i, n = !1;
  for (let o = 0; o < t.length; o++) {
    const r = t[o].trim();
    if (typeof i > "u" && r.match(/^\s*\|/)) {
      const a = r.match(/(\|[^\|]+)(?=\||$)/g);
      a && (i = a.length);
    } else if (typeof i == "number")
      if (r.match(/^\s*\|/)) {
        if (o !== t.length - 1)
          return;
        n = !0;
      } else
        return;
  }
  if (typeof i == "number" && i > 0) {
    const o = n ? t.slice(0, -1).join(`
`) : e, r = !!o.match(/\|\s*$/), a = o + (r ? "" : "|") + `
|${" --- |".repeat(i)}`;
    return X0(a);
  }
}
function z2(s, e) {
  return FH(s, e), we(() => OH(s));
}
const rl = class rl {
  static createEmpty(e, t) {
    const i = rl.defaultTokenMetadata, n = new Uint32Array(2);
    return n[0] = e.length, n[1] = i, new rl(n, e, t);
  }
  static createFromTextAndMetadata(e, t) {
    let i = 0, n = "";
    const o = new Array();
    for (const { text: r, metadata: a } of e)
      o.push(i + r.length, a), i += r.length, n += r;
    return new rl(new Uint32Array(o), n, t);
  }
  constructor(e, t, i) {
    this._lineTokensBrand = void 0, this._tokens = e, this._tokensCount = this._tokens.length >>> 1, this._text = t, this.languageIdCodec = i;
  }
  equals(e) {
    return e instanceof rl ? this.slicedEquals(e, 0, this._tokensCount) : !1;
  }
  slicedEquals(e, t, i) {
    if (this._text !== e._text || this._tokensCount !== e._tokensCount)
      return !1;
    const n = t << 1, o = n + (i << 1);
    for (let r = n; r < o; r++)
      if (this._tokens[r] !== e._tokens[r])
        return !1;
    return !0;
  }
  getLineContent() {
    return this._text;
  }
  getCount() {
    return this._tokensCount;
  }
  getStartOffset(e) {
    return e > 0 ? this._tokens[e - 1 << 1] : 0;
  }
  getMetadata(e) {
    return this._tokens[(e << 1) + 1];
  }
  getLanguageId(e) {
    const t = this._tokens[(e << 1) + 1], i = xr.getLanguageId(t);
    return this.languageIdCodec.decodeLanguageId(i);
  }
  getStandardTokenType(e) {
    const t = this._tokens[(e << 1) + 1];
    return xr.getTokenType(t);
  }
  getForeground(e) {
    const t = this._tokens[(e << 1) + 1];
    return xr.getForeground(t);
  }
  getClassName(e) {
    const t = this._tokens[(e << 1) + 1];
    return xr.getClassNameFromMetadata(t);
  }
  getInlineStyle(e, t) {
    const i = this._tokens[(e << 1) + 1];
    return xr.getInlineStyleFromMetadata(i, t);
  }
  getPresentation(e) {
    const t = this._tokens[(e << 1) + 1];
    return xr.getPresentationFromMetadata(t);
  }
  getEndOffset(e) {
    return this._tokens[e << 1];
  }
  /**
   * Find the token containing offset `offset`.
   * @param offset The search offset
   * @return The index of the token containing the offset.
   */
  findTokenIndexAtOffset(e) {
    return rl.findIndexInTokensArray(this._tokens, e);
  }
  inflate() {
    return this;
  }
  sliceAndInflate(e, t, i) {
    return new NN(this, e, t, i);
  }
  static convertToEndOffset(e, t) {
    const n = (e.length >>> 1) - 1;
    for (let o = 0; o < n; o++)
      e[o << 1] = e[o + 1 << 1];
    e[n << 1] = t;
  }
  static findIndexInTokensArray(e, t) {
    if (e.length <= 2)
      return 0;
    let i = 0, n = (e.length >>> 1) - 1;
    for (; i < n; ) {
      const o = i + Math.floor((n - i) / 2), r = e[o << 1];
      if (r === t)
        return o + 1;
      r < t ? i = o + 1 : r > t && (n = o);
    }
    return i;
  }
  /**
   * @pure
   * @param insertTokens Must be sorted by offset.
  */
  withInserted(e) {
    if (e.length === 0)
      return this;
    let t = 0, i = 0, n = "";
    const o = new Array();
    let r = 0;
    for (; ; ) {
      const a = t < this._tokensCount ? this._tokens[t << 1] : -1, l = i < e.length ? e[i] : null;
      if (a !== -1 && (l === null || a <= l.offset)) {
        n += this._text.substring(r, a);
        const c = this._tokens[(t << 1) + 1];
        o.push(n.length, c), t++, r = a;
      } else if (l) {
        if (l.offset > r) {
          n += this._text.substring(r, l.offset);
          const c = this._tokens[(t << 1) + 1];
          o.push(n.length, c), r = l.offset;
        }
        n += l.text, o.push(n.length, l.tokenMetadata), i++;
      } else
        break;
    }
    return new rl(new Uint32Array(o), n, this.languageIdCodec);
  }
  getTokenText(e) {
    const t = this.getStartOffset(e), i = this.getEndOffset(e);
    return this._text.substring(t, i);
  }
  forEach(e) {
    const t = this.getCount();
    for (let i = 0; i < t; i++)
      e(i);
  }
};
rl.defaultTokenMetadata = (32768 | 2 << 24) >>> 0;
let Gi = rl;
class NN {
  constructor(e, t, i, n) {
    this._source = e, this._startOffset = t, this._endOffset = i, this._deltaOffset = n, this._firstTokenIndex = e.findTokenIndexAtOffset(t), this.languageIdCodec = e.languageIdCodec, this._tokensCount = 0;
    for (let o = this._firstTokenIndex, r = e.getCount(); o < r && !(e.getStartOffset(o) >= i); o++)
      this._tokensCount++;
  }
  getMetadata(e) {
    return this._source.getMetadata(this._firstTokenIndex + e);
  }
  getLanguageId(e) {
    return this._source.getLanguageId(this._firstTokenIndex + e);
  }
  getLineContent() {
    return this._source.getLineContent().substring(this._startOffset, this._endOffset);
  }
  equals(e) {
    return e instanceof NN ? this._startOffset === e._startOffset && this._endOffset === e._endOffset && this._deltaOffset === e._deltaOffset && this._source.slicedEquals(e._source, this._firstTokenIndex, this._tokensCount) : !1;
  }
  getCount() {
    return this._tokensCount;
  }
  getStandardTokenType(e) {
    return this._source.getStandardTokenType(this._firstTokenIndex + e);
  }
  getForeground(e) {
    return this._source.getForeground(this._firstTokenIndex + e);
  }
  getEndOffset(e) {
    const t = this._source.getEndOffset(this._firstTokenIndex + e);
    return Math.min(this._endOffset, t) - this._startOffset + this._deltaOffset;
  }
  getClassName(e) {
    return this._source.getClassName(this._firstTokenIndex + e);
  }
  getInlineStyle(e, t) {
    return this._source.getInlineStyle(this._firstTokenIndex + e, t);
  }
  getPresentation(e) {
    return this._source.getPresentation(this._firstTokenIndex + e);
  }
  findTokenIndexAtOffset(e) {
    return this._source.findTokenIndexAtOffset(e + this._startOffset - this._deltaOffset) - this._firstTokenIndex;
  }
  getTokenText(e) {
    const t = this._firstTokenIndex + e, i = this._source.getStartOffset(t), n = this._source.getEndOffset(t);
    let o = this._source.getTokenText(t);
    return i < this._startOffset && (o = o.substring(this._startOffset - i)), n > this._endOffset && (o = o.substring(0, o.length - (n - this._endOffset))), o;
  }
  forEach(e) {
    for (let t = 0; t < this.getCount(); t++)
      e(t);
  }
}
const jA = new class {
  clone() {
    return this;
  }
  equals(s) {
    return this === s;
  }
}();
function E3(s, e) {
  return new BM([new xA(0, "", s)], e);
}
function TN(s, e) {
  const t = new Uint32Array(2);
  return t[0] = 0, t[1] = (s << 0 | 0 | 0 | 32768 | 2 << 24) >>> 0, new A0(t, e === null ? jA : e);
}
const U2 = {
  getInitialState: () => jA,
  tokenizeEncoded: (s, e, t) => TN(0, t)
};
async function JJ(s, e, t) {
  if (!t)
    return Q2(e, s.languageIdCodec, U2);
  const i = await ci.getOrCreate(t);
  return Q2(e, s.languageIdCodec, i || U2);
}
function qJ(s, e, t, i, n, o, r) {
  let a = "<div>", l = i, c = 0, d = !0;
  for (let h = 0, u = e.getCount(); h < u; h++) {
    const g = e.getEndOffset(h);
    if (g <= i)
      continue;
    let m = "";
    for (; l < g && l < n; l++) {
      const p = s.charCodeAt(l);
      switch (p) {
        case 9: {
          let A = o - (l + c) % o;
          for (c += A - 1; A > 0; )
            r && d ? (m += "&#160;", d = !1) : (m += " ", d = !0), A--;
          break;
        }
        case 60:
          m += "&lt;", d = !1;
          break;
        case 62:
          m += "&gt;", d = !1;
          break;
        case 38:
          m += "&amp;", d = !1;
          break;
        case 0:
          m += "&#00;", d = !1;
          break;
        case 65279:
        case 8232:
        case 8233:
        case 133:
          m += "�", d = !1;
          break;
        case 13:
          m += "&#8203", d = !1;
          break;
        case 32:
          r && d ? (m += "&#160;", d = !1) : (m += " ", d = !0);
          break;
        default:
          m += String.fromCharCode(p), d = !1;
      }
    }
    if (a += `<span style="${e.getInlineStyle(h, t)}">${m}</span>`, g > n || l >= n)
      break;
  }
  return a += "</div>", a;
}
function Q2(s, e, t) {
  let i = '<div class="monaco-tokenized-source">';
  const n = bd(s);
  let o = t.getInitialState();
  for (let r = 0, a = n.length; r < a; r++) {
    const l = n[r];
    r > 0 && (i += "<br/>");
    const c = t.tokenizeEncoded(l, !0, o);
    Gi.convertToEndOffset(c.tokens, l.length);
    const h = new Gi(c.tokens, l, e).inflate();
    let u = 0;
    for (let g = 0, m = h.getCount(); g < m; g++) {
      const p = h.getClassName(g), A = h.getEndOffset(g);
      i += `<span class="${p}">${Ip(l.substring(u, A))}</span>`, u = A;
    }
    o = c.endState;
  }
  return i += "</div>", i;
}
var $J = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, G2 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, FL, Rh;
let Cu = (Rh = class {
  constructor(e, t, i) {
    this._options = e, this._languageService = t, this._openerService = i, this._onDidRenderAsync = new B(), this.onDidRenderAsync = this._onDidRenderAsync.event;
  }
  dispose() {
    this._onDidRenderAsync.dispose();
  }
  render(e, t, i) {
    if (!e)
      return { element: document.createElement("span"), dispose: () => {
      } };
    const n = new X(), o = n.add(Z0(e, { ...this._getRenderOptions(e, n), ...t }, i));
    return o.element.classList.add("rendered-markdown"), {
      element: o.element,
      dispose: () => n.dispose()
    };
  }
  _getRenderOptions(e, t) {
    return {
      codeBlockRenderer: async (i, n) => {
        let o;
        i ? o = this._languageService.getLanguageIdByLanguageName(i) : this._options.editor && (o = this._options.editor.getModel()?.getLanguageId()), o || (o = Js);
        const r = await JJ(this._languageService, n, o), a = document.createElement("span");
        if (a.innerHTML = FL._ttpTokenizer?.createHTML(r) ?? r, this._options.editor) {
          const l = this._options.editor.getOption(
            50
            /* EditorOption.fontInfo */
          );
          cn(a, l);
        } else this._options.codeBlockFontFamily && (a.style.fontFamily = this._options.codeBlockFontFamily);
        return this._options.codeBlockFontSize !== void 0 && (a.style.fontSize = this._options.codeBlockFontSize), a;
      },
      asyncRenderCallback: () => this._onDidRenderAsync.fire(),
      actionHandler: {
        callback: (i) => BN(this._openerService, i, e.isTrusted),
        disposables: t
      }
    };
  }
}, FL = Rh, Rh._ttpTokenizer = Hu("tokenizeToString", {
  createHTML(e) {
    return e;
  }
}), Rh);
Cu = FL = $J([
  G2(1, si),
  G2(2, lr)
], Cu);
async function BN(s, e, t) {
  try {
    return await s.open(e, {
      fromUserGesture: !0,
      allowContributedOpeners: !0,
      allowCommands: XJ(t)
    });
  } catch (i) {
    return Pe(i), !1;
  }
}
function XJ(s) {
  return s === !0 ? !0 : s && Array.isArray(s.enabledCommands) ? s.enabledCommands : !1;
}
const Lo = We("accessibilityService"), O_ = new le("accessibilityModeEnabled", !1), j2 = 2e4;
let th, xw, OL, Ew, PL;
function ZJ(s) {
  th = document.createElement("div"), th.className = "monaco-aria-container";
  const e = () => {
    const i = document.createElement("div");
    return i.className = "monaco-alert", i.setAttribute("role", "alert"), i.setAttribute("aria-atomic", "true"), th.appendChild(i), i;
  };
  xw = e(), OL = e();
  const t = () => {
    const i = document.createElement("div");
    return i.className = "monaco-status", i.setAttribute("aria-live", "polite"), i.setAttribute("aria-atomic", "true"), th.appendChild(i), i;
  };
  Ew = t(), PL = t(), s.appendChild(th);
}
function Ia(s) {
  th && (xw.textContent !== s ? (Bn(OL), IC(xw, s)) : (Bn(xw), IC(OL, s)));
}
function vu(s) {
  th && (Ew.textContent !== s ? (Bn(PL), IC(Ew, s)) : (Bn(Ew), IC(PL, s)));
}
function IC(s, e) {
  Bn(s), e.length > j2 && (e = e.substr(0, j2)), s.textContent = e, s.style.visibility = "hidden", s.style.visibility = "visible";
}
var eq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qm = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Gr = de;
let HL = class extends to {
  get _targetWindow() {
    return fe(this._target.targetElements[0]);
  }
  get _targetDocumentElement() {
    return fe(this._target.targetElements[0]).document.documentElement;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  get isMouseIn() {
    return this._lockMouseTracker.isMouseIn;
  }
  get domNode() {
    return this._hover.containerDomNode;
  }
  get onDispose() {
    return this._onDispose.event;
  }
  get onRequestLayout() {
    return this._onRequestLayout.event;
  }
  get anchor() {
    return this._hoverPosition === 2 ? 0 : 1;
  }
  get x() {
    return this._x;
  }
  get y() {
    return this._y;
  }
  /**
   * Whether the hover is "locked" by holding the alt/option key. When locked, the hover will not
   * hide and can be hovered regardless of whether the `hideOnHover` hover option is set.
   */
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked !== e && (this._isLocked = e, this._hoverContainer.classList.toggle("locked", this._isLocked));
  }
  constructor(e, t, i, n, o, r) {
    super(), this._keybindingService = t, this._configurationService = i, this._openerService = n, this._instantiationService = o, this._accessibilityService = r, this._messageListeners = new X(), this._isDisposed = !1, this._forcePosition = !1, this._x = 0, this._y = 0, this._isLocked = !1, this._enableFocusTraps = !1, this._addedFocusTrap = !1, this._onDispose = this._register(new B()), this._onRequestLayout = this._register(new B()), this._linkHandler = e.linkHandler || ((u) => BN(this._openerService, u, Sa(e.content) ? e.content.isTrusted : void 0)), this._target = "targetElements" in e.target ? e.target : new tq(e.target), this._hoverPointer = e.appearance?.showPointer ? Gr("div.workbench-hover-pointer") : void 0, this._hover = this._register(new yN()), this._hover.containerDomNode.classList.add("workbench-hover", "fadeIn"), e.appearance?.compact && this._hover.containerDomNode.classList.add("workbench-hover", "compact"), e.appearance?.skipFadeInAnimation && this._hover.containerDomNode.classList.add("skip-fade-in"), e.additionalClasses && this._hover.containerDomNode.classList.add(...e.additionalClasses), e.position?.forcePosition && (this._forcePosition = !0), e.trapFocus && (this._enableFocusTraps = !0), this._hoverPosition = e.position?.hoverPosition ?? 3, this.onmousedown(this._hover.containerDomNode, (u) => u.stopPropagation()), this.onkeydown(this._hover.containerDomNode, (u) => {
      u.equals(
        9
        /* KeyCode.Escape */
      ) && this.dispose();
    }), this._register(U(this._targetWindow, "blur", () => this.dispose()));
    const a = Gr("div.hover-row.markdown-hover"), l = Gr("div.hover-contents");
    if (typeof e.content == "string")
      l.textContent = e.content, l.style.whiteSpace = "pre-wrap";
    else if (Bi(e.content))
      l.appendChild(e.content), l.classList.add("html-hover-contents");
    else {
      const u = e.content, g = this._instantiationService.createInstance(Cu, { codeBlockFontFamily: this._configurationService.getValue("editor").fontFamily || Zn.fontFamily }), { element: m } = g.render(u, {
        actionHandler: {
          callback: (p) => this._linkHandler(p),
          disposables: this._messageListeners
        },
        asyncRenderCallback: () => {
          l.classList.add("code-hover-contents"), this.layout(), this._onRequestLayout.fire();
        }
      });
      l.appendChild(m);
    }
    if (a.appendChild(l), this._hover.contentsDomNode.appendChild(a), e.actions && e.actions.length > 0) {
      const u = Gr("div.hover-row.status-bar"), g = Gr("div.actions");
      e.actions.forEach((m) => {
        const p = this._keybindingService.lookupKeybinding(m.commandId), A = p ? p.getLabel() : null;
        K0.render(g, {
          label: m.label,
          commandId: m.commandId,
          run: (_) => {
            m.run(_), this.dispose();
          },
          iconClass: m.iconClass
        }, A);
      }), u.appendChild(g), this._hover.containerDomNode.appendChild(u);
    }
    this._hoverContainer = Gr("div.workbench-hover-container"), this._hoverPointer && this._hoverContainer.appendChild(this._hoverPointer), this._hoverContainer.appendChild(this._hover.containerDomNode);
    let c;
    if (e.actions && e.actions.length > 0 ? c = !1 : e.persistence?.hideOnHover === void 0 ? c = typeof e.content == "string" || Sa(e.content) && !e.content.value.includes("](") && !e.content.value.includes("</a>") : c = e.persistence.hideOnHover, e.appearance?.showHoverHint) {
      const u = Gr("div.hover-row.status-bar"), g = Gr("div.info");
      g.textContent = f("hoverhint", "Hold {0} key to mouse over", ze ? "Option" : "Alt"), u.appendChild(g), this._hover.containerDomNode.appendChild(u);
    }
    const d = [...this._target.targetElements];
    c || d.push(this._hoverContainer);
    const h = this._register(new Y2(d));
    if (this._register(h.onMouseOut(() => {
      this._isLocked || this.dispose();
    })), c) {
      const u = [...this._target.targetElements, this._hoverContainer];
      this._lockMouseTracker = this._register(new Y2(u)), this._register(this._lockMouseTracker.onMouseOut(() => {
        this._isLocked || this.dispose();
      }));
    } else
      this._lockMouseTracker = h;
  }
  addFocusTrap() {
    if (!this._enableFocusTraps || this._addedFocusTrap)
      return;
    this._addedFocusTrap = !0;
    const e = this._hover.containerDomNode, t = this.findLastFocusableChild(this._hover.containerDomNode);
    if (t) {
      const i = $M(this._hoverContainer, Gr("div")), n = K(this._hoverContainer, Gr("div"));
      i.tabIndex = 0, n.tabIndex = 0, this._register(U(n, "focus", (o) => {
        e.focus(), o.preventDefault();
      })), this._register(U(i, "focus", (o) => {
        t.focus(), o.preventDefault();
      }));
    }
  }
  findLastFocusableChild(e) {
    if (e.hasChildNodes())
      for (let t = 0; t < e.childNodes.length; t++) {
        const i = e.childNodes.item(e.childNodes.length - t - 1);
        if (i.nodeType === i.ELEMENT_NODE) {
          const o = i;
          if (typeof o.tabIndex == "number" && o.tabIndex >= 0)
            return o;
        }
        const n = this.findLastFocusableChild(i);
        if (n)
          return n;
      }
  }
  render(e) {
    e.appendChild(this._hoverContainer);
    const i = this._hoverContainer.contains(this._hoverContainer.ownerDocument.activeElement) && d3(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), this._keybindingService.lookupKeybinding("editor.action.accessibleView")?.getAriaLabel());
    i && vu(i), this.layout(), this.addFocusTrap();
  }
  layout() {
    this._hover.containerDomNode.classList.remove("right-aligned"), this._hover.contentsDomNode.style.maxHeight = "";
    const e = (d) => {
      const h = zH(d), u = d.getBoundingClientRect();
      return {
        top: u.top * h,
        bottom: u.bottom * h,
        right: u.right * h,
        left: u.left * h
      };
    }, t = this._target.targetElements.map((d) => e(d)), { top: i, right: n, bottom: o, left: r } = t[0], a = n - r, l = o - i, c = {
      top: i,
      right: n,
      bottom: o,
      left: r,
      width: a,
      height: l,
      center: {
        x: r + a / 2,
        y: i + l / 2
      }
    };
    if (this.adjustHorizontalHoverPosition(c), this.adjustVerticalHoverPosition(c), this.adjustHoverMaxHeight(c), this._hoverContainer.style.padding = "", this._hoverContainer.style.margin = "", this._hoverPointer) {
      switch (this._hoverPosition) {
        case 1:
          c.left += 3, c.right += 3, this._hoverContainer.style.paddingLeft = "3px", this._hoverContainer.style.marginLeft = "-3px";
          break;
        case 0:
          c.left -= 3, c.right -= 3, this._hoverContainer.style.paddingRight = "3px", this._hoverContainer.style.marginRight = "-3px";
          break;
        case 2:
          c.top += 3, c.bottom += 3, this._hoverContainer.style.paddingTop = "3px", this._hoverContainer.style.marginTop = "-3px";
          break;
        case 3:
          c.top -= 3, c.bottom -= 3, this._hoverContainer.style.paddingBottom = "3px", this._hoverContainer.style.marginBottom = "-3px";
          break;
      }
      c.center.x = c.left + a / 2, c.center.y = c.top + l / 2;
    }
    this.computeXCordinate(c), this.computeYCordinate(c), this._hoverPointer && (this._hoverPointer.classList.remove("top"), this._hoverPointer.classList.remove("left"), this._hoverPointer.classList.remove("right"), this._hoverPointer.classList.remove("bottom"), this.setHoverPointerPosition(c)), this._hover.onContentsChanged();
  }
  computeXCordinate(e) {
    const t = this._hover.containerDomNode.clientWidth + 2;
    this._target.x !== void 0 ? this._x = this._target.x : this._hoverPosition === 1 ? this._x = e.right : this._hoverPosition === 0 ? this._x = e.left - t : (this._hoverPointer ? this._x = e.center.x - this._hover.containerDomNode.clientWidth / 2 : this._x = e.left, this._x + t >= this._targetDocumentElement.clientWidth && (this._hover.containerDomNode.classList.add("right-aligned"), this._x = Math.max(this._targetDocumentElement.clientWidth - t - 2, this._targetDocumentElement.clientLeft))), this._x < this._targetDocumentElement.clientLeft && (this._x = e.left + 2);
  }
  computeYCordinate(e) {
    this._target.y !== void 0 ? this._y = this._target.y : this._hoverPosition === 3 ? this._y = e.top : this._hoverPosition === 2 ? this._y = e.bottom - 2 : this._hoverPointer ? this._y = e.center.y + this._hover.containerDomNode.clientHeight / 2 : this._y = e.bottom, this._y > this._targetWindow.innerHeight && (this._y = e.bottom);
  }
  adjustHorizontalHoverPosition(e) {
    if (this._target.x !== void 0)
      return;
    const t = this._hoverPointer ? 3 : 0;
    if (this._forcePosition) {
      const i = t + 2;
      this._hoverPosition === 1 ? this._hover.containerDomNode.style.maxWidth = `${this._targetDocumentElement.clientWidth - e.right - i}px` : this._hoverPosition === 0 && (this._hover.containerDomNode.style.maxWidth = `${e.left - i}px`);
      return;
    }
    this._hoverPosition === 1 ? this._targetDocumentElement.clientWidth - e.right < this._hover.containerDomNode.clientWidth + t && (e.left >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 0 : this._hoverPosition = 2) : this._hoverPosition === 0 && (e.left < this._hover.containerDomNode.clientWidth + t && (this._targetDocumentElement.clientWidth - e.right >= this._hover.containerDomNode.clientWidth + t ? this._hoverPosition = 1 : this._hoverPosition = 2), e.left - this._hover.containerDomNode.clientWidth - t <= this._targetDocumentElement.clientLeft && (this._hoverPosition = 1));
  }
  adjustVerticalHoverPosition(e) {
    if (this._target.y !== void 0 || this._forcePosition)
      return;
    const t = this._hoverPointer ? 3 : 0;
    this._hoverPosition === 3 ? e.top - this._hover.containerDomNode.clientHeight - t < 0 && (this._hoverPosition = 2) : this._hoverPosition === 2 && e.bottom + this._hover.containerDomNode.clientHeight + t > this._targetWindow.innerHeight && (this._hoverPosition = 3);
  }
  adjustHoverMaxHeight(e) {
    let t = this._targetWindow.innerHeight / 2;
    if (this._forcePosition) {
      const i = (this._hoverPointer ? 3 : 0) + 2;
      this._hoverPosition === 3 ? t = Math.min(t, e.top - i) : this._hoverPosition === 2 && (t = Math.min(t, this._targetWindow.innerHeight - e.bottom - i));
    }
    if (this._hover.containerDomNode.style.maxHeight = `${t}px`, this._hover.contentsDomNode.clientHeight < this._hover.contentsDomNode.scrollHeight) {
      const i = `${this._hover.scrollbar.options.verticalScrollbarSize}px`;
      this._hover.contentsDomNode.style.paddingRight !== i && (this._hover.contentsDomNode.style.paddingRight = i);
    }
  }
  setHoverPointerPosition(e) {
    if (this._hoverPointer)
      switch (this._hoverPosition) {
        case 0:
        case 1: {
          this._hoverPointer.classList.add(this._hoverPosition === 0 ? "right" : "left");
          const t = this._hover.containerDomNode.clientHeight;
          t > e.height ? this._hoverPointer.style.top = `${e.center.y - (this._y - t) - 3}px` : this._hoverPointer.style.top = `${Math.round(t / 2) - 3}px`;
          break;
        }
        case 3:
        case 2: {
          this._hoverPointer.classList.add(this._hoverPosition === 3 ? "bottom" : "top");
          const t = this._hover.containerDomNode.clientWidth;
          let i = Math.round(t / 2) - 3;
          const n = this._x + i;
          (n < e.left || n > e.right) && (i = e.center.x - this._x - 3), this._hoverPointer.style.left = `${i}px`;
          break;
        }
      }
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  dispose() {
    this._isDisposed || (this._onDispose.fire(), this._hoverContainer.remove(), this._messageListeners.dispose(), this._target.dispose(), super.dispose()), this._isDisposed = !0;
  }
};
HL = eq([
  qm(1, bt),
  qm(2, ht),
  qm(3, lr),
  qm(4, ke),
  qm(5, Lo)
], HL);
class Y2 extends to {
  get onMouseOut() {
    return this._onMouseOut.event;
  }
  get isMouseIn() {
    return this._isMouseIn;
  }
  constructor(e) {
    super(), this._elements = e, this._isMouseIn = !0, this._onMouseOut = this._register(new B()), this._elements.forEach((t) => this.onmouseover(t, () => this._onTargetMouseOver(t))), this._elements.forEach((t) => this.onmouseleave(t, () => this._onTargetMouseLeave(t)));
  }
  _onTargetMouseOver(e) {
    this._isMouseIn = !0, this._clearEvaluateMouseStateTimeout(e);
  }
  _onTargetMouseLeave(e) {
    this._isMouseIn = !1, this._evaluateMouseState(e);
  }
  _evaluateMouseState(e) {
    this._clearEvaluateMouseStateTimeout(e), this._mouseTimeout = fe(e).setTimeout(() => this._fireIfMouseOutside(), 0);
  }
  _clearEvaluateMouseStateTimeout(e) {
    this._mouseTimeout && (fe(e).clearTimeout(this._mouseTimeout), this._mouseTimeout = void 0);
  }
  _fireIfMouseOutside() {
    this._isMouseIn || this._onMouseOut.fire();
  }
}
class tq {
  constructor(e) {
    this._element = e, this.targetElements = [this._element];
  }
  dispose() {
  }
}
var on;
(function(s) {
  function e(o, r) {
    if (o.start >= r.end || r.start >= o.end)
      return { start: 0, end: 0 };
    const a = Math.max(o.start, r.start), l = Math.min(o.end, r.end);
    return l - a <= 0 ? { start: 0, end: 0 } : { start: a, end: l };
  }
  s.intersect = e;
  function t(o) {
    return o.end - o.start <= 0;
  }
  s.isEmpty = t;
  function i(o, r) {
    return !t(e(o, r));
  }
  s.intersects = i;
  function n(o, r) {
    const a = [], l = { start: o.start, end: Math.min(r.start, o.end) }, c = { start: Math.max(r.end, o.start), end: o.end };
    return t(l) || a.push(l), t(c) || a.push(c), a;
  }
  s.relativeComplement = n;
})(on || (on = {}));
function iq(s) {
  const e = s;
  return !!e && typeof e.x == "number" && typeof e.y == "number";
}
var Dc;
(function(s) {
  s[s.AVOID = 0] = "AVOID", s[s.ALIGN = 1] = "ALIGN";
})(Dc || (Dc = {}));
function Fg(s, e, t) {
  const i = t.mode === Dc.ALIGN ? t.offset : t.offset + t.size, n = t.mode === Dc.ALIGN ? t.offset + t.size : t.offset;
  return t.position === 0 ? e <= s - i ? i : e <= n ? n - e : Math.max(s - e, 0) : e <= n ? n - e : e <= s - i ? i : 0;
}
const sf = class sf extends V {
  constructor(e, t) {
    super(), this.container = null, this.useFixedPosition = !1, this.useShadowDOM = !1, this.delegate = null, this.toDisposeOnClean = V.None, this.toDisposeOnSetContainer = V.None, this.shadowRoot = null, this.shadowRootHostElement = null, this.view = de(".context-view"), Dn(this.view), this.setContainer(e, t), this._register(we(() => this.setContainer(
      null,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )));
  }
  setContainer(e, t) {
    this.useFixedPosition = t !== 1;
    const i = this.useShadowDOM;
    if (this.useShadowDOM = t === 3, !(e === this.container && i === this.useShadowDOM) && (this.container && (this.toDisposeOnSetContainer.dispose(), this.view.remove(), this.shadowRoot && (this.shadowRoot = null, this.shadowRootHostElement?.remove(), this.shadowRootHostElement = null), this.container = null), e)) {
      if (this.container = e, this.useShadowDOM) {
        this.shadowRootHostElement = de(".shadow-root-host"), this.container.appendChild(this.shadowRootHostElement), this.shadowRoot = this.shadowRootHostElement.attachShadow({ mode: "open" });
        const o = document.createElement("style");
        o.textContent = nq, this.shadowRoot.appendChild(o), this.shadowRoot.appendChild(this.view), this.shadowRoot.appendChild(de("slot"));
      } else
        this.container.appendChild(this.view);
      const n = new X();
      sf.BUBBLE_UP_EVENTS.forEach((o) => {
        n.add(Xt(this.container, o, (r) => {
          this.onDOMEvent(r, !1);
        }));
      }), sf.BUBBLE_DOWN_EVENTS.forEach((o) => {
        n.add(Xt(this.container, o, (r) => {
          this.onDOMEvent(r, !0);
        }, !0));
      }), this.toDisposeOnSetContainer = n;
    }
  }
  show(e) {
    this.isVisible() && this.hide(), Bn(this.view), this.view.className = "context-view monaco-component", this.view.style.top = "0px", this.view.style.left = "0px", this.view.style.zIndex = `${2575 + (e.layer ?? 0)}`, this.view.style.position = this.useFixedPosition ? "fixed" : "absolute", ps(this.view), this.toDisposeOnClean = e.render(this.view) || V.None, this.delegate = e, this.doLayout(), this.delegate.focus?.();
  }
  getViewElement() {
    return this.view;
  }
  layout() {
    if (this.isVisible()) {
      if (this.delegate.canRelayout === !1 && !(Ea && UM.pointerEvents)) {
        this.hide();
        return;
      }
      this.delegate?.layout?.(), this.doLayout();
    }
  }
  doLayout() {
    if (!this.isVisible())
      return;
    const e = this.delegate.getAnchor();
    let t;
    if (Bi(e)) {
      const u = ui(e), g = zH(e);
      t = {
        top: u.top * g,
        left: u.left * g,
        width: u.width * g,
        height: u.height * g
      };
    } else iq(e) ? t = {
      top: e.y,
      left: e.x,
      width: e.width || 1,
      height: e.height || 2
    } : t = {
      top: e.posy,
      left: e.posx,
      // We are about to position the context view where the mouse
      // cursor is. To prevent the view being exactly under the mouse
      // when showing and thus potentially triggering an action within,
      // we treat the mouse location like a small sized block element.
      width: 2,
      height: 2
    };
    const i = Rs(this.view), n = _h(this.view), o = this.delegate.anchorPosition || 0, r = this.delegate.anchorAlignment || 0, a = this.delegate.anchorAxisAlignment || 0;
    let l, c;
    const d = dp();
    if (a === 0) {
      const u = {
        offset: t.top - d.pageYOffset,
        size: t.height,
        position: o === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, g = { offset: t.left, size: t.width, position: r === 0 ? 0 : 1, mode: Dc.ALIGN };
      l = Fg(d.innerHeight, n, u) + d.pageYOffset, on.intersects({ start: l, end: l + n }, { start: u.offset, end: u.offset + u.size }) && (g.mode = Dc.AVOID), c = Fg(d.innerWidth, i, g);
    } else {
      const u = {
        offset: t.left,
        size: t.width,
        position: r === 0 ? 0 : 1
        /* LayoutAnchorPosition.After */
      }, g = { offset: t.top, size: t.height, position: o === 0 ? 0 : 1, mode: Dc.ALIGN };
      c = Fg(d.innerWidth, i, u), on.intersects({ start: c, end: c + i }, { start: u.offset, end: u.offset + u.size }) && (g.mode = Dc.AVOID), l = Fg(d.innerHeight, n, g) + d.pageYOffset;
    }
    this.view.classList.remove("top", "bottom", "left", "right"), this.view.classList.add(o === 0 ? "bottom" : "top"), this.view.classList.add(r === 0 ? "left" : "right"), this.view.classList.toggle("fixed", this.useFixedPosition);
    const h = ui(this.container);
    this.view.style.top = `${l - (this.useFixedPosition ? ui(this.view).top : h.top)}px`, this.view.style.left = `${c - (this.useFixedPosition ? ui(this.view).left : h.left)}px`, this.view.style.width = "initial";
  }
  hide(e) {
    const t = this.delegate;
    this.delegate = null, t?.onHide && t.onHide(e), this.toDisposeOnClean.dispose(), Dn(this.view);
  }
  isVisible() {
    return !!this.delegate;
  }
  onDOMEvent(e, t) {
    this.delegate && (this.delegate.onDOMEvent ? this.delegate.onDOMEvent(e, fe(e).document.activeElement) : t && !yi(e.target, this.container) && this.hide());
  }
  dispose() {
    this.hide(), super.dispose();
  }
};
sf.BUBBLE_UP_EVENTS = ["click", "keydown", "focus", "blur"], sf.BUBBLE_DOWN_EVENTS = ["click"];
let WL = sf;
const nq = (
  /* css */
  `
	:host {
		all: initial; /* 1st rule so subsequent properties are reset. */
	}

	.codicon[class*='codicon-'] {
		font: normal normal normal 16px/1 codicon;
		display: inline-block;
		text-decoration: none;
		text-rendering: auto;
		text-align: center;
		-webkit-font-smoothing: antialiased;
		-moz-osx-font-smoothing: grayscale;
		user-select: none;
		-webkit-user-select: none;
		-ms-user-select: none;
	}

	:host {
		font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "HelveticaNeue-Light", system-ui, "Ubuntu", "Droid Sans", sans-serif;
	}

	:host-context(.mac) { font-family: -apple-system, BlinkMacSystemFont, sans-serif; }
	:host-context(.mac:lang(zh-Hans)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang SC", "Hiragino Sans GB", sans-serif; }
	:host-context(.mac:lang(zh-Hant)) { font-family: -apple-system, BlinkMacSystemFont, "PingFang TC", sans-serif; }
	:host-context(.mac:lang(ja)) { font-family: -apple-system, BlinkMacSystemFont, "Hiragino Kaku Gothic Pro", sans-serif; }
	:host-context(.mac:lang(ko)) { font-family: -apple-system, BlinkMacSystemFont, "Nanum Gothic", "Apple SD Gothic Neo", "AppleGothic", sans-serif; }

	:host-context(.windows) { font-family: "Segoe WPC", "Segoe UI", sans-serif; }
	:host-context(.windows:lang(zh-Hans)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft YaHei", sans-serif; }
	:host-context(.windows:lang(zh-Hant)) { font-family: "Segoe WPC", "Segoe UI", "Microsoft Jhenghei", sans-serif; }
	:host-context(.windows:lang(ja)) { font-family: "Segoe WPC", "Segoe UI", "Yu Gothic UI", "Meiryo UI", sans-serif; }
	:host-context(.windows:lang(ko)) { font-family: "Segoe WPC", "Segoe UI", "Malgun Gothic", "Dotom", sans-serif; }

	:host-context(.linux) { font-family: system-ui, "Ubuntu", "Droid Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hans)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans SC", "Source Han Sans CN", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(zh-Hant)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans TC", "Source Han Sans TW", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ja)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans J", "Source Han Sans JP", "Source Han Sans", sans-serif; }
	:host-context(.linux:lang(ko)) { font-family: system-ui, "Ubuntu", "Droid Sans", "Source Han Sans K", "Source Han Sans JR", "Source Han Sans", "UnDotum", "FBaekmuk Gulim", sans-serif; }
`
);
var sq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, oq = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let MC = class extends V {
  constructor(e) {
    super(), this.layoutService = e, this.contextView = this._register(new WL(
      this.layoutService.mainContainer,
      1
      /* ContextViewDOMPosition.ABSOLUTE */
    )), this.layout(), this._register(e.onDidLayoutContainer(() => this.layout()));
  }
  // ContextView
  showContextView(e, t, i) {
    let n;
    t ? t === this.layoutService.getContainer(fe(t)) ? n = 1 : i ? n = 3 : n = 2 : n = 1, this.contextView.setContainer(t ?? this.layoutService.activeContainer, n), this.contextView.show(e);
    const o = {
      close: () => {
        this.openContextView === o && this.hideContextView();
      }
    };
    return this.openContextView = o, o;
  }
  layout() {
    this.contextView.layout();
  }
  hideContextView(e) {
    this.contextView.hide(e), this.openContextView = void 0;
  }
};
MC = sq([
  oq(0, wd)
], MC);
class rq extends MC {
  getContextViewElement() {
    return this.contextView.getViewElement();
  }
}
class aq {
  constructor(e, t, i) {
    this.hoverDelegate = e, this.target = t, this.fadeInAnimation = i;
  }
  async update(e, t, i) {
    if (this._cancellationTokenSource && (this._cancellationTokenSource.dispose(!0), this._cancellationTokenSource = void 0), this.isDisposed)
      return;
    let n;
    if (e === void 0 || _s(e) || Bi(e))
      n = e;
    else if (!Gw(e.markdown))
      n = e.markdown ?? e.markdownNotSupportedFallback;
    else {
      this._hoverWidget || this.show(f("iconLabel.loading", "Loading..."), t, i), this._cancellationTokenSource = new vs();
      const o = this._cancellationTokenSource.token;
      if (n = await e.markdown(o), n === void 0 && (n = e.markdownNotSupportedFallback), this.isDisposed || o.isCancellationRequested)
        return;
    }
    this.show(n, t, i);
  }
  show(e, t, i) {
    const n = this._hoverWidget;
    if (this.hasContent(e)) {
      const o = {
        content: e,
        target: this.target,
        actions: i?.actions,
        linkHandler: i?.linkHandler,
        trapFocus: i?.trapFocus,
        appearance: {
          showPointer: this.hoverDelegate.placement === "element",
          skipFadeInAnimation: !this.fadeInAnimation || !!n,
          // do not fade in if the hover is already showing
          showHoverHint: i?.appearance?.showHoverHint
        },
        position: {
          hoverPosition: 2
        }
      };
      this._hoverWidget = this.hoverDelegate.showHover(o, t);
    }
    n?.dispose();
  }
  hasContent(e) {
    return e ? Sa(e) ? !!e.value : !0 : !1;
  }
  get isDisposed() {
    return this._hoverWidget?.isDisposed;
  }
  dispose() {
    this._hoverWidget?.dispose(), this._cancellationTokenSource?.dispose(!0), this._cancellationTokenSource = void 0;
  }
}
var lq = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, $m = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let VL = class extends V {
  constructor(e, t, i, n, o) {
    super(), this._instantiationService = e, this._keybindingService = i, this._layoutService = n, this._accessibilityService = o, this._managedHovers = /* @__PURE__ */ new Map(), t.onDidShowContextMenu(() => this.hideHover()), this._contextViewHandler = this._register(new MC(this._layoutService));
  }
  showHover(e, t, i) {
    if (K2(this._currentHoverOptions) === K2(e) || this._currentHover && this._currentHoverOptions?.persistence?.sticky)
      return;
    this._currentHoverOptions = e, this._lastHoverOptions = e;
    const n = e.trapFocus || this._accessibilityService.isScreenReaderOptimized(), o = ln();
    i || (n && o ? o.classList.contains("monaco-hover") || (this._lastFocusedElementBeforeOpen = o) : this._lastFocusedElementBeforeOpen = void 0);
    const r = new X(), a = this._instantiationService.createInstance(HL, e);
    if (e.persistence?.sticky && (a.isLocked = !0), a.onDispose(() => {
      this._currentHover?.domNode && QH(this._currentHover.domNode) && this._lastFocusedElementBeforeOpen?.focus(), this._currentHoverOptions === e && (this._currentHoverOptions = void 0), r.dispose();
    }, void 0, r), !e.container) {
      const l = Bi(e.target) ? e.target : e.target.targetElements[0];
      e.container = this._layoutService.getContainer(fe(l));
    }
    if (this._contextViewHandler.showContextView(new cq(a, t), e.container), a.onRequestLayout(() => this._contextViewHandler.layout(), void 0, r), e.persistence?.sticky)
      r.add(U(fe(e.container).document, ee.MOUSE_DOWN, (l) => {
        yi(l.target, a.domNode) || this.doHideHover();
      }));
    else {
      if ("targetElements" in e.target)
        for (const c of e.target.targetElements)
          r.add(U(c, ee.CLICK, () => this.hideHover()));
      else
        r.add(U(e.target, ee.CLICK, () => this.hideHover()));
      const l = ln();
      if (l) {
        const c = fe(l).document;
        r.add(U(l, ee.KEY_DOWN, (d) => this._keyDown(d, a, !!e.persistence?.hideOnKeyDown))), r.add(U(c, ee.KEY_DOWN, (d) => this._keyDown(d, a, !!e.persistence?.hideOnKeyDown))), r.add(U(l, ee.KEY_UP, (d) => this._keyUp(d, a))), r.add(U(c, ee.KEY_UP, (d) => this._keyUp(d, a)));
      }
    }
    if ("IntersectionObserver" in vt) {
      const l = new IntersectionObserver((d) => this._intersectionChange(d, a), { threshold: 0 }), c = "targetElements" in e.target ? e.target.targetElements[0] : e.target;
      l.observe(c), r.add(we(() => l.disconnect()));
    }
    return this._currentHover = a, a;
  }
  hideHover() {
    this._currentHover?.isLocked || !this._currentHoverOptions || this.doHideHover();
  }
  doHideHover() {
    this._currentHover = void 0, this._currentHoverOptions = void 0, this._contextViewHandler.hideContextView();
  }
  _intersectionChange(e, t) {
    e[e.length - 1].isIntersecting || t.dispose();
  }
  showAndFocusLastHover() {
    this._lastHoverOptions && this.showHover(this._lastHoverOptions, !0, !0);
  }
  _keyDown(e, t, i) {
    if (e.key === "Alt") {
      t.isLocked = !0;
      return;
    }
    const n = new Mt(e);
    this._keybindingService.resolveKeyboardEvent(n).getSingleModifierDispatchChords().some((r) => !!r) || this._keybindingService.softDispatch(n, n.target).kind !== 0 || i && (!this._currentHoverOptions?.trapFocus || e.key !== "Tab") && (this.hideHover(), this._lastFocusedElementBeforeOpen?.focus());
  }
  _keyUp(e, t) {
    e.key === "Alt" && (t.isLocked = !1, t.isMouseIn || (this.hideHover(), this._lastFocusedElementBeforeOpen?.focus()));
  }
  // TODO: Investigate performance of this function. There seems to be a lot of content created
  //       and thrown away on start up
  setupManagedHover(e, t, i, n) {
    t.setAttribute("custom-hover", "true"), t.title !== "" && (console.warn("HTML element already has a title attribute, which will conflict with the custom hover. Please remove the title attribute."), console.trace("Stack trace:", t.title), t.title = "");
    let o, r;
    const a = (C, w) => {
      const S = r !== void 0;
      C && (r?.dispose(), r = void 0), w && (o?.dispose(), o = void 0), S && (e.onDidHideHover?.(), r = void 0);
    }, l = (C, w, S, x) => new nr(async () => {
      (!r || r.isDisposed) && (r = new aq(e, S || t, C > 0), await r.update(typeof i == "function" ? i() : i, w, { ...n, trapFocus: x }));
    }, C);
    let c = !1;
    const d = U(t, ee.MOUSE_DOWN, () => {
      c = !0, a(!0, !0);
    }, !0), h = U(t, ee.MOUSE_UP, () => {
      c = !1;
    }, !0), u = U(t, ee.MOUSE_LEAVE, (C) => {
      c = !1, a(!1, C.fromElement === t);
    }, !0), g = (C) => {
      if (o)
        return;
      const w = new X(), S = {
        targetElements: [t],
        dispose: () => {
        }
      };
      if (e.placement === void 0 || e.placement === "mouse") {
        const x = (y) => {
          S.x = y.x + 10, Bi(y.target) && J2(y.target, t) !== t && a(!0, !0);
        };
        w.add(U(t, ee.MOUSE_MOVE, x, !0));
      }
      o = w, !(Bi(C.target) && J2(C.target, t) !== t) && w.add(l(e.delay, !1, S));
    }, m = U(t, ee.MOUSE_OVER, g, !0), p = () => {
      if (c || o)
        return;
      const C = {
        targetElements: [t],
        dispose: () => {
        }
      }, w = new X(), S = () => a(!0, !0);
      w.add(U(t, ee.BLUR, S, !0)), w.add(l(e.delay, !1, C)), o = w;
    };
    let A;
    const _ = t.tagName.toLowerCase();
    _ !== "input" && _ !== "textarea" && (A = U(t, ee.FOCUS, p, !0));
    const b = {
      show: (C) => {
        a(!1, !0), l(0, C, void 0, C);
      },
      hide: () => {
        a(!0, !0);
      },
      update: async (C, w) => {
        i = C, await r?.update(i, void 0, w);
      },
      dispose: () => {
        this._managedHovers.delete(t), m.dispose(), u.dispose(), d.dispose(), h.dispose(), A?.dispose(), a(!0, !0);
      }
    };
    return this._managedHovers.set(t, b), b;
  }
  showManagedHover(e) {
    const t = this._managedHovers.get(e);
    t && t.show(!0);
  }
  dispose() {
    this._managedHovers.forEach((e) => e.dispose()), super.dispose();
  }
};
VL = lq([
  $m(0, ke),
  $m(1, ar),
  $m(2, bt),
  $m(3, wd),
  $m(4, Lo)
], VL);
function K2(s) {
  if (s !== void 0)
    return s?.id ?? s;
}
class cq {
  get anchorPosition() {
    return this._hover.anchor;
  }
  constructor(e, t = !1) {
    this._hover = e, this._focus = t, this.layer = 1;
  }
  render(e) {
    return this._hover.render(e), this._focus && this._hover.focus(), this._hover;
  }
  getAnchor() {
    return {
      x: this._hover.x,
      y: this._hover.y
    };
  }
  layout() {
    this._hover.layout();
  }
}
function J2(s, e) {
  for (e = e ?? fe(s).document.body; !s.hasAttribute("custom-hover") && s !== e; )
    s = s.parentElement;
  return s;
}
$e(
  jl,
  VL,
  1
  /* InstantiationType.Delayed */
);
rr((s, e) => {
  const t = s.getColor(e3);
  t && (e.addRule(`.monaco-workbench .workbench-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-workbench .workbench-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`));
});
const L3 = We("IWorkspaceEditService");
class RN {
  constructor(e) {
    this.metadata = e;
  }
  static convert(e) {
    return e.edits.map((t) => {
      if (Dh.is(t))
        return Dh.lift(t);
      if (bf.is(t))
        return bf.lift(t);
      throw new Error("Unsupported edit");
    });
  }
}
class Dh extends RN {
  static is(e) {
    return e instanceof Dh ? !0 : Ti(e) && _e.isUri(e.resource) && Ti(e.textEdit);
  }
  static lift(e) {
    return e instanceof Dh ? e : new Dh(e.resource, e.textEdit, e.versionId, e.metadata);
  }
  constructor(e, t, i = void 0, n) {
    super(n), this.resource = e, this.textEdit = t, this.versionId = i;
  }
}
class bf extends RN {
  static is(e) {
    return e instanceof bf ? !0 : Ti(e) && (!!e.newResource || !!e.oldResource);
  }
  static lift(e) {
    return e instanceof bf ? e : new bf(e.oldResource, e.newResource, e.options, e.metadata);
  }
  constructor(e, t, i = {}, n) {
    super(n), this.oldResource = e, this.newResource = t, this.options = i;
  }
}
const Ki = {
  enableSplitViewResizing: !0,
  renderSideBySide: !0,
  renderMarginRevertIcon: !0,
  renderGutterMenu: !0,
  maxComputationTime: 5e3,
  maxFileSize: 50,
  ignoreTrimWhitespace: !0,
  renderIndicators: !0,
  originalEditable: !1,
  diffCodeLens: !1,
  renderOverviewRuler: !0,
  diffWordWrap: "inherit",
  diffAlgorithm: "advanced",
  accessibilityVerbose: !1,
  experimental: {
    showMoves: !1,
    showEmptyDecorations: !0,
    useTrueInlineView: !1
  },
  hideUnchangedRegions: {
    enabled: !1,
    contextLineCount: 3,
    minimumLineCount: 3,
    revealLineCount: 20
  },
  isInEmbeddedEditor: !1,
  onlyShowAccessibleDiffViewer: !1,
  renderSideBySideInlineBreakpoint: 900,
  useInlineViewWhenSpaceIsLimited: !0,
  compactMode: !1
}, dq = Object.freeze({
  id: "editor",
  order: 5,
  type: "object",
  title: f("editorConfigurationTitle", "Editor"),
  scope: 5
}), NC = {
  ...dq,
  properties: {
    "editor.tabSize": {
      type: "number",
      default: an.tabSize,
      minimum: 1,
      markdownDescription: f("tabSize", "The number of spaces a tab is equal to. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.indentSize": {
      anyOf: [
        {
          type: "string",
          enum: ["tabSize"]
        },
        {
          type: "number",
          minimum: 1
        }
      ],
      default: "tabSize",
      markdownDescription: f("indentSize", 'The number of spaces used for indentation or `"tabSize"` to use the value from `#editor.tabSize#`. This setting is overridden based on the file contents when `#editor.detectIndentation#` is on.')
    },
    "editor.insertSpaces": {
      type: "boolean",
      default: an.insertSpaces,
      markdownDescription: f("insertSpaces", "Insert spaces when pressing `Tab`. This setting is overridden based on the file contents when {0} is on.", "`#editor.detectIndentation#`")
    },
    "editor.detectIndentation": {
      type: "boolean",
      default: an.detectIndentation,
      markdownDescription: f("detectIndentation", "Controls whether {0} and {1} will be automatically detected when a file is opened based on the file contents.", "`#editor.tabSize#`", "`#editor.insertSpaces#`")
    },
    "editor.trimAutoWhitespace": {
      type: "boolean",
      default: an.trimAutoWhitespace,
      description: f("trimAutoWhitespace", "Remove trailing auto inserted whitespace.")
    },
    "editor.largeFileOptimizations": {
      type: "boolean",
      default: an.largeFileOptimizations,
      description: f("largeFileOptimizations", "Special handling for large files to disable certain memory intensive features.")
    },
    "editor.wordBasedSuggestions": {
      enum: ["off", "currentDocument", "matchingDocuments", "allDocuments"],
      default: "matchingDocuments",
      enumDescriptions: [
        f("wordBasedSuggestions.off", "Turn off Word Based Suggestions."),
        f("wordBasedSuggestions.currentDocument", "Only suggest words from the active document."),
        f("wordBasedSuggestions.matchingDocuments", "Suggest words from all open documents of the same language."),
        f("wordBasedSuggestions.allDocuments", "Suggest words from all open documents.")
      ],
      description: f("wordBasedSuggestions", "Controls whether completions should be computed based on words in the document and from which documents they are computed.")
    },
    "editor.semanticHighlighting.enabled": {
      enum: [!0, !1, "configuredByTheme"],
      enumDescriptions: [
        f("semanticHighlighting.true", "Semantic highlighting enabled for all color themes."),
        f("semanticHighlighting.false", "Semantic highlighting disabled for all color themes."),
        f("semanticHighlighting.configuredByTheme", "Semantic highlighting is configured by the current color theme's `semanticHighlighting` setting.")
      ],
      default: "configuredByTheme",
      description: f("semanticHighlighting.enabled", "Controls whether the semanticHighlighting is shown for the languages that support it.")
    },
    "editor.stablePeek": {
      type: "boolean",
      default: !1,
      markdownDescription: f("stablePeek", "Keep peek editors open even when double-clicking their content or when hitting `Escape`.")
    },
    "editor.maxTokenizationLineLength": {
      type: "integer",
      default: 2e4,
      description: f("maxTokenizationLineLength", "Lines above this length will not be tokenized for performance reasons")
    },
    "editor.experimental.asyncTokenization": {
      type: "boolean",
      default: !0,
      description: f("editor.experimental.asyncTokenization", "Controls whether the tokenization should happen asynchronously on a web worker."),
      tags: ["experimental"]
    },
    "editor.experimental.asyncTokenizationLogging": {
      type: "boolean",
      default: !1,
      description: f("editor.experimental.asyncTokenizationLogging", "Controls whether async tokenization should be logged. For debugging only.")
    },
    "editor.experimental.asyncTokenizationVerification": {
      type: "boolean",
      default: !1,
      description: f("editor.experimental.asyncTokenizationVerification", "Controls whether async tokenization should be verified against legacy background tokenization. Might slow down tokenization. For debugging only."),
      tags: ["experimental"]
    },
    "editor.experimental.treeSitterTelemetry": {
      type: "boolean",
      default: !1,
      markdownDescription: f("editor.experimental.treeSitterTelemetry", "Controls whether tree sitter parsing should be turned on and telemetry collected. Setting `editor.experimental.preferTreeSitter` for specific languages will take precedence."),
      tags: ["experimental"]
    },
    "editor.language.brackets": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: f("schema.brackets", "Defines the bracket symbols that increase or decrease the indentation."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: f("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: f("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "editor.language.colorizedBracketPairs": {
      type: ["array", "null"],
      default: null,
      // We want to distinguish the empty array from not configured.
      description: f("schema.colorizedBracketPairs", "Defines the bracket pairs that are colorized by their nesting level if bracket pair colorization is enabled."),
      items: {
        type: "array",
        items: [
          {
            type: "string",
            description: f("schema.openBracket", "The opening bracket character or string sequence.")
          },
          {
            type: "string",
            description: f("schema.closeBracket", "The closing bracket character or string sequence.")
          }
        ]
      }
    },
    "diffEditor.maxComputationTime": {
      type: "number",
      default: Ki.maxComputationTime,
      description: f("maxComputationTime", "Timeout in milliseconds after which diff computation is cancelled. Use 0 for no timeout.")
    },
    "diffEditor.maxFileSize": {
      type: "number",
      default: Ki.maxFileSize,
      description: f("maxFileSize", "Maximum file size in MB for which to compute diffs. Use 0 for no limit.")
    },
    "diffEditor.renderSideBySide": {
      type: "boolean",
      default: Ki.renderSideBySide,
      description: f("sideBySide", "Controls whether the diff editor shows the diff side by side or inline.")
    },
    "diffEditor.renderSideBySideInlineBreakpoint": {
      type: "number",
      default: Ki.renderSideBySideInlineBreakpoint,
      description: f("renderSideBySideInlineBreakpoint", "If the diff editor width is smaller than this value, the inline view is used.")
    },
    "diffEditor.useInlineViewWhenSpaceIsLimited": {
      type: "boolean",
      default: Ki.useInlineViewWhenSpaceIsLimited,
      description: f("useInlineViewWhenSpaceIsLimited", "If enabled and the editor width is too small, the inline view is used.")
    },
    "diffEditor.renderMarginRevertIcon": {
      type: "boolean",
      default: Ki.renderMarginRevertIcon,
      description: f("renderMarginRevertIcon", "When enabled, the diff editor shows arrows in its glyph margin to revert changes.")
    },
    "diffEditor.renderGutterMenu": {
      type: "boolean",
      default: Ki.renderGutterMenu,
      description: f("renderGutterMenu", "When enabled, the diff editor shows a special gutter for revert and stage actions.")
    },
    "diffEditor.ignoreTrimWhitespace": {
      type: "boolean",
      default: Ki.ignoreTrimWhitespace,
      description: f("ignoreTrimWhitespace", "When enabled, the diff editor ignores changes in leading or trailing whitespace.")
    },
    "diffEditor.renderIndicators": {
      type: "boolean",
      default: Ki.renderIndicators,
      description: f("renderIndicators", "Controls whether the diff editor shows +/- indicators for added/removed changes.")
    },
    "diffEditor.codeLens": {
      type: "boolean",
      default: Ki.diffCodeLens,
      description: f("codeLens", "Controls whether the editor shows CodeLens.")
    },
    "diffEditor.wordWrap": {
      type: "string",
      enum: ["off", "on", "inherit"],
      default: Ki.diffWordWrap,
      markdownEnumDescriptions: [
        f("wordWrap.off", "Lines will never wrap."),
        f("wordWrap.on", "Lines will wrap at the viewport width."),
        f("wordWrap.inherit", "Lines will wrap according to the {0} setting.", "`#editor.wordWrap#`")
      ]
    },
    "diffEditor.diffAlgorithm": {
      type: "string",
      enum: ["legacy", "advanced"],
      default: Ki.diffAlgorithm,
      markdownEnumDescriptions: [
        f("diffAlgorithm.legacy", "Uses the legacy diffing algorithm."),
        f("diffAlgorithm.advanced", "Uses the advanced diffing algorithm.")
      ],
      tags: ["experimental"]
    },
    "diffEditor.hideUnchangedRegions.enabled": {
      type: "boolean",
      default: Ki.hideUnchangedRegions.enabled,
      markdownDescription: f("hideUnchangedRegions.enabled", "Controls whether the diff editor shows unchanged regions.")
    },
    "diffEditor.hideUnchangedRegions.revealLineCount": {
      type: "integer",
      default: Ki.hideUnchangedRegions.revealLineCount,
      markdownDescription: f("hideUnchangedRegions.revealLineCount", "Controls how many lines are used for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.minimumLineCount": {
      type: "integer",
      default: Ki.hideUnchangedRegions.minimumLineCount,
      markdownDescription: f("hideUnchangedRegions.minimumLineCount", "Controls how many lines are used as a minimum for unchanged regions."),
      minimum: 1
    },
    "diffEditor.hideUnchangedRegions.contextLineCount": {
      type: "integer",
      default: Ki.hideUnchangedRegions.contextLineCount,
      markdownDescription: f("hideUnchangedRegions.contextLineCount", "Controls how many lines are used as context when comparing unchanged regions."),
      minimum: 1
    },
    "diffEditor.experimental.showMoves": {
      type: "boolean",
      default: Ki.experimental.showMoves,
      markdownDescription: f("showMoves", "Controls whether the diff editor should show detected code moves.")
    },
    "diffEditor.experimental.showEmptyDecorations": {
      type: "boolean",
      default: Ki.experimental.showEmptyDecorations,
      description: f("showEmptyDecorations", "Controls whether the diff editor shows empty decorations to see where characters got inserted or deleted.")
    },
    "diffEditor.experimental.useTrueInlineView": {
      type: "boolean",
      default: Ki.experimental.useTrueInlineView,
      description: f("useTrueInlineView", "If enabled and the editor uses the inline view, word changes are rendered inline.")
    }
  }
};
function hq(s) {
  return typeof s.type < "u" || typeof s.anyOf < "u";
}
for (const s of Dg) {
  const e = s.schema;
  if (typeof e < "u")
    if (hq(e))
      NC.properties[`editor.${s.name}`] = e;
    else
      for (const t in e)
        Object.hasOwnProperty.call(e, t) && (NC.properties[t] = e[t]);
}
let yb = null;
function k3() {
  return yb === null && (yb = /* @__PURE__ */ Object.create(null), Object.keys(NC.properties).forEach((s) => {
    yb[s] = !0;
  })), yb;
}
function uq(s) {
  return k3()[`editor.${s}`] || !1;
}
function gq(s) {
  return k3()[`diffEditor.${s}`] || !1;
}
const fq = ji.as(Wu.Configuration);
fq.registerConfiguration(NC);
class ms {
  static insert(e, t) {
    return {
      range: new E(e.lineNumber, e.column, e.lineNumber, e.column),
      text: t,
      forceMoveMarkers: !0
    };
  }
  static delete(e) {
    return {
      range: e,
      text: null
    };
  }
  static replace(e, t) {
    return {
      range: e,
      text: t
    };
  }
  static replaceMove(e, t) {
    return {
      range: e,
      text: t,
      forceMoveMarkers: !0
    };
  }
}
function xb(s) {
  return Object.isFrozen(s) ? s : k9(s);
}
class Ui {
  static createEmptyModel(e) {
    return new Ui({}, [], [], void 0, e);
  }
  constructor(e, t, i, n, o) {
    this._contents = e, this._keys = t, this._overrides = i, this.raw = n, this.logService = o, this.overrideConfigurations = /* @__PURE__ */ new Map();
  }
  get rawConfiguration() {
    if (!this._rawConfiguration)
      if (this.raw?.length) {
        const e = this.raw.map((t) => {
          if (t instanceof Ui)
            return t;
          const i = new mq("", this.logService);
          return i.parseRaw(t), i.configurationModel;
        });
        this._rawConfiguration = e.reduce((t, i) => i === t ? i : t.merge(i), e[0]);
      } else
        this._rawConfiguration = this;
    return this._rawConfiguration;
  }
  get contents() {
    return this._contents;
  }
  get overrides() {
    return this._overrides;
  }
  get keys() {
    return this._keys;
  }
  isEmpty() {
    return this._keys.length === 0 && Object.keys(this._contents).length === 0 && this._overrides.length === 0;
  }
  getValue(e) {
    return e ? ER(this.contents, e) : this.contents;
  }
  inspect(e, t) {
    const i = this;
    return {
      get value() {
        return xb(i.rawConfiguration.getValue(e));
      },
      get override() {
        return t ? xb(i.rawConfiguration.getOverrideValue(e, t)) : void 0;
      },
      get merged() {
        return xb(t ? i.rawConfiguration.override(t).getValue(e) : i.rawConfiguration.getValue(e));
      },
      get overrides() {
        const n = [];
        for (const { contents: o, identifiers: r, keys: a } of i.rawConfiguration.overrides) {
          const l = new Ui(o, a, [], void 0, i.logService).getValue(e);
          l !== void 0 && n.push({ identifiers: r, value: l });
        }
        return n.length ? xb(n) : void 0;
      }
    };
  }
  getOverrideValue(e, t) {
    const i = this.getContentsForOverrideIdentifer(t);
    return i ? e ? ER(i, e) : i : void 0;
  }
  override(e) {
    let t = this.overrideConfigurations.get(e);
    return t || (t = this.createOverrideConfigurationModel(e), this.overrideConfigurations.set(e, t)), t;
  }
  merge(...e) {
    const t = ll(this.contents), i = ll(this.overrides), n = [...this.keys], o = this.raw?.length ? [...this.raw] : [this];
    for (const r of e)
      if (o.push(...r.raw?.length ? r.raw : [r]), !r.isEmpty()) {
        this.mergeContents(t, r.contents);
        for (const a of r.overrides) {
          const [l] = i.filter((c) => pi(c.identifiers, a.identifiers));
          l ? (this.mergeContents(l.contents, a.contents), l.keys.push(...a.keys), l.keys = du(l.keys)) : i.push(ll(a));
        }
        for (const a of r.keys)
          n.indexOf(a) === -1 && n.push(a);
      }
    return new Ui(t, n, i, o.every((r) => r instanceof Ui) ? void 0 : o, this.logService);
  }
  createOverrideConfigurationModel(e) {
    const t = this.getContentsForOverrideIdentifer(e);
    if (!t || typeof t != "object" || !Object.keys(t).length)
      return this;
    const i = {};
    for (const n of du([...Object.keys(this.contents), ...Object.keys(t)])) {
      let o = this.contents[n];
      const r = t[n];
      r && (typeof o == "object" && typeof r == "object" ? (o = ll(o), this.mergeContents(o, r)) : o = r), i[n] = o;
    }
    return new Ui(i, this.keys, this.overrides, void 0, this.logService);
  }
  mergeContents(e, t) {
    for (const i of Object.keys(t)) {
      if (i in e && Ti(e[i]) && Ti(t[i])) {
        this.mergeContents(e[i], t[i]);
        continue;
      }
      e[i] = ll(t[i]);
    }
  }
  getContentsForOverrideIdentifer(e) {
    let t = null, i = null;
    const n = (o) => {
      o && (i ? this.mergeContents(i, o) : i = ll(o));
    };
    for (const o of this.overrides)
      o.identifiers.length === 1 && o.identifiers[0] === e ? t = o.contents : o.identifiers.includes(e) && n(o.contents);
    return n(t), i;
  }
  toJSON() {
    return {
      contents: this.contents,
      overrides: this.overrides,
      keys: this.keys
    };
  }
  setValue(e, t) {
    this.updateValue(e, t, !1);
  }
  removeValue(e) {
    const t = this.keys.indexOf(e);
    t !== -1 && (this.keys.splice(t, 1), fQ(this.contents, e), rd.test(e) && this.overrides.splice(this.overrides.findIndex((i) => pi(i.identifiers, dC(e))), 1));
  }
  updateValue(e, t, i) {
    if (h5(this.contents, e, t, (n) => this.logService.error(n)), i = i || this.keys.indexOf(e) === -1, i && this.keys.push(e), rd.test(e)) {
      const n = dC(e), o = {
        identifiers: n,
        keys: Object.keys(this.contents[e]),
        contents: XE(this.contents[e], (a) => this.logService.error(a))
      }, r = this.overrides.findIndex((a) => pi(a.identifiers, n));
      r !== -1 ? this.overrides[r] = o : this.overrides.push(o);
    }
  }
}
class mq {
  constructor(e, t) {
    this._name = e, this.logService = t, this._raw = null, this._configurationModel = null, this._restrictedConfigurations = [];
  }
  get configurationModel() {
    return this._configurationModel || Ui.createEmptyModel(this.logService);
  }
  parseRaw(e, t) {
    this._raw = e;
    const { contents: i, keys: n, overrides: o, restricted: r, hasExcludedProperties: a } = this.doParseRaw(e, t);
    this._configurationModel = new Ui(i, n, o, a ? [e] : void 0, this.logService), this._restrictedConfigurations = r || [];
  }
  doParseRaw(e, t) {
    const i = ji.as(Wu.Configuration).getConfigurationProperties(), n = this.filter(e, i, !0, t);
    e = n.raw;
    const o = XE(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`)), r = Object.keys(e), a = this.toOverrides(e, (l) => this.logService.error(`Conflict in settings file ${this._name}: ${l}`));
    return { contents: o, keys: r, overrides: a, restricted: n.restricted, hasExcludedProperties: n.hasExcludedProperties };
  }
  filter(e, t, i, n) {
    let o = !1;
    if (!n?.scopes && !n?.skipRestricted && !n?.exclude?.length)
      return { raw: e, restricted: [], hasExcludedProperties: o };
    const r = {}, a = [];
    for (const l in e)
      if (rd.test(l) && i) {
        const c = this.filter(e[l], t, !1, n);
        r[l] = c.raw, o = o || c.hasExcludedProperties, a.push(...c.restricted);
      } else {
        const c = t[l], d = c ? typeof c.scope < "u" ? c.scope : 3 : void 0;
        c?.restricted && a.push(l), !n.exclude?.includes(l) && (n.include?.includes(l) || (d === void 0 || n.scopes === void 0 || n.scopes.includes(d)) && !(n.skipRestricted && c?.restricted)) ? r[l] = e[l] : o = !0;
      }
    return { raw: r, restricted: a, hasExcludedProperties: o };
  }
  toOverrides(e, t) {
    const i = [];
    for (const n of Object.keys(e))
      if (rd.test(n)) {
        const o = {};
        for (const r in e[n])
          o[r] = e[n][r];
        i.push({
          identifiers: dC(n),
          keys: Object.keys(o),
          contents: XE(o, t)
        });
      }
    return i;
  }
}
class pq {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g) {
    this.key = e, this.overrides = t, this._value = i, this.overrideIdentifiers = n, this.defaultConfiguration = o, this.policyConfiguration = r, this.applicationConfiguration = a, this.userConfiguration = l, this.localUserConfiguration = c, this.remoteUserConfiguration = d, this.workspaceConfiguration = h, this.folderConfigurationModel = u, this.memoryConfigurationModel = g;
  }
  toInspectValue(e) {
    return e?.value !== void 0 || e?.override !== void 0 || e?.overrides !== void 0 ? e : void 0;
  }
  get userInspectValue() {
    return this._userInspectValue || (this._userInspectValue = this.userConfiguration.inspect(this.key, this.overrides.overrideIdentifier)), this._userInspectValue;
  }
  get user() {
    return this.toInspectValue(this.userInspectValue);
  }
}
class eS {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    this._defaultConfiguration = e, this._policyConfiguration = t, this._applicationConfiguration = i, this._localUserConfiguration = n, this._remoteUserConfiguration = o, this._workspaceConfiguration = r, this._folderConfigurations = a, this._memoryConfiguration = l, this._memoryConfigurationByResource = c, this.logService = d, this._workspaceConsolidatedConfiguration = null, this._foldersConsolidatedConfigurations = new ws(), this._userConfiguration = null;
  }
  getValue(e, t, i) {
    return this.getConsolidatedConfigurationModel(e, t, i).getValue(e);
  }
  updateValue(e, t, i = {}) {
    let n;
    i.resource ? (n = this._memoryConfigurationByResource.get(i.resource), n || (n = Ui.createEmptyModel(this.logService), this._memoryConfigurationByResource.set(i.resource, n))) : n = this._memoryConfiguration, t === void 0 ? n.removeValue(e) : n.setValue(e, t), i.resource || (this._workspaceConsolidatedConfiguration = null);
  }
  inspect(e, t, i) {
    const n = this.getConsolidatedConfigurationModel(e, t, i), o = this.getFolderConfigurationModelForResource(t.resource, i), r = t.resource ? this._memoryConfigurationByResource.get(t.resource) || this._memoryConfiguration : this._memoryConfiguration, a = /* @__PURE__ */ new Set();
    for (const l of n.overrides)
      for (const c of l.identifiers)
        n.getOverrideValue(e, c) !== void 0 && a.add(c);
    return new pq(e, t, n.getValue(e), a.size ? [...a] : void 0, this._defaultConfiguration, this._policyConfiguration.isEmpty() ? void 0 : this._policyConfiguration, this.applicationConfiguration.isEmpty() ? void 0 : this.applicationConfiguration, this.userConfiguration, this.localUserConfiguration, this.remoteUserConfiguration, i ? this._workspaceConfiguration : void 0, o || void 0, r);
  }
  get applicationConfiguration() {
    return this._applicationConfiguration;
  }
  get userConfiguration() {
    return this._userConfiguration || (this._userConfiguration = this._remoteUserConfiguration.isEmpty() ? this._localUserConfiguration : this._localUserConfiguration.merge(this._remoteUserConfiguration)), this._userConfiguration;
  }
  get localUserConfiguration() {
    return this._localUserConfiguration;
  }
  get remoteUserConfiguration() {
    return this._remoteUserConfiguration;
  }
  getConsolidatedConfigurationModel(e, t, i) {
    let n = this.getConsolidatedConfigurationModelForResource(t, i);
    return t.overrideIdentifier && (n = n.override(t.overrideIdentifier)), !this._policyConfiguration.isEmpty() && this._policyConfiguration.getValue(e) !== void 0 && (n = n.merge(this._policyConfiguration)), n;
  }
  getConsolidatedConfigurationModelForResource({ resource: e }, t) {
    let i = this.getWorkspaceConsolidatedConfiguration();
    if (t && e) {
      const n = t.getFolder(e);
      n && (i = this.getFolderConsolidatedConfiguration(n.uri) || i);
      const o = this._memoryConfigurationByResource.get(e);
      o && (i = i.merge(o));
    }
    return i;
  }
  getWorkspaceConsolidatedConfiguration() {
    return this._workspaceConsolidatedConfiguration || (this._workspaceConsolidatedConfiguration = this._defaultConfiguration.merge(this.applicationConfiguration, this.userConfiguration, this._workspaceConfiguration, this._memoryConfiguration)), this._workspaceConsolidatedConfiguration;
  }
  getFolderConsolidatedConfiguration(e) {
    let t = this._foldersConsolidatedConfigurations.get(e);
    if (!t) {
      const i = this.getWorkspaceConsolidatedConfiguration(), n = this._folderConfigurations.get(e);
      n ? (t = i.merge(n), this._foldersConsolidatedConfigurations.set(e, t)) : t = i;
    }
    return t;
  }
  getFolderConfigurationModelForResource(e, t) {
    if (t && e) {
      const i = t.getFolder(e);
      if (i)
        return this._folderConfigurations.get(i.uri);
    }
  }
  toData() {
    return {
      defaults: {
        contents: this._defaultConfiguration.contents,
        overrides: this._defaultConfiguration.overrides,
        keys: this._defaultConfiguration.keys
      },
      policy: {
        contents: this._policyConfiguration.contents,
        overrides: this._policyConfiguration.overrides,
        keys: this._policyConfiguration.keys
      },
      application: {
        contents: this.applicationConfiguration.contents,
        overrides: this.applicationConfiguration.overrides,
        keys: this.applicationConfiguration.keys
      },
      user: {
        contents: this.userConfiguration.contents,
        overrides: this.userConfiguration.overrides,
        keys: this.userConfiguration.keys
      },
      workspace: {
        contents: this._workspaceConfiguration.contents,
        overrides: this._workspaceConfiguration.overrides,
        keys: this._workspaceConfiguration.keys
      },
      folders: [...this._folderConfigurations.keys()].reduce((e, t) => {
        const { contents: i, overrides: n, keys: o } = this._folderConfigurations.get(t);
        return e.push([t, { contents: i, overrides: n, keys: o }]), e;
      }, [])
    };
  }
  static parse(e, t) {
    const i = this.parseConfigurationModel(e.defaults, t), n = this.parseConfigurationModel(e.policy, t), o = this.parseConfigurationModel(e.application, t), r = this.parseConfigurationModel(e.user, t), a = this.parseConfigurationModel(e.workspace, t), l = e.folders.reduce((c, d) => (c.set(_e.revive(d[0]), this.parseConfigurationModel(d[1], t)), c), new ws());
    return new eS(i, n, o, r, Ui.createEmptyModel(t), a, l, Ui.createEmptyModel(t), new ws(), t);
  }
  static parseConfigurationModel(e, t) {
    return new Ui(e.contents, e.keys, e.overrides, void 0, t);
  }
}
class Aq {
  constructor(e, t, i, n, o) {
    this.change = e, this.previous = t, this.currentConfiguraiton = i, this.currentWorkspace = n, this.logService = o, this._marker = `
`, this._markerCode1 = this._marker.charCodeAt(0), this._markerCode2 = 46, this.affectedKeys = /* @__PURE__ */ new Set(), this._previousConfiguration = void 0;
    for (const r of e.keys)
      this.affectedKeys.add(r);
    for (const [, r] of e.overrides)
      for (const a of r)
        this.affectedKeys.add(a);
    this._affectsConfigStr = this._marker;
    for (const r of this.affectedKeys)
      this._affectsConfigStr += r + this._marker;
  }
  get previousConfiguration() {
    return !this._previousConfiguration && this.previous && (this._previousConfiguration = eS.parse(this.previous.data, this.logService)), this._previousConfiguration;
  }
  affectsConfiguration(e, t) {
    const i = this._marker + e, n = this._affectsConfigStr.indexOf(i);
    if (n < 0)
      return !1;
    const o = n + i.length;
    if (o >= this._affectsConfigStr.length)
      return !1;
    const r = this._affectsConfigStr.charCodeAt(o);
    if (r !== this._markerCode1 && r !== this._markerCode2)
      return !1;
    if (t) {
      const a = this.previousConfiguration ? this.previousConfiguration.getValue(e, t, this.previous?.workspace) : void 0, l = this.currentConfiguraiton.getValue(e, t, this.currentWorkspace);
      return !bs(a, l);
    }
    return !0;
  }
}
class _q {
  constructor() {
    this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._enabled = !0;
  }
  get enabled() {
    return this._enabled;
  }
  /**
   * Enable IME
   */
  enable() {
    this._enabled = !0, this._onDidChange.fire();
  }
  /**
   * Disable IME
   */
  disable() {
    this._enabled = !1, this._onDidChange.fire();
  }
}
const Rp = new _q(), TC = {
  kind: 0
  /* ResultKind.NoMatchingKb */
}, bq = {
  kind: 1
  /* ResultKind.MoreChordsNeeded */
};
function wq(s, e, t) {
  return { kind: 2, commandId: s, commandArgs: e, isBubble: t };
}
class Fp {
  constructor(e, t, i) {
    this._log = i, this._defaultKeybindings = e, this._defaultBoundCommands = /* @__PURE__ */ new Map();
    for (const n of e) {
      const o = n.command;
      o && o.charAt(0) !== "-" && this._defaultBoundCommands.set(o, !0);
    }
    this._map = /* @__PURE__ */ new Map(), this._lookupMap = /* @__PURE__ */ new Map(), this._keybindings = Fp.handleRemovals([].concat(e).concat(t));
    for (let n = 0, o = this._keybindings.length; n < o; n++) {
      const r = this._keybindings[n];
      if (r.chords.length === 0)
        continue;
      const a = r.when?.substituteConstants();
      a && a.type === 0 || this._addKeyPress(r.chords[0], r);
    }
  }
  static _isTargetedForRemoval(e, t, i) {
    if (t) {
      for (let n = 0; n < t.length; n++)
        if (t[n] !== e.chords[n])
          return !1;
    }
    return !(i && i.type !== 1 && (!e.when || !xU(i, e.when)));
  }
  /**
   * Looks for rules containing "-commandId" and removes them.
   */
  static handleRemovals(e) {
    const t = /* @__PURE__ */ new Map();
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (r.command && r.command.charAt(0) === "-") {
        const a = r.command.substring(1);
        t.has(a) ? t.get(a).push(r) : t.set(a, [r]);
      }
    }
    if (t.size === 0)
      return e;
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (!r.command || r.command.length === 0) {
        i.push(r);
        continue;
      }
      if (r.command.charAt(0) === "-")
        continue;
      const a = t.get(r.command);
      if (!a || !r.isDefault) {
        i.push(r);
        continue;
      }
      let l = !1;
      for (const c of a) {
        const d = c.when;
        if (this._isTargetedForRemoval(r, c.chords, d)) {
          l = !0;
          break;
        }
      }
      if (!l) {
        i.push(r);
        continue;
      }
    }
    return i;
  }
  _addKeyPress(e, t) {
    const i = this._map.get(e);
    if (typeof i > "u") {
      this._map.set(e, [t]), this._addToLookupMap(t);
      return;
    }
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (o.command === t.command)
        continue;
      let r = !0;
      for (let a = 1; a < o.chords.length && a < t.chords.length; a++)
        if (o.chords[a] !== t.chords[a]) {
          r = !1;
          break;
        }
      r && Fp.whenIsEntirelyIncluded(o.when, t.when) && this._removeFromLookupMap(o);
    }
    i.push(t), this._addToLookupMap(t);
  }
  _addToLookupMap(e) {
    if (!e.command)
      return;
    let t = this._lookupMap.get(e.command);
    typeof t > "u" ? (t = [e], this._lookupMap.set(e.command, t)) : t.push(e);
  }
  _removeFromLookupMap(e) {
    if (!e.command)
      return;
    const t = this._lookupMap.get(e.command);
    if (!(typeof t > "u")) {
      for (let i = 0, n = t.length; i < n; i++)
        if (t[i] === e) {
          t.splice(i, 1);
          return;
        }
    }
  }
  /**
   * Returns true if it is provable `a` implies `b`.
   */
  static whenIsEntirelyIncluded(e, t) {
    return !t || t.type === 1 ? !0 : !e || e.type === 1 ? !1 : KE(e, t);
  }
  getKeybindings() {
    return this._keybindings;
  }
  lookupPrimaryKeybinding(e, t) {
    const i = this._lookupMap.get(e);
    if (typeof i > "u" || i.length === 0)
      return null;
    if (i.length === 1)
      return i[0];
    for (let n = i.length - 1; n >= 0; n--) {
      const o = i[n];
      if (t.contextMatchesRules(o.when))
        return o;
    }
    return i[i.length - 1];
  }
  /**
   * Looks up a keybinding trigged as a result of pressing a sequence of chords - `[...currentChords, keypress]`
   *
   * Example: resolving 3 chords pressed sequentially - `cmd+k cmd+p cmd+i`:
   * 	`currentChords = [ 'cmd+k' , 'cmd+p' ]` and `keypress = `cmd+i` - last pressed chord
   */
  resolve(e, t, i) {
    const n = [...t, i];
    this._log(`| Resolving ${n}`);
    const o = this._map.get(n[0]);
    if (o === void 0)
      return this._log("\\ No keybinding entries."), TC;
    let r = null;
    if (n.length < 2)
      r = o;
    else {
      r = [];
      for (let l = 0, c = o.length; l < c; l++) {
        const d = o[l];
        if (n.length > d.chords.length)
          continue;
        let h = !0;
        for (let u = 1; u < n.length; u++)
          if (d.chords[u] !== n[u]) {
            h = !1;
            break;
          }
        h && r.push(d);
      }
    }
    const a = this._findCommand(e, r);
    return a ? n.length < a.chords.length ? (this._log(`\\ From ${r.length} keybinding entries, awaiting ${a.chords.length - n.length} more chord(s), when: ${q2(a.when)}, source: ${$2(a)}.`), bq) : (this._log(`\\ From ${r.length} keybinding entries, matched ${a.command}, when: ${q2(a.when)}, source: ${$2(a)}.`), wq(a.command, a.commandArgs, a.bubble)) : (this._log(`\\ From ${r.length} keybinding entries, no when clauses matched the context.`), TC);
  }
  _findCommand(e, t) {
    for (let i = t.length - 1; i >= 0; i--) {
      const n = t[i];
      if (Fp._contextMatchesRules(e, n.when))
        return n;
    }
    return null;
  }
  static _contextMatchesRules(e, t) {
    return t ? t.evaluate(e) : !0;
  }
}
function q2(s) {
  return s ? `${s.serialize()}` : "no when condition";
}
function $2(s) {
  return s.extensionId ? s.isBuiltinExtension ? `built-in extension ${s.extensionId}` : `user extension ${s.extensionId}` : s.isDefault ? "built-in" : "user";
}
const Cq = /^(cursor|delete|undo|redo|tab|editor\.action\.clipboard)/;
class vq extends V {
  get onDidUpdateKeybindings() {
    return this._onDidUpdateKeybindings ? this._onDidUpdateKeybindings.event : te.None;
  }
  get inChordMode() {
    return this._currentChords.length > 0;
  }
  constructor(e, t, i, n, o) {
    super(), this._contextKeyService = e, this._commandService = t, this._telemetryService = i, this._notificationService = n, this._logService = o, this._onDidUpdateKeybindings = this._register(new B()), this._currentChords = [], this._currentChordChecker = new QM(), this._currentChordStatusMessage = null, this._ignoreSingleModifiers = Og.EMPTY, this._currentSingleModifier = null, this._currentSingleModifierClearTimeout = new nr(), this._currentlyDispatchingCommandId = null, this._logging = !1;
  }
  dispose() {
    super.dispose();
  }
  _log(e) {
    this._logging && this._logService.info(`[KeybindingService]: ${e}`);
  }
  getKeybindings() {
    return this._getResolver().getKeybindings();
  }
  lookupKeybinding(e, t) {
    const i = this._getResolver().lookupPrimaryKeybinding(e, t || this._contextKeyService);
    if (i)
      return i.resolvedKeybinding;
  }
  dispatchEvent(e, t) {
    return this._dispatch(e, t);
  }
  // TODO@ulugbekna: update namings to align with `_doDispatch`
  // TODO@ulugbekna: this fn doesn't seem to take into account single-modifier keybindings, eg `shift shift`
  softDispatch(e, t) {
    this._log("/ Soft dispatching keyboard event");
    const i = this.resolveKeyboardEvent(e);
    if (i.hasMultipleChords())
      return console.warn("keyboard event should not be mapped to multiple chords"), TC;
    const [n] = i.getDispatchChords();
    if (n === null)
      return this._log("\\ Keyboard event cannot be dispatched"), TC;
    const o = this._contextKeyService.getContext(t), r = this._currentChords.map(({ keypress: a }) => a);
    return this._getResolver().resolve(o, r, n);
  }
  _scheduleLeaveChordMode() {
    const e = Date.now();
    this._currentChordChecker.cancelAndSet(() => {
      if (!this._documentHasFocus()) {
        this._leaveChordMode();
        return;
      }
      Date.now() - e > 5e3 && this._leaveChordMode();
    }, 500);
  }
  _expectAnotherChord(e, t) {
    switch (this._currentChords.push({ keypress: e, label: t }), this._currentChords.length) {
      case 0:
        throw kM("impossible");
      case 1:
        this._currentChordStatusMessage = this._notificationService.status(f("first.chord", "({0}) was pressed. Waiting for second key of chord...", t));
        break;
      default: {
        const i = this._currentChords.map(({ label: n }) => n).join(", ");
        this._currentChordStatusMessage = this._notificationService.status(f("next.chord", "({0}) was pressed. Waiting for next key of chord...", i));
      }
    }
    this._scheduleLeaveChordMode(), Rp.enabled && Rp.disable();
  }
  _leaveChordMode() {
    this._currentChordStatusMessage && (this._currentChordStatusMessage.dispose(), this._currentChordStatusMessage = null), this._currentChordChecker.cancel(), this._currentChords = [], Rp.enable();
  }
  _dispatch(e, t) {
    return this._doDispatch(
      this.resolveKeyboardEvent(e),
      t,
      /*isSingleModiferChord*/
      !1
    );
  }
  _singleModifierDispatch(e, t) {
    const i = this.resolveKeyboardEvent(e), [n] = i.getSingleModifierDispatchChords();
    if (n)
      return this._ignoreSingleModifiers.has(n) ? (this._log(`+ Ignoring single modifier ${n} due to it being pressed together with other keys.`), this._ignoreSingleModifiers = Og.EMPTY, this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1) : (this._ignoreSingleModifiers = Og.EMPTY, this._currentSingleModifier === null ? (this._log(`+ Storing single modifier for possible chord ${n}.`), this._currentSingleModifier = n, this._currentSingleModifierClearTimeout.cancelAndSet(() => {
        this._log("+ Clearing single modifier due to 300ms elapsed."), this._currentSingleModifier = null;
      }, 300), !1) : n === this._currentSingleModifier ? (this._log(`/ Dispatching single modifier chord ${n} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, this._doDispatch(
        i,
        t,
        /*isSingleModiferChord*/
        !0
      )) : (this._log(`+ Clearing single modifier due to modifier mismatch: ${this._currentSingleModifier} ${n}`), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1));
    const [o] = i.getChords();
    return this._ignoreSingleModifiers = new Og(o), this._currentSingleModifier !== null && this._log("+ Clearing single modifier due to other key up."), this._currentSingleModifierClearTimeout.cancel(), this._currentSingleModifier = null, !1;
  }
  _doDispatch(e, t, i = !1) {
    let n = !1;
    if (e.hasMultipleChords())
      return console.warn("Unexpected keyboard event mapped to multiple chords"), !1;
    let o = null, r = null;
    if (i) {
      const [d] = e.getSingleModifierDispatchChords();
      o = d, r = d ? [d] : [];
    } else
      [o] = e.getDispatchChords(), r = this._currentChords.map(({ keypress: d }) => d);
    if (o === null)
      return this._log("\\ Keyboard event cannot be dispatched in keydown phase."), n;
    const a = this._contextKeyService.getContext(t), l = e.getLabel(), c = this._getResolver().resolve(a, r, o);
    switch (c.kind) {
      case 0: {
        if (this._logService.trace("KeybindingService#dispatch", l, "[ No matching keybinding ]"), this.inChordMode) {
          const d = this._currentChords.map(({ label: h }) => h).join(", ");
          this._log(`+ Leaving multi-chord mode: Nothing bound to "${d}, ${l}".`), this._notificationService.status(f("missing.chord", "The key combination ({0}, {1}) is not a command.", d, l), {
            hideAfter: 10 * 1e3
            /* 10s */
          }), this._leaveChordMode(), n = !0;
        }
        return n;
      }
      case 1:
        return this._logService.trace("KeybindingService#dispatch", l, "[ Several keybindings match - more chords needed ]"), n = !0, this._expectAnotherChord(o, l), this._log(this._currentChords.length === 1 ? "+ Entering multi-chord mode..." : "+ Continuing multi-chord mode..."), n;
      case 2: {
        if (this._logService.trace("KeybindingService#dispatch", l, `[ Will dispatch command ${c.commandId} ]`), c.commandId === null || c.commandId === "") {
          if (this.inChordMode) {
            const d = this._currentChords.map(({ label: h }) => h).join(", ");
            this._log(`+ Leaving chord mode: Nothing bound to "${d}, ${l}".`), this._notificationService.status(f("missing.chord", "The key combination ({0}, {1}) is not a command.", d, l), {
              hideAfter: 10 * 1e3
              /* 10s */
            }), this._leaveChordMode(), n = !0;
          }
        } else {
          this.inChordMode && this._leaveChordMode(), c.isBubble || (n = !0), this._log(`+ Invoking command ${c.commandId}.`), this._currentlyDispatchingCommandId = c.commandId;
          try {
            typeof c.commandArgs > "u" ? this._commandService.executeCommand(c.commandId).then(void 0, (d) => this._notificationService.warn(d)) : this._commandService.executeCommand(c.commandId, c.commandArgs).then(void 0, (d) => this._notificationService.warn(d));
          } finally {
            this._currentlyDispatchingCommandId = null;
          }
          Cq.test(c.commandId) || this._telemetryService.publicLog2("workbenchActionExecuted", { id: c.commandId, from: "keybinding", detail: e.getUserSettingsLabel() ?? void 0 });
        }
        return n;
      }
    }
  }
  mightProducePrintableCharacter(e) {
    return e.ctrlKey || e.metaKey ? !1 : e.keyCode >= 31 && e.keyCode <= 56 || e.keyCode >= 21 && e.keyCode <= 30;
  }
}
const x1 = class x1 {
  constructor(e) {
    this._ctrlKey = e ? e.ctrlKey : !1, this._shiftKey = e ? e.shiftKey : !1, this._altKey = e ? e.altKey : !1, this._metaKey = e ? e.metaKey : !1;
  }
  has(e) {
    switch (e) {
      case "ctrl":
        return this._ctrlKey;
      case "shift":
        return this._shiftKey;
      case "alt":
        return this._altKey;
      case "meta":
        return this._metaKey;
    }
  }
};
x1.EMPTY = new x1(null);
let Og = x1;
class X2 {
  constructor(e, t, i, n, o, r, a) {
    this._resolvedKeybindingItemBrand = void 0, this.resolvedKeybinding = e, this.chords = e ? zL(e.getDispatchChords()) : [], e && this.chords.length === 0 && (this.chords = zL(e.getSingleModifierDispatchChords())), this.bubble = t ? t.charCodeAt(0) === 94 : !1, this.command = this.bubble ? t.substr(1) : t, this.commandArgs = i, this.when = n, this.isDefault = o, this.extensionId = r, this.isBuiltinExtension = a;
  }
}
function zL(s) {
  const e = [];
  for (let t = 0, i = s.length; t < i; t++) {
    const n = s[t];
    if (!n)
      return [];
    e.push(n);
  }
  return e;
}
class tS {
  constructor(e, t, i = t) {
    this.modifierLabels = [null], this.modifierLabels[
      2
      /* OperatingSystem.Macintosh */
    ] = e, this.modifierLabels[
      1
      /* OperatingSystem.Windows */
    ] = t, this.modifierLabels[
      3
      /* OperatingSystem.Linux */
    ] = i;
  }
  toLabel(e, t, i) {
    if (t.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = i(a);
      if (l === null)
        return null;
      n[o] = Eq(a, l, this.modifierLabels[e]);
    }
    return n.join(" ");
  }
}
const FN = new tS({
  ctrlKey: "⌃",
  shiftKey: "⇧",
  altKey: "⌥",
  metaKey: "⌘",
  separator: ""
}, {
  ctrlKey: f({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: f({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: f({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: f({ key: "windowsKey", comment: ["This is the short form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: f({ key: "ctrlKey", comment: ["This is the short form for the Control key on the keyboard"] }, "Ctrl"),
  shiftKey: f({ key: "shiftKey", comment: ["This is the short form for the Shift key on the keyboard"] }, "Shift"),
  altKey: f({ key: "altKey", comment: ["This is the short form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: f({ key: "superKey", comment: ["This is the short form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), Sq = new tS({
  ctrlKey: f({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: f({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: f({ key: "optKey.long", comment: ["This is the long form for the Alt/Option key on the keyboard"] }, "Option"),
  metaKey: f({ key: "cmdKey.long", comment: ["This is the long form for the Command key on the keyboard"] }, "Command"),
  separator: "+"
}, {
  ctrlKey: f({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: f({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: f({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: f({ key: "windowsKey.long", comment: ["This is the long form for the Windows key on the keyboard"] }, "Windows"),
  separator: "+"
}, {
  ctrlKey: f({ key: "ctrlKey.long", comment: ["This is the long form for the Control key on the keyboard"] }, "Control"),
  shiftKey: f({ key: "shiftKey.long", comment: ["This is the long form for the Shift key on the keyboard"] }, "Shift"),
  altKey: f({ key: "altKey.long", comment: ["This is the long form for the Alt key on the keyboard"] }, "Alt"),
  metaKey: f({ key: "superKey.long", comment: ["This is the long form for the Super key on the keyboard"] }, "Super"),
  separator: "+"
}), yq = new tS({
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Cmd",
  separator: "+"
}, {
  ctrlKey: "Ctrl",
  shiftKey: "Shift",
  altKey: "Alt",
  metaKey: "Super",
  separator: "+"
}), xq = new tS({
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "cmd",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "win",
  separator: "+"
}, {
  ctrlKey: "ctrl",
  shiftKey: "shift",
  altKey: "alt",
  metaKey: "meta",
  separator: "+"
});
function Eq(s, e, t) {
  if (e === null)
    return "";
  const i = [];
  return s.ctrlKey && i.push(t.ctrlKey), s.shiftKey && i.push(t.shiftKey), s.altKey && i.push(t.altKey), s.metaKey && i.push(t.metaKey), e !== "" && i.push(e), i.join(t.separator);
}
class Lq extends G7 {
  constructor(e, t) {
    if (super(), t.length === 0)
      throw Go("chords");
    this._os = e, this._chords = t;
  }
  getLabel() {
    return FN.toLabel(this._os, this._chords, (e) => this._getLabel(e));
  }
  getAriaLabel() {
    return Sq.toLabel(this._os, this._chords, (e) => this._getAriaLabel(e));
  }
  getElectronAccelerator() {
    return this._chords.length > 1 || this._chords[0].isDuplicateModifierCase() ? null : yq.toLabel(this._os, this._chords, (e) => this._getElectronAccelerator(e));
  }
  getUserSettingsLabel() {
    return xq.toLabel(this._os, this._chords, (e) => this._getUserSettingsLabel(e));
  }
  hasMultipleChords() {
    return this._chords.length > 1;
  }
  getChords() {
    return this._chords.map((e) => this._getChord(e));
  }
  _getChord(e) {
    return new Q7(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, this._getLabel(e), this._getAriaLabel(e));
  }
  getDispatchChords() {
    return this._chords.map((e) => this._getChordDispatch(e));
  }
  getSingleModifierDispatchChords() {
    return this._chords.map((e) => this._getSingleModifierChordDispatch(e));
  }
}
class YA extends Lq {
  constructor(e, t) {
    super(t, e);
  }
  _keyCodeToUILabel(e) {
    if (this._os === 2)
      switch (e) {
        case 15:
          return "←";
        case 16:
          return "↑";
        case 17:
          return "→";
        case 18:
          return "↓";
      }
    return ul.toString(e);
  }
  _getLabel(e) {
    return e.isDuplicateModifierCase() ? "" : this._keyCodeToUILabel(e.keyCode);
  }
  _getAriaLabel(e) {
    return e.isDuplicateModifierCase() ? "" : ul.toString(e.keyCode);
  }
  _getElectronAccelerator(e) {
    return ul.toElectronAccelerator(e.keyCode);
  }
  _getUserSettingsLabel(e) {
    if (e.isDuplicateModifierCase())
      return "";
    const t = ul.toUserSettingsUS(e.keyCode);
    return t && t.toLowerCase();
  }
  _getChordDispatch(e) {
    return YA.getDispatchStr(e);
  }
  static getDispatchStr(e) {
    if (e.isModifierKey())
      return null;
    let t = "";
    return e.ctrlKey && (t += "ctrl+"), e.shiftKey && (t += "shift+"), e.altKey && (t += "alt+"), e.metaKey && (t += "meta+"), t += ul.toString(e.keyCode), t;
  }
  _getSingleModifierChordDispatch(e) {
    return e.keyCode === 5 && !e.shiftKey && !e.altKey && !e.metaKey ? "ctrl" : e.keyCode === 4 && !e.ctrlKey && !e.altKey && !e.metaKey ? "shift" : e.keyCode === 6 && !e.ctrlKey && !e.shiftKey && !e.metaKey ? "alt" : e.keyCode === 57 && !e.ctrlKey && !e.shiftKey && !e.altKey ? "meta" : null;
  }
  /**
   * *NOTE*: Check return value for `KeyCode.Unknown`.
   */
  static _scanCodeToKeyCode(e) {
    const t = TM[e];
    if (t !== -1)
      return t;
    switch (e) {
      case 10:
        return 31;
      case 11:
        return 32;
      case 12:
        return 33;
      case 13:
        return 34;
      case 14:
        return 35;
      case 15:
        return 36;
      case 16:
        return 37;
      case 17:
        return 38;
      case 18:
        return 39;
      case 19:
        return 40;
      case 20:
        return 41;
      case 21:
        return 42;
      case 22:
        return 43;
      case 23:
        return 44;
      case 24:
        return 45;
      case 25:
        return 46;
      case 26:
        return 47;
      case 27:
        return 48;
      case 28:
        return 49;
      case 29:
        return 50;
      case 30:
        return 51;
      case 31:
        return 52;
      case 32:
        return 53;
      case 33:
        return 54;
      case 34:
        return 55;
      case 35:
        return 56;
      case 36:
        return 22;
      case 37:
        return 23;
      case 38:
        return 24;
      case 39:
        return 25;
      case 40:
        return 26;
      case 41:
        return 27;
      case 42:
        return 28;
      case 43:
        return 29;
      case 44:
        return 30;
      case 45:
        return 21;
      case 51:
        return 88;
      case 52:
        return 86;
      case 53:
        return 92;
      case 54:
        return 94;
      case 55:
        return 93;
      case 56:
        return 0;
      case 57:
        return 85;
      case 58:
        return 95;
      case 59:
        return 91;
      case 60:
        return 87;
      case 61:
        return 89;
      case 62:
        return 90;
      case 106:
        return 97;
    }
    return 0;
  }
  static _toKeyCodeChord(e) {
    if (!e)
      return null;
    if (e instanceof Hl)
      return e;
    const t = this._scanCodeToKeyCode(e.scanCode);
    return t === 0 ? null : new Hl(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, t);
  }
  static resolveKeybinding(e, t) {
    const i = zL(e.chords.map((n) => this._toKeyCodeChord(n)));
    return i.length > 0 ? [new YA(i, t)] : [];
  }
}
const Zf = We("labelService"), kq = We("progressService"), NB = class NB {
  constructor(e) {
    this.callback = e;
  }
  report(e) {
    this._value = e, this.callback(this._value);
  }
};
NB.None = Object.freeze({ report() {
} });
let Ic = NB;
const P_ = We("editorProgressService");
class Dq {
  constructor() {
    this._value = "", this._pos = 0;
  }
  reset(e) {
    return this._value = e, this._pos = 0, this;
  }
  next() {
    return this._pos += 1, this;
  }
  hasNext() {
    return this._pos < this._value.length - 1;
  }
  cmp(e) {
    const t = e.charCodeAt(0), i = this._value.charCodeAt(this._pos);
    return t - i;
  }
  value() {
    return this._value[this._pos];
  }
}
class Iq {
  constructor(e = !0) {
    this._caseSensitive = e;
  }
  reset(e) {
    return this._value = e, this._from = 0, this._to = 0, this.next();
  }
  hasNext() {
    return this._to < this._value.length;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._value.length; this._to++)
      if (this._value.charCodeAt(this._to) === 46)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? RM(e, this._value, 0, e.length, this._from, this._to) : D_(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class Mq {
  constructor(e = !0, t = !0) {
    this._splitOnBackslash = e, this._caseSensitive = t;
  }
  reset(e) {
    this._from = 0, this._to = 0, this._value = e, this._valueLen = e.length;
    for (let t = e.length - 1; t >= 0; t--, this._valueLen--) {
      const i = this._value.charCodeAt(t);
      if (!(i === 47 || this._splitOnBackslash && i === 92))
        break;
    }
    return this.next();
  }
  hasNext() {
    return this._to < this._valueLen;
  }
  next() {
    this._from = this._to;
    let e = !0;
    for (; this._to < this._valueLen; this._to++) {
      const t = this._value.charCodeAt(this._to);
      if (t === 47 || this._splitOnBackslash && t === 92)
        if (e)
          this._from++;
        else
          break;
      else
        e = !1;
    }
    return this;
  }
  cmp(e) {
    return this._caseSensitive ? RM(e, this._value, 0, e.length, this._from, this._to) : D_(e, this._value, 0, e.length, this._from, this._to);
  }
  value() {
    return this._value.substring(this._from, this._to);
  }
}
class Nq {
  constructor(e, t) {
    this._ignorePathCasing = e, this._ignoreQueryAndFragment = t, this._states = [], this._stateIdx = 0;
  }
  reset(e) {
    return this._value = e, this._states = [], this._value.scheme && this._states.push(
      1
      /* UriIteratorState.Scheme */
    ), this._value.authority && this._states.push(
      2
      /* UriIteratorState.Authority */
    ), this._value.path && (this._pathIterator = new Mq(!1, !this._ignorePathCasing(e)), this._pathIterator.reset(e.path), this._pathIterator.value() && this._states.push(
      3
      /* UriIteratorState.Path */
    )), this._ignoreQueryAndFragment(e) || (this._value.query && this._states.push(
      4
      /* UriIteratorState.Query */
    ), this._value.fragment && this._states.push(
      5
      /* UriIteratorState.Fragment */
    )), this._stateIdx = 0, this;
  }
  next() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() ? this._pathIterator.next() : this._stateIdx += 1, this;
  }
  hasNext() {
    return this._states[this._stateIdx] === 3 && this._pathIterator.hasNext() || this._stateIdx < this._states.length - 1;
  }
  cmp(e) {
    if (this._states[this._stateIdx] === 1)
      return ME(e, this._value.scheme);
    if (this._states[this._stateIdx] === 2)
      return ME(e, this._value.authority);
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.cmp(e);
    if (this._states[this._stateIdx] === 4)
      return LA(e, this._value.query);
    if (this._states[this._stateIdx] === 5)
      return LA(e, this._value.fragment);
    throw new Error();
  }
  value() {
    if (this._states[this._stateIdx] === 1)
      return this._value.scheme;
    if (this._states[this._stateIdx] === 2)
      return this._value.authority;
    if (this._states[this._stateIdx] === 3)
      return this._pathIterator.value();
    if (this._states[this._stateIdx] === 4)
      return this._value.query;
    if (this._states[this._stateIdx] === 5)
      return this._value.fragment;
    throw new Error();
  }
}
class Eb {
  constructor() {
    this.height = 1;
  }
  rotateLeft() {
    const e = this.right;
    return this.right = e.left, e.left = this, this.updateHeight(), e.updateHeight(), e;
  }
  rotateRight() {
    const e = this.left;
    return this.left = e.right, e.right = this, this.updateHeight(), e.updateHeight(), e;
  }
  updateHeight() {
    this.height = 1 + Math.max(this.heightLeft, this.heightRight);
  }
  balanceFactor() {
    return this.heightRight - this.heightLeft;
  }
  get heightLeft() {
    return this.left?.height ?? 0;
  }
  get heightRight() {
    return this.right?.height ?? 0;
  }
}
class wf {
  static forUris(e = () => !1, t = () => !1) {
    return new wf(new Nq(e, t));
  }
  static forStrings() {
    return new wf(new Dq());
  }
  static forConfigKeys() {
    return new wf(new Iq());
  }
  constructor(e) {
    this._iter = e;
  }
  clear() {
    this._root = void 0;
  }
  set(e, t) {
    const i = this._iter.reset(e);
    let n;
    this._root || (this._root = new Eb(), this._root.segment = i.value());
    const o = [];
    for (n = this._root; ; ) {
      const a = i.cmp(n.segment);
      if (a > 0)
        n.left || (n.left = new Eb(), n.left.segment = i.value()), o.push([-1, n]), n = n.left;
      else if (a < 0)
        n.right || (n.right = new Eb(), n.right.segment = i.value()), o.push([1, n]), n = n.right;
      else if (i.hasNext())
        i.next(), n.mid || (n.mid = new Eb(), n.mid.segment = i.value()), o.push([0, n]), n = n.mid;
      else
        break;
    }
    const r = n.value;
    n.value = t, n.key = e;
    for (let a = o.length - 1; a >= 0; a--) {
      const l = o[a][1];
      l.updateHeight();
      const c = l.balanceFactor();
      if (c < -1 || c > 1) {
        const d = o[a][0], h = o[a + 1][0];
        if (d === 1 && h === 1)
          o[a][1] = l.rotateLeft();
        else if (d === -1 && h === -1)
          o[a][1] = l.rotateRight();
        else if (d === 1 && h === -1)
          l.right = o[a + 1][1] = o[a + 1][1].rotateRight(), o[a][1] = l.rotateLeft();
        else if (d === -1 && h === 1)
          l.left = o[a + 1][1] = o[a + 1][1].rotateLeft(), o[a][1] = l.rotateRight();
        else
          throw new Error();
        if (a > 0)
          switch (o[a - 1][0]) {
            case -1:
              o[a - 1][1].left = o[a][1];
              break;
            case 1:
              o[a - 1][1].right = o[a][1];
              break;
            case 0:
              o[a - 1][1].mid = o[a][1];
              break;
          }
        else
          this._root = o[0][1];
      }
    }
    return r;
  }
  get(e) {
    return this._getNode(e)?.value;
  }
  _getNode(e) {
    const t = this._iter.reset(e);
    let i = this._root;
    for (; i; ) {
      const n = t.cmp(i.segment);
      if (n > 0)
        i = i.left;
      else if (n < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), i = i.mid;
      else
        break;
    }
    return i;
  }
  has(e) {
    const t = this._getNode(e);
    return !(t?.value === void 0 && t?.mid === void 0);
  }
  delete(e) {
    return this._delete(e, !1);
  }
  deleteSuperstr(e) {
    return this._delete(e, !0);
  }
  _delete(e, t) {
    const i = this._iter.reset(e), n = [];
    let o = this._root;
    for (; o; ) {
      const r = i.cmp(o.segment);
      if (r > 0)
        n.push([-1, o]), o = o.left;
      else if (r < 0)
        n.push([1, o]), o = o.right;
      else if (i.hasNext())
        i.next(), n.push([0, o]), o = o.mid;
      else
        break;
    }
    if (o) {
      if (t ? (o.left = void 0, o.mid = void 0, o.right = void 0, o.height = 1) : (o.key = void 0, o.value = void 0), !o.mid && !o.value)
        if (o.left && o.right) {
          const r = this._min(o.right);
          if (r.key) {
            const { key: a, value: l, segment: c } = r;
            this._delete(r.key, !1), o.key = a, o.value = l, o.segment = c;
          }
        } else {
          const r = o.left ?? o.right;
          if (n.length > 0) {
            const [a, l] = n[n.length - 1];
            switch (a) {
              case -1:
                l.left = r;
                break;
              case 0:
                l.mid = r;
                break;
              case 1:
                l.right = r;
                break;
            }
          } else
            this._root = r;
        }
      for (let r = n.length - 1; r >= 0; r--) {
        const a = n[r][1];
        a.updateHeight();
        const l = a.balanceFactor();
        if (l > 1 ? (a.right.balanceFactor() >= 0 || (a.right = a.right.rotateRight()), n[r][1] = a.rotateLeft()) : l < -1 && (a.left.balanceFactor() <= 0 || (a.left = a.left.rotateLeft()), n[r][1] = a.rotateRight()), r > 0)
          switch (n[r - 1][0]) {
            case -1:
              n[r - 1][1].left = n[r][1];
              break;
            case 1:
              n[r - 1][1].right = n[r][1];
              break;
            case 0:
              n[r - 1][1].mid = n[r][1];
              break;
          }
        else
          this._root = n[0][1];
      }
    }
  }
  _min(e) {
    for (; e.left; )
      e = e.left;
    return e;
  }
  findSubstr(e) {
    const t = this._iter.reset(e);
    let i = this._root, n;
    for (; i; ) {
      const o = t.cmp(i.segment);
      if (o > 0)
        i = i.left;
      else if (o < 0)
        i = i.right;
      else if (t.hasNext())
        t.next(), n = i.value || n, i = i.mid;
      else
        break;
    }
    return i && i.value || n;
  }
  findSuperstr(e) {
    return this._findSuperstrOrElement(e, !1);
  }
  _findSuperstrOrElement(e, t) {
    const i = this._iter.reset(e);
    let n = this._root;
    for (; n; ) {
      const o = i.cmp(n.segment);
      if (o > 0)
        n = n.left;
      else if (o < 0)
        n = n.right;
      else if (i.hasNext())
        i.next(), n = n.mid;
      else
        return n.mid ? this._entries(n.mid) : t ? n.value : void 0;
    }
  }
  forEach(e) {
    for (const [t, i] of this)
      e(i, t);
  }
  *[Symbol.iterator]() {
    yield* this._entries(this._root);
  }
  _entries(e) {
    const t = [];
    return this._dfsEntries(e, t), t[Symbol.iterator]();
  }
  _dfsEntries(e, t) {
    e && (e.left && this._dfsEntries(e.left, t), e.value && t.push([e.key, e.value]), e.mid && this._dfsEntries(e.mid, t), e.right && this._dfsEntries(e.right, t));
  }
}
const BC = We("contextService");
function UL(s) {
  const e = s;
  return typeof e?.id == "string" && _e.isUri(e.uri);
}
function Tq(s) {
  return typeof s?.id == "string" && !UL(s) && !Fq(s);
}
const Bq = { id: "empty-window" };
function Rq(s, e) {
  if (typeof s == "string" || typeof s > "u")
    return typeof s == "string" ? {
      id: Pc(s)
    } : Bq;
  const t = s;
  return t.configuration ? {
    id: t.id,
    configPath: t.configuration
  } : t.folders.length === 1 ? {
    id: t.id,
    uri: t.folders[0].uri
  } : {
    id: t.id
  };
}
function Fq(s) {
  const e = s;
  return typeof e?.id == "string" && _e.isUri(e.configPath);
}
class Oq {
  constructor(e, t) {
    this.raw = t, this.uri = e.uri, this.index = e.index, this.name = e.name;
  }
  toJSON() {
    return { uri: this.uri, name: this.name, index: this.index };
  }
}
const QL = "code-workspace";
f("codeWorkspace", "Code Workspace");
const D3 = "4064f6ec-cb38-4ad0-af64-ee6467e63c82";
function Pq(s) {
  return s.id === D3;
}
var Z2;
(function(s) {
  s.inspectTokensAction = f("inspectTokens", "Developer: Inspect Tokens");
})(Z2 || (Z2 = {}));
var eF;
(function(s) {
  s.gotoLineActionLabel = f("gotoLineActionLabel", "Go to Line/Column...");
})(eF || (eF = {}));
var tF;
(function(s) {
  s.helpQuickAccessActionLabel = f("helpQuickAccess", "Show all Quick Access Providers");
})(tF || (tF = {}));
var iF;
(function(s) {
  s.quickCommandActionLabel = f("quickCommandActionLabel", "Command Palette"), s.quickCommandHelp = f("quickCommandActionHelp", "Show And Run Commands");
})(iF || (iF = {}));
var nF;
(function(s) {
  s.quickOutlineActionLabel = f("quickOutlineActionLabel", "Go to Symbol..."), s.quickOutlineByCategoryActionLabel = f("quickOutlineByCategoryActionLabel", "Go to Symbol by Category...");
})(nF || (nF = {}));
var GL;
(function(s) {
  s.editorViewAccessibleLabel = f("editorViewAccessibleLabel", "Editor content");
})(GL || (GL = {}));
var sF;
(function(s) {
  s.toggleHighContrast = f("toggleHighContrast", "Toggle High Contrast Theme");
})(sF || (sF = {}));
var jL;
(function(s) {
  s.bulkEditServiceSummary = f("bulkEditServiceSummary", "Made {0} edits in {1} files");
})(jL || (jL = {}));
const Hq = We("workspaceTrustManagementService");
let em = [], ON = [], I3 = [];
function Lb(s, e = !1) {
  Wq(s, !1, e);
}
function Wq(s, e, t) {
  const i = Vq(s, e);
  em.push(i), i.userConfigured ? I3.push(i) : ON.push(i), t && !i.userConfigured && em.forEach((n) => {
    n.mime === i.mime || n.userConfigured || (i.extension && n.extension === i.extension && console.warn(`Overwriting extension <<${i.extension}>> to now point to mime <<${i.mime}>>`), i.filename && n.filename === i.filename && console.warn(`Overwriting filename <<${i.filename}>> to now point to mime <<${i.mime}>>`), i.filepattern && n.filepattern === i.filepattern && console.warn(`Overwriting filepattern <<${i.filepattern}>> to now point to mime <<${i.mime}>>`), i.firstline && n.firstline === i.firstline && console.warn(`Overwriting firstline <<${i.firstline}>> to now point to mime <<${i.mime}>>`));
  });
}
function Vq(s, e) {
  return {
    id: s.id,
    mime: s.mime,
    filename: s.filename,
    extension: s.extension,
    filepattern: s.filepattern,
    firstline: s.firstline,
    userConfigured: e,
    filenameLowercase: s.filename ? s.filename.toLowerCase() : void 0,
    extensionLowercase: s.extension ? s.extension.toLowerCase() : void 0,
    filepatternLowercase: s.filepattern ? z5(s.filepattern.toLowerCase()) : void 0,
    filepatternOnPath: s.filepattern ? s.filepattern.indexOf(di.sep) >= 0 : !1
  };
}
function zq() {
  em = em.filter((s) => s.userConfigured), ON = [];
}
function Uq(s, e) {
  return Qq(s, e).map((t) => t.id);
}
function Qq(s, e) {
  let t;
  if (s)
    switch (s.scheme) {
      case Ie.file:
        t = s.fsPath;
        break;
      case Ie.data: {
        t = ld.parseMetaData(s).get(ld.META_DATA_LABEL);
        break;
      }
      case Ie.vscodeNotebookCell:
        t = void 0;
        break;
      default:
        t = s.path;
    }
  if (!t)
    return [{ id: "unknown", mime: fl.unknown }];
  t = t.toLowerCase();
  const i = Pc(t), n = oF(t, i, I3);
  if (n)
    return [n, { id: Js, mime: fl.text }];
  const o = oF(t, i, ON);
  if (o)
    return [o, { id: Js, mime: fl.text }];
  if (e) {
    const r = Gq(e);
    if (r)
      return [r, { id: Js, mime: fl.text }];
  }
  return [{ id: "unknown", mime: fl.unknown }];
}
function oF(s, e, t) {
  let i, n, o;
  for (let r = t.length - 1; r >= 0; r--) {
    const a = t[r];
    if (e === a.filenameLowercase) {
      i = a;
      break;
    }
    if (a.filepattern && (!n || a.filepattern.length > n.filepattern.length)) {
      const l = a.filepatternOnPath ? s : e;
      a.filepatternLowercase?.(l) && (n = a);
    }
    a.extension && (!o || a.extension.length > o.extension.length) && e.endsWith(a.extensionLowercase) && (o = a);
  }
  if (i)
    return i;
  if (n)
    return n;
  if (o)
    return o;
}
function Gq(s) {
  if (zM(s) && (s = s.substr(1)), s.length > 0)
    for (let e = em.length - 1; e >= 0; e--) {
      const t = em[e];
      if (!t.firstline)
        continue;
      const i = s.match(t.firstline);
      if (i && i.length > 0)
        return t;
    }
}
const kb = Object.prototype.hasOwnProperty, rF = "vs.editor.nullLanguage";
class jq {
  constructor() {
    this._languageIdToLanguage = [], this._languageToLanguageId = /* @__PURE__ */ new Map(), this._register(
      rF,
      0
      /* LanguageId.Null */
    ), this._register(
      Js,
      1
      /* LanguageId.PlainText */
    ), this._nextLanguageId = 2;
  }
  _register(e, t) {
    this._languageIdToLanguage[t] = e, this._languageToLanguageId.set(e, t);
  }
  register(e) {
    if (this._languageToLanguageId.has(e))
      return;
    const t = this._nextLanguageId++;
    this._register(e, t);
  }
  encodeLanguageId(e) {
    return this._languageToLanguageId.get(e) || 0;
  }
  decodeLanguageId(e) {
    return this._languageIdToLanguage[e] || rF;
  }
}
const uA = class uA extends V {
  constructor(e = !0, t = !1) {
    super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, uA.instanceCount++, this._warnOnOverwrite = t, this.languageIdCodec = new jq(), this._dynamicLanguages = [], this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, e && (this._initializeFromRegistry(), this._register(Qf.onDidChangeLanguages((i) => {
      this._initializeFromRegistry();
    })));
  }
  dispose() {
    uA.instanceCount--, super.dispose();
  }
  _initializeFromRegistry() {
    this._languages = {}, this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, zq();
    const e = [].concat(Qf.getLanguages()).concat(this._dynamicLanguages);
    this._registerLanguages(e);
  }
  _registerLanguages(e) {
    for (const t of e)
      this._registerLanguage(t);
    this._mimeTypesMap = {}, this._nameMap = {}, this._lowercaseNameMap = {}, Object.keys(this._languages).forEach((t) => {
      const i = this._languages[t];
      i.name && (this._nameMap[i.name] = i.identifier), i.aliases.forEach((n) => {
        this._lowercaseNameMap[n.toLowerCase()] = i.identifier;
      }), i.mimetypes.forEach((n) => {
        this._mimeTypesMap[n] = i.identifier;
      });
    }), ji.as(Wu.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds()), this._onDidChange.fire();
  }
  _registerLanguage(e) {
    const t = e.id;
    let i;
    kb.call(this._languages, t) ? i = this._languages[t] : (this.languageIdCodec.register(t), i = {
      identifier: t,
      name: null,
      mimetypes: [],
      aliases: [],
      extensions: [],
      filenames: [],
      configurationFiles: [],
      icons: []
    }, this._languages[t] = i), this._mergeLanguage(i, e);
  }
  _mergeLanguage(e, t) {
    const i = t.id;
    let n = null;
    if (Array.isArray(t.mimetypes) && t.mimetypes.length > 0 && (e.mimetypes.push(...t.mimetypes), n = t.mimetypes[0]), n || (n = `text/x-${i}`, e.mimetypes.push(n)), Array.isArray(t.extensions)) {
      t.configuration ? e.extensions = t.extensions.concat(e.extensions) : e.extensions = e.extensions.concat(t.extensions);
      for (const a of t.extensions)
        Lb({ id: i, mime: n, extension: a }, this._warnOnOverwrite);
    }
    if (Array.isArray(t.filenames))
      for (const a of t.filenames)
        Lb({ id: i, mime: n, filename: a }, this._warnOnOverwrite), e.filenames.push(a);
    if (Array.isArray(t.filenamePatterns))
      for (const a of t.filenamePatterns)
        Lb({ id: i, mime: n, filepattern: a }, this._warnOnOverwrite);
    if (typeof t.firstLine == "string" && t.firstLine.length > 0) {
      let a = t.firstLine;
      a.charAt(0) !== "^" && (a = "^" + a);
      try {
        const l = new RegExp(a);
        M7(l) || Lb({ id: i, mime: n, firstline: l }, this._warnOnOverwrite);
      } catch (l) {
        console.warn(`[${t.id}]: Invalid regular expression \`${a}\`: `, l);
      }
    }
    e.aliases.push(i);
    let o = null;
    if (typeof t.aliases < "u" && Array.isArray(t.aliases) && (t.aliases.length === 0 ? o = [null] : o = t.aliases), o !== null)
      for (const a of o)
        !a || a.length === 0 || e.aliases.push(a);
    const r = o !== null && o.length > 0;
    if (!(r && o[0] === null)) {
      const a = (r ? o[0] : null) || i;
      (r || !e.name) && (e.name = a);
    }
    t.configuration && e.configurationFiles.push(t.configuration), t.icon && e.icons.push(t.icon);
  }
  isRegisteredLanguageId(e) {
    return e ? kb.call(this._languages, e) : !1;
  }
  getRegisteredLanguageIds() {
    return Object.keys(this._languages);
  }
  getLanguageIdByLanguageName(e) {
    const t = e.toLowerCase();
    return kb.call(this._lowercaseNameMap, t) ? this._lowercaseNameMap[t] : null;
  }
  getLanguageIdByMimeType(e) {
    return e && kb.call(this._mimeTypesMap, e) ? this._mimeTypesMap[e] : null;
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    return !e && !t ? [] : Uq(e, t);
  }
};
uA.instanceCount = 0;
let YL = uA;
const Zo = (s, e) => s === e;
function Yq(s = Zo) {
  return (e, t) => pi(e, t, s);
}
function aF(s, e, t) {
  {
    const i = s;
    return (n, o) => n == null || o === void 0 || o === null ? o === n : i(n, o);
  }
}
class Vn {
  constructor(e, t, i) {
    this.owner = e, this.debugNameSource = t, this.referenceFn = i;
  }
  getDebugName(e) {
    return Kq(e, this);
  }
}
const lF = /* @__PURE__ */ new Map(), KL = /* @__PURE__ */ new WeakMap();
function Kq(s, e) {
  const t = KL.get(s);
  if (t)
    return t;
  const i = Jq(s, e);
  if (i) {
    let n = lF.get(i) ?? 0;
    n++, lF.set(i, n);
    const o = n === 1 ? i : `${i}#${n}`;
    return KL.set(s, o), o;
  }
}
function Jq(s, e) {
  const t = KL.get(s);
  if (t)
    return t;
  const i = e.owner ? $q(e.owner) + "." : "";
  let n;
  const o = e.debugNameSource;
  if (o !== void 0)
    if (typeof o == "function") {
      if (n = o(), n !== void 0)
        return i + n;
    } else
      return i + o;
  const r = e.referenceFn;
  if (r !== void 0 && (n = PN(r), n !== void 0))
    return i + n;
  if (e.owner !== void 0) {
    const a = qq(e.owner, s);
    if (a !== void 0)
      return i + a;
  }
}
function qq(s, e) {
  for (const t in s)
    if (s[t] === e)
      return t;
}
const cF = /* @__PURE__ */ new Map(), dF = /* @__PURE__ */ new WeakMap();
function $q(s) {
  const e = dF.get(s);
  if (e)
    return e;
  const t = Xq(s);
  let i = cF.get(t) ?? 0;
  i++, cF.set(t, i);
  const n = i === 1 ? t : `${t}#${i}`;
  return dF.set(s, n), n;
}
function Xq(s) {
  const e = s.constructor;
  return e ? e.name : "Object";
}
function PN(s) {
  const e = s.toString(), i = /\/\*\*\s*@description\s*([^*]*)\*\//.exec(e);
  return (i ? i[1] : void 0)?.trim();
}
let Zq;
function M3() {
  return Zq;
}
let N3;
function e$(s) {
  N3 = s;
}
let T3;
function t$(s) {
  T3 = s;
}
let JL;
function i$(s) {
  JL = s;
}
class B3 {
  get TChange() {
    return null;
  }
  reportChanges() {
    this.get();
  }
  /** @sealed */
  read(e) {
    return e ? e.readObservable(this) : this.get();
  }
  map(e, t) {
    const i = t === void 0 ? void 0 : e, n = t === void 0 ? e : t;
    return JL({
      owner: i,
      debugName: () => {
        const o = PN(n);
        if (o !== void 0)
          return o;
        const a = /^\s*\(?\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*\)?\s*=>\s*\1(?:\??)\.([a-zA-Z_$][a-zA-Z_$0-9]*)\s*$/.exec(n.toString());
        if (a)
          return `${this.debugName}.${a[2]}`;
        if (!i)
          return `${this.debugName} (mapped)`;
      },
      debugReferenceFn: n
    }, (o) => n(this.read(o), o));
  }
  /**
   * @sealed
   * Converts an observable of an observable value into a direct observable of the value.
  */
  flatten() {
    return JL({
      owner: void 0,
      debugName: () => `${this.debugName} (flattened)`
    }, (e) => this.read(e).read(e));
  }
  recomputeInitiallyAndOnChange(e, t) {
    return e.add(N3(this, t)), this;
  }
  /**
   * Ensures that this observable is observed. This keeps the cache alive.
   * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).
   * Use `recomputeInitiallyAndOnChange` for eager evaluation.
   */
  keepObserved(e) {
    return e.add(T3(this)), this;
  }
}
class Sm extends B3 {
  constructor() {
    super(...arguments), this.observers = /* @__PURE__ */ new Set();
  }
  addObserver(e) {
    const t = this.observers.size;
    this.observers.add(e), t === 0 && this.onFirstObserverAdded();
  }
  removeObserver(e) {
    this.observers.delete(e) && this.observers.size === 0 && this.onLastObserverRemoved();
  }
  onFirstObserverAdded() {
  }
  onLastObserverRemoved() {
  }
}
function xi(s, e) {
  const t = new H_(s, e);
  try {
    s(t);
  } finally {
    t.finish();
  }
}
let Db;
function mp(s) {
  if (Db)
    s(Db);
  else {
    const e = new H_(s, void 0);
    Db = e;
    try {
      s(e);
    } finally {
      e.finish(), Db = void 0;
    }
  }
}
function HN(s, e, t) {
  s ? e(s) : xi(e, t);
}
class H_ {
  constructor(e, t) {
    this._fn = e, this._getDebugName = t, this.updatingObservers = [];
  }
  getDebugName() {
    return this._getDebugName ? this._getDebugName() : PN(this._fn);
  }
  updateObserver(e, t) {
    this.updatingObservers.push({ observer: e, observable: t }), e.beginUpdate(t);
  }
  finish() {
    const e = this.updatingObservers;
    for (let t = 0; t < e.length; t++) {
      const { observer: i, observable: n } = e[t];
      i.endUpdate(n);
    }
    this.updatingObservers = null;
  }
}
function ot(s, e) {
  let t;
  return typeof s == "string" ? t = new Vn(void 0, s, void 0) : t = new Vn(s, void 0, void 0), new WN(t, e, Zo);
}
class WN extends Sm {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "ObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._value = t;
  }
  get() {
    return this._value;
  }
  set(e, t, i) {
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new H_(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      const o = this._value;
      this._setValue(e), M3()?.handleObservableChanged(this, { oldValue: o, newValue: e, change: i, didChange: !0, hadValue: !0 });
      for (const r of this.observers)
        t.updateObserver(r, this), r.handleChange(this, i);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function R3(s, e) {
  let t;
  return typeof s == "string" ? t = new Vn(void 0, s, void 0) : t = new Vn(s, void 0, void 0), new n$(t, e, Zo);
}
class n$ extends WN {
  _setValue(e) {
    this._value !== e && (this._value && this._value.dispose(), this._value = e);
  }
  dispose() {
    this._value?.dispose();
  }
}
function De(s, e) {
  return e !== void 0 ? new tm(new Vn(s, void 0, e), e, void 0, void 0, void 0, Zo) : new tm(new Vn(void 0, void 0, s), s, void 0, void 0, void 0, Zo);
}
function VN(s, e, t) {
  return new s$(new Vn(s, void 0, e), e, void 0, void 0, void 0, Zo, t);
}
function iS(s, e) {
  return new tm(new Vn(s.owner, s.debugName, s.debugReferenceFn), e, void 0, void 0, s.onLastObserverRemoved, s.equalsFn ?? Zo);
}
i$(iS);
function Uu(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  const n = new X();
  return new tm(new Vn(i, void 0, t), (o) => (n.clear(), t(o, n)), void 0, void 0, () => n.dispose(), Zo);
}
function Zr(s, e) {
  let t, i;
  e === void 0 ? (t = s, i = void 0) : (i = s, t = e);
  let n;
  return new tm(new Vn(i, void 0, t), (o) => {
    n ? n.clear() : n = new X();
    const r = t(o);
    return r && n.add(r), r;
  }, void 0, void 0, () => {
    n && (n.dispose(), n = void 0);
  }, Zo);
}
class tm extends Sm {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n, o = void 0, r) {
    super(), this._debugNameData = e, this._computeFn = t, this.createChangeSummary = i, this._handleChange = n, this._handleLastObserverRemoved = o, this._equalityComparator = r, this.state = 0, this.value = void 0, this.updateCount = 0, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = void 0, this.changeSummary = this.createChangeSummary?.();
  }
  onLastObserverRemoved() {
    this.state = 0, this.value = void 0;
    for (const e of this.dependencies)
      e.removeObserver(this);
    this.dependencies.clear(), this._handleLastObserverRemoved?.();
  }
  get() {
    if (this.observers.size === 0) {
      const e = this._computeFn(this, this.createChangeSummary?.());
      return this.onLastObserverRemoved(), e;
    } else {
      do {
        if (this.state === 1) {
          for (const e of this.dependencies)
            if (e.reportChanges(), this.state === 2)
              break;
        }
        this.state === 1 && (this.state = 3), this._recomputeIfNeeded();
      } while (this.state !== 3);
      return this.value;
    }
  }
  _recomputeIfNeeded() {
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e;
    const t = this.state !== 0, i = this.value;
    this.state = 3;
    const n = this.changeSummary;
    this.changeSummary = this.createChangeSummary?.();
    try {
      this.value = this._computeFn(this, n);
    } finally {
      for (const r of this.dependenciesToBeRemoved)
        r.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
    if (t && !this._equalityComparator(i, this.value))
      for (const r of this.observers)
        r.handleChange(this, void 0);
  }
  toString() {
    return `LazyDerived<${this.debugName}>`;
  }
  // IObserver Implementation
  beginUpdate(e) {
    this.updateCount++;
    const t = this.updateCount === 1;
    if (this.state === 3 && (this.state = 1, !t))
      for (const i of this.observers)
        i.handlePossibleChange(this);
    if (t)
      for (const i of this.observers)
        i.beginUpdate(this);
  }
  endUpdate(e) {
    if (this.updateCount--, this.updateCount === 0) {
      const t = [...this.observers];
      for (const i of t)
        i.endUpdate(this);
    }
    _u(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    if (this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      this.state = 1;
      for (const t of this.observers)
        t.handlePossibleChange(this);
    }
  }
  handleChange(e, t) {
    if (this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e)) {
      const i = this._handleChange ? this._handleChange({
        changedObservable: e,
        change: t,
        didChange: (o) => o === e
      }, this.changeSummary) : !0, n = this.state === 3;
      if (i && (this.state === 1 || n) && (this.state = 2, n))
        for (const o of this.observers)
          o.handlePossibleChange(this);
    }
  }
  // IReader Implementation
  readObservable(e) {
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this.updateCount > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this.updateCount > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
}
class s$ extends tm {
  constructor(e, t, i, n, o = void 0, r, a) {
    super(e, t, i, n, o, r), this.set = a;
  }
}
function et(s) {
  return new oS(new Vn(void 0, void 0, s), s, void 0, void 0);
}
function nS(s, e) {
  return new oS(new Vn(s.owner, s.debugName, s.debugReferenceFn ?? e), e, void 0, void 0);
}
function sS(s, e) {
  return new oS(new Vn(s.owner, s.debugName, s.debugReferenceFn ?? e), e, s.createEmptyChangeSummary, s.handleChange);
}
function Yo(s) {
  const e = new X(), t = nS({
    owner: void 0,
    debugName: void 0,
    debugReferenceFn: s
  }, (i) => {
    e.clear(), s(i, e);
  });
  return we(() => {
    t.dispose(), e.dispose();
  });
}
class oS {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "(anonymous)";
  }
  constructor(e, t, i, n) {
    this._debugNameData = e, this._runFn = t, this.createChangeSummary = i, this._handleChange = n, this.state = 2, this.updateCount = 0, this.disposed = !1, this.dependencies = /* @__PURE__ */ new Set(), this.dependenciesToBeRemoved = /* @__PURE__ */ new Set(), this.changeSummary = this.createChangeSummary?.(), this._runIfNeeded();
  }
  dispose() {
    this.disposed = !0;
    for (const e of this.dependencies)
      e.removeObserver(this);
    this.dependencies.clear();
  }
  _runIfNeeded() {
    if (this.state === 3)
      return;
    const e = this.dependenciesToBeRemoved;
    this.dependenciesToBeRemoved = this.dependencies, this.dependencies = e, this.state = 3;
    const t = this.disposed;
    try {
      if (!t) {
        M3()?.handleAutorunTriggered(this);
        const i = this.changeSummary;
        this.changeSummary = this.createChangeSummary?.(), this._runFn(this, i);
      }
    } finally {
      for (const i of this.dependenciesToBeRemoved)
        i.removeObserver(this);
      this.dependenciesToBeRemoved.clear();
    }
  }
  toString() {
    return `Autorun<${this.debugName}>`;
  }
  // IObserver implementation
  beginUpdate() {
    this.state === 3 && (this.state = 1), this.updateCount++;
  }
  endUpdate() {
    if (this.updateCount === 1)
      do {
        if (this.state === 1) {
          this.state = 3;
          for (const e of this.dependencies)
            if (e.reportChanges(), this.state === 2)
              break;
        }
        this._runIfNeeded();
      } while (this.state !== 3);
    this.updateCount--, _u(() => this.updateCount >= 0);
  }
  handlePossibleChange(e) {
    this.state === 3 && this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (this.state = 1);
  }
  handleChange(e, t) {
    this.dependencies.has(e) && !this.dependenciesToBeRemoved.has(e) && (!this._handleChange || this._handleChange({
      changedObservable: e,
      change: t,
      didChange: (n) => n === e
    }, this.changeSummary)) && (this.state = 2);
  }
  // IReader implementation
  readObservable(e) {
    if (this.disposed)
      return e.get();
    e.addObserver(this);
    const t = e.get();
    return this.dependencies.add(e), this.dependenciesToBeRemoved.delete(e), t;
  }
}
(function(s) {
  s.Observer = oS;
})(et || (et = {}));
function RC(s) {
  return new o$(s);
}
class o$ extends B3 {
  constructor(e) {
    super(), this.value = e;
  }
  get debugName() {
    return this.toString();
  }
  get() {
    return this.value;
  }
  addObserver(e) {
  }
  removeObserver(e) {
  }
  toString() {
    return `Const: ${this.value}`;
  }
}
function $t(...s) {
  let e, t, i;
  return s.length === 3 ? [e, t, i] = s : [t, i] = s, new Pg(new Vn(e, void 0, i), t, i, () => Pg.globalTransaction, Zo);
}
class Pg extends Sm {
  constructor(e, t, i, n, o) {
    super(), this._debugNameData = e, this.event = t, this._getValue = i, this._getTransaction = n, this._equalityComparator = o, this.hasValue = !1, this.handleEvent = (r) => {
      const a = this._getValue(r), l = this.value;
      (!this.hasValue || !this._equalityComparator(l, a)) && (this.value = a, this.hasValue && HN(this._getTransaction(), (d) => {
        for (const h of this.observers)
          d.updateObserver(h, this), h.handleChange(this, void 0);
      }, () => {
        const d = this.getDebugName();
        return "Event fired" + (d ? `: ${d}` : "");
      }), this.hasValue = !0);
    };
  }
  getDebugName() {
    return this._debugNameData.getDebugName(this);
  }
  get debugName() {
    const e = this.getDebugName();
    return "From Event" + (e ? `: ${e}` : "");
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0, this.hasValue = !1, this.value = void 0;
  }
  get() {
    return this.subscription ? (this.hasValue || this.handleEvent(void 0), this.value) : this._getValue(void 0);
  }
}
(function(s) {
  s.Observer = Pg;
  function e(t, i) {
    let n = !1;
    Pg.globalTransaction === void 0 && (Pg.globalTransaction = t, n = !0);
    try {
      i();
    } finally {
      n && (Pg.globalTransaction = void 0);
    }
  }
  s.batchEventsGlobally = e;
})($t || ($t = {}));
function fo(s, e) {
  return new r$(s, e);
}
class r$ extends Sm {
  constructor(e, t) {
    super(), this.debugName = e, this.event = t, this.handleEvent = () => {
      xi((i) => {
        for (const n of this.observers)
          i.updateObserver(n, this), n.handleChange(this, void 0);
      }, () => this.debugName);
    };
  }
  onFirstObserverAdded() {
    this.subscription = this.event(this.handleEvent);
  }
  onLastObserverRemoved() {
    this.subscription.dispose(), this.subscription = void 0;
  }
  get() {
  }
}
function zN(s) {
  return typeof s == "string" ? new hF(s) : new hF(void 0, s);
}
class hF extends Sm {
  get debugName() {
    return new Vn(this._owner, this._debugName, void 0).getDebugName(this) ?? "Observable Signal";
  }
  toString() {
    return this.debugName;
  }
  constructor(e, t) {
    super(), this._debugName = e, this._owner = t;
  }
  trigger(e, t) {
    if (!e) {
      xi((i) => {
        this.trigger(i, t);
      }, () => `Trigger signal ${this.debugName}`);
      return;
    }
    for (const i of this.observers)
      e.updateObserver(i, this), i.handleChange(this, t);
  }
  get() {
  }
}
function a$(s) {
  const e = new F3(!1, void 0);
  return s.addObserver(e), we(() => {
    s.removeObserver(e);
  });
}
t$(a$);
function rS(s, e) {
  const t = new F3(!0, e);
  return s.addObserver(t), e ? e(s.get()) : s.reportChanges(), we(() => {
    s.removeObserver(t);
  });
}
e$(rS);
class F3 {
  constructor(e, t) {
    this._forceRecompute = e, this._handleValue = t, this._counter = 0;
  }
  beginUpdate(e) {
    this._counter++;
  }
  endUpdate(e) {
    this._counter--, this._counter === 0 && this._forceRecompute && (this._handleValue ? this._handleValue(e.get()) : e.reportChanges());
  }
  handlePossibleChange(e) {
  }
  handleChange(e, t) {
  }
}
function O3(s, e) {
  let t;
  return iS({ owner: s, debugReferenceFn: e }, (n) => (t = e(n, t), t));
}
function l$(s, e) {
  return O3(s, (t, i) => i ?? e(t));
}
function c$(s, e, t, i) {
  return e || (e = (n) => n != null), new Promise((n, o) => {
    let r = !0, a = !1;
    const l = s.map((d) => ({
      isFinished: e(d),
      error: !1,
      state: d
    })), c = et((d) => {
      const { isFinished: h, error: u, state: g } = l.read(d);
      (h || u) && (r ? a = !0 : c.dispose(), u ? o(u === !0 ? g : u) : n(g));
    });
    r = !1, a && c.dispose();
  });
}
class d$ extends Sm {
  get debugName() {
    return this._debugNameData.getDebugName(this) ?? "LazyObservableValue";
  }
  constructor(e, t, i) {
    super(), this._debugNameData = e, this._equalityComparator = i, this._isUpToDate = !0, this._deltas = [], this._updateCounter = 0, this._value = t;
  }
  get() {
    return this._update(), this._value;
  }
  _update() {
    if (!this._isUpToDate)
      if (this._isUpToDate = !0, this._deltas.length > 0) {
        for (const e of this.observers)
          for (const t of this._deltas)
            e.handleChange(this, t);
        this._deltas.length = 0;
      } else
        for (const e of this.observers)
          e.handleChange(this, void 0);
  }
  _beginUpdate() {
    if (this._updateCounter++, this._updateCounter === 1)
      for (const e of this.observers)
        e.beginUpdate(this);
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      this._update();
      const e = [...this.observers];
      for (const t of e)
        t.endUpdate(this);
    }
  }
  addObserver(e) {
    const t = !this.observers.has(e) && this._updateCounter > 0;
    super.addObserver(e), t && e.beginUpdate(this);
  }
  removeObserver(e) {
    const t = this.observers.has(e) && this._updateCounter > 0;
    super.removeObserver(e), t && e.endUpdate(this);
  }
  set(e, t, i) {
    if (i === void 0 && this._equalityComparator(this._value, e))
      return;
    let n;
    t || (t = n = new H_(() => {
    }, () => `Setting ${this.debugName}`));
    try {
      if (this._isUpToDate = !1, this._setValue(e), i !== void 0 && this._deltas.push(i), t.updateObserver({
        beginUpdate: () => this._beginUpdate(),
        endUpdate: () => this._endUpdate(),
        handleChange: (o, r) => {
        },
        handlePossibleChange: (o) => {
        }
      }, this), this._updateCounter > 1)
        for (const o of this.observers)
          o.handlePossibleChange(this);
    } finally {
      n && n.finish();
    }
  }
  toString() {
    return `${this.debugName}: ${this._value}`;
  }
  _setValue(e) {
    this._value = e;
  }
}
function qL(s, e) {
  return s.lazy ? new d$(new Vn(s.owner, s.debugName, void 0), e, s.equalsFn ?? Zo) : new WN(new Vn(s.owner, s.debugName, void 0), e, s.equalsFn ?? Zo);
}
const gA = class gA extends V {
  constructor(e = !1) {
    super(), this._onDidRequestBasicLanguageFeatures = this._register(new B()), this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event, this._onDidRequestRichLanguageFeatures = this._register(new B()), this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event, this._onDidChange = this._register(new B({
      leakWarningThreshold: 200
      /* https://github.com/microsoft/vscode/issues/119968 */
    })), this.onDidChange = this._onDidChange.event, this._requestedBasicLanguages = /* @__PURE__ */ new Set(), this._requestedRichLanguages = /* @__PURE__ */ new Set(), gA.instanceCount++, this._registry = this._register(new YL(!0, e)), this.languageIdCodec = this._registry.languageIdCodec, this._register(this._registry.onDidChange(() => this._onDidChange.fire()));
  }
  dispose() {
    gA.instanceCount--, super.dispose();
  }
  isRegisteredLanguageId(e) {
    return this._registry.isRegisteredLanguageId(e);
  }
  getLanguageIdByLanguageName(e) {
    return this._registry.getLanguageIdByLanguageName(e);
  }
  getLanguageIdByMimeType(e) {
    return this._registry.getLanguageIdByMimeType(e);
  }
  guessLanguageIdByFilepathOrFirstLine(e, t) {
    const i = this._registry.guessLanguageIdByFilepathOrFirstLine(e, t);
    return vM(i, null);
  }
  createById(e) {
    return new uF(this.onDidChange, () => this._createAndGetLanguageIdentifier(e));
  }
  createByFilepathOrFirstLine(e, t) {
    return new uF(this.onDidChange, () => {
      const i = this.guessLanguageIdByFilepathOrFirstLine(e, t);
      return this._createAndGetLanguageIdentifier(i);
    });
  }
  _createAndGetLanguageIdentifier(e) {
    return (!e || !this.isRegisteredLanguageId(e)) && (e = Js), e;
  }
  requestBasicLanguageFeatures(e) {
    this._requestedBasicLanguages.has(e) || (this._requestedBasicLanguages.add(e), this._onDidRequestBasicLanguageFeatures.fire(e));
  }
  requestRichLanguageFeatures(e) {
    this._requestedRichLanguages.has(e) || (this._requestedRichLanguages.add(e), this.requestBasicLanguageFeatures(e), ci.getOrCreate(e), this._onDidRequestRichLanguageFeatures.fire(e));
  }
};
gA.instanceCount = 0;
let $L = gA;
class uF {
  constructor(e, t) {
    this._value = $t(this, e, () => t()), this.onDidChange = te.fromObservable(this._value);
  }
  get languageId() {
    return this._value.get();
  }
}
const P3 = {
  /**
   * Typically transfer type for copy/paste transfers.
   */
  TEXT: fl.text
}, h$ = () => ({
  get delay() {
    return -1;
  },
  dispose: () => {
  },
  showHover: () => {
  }
});
let aS = h$;
const u$ = new Br(() => aS("mouse", !1)), g$ = new Br(() => aS("element", !1));
function f$(s) {
  aS = s;
}
function Ls(s) {
  return s === "element" ? g$.value : u$.value;
}
function im() {
  return aS("element", !0);
}
let H3 = {
  showHover: () => {
  },
  hideHover: () => {
  },
  showAndFocusLastHover: () => {
  },
  setupManagedHover: () => null,
  showManagedHover: () => {
  }
};
function m$(s) {
  H3 = s;
}
function Oa() {
  return H3;
}
class p$ {
  constructor(e) {
    this.spliceables = e;
  }
  splice(e, t, i) {
    this.spliceables.forEach((n) => n.splice(e, t, i));
  }
}
class Nd extends Error {
  constructor(e, t) {
    super(`ListError [${e}] ${t}`);
  }
}
function gF(s, e) {
  const t = [];
  for (const i of e) {
    if (s.start >= i.range.end)
      continue;
    if (s.end < i.range.start)
      break;
    const n = on.intersect(s, i.range);
    on.isEmpty(n) || t.push({
      range: n,
      size: i.size
    });
  }
  return t;
}
function XL({ start: s, end: e }, t) {
  return { start: s + t, end: e + t };
}
function A$(s) {
  const e = [];
  let t = null;
  for (const i of s) {
    const n = i.range.start, o = i.range.end, r = i.size;
    if (t && r === t.size) {
      t.range.end = o;
      continue;
    }
    t = { range: { start: n, end: o }, size: r }, e.push(t);
  }
  return e;
}
function _$(...s) {
  return A$(s.reduce((e, t) => e.concat(t), []));
}
class b$ {
  get paddingTop() {
    return this._paddingTop;
  }
  set paddingTop(e) {
    this._size = this._size + e - this._paddingTop, this._paddingTop = e;
  }
  constructor(e) {
    this.groups = [], this._size = 0, this._paddingTop = 0, this._paddingTop = e ?? 0, this._size = this._paddingTop;
  }
  splice(e, t, i = []) {
    const n = i.length - t, o = gF({ start: 0, end: e }, this.groups), r = gF({ start: e + t, end: Number.POSITIVE_INFINITY }, this.groups).map((l) => ({ range: XL(l.range, n), size: l.size })), a = i.map((l, c) => ({
      range: { start: e + c, end: e + c + 1 },
      size: l.size
    }));
    this.groups = _$(o, a, r), this._size = this._paddingTop + this.groups.reduce((l, c) => l + c.size * (c.range.end - c.range.start), 0);
  }
  /**
   * Returns the number of items in the range map.
   */
  get count() {
    const e = this.groups.length;
    return e ? this.groups[e - 1].range.end : 0;
  }
  /**
   * Returns the sum of the sizes of all items in the range map.
   */
  get size() {
    return this._size;
  }
  /**
   * Returns the index of the item at the given position.
   */
  indexAt(e) {
    if (e < 0)
      return -1;
    if (e < this._paddingTop)
      return 0;
    let t = 0, i = this._paddingTop;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o * n.size;
      if (e < r)
        return t + Math.floor((e - i) / n.size);
      t += o, i = r;
    }
    return t;
  }
  /**
   * Returns the index of the item right after the item at the
   * index of the given position.
   */
  indexAfter(e) {
    return Math.min(this.indexAt(e) + 1, this.count);
  }
  /**
   * Returns the start position of the item at the given index.
   */
  positionAt(e) {
    if (e < 0)
      return -1;
    let t = 0, i = 0;
    for (const n of this.groups) {
      const o = n.range.end - n.range.start, r = i + o;
      if (e < r)
        return this._paddingTop + t + (e - i) * n.size;
      t += o * n.size, i = r;
    }
    return -1;
  }
}
class w$ {
  constructor(e) {
    this.renderers = e, this.cache = /* @__PURE__ */ new Map(), this.transactionNodesPendingRemoval = /* @__PURE__ */ new Set(), this.inTransaction = !1;
  }
  /**
   * Returns a row either by creating a new one or reusing
   * a previously released row which shares the same templateId.
   *
   * @returns A row and `isReusingConnectedDomNode` if the row's node is already in the dom in a stale position.
   */
  alloc(e) {
    let t = this.getTemplateCache(e).pop(), i = !1;
    if (t)
      i = this.transactionNodesPendingRemoval.has(t.domNode), i && this.transactionNodesPendingRemoval.delete(t.domNode);
    else {
      const n = de(".monaco-list-row"), r = this.getRenderer(e).renderTemplate(n);
      t = { domNode: n, templateId: e, templateData: r };
    }
    return { row: t, isReusingConnectedDomNode: i };
  }
  /**
   * Releases the row for eventual reuse.
   */
  release(e) {
    e && this.releaseRow(e);
  }
  /**
   * Begin a set of changes that use the cache. This lets us skip work when a row is removed and then inserted again.
   */
  transact(e) {
    if (this.inTransaction)
      throw new Error("Already in transaction");
    this.inTransaction = !0;
    try {
      e();
    } finally {
      for (const t of this.transactionNodesPendingRemoval)
        this.doRemoveNode(t);
      this.transactionNodesPendingRemoval.clear(), this.inTransaction = !1;
    }
  }
  releaseRow(e) {
    const { domNode: t, templateId: i } = e;
    t && (this.inTransaction ? this.transactionNodesPendingRemoval.add(t) : this.doRemoveNode(t)), this.getTemplateCache(i).push(e);
  }
  doRemoveNode(e) {
    e.classList.remove("scrolling"), e.remove();
  }
  getTemplateCache(e) {
    let t = this.cache.get(e);
    return t || (t = [], this.cache.set(e, t)), t;
  }
  dispose() {
    this.cache.forEach((e, t) => {
      for (const i of e)
        this.getRenderer(t).disposeTemplate(i.templateData), i.templateData = null;
    }), this.cache.clear(), this.transactionNodesPendingRemoval.clear();
  }
  getRenderer(e) {
    const t = this.renderers.get(e);
    if (!t)
      throw new Error(`No renderer found for ${e}`);
    return t;
  }
}
var Kl = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const Td = {
  CurrentDragAndDropData: void 0
}, jr = {
  useShadows: !0,
  verticalScrollMode: 1,
  setRowLineHeight: !0,
  setRowHeight: !0,
  supportDynamicHeights: !1,
  dnd: {
    getDragElements(s) {
      return [s];
    },
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  },
  horizontalScrolling: !1,
  transformOptimization: !0,
  alwaysConsumeMouseWheel: !0
};
class W_ {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class C$ {
  constructor(e) {
    this.elements = e;
  }
  update() {
  }
  getData() {
    return this.elements;
  }
}
class v$ {
  constructor() {
    this.types = [], this.files = [];
  }
  update(e) {
    if (e.types && this.types.splice(0, this.types.length, ...e.types), e.files) {
      this.files.splice(0, this.files.length);
      for (let t = 0; t < e.files.length; t++) {
        const i = e.files.item(t);
        i && (i.size || i.type) && this.files.push(i);
      }
    }
  }
  getData() {
    return {
      types: this.types,
      files: this.files
    };
  }
}
function S$(s, e) {
  return Array.isArray(s) && Array.isArray(e) ? pi(s, e) : s === e;
}
class y$ {
  constructor(e) {
    e?.getSetSize ? this.getSetSize = e.getSetSize.bind(e) : this.getSetSize = (t, i, n) => n, e?.getPosInSet ? this.getPosInSet = e.getPosInSet.bind(e) : this.getPosInSet = (t, i) => i + 1, e?.getRole ? this.getRole = e.getRole.bind(e) : this.getRole = (t) => "listitem", e?.isChecked ? this.isChecked = e.isChecked.bind(e) : this.isChecked = (t) => {
    };
  }
}
const E1 = class E1 {
  get contentHeight() {
    return this.rangeMap.size;
  }
  get onDidScroll() {
    return this.scrollableElement.onScroll;
  }
  get scrollableElementDomNode() {
    return this.scrollableElement.getDomNode();
  }
  get horizontalScrolling() {
    return this._horizontalScrolling;
  }
  set horizontalScrolling(e) {
    if (e !== this._horizontalScrolling) {
      if (e && this.supportDynamicHeights)
        throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
      if (this._horizontalScrolling = e, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this._horizontalScrolling) {
        for (const t of this.items)
          this.measureItemWidth(t);
        this.updateScrollWidth(), this.scrollableElement.setScrollDimensions({ width: iy(this.domNode) }), this.rowsContainer.style.width = `${Math.max(this.scrollWidth || 0, this.renderWidth)}px`;
      } else
        this.scrollableElementWidthDelayer.cancel(), this.scrollableElement.setScrollDimensions({ width: this.renderWidth, scrollWidth: this.renderWidth }), this.rowsContainer.style.width = "";
    }
  }
  constructor(e, t, i, n = jr) {
    if (this.virtualDelegate = t, this.domId = `list_id_${++E1.InstanceCount}`, this.renderers = /* @__PURE__ */ new Map(), this.renderWidth = 0, this._scrollHeight = 0, this.scrollableElementUpdateDisposable = null, this.scrollableElementWidthDelayer = new Gl(50), this.splicing = !1, this.dragOverAnimationStopDisposable = V.None, this.dragOverMouseY = 0, this.canDrop = !1, this.currentDragFeedbackDisposable = V.None, this.onDragLeaveTimeout = V.None, this.disposables = new X(), this._onDidChangeContentHeight = new B(), this._onDidChangeContentWidth = new B(), this.onDidChangeContentHeight = te.latch(this._onDidChangeContentHeight.event, void 0, this.disposables), this._horizontalScrolling = !1, n.horizontalScrolling && n.supportDynamicHeights)
      throw new Error("Horizontal scrolling and dynamic heights not supported simultaneously");
    this.items = [], this.itemId = 0, this.rangeMap = this.createRangeMap(n.paddingTop ?? 0);
    for (const r of i)
      this.renderers.set(r.templateId, r);
    this.cache = this.disposables.add(new w$(this.renderers)), this.lastRenderTop = 0, this.lastRenderHeight = 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-list", this.domNode.classList.add(this.domId), this.domNode.tabIndex = 0, this.domNode.classList.toggle("mouse-support", typeof n.mouseSupport == "boolean" ? n.mouseSupport : !0), this._horizontalScrolling = n.horizontalScrolling ?? jr.horizontalScrolling, this.domNode.classList.toggle("horizontal-scrolling", this._horizontalScrolling), this.paddingBottom = typeof n.paddingBottom > "u" ? 0 : n.paddingBottom, this.accessibilityProvider = new y$(n.accessibilityProvider), this.rowsContainer = document.createElement("div"), this.rowsContainer.className = "monaco-list-rows", (n.transformOptimization ?? jr.transformOptimization) && (this.rowsContainer.style.transform = "translate3d(0px, 0px, 0px)", this.rowsContainer.style.overflow = "hidden", this.rowsContainer.style.contain = "strict"), this.disposables.add(xn.addTarget(this.rowsContainer)), this.scrollable = this.disposables.add(new vm({
      forceIntegerValues: !0,
      smoothScrollDuration: n.smoothScrolling ?? !1 ? 125 : 0,
      scheduleAtNextAnimationFrame: (r) => ys(fe(this.domNode), r)
    })), this.scrollableElement = this.disposables.add(new Y0(this.rowsContainer, {
      alwaysConsumeMouseWheel: n.alwaysConsumeMouseWheel ?? jr.alwaysConsumeMouseWheel,
      horizontal: 1,
      vertical: n.verticalScrollMode ?? jr.verticalScrollMode,
      useShadows: n.useShadows ?? jr.useShadows,
      mouseWheelScrollSensitivity: n.mouseWheelScrollSensitivity,
      fastScrollSensitivity: n.fastScrollSensitivity,
      scrollByPage: n.scrollByPage
    }, this.scrollable)), this.domNode.appendChild(this.scrollableElement.getDomNode()), e.appendChild(this.domNode), this.scrollableElement.onScroll(this.onScroll, this, this.disposables), this.disposables.add(U(this.rowsContainer, Et.Change, (r) => this.onTouchChange(r))), this.disposables.add(U(this.scrollableElement.getDomNode(), "scroll", (r) => r.target.scrollTop = 0)), this.disposables.add(U(this.domNode, "dragover", (r) => this.onDragOver(this.toDragEvent(r)))), this.disposables.add(U(this.domNode, "drop", (r) => this.onDrop(this.toDragEvent(r)))), this.disposables.add(U(this.domNode, "dragleave", (r) => this.onDragLeave(this.toDragEvent(r)))), this.disposables.add(U(this.domNode, "dragend", (r) => this.onDragEnd(r))), this.setRowLineHeight = n.setRowLineHeight ?? jr.setRowLineHeight, this.setRowHeight = n.setRowHeight ?? jr.setRowHeight, this.supportDynamicHeights = n.supportDynamicHeights ?? jr.supportDynamicHeights, this.dnd = n.dnd ?? this.disposables.add(jr.dnd), this.layout(n.initialSize?.height, n.initialSize?.width);
  }
  updateOptions(e) {
    e.paddingBottom !== void 0 && (this.paddingBottom = e.paddingBottom, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), e.smoothScrolling !== void 0 && this.scrollable.setSmoothScrollDuration(e.smoothScrolling ? 125 : 0), e.horizontalScrolling !== void 0 && (this.horizontalScrolling = e.horizontalScrolling);
    let t;
    if (e.scrollByPage !== void 0 && (t = { ...t ?? {}, scrollByPage: e.scrollByPage }), e.mouseWheelScrollSensitivity !== void 0 && (t = { ...t ?? {}, mouseWheelScrollSensitivity: e.mouseWheelScrollSensitivity }), e.fastScrollSensitivity !== void 0 && (t = { ...t ?? {}, fastScrollSensitivity: e.fastScrollSensitivity }), t && this.scrollableElement.updateOptions(t), e.paddingTop !== void 0 && e.paddingTop !== this.rangeMap.paddingTop) {
      const i = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), n = e.paddingTop - this.rangeMap.paddingTop;
      this.rangeMap.paddingTop = e.paddingTop, this.render(i, Math.max(0, this.lastRenderTop + n), this.lastRenderHeight, void 0, void 0, !0), this.setScrollTop(this.lastRenderTop), this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  createRangeMap(e) {
    return new b$(e);
  }
  splice(e, t, i = []) {
    if (this.splicing)
      throw new Error("Can't run recursive splices.");
    this.splicing = !0;
    try {
      return this._splice(e, t, i);
    } finally {
      this.splicing = !1, this._onDidChangeContentHeight.fire(this.contentHeight);
    }
  }
  _splice(e, t, i = []) {
    const n = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), o = { start: e, end: e + t }, r = on.intersect(n, o), a = /* @__PURE__ */ new Map();
    for (let S = r.end - 1; S >= r.start; S--) {
      const x = this.items[S];
      if (x.dragStartDisposable.dispose(), x.checkedDisposable.dispose(), x.row) {
        let y = a.get(x.templateId);
        y || (y = [], a.set(x.templateId, y));
        const D = this.renderers.get(x.templateId);
        D && D.disposeElement && D.disposeElement(x.element, S, x.row.templateData, x.size), y.unshift(x.row);
      }
      x.row = null, x.stale = !0;
    }
    const l = { start: e + t, end: this.items.length }, c = on.intersect(l, n), d = on.relativeComplement(l, n), h = i.map((S) => ({
      id: String(this.itemId++),
      element: S,
      templateId: this.virtualDelegate.getTemplateId(S),
      size: this.virtualDelegate.getHeight(S),
      width: void 0,
      hasDynamicHeight: !!this.virtualDelegate.hasDynamicHeight && this.virtualDelegate.hasDynamicHeight(S),
      lastDynamicHeightWidth: void 0,
      row: null,
      uri: void 0,
      dropTarget: !1,
      dragStartDisposable: V.None,
      checkedDisposable: V.None,
      stale: !1
    }));
    let u;
    e === 0 && t >= this.items.length ? (this.rangeMap = this.createRangeMap(this.rangeMap.paddingTop), this.rangeMap.splice(0, 0, h), u = this.items, this.items = h) : (this.rangeMap.splice(e, t, h), u = this.items.splice(e, t, ...h));
    const g = i.length - t, m = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight), p = XL(c, g), A = on.intersect(m, p);
    for (let S = A.start; S < A.end; S++)
      this.updateItemInDOM(this.items[S], S);
    const _ = on.relativeComplement(p, m);
    for (const S of _)
      for (let x = S.start; x < S.end; x++)
        this.removeItemFromDOM(x);
    const b = d.map((S) => XL(S, g)), w = [{ start: e, end: e + i.length }, ...b].map((S) => on.intersect(m, S)).reverse();
    for (const S of w)
      for (let x = S.end - 1; x >= S.start; x--) {
        const y = this.items[x], I = a.get(y.templateId)?.pop();
        this.insertItemInDOM(x, I);
      }
    for (const S of a.values())
      for (const x of S)
        this.cache.release(x);
    return this.eventuallyUpdateScrollDimensions(), this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight), u.map((S) => S.element);
  }
  eventuallyUpdateScrollDimensions() {
    this._scrollHeight = this.contentHeight, this.rowsContainer.style.height = `${this._scrollHeight}px`, this.scrollableElementUpdateDisposable || (this.scrollableElementUpdateDisposable = ys(fe(this.domNode), () => {
      this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight }), this.updateScrollWidth(), this.scrollableElementUpdateDisposable = null;
    }));
  }
  eventuallyUpdateScrollWidth() {
    if (!this.horizontalScrolling) {
      this.scrollableElementWidthDelayer.cancel();
      return;
    }
    this.scrollableElementWidthDelayer.trigger(() => this.updateScrollWidth());
  }
  updateScrollWidth() {
    if (!this.horizontalScrolling)
      return;
    let e = 0;
    for (const t of this.items)
      typeof t.width < "u" && (e = Math.max(e, t.width));
    this.scrollWidth = e, this.scrollableElement.setScrollDimensions({ scrollWidth: e === 0 ? 0 : e + 10 }), this._onDidChangeContentWidth.fire(this.scrollWidth);
  }
  rerender() {
    if (this.supportDynamicHeights) {
      for (const e of this.items)
        e.lastDynamicHeightWidth = void 0;
      this._rerender(this.lastRenderTop, this.lastRenderHeight);
    }
  }
  get length() {
    return this.items.length;
  }
  get renderHeight() {
    return this.scrollableElement.getScrollDimensions().height;
  }
  get firstVisibleIndex() {
    return this.getRenderRange(this.lastRenderTop, this.lastRenderHeight).start;
  }
  element(e) {
    return this.items[e].element;
  }
  indexOf(e) {
    return this.items.findIndex((t) => t.element === e);
  }
  domElement(e) {
    const t = this.items[e].row;
    return t && t.domNode;
  }
  elementHeight(e) {
    return this.items[e].size;
  }
  elementTop(e) {
    return this.rangeMap.positionAt(e);
  }
  indexAt(e) {
    return this.rangeMap.indexAt(e);
  }
  indexAfter(e) {
    return this.rangeMap.indexAfter(e);
  }
  layout(e, t) {
    const i = {
      height: typeof e == "number" ? e : W6(this.domNode)
    };
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, i.scrollHeight = this.scrollHeight), this.scrollableElement.setScrollDimensions(i), typeof t < "u" && (this.renderWidth = t, this.supportDynamicHeights && this._rerender(this.scrollTop, this.renderHeight)), this.horizontalScrolling && this.scrollableElement.setScrollDimensions({
      width: typeof t == "number" ? t : iy(this.domNode)
    });
  }
  // Render
  render(e, t, i, n, o, r = !1) {
    const a = this.getRenderRange(t, i), l = on.relativeComplement(a, e).reverse(), c = on.relativeComplement(e, a);
    if (r) {
      const d = on.intersect(e, a);
      for (let h = d.start; h < d.end; h++)
        this.updateItemInDOM(this.items[h], h);
    }
    this.cache.transact(() => {
      for (const d of c)
        for (let h = d.start; h < d.end; h++)
          this.removeItemFromDOM(h);
      for (const d of l)
        for (let h = d.end - 1; h >= d.start; h--)
          this.insertItemInDOM(h);
    }), n !== void 0 && (this.rowsContainer.style.left = `-${n}px`), this.rowsContainer.style.top = `-${t}px`, this.horizontalScrolling && o !== void 0 && (this.rowsContainer.style.width = `${Math.max(o, this.renderWidth)}px`), this.lastRenderTop = t, this.lastRenderHeight = i;
  }
  // DOM operations
  insertItemInDOM(e, t) {
    const i = this.items[e];
    if (!i.row)
      if (t)
        i.row = t, i.stale = !0;
      else {
        const l = this.cache.alloc(i.templateId);
        i.row = l.row, i.stale || (i.stale = l.isReusingConnectedDomNode);
      }
    const n = this.accessibilityProvider.getRole(i.element) || "listitem";
    i.row.domNode.setAttribute("role", n);
    const o = this.accessibilityProvider.isChecked(i.element);
    if (typeof o == "boolean")
      i.row.domNode.setAttribute("aria-checked", String(!!o));
    else if (o) {
      const l = (c) => i.row.domNode.setAttribute("aria-checked", String(!!c));
      l(o.value), i.checkedDisposable = o.onDidChange(() => l(o.value));
    }
    if (i.stale || !i.row.domNode.parentElement) {
      const l = this.items.at(e + 1)?.row?.domNode ?? null;
      (i.row.domNode.parentElement !== this.rowsContainer || i.row.domNode.nextElementSibling !== l) && this.rowsContainer.insertBefore(i.row.domNode, l), i.stale = !1;
    }
    this.updateItemInDOM(i, e);
    const r = this.renderers.get(i.templateId);
    if (!r)
      throw new Error(`No renderer found for template id ${i.templateId}`);
    r?.renderElement(i.element, e, i.row.templateData, i.size);
    const a = this.dnd.getDragURI(i.element);
    i.dragStartDisposable.dispose(), i.row.domNode.draggable = !!a, a && (i.dragStartDisposable = U(i.row.domNode, "dragstart", (l) => this.onDragStart(i.element, a, l))), this.horizontalScrolling && (this.measureItemWidth(i), this.eventuallyUpdateScrollWidth());
  }
  measureItemWidth(e) {
    if (!e.row || !e.row.domNode)
      return;
    e.row.domNode.style.width = "fit-content", e.width = iy(e.row.domNode);
    const t = fe(e.row.domNode).getComputedStyle(e.row.domNode);
    t.paddingLeft && (e.width += parseFloat(t.paddingLeft)), t.paddingRight && (e.width += parseFloat(t.paddingRight)), e.row.domNode.style.width = "";
  }
  updateItemInDOM(e, t) {
    e.row.domNode.style.top = `${this.elementTop(t)}px`, this.setRowHeight && (e.row.domNode.style.height = `${e.size}px`), this.setRowLineHeight && (e.row.domNode.style.lineHeight = `${e.size}px`), e.row.domNode.setAttribute("data-index", `${t}`), e.row.domNode.setAttribute("data-last-element", t === this.length - 1 ? "true" : "false"), e.row.domNode.setAttribute("data-parity", t % 2 === 0 ? "even" : "odd"), e.row.domNode.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(e.element, t, this.length))), e.row.domNode.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(e.element, t))), e.row.domNode.setAttribute("id", this.getElementDomId(t)), e.row.domNode.classList.toggle("drop-target", e.dropTarget);
  }
  removeItemFromDOM(e) {
    const t = this.items[e];
    if (t.dragStartDisposable.dispose(), t.checkedDisposable.dispose(), t.row) {
      const i = this.renderers.get(t.templateId);
      i && i.disposeElement && i.disposeElement(t.element, e, t.row.templateData, t.size), this.cache.release(t.row), t.row = null;
    }
    this.horizontalScrolling && this.eventuallyUpdateScrollWidth();
  }
  getScrollTop() {
    return this.scrollableElement.getScrollPosition().scrollTop;
  }
  setScrollTop(e, t) {
    this.scrollableElementUpdateDisposable && (this.scrollableElementUpdateDisposable.dispose(), this.scrollableElementUpdateDisposable = null, this.scrollableElement.setScrollDimensions({ scrollHeight: this.scrollHeight })), this.scrollableElement.setScrollPosition({ scrollTop: e, reuseAnimation: t });
  }
  get scrollTop() {
    return this.getScrollTop();
  }
  set scrollTop(e) {
    this.setScrollTop(e);
  }
  get scrollHeight() {
    return this._scrollHeight + (this.horizontalScrolling ? 10 : 0) + this.paddingBottom;
  }
  // Events
  get onMouseClick() {
    return te.map(this.disposables.add(new Ke(this.domNode, "click")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseDblClick() {
    return te.map(this.disposables.add(new Ke(this.domNode, "dblclick")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseMiddleClick() {
    return te.filter(te.map(this.disposables.add(new Ke(this.domNode, "auxclick")).event, (e) => this.toMouseEvent(e), this.disposables), (e) => e.browserEvent.button === 1, this.disposables);
  }
  get onMouseDown() {
    return te.map(this.disposables.add(new Ke(this.domNode, "mousedown")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOver() {
    return te.map(this.disposables.add(new Ke(this.domNode, "mouseover")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onMouseOut() {
    return te.map(this.disposables.add(new Ke(this.domNode, "mouseout")).event, (e) => this.toMouseEvent(e), this.disposables);
  }
  get onContextMenu() {
    return te.any(te.map(this.disposables.add(new Ke(this.domNode, "contextmenu")).event, (e) => this.toMouseEvent(e), this.disposables), te.map(this.disposables.add(new Ke(this.domNode, Et.Contextmenu)).event, (e) => this.toGestureEvent(e), this.disposables));
  }
  get onTouchStart() {
    return te.map(this.disposables.add(new Ke(this.domNode, "touchstart")).event, (e) => this.toTouchEvent(e), this.disposables);
  }
  get onTap() {
    return te.map(this.disposables.add(new Ke(this.rowsContainer, Et.Tap)).event, (e) => this.toGestureEvent(e), this.disposables);
  }
  toMouseEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toTouchEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toGestureEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.initialTarget || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element;
    return { browserEvent: e, index: t, element: n };
  }
  toDragEvent(e) {
    const t = this.getItemIndexFromEventTarget(e.target || null), i = typeof t > "u" ? void 0 : this.items[t], n = i && i.element, o = this.getTargetSector(e, t);
    return { browserEvent: e, index: t, element: n, sector: o };
  }
  onScroll(e) {
    try {
      const t = this.getRenderRange(this.lastRenderTop, this.lastRenderHeight);
      this.render(t, e.scrollTop, e.height, e.scrollLeft, e.scrollWidth), this.supportDynamicHeights && this._rerender(e.scrollTop, e.height, e.inSmoothScrolling);
    } catch (t) {
      throw console.error("Got bad scroll event:", e), t;
    }
  }
  onTouchChange(e) {
    e.preventDefault(), e.stopPropagation(), this.scrollTop -= e.translationY;
  }
  // DND
  onDragStart(e, t, i) {
    if (!i.dataTransfer)
      return;
    const n = this.dnd.getDragElements(e);
    if (i.dataTransfer.effectAllowed = "copyMove", i.dataTransfer.setData(P3.TEXT, t), i.dataTransfer.setDragImage) {
      let o;
      this.dnd.getDragLabel && (o = this.dnd.getDragLabel(n, i)), typeof o > "u" && (o = String(n.length));
      const r = de(".monaco-drag-image");
      r.textContent = o, ((c) => {
        for (; c && !c.classList.contains("monaco-workbench"); )
          c = c.parentElement;
        return c || this.domNode.ownerDocument;
      })(this.domNode).appendChild(r), i.dataTransfer.setDragImage(r, -10, -10), setTimeout(() => r.remove(), 0);
    }
    this.domNode.classList.add("dragging"), this.currentDragData = new W_(n), Td.CurrentDragAndDropData = new C$(n), this.dnd.onDragStart?.(this.currentDragData, i);
  }
  onDragOver(e) {
    if (e.browserEvent.preventDefault(), this.onDragLeaveTimeout.dispose(), Td.CurrentDragAndDropData && Td.CurrentDragAndDropData.getData() === "vscode-ui" || (this.setupDragAndDropScrollTopAnimation(e.browserEvent), !e.browserEvent.dataTransfer))
      return !1;
    if (!this.currentDragData)
      if (Td.CurrentDragAndDropData)
        this.currentDragData = Td.CurrentDragAndDropData;
      else {
        if (!e.browserEvent.dataTransfer.types)
          return !1;
        this.currentDragData = new v$();
      }
    const t = this.dnd.onDragOver(this.currentDragData, e.element, e.index, e.sector, e.browserEvent);
    if (this.canDrop = typeof t == "boolean" ? t : t.accept, !this.canDrop)
      return this.currentDragFeedback = void 0, this.currentDragFeedbackDisposable.dispose(), !1;
    e.browserEvent.dataTransfer.dropEffect = typeof t != "boolean" && t.effect?.type === 0 ? "copy" : "move";
    let i;
    typeof t != "boolean" && t.feedback ? i = t.feedback : typeof e.index > "u" ? i = [-1] : i = [e.index], i = du(i).filter((o) => o >= -1 && o < this.length).sort((o, r) => o - r), i = i[0] === -1 ? [-1] : i;
    let n = typeof t != "boolean" && t.effect && t.effect.position ? t.effect.position : "drop-target";
    if (S$(this.currentDragFeedback, i) && this.currentDragFeedbackPosition === n)
      return !0;
    if (this.currentDragFeedback = i, this.currentDragFeedbackPosition = n, this.currentDragFeedbackDisposable.dispose(), i[0] === -1)
      this.domNode.classList.add(n), this.rowsContainer.classList.add(n), this.currentDragFeedbackDisposable = we(() => {
        this.domNode.classList.remove(n), this.rowsContainer.classList.remove(n);
      });
    else {
      if (i.length > 1 && n !== "drop-target")
        throw new Error("Can't use multiple feedbacks with position different than 'over'");
      n === "drop-target-after" && i[0] < this.length - 1 && (i[0] += 1, n = "drop-target-before");
      for (const o of i) {
        const r = this.items[o];
        r.dropTarget = !0, r.row?.domNode.classList.add(n);
      }
      this.currentDragFeedbackDisposable = we(() => {
        for (const o of i) {
          const r = this.items[o];
          r.dropTarget = !1, r.row?.domNode.classList.remove(n);
        }
      });
    }
    return !0;
  }
  onDragLeave(e) {
    this.onDragLeaveTimeout.dispose(), this.onDragLeaveTimeout = zf(() => this.clearDragOverFeedback(), 100, this.disposables), this.currentDragData && this.dnd.onDragLeave?.(this.currentDragData, e.element, e.index, e.browserEvent);
  }
  onDrop(e) {
    if (!this.canDrop)
      return;
    const t = this.currentDragData;
    this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, Td.CurrentDragAndDropData = void 0, !(!t || !e.browserEvent.dataTransfer) && (e.browserEvent.preventDefault(), t.update(e.browserEvent.dataTransfer), this.dnd.drop(t, e.element, e.index, e.sector, e.browserEvent));
  }
  onDragEnd(e) {
    this.canDrop = !1, this.teardownDragAndDropScrollTopAnimation(), this.clearDragOverFeedback(), this.domNode.classList.remove("dragging"), this.currentDragData = void 0, Td.CurrentDragAndDropData = void 0, this.dnd.onDragEnd?.(e);
  }
  clearDragOverFeedback() {
    this.currentDragFeedback = void 0, this.currentDragFeedbackPosition = void 0, this.currentDragFeedbackDisposable.dispose(), this.currentDragFeedbackDisposable = V.None;
  }
  // DND scroll top animation
  setupDragAndDropScrollTopAnimation(e) {
    if (!this.dragOverAnimationDisposable) {
      const t = VH(this.domNode).top;
      this.dragOverAnimationDisposable = X6(fe(this.domNode), this.animateDragAndDropScrollTop.bind(this, t));
    }
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationStopDisposable = zf(() => {
      this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
    }, 1e3, this.disposables), this.dragOverMouseY = e.pageY;
  }
  animateDragAndDropScrollTop(e) {
    if (this.dragOverMouseY === void 0)
      return;
    const t = this.dragOverMouseY - e, i = this.renderHeight - 35;
    t < 35 ? this.scrollTop += Math.max(-14, Math.floor(0.3 * (t - 35))) : t > i && (this.scrollTop += Math.min(14, Math.floor(0.3 * (t - i))));
  }
  teardownDragAndDropScrollTopAnimation() {
    this.dragOverAnimationStopDisposable.dispose(), this.dragOverAnimationDisposable && (this.dragOverAnimationDisposable.dispose(), this.dragOverAnimationDisposable = void 0);
  }
  // Util
  getTargetSector(e, t) {
    if (t === void 0)
      return;
    const i = e.offsetY / this.items[t].size, n = Math.floor(i / 0.25);
    return kn(n, 0, 3);
  }
  getItemIndexFromEventTarget(e) {
    const t = this.scrollableElement.getDomNode();
    let i = e;
    for (; (Bi(i) || G6(i)) && i !== this.rowsContainer && t.contains(i); ) {
      const n = i.getAttribute("data-index");
      if (n) {
        const o = Number(n);
        if (!isNaN(o))
          return o;
      }
      i = i.parentElement;
    }
  }
  getRenderRange(e, t) {
    return {
      start: this.rangeMap.indexAt(e),
      end: this.rangeMap.indexAfter(e + t - 1)
    };
  }
  /**
   * Given a stable rendered state, checks every rendered element whether it needs
   * to be probed for dynamic height. Adjusts scroll height and top if necessary.
   */
  _rerender(e, t, i) {
    const n = this.getRenderRange(e, t);
    let o, r;
    e === this.elementTop(n.start) ? (o = n.start, r = 0) : n.end - n.start > 1 && (o = n.start + 1, r = this.elementTop(o) - e);
    let a = 0;
    for (; ; ) {
      const l = this.getRenderRange(e, t);
      let c = !1;
      for (let d = l.start; d < l.end; d++) {
        const h = this.probeDynamicHeight(d);
        h !== 0 && this.rangeMap.splice(d, 1, [this.items[d]]), a += h, c = c || h !== 0;
      }
      if (!c) {
        a !== 0 && this.eventuallyUpdateScrollDimensions();
        const d = on.relativeComplement(n, l);
        for (const u of d)
          for (let g = u.start; g < u.end; g++)
            this.items[g].row && this.removeItemFromDOM(g);
        const h = on.relativeComplement(l, n).reverse();
        for (const u of h)
          for (let g = u.end - 1; g >= u.start; g--)
            this.insertItemInDOM(g);
        for (let u = l.start; u < l.end; u++)
          this.items[u].row && this.updateItemInDOM(this.items[u], u);
        if (typeof o == "number") {
          const u = this.scrollable.getFutureScrollPosition().scrollTop - e, g = this.elementTop(o) - r + u;
          this.setScrollTop(g, i);
        }
        this._onDidChangeContentHeight.fire(this.contentHeight);
        return;
      }
    }
  }
  probeDynamicHeight(e) {
    const t = this.items[e];
    if (this.virtualDelegate.getDynamicHeight) {
      const r = this.virtualDelegate.getDynamicHeight(t.element);
      if (r !== null) {
        const a = t.size;
        return t.size = r, t.lastDynamicHeightWidth = this.renderWidth, r - a;
      }
    }
    if (!t.hasDynamicHeight || t.lastDynamicHeightWidth === this.renderWidth || this.virtualDelegate.hasDynamicHeight && !this.virtualDelegate.hasDynamicHeight(t.element))
      return 0;
    const i = t.size;
    if (t.row)
      return t.row.domNode.style.height = "", t.size = t.row.domNode.offsetHeight, t.size === 0 && !yi(t.row.domNode, fe(t.row.domNode).document.body) && console.warn("Measuring item node that is not in DOM! Add ListView to the DOM before measuring row height!", new Error().stack), t.lastDynamicHeightWidth = this.renderWidth, t.size - i;
    const { row: n } = this.cache.alloc(t.templateId);
    n.domNode.style.height = "", this.rowsContainer.appendChild(n.domNode);
    const o = this.renderers.get(t.templateId);
    if (!o)
      throw new lt("Missing renderer for templateId: " + t.templateId);
    return o.renderElement(t.element, e, n.templateData, void 0), t.size = n.domNode.offsetHeight, o.disposeElement?.(t.element, e, n.templateData, void 0), this.virtualDelegate.setDynamicHeight?.(t.element, t.size), t.lastDynamicHeightWidth = this.renderWidth, n.domNode.remove(), this.cache.release(n), t.size - i;
  }
  getElementDomId(e) {
    return `${this.domId}_${e}`;
  }
  // Dispose
  dispose() {
    for (const e of this.items)
      if (e.dragStartDisposable.dispose(), e.checkedDisposable.dispose(), e.row) {
        const t = this.renderers.get(e.row.templateId);
        t && (t.disposeElement?.(e.element, -1, e.row.templateData, void 0), t.disposeTemplate(e.row.templateData));
      }
    this.items = [], this.domNode?.remove(), this.dragOverAnimationDisposable?.dispose(), this.disposables.dispose();
  }
};
E1.InstanceCount = 0;
let er = E1;
Kl([
  oi
], er.prototype, "onMouseClick", null);
Kl([
  oi
], er.prototype, "onMouseDblClick", null);
Kl([
  oi
], er.prototype, "onMouseMiddleClick", null);
Kl([
  oi
], er.prototype, "onMouseDown", null);
Kl([
  oi
], er.prototype, "onMouseOver", null);
Kl([
  oi
], er.prototype, "onMouseOut", null);
Kl([
  oi
], er.prototype, "onContextMenu", null);
Kl([
  oi
], er.prototype, "onTouchStart", null);
Kl([
  oi
], er.prototype, "onTap", null);
var vd = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class x$ {
  constructor(e) {
    this.trait = e, this.renderedElements = [];
  }
  get templateId() {
    return `template:${this.trait.name}`;
  }
  renderTemplate(e) {
    return e;
  }
  renderElement(e, t, i) {
    const n = this.renderedElements.findIndex((o) => o.templateData === i);
    if (n >= 0) {
      const o = this.renderedElements[n];
      this.trait.unrender(i), o.index = t;
    } else {
      const o = { index: t, templateData: i };
      this.renderedElements.push(o);
    }
    this.trait.renderIndex(t, i);
  }
  splice(e, t, i) {
    const n = [];
    for (const o of this.renderedElements)
      o.index < e ? n.push(o) : o.index >= e + t && n.push({
        index: o.index + i - t,
        templateData: o.templateData
      });
    this.renderedElements = n;
  }
  renderIndexes(e) {
    for (const { index: t, templateData: i } of this.renderedElements)
      e.indexOf(t) > -1 && this.trait.renderIndex(t, i);
  }
  disposeTemplate(e) {
    const t = this.renderedElements.findIndex((i) => i.templateData === e);
    t < 0 || this.renderedElements.splice(t, 1);
  }
}
let FC = class {
  get name() {
    return this._trait;
  }
  get renderer() {
    return new x$(this);
  }
  constructor(e) {
    this._trait = e, this.indexes = [], this.sortedIndexes = [], this._onChange = new B(), this.onChange = this._onChange.event;
  }
  splice(e, t, i) {
    const n = i.length - t, o = e + t, r = [];
    let a = 0;
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] < e; )
      r.push(this.sortedIndexes[a++]);
    for (let l = 0; l < i.length; l++)
      i[l] && r.push(l + e);
    for (; a < this.sortedIndexes.length && this.sortedIndexes[a] >= o; )
      r.push(this.sortedIndexes[a++] + n);
    this.renderer.splice(e, t, i.length), this._set(r, r);
  }
  renderIndex(e, t) {
    t.classList.toggle(this._trait, this.contains(e));
  }
  unrender(e) {
    e.classList.remove(this._trait);
  }
  /**
   * Sets the indexes which should have this trait.
   *
   * @param indexes Indexes which should have this trait.
   * @return The old indexes which had this trait.
   */
  set(e, t) {
    return this._set(e, [...e].sort(mF), t);
  }
  _set(e, t, i) {
    const n = this.indexes, o = this.sortedIndexes;
    this.indexes = e, this.sortedIndexes = t;
    const r = ZL(o, e);
    return this.renderer.renderIndexes(r), this._onChange.fire({ indexes: e, browserEvent: i }), n;
  }
  get() {
    return this.indexes;
  }
  contains(e) {
    return wM(this.sortedIndexes, e, mF) >= 0;
  }
  dispose() {
    Ct(this._onChange);
  }
};
vd([
  oi
], FC.prototype, "renderer", null);
class E$ extends FC {
  constructor(e) {
    super("selected"), this.setAriaSelected = e;
  }
  renderIndex(e, t) {
    super.renderIndex(e, t), this.setAriaSelected && (this.contains(e) ? t.setAttribute("aria-selected", "true") : t.setAttribute("aria-selected", "false"));
  }
}
class Iy {
  constructor(e, t, i) {
    this.trait = e, this.view = t, this.identityProvider = i;
  }
  splice(e, t, i) {
    if (!this.identityProvider)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const n = this.trait.get().map((a) => this.identityProvider.getId(this.view.element(a)).toString());
    if (n.length === 0)
      return this.trait.splice(e, t, new Array(i.length).fill(!1));
    const o = new Set(n), r = i.map((a) => o.has(this.identityProvider.getId(a).toString()));
    this.trait.splice(e, t, r);
  }
}
function Vc(s) {
  return s.tagName === "INPUT" || s.tagName === "TEXTAREA";
}
function V_(s, e) {
  return s.classList.contains(e) ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : V_(s.parentElement, e);
}
function pp(s) {
  return V_(s, "monaco-editor");
}
function L$(s) {
  return V_(s, "monaco-custom-toggle");
}
function k$(s) {
  return V_(s, "action-item");
}
function Op(s) {
  return V_(s, "monaco-tree-sticky-row");
}
function KA(s) {
  return s.classList.contains("monaco-tree-sticky-container");
}
function W3(s) {
  return s.tagName === "A" && s.classList.contains("monaco-button") || s.tagName === "DIV" && s.classList.contains("monaco-button-dropdown") ? !0 : s.classList.contains("monaco-list") || !s.parentElement ? !1 : W3(s.parentElement);
}
class V3 {
  get onKeyDown() {
    return te.chain(this.disposables.add(new Ke(this.view.domNode, "keydown")).event, (e) => e.filter((t) => !Vc(t.target)).map((t) => new Mt(t)));
  }
  constructor(e, t, i) {
    this.list = e, this.view = t, this.disposables = new X(), this.multipleSelectionDisposables = new X(), this.multipleSelectionSupport = i.multipleSelectionSupport, this.disposables.add(this.onKeyDown((n) => {
      switch (n.keyCode) {
        case 3:
          return this.onEnter(n);
        case 16:
          return this.onUpArrow(n);
        case 18:
          return this.onDownArrow(n);
        case 11:
          return this.onPageUpArrow(n);
        case 12:
          return this.onPageDownArrow(n);
        case 9:
          return this.onEscape(n);
        case 31:
          this.multipleSelectionSupport && (ze ? n.metaKey : n.ctrlKey) && this.onCtrlA(n);
      }
    }));
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionSupport = e.multipleSelectionSupport);
  }
  onEnter(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(this.list.getFocus(), e.browserEvent);
  }
  onUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPrevious(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNext(1, !1, e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageUpArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusPreviousPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onPageDownArrow(e) {
    e.preventDefault(), e.stopPropagation(), this.list.focusNextPage(e.browserEvent);
    const t = this.list.getFocus()[0];
    this.list.setAnchor(t), this.list.reveal(t), this.view.domNode.focus();
  }
  onCtrlA(e) {
    e.preventDefault(), e.stopPropagation(), this.list.setSelection(Yn(this.list.length), e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus();
  }
  onEscape(e) {
    this.list.getSelection().length && (e.preventDefault(), e.stopPropagation(), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0), this.view.domNode.focus());
  }
  dispose() {
    this.disposables.dispose(), this.multipleSelectionDisposables.dispose();
  }
}
vd([
  oi
], V3.prototype, "onKeyDown", null);
var fa;
(function(s) {
  s[s.Automatic = 0] = "Automatic", s[s.Trigger = 1] = "Trigger";
})(fa || (fa = {}));
var Hg;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Typing = 1] = "Typing";
})(Hg || (Hg = {}));
const D$ = new class {
  mightProducePrintableCharacter(s) {
    return s.ctrlKey || s.metaKey || s.altKey ? !1 : s.keyCode >= 31 && s.keyCode <= 56 || s.keyCode >= 21 && s.keyCode <= 30 || s.keyCode >= 98 && s.keyCode <= 107 || s.keyCode >= 85 && s.keyCode <= 95;
  }
}();
class I$ {
  constructor(e, t, i, n, o) {
    this.list = e, this.view = t, this.keyboardNavigationLabelProvider = i, this.keyboardNavigationEventFilter = n, this.delegate = o, this.enabled = !1, this.state = Hg.Idle, this.mode = fa.Automatic, this.triggered = !1, this.previouslyFocused = -1, this.enabledDisposables = new X(), this.disposables = new X(), this.updateOptions(e.options);
  }
  updateOptions(e) {
    e.typeNavigationEnabled ?? !0 ? this.enable() : this.disable(), this.mode = e.typeNavigationMode ?? fa.Automatic;
  }
  enable() {
    if (this.enabled)
      return;
    let e = !1;
    const t = te.chain(this.enabledDisposables.add(new Ke(this.view.domNode, "keydown")).event, (o) => o.filter((r) => !Vc(r.target)).filter(() => this.mode === fa.Automatic || this.triggered).map((r) => new Mt(r)).filter((r) => e || this.keyboardNavigationEventFilter(r)).filter((r) => this.delegate.mightProducePrintableCharacter(r)).forEach((r) => Ve.stop(r, !0)).map((r) => r.browserEvent.key)), i = te.debounce(t, () => null, 800, void 0, void 0, void 0, this.enabledDisposables);
    te.reduce(te.any(t, i), (o, r) => r === null ? null : (o || "") + r, void 0, this.enabledDisposables)(this.onInput, this, this.enabledDisposables), i(this.onClear, this, this.enabledDisposables), t(() => e = !0, void 0, this.enabledDisposables), i(() => e = !1, void 0, this.enabledDisposables), this.enabled = !0, this.triggered = !1;
  }
  disable() {
    this.enabled && (this.enabledDisposables.clear(), this.enabled = !1, this.triggered = !1);
  }
  onClear() {
    const e = this.list.getFocus();
    if (e.length > 0 && e[0] === this.previouslyFocused) {
      const t = this.list.options.accessibilityProvider?.getAriaLabel(this.list.element(e[0]));
      typeof t == "string" ? Ia(t) : t && Ia(t.get());
    }
    this.previouslyFocused = -1;
  }
  onInput(e) {
    if (!e) {
      this.state = Hg.Idle, this.triggered = !1;
      return;
    }
    const t = this.list.getFocus(), i = t.length > 0 ? t[0] : 0, n = this.state === Hg.Idle ? 1 : 0;
    this.state = Hg.Typing;
    for (let o = 0; o < this.list.length; o++) {
      const r = (i + o + n) % this.list.length, a = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(this.view.element(r)), l = a && a.toString();
      if (this.list.options.typeNavigationEnabled) {
        if (typeof l < "u") {
          if (kC(e, l)) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
          const c = ZK(e, l);
          if (c && c[0].end - c[0].start > 1 && c.length === 1) {
            this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
            return;
          }
        }
      } else if (typeof l > "u" || kC(e, l)) {
        this.previouslyFocused = i, this.list.setFocus([r]), this.list.reveal(r);
        return;
      }
    }
  }
  dispose() {
    this.disable(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
}
class M$ {
  constructor(e, t) {
    this.list = e, this.view = t, this.disposables = new X();
    const i = te.chain(this.disposables.add(new Ke(t.domNode, "keydown")).event, (o) => o.filter((r) => !Vc(r.target)).map((r) => new Mt(r)));
    te.chain(i, (o) => o.filter((r) => r.keyCode === 2 && !r.ctrlKey && !r.metaKey && !r.shiftKey && !r.altKey))(this.onTab, this, this.disposables);
  }
  onTab(e) {
    if (e.target !== this.view.domNode)
      return;
    const t = this.list.getFocus();
    if (t.length === 0)
      return;
    const i = this.view.domElement(t[0]);
    if (!i)
      return;
    const n = i.querySelector("[tabIndex]");
    if (!n || !Bi(n) || n.tabIndex === -1)
      return;
    const o = fe(n).getComputedStyle(n);
    o.visibility === "hidden" || o.display === "none" || (e.preventDefault(), e.stopPropagation(), n.focus());
  }
  dispose() {
    this.disposables.dispose();
  }
}
function z3(s) {
  return ze ? s.browserEvent.metaKey : s.browserEvent.ctrlKey;
}
function U3(s) {
  return s.browserEvent.shiftKey;
}
function N$(s) {
  return qM(s) && s.button === 2;
}
const fF = {
  isSelectionSingleChangeEvent: z3,
  isSelectionRangeChangeEvent: U3
};
class Q3 {
  constructor(e) {
    this.list = e, this.disposables = new X(), this._onPointer = new B(), this.onPointer = this._onPointer.event, e.options.multipleSelectionSupport !== !1 && (this.multipleSelectionController = this.list.options.multipleSelectionController || fF), this.mouseSupport = typeof e.options.mouseSupport > "u" || !!e.options.mouseSupport, this.mouseSupport && (e.onMouseDown(this.onMouseDown, this, this.disposables), e.onContextMenu(this.onContextMenu, this, this.disposables), e.onMouseDblClick(this.onDoubleClick, this, this.disposables), e.onTouchStart(this.onMouseDown, this, this.disposables), this.disposables.add(xn.addTarget(e.getHTMLElement()))), te.any(e.onMouseClick, e.onMouseMiddleClick, e.onTap)(this.onViewPointer, this, this.disposables);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && (this.multipleSelectionController = void 0, e.multipleSelectionSupport && (this.multipleSelectionController = this.list.options.multipleSelectionController || fF));
  }
  isSelectionSingleChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionSingleChangeEvent(e) : !1;
  }
  isSelectionRangeChangeEvent(e) {
    return this.multipleSelectionController ? this.multipleSelectionController.isSelectionRangeChangeEvent(e) : !1;
  }
  isSelectionChangeEvent(e) {
    return this.isSelectionSingleChangeEvent(e) || this.isSelectionRangeChangeEvent(e);
  }
  onMouseDown(e) {
    pp(e.browserEvent.target) || ln() !== e.browserEvent.target && this.list.domFocus();
  }
  onContextMenu(e) {
    if (Vc(e.browserEvent.target) || pp(e.browserEvent.target))
      return;
    const t = typeof e.index > "u" ? [] : [e.index];
    this.list.setFocus(t, e.browserEvent);
  }
  onViewPointer(e) {
    if (!this.mouseSupport || Vc(e.browserEvent.target) || pp(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = e.index;
    if (typeof t > "u") {
      this.list.setFocus([], e.browserEvent), this.list.setSelection([], e.browserEvent), this.list.setAnchor(void 0);
      return;
    }
    if (this.isSelectionChangeEvent(e))
      return this.changeSelection(e);
    this.list.setFocus([t], e.browserEvent), this.list.setAnchor(t), N$(e.browserEvent) || this.list.setSelection([t], e.browserEvent), this._onPointer.fire(e);
  }
  onDoubleClick(e) {
    if (Vc(e.browserEvent.target) || pp(e.browserEvent.target) || this.isSelectionChangeEvent(e) || e.browserEvent.isHandledByList)
      return;
    e.browserEvent.isHandledByList = !0;
    const t = this.list.getFocus();
    this.list.setSelection(t, e.browserEvent);
  }
  changeSelection(e) {
    const t = e.index;
    let i = this.list.getAnchor();
    if (this.isSelectionRangeChangeEvent(e)) {
      typeof i > "u" && (i = this.list.getFocus()[0] ?? t, this.list.setAnchor(i));
      const n = Math.min(i, t), o = Math.max(i, t), r = Yn(n, o + 1), a = this.list.getSelection(), l = R$(ZL(a, [i]), i);
      if (l.length === 0)
        return;
      const c = ZL(r, F$(a, l));
      this.list.setSelection(c, e.browserEvent), this.list.setFocus([t], e.browserEvent);
    } else if (this.isSelectionSingleChangeEvent(e)) {
      const n = this.list.getSelection(), o = n.filter((r) => r !== t);
      this.list.setFocus([t]), this.list.setAnchor(t), n.length === o.length ? this.list.setSelection([...o, t], e.browserEvent) : this.list.setSelection(o, e.browserEvent);
    }
  }
  dispose() {
    this.disposables.dispose();
  }
}
class G3 {
  constructor(e, t) {
    this.styleElement = e, this.selectorSuffix = t;
  }
  style(e) {
    const t = this.selectorSuffix && `.${this.selectorSuffix}`, i = [];
    e.listBackground && i.push(`.monaco-list${t} .monaco-list-rows { background: ${e.listBackground}; }`), e.listFocusBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.focused { background-color: ${e.listFocusBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.focused:hover { background-color: ${e.listFocusBackground}; }`)), e.listFocusForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), e.listActiveSelectionBackground && (i.push(`.monaco-list${t}:focus .monaco-list-row.selected { background-color: ${e.listActiveSelectionBackground}; }`), i.push(`.monaco-list${t}:focus .monaco-list-row.selected:hover { background-color: ${e.listActiveSelectionBackground}; }`)), e.listActiveSelectionForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected { color: ${e.listActiveSelectionForeground}; }`), e.listActiveSelectionIconForeground && i.push(`.monaco-list${t}:focus .monaco-list-row.selected .codicon { color: ${e.listActiveSelectionIconForeground}; }`), e.listFocusAndSelectionBackground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { background-color: ${e.listFocusAndSelectionBackground}; }
			`), e.listFocusAndSelectionForeground && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.selected.focused { color: ${e.listFocusAndSelectionForeground}; }
			`), e.listInactiveFocusForeground && (i.push(`.monaco-list${t} .monaco-list-row.focused { color:  ${e.listInactiveFocusForeground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { color:  ${e.listInactiveFocusForeground}; }`)), e.listInactiveSelectionIconForeground && i.push(`.monaco-list${t} .monaco-list-row.focused .codicon { color:  ${e.listInactiveSelectionIconForeground}; }`), e.listInactiveFocusBackground && (i.push(`.monaco-list${t} .monaco-list-row.focused { background-color:  ${e.listInactiveFocusBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.focused:hover { background-color:  ${e.listInactiveFocusBackground}; }`)), e.listInactiveSelectionBackground && (i.push(`.monaco-list${t} .monaco-list-row.selected { background-color:  ${e.listInactiveSelectionBackground}; }`), i.push(`.monaco-list${t} .monaco-list-row.selected:hover { background-color:  ${e.listInactiveSelectionBackground}; }`)), e.listInactiveSelectionForeground && i.push(`.monaco-list${t} .monaco-list-row.selected { color: ${e.listInactiveSelectionForeground}; }`), e.listHoverBackground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { background-color: ${e.listHoverBackground}; }`), e.listHoverForeground && i.push(`.monaco-list${t}:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused) { color:  ${e.listHoverForeground}; }`);
    const n = Tl(e.listFocusAndSelectionOutline, Tl(e.listSelectionOutline, e.listFocusOutline ?? ""));
    n && i.push(`.monaco-list${t}:focus .monaco-list-row.focused.selected { outline: 1px solid ${n}; outline-offset: -1px;}`), e.listFocusOutline && i.push(`
				.monaco-drag-image,
				.monaco-list${t}:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
				.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }
			`);
    const o = Tl(e.listSelectionOutline, e.listInactiveFocusOutline ?? "");
    o && i.push(`.monaco-list${t} .monaco-list-row.focused.selected { outline: 1px dotted ${o}; outline-offset: -1px; }`), e.listSelectionOutline && i.push(`.monaco-list${t} .monaco-list-row.selected { outline: 1px dotted ${e.listSelectionOutline}; outline-offset: -1px; }`), e.listInactiveFocusOutline && i.push(`.monaco-list${t} .monaco-list-row.focused { outline: 1px dotted ${e.listInactiveFocusOutline}; outline-offset: -1px; }`), e.listHoverOutline && i.push(`.monaco-list${t} .monaco-list-row:hover { outline: 1px dashed ${e.listHoverOutline}; outline-offset: -1px; }`), e.listDropOverBackground && i.push(`
				.monaco-list${t}.drop-target,
				.monaco-list${t} .monaco-list-rows.drop-target,
				.monaco-list${t} .monaco-list-row.drop-target { background-color: ${e.listDropOverBackground} !important; color: inherit !important; }
			`), e.listDropBetweenBackground && (i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-before .monaco-list-row:first-child::before,
			.monaco-list${t} .monaco-list-row.drop-target-before::before {
				content: ""; position: absolute; top: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`), i.push(`
			.monaco-list${t} .monaco-list-rows.drop-target-after .monaco-list-row:last-child::after,
			.monaco-list${t} .monaco-list-row.drop-target-after::after {
				content: ""; position: absolute; bottom: 0px; left: 0px; width: 100%; height: 1px;
				background-color: ${e.listDropBetweenBackground};
			}`)), e.tableColumnsBorder && i.push(`
				.monaco-table > .monaco-split-view2,
				.monaco-table > .monaco-split-view2 .monaco-sash.vertical::before,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table:hover > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: ${e.tableColumnsBorder};
				}

				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2,
				.monaco-workbench:not(.reduce-motion) .monaco-table > .monaco-split-view2 .monaco-sash.vertical::before {
					border-color: transparent;
				}
			`), e.tableOddRowsBackgroundColor && i.push(`
				.monaco-table .monaco-list-row[data-parity=odd]:not(.focused):not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(:focus) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr,
				.monaco-table .monaco-list:not(.focused) .monaco-list-row[data-parity=odd].focused:not(.selected):not(:hover) .monaco-table-tr {
					background-color: ${e.tableOddRowsBackgroundColor};
				}
			`), this.styleElement.textContent = i.join(`
`);
  }
}
const T$ = {
  listFocusBackground: "#7FB0D0",
  listActiveSelectionBackground: "#0E639C",
  listActiveSelectionForeground: "#FFFFFF",
  listActiveSelectionIconForeground: "#FFFFFF",
  listFocusAndSelectionOutline: "#90C2F9",
  listFocusAndSelectionBackground: "#094771",
  listFocusAndSelectionForeground: "#FFFFFF",
  listInactiveSelectionBackground: "#3F3F46",
  listInactiveSelectionIconForeground: "#FFFFFF",
  listHoverBackground: "#2A2D2E",
  listDropOverBackground: "#383B3D",
  listDropBetweenBackground: "#EEEEEE",
  treeIndentGuidesStroke: "#a9a9a9",
  treeInactiveIndentGuidesStroke: Y.fromHex("#a9a9a9").transparent(0.4).toString(),
  tableColumnsBorder: Y.fromHex("#cccccc").transparent(0.2).toString(),
  tableOddRowsBackgroundColor: Y.fromHex("#cccccc").transparent(0.04).toString(),
  listBackground: void 0,
  listFocusForeground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusForeground: void 0,
  listInactiveFocusBackground: void 0,
  listHoverForeground: void 0,
  listFocusOutline: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listHoverOutline: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, B$ = {
  keyboardSupport: !0,
  mouseSupport: !0,
  multipleSelectionSupport: !0,
  dnd: {
    getDragURI() {
      return null;
    },
    onDragStart() {
    },
    onDragOver() {
      return !1;
    },
    drop() {
    },
    dispose() {
    }
  }
};
function R$(s, e) {
  const t = s.indexOf(e);
  if (t === -1)
    return [];
  const i = [];
  let n = t - 1;
  for (; n >= 0 && s[n] === e - (t - n); )
    i.push(s[n--]);
  for (i.reverse(), n = t; n < s.length && s[n] === e + (n - t); )
    i.push(s[n++]);
  return i;
}
function ZL(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      t.push(s[i]), i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : t.push(e[n++]);
  return t;
}
function F$(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length || n < e.length; )
    if (i >= s.length)
      t.push(e[n++]);
    else if (n >= e.length)
      t.push(s[i++]);
    else if (s[i] === e[n]) {
      i++, n++;
      continue;
    } else s[i] < e[n] ? t.push(s[i++]) : n++;
  return t;
}
const mF = (s, e) => s - e;
class O$ {
  constructor(e, t) {
    this._templateId = e, this.renderers = t;
  }
  get templateId() {
    return this._templateId;
  }
  renderTemplate(e) {
    return this.renderers.map((t) => t.renderTemplate(e));
  }
  renderElement(e, t, i, n) {
    let o = 0;
    for (const r of this.renderers)
      r.renderElement(e, t, i[o++], n);
  }
  disposeElement(e, t, i, n) {
    let o = 0;
    for (const r of this.renderers)
      r.disposeElement?.(e, t, i[o], n), o += 1;
  }
  disposeTemplate(e) {
    let t = 0;
    for (const i of this.renderers)
      i.disposeTemplate(e[t++]);
  }
}
class P$ {
  constructor(e) {
    this.accessibilityProvider = e, this.templateId = "a18n";
  }
  renderTemplate(e) {
    return { container: e, disposables: new X() };
  }
  renderElement(e, t, i) {
    const n = this.accessibilityProvider.getAriaLabel(e), o = n && typeof n != "string" ? n : RC(n);
    i.disposables.add(et((a) => {
      this.setAriaLabel(a.readObservable(o), i.container);
    }));
    const r = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(e);
    typeof r == "number" ? i.container.setAttribute("aria-level", `${r}`) : i.container.removeAttribute("aria-level");
  }
  setAriaLabel(e, t) {
    e ? t.setAttribute("aria-label", e) : t.removeAttribute("aria-label");
  }
  disposeElement(e, t, i, n) {
    i.disposables.clear();
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
}
class H$ {
  constructor(e, t) {
    this.list = e, this.dnd = t;
  }
  getDragElements(e) {
    const t = this.list.getSelectedElements();
    return t.indexOf(e) > -1 ? t : [e];
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e, t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart?.(e, t);
  }
  onDragOver(e, t, i, n, o) {
    return this.dnd.onDragOver(e, t, i, n, o);
  }
  onDragLeave(e, t, i, n) {
    this.dnd.onDragLeave?.(e, t, i, n);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd?.(e);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(e, t, i, n, o);
  }
  dispose() {
    this.dnd.dispose();
  }
}
class ko {
  get onDidChangeFocus() {
    return te.map(this.eventBufferer.wrapEvent(this.focus.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get onDidChangeSelection() {
    return te.map(this.eventBufferer.wrapEvent(this.selection.onChange), (e) => this.toListEvent(e), this.disposables);
  }
  get domId() {
    return this.view.domId;
  }
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onMouseClick() {
    return this.view.onMouseClick;
  }
  get onMouseDblClick() {
    return this.view.onMouseDblClick;
  }
  get onMouseMiddleClick() {
    return this.view.onMouseMiddleClick;
  }
  get onPointer() {
    return this.mouseController.onPointer;
  }
  get onMouseDown() {
    return this.view.onMouseDown;
  }
  get onMouseOver() {
    return this.view.onMouseOver;
  }
  get onMouseOut() {
    return this.view.onMouseOut;
  }
  get onTouchStart() {
    return this.view.onTouchStart;
  }
  get onTap() {
    return this.view.onTap;
  }
  /**
   * Possible context menu trigger events:
   * - ContextMenu key
   * - Shift F10
   * - Ctrl Option Shift M (macOS with VoiceOver)
   * - Mouse right click
   */
  get onContextMenu() {
    let e = !1;
    const t = te.chain(this.disposables.add(new Ke(this.view.domNode, "keydown")).event, (o) => o.map((r) => new Mt(r)).filter((r) => e = r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Ve.stop(r, !0)).filter(() => !1)), i = te.chain(this.disposables.add(new Ke(this.view.domNode, "keyup")).event, (o) => o.forEach(() => e = !1).map((r) => new Mt(r)).filter((r) => r.keyCode === 58 || r.shiftKey && r.keyCode === 68).map((r) => Ve.stop(r, !0)).map(({ browserEvent: r }) => {
      const a = this.getFocus(), l = a.length ? a[0] : void 0, c = typeof l < "u" ? this.view.element(l) : void 0, d = typeof l < "u" ? this.view.domElement(l) : this.view.domNode;
      return { index: l, element: c, anchor: d, browserEvent: r };
    })), n = te.chain(this.view.onContextMenu, (o) => o.filter((r) => !e).map(({ element: r, index: a, browserEvent: l }) => ({ element: r, index: a, anchor: new Ir(fe(this.view.domNode), l), browserEvent: l })));
    return te.any(t, i, n);
  }
  get onKeyDown() {
    return this.disposables.add(new Ke(this.view.domNode, "keydown")).event;
  }
  get onDidFocus() {
    return te.signal(this.disposables.add(new Ke(this.view.domNode, "focus", !0)).event);
  }
  get onDidBlur() {
    return te.signal(this.disposables.add(new Ke(this.view.domNode, "blur", !0)).event);
  }
  constructor(e, t, i, n, o = B$) {
    this.user = e, this._options = o, this.focus = new FC("focused"), this.anchor = new FC("anchor"), this.eventBufferer = new k_(), this._ariaLabel = "", this.disposables = new X(), this._onDidDispose = new B(), this.onDidDispose = this._onDidDispose.event;
    const r = this._options.accessibilityProvider && this._options.accessibilityProvider.getWidgetRole ? this._options.accessibilityProvider?.getWidgetRole() : "list";
    this.selection = new E$(r !== "listbox");
    const a = [this.focus.renderer, this.selection.renderer];
    this.accessibilityProvider = o.accessibilityProvider, this.accessibilityProvider && (a.push(new P$(this.accessibilityProvider)), this.accessibilityProvider.onDidChangeActiveDescendant?.(this.onDidChangeActiveDescendant, this, this.disposables)), n = n.map((c) => new O$(c.templateId, [...a, c]));
    const l = {
      ...o,
      dnd: o.dnd && new H$(this, o.dnd)
    };
    if (this.view = this.createListView(t, i, n, l), this.view.domNode.setAttribute("role", r), o.styleController)
      this.styleController = o.styleController(this.view.domId);
    else {
      const c = xo(this.view.domNode);
      this.styleController = new G3(c, this.view.domId);
    }
    if (this.spliceable = new p$([
      new Iy(this.focus, this.view, o.identityProvider),
      new Iy(this.selection, this.view, o.identityProvider),
      new Iy(this.anchor, this.view, o.identityProvider),
      this.view
    ]), this.disposables.add(this.focus), this.disposables.add(this.selection), this.disposables.add(this.anchor), this.disposables.add(this.view), this.disposables.add(this._onDidDispose), this.disposables.add(new M$(this, this.view)), (typeof o.keyboardSupport != "boolean" || o.keyboardSupport) && (this.keyboardController = new V3(this, this.view, o), this.disposables.add(this.keyboardController)), o.keyboardNavigationLabelProvider) {
      const c = o.keyboardNavigationDelegate || D$;
      this.typeNavigationController = new I$(this, this.view, o.keyboardNavigationLabelProvider, o.keyboardNavigationEventFilter ?? (() => !0), c), this.disposables.add(this.typeNavigationController);
    }
    this.mouseController = this.createMouseController(o), this.disposables.add(this.mouseController), this.onDidChangeFocus(this._onFocusChange, this, this.disposables), this.onDidChangeSelection(this._onSelectionChange, this, this.disposables), this.accessibilityProvider && (this.ariaLabel = this.accessibilityProvider.getWidgetAriaLabel()), this._options.multipleSelectionSupport !== !1 && this.view.domNode.setAttribute("aria-multiselectable", "true");
  }
  createListView(e, t, i, n) {
    return new er(e, t, i, n);
  }
  createMouseController(e) {
    return new Q3(this);
  }
  updateOptions(e = {}) {
    this._options = { ...this._options, ...e }, this.typeNavigationController?.updateOptions(this._options), this._options.multipleSelectionController !== void 0 && (this._options.multipleSelectionSupport ? this.view.domNode.setAttribute("aria-multiselectable", "true") : this.view.domNode.removeAttribute("aria-multiselectable")), this.mouseController.updateOptions(e), this.keyboardController?.updateOptions(e), this.view.updateOptions(e);
  }
  get options() {
    return this._options;
  }
  splice(e, t, i = []) {
    if (e < 0 || e > this.view.length)
      throw new Nd(this.user, `Invalid start index: ${e}`);
    if (t < 0)
      throw new Nd(this.user, `Invalid delete count: ${t}`);
    t === 0 && i.length === 0 || this.eventBufferer.bufferEvents(() => this.spliceable.splice(e, t, i));
  }
  rerender() {
    this.view.rerender();
  }
  element(e) {
    return this.view.element(e);
  }
  indexOf(e) {
    return this.view.indexOf(e);
  }
  indexAt(e) {
    return this.view.indexAt(e);
  }
  get length() {
    return this.view.length;
  }
  get contentHeight() {
    return this.view.contentHeight;
  }
  get onDidChangeContentHeight() {
    return this.view.onDidChangeContentHeight;
  }
  get scrollTop() {
    return this.view.getScrollTop();
  }
  set scrollTop(e) {
    this.view.setScrollTop(e);
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get firstVisibleIndex() {
    return this.view.firstVisibleIndex;
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.view.domNode.setAttribute("aria-label", e);
  }
  domFocus() {
    this.view.domNode.focus({ preventScroll: !0 });
  }
  layout(e, t) {
    this.view.layout(e, t);
  }
  setSelection(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Nd(this.user, `Invalid index ${i}`);
    this.selection.set(e, t);
  }
  getSelection() {
    return this.selection.get();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.view.element(e));
  }
  setAnchor(e) {
    if (typeof e > "u") {
      this.anchor.set([]);
      return;
    }
    if (e < 0 || e >= this.length)
      throw new Nd(this.user, `Invalid index ${e}`);
    this.anchor.set([e]);
  }
  getAnchor() {
    return vM(this.anchor.get(), void 0);
  }
  getAnchorElement() {
    const e = this.getAnchor();
    return typeof e > "u" ? void 0 : this.element(e);
  }
  setFocus(e, t) {
    for (const i of e)
      if (i < 0 || i >= this.length)
        throw new Nd(this.user, `Invalid index ${i}`);
    this.focus.set(e, t);
  }
  focusNext(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findNextIndex(o.length > 0 ? o[0] + e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  focusPrevious(e = 1, t = !1, i, n) {
    if (this.length === 0)
      return;
    const o = this.focus.get(), r = this.findPreviousIndex(o.length > 0 ? o[0] - e : 0, t, n);
    r > -1 && this.setFocus([r], i);
  }
  async focusNextPage(e, t) {
    let i = this.view.indexAt(this.view.getScrollTop() + this.view.renderHeight);
    i = i === 0 ? 0 : i - 1;
    const n = this.getFocus()[0];
    if (n !== i && (n === void 0 || i > n)) {
      const o = this.findPreviousIndex(i, !1, t);
      o > -1 && n !== o ? this.setFocus([o], e) : this.setFocus([i], e);
    } else {
      const o = this.view.getScrollTop();
      let r = o + this.view.renderHeight;
      i > n && (r -= this.view.elementHeight(i)), this.view.setScrollTop(r), this.view.getScrollTop() !== o && (this.setFocus([]), await MA(0), await this.focusNextPage(e, t));
    }
  }
  async focusPreviousPage(e, t, i = () => 0) {
    let n;
    const o = i(), r = this.view.getScrollTop() + o;
    r === 0 ? n = this.view.indexAt(r) : n = this.view.indexAfter(r - 1);
    const a = this.getFocus()[0];
    if (a !== n && (a === void 0 || a >= n)) {
      const l = this.findNextIndex(n, !1, t);
      l > -1 && a !== l ? this.setFocus([l], e) : this.setFocus([n], e);
    } else {
      const l = r;
      this.view.setScrollTop(r - this.view.renderHeight - o), this.view.getScrollTop() + i() !== l && (this.setFocus([]), await MA(0), await this.focusPreviousPage(e, t, i));
    }
  }
  focusLast(e, t) {
    if (this.length === 0)
      return;
    const i = this.findPreviousIndex(this.length - 1, !1, t);
    i > -1 && this.setFocus([i], e);
  }
  focusFirst(e, t) {
    this.focusNth(0, e, t);
  }
  focusNth(e, t, i) {
    if (this.length === 0)
      return;
    const n = this.findNextIndex(e, !1, i);
    n > -1 && this.setFocus([n], t);
  }
  findNextIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e >= this.length && !t)
        return -1;
      if (e = e % this.length, !i || i(this.element(e)))
        return e;
      e++;
    }
    return -1;
  }
  findPreviousIndex(e, t = !1, i) {
    for (let n = 0; n < this.length; n++) {
      if (e < 0 && !t)
        return -1;
      if (e = (this.length + e % this.length) % this.length, !i || i(this.element(e)))
        return e;
      e--;
    }
    return -1;
  }
  getFocus() {
    return this.focus.get();
  }
  getFocusedElements() {
    return this.getFocus().map((e) => this.view.element(e));
  }
  reveal(e, t, i = 0) {
    if (e < 0 || e >= this.length)
      throw new Nd(this.user, `Invalid index ${e}`);
    const n = this.view.getScrollTop(), o = this.view.elementTop(e), r = this.view.elementHeight(e);
    if (id(t)) {
      const a = r - this.view.renderHeight + i;
      this.view.setScrollTop(a * kn(t, 0, 1) + o - i);
    } else {
      const a = o + r, l = n + this.view.renderHeight;
      o < n + i && a >= l || (o < n + i || a >= l && r >= this.view.renderHeight ? this.view.setScrollTop(o - i) : a >= l && this.view.setScrollTop(a - this.view.renderHeight));
    }
  }
  /**
   * Returns the relative position of an element rendered in the list.
   * Returns `null` if the element isn't *entirely* in the visible viewport.
   */
  getRelativeTop(e, t = 0) {
    if (e < 0 || e >= this.length)
      throw new Nd(this.user, `Invalid index ${e}`);
    const i = this.view.getScrollTop(), n = this.view.elementTop(e), o = this.view.elementHeight(e);
    if (n < i + t || n + o > i + this.view.renderHeight)
      return null;
    const r = o - this.view.renderHeight + t;
    return Math.abs((i + t - n) / r);
  }
  getHTMLElement() {
    return this.view.domNode;
  }
  getScrollableElement() {
    return this.view.scrollableElementDomNode;
  }
  getElementID(e) {
    return this.view.getElementDomId(e);
  }
  getElementTop(e) {
    return this.view.elementTop(e);
  }
  style(e) {
    this.styleController.style(e);
  }
  toListEvent({ indexes: e, browserEvent: t }) {
    return { indexes: e, elements: e.map((i) => this.view.element(i)), browserEvent: t };
  }
  _onFocusChange() {
    const e = this.focus.get();
    this.view.domNode.classList.toggle("element-focused", e.length > 0), this.onDidChangeActiveDescendant();
  }
  onDidChangeActiveDescendant() {
    const e = this.focus.get();
    if (e.length > 0) {
      let t;
      this.accessibilityProvider?.getActiveDescendantId && (t = this.accessibilityProvider.getActiveDescendantId(this.view.element(e[0]))), this.view.domNode.setAttribute("aria-activedescendant", t || this.view.getElementDomId(e[0]));
    } else
      this.view.domNode.removeAttribute("aria-activedescendant");
  }
  _onSelectionChange() {
    const e = this.selection.get();
    this.view.domNode.classList.toggle("selection-none", e.length === 0), this.view.domNode.classList.toggle("selection-single", e.length === 1), this.view.domNode.classList.toggle("selection-multiple", e.length > 1);
  }
  dispose() {
    this._onDidDispose.fire(), this.disposables.dispose(), this._onDidDispose.dispose();
  }
}
vd([
  oi
], ko.prototype, "onDidChangeFocus", null);
vd([
  oi
], ko.prototype, "onDidChangeSelection", null);
vd([
  oi
], ko.prototype, "onContextMenu", null);
vd([
  oi
], ko.prototype, "onKeyDown", null);
vd([
  oi
], ko.prototype, "onDidFocus", null);
vd([
  oi
], ko.prototype, "onDidBlur", null);
const Ch = de, j3 = "selectOption.entry.template";
class W$ {
  get templateId() {
    return j3;
  }
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    return t.root = e, t.text = K(e, Ch(".option-text")), t.detail = K(e, Ch(".option-detail")), t.decoratorRight = K(e, Ch(".option-decorator-right")), t;
  }
  renderElement(e, t, i) {
    const n = i, o = e.text, r = e.detail, a = e.decoratorRight, l = e.isDisabled;
    n.text.textContent = o, n.detail.textContent = r || "", n.decoratorRight.innerText = a || "", l ? n.root.classList.add("option-disabled") : n.root.classList.remove("option-disabled");
  }
  disposeTemplate(e) {
  }
}
const na = class na extends V {
  constructor(e, t, i, n, o) {
    super(), this.options = [], this._currentSelection = 0, this._hasDetails = !1, this._skipLayout = !1, this._sticky = !1, this._isVisible = !1, this.styles = n, this.selectBoxOptions = o || /* @__PURE__ */ Object.create(null), typeof this.selectBoxOptions.minBottomMargin != "number" ? this.selectBoxOptions.minBottomMargin = na.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN : this.selectBoxOptions.minBottomMargin < 0 && (this.selectBoxOptions.minBottomMargin = 0), this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box monaco-select-box-dropdown-padding", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = new B(), this._register(this._onDidSelect), this.registerListeners(), this.constructSelectDropDown(i), this.selected = t || 0, e && this.setOptions(e, t), this.initStyleSheet();
  }
  setTitle(e) {
    !this._hover && e ? this._hover = this._register(Oa().setupManagedHover(Ls("mouse"), this.selectElement, e)) : this._hover && this._hover.update(e);
  }
  // IDelegate - List renderer
  getHeight() {
    return 22;
  }
  getTemplateId() {
    return j3;
  }
  constructSelectDropDown(e) {
    this.contextViewProvider = e, this.selectDropDownContainer = de(".monaco-select-box-dropdown-container"), this.selectDropDownContainer.classList.add("monaco-select-box-dropdown-padding"), this.selectionDetailsPane = K(this.selectDropDownContainer, Ch(".select-box-details-pane"));
    const t = K(this.selectDropDownContainer, Ch(".select-box-dropdown-container-width-control")), i = K(t, Ch(".width-control-div"));
    this.widthControlElement = document.createElement("span"), this.widthControlElement.className = "option-text-width-control", K(i, this.widthControlElement), this._dropDownPosition = 0, this.styleElement = xo(this.selectDropDownContainer), this.selectDropDownContainer.setAttribute("draggable", "true"), this._register(U(this.selectDropDownContainer, ee.DRAG_START, (n) => {
      Ve.stop(n, !0);
    }));
  }
  registerListeners() {
    this._register(Xt(this.selectElement, "change", (t) => {
      this.selected = t.target.selectedIndex, this._onDidSelect.fire({
        index: t.target.selectedIndex,
        selected: t.target.value
      }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
    })), this._register(U(this.selectElement, ee.CLICK, (t) => {
      Ve.stop(t), this._isVisible ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(U(this.selectElement, ee.MOUSE_DOWN, (t) => {
      Ve.stop(t);
    }));
    let e;
    this._register(U(this.selectElement, "touchstart", (t) => {
      e = this._isVisible;
    })), this._register(U(this.selectElement, "touchend", (t) => {
      Ve.stop(t), e ? this.hideSelectDropDown(!0) : this.showSelectDropDown();
    })), this._register(U(this.selectElement, ee.KEY_DOWN, (t) => {
      const i = new Mt(t);
      let n = !1;
      ze ? (i.keyCode === 18 || i.keyCode === 16 || i.keyCode === 10 || i.keyCode === 3) && (n = !0) : (i.keyCode === 18 && i.altKey || i.keyCode === 16 && i.altKey || i.keyCode === 10 || i.keyCode === 3) && (n = !0), n && (this.showSelectDropDown(), Ve.stop(t, !0));
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    pi(this.options, e) || (this.options = e, this.selectElement.options.length = 0, this._hasDetails = !1, this._cachedMaxDetailsHeight = void 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled)), typeof i.description == "string" && (this._hasDetails = !0);
    })), t !== void 0 && (this.select(t), this._currentSelection = this.selected);
  }
  setOptionsList() {
    this.selectList?.splice(0, this.selectList.length, this.options);
  }
  select(e) {
    e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text);
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    this.container = e, e.classList.add("select-container"), e.appendChild(this.selectElement), this.styleSelectElement();
  }
  initStyleSheet() {
    const e = [];
    this.styles.listFocusBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { background-color: ${this.styles.listFocusBackground} !important; }`), this.styles.listFocusForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { color: ${this.styles.listFocusForeground} !important; }`), this.styles.decoratorRightForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.focused) .option-decorator-right { color: ${this.styles.decoratorRightForeground}; }`), this.styles.selectBackground && this.styles.selectBorder && this.styles.selectBorder !== this.styles.selectBackground ? (e.push(`.monaco-select-box-dropdown-container { border: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectBorder} } `)) : this.styles.selectListBorder && (e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-top { border-top: 1px solid ${this.styles.selectListBorder} } `), e.push(`.monaco-select-box-dropdown-container > .select-box-details-pane.border-bottom { border-bottom: 1px solid ${this.styles.selectListBorder} } `)), this.styles.listHoverForeground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { color: ${this.styles.listHoverForeground} !important; }`), this.styles.listHoverBackground && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { background-color: ${this.styles.listHoverBackground} !important; }`), this.styles.listFocusOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.focused { outline: 1.6px dotted ${this.styles.listFocusOutline} !important; outline-offset: -1.6px !important; }`), this.styles.listHoverOutline && e.push(`.monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row:not(.option-disabled):not(.focused):hover { outline: 1.6px dashed ${this.styles.listHoverOutline} !important; outline-offset: -1.6px !important; }`), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled.focused { background-color: transparent !important; color: inherit !important; outline: none !important; }"), e.push(".monaco-select-box-dropdown-container > .select-box-dropdown-list-container .monaco-list .monaco-list-row.option-disabled:hover { background-color: transparent !important; color: inherit !important; outline: none !important; }"), this.styleElement.textContent = e.join(`
`);
  }
  styleSelectElement() {
    const e = this.styles.selectBackground ?? "", t = this.styles.selectForeground ?? "", i = this.styles.selectBorder ?? "";
    this.selectElement.style.backgroundColor = e, this.selectElement.style.color = t, this.selectElement.style.borderColor = i;
  }
  styleList() {
    const e = this.styles.selectBackground ?? "", t = Tl(this.styles.selectListBackground, e);
    this.selectDropDownListContainer.style.backgroundColor = t, this.selectionDetailsPane.style.backgroundColor = t;
    const i = this.styles.focusBorder ?? "";
    this.selectDropDownContainer.style.outlineColor = i, this.selectDropDownContainer.style.outlineOffset = "-1px", this.selectList.style(this.styles);
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
  // ContextView dropdown methods
  showSelectDropDown() {
    this.selectionDetailsPane.innerText = "", !(!this.contextViewProvider || this._isVisible) && (this.createSelectList(this.selectDropDownContainer), this.setOptionsList(), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e, !0),
      layout: () => {
        this.layoutSelectDropDown();
      },
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._isVisible = !0, this.hideSelectDropDown(!1), this.contextViewProvider.showContextView({
      getAnchor: () => this.selectElement,
      render: (e) => this.renderSelectDropDown(e),
      layout: () => this.layoutSelectDropDown(),
      onHide: () => {
        this.selectDropDownContainer.classList.remove("visible"), this.selectElement.classList.remove("synthetic-focus");
      },
      anchorPosition: this._dropDownPosition
    }, this.selectBoxOptions.optionsAsChildren ? this.container : void 0), this._currentSelection = this.selected, this._isVisible = !0, this.selectElement.setAttribute("aria-expanded", "true"));
  }
  hideSelectDropDown(e) {
    !this.contextViewProvider || !this._isVisible || (this._isVisible = !1, this.selectElement.setAttribute("aria-expanded", "false"), e && this.selectElement.focus(), this.contextViewProvider.hideContextView());
  }
  renderSelectDropDown(e, t) {
    return e.appendChild(this.selectDropDownContainer), this.layoutSelectDropDown(t), {
      dispose: () => {
        this.selectDropDownContainer.remove();
      }
    };
  }
  // Iterate over detailed descriptions, find max height
  measureMaxDetailsHeight() {
    let e = 0;
    return this.options.forEach((t, i) => {
      this.updateDetail(i), this.selectionDetailsPane.offsetHeight > e && (e = this.selectionDetailsPane.offsetHeight);
    }), e;
  }
  layoutSelectDropDown(e) {
    if (this._skipLayout)
      return !1;
    if (this.selectList) {
      this.selectDropDownContainer.classList.add("visible");
      const t = fe(this.selectElement), i = ui(this.selectElement), n = fe(this.selectElement).getComputedStyle(this.selectElement), o = parseFloat(n.getPropertyValue("--dropdown-padding-top")) + parseFloat(n.getPropertyValue("--dropdown-padding-bottom")), r = t.innerHeight - i.top - i.height - (this.selectBoxOptions.minBottomMargin || 0), a = i.top - na.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN, l = this.selectElement.offsetWidth, c = this.setWidthControlElement(this.widthControlElement), d = Math.max(c, Math.round(l)).toString() + "px";
      this.selectDropDownContainer.style.width = d, this.selectList.getHTMLElement().style.height = "", this.selectList.layout();
      let h = this.selectList.contentHeight;
      this._hasDetails && this._cachedMaxDetailsHeight === void 0 && (this._cachedMaxDetailsHeight = this.measureMaxDetailsHeight());
      const u = this._hasDetails ? this._cachedMaxDetailsHeight : 0, g = h + o + u, m = Math.floor((r - o - u) / this.getHeight()), p = Math.floor((a - o - u) / this.getHeight());
      if (e)
        return i.top + i.height > t.innerHeight - 22 || i.top < na.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || m < 1 && p < 1 ? !1 : (m < na.DEFAULT_MINIMUM_VISIBLE_OPTIONS && p > m && this.options.length > m ? (this._dropDownPosition = 1, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectionDetailsPane.classList.remove("border-top"), this.selectionDetailsPane.classList.add("border-bottom")) : (this._dropDownPosition = 0, this.selectDropDownListContainer.remove(), this.selectionDetailsPane.remove(), this.selectDropDownContainer.appendChild(this.selectDropDownListContainer), this.selectDropDownContainer.appendChild(this.selectionDetailsPane), this.selectionDetailsPane.classList.remove("border-bottom"), this.selectionDetailsPane.classList.add("border-top")), !0);
      if (i.top + i.height > t.innerHeight - 22 || i.top < na.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN || this._dropDownPosition === 0 && m < 1 || this._dropDownPosition === 1 && p < 1)
        return this.hideSelectDropDown(!0), !1;
      if (this._dropDownPosition === 0) {
        if (this._isVisible && m + p < 1)
          return this.hideSelectDropDown(!0), !1;
        g > r && (h = m * this.getHeight());
      } else
        g > a && (h = p * this.getHeight());
      return this.selectList.layout(h), this.selectList.domFocus(), this.selectList.length > 0 && (this.selectList.setFocus([this.selected || 0]), this.selectList.reveal(this.selectList.getFocus()[0] || 0)), this._hasDetails ? (this.selectList.getHTMLElement().style.height = h + o + "px", this.selectDropDownContainer.style.height = "") : this.selectDropDownContainer.style.height = h + o + "px", this.updateDetail(this.selected), this.selectDropDownContainer.style.width = d, this.selectDropDownListContainer.setAttribute("tabindex", "0"), this.selectElement.classList.add("synthetic-focus"), this.selectDropDownContainer.classList.add("synthetic-focus"), !0;
    } else
      return !1;
  }
  setWidthControlElement(e) {
    let t = 0;
    if (e) {
      let i = 0, n = 0;
      this.options.forEach((o, r) => {
        const a = o.detail ? o.detail.length : 0, l = o.decoratorRight ? o.decoratorRight.length : 0, c = o.text.length + a + l;
        c > n && (i = r, n = c);
      }), e.textContent = this.options[i].text + (this.options[i].decoratorRight ? this.options[i].decoratorRight + " " : ""), t = Rs(e);
    }
    return t;
  }
  createSelectList(e) {
    if (this.selectList)
      return;
    this.selectDropDownListContainer = K(e, Ch(".select-box-dropdown-list-container")), this.listRenderer = new W$(), this.selectList = this._register(new ko("SelectBoxCustom", this.selectDropDownListContainer, this, [this.listRenderer], {
      useShadows: !1,
      verticalScrollMode: 3,
      keyboardSupport: !1,
      mouseSupport: !1,
      accessibilityProvider: {
        getAriaLabel: (n) => {
          let o = n.text;
          return n.detail && (o += `. ${n.detail}`), n.decoratorRight && (o += `. ${n.decoratorRight}`), n.description && (o += `. ${n.description}`), o;
        },
        getWidgetAriaLabel: () => f({ key: "selectBox", comment: ["Behave like native select dropdown element."] }, "Select Box"),
        getRole: () => ze ? "" : "option",
        getWidgetRole: () => "listbox"
      }
    })), this.selectBoxOptions.ariaLabel && (this.selectList.ariaLabel = this.selectBoxOptions.ariaLabel);
    const t = this._register(new Ke(this.selectDropDownListContainer, "keydown")), i = te.chain(t.event, (n) => n.filter(() => this.selectList.length > 0).map((o) => new Mt(o)));
    this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 3
      /* KeyCode.Enter */
    ))(this.onEnter, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 2
      /* KeyCode.Tab */
    ))(this.onEnter, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 9
      /* KeyCode.Escape */
    ))(this.onEscape, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 16
      /* KeyCode.UpArrow */
    ))(this.onUpArrow, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 18
      /* KeyCode.DownArrow */
    ))(this.onDownArrow, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 12
      /* KeyCode.PageDown */
    ))(this.onPageDown, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 11
      /* KeyCode.PageUp */
    ))(this.onPageUp, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 14
      /* KeyCode.Home */
    ))(this.onHome, this)), this._register(te.chain(i, (n) => n.filter(
      (o) => o.keyCode === 13
      /* KeyCode.End */
    ))(this.onEnd, this)), this._register(te.chain(i, (n) => n.filter((o) => o.keyCode >= 21 && o.keyCode <= 56 || o.keyCode >= 85 && o.keyCode <= 113))(this.onCharacter, this)), this._register(U(this.selectList.getHTMLElement(), ee.POINTER_UP, (n) => this.onPointerUp(n))), this._register(this.selectList.onMouseOver((n) => typeof n.index < "u" && this.selectList.setFocus([n.index]))), this._register(this.selectList.onDidChangeFocus((n) => this.onListFocus(n))), this._register(U(this.selectDropDownContainer, ee.FOCUS_OUT, (n) => {
      !this._isVisible || yi(n.relatedTarget, this.selectDropDownContainer) || this.onListBlur();
    })), this.selectList.getHTMLElement().setAttribute("aria-label", this.selectBoxOptions.ariaLabel || ""), this.selectList.getHTMLElement().setAttribute("aria-expanded", "true"), this.styleList();
  }
  // List methods
  // List mouse controller - active exit, select option, fire onDidSelect if change, return focus to parent select
  // Also takes in touchend events
  onPointerUp(e) {
    if (!this.selectList.length)
      return;
    Ve.stop(e);
    const t = e.target;
    if (!t || t.classList.contains("slider"))
      return;
    const i = t.closest(".monaco-list-row");
    if (!i)
      return;
    const n = Number(i.getAttribute("data-index")), o = i.classList.contains("option-disabled");
    n >= 0 && n < this.options.length && !o && (this.selected = n, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0));
  }
  // List Exit - passive - implicit no selection change, hide drop-down
  onListBlur() {
    this._sticky || (this.selected !== this._currentSelection && this.select(this._currentSelection), this.hideSelectDropDown(!1));
  }
  renderDescriptionMarkdown(e, t) {
    const i = (o) => {
      for (let r = 0; r < o.childNodes.length; r++) {
        const a = o.childNodes.item(r);
        (a.tagName && a.tagName.toLowerCase()) === "img" ? a.remove() : i(a);
      }
    }, n = Z0({ value: e, supportThemeIcons: !0 }, { actionHandler: t });
    return n.element.classList.add("select-box-description-markdown"), i(n.element), n.element;
  }
  // List Focus Change - passive - update details pane with newly focused element's data
  onListFocus(e) {
    !this._isVisible || !this._hasDetails || this.updateDetail(e.indexes[0]);
  }
  updateDetail(e) {
    this.selectionDetailsPane.innerText = "";
    const t = this.options[e], i = t?.description ?? "", n = t?.descriptionIsMarkdown ?? !1;
    if (i) {
      if (n) {
        const o = t.descriptionMarkdownActionHandler;
        this.selectionDetailsPane.appendChild(this.renderDescriptionMarkdown(i, o));
      } else
        this.selectionDetailsPane.innerText = i;
      this.selectionDetailsPane.style.display = "block";
    } else
      this.selectionDetailsPane.style.display = "none";
    this._skipLayout = !0, this.contextViewProvider.layout(), this._skipLayout = !1;
  }
  // List keyboard controller
  // List exit - active - hide ContextView dropdown, reset selection, return focus to parent select
  onEscape(e) {
    Ve.stop(e), this.select(this._currentSelection), this.hideSelectDropDown(!0);
  }
  // List exit - active - hide ContextView dropdown, return focus to parent select, fire onDidSelect if change
  onEnter(e) {
    Ve.stop(e), this.selected !== this._currentSelection && (this._currentSelection = this.selected, this._onDidSelect.fire({
      index: this.selectElement.selectedIndex,
      selected: this.options[this.selected].text
    }), this.options[this.selected] && this.options[this.selected].text && this.setTitle(this.options[this.selected].text)), this.hideSelectDropDown(!0);
  }
  // List navigation - have to handle a disabled option (jump over)
  onDownArrow(e) {
    if (this.selected < this.options.length - 1) {
      Ve.stop(e, !0);
      const t = this.options[this.selected + 1].isDisabled;
      if (t && this.options.length > this.selected + 2)
        this.selected += 2;
      else {
        if (t)
          return;
        this.selected++;
      }
      this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]);
    }
  }
  onUpArrow(e) {
    this.selected > 0 && (Ve.stop(e, !0), this.options[this.selected - 1].isDisabled && this.selected > 1 ? this.selected -= 2 : this.selected--, this.select(this.selected), this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selectList.getFocus()[0]));
  }
  onPageUp(e) {
    Ve.stop(e), this.selectList.focusPreviousPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected < this.options.length - 1 && (this.selected++, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onPageDown(e) {
    Ve.stop(e), this.selectList.focusNextPage(), setTimeout(() => {
      this.selected = this.selectList.getFocus()[0], this.options[this.selected].isDisabled && this.selected > 0 && (this.selected--, this.selectList.setFocus([this.selected])), this.selectList.reveal(this.selected), this.select(this.selected);
    }, 1);
  }
  onHome(e) {
    Ve.stop(e), !(this.options.length < 2) && (this.selected = 0, this.options[this.selected].isDisabled && this.selected > 1 && this.selected++, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  onEnd(e) {
    Ve.stop(e), !(this.options.length < 2) && (this.selected = this.options.length - 1, this.options[this.selected].isDisabled && this.selected > 1 && this.selected--, this.selectList.setFocus([this.selected]), this.selectList.reveal(this.selected), this.select(this.selected));
  }
  // Mimic option first character navigation of native select
  onCharacter(e) {
    const t = ul.toString(e.keyCode);
    let i = -1;
    for (let n = 0; n < this.options.length - 1; n++)
      if (i = (n + this.selected + 1) % this.options.length, this.options[i].text.charAt(0).toUpperCase() === t && !this.options[i].isDisabled) {
        this.select(i), this.selectList.setFocus([i]), this.selectList.reveal(this.selectList.getFocus()[0]), Ve.stop(e);
        break;
      }
  }
  dispose() {
    this.hideSelectDropDown(!1), super.dispose();
  }
};
na.DEFAULT_DROPDOWN_MINIMUM_BOTTOM_MARGIN = 32, na.DEFAULT_DROPDOWN_MINIMUM_TOP_MARGIN = 2, na.DEFAULT_MINIMUM_VISIBLE_OPTIONS = 3;
let ek = na;
class V$ extends V {
  constructor(e, t, i, n) {
    super(), this.selected = 0, this.selectBoxOptions = n || /* @__PURE__ */ Object.create(null), this.options = [], this.selectElement = document.createElement("select"), this.selectElement.className = "monaco-select-box", typeof this.selectBoxOptions.ariaLabel == "string" && this.selectElement.setAttribute("aria-label", this.selectBoxOptions.ariaLabel), typeof this.selectBoxOptions.ariaDescription == "string" && this.selectElement.setAttribute("aria-description", this.selectBoxOptions.ariaDescription), this._onDidSelect = this._register(new B()), this.styles = i, this.registerListeners(), this.setOptions(e, t);
  }
  registerListeners() {
    this._register(xn.addTarget(this.selectElement)), [Et.Tap].forEach((e) => {
      this._register(U(this.selectElement, e, (t) => {
        this.selectElement.focus();
      }));
    }), this._register(Xt(this.selectElement, "click", (e) => {
      Ve.stop(e, !0);
    })), this._register(Xt(this.selectElement, "change", (e) => {
      this.selectElement.title = e.target.value, this._onDidSelect.fire({
        index: e.target.selectedIndex,
        selected: e.target.value
      });
    })), this._register(Xt(this.selectElement, "keydown", (e) => {
      let t = !1;
      ze ? (e.keyCode === 18 || e.keyCode === 16 || e.keyCode === 10) && (t = !0) : (e.keyCode === 18 && e.altKey || e.keyCode === 10 || e.keyCode === 3) && (t = !0), t && e.stopPropagation();
    }));
  }
  get onDidSelect() {
    return this._onDidSelect.event;
  }
  setOptions(e, t) {
    (!this.options || !pi(this.options, e)) && (this.options = e, this.selectElement.options.length = 0, this.options.forEach((i, n) => {
      this.selectElement.add(this.createOption(i.text, n, i.isDisabled));
    })), t !== void 0 && this.select(t);
  }
  select(e) {
    this.options.length === 0 ? this.selected = 0 : e >= 0 && e < this.options.length ? this.selected = e : e > this.options.length - 1 ? this.select(this.options.length - 1) : this.selected < 0 && (this.selected = 0), this.selectElement.selectedIndex = this.selected, this.selected < this.options.length && typeof this.options[this.selected].text == "string" ? this.selectElement.title = this.options[this.selected].text : this.selectElement.title = "";
  }
  focus() {
    this.selectElement && (this.selectElement.tabIndex = 0, this.selectElement.focus());
  }
  blur() {
    this.selectElement && (this.selectElement.tabIndex = -1, this.selectElement.blur());
  }
  setFocusable(e) {
    this.selectElement.tabIndex = e ? 0 : -1;
  }
  render(e) {
    e.classList.add("select-container"), e.appendChild(this.selectElement), this.setOptions(this.options, this.selected), this.applyStyles();
  }
  applyStyles() {
    this.selectElement && (this.selectElement.style.backgroundColor = this.styles.selectBackground ?? "", this.selectElement.style.color = this.styles.selectForeground ?? "", this.selectElement.style.borderColor = this.styles.selectBorder ?? "");
  }
  createOption(e, t, i) {
    const n = document.createElement("option");
    return n.value = e, n.text = e, n.disabled = !!i, n;
  }
}
class z$ extends to {
  constructor(e, t, i, n, o) {
    super(), ze && !o?.useCustomDrawn ? this.selectBoxDelegate = new V$(e, t, n, o) : this.selectBoxDelegate = new ek(e, t, i, n, o), this._register(this.selectBoxDelegate);
  }
  // Public SelectBox Methods - routed through delegate interface
  get onDidSelect() {
    return this.selectBoxDelegate.onDidSelect;
  }
  setOptions(e, t) {
    this.selectBoxDelegate.setOptions(e, t);
  }
  select(e) {
    this.selectBoxDelegate.select(e);
  }
  focus() {
    this.selectBoxDelegate.focus();
  }
  blur() {
    this.selectBoxDelegate.blur();
  }
  setFocusable(e) {
    this.selectBoxDelegate.setFocusable(e);
  }
  render(e) {
    this.selectBoxDelegate.render(e);
  }
}
class Er extends V {
  get action() {
    return this._action;
  }
  constructor(e, t, i = {}) {
    super(), this.options = i, this._context = e || this, this._action = t, t instanceof Ks && this._register(t.onDidChange((n) => {
      this.element && this.handleActionChangeEvent(n);
    }));
  }
  handleActionChangeEvent(e) {
    e.enabled !== void 0 && this.updateEnabled(), e.checked !== void 0 && this.updateChecked(), e.class !== void 0 && this.updateClass(), e.label !== void 0 && (this.updateLabel(), this.updateTooltip()), e.tooltip !== void 0 && this.updateTooltip();
  }
  get actionRunner() {
    return this._actionRunner || (this._actionRunner = this._register(new Au())), this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e;
  }
  isEnabled() {
    return this._action.enabled;
  }
  setActionContext(e) {
    this._context = e;
  }
  render(e) {
    const t = this.element = e;
    this._register(xn.addTarget(e));
    const i = this.options && this.options.draggable;
    i && (e.draggable = !0, Ko && this._register(U(e, ee.DRAG_START, (n) => n.dataTransfer?.setData(P3.TEXT, this._action.label)))), this._register(U(t, Et.Tap, (n) => this.onClick(n, !0))), this._register(U(t, ee.MOUSE_DOWN, (n) => {
      i || Ve.stop(n, !0), this._action.enabled && n.button === 0 && t.classList.add("active");
    })), ze && this._register(U(t, ee.CONTEXT_MENU, (n) => {
      n.button === 0 && n.ctrlKey === !0 && this.onClick(n);
    })), this._register(U(t, ee.CLICK, (n) => {
      Ve.stop(n, !0), this.options && this.options.isMenu || this.onClick(n);
    })), this._register(U(t, ee.DBLCLICK, (n) => {
      Ve.stop(n, !0);
    })), [ee.MOUSE_UP, ee.MOUSE_OUT].forEach((n) => {
      this._register(U(t, n, (o) => {
        Ve.stop(o), t.classList.remove("active");
      }));
    });
  }
  onClick(e, t = !1) {
    Ve.stop(e, !0);
    const i = Ws(this._context) ? this.options?.useEventAsContext ? e : { preserveFocus: t } : this._context;
    this.actionRunner.run(this._action, i);
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.element && (this.element.tabIndex = 0, this.element.focus(), this.element.classList.add("focused"));
  }
  blur() {
    this.element && (this.element.blur(), this.element.tabIndex = -1, this.element.classList.remove("focused"));
  }
  setFocusable(e) {
    this.element && (this.element.tabIndex = e ? 0 : -1);
  }
  get trapsArrowNavigation() {
    return !1;
  }
  updateEnabled() {
  }
  updateLabel() {
  }
  getClass() {
    return this.action.class;
  }
  getTooltip() {
    return this.action.tooltip;
  }
  updateTooltip() {
    if (!this.element)
      return;
    const e = this.getTooltip() ?? "";
    if (this.updateAriaLabel(), this.options.hoverDelegate?.showNativeHover)
      this.element.title = e;
    else if (!this.customHover && e !== "") {
      const t = this.options.hoverDelegate ?? Ls("element");
      this.customHover = this._store.add(Oa().setupManagedHover(t, this.element, e));
    } else this.customHover && this.customHover.update(e);
  }
  updateAriaLabel() {
    if (this.element) {
      const e = this.getTooltip() ?? "";
      this.element.setAttribute("aria-label", e);
    }
  }
  updateClass() {
  }
  updateChecked() {
  }
  dispose() {
    this.element && (this.element.remove(), this.element = void 0), this._context = void 0, super.dispose();
  }
}
class nm extends Er {
  constructor(e, t, i) {
    super(e, t, i), this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "";
  }
  render(e) {
    super.render(e), jt(this.element);
    const t = document.createElement("a");
    if (t.classList.add("action-label"), t.setAttribute("role", this.getDefaultAriaRole()), this.label = t, this.element.appendChild(t), this.options.label && this.options.keybinding) {
      const i = document.createElement("span");
      i.classList.add("keybinding"), i.textContent = this.options.keybinding, this.element.appendChild(i);
    }
    this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked();
  }
  getDefaultAriaRole() {
    return this._action.id === Ri.ID ? "presentation" : this.options.isMenu ? "menuitem" : this.options.isTabList ? "tab" : "button";
  }
  // Only set the tabIndex on the element once it is about to get focused
  // That way this element wont be a tab stop when it is not needed #106441
  focus() {
    this.label && (this.label.tabIndex = 0, this.label.focus());
  }
  blur() {
    this.label && (this.label.tabIndex = -1);
  }
  setFocusable(e) {
    this.label && (this.label.tabIndex = e ? 0 : -1);
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this.action.label);
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : !this.options.label && this.action.label && this.options.icon && (e = this.action.label, this.options.keybinding && (e = f({ key: "titleLabel", comment: ["action title", "action keybinding"] }, "{0} ({1})", e, this.options.keybinding))), e ?? void 0;
  }
  updateClass() {
    this.cssClass && this.label && this.label.classList.remove(...this.cssClass.split(" ")), this.options.icon ? (this.cssClass = this.getClass(), this.label && (this.label.classList.add("codicon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" "))), this.updateEnabled()) : this.label?.classList.remove("codicon");
  }
  updateEnabled() {
    this.action.enabled ? (this.label && (this.label.removeAttribute("aria-disabled"), this.label.classList.remove("disabled")), this.element?.classList.remove("disabled")) : (this.label && (this.label.setAttribute("aria-disabled", "true"), this.label.classList.add("disabled")), this.element?.classList.add("disabled"));
  }
  updateAriaLabel() {
    if (this.label) {
      const e = this.getTooltip() ?? "";
      this.label.setAttribute("aria-label", e);
    }
  }
  updateChecked() {
    this.label && (this.action.checked !== void 0 ? (this.label.classList.toggle("checked", this.action.checked), this.options.isTabList ? this.label.setAttribute("aria-selected", this.action.checked ? "true" : "false") : (this.label.setAttribute("aria-checked", this.action.checked ? "true" : "false"), this.label.setAttribute("role", "checkbox"))) : (this.label.classList.remove("checked"), this.label.removeAttribute(this.options.isTabList ? "aria-selected" : "aria-checked"), this.label.setAttribute("role", this.getDefaultAriaRole())));
  }
}
class U$ extends Er {
  constructor(e, t, i, n, o, r, a) {
    super(e, t), this.selectBox = new z$(i, n, o, r, a), this.selectBox.setFocusable(!1), this._register(this.selectBox), this.registerListeners();
  }
  select(e) {
    this.selectBox.select(e);
  }
  registerListeners() {
    this._register(this.selectBox.onDidSelect((e) => this.runAction(e.selected, e.index)));
  }
  runAction(e, t) {
    this.actionRunner.run(this._action, this.getActionContext(e, t));
  }
  getActionContext(e, t) {
    return e;
  }
  setFocusable(e) {
    this.selectBox.setFocusable(e);
  }
  focus() {
    this.selectBox?.focus();
  }
  blur() {
    this.selectBox?.blur();
  }
  render(e) {
    this.selectBox.render(e);
  }
}
class Q$ extends Au {
  constructor(e, t) {
    super(), this._onDidChangeVisibility = this._register(new B()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this._element = K(e, de(".monaco-dropdown")), this._label = K(this._element, de(".dropdown-label"));
    let i = t.labelRenderer;
    i || (i = (o) => (o.textContent = t.label || "", null));
    for (const o of [ee.CLICK, ee.MOUSE_DOWN, Et.Tap])
      this._register(U(this.element, o, (r) => Ve.stop(r, !0)));
    for (const o of [ee.MOUSE_DOWN, Et.Tap])
      this._register(U(this._label, o, (r) => {
        qM(r) && (r.detail > 1 || r.button !== 0) || (this.visible ? this.hide() : this.show());
      }));
    this._register(U(this._label, ee.KEY_UP, (o) => {
      const r = new Mt(o);
      (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) && (Ve.stop(o, !0), this.visible ? this.hide() : this.show());
    }));
    const n = i(this._label);
    n && this._register(n), this._register(xn.addTarget(this._label));
  }
  get element() {
    return this._element;
  }
  show() {
    this.visible || (this.visible = !0, this._onDidChangeVisibility.fire(!0));
  }
  hide() {
    this.visible && (this.visible = !1, this._onDidChangeVisibility.fire(!1));
  }
  dispose() {
    super.dispose(), this.hide(), this.boxContainer && (this.boxContainer.remove(), this.boxContainer = void 0), this.contents && (this.contents.remove(), this.contents = void 0), this._label && (this._label.remove(), this._label = void 0);
  }
}
class G$ extends Q$ {
  constructor(e, t) {
    super(e, t), this._options = t, this._actions = [], this.actions = t.actions || [];
  }
  set menuOptions(e) {
    this._menuOptions = e;
  }
  get menuOptions() {
    return this._menuOptions;
  }
  get actions() {
    return this._options.actionProvider ? this._options.actionProvider.getActions() : this._actions;
  }
  set actions(e) {
    this._actions = e;
  }
  show() {
    super.show(), this.element.classList.add("active"), this._options.contextMenuProvider.showContextMenu({
      getAnchor: () => this.element,
      getActions: () => this.actions,
      getActionsContext: () => this.menuOptions ? this.menuOptions.context : null,
      getActionViewItem: (e, t) => this.menuOptions && this.menuOptions.actionViewItemProvider ? this.menuOptions.actionViewItemProvider(e, t) : void 0,
      getKeyBinding: (e) => this.menuOptions && this.menuOptions.getKeyBinding ? this.menuOptions.getKeyBinding(e) : void 0,
      getMenuClassName: () => this._options.menuClassName || "",
      onHide: () => this.onHide(),
      actionRunner: this.menuOptions ? this.menuOptions.actionRunner : void 0,
      anchorAlignment: this.menuOptions ? this.menuOptions.anchorAlignment : 0,
      domForShadowRoot: this._options.menuAsChild ? this.element : void 0,
      skipTelemetry: this._options.skipTelemetry
    });
  }
  hide() {
    super.hide();
  }
  onHide() {
    this.hide(), this.element.classList.remove("active");
  }
}
class OC extends Er {
  constructor(e, t, i, n = /* @__PURE__ */ Object.create(null)) {
    super(null, e, n), this.actionItem = null, this._onDidChangeVisibility = this._register(new B()), this.onDidChangeVisibility = this._onDidChangeVisibility.event, this.menuActionsOrProvider = t, this.contextMenuProvider = i, this.options = n, this.options.actionRunner && (this.actionRunner = this.options.actionRunner);
  }
  render(e) {
    this.actionItem = e;
    const t = (o) => {
      this.element = K(o, de("a.action-label"));
      let r = [];
      return typeof this.options.classNames == "string" ? r = this.options.classNames.split(/\s+/g).filter((a) => !!a) : this.options.classNames && (r = this.options.classNames), r.find((a) => a === "icon") || r.push("codicon"), this.element.classList.add(...r), this.element.setAttribute("role", "button"), this.element.setAttribute("aria-haspopup", "true"), this.element.setAttribute("aria-expanded", "false"), this._action.label && this._register(Oa().setupManagedHover(this.options.hoverDelegate ?? Ls("mouse"), this.element, this._action.label)), this.element.ariaLabel = this._action.label || "", null;
    }, i = Array.isArray(this.menuActionsOrProvider), n = {
      contextMenuProvider: this.contextMenuProvider,
      labelRenderer: t,
      menuAsChild: this.options.menuAsChild,
      actions: i ? this.menuActionsOrProvider : void 0,
      actionProvider: i ? void 0 : this.menuActionsOrProvider,
      skipTelemetry: this.options.skipTelemetry
    };
    if (this.dropdownMenu = this._register(new G$(e, n)), this._register(this.dropdownMenu.onDidChangeVisibility((o) => {
      this.element?.setAttribute("aria-expanded", `${o}`), this._onDidChangeVisibility.fire(o);
    })), this.dropdownMenu.menuOptions = {
      actionViewItemProvider: this.options.actionViewItemProvider,
      actionRunner: this.actionRunner,
      getKeyBinding: this.options.keybindingProvider,
      context: this._context
    }, this.options.anchorAlignmentProvider) {
      const o = this;
      this.dropdownMenu.menuOptions = {
        ...this.dropdownMenu.menuOptions,
        get anchorAlignment() {
          return o.options.anchorAlignmentProvider();
        }
      };
    }
    this.updateTooltip(), this.updateEnabled();
  }
  getTooltip() {
    let e = null;
    return this.action.tooltip ? e = this.action.tooltip : this.action.label && (e = this.action.label), e ?? void 0;
  }
  setActionContext(e) {
    super.setActionContext(e), this.dropdownMenu && (this.dropdownMenu.menuOptions ? this.dropdownMenu.menuOptions.context = e : this.dropdownMenu.menuOptions = { context: e });
  }
  show() {
    this.dropdownMenu?.show();
  }
  updateEnabled() {
    const e = !this.action.enabled;
    this.actionItem?.classList.toggle("disabled", e), this.element?.classList.toggle("disabled", e);
  }
}
function j$(s) {
  return s ? s.condition !== void 0 : !1;
}
var Cf;
(function(s) {
  s[s.STORAGE_DOES_NOT_EXIST = 0] = "STORAGE_DOES_NOT_EXIST", s[s.STORAGE_IN_MEMORY = 1] = "STORAGE_IN_MEMORY";
})(Cf || (Cf = {}));
var Wg;
(function(s) {
  s[s.None = 0] = "None", s[s.Initialized = 1] = "Initialized", s[s.Closed = 2] = "Closed";
})(Wg || (Wg = {}));
const L1 = class L1 extends V {
  constructor(e, t = /* @__PURE__ */ Object.create(null)) {
    super(), this.database = e, this.options = t, this._onDidChangeStorage = this._register(new uu()), this.onDidChangeStorage = this._onDidChangeStorage.event, this.state = Wg.None, this.cache = /* @__PURE__ */ new Map(), this.flushDelayer = this._register(new EH(L1.DEFAULT_FLUSH_DELAY)), this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.whenFlushedCallbacks = [], this.registerListeners();
  }
  registerListeners() {
    this._register(this.database.onDidChangeItemsExternal((e) => this.onDidChangeItemsExternal(e)));
  }
  onDidChangeItemsExternal(e) {
    this._onDidChangeStorage.pause();
    try {
      e.changed?.forEach((t, i) => this.acceptExternal(i, t)), e.deleted?.forEach((t) => this.acceptExternal(t, void 0));
    } finally {
      this._onDidChangeStorage.resume();
    }
  }
  acceptExternal(e, t) {
    if (this.state === Wg.Closed)
      return;
    let i = !1;
    Ws(t) ? i = this.cache.delete(e) : this.cache.get(e) !== t && (this.cache.set(e, t), i = !0), i && this._onDidChangeStorage.fire({ key: e, external: !0 });
  }
  get(e, t) {
    const i = this.cache.get(e);
    return Ws(i) ? t : i;
  }
  getBoolean(e, t) {
    const i = this.get(e);
    return Ws(i) ? t : i === "true";
  }
  getNumber(e, t) {
    const i = this.get(e);
    return Ws(i) ? t : parseInt(i, 10);
  }
  async set(e, t, i = !1) {
    if (this.state === Wg.Closed)
      return;
    if (Ws(t))
      return this.delete(e, i);
    const n = Ti(t) || Array.isArray(t) ? yJ(t) : String(t);
    if (this.cache.get(e) !== n)
      return this.cache.set(e, n), this.pendingInserts.set(e, n), this.pendingDeletes.delete(e), this._onDidChangeStorage.fire({ key: e, external: i }), this.doFlush();
  }
  async delete(e, t = !1) {
    if (!(this.state === Wg.Closed || !this.cache.delete(e)))
      return this.pendingDeletes.has(e) || this.pendingDeletes.add(e), this.pendingInserts.delete(e), this._onDidChangeStorage.fire({ key: e, external: t }), this.doFlush();
  }
  get hasPending() {
    return this.pendingInserts.size > 0 || this.pendingDeletes.size > 0;
  }
  async flushPending() {
    if (!this.hasPending)
      return;
    const e = { insert: this.pendingInserts, delete: this.pendingDeletes };
    return this.pendingDeletes = /* @__PURE__ */ new Set(), this.pendingInserts = /* @__PURE__ */ new Map(), this.database.updateItems(e).finally(() => {
      if (!this.hasPending)
        for (; this.whenFlushedCallbacks.length; )
          this.whenFlushedCallbacks.pop()?.();
    });
  }
  async doFlush(e) {
    return this.options.hint === Cf.STORAGE_IN_MEMORY ? this.flushPending() : this.flushDelayer.trigger(() => this.flushPending(), e);
  }
};
L1.DEFAULT_FLUSH_DELAY = 100;
let Pp = L1;
class My {
  constructor() {
    this.onDidChangeItemsExternal = te.None, this.items = /* @__PURE__ */ new Map();
  }
  async updateItems(e) {
    e.insert?.forEach((t, i) => this.items.set(i, t)), e.delete?.forEach((t) => this.items.delete(t));
  }
}
const Lw = "__$__targetStorageMarker", Jl = We("storageService");
var tk;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.SHUTDOWN = 1] = "SHUTDOWN";
})(tk || (tk = {}));
function Y$(s) {
  const e = s.get(Lw);
  if (e)
    try {
      return JSON.parse(e);
    } catch {
    }
  return /* @__PURE__ */ Object.create(null);
}
const k1 = class k1 extends V {
  // every minute
  constructor(e = { flushInterval: k1.DEFAULT_FLUSH_INTERVAL }) {
    super(), this.options = e, this._onDidChangeValue = this._register(new uu()), this._onDidChangeTarget = this._register(new uu()), this._onWillSaveState = this._register(new B()), this.onWillSaveState = this._onWillSaveState.event, this._workspaceKeyTargets = void 0, this._profileKeyTargets = void 0, this._applicationKeyTargets = void 0;
  }
  onDidChangeValue(e, t, i) {
    return te.filter(this._onDidChangeValue.event, (n) => n.scope === e && (t === void 0 || n.key === t), i);
  }
  emitDidChangeValue(e, t) {
    const { key: i, external: n } = t;
    if (i === Lw) {
      switch (e) {
        case -1:
          this._applicationKeyTargets = void 0;
          break;
        case 0:
          this._profileKeyTargets = void 0;
          break;
        case 1:
          this._workspaceKeyTargets = void 0;
          break;
      }
      this._onDidChangeTarget.fire({ scope: e });
    } else
      this._onDidChangeValue.fire({ scope: e, key: i, target: this.getKeyTargets(e)[i], external: n });
  }
  get(e, t, i) {
    return this.getStorage(t)?.get(e, i);
  }
  getBoolean(e, t, i) {
    return this.getStorage(t)?.getBoolean(e, i);
  }
  getNumber(e, t, i) {
    return this.getStorage(t)?.getNumber(e, i);
  }
  store(e, t, i, n, o = !1) {
    if (Ws(t)) {
      this.remove(e, i, o);
      return;
    }
    this.withPausedEmitters(() => {
      this.updateKeyTarget(e, i, n), this.getStorage(i)?.set(e, t, o);
    });
  }
  remove(e, t, i = !1) {
    this.withPausedEmitters(() => {
      this.updateKeyTarget(e, t, void 0), this.getStorage(t)?.delete(e, i);
    });
  }
  withPausedEmitters(e) {
    this._onDidChangeValue.pause(), this._onDidChangeTarget.pause();
    try {
      e();
    } finally {
      this._onDidChangeValue.resume(), this._onDidChangeTarget.resume();
    }
  }
  updateKeyTarget(e, t, i, n = !1) {
    const o = this.getKeyTargets(t);
    typeof i == "number" ? o[e] !== i && (o[e] = i, this.getStorage(t)?.set(Lw, JSON.stringify(o), n)) : typeof o[e] == "number" && (delete o[e], this.getStorage(t)?.set(Lw, JSON.stringify(o), n));
  }
  get workspaceKeyTargets() {
    return this._workspaceKeyTargets || (this._workspaceKeyTargets = this.loadKeyTargets(
      1
      /* StorageScope.WORKSPACE */
    )), this._workspaceKeyTargets;
  }
  get profileKeyTargets() {
    return this._profileKeyTargets || (this._profileKeyTargets = this.loadKeyTargets(
      0
      /* StorageScope.PROFILE */
    )), this._profileKeyTargets;
  }
  get applicationKeyTargets() {
    return this._applicationKeyTargets || (this._applicationKeyTargets = this.loadKeyTargets(
      -1
      /* StorageScope.APPLICATION */
    )), this._applicationKeyTargets;
  }
  getKeyTargets(e) {
    switch (e) {
      case -1:
        return this.applicationKeyTargets;
      case 0:
        return this.profileKeyTargets;
      default:
        return this.workspaceKeyTargets;
    }
  }
  loadKeyTargets(e) {
    const t = this.getStorage(e);
    return t ? Y$(t) : /* @__PURE__ */ Object.create(null);
  }
};
k1.DEFAULT_FLUSH_INTERVAL = 60 * 1e3;
let ik = k1;
class K$ extends ik {
  constructor() {
    super(), this.applicationStorage = this._register(new Pp(new My(), { hint: Cf.STORAGE_IN_MEMORY })), this.profileStorage = this._register(new Pp(new My(), { hint: Cf.STORAGE_IN_MEMORY })), this.workspaceStorage = this._register(new Pp(new My(), { hint: Cf.STORAGE_IN_MEMORY })), this._register(this.workspaceStorage.onDidChangeStorage((e) => this.emitDidChangeValue(1, e))), this._register(this.profileStorage.onDidChangeStorage((e) => this.emitDidChangeValue(0, e))), this._register(this.applicationStorage.onDidChangeStorage((e) => this.emitDidChangeValue(-1, e)));
  }
  getStorage(e) {
    switch (e) {
      case -1:
        return this.applicationStorage;
      case 0:
        return this.profileStorage;
      default:
        return this.workspaceStorage;
    }
  }
}
function J$(s, e) {
  const t = { ...e };
  for (const i in s) {
    const n = s[i];
    t[i] = n !== void 0 ? oe(n) : void 0;
  }
  return t;
}
const q$ = {
  keybindingLabelBackground: oe(UY),
  keybindingLabelForeground: oe(QY),
  keybindingLabelBorder: oe(GY),
  keybindingLabelBottomBorder: oe(jY),
  keybindingLabelShadow: oe(B_)
}, $$ = {
  buttonForeground: oe(i3),
  buttonSeparator: oe(DY),
  buttonBackground: oe(up),
  buttonHoverBackground: oe(IY),
  buttonSecondaryForeground: oe(NY),
  buttonSecondaryBackground: oe(LL),
  buttonSecondaryHoverBackground: oe(TY),
  buttonBorder: oe(MY)
}, X$ = {
  progressBarBackground: oe(Hj)
}, PC = {
  inputActiveOptionBorder: oe(Q0),
  inputActiveOptionForeground: oe(G0),
  inputActiveOptionBackground: oe(R_)
};
oe(gp), oe(BY), oe(RY), oe(FY), oe(OY), oe(PY), oe(HY);
oe(WY), oe(zY), oe(VY);
oe(Ao), oe(z0), oe(B_), oe(Je), oe(aY), oe(lY), oe(cY), oe(Oj);
const HC = {
  inputBackground: oe(mY),
  inputForeground: oe(pY),
  inputBorder: oe(AY),
  inputValidationInfoBorder: oe(CY),
  inputValidationInfoBackground: oe(bY),
  inputValidationInfoForeground: oe(wY),
  inputValidationWarningBorder: oe(yY),
  inputValidationWarningBackground: oe(vY),
  inputValidationWarningForeground: oe(SY),
  inputValidationErrorBorder: oe(LY),
  inputValidationErrorBackground: oe(xY),
  inputValidationErrorForeground: oe(EY)
}, Z$ = {
  listFilterWidgetBackground: oe(oK),
  listFilterWidgetOutline: oe(rK),
  listFilterWidgetNoMatchesOutline: oe(aK),
  listFilterWidgetShadow: oe(lK),
  inputBoxStyles: HC,
  toggleStyles: PC
}, Y3 = {
  badgeBackground: oe(Sw),
  badgeForeground: oe(Pj),
  badgeBorder: oe(Je)
};
oe(oY), oe(sY), oe(x2), oe(x2), oe(rY);
const Qu = {
  listBackground: void 0,
  listInactiveFocusForeground: void 0,
  listFocusBackground: oe(YY),
  listFocusForeground: oe(KY),
  listFocusOutline: oe(JY),
  listActiveSelectionBackground: oe(wu),
  listActiveSelectionForeground: oe(UA),
  listActiveSelectionIconForeground: oe(n3),
  listFocusAndSelectionOutline: oe(qY),
  listFocusAndSelectionBackground: oe(wu),
  listFocusAndSelectionForeground: oe(UA),
  listInactiveSelectionBackground: oe($Y),
  listInactiveSelectionIconForeground: oe(ZY),
  listInactiveSelectionForeground: oe(XY),
  listInactiveFocusBackground: oe(eK),
  listInactiveFocusOutline: oe(tK),
  listHoverBackground: oe(s3),
  listHoverForeground: oe(o3),
  listDropOverBackground: oe(iK),
  listDropBetweenBackground: oe(nK),
  listSelectionOutline: oe(Kt),
  listHoverOutline: oe(Kt),
  treeIndentGuidesStroke: oe(r3),
  treeInactiveIndentGuidesStroke: oe(cK),
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: oe(mN),
  tableColumnsBorder: oe(dK),
  tableOddRowsBackgroundColor: oe(hK)
};
function ym(s) {
  return J$(s, Qu);
}
const eX = {
  selectBackground: oe(j0),
  selectListBackground: oe(kY),
  selectForeground: oe(wN),
  decoratorRightForeground: oe(a3),
  selectBorder: oe(CN),
  focusBorder: oe(ka),
  listFocusBackground: oe(yC),
  listInactiveSelectionIconForeground: oe(vN),
  listFocusForeground: oe(SC),
  listFocusOutline: Mj(Kt, Y.transparent.toString()),
  listHoverBackground: oe(s3),
  listHoverForeground: oe(o3),
  listHoverOutline: oe(Kt),
  selectListBorder: oe(pN),
  listBackground: void 0,
  listActiveSelectionBackground: void 0,
  listActiveSelectionForeground: void 0,
  listActiveSelectionIconForeground: void 0,
  listFocusAndSelectionBackground: void 0,
  listDropOverBackground: void 0,
  listDropBetweenBackground: void 0,
  listInactiveSelectionBackground: void 0,
  listInactiveSelectionForeground: void 0,
  listInactiveFocusBackground: void 0,
  listInactiveFocusOutline: void 0,
  listSelectionOutline: void 0,
  listFocusAndSelectionForeground: void 0,
  listFocusAndSelectionOutline: void 0,
  listInactiveFocusForeground: void 0,
  tableColumnsBorder: void 0,
  tableOddRowsBackgroundColor: void 0,
  treeIndentGuidesStroke: void 0,
  treeInactiveIndentGuidesStroke: void 0,
  treeStickyScrollBackground: void 0,
  treeStickyScrollBorder: void 0,
  treeStickyScrollShadow: void 0
}, tX = {
  shadowColor: oe(B_),
  borderColor: oe(uK),
  foregroundColor: oe(gK),
  backgroundColor: oe(fK),
  selectionForegroundColor: oe(mK),
  selectionBackgroundColor: oe(pK),
  selectionBorderColor: oe(AK),
  separatorColor: oe(_K),
  scrollbarShadow: oe(mN),
  scrollbarSliderBackground: oe(J5),
  scrollbarSliderHoverBackground: oe(q5),
  scrollbarSliderActiveBackground: oe($5)
};
var lS = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Jn = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function iX(s, e, t, i) {
  let n, o, r;
  if (Array.isArray(s))
    r = s, n = e, o = t;
  else {
    const c = e;
    r = s.getActions(c), n = t, o = i;
  }
  const a = bl.getInstance(), l = a.keyStatus.altKey || (yn || Fn) && a.keyStatus.shiftKey;
  K3(r, n, l, o ? (c) => c === o : (c) => c === "navigation");
}
function UN(s, e, t, i, n, o) {
  let r, a, l, c, d;
  if (Array.isArray(s))
    d = s, r = e, a = t, l = i, c = n;
  else {
    const u = e;
    d = s.getActions(u), r = t, a = i, l = n, c = o;
  }
  K3(d, r, !1, typeof a == "string" ? (u) => u === a : a, l, c);
}
function K3(s, e, t, i = (r) => r === "navigation", n = () => !1, o = !1) {
  let r, a;
  Array.isArray(e) ? (r = e, a = e) : (r = e.primary, a = e.secondary);
  const l = /* @__PURE__ */ new Set();
  for (const [c, d] of s) {
    let h;
    i(c) ? (h = r, h.length > 0 && o && h.push(new Ri())) : (h = a, h.length > 0 && h.push(new Ri()));
    for (let u of d) {
      t && (u = u instanceof bo && u.alt ? u.alt : u);
      const g = h.push(u);
      u instanceof Uf && l.add({ group: c, action: u, index: g - 1 });
    }
  }
  for (const { group: c, action: d, index: h } of l) {
    const u = i(c) ? r : a, g = d.actions;
    n(d, c, u.length) && u.splice(h, 1, ...g);
  }
}
let Su = class extends nm {
  constructor(e, t, i, n, o, r, a, l) {
    super(void 0, e, { icon: !!(e.class || e.item.icon), label: !e.class && !e.item.icon, draggable: t?.draggable, keybinding: t?.keybinding, hoverDelegate: t?.hoverDelegate }), this._options = t, this._keybindingService = i, this._notificationService = n, this._contextKeyService = o, this._themeService = r, this._contextMenuService = a, this._accessibilityService = l, this._wantsAltCommand = !1, this._itemClassDispose = this._register(new On()), this._altKey = bl.getInstance();
  }
  get _menuItemAction() {
    return this._action;
  }
  get _commandAction() {
    return this._wantsAltCommand && this._menuItemAction.alt || this._menuItemAction;
  }
  async onClick(e) {
    e.preventDefault(), e.stopPropagation();
    try {
      await this.actionRunner.run(this._commandAction, this._context);
    } catch (t) {
      this._notificationService.error(t);
    }
  }
  render(e) {
    if (super.render(e), e.classList.add("menu-entry"), this.options.icon && this._updateItemClass(this._menuItemAction.item), this._menuItemAction.alt) {
      let t = !1;
      const i = () => {
        const n = !!this._menuItemAction.alt?.enabled && (!this._accessibilityService.isMotionReduced() || t) && (this._altKey.keyStatus.altKey || this._altKey.keyStatus.shiftKey && t);
        n !== this._wantsAltCommand && (this._wantsAltCommand = n, this.updateLabel(), this.updateTooltip(), this.updateClass());
      };
      this._register(this._altKey.event(i)), this._register(U(e, "mouseleave", (n) => {
        t = !1, i();
      })), this._register(U(e, "mouseenter", (n) => {
        t = !0, i();
      })), i();
    }
  }
  updateLabel() {
    this.options.label && this.label && (this.label.textContent = this._commandAction.label);
  }
  getTooltip() {
    const e = this._keybindingService.lookupKeybinding(this._commandAction.id, this._contextKeyService), t = e && e.getLabel(), i = this._commandAction.tooltip || this._commandAction.label;
    let n = t ? f("titleAndKb", "{0} ({1})", i, t) : i;
    if (!this._wantsAltCommand && this._menuItemAction.alt?.enabled) {
      const o = this._menuItemAction.alt.tooltip || this._menuItemAction.alt.label, r = this._keybindingService.lookupKeybinding(this._menuItemAction.alt.id, this._contextKeyService), a = r && r.getLabel(), l = a ? f("titleAndKb", "{0} ({1})", o, a) : o;
      n = f("titleAndKbAndAlt", `{0}
[{1}] {2}`, n, FN.modifierLabels[Us].altKey, l);
    }
    return n;
  }
  updateClass() {
    this.options.icon && (this._commandAction !== this._menuItemAction ? this._menuItemAction.alt && this._updateItemClass(this._menuItemAction.alt.item) : this._updateItemClass(this._menuItemAction.item));
  }
  _updateItemClass(e) {
    this._itemClassDispose.value = void 0;
    const { element: t, label: i } = this;
    if (!t || !i)
      return;
    const n = this._commandAction.checked && j$(e.toggled) && e.toggled.icon ? e.toggled.icon : e.icon;
    if (n)
      if (pe.isThemeIcon(n)) {
        const o = pe.asClassNameArray(n);
        i.classList.add(...o), this._itemClassDispose.value = we(() => {
          i.classList.remove(...o);
        });
      } else
        i.style.backgroundImage = P0(this._themeService.getColorTheme().type) ? Vl(n.dark) : Vl(n.light), i.classList.add("icon"), this._itemClassDispose.value = jo(we(() => {
          i.style.backgroundImage = "", i.classList.remove("icon");
        }), this._themeService.onDidColorThemeChange(() => {
          this.updateClass();
        }));
  }
};
Su = lS([
  Jn(2, bt),
  Jn(3, Oi),
  Jn(4, Se),
  Jn(5, nn),
  Jn(6, ar),
  Jn(7, Lo)
], Su);
class QN extends Su {
  render(e) {
    this.options.label = !0, this.options.icon = !1, super.render(e), e.classList.add("text-only"), e.classList.toggle("use-comma", this._options?.useComma ?? !1);
  }
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = QN._symbolPrintEnter(e);
      this._options?.conversational ? this.label.textContent = f({ key: "content2", comment: ['A label with keybindg like "ESC to dismiss"'] }, "{1} to {0}", this._action.label, t) : this.label.textContent = f({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", this._action.label, t);
    }
  }
  static _symbolPrintEnter(e) {
    return e.getLabel()?.replace(/\benter\b/gi, "⏎").replace(/\bEscape\b/gi, "Esc");
  }
}
let nk = class extends OC {
  constructor(e, t, i, n, o) {
    const r = {
      ...t,
      menuAsChild: t?.menuAsChild ?? !1,
      classNames: t?.classNames ?? (pe.isThemeIcon(e.item.icon) ? pe.asClassName(e.item.icon) : void 0),
      keybindingProvider: t?.keybindingProvider ?? ((a) => i.lookupKeybinding(a.id))
    };
    super(e, { getActions: () => e.actions }, n, r), this._keybindingService = i, this._contextMenuService = n, this._themeService = o;
  }
  render(e) {
    super.render(e), jt(this.element), e.classList.add("menu-entry");
    const t = this._action, { icon: i } = t.item;
    if (i && !pe.isThemeIcon(i)) {
      this.element.classList.add("icon");
      const n = () => {
        this.element && (this.element.style.backgroundImage = P0(this._themeService.getColorTheme().type) ? Vl(i.dark) : Vl(i.light));
      };
      n(), this._register(this._themeService.onDidColorThemeChange(() => {
        n();
      }));
    }
  }
};
nk = lS([
  Jn(2, bt),
  Jn(3, ar),
  Jn(4, nn)
], nk);
let sk = class extends Er {
  constructor(e, t, i, n, o, r, a, l) {
    super(null, e), this._keybindingService = i, this._notificationService = n, this._contextMenuService = o, this._menuService = r, this._instaService = a, this._storageService = l, this._container = null, this._options = t, this._storageKey = `${e.item.submenu.id}_lastActionId`;
    let c;
    const d = t?.persistLastActionId ? l.get(
      this._storageKey,
      1
      /* StorageScope.WORKSPACE */
    ) : void 0;
    d && (c = e.actions.find((u) => d === u.id)), c || (c = e.actions[0]), this._defaultAction = this._instaService.createInstance(Su, c, { keybinding: this._getDefaultActionKeybindingLabel(c) });
    const h = {
      keybindingProvider: (u) => this._keybindingService.lookupKeybinding(u.id),
      ...t,
      menuAsChild: t?.menuAsChild ?? !0,
      classNames: t?.classNames ?? ["codicon", "codicon-chevron-down"],
      actionRunner: t?.actionRunner ?? new Au()
    };
    this._dropdown = new OC(e, e.actions, this._contextMenuService, h), this._register(this._dropdown.actionRunner.onDidRun((u) => {
      u.action instanceof bo && this.update(u.action);
    }));
  }
  update(e) {
    this._options?.persistLastActionId && this._storageService.store(
      this._storageKey,
      e.id,
      1,
      1
      /* StorageTarget.MACHINE */
    ), this._defaultAction.dispose(), this._defaultAction = this._instaService.createInstance(Su, e, { keybinding: this._getDefaultActionKeybindingLabel(e) }), this._defaultAction.actionRunner = new class extends Au {
      async runAction(t, i) {
        await t.run(void 0);
      }
    }(), this._container && this._defaultAction.render($M(this._container, de(".action-container")));
  }
  _getDefaultActionKeybindingLabel(e) {
    let t;
    if (this._options?.renderKeybindingWithDefaultActionLabel) {
      const i = this._keybindingService.lookupKeybinding(e.id);
      i && (t = `(${i.getLabel()})`);
    }
    return t;
  }
  setActionContext(e) {
    super.setActionContext(e), this._defaultAction.setActionContext(e), this._dropdown.setActionContext(e);
  }
  render(e) {
    this._container = e, super.render(this._container), this._container.classList.add("monaco-dropdown-with-default");
    const t = de(".action-container");
    this._defaultAction.render(K(this._container, t)), this._register(U(t, ee.KEY_DOWN, (n) => {
      const o = new Mt(n);
      o.equals(
        17
        /* KeyCode.RightArrow */
      ) && (this._defaultAction.element.tabIndex = -1, this._dropdown.focus(), o.stopPropagation());
    }));
    const i = de(".dropdown-action-container");
    this._dropdown.render(K(this._container, i)), this._register(U(i, ee.KEY_DOWN, (n) => {
      const o = new Mt(n);
      o.equals(
        15
        /* KeyCode.LeftArrow */
      ) && (this._defaultAction.element.tabIndex = 0, this._dropdown.setFocusable(!1), this._defaultAction.element?.focus(), o.stopPropagation());
    }));
  }
  focus(e) {
    e ? this._dropdown.focus() : (this._defaultAction.element.tabIndex = 0, this._defaultAction.element.focus());
  }
  blur() {
    this._defaultAction.element.tabIndex = -1, this._dropdown.blur(), this._container.blur();
  }
  setFocusable(e) {
    e ? this._defaultAction.element.tabIndex = 0 : (this._defaultAction.element.tabIndex = -1, this._dropdown.setFocusable(!1));
  }
  dispose() {
    this._defaultAction.dispose(), this._dropdown.dispose(), super.dispose();
  }
};
sk = lS([
  Jn(2, bt),
  Jn(3, Oi),
  Jn(4, ar),
  Jn(5, sr),
  Jn(6, ke),
  Jn(7, Jl)
], sk);
let ok = class extends U$ {
  constructor(e, t) {
    super(null, e, e.actions.map((i) => ({
      text: i.id === Ri.ID ? "─────────" : i.label,
      isDisabled: !i.enabled
    })), 0, t, eX, { ariaLabel: e.tooltip, optionsAsChildren: !0 }), this.select(Math.max(0, e.actions.findIndex((i) => i.checked)));
  }
  render(e) {
    super.render(e), e.style.borderColor = oe(CN);
  }
  runAction(e, t) {
    const i = this.action.actions[t];
    i && this.actionRunner.run(i);
  }
};
ok = lS([
  Jn(1, Yl)
], ok);
function J3(s, e, t) {
  return e instanceof bo ? s.createInstance(Su, e, t) : e instanceof mf ? e.item.isSelection ? s.createInstance(ok, e) : e.item.rememberDefaultAction ? s.createInstance(sk, e, { ...t, persistLastActionId: !0 }) : s.createInstance(nk, e, t) : void 0;
}
class wo extends V {
  constructor(e, t = {}) {
    super(), this._actionRunnerDisposables = this._register(new X()), this.viewItemDisposables = this._register(new IM()), this.triggerKeyDown = !1, this.focusable = !0, this._onDidBlur = this._register(new B()), this.onDidBlur = this._onDidBlur.event, this._onDidCancel = this._register(new B({ onWillAddFirstListener: () => this.cancelHasListener = !0 })), this.onDidCancel = this._onDidCancel.event, this.cancelHasListener = !1, this._onDidRun = this._register(new B()), this.onDidRun = this._onDidRun.event, this._onWillRun = this._register(new B()), this.onWillRun = this._onWillRun.event, this.options = t, this._context = t.context ?? null, this._orientation = this.options.orientation ?? 0, this._triggerKeys = {
      keyDown: this.options.triggerKeys?.keyDown ?? !1,
      keys: this.options.triggerKeys?.keys ?? [
        3,
        10
        /* KeyCode.Space */
      ]
    }, this._hoverDelegate = t.hoverDelegate ?? this._register(im()), this.options.actionRunner ? this._actionRunner = this.options.actionRunner : (this._actionRunner = new Au(), this._actionRunnerDisposables.add(this._actionRunner)), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((o) => this._onDidRun.fire(o))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((o) => this._onWillRun.fire(o))), this.viewItems = [], this.focusedItem = void 0, this.domNode = document.createElement("div"), this.domNode.className = "monaco-action-bar";
    let i, n;
    switch (this._orientation) {
      case 0:
        i = [
          15
          /* KeyCode.LeftArrow */
        ], n = [
          17
          /* KeyCode.RightArrow */
        ];
        break;
      case 1:
        i = [
          16
          /* KeyCode.UpArrow */
        ], n = [
          18
          /* KeyCode.DownArrow */
        ], this.domNode.className += " vertical";
        break;
    }
    this._register(U(this.domNode, ee.KEY_DOWN, (o) => {
      const r = new Mt(o);
      let a = !0;
      const l = typeof this.focusedItem == "number" ? this.viewItems[this.focusedItem] : void 0;
      i && (r.equals(i[0]) || r.equals(i[1])) ? a = this.focusPrevious() : n && (r.equals(n[0]) || r.equals(n[1])) ? a = this.focusNext() : r.equals(
        9
        /* KeyCode.Escape */
      ) && this.cancelHasListener ? this._onDidCancel.fire() : r.equals(
        14
        /* KeyCode.Home */
      ) ? a = this.focusFirst() : r.equals(
        13
        /* KeyCode.End */
      ) ? a = this.focusLast() : r.equals(
        2
        /* KeyCode.Tab */
      ) && l instanceof Er && l.trapsArrowNavigation ? a = this.focusNext(void 0, !0) : this.isTriggerKeyEvent(r) ? this._triggerKeys.keyDown ? this.doTrigger(r) : this.triggerKeyDown = !0 : a = !1, a && (r.preventDefault(), r.stopPropagation());
    })), this._register(U(this.domNode, ee.KEY_UP, (o) => {
      const r = new Mt(o);
      this.isTriggerKeyEvent(r) ? (!this._triggerKeys.keyDown && this.triggerKeyDown && (this.triggerKeyDown = !1, this.doTrigger(r)), r.preventDefault(), r.stopPropagation()) : (r.equals(
        2
        /* KeyCode.Tab */
      ) || r.equals(
        1026
        /* KeyCode.Tab */
      ) || r.equals(
        16
        /* KeyCode.UpArrow */
      ) || r.equals(
        18
        /* KeyCode.DownArrow */
      ) || r.equals(
        15
        /* KeyCode.LeftArrow */
      ) || r.equals(
        17
        /* KeyCode.RightArrow */
      )) && this.updateFocusedItem();
    })), this.focusTracker = this._register(Wl(this.domNode)), this._register(this.focusTracker.onDidBlur(() => {
      (ln() === this.domNode || !yi(ln(), this.domNode)) && (this._onDidBlur.fire(), this.previouslyFocusedItem = this.focusedItem, this.focusedItem = void 0, this.triggerKeyDown = !1);
    })), this._register(this.focusTracker.onDidFocus(() => this.updateFocusedItem())), this.actionsList = document.createElement("ul"), this.actionsList.className = "actions-container", this.options.highlightToggledItems && this.actionsList.classList.add("highlight-toggled"), this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar"), this.options.ariaLabel && this.actionsList.setAttribute("aria-label", this.options.ariaLabel), this.domNode.appendChild(this.actionsList), e.appendChild(this.domNode);
  }
  refreshRole() {
    this.length() >= 1 ? this.actionsList.setAttribute("role", this.options.ariaRole || "toolbar") : this.actionsList.setAttribute("role", "presentation");
  }
  // Some action bars should not be focusable at times
  // When an action bar is not focusable make sure to make all the elements inside it not focusable
  // When an action bar is focusable again, make sure the first item can be focused
  setFocusable(e) {
    if (this.focusable = e, this.focusable) {
      const t = this.viewItems.find((i) => i instanceof Er && i.isEnabled());
      t instanceof Er && t.setFocusable(!0);
    } else
      this.viewItems.forEach((t) => {
        t instanceof Er && t.setFocusable(!1);
      });
  }
  isTriggerKeyEvent(e) {
    let t = !1;
    return this._triggerKeys.keys.forEach((i) => {
      t = t || e.equals(i);
    }), t;
  }
  updateFocusedItem() {
    for (let e = 0; e < this.actionsList.children.length; e++) {
      const t = this.actionsList.children[e];
      if (yi(ln(), t)) {
        this.focusedItem = e, this.viewItems[this.focusedItem]?.showHover?.();
        break;
      }
    }
  }
  get context() {
    return this._context;
  }
  set context(e) {
    this._context = e, this.viewItems.forEach((t) => t.setActionContext(e));
  }
  get actionRunner() {
    return this._actionRunner;
  }
  set actionRunner(e) {
    this._actionRunner = e, this._actionRunnerDisposables.clear(), this._actionRunnerDisposables.add(this._actionRunner.onDidRun((t) => this._onDidRun.fire(t))), this._actionRunnerDisposables.add(this._actionRunner.onWillRun((t) => this._onWillRun.fire(t))), this.viewItems.forEach((t) => t.actionRunner = e);
  }
  getContainer() {
    return this.domNode;
  }
  getAction(e) {
    if (typeof e == "number")
      return this.viewItems[e]?.action;
    if (Bi(e)) {
      for (; e.parentElement !== this.actionsList; ) {
        if (!e.parentElement)
          return;
        e = e.parentElement;
      }
      for (let t = 0; t < this.actionsList.childNodes.length; t++)
        if (this.actionsList.childNodes[t] === e)
          return this.viewItems[t].action;
    }
  }
  push(e, t = {}) {
    const i = Array.isArray(e) ? e : [e];
    let n = id(t.index) ? t.index : null;
    i.forEach((o) => {
      const r = document.createElement("li");
      r.className = "action-item", r.setAttribute("role", "presentation");
      let a;
      const l = { hoverDelegate: this._hoverDelegate, ...t, isTabList: this.options.ariaRole === "tablist" };
      this.options.actionViewItemProvider && (a = this.options.actionViewItemProvider(o, l)), a || (a = new nm(this.context, o, l)), this.options.allowContextMenu || this.viewItemDisposables.set(a, U(r, ee.CONTEXT_MENU, (c) => {
        Ve.stop(c, !0);
      })), a.actionRunner = this._actionRunner, a.setActionContext(this.context), a.render(r), this.focusable && a instanceof Er && this.viewItems.length === 0 && a.setFocusable(!0), n === null || n < 0 || n >= this.actionsList.children.length ? (this.actionsList.appendChild(r), this.viewItems.push(a)) : (this.actionsList.insertBefore(r, this.actionsList.children[n]), this.viewItems.splice(n, 0, a), n++);
    }), typeof this.focusedItem == "number" && this.focus(this.focusedItem), this.refreshRole();
  }
  clear() {
    this.isEmpty() || (this.viewItems = Ct(this.viewItems), this.viewItemDisposables.clearAndDisposeAll(), Bn(this.actionsList), this.refreshRole());
  }
  length() {
    return this.viewItems.length;
  }
  isEmpty() {
    return this.viewItems.length === 0;
  }
  focus(e) {
    let t = !1, i;
    if (e === void 0 ? t = !0 : typeof e == "number" ? i = e : typeof e == "boolean" && (t = e), t && typeof this.focusedItem > "u") {
      const n = this.viewItems.findIndex((o) => o.isEnabled());
      this.focusedItem = n === -1 ? void 0 : n, this.updateFocus(void 0, void 0, !0);
    } else
      i !== void 0 && (this.focusedItem = i), this.updateFocus(void 0, void 0, !0);
  }
  focusFirst() {
    return this.focusedItem = this.length() - 1, this.focusNext(!0);
  }
  focusLast() {
    return this.focusedItem = 0, this.focusPrevious(!0);
  }
  focusNext(e, t) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = this.viewItems.length - 1;
    else if (this.viewItems.length <= 1)
      return !1;
    const i = this.focusedItem;
    let n;
    do {
      if (!e && this.options.preventLoopNavigation && this.focusedItem + 1 >= this.viewItems.length)
        return this.focusedItem = i, !1;
      this.focusedItem = (this.focusedItem + 1) % this.viewItems.length, n = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== i && (this.options.focusOnlyEnabledItems && !n.isEnabled() || n.action.id === Ri.ID));
    return this.updateFocus(void 0, void 0, t), !0;
  }
  focusPrevious(e) {
    if (typeof this.focusedItem > "u")
      this.focusedItem = 0;
    else if (this.viewItems.length <= 1)
      return !1;
    const t = this.focusedItem;
    let i;
    do {
      if (this.focusedItem = this.focusedItem - 1, this.focusedItem < 0) {
        if (!e && this.options.preventLoopNavigation)
          return this.focusedItem = t, !1;
        this.focusedItem = this.viewItems.length - 1;
      }
      i = this.viewItems[this.focusedItem];
    } while (this.focusedItem !== t && (this.options.focusOnlyEnabledItems && !i.isEnabled() || i.action.id === Ri.ID));
    return this.updateFocus(!0), !0;
  }
  updateFocus(e, t, i = !1) {
    typeof this.focusedItem > "u" && this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem !== void 0 && this.previouslyFocusedItem !== this.focusedItem && this.viewItems[this.previouslyFocusedItem]?.blur();
    const n = this.focusedItem !== void 0 ? this.viewItems[this.focusedItem] : void 0;
    if (n) {
      let o = !0;
      Gw(n.focus) || (o = !1), this.options.focusOnlyEnabledItems && Gw(n.isEnabled) && !n.isEnabled() && (o = !1), n.action.id === Ri.ID && (o = !1), o ? (i || this.previouslyFocusedItem !== this.focusedItem) && (n.focus(e), this.previouslyFocusedItem = this.focusedItem) : (this.actionsList.focus({ preventScroll: t }), this.previouslyFocusedItem = void 0), o && n.showHover?.();
    }
  }
  doTrigger(e) {
    if (typeof this.focusedItem > "u")
      return;
    const t = this.viewItems[this.focusedItem];
    if (t instanceof Er) {
      const i = t._context === null || t._context === void 0 ? e : t._context;
      this.run(t._action, i);
    }
  }
  async run(e, t) {
    await this._actionRunner.run(e, t);
  }
  dispose() {
    this._context = void 0, this.viewItems = Ct(this.viewItems), this.getContainer().remove(), super.dispose();
  }
}
const rk = /\(&([^\s&])\)|(^|[^&])&([^\s&])/, Ny = /(&amp;)?(&amp;)([^\s&])/g;
var WC;
(function(s) {
  s[s.Right = 0] = "Right", s[s.Left = 1] = "Left";
})(WC || (WC = {}));
var ak;
(function(s) {
  s[s.Above = 0] = "Above", s[s.Below = 1] = "Below";
})(ak || (ak = {}));
class vf extends wo {
  constructor(e, t, i, n) {
    e.classList.add("monaco-menu-container"), e.setAttribute("role", "presentation");
    const o = document.createElement("div");
    o.classList.add("monaco-menu"), o.setAttribute("role", "presentation"), super(o, {
      orientation: 1,
      actionViewItemProvider: (c) => this.doGetActionViewItem(c, i, r),
      context: i.context,
      actionRunner: i.actionRunner,
      ariaLabel: i.ariaLabel,
      ariaRole: "menu",
      focusOnlyEnabledItems: !0,
      triggerKeys: { keys: [3, ...ze || Fn ? [
        10
        /* KeyCode.Space */
      ] : []], keyDown: !0 }
    }), this.menuStyles = n, this.menuElement = o, this.actionsList.tabIndex = 0, this.initializeOrUpdateStyleSheet(e, n), this._register(xn.addTarget(o)), this._register(U(o, ee.KEY_DOWN, (c) => {
      new Mt(c).equals(
        2
        /* KeyCode.Tab */
      ) && c.preventDefault();
    })), i.enableMnemonics && this._register(U(o, ee.KEY_DOWN, (c) => {
      const d = c.key.toLocaleLowerCase();
      if (this.mnemonics.has(d)) {
        Ve.stop(c, !0);
        const h = this.mnemonics.get(d);
        if (h.length === 1 && (h[0] instanceof pF && h[0].container && this.focusItemByElement(h[0].container), h[0].onClick(c)), h.length > 1) {
          const u = h.shift();
          u && u.container && (this.focusItemByElement(u.container), h.push(u)), this.mnemonics.set(d, h);
        }
      }
    })), Fn && this._register(U(o, ee.KEY_DOWN, (c) => {
      const d = new Mt(c);
      d.equals(
        14
        /* KeyCode.Home */
      ) || d.equals(
        11
        /* KeyCode.PageUp */
      ) ? (this.focusedItem = this.viewItems.length - 1, this.focusNext(), Ve.stop(c, !0)) : (d.equals(
        13
        /* KeyCode.End */
      ) || d.equals(
        12
        /* KeyCode.PageDown */
      )) && (this.focusedItem = 0, this.focusPrevious(), Ve.stop(c, !0));
    })), this._register(U(this.domNode, ee.MOUSE_OUT, (c) => {
      const d = c.relatedTarget;
      yi(d, this.domNode) || (this.focusedItem = void 0, this.updateFocus(), c.stopPropagation());
    })), this._register(U(this.actionsList, ee.MOUSE_OVER, (c) => {
      let d = c.target;
      if (!(!d || !yi(d, this.actionsList) || d === this.actionsList)) {
        for (; d.parentElement !== this.actionsList && d.parentElement !== null; )
          d = d.parentElement;
        if (d.classList.contains("action-item")) {
          const h = this.focusedItem;
          this.setFocusedItem(d), h !== this.focusedItem && this.updateFocus();
        }
      }
    })), this._register(xn.addTarget(this.actionsList)), this._register(U(this.actionsList, Et.Tap, (c) => {
      let d = c.initialTarget;
      if (!(!d || !yi(d, this.actionsList) || d === this.actionsList)) {
        for (; d.parentElement !== this.actionsList && d.parentElement !== null; )
          d = d.parentElement;
        if (d.classList.contains("action-item")) {
          const h = this.focusedItem;
          this.setFocusedItem(d), h !== this.focusedItem && this.updateFocus();
        }
      }
    }));
    const r = {
      parent: this
    };
    this.mnemonics = /* @__PURE__ */ new Map(), this.scrollableElement = this._register(new F_(o, {
      alwaysConsumeMouseWheel: !0,
      horizontal: 2,
      vertical: 3,
      verticalScrollbarSize: 7,
      handleMouseWheel: !0,
      useShadows: !0
    }));
    const a = this.scrollableElement.getDomNode();
    a.style.position = "", this.styleScrollElement(a, n), this._register(U(o, Et.Change, (c) => {
      Ve.stop(c, !0);
      const d = this.scrollableElement.getScrollPosition().scrollTop;
      this.scrollableElement.setScrollPosition({ scrollTop: d - c.translationY });
    })), this._register(U(a, ee.MOUSE_UP, (c) => {
      c.preventDefault();
    }));
    const l = fe(e);
    o.style.maxHeight = `${Math.max(10, l.innerHeight - e.getBoundingClientRect().top - 35)}px`, t = t.filter((c, d) => i.submenuIds?.has(c.id) ? (console.warn(`Found submenu cycle: ${c.id}`), !1) : !(c instanceof Ri && (d === t.length - 1 || d === 0 || t[d - 1] instanceof Ri))), this.push(t, { icon: !0, label: !0, isMenu: !0 }), e.appendChild(this.scrollableElement.getDomNode()), this.scrollableElement.scanDomNode(), this.viewItems.filter((c) => !(c instanceof AF)).forEach((c, d, h) => {
      c.updatePositionInSet(d + 1, h.length);
    });
  }
  initializeOrUpdateStyleSheet(e, t) {
    this.styleSheet || (rC(e) ? this.styleSheet = xo(e) : (vf.globalStyleSheet || (vf.globalStyleSheet = xo()), this.styleSheet = vf.globalStyleSheet)), this.styleSheet.textContent = sX(t, rC(e));
  }
  styleScrollElement(e, t) {
    const i = t.foregroundColor ?? "", n = t.backgroundColor ?? "", o = t.borderColor ? `1px solid ${t.borderColor}` : "", r = "5px", a = t.shadowColor ? `0 2px 8px ${t.shadowColor}` : "";
    e.style.outline = o, e.style.borderRadius = r, e.style.color = i, e.style.backgroundColor = n, e.style.boxShadow = a;
  }
  getContainer() {
    return this.scrollableElement.getDomNode();
  }
  get onScroll() {
    return this.scrollableElement.onScroll;
  }
  focusItemByElement(e) {
    const t = this.focusedItem;
    this.setFocusedItem(e), t !== this.focusedItem && this.updateFocus();
  }
  setFocusedItem(e) {
    for (let t = 0; t < this.actionsList.children.length; t++) {
      const i = this.actionsList.children[t];
      if (e === i) {
        this.focusedItem = t;
        break;
      }
    }
  }
  updateFocus(e) {
    super.updateFocus(e, !0, !0), typeof this.focusedItem < "u" && this.scrollableElement.setScrollPosition({
      scrollTop: Math.round(this.menuElement.scrollTop)
    });
  }
  doGetActionViewItem(e, t, i) {
    if (e instanceof Ri)
      return new AF(t.context, e, { icon: !0 }, this.menuStyles);
    if (e instanceof Uf) {
      const n = new pF(e, e.actions, i, { ...t, submenuIds: /* @__PURE__ */ new Set([...t.submenuIds || [], e.id]) }, this.menuStyles);
      if (t.enableMnemonics) {
        const o = n.getMnemonic();
        if (o && n.isEnabled()) {
          let r = [];
          this.mnemonics.has(o) && (r = this.mnemonics.get(o)), r.push(n), this.mnemonics.set(o, r);
        }
      }
      return n;
    } else {
      const n = { enableMnemonics: t.enableMnemonics, useEventAsContext: t.useEventAsContext };
      if (t.getKeyBinding) {
        const r = t.getKeyBinding(e);
        if (r) {
          const a = r.getLabel();
          a && (n.keybinding = a);
        }
      }
      const o = new q3(t.context, e, n, this.menuStyles);
      if (t.enableMnemonics) {
        const r = o.getMnemonic();
        if (r && o.isEnabled()) {
          let a = [];
          this.mnemonics.has(r) && (a = this.mnemonics.get(r)), a.push(o), this.mnemonics.set(r, a);
        }
      }
      return o;
    }
  }
}
class q3 extends Er {
  constructor(e, t, i, n) {
    if (i.isMenu = !0, super(t, t, i), this.menuStyle = n, this.options = i, this.options.icon = i.icon !== void 0 ? i.icon : !1, this.options.label = i.label !== void 0 ? i.label : !0, this.cssClass = "", this.options.label && i.enableMnemonics) {
      const o = this.action.label;
      if (o) {
        const r = rk.exec(o);
        r && (this.mnemonic = (r[1] ? r[1] : r[3]).toLocaleLowerCase());
      }
    }
    this.runOnceToEnableMouseUp = new zt(() => {
      this.element && (this._register(U(this.element, ee.MOUSE_UP, (o) => {
        if (Ve.stop(o, !0), Ko) {
          if (new Ir(fe(this.element), o).rightButton)
            return;
          this.onClick(o);
        } else
          setTimeout(() => {
            this.onClick(o);
          }, 0);
      })), this._register(U(this.element, ee.CONTEXT_MENU, (o) => {
        Ve.stop(o, !0);
      })));
    }, 100), this._register(this.runOnceToEnableMouseUp);
  }
  render(e) {
    super.render(e), this.element && (this.container = e, this.item = K(this.element, de("a.action-menu-item")), this._action.id === Ri.ID ? this.item.setAttribute("role", "presentation") : (this.item.setAttribute("role", "menuitem"), this.mnemonic && this.item.setAttribute("aria-keyshortcuts", `${this.mnemonic}`)), this.check = K(this.item, de("span.menu-item-check" + pe.asCSSSelector(Z.menuSelection))), this.check.setAttribute("role", "none"), this.label = K(this.item, de("span.action-label")), this.options.label && this.options.keybinding && (K(this.item, de("span.keybinding")).textContent = this.options.keybinding), this.runOnceToEnableMouseUp.schedule(), this.updateClass(), this.updateLabel(), this.updateTooltip(), this.updateEnabled(), this.updateChecked(), this.applyStyle());
  }
  blur() {
    super.blur(), this.applyStyle();
  }
  focus() {
    super.focus(), this.item?.focus(), this.applyStyle();
  }
  updatePositionInSet(e, t) {
    this.item && (this.item.setAttribute("aria-posinset", `${e}`), this.item.setAttribute("aria-setsize", `${t}`));
  }
  updateLabel() {
    if (this.label && this.options.label) {
      Bn(this.label);
      let e = v3(this.action.label);
      if (e) {
        const t = nX(e);
        this.options.enableMnemonics || (e = t), this.label.setAttribute("aria-label", t.replace(/&&/g, "&"));
        const i = rk.exec(e);
        if (i) {
          e = Ip(e), Ny.lastIndex = 0;
          let n = Ny.exec(e);
          for (; n && n[1]; )
            n = Ny.exec(e);
          const o = (r) => r.replace(/&amp;&amp;/g, "&amp;");
          n ? this.label.append(_0(o(e.substr(0, n.index)), " "), de("u", { "aria-hidden": "true" }, n[3]), D7(o(e.substr(n.index + n[0].length)), " ")) : this.label.innerText = o(e).trim(), this.item?.setAttribute("aria-keyshortcuts", (i[1] ? i[1] : i[3]).toLocaleLowerCase());
        } else
          this.label.innerText = e.replace(/&&/g, "&").trim();
      }
    }
  }
  updateTooltip() {
  }
  updateClass() {
    this.cssClass && this.item && this.item.classList.remove(...this.cssClass.split(" ")), this.options.icon && this.label ? (this.cssClass = this.action.class || "", this.label.classList.add("icon"), this.cssClass && this.label.classList.add(...this.cssClass.split(" ")), this.updateEnabled()) : this.label && this.label.classList.remove("icon");
  }
  updateEnabled() {
    this.action.enabled ? (this.element && (this.element.classList.remove("disabled"), this.element.removeAttribute("aria-disabled")), this.item && (this.item.classList.remove("disabled"), this.item.removeAttribute("aria-disabled"), this.item.tabIndex = 0)) : (this.element && (this.element.classList.add("disabled"), this.element.setAttribute("aria-disabled", "true")), this.item && (this.item.classList.add("disabled"), this.item.setAttribute("aria-disabled", "true")));
  }
  updateChecked() {
    if (!this.item)
      return;
    const e = this.action.checked;
    this.item.classList.toggle("checked", !!e), e !== void 0 ? (this.item.setAttribute("role", "menuitemcheckbox"), this.item.setAttribute("aria-checked", e ? "true" : "false")) : (this.item.setAttribute("role", "menuitem"), this.item.setAttribute("aria-checked", ""));
  }
  getMnemonic() {
    return this.mnemonic;
  }
  applyStyle() {
    const e = this.element && this.element.classList.contains("focused"), t = e && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor, i = e && this.menuStyle.selectionBackgroundColor ? this.menuStyle.selectionBackgroundColor : void 0, n = e && this.menuStyle.selectionBorderColor ? `1px solid ${this.menuStyle.selectionBorderColor}` : "", o = e && this.menuStyle.selectionBorderColor ? "-1px" : "";
    this.item && (this.item.style.color = t ?? "", this.item.style.backgroundColor = i ?? "", this.item.style.outline = n, this.item.style.outlineOffset = o), this.check && (this.check.style.color = t ?? "");
  }
}
class pF extends q3 {
  constructor(e, t, i, n, o) {
    super(e, e, n, o), this.submenuActions = t, this.parentData = i, this.submenuOptions = n, this.mysubmenu = null, this.submenuDisposables = this._register(new X()), this.mouseOver = !1, this.expandDirection = n && n.expandDirection !== void 0 ? n.expandDirection : { horizontal: WC.Right, vertical: ak.Below }, this.showScheduler = new zt(() => {
      this.mouseOver && (this.cleanupExistingSubmenu(!1), this.createSubmenu(!1));
    }, 250), this.hideScheduler = new zt(() => {
      this.element && !yi(ln(), this.element) && this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    }, 750);
  }
  render(e) {
    super.render(e), this.element && (this.item && (this.item.classList.add("monaco-submenu-item"), this.item.tabIndex = 0, this.item.setAttribute("aria-haspopup", "true"), this.updateAriaExpanded("false"), this.submenuIndicator = K(this.item, de("span.submenu-indicator" + pe.asCSSSelector(Z.menuSubmenu))), this.submenuIndicator.setAttribute("aria-hidden", "true")), this._register(U(this.element, ee.KEY_UP, (t) => {
      const i = new Mt(t);
      (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && (Ve.stop(t, !0), this.createSubmenu(!0));
    })), this._register(U(this.element, ee.KEY_DOWN, (t) => {
      const i = new Mt(t);
      ln() === this.item && (i.equals(
        17
        /* KeyCode.RightArrow */
      ) || i.equals(
        3
        /* KeyCode.Enter */
      )) && Ve.stop(t, !0);
    })), this._register(U(this.element, ee.MOUSE_OVER, (t) => {
      this.mouseOver || (this.mouseOver = !0, this.showScheduler.schedule());
    })), this._register(U(this.element, ee.MOUSE_LEAVE, (t) => {
      this.mouseOver = !1;
    })), this._register(U(this.element, ee.FOCUS_OUT, (t) => {
      this.element && !yi(ln(), this.element) && this.hideScheduler.schedule();
    })), this._register(this.parentData.parent.onScroll(() => {
      this.parentData.submenu === this.mysubmenu && (this.parentData.parent.focus(!1), this.cleanupExistingSubmenu(!0));
    })));
  }
  updateEnabled() {
  }
  onClick(e) {
    Ve.stop(e, !0), this.cleanupExistingSubmenu(!1), this.createSubmenu(!0);
  }
  cleanupExistingSubmenu(e) {
    if (this.parentData.submenu && (e || this.parentData.submenu !== this.mysubmenu)) {
      try {
        this.parentData.submenu.dispose();
      } catch {
      }
      this.parentData.submenu = void 0, this.updateAriaExpanded("false"), this.submenuContainer && (this.submenuDisposables.clear(), this.submenuContainer = void 0);
    }
  }
  calculateSubmenuMenuLayout(e, t, i, n) {
    const o = { top: 0, left: 0 };
    return o.left = Fg(e.width, t.width, { position: n.horizontal === WC.Right ? 0 : 1, offset: i.left, size: i.width }), o.left >= i.left && o.left < i.left + i.width && (i.left + 10 + t.width <= e.width && (o.left = i.left + 10), i.top += 10, i.height = 0), o.top = Fg(e.height, t.height, { position: 0, offset: i.top, size: 0 }), o.top + t.height === i.top && o.top + i.height + t.height <= e.height && (o.top += i.height), o;
  }
  createSubmenu(e = !0) {
    if (this.element)
      if (this.parentData.submenu)
        this.parentData.submenu.focus(!1);
      else {
        this.updateAriaExpanded("true"), this.submenuContainer = K(this.element, de("div.monaco-submenu")), this.submenuContainer.classList.add("menubar-menu-items-holder", "context-view");
        const t = fe(this.parentData.parent.domNode).getComputedStyle(this.parentData.parent.domNode), i = parseFloat(t.paddingTop || "0") || 0;
        this.submenuContainer.style.zIndex = "1", this.submenuContainer.style.position = "fixed", this.submenuContainer.style.top = "0", this.submenuContainer.style.left = "0", this.parentData.submenu = new vf(this.submenuContainer, this.submenuActions.length ? this.submenuActions : [new jE()], this.submenuOptions, this.menuStyle);
        const n = this.element.getBoundingClientRect(), o = {
          top: n.top - i,
          left: n.left,
          height: n.height + 2 * i,
          width: n.width
        }, r = this.submenuContainer.getBoundingClientRect(), a = fe(this.element), { top: l, left: c } = this.calculateSubmenuMenuLayout(new at(a.innerWidth, a.innerHeight), at.lift(r), o, this.expandDirection);
        this.submenuContainer.style.left = `${c - r.left}px`, this.submenuContainer.style.top = `${l - r.top}px`, this.submenuDisposables.add(U(this.submenuContainer, ee.KEY_UP, (d) => {
          new Mt(d).equals(
            15
            /* KeyCode.LeftArrow */
          ) && (Ve.stop(d, !0), this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0));
        })), this.submenuDisposables.add(U(this.submenuContainer, ee.KEY_DOWN, (d) => {
          new Mt(d).equals(
            15
            /* KeyCode.LeftArrow */
          ) && Ve.stop(d, !0);
        })), this.submenuDisposables.add(this.parentData.submenu.onDidCancel(() => {
          this.parentData.parent.focus(), this.cleanupExistingSubmenu(!0);
        })), this.parentData.submenu.focus(e), this.mysubmenu = this.parentData.submenu;
      }
  }
  updateAriaExpanded(e) {
    this.item && this.item?.setAttribute("aria-expanded", e);
  }
  applyStyle() {
    super.applyStyle();
    const t = this.element && this.element.classList.contains("focused") && this.menuStyle.selectionForegroundColor ? this.menuStyle.selectionForegroundColor : this.menuStyle.foregroundColor;
    this.submenuIndicator && (this.submenuIndicator.style.color = t ?? "");
  }
  dispose() {
    super.dispose(), this.hideScheduler.dispose(), this.mysubmenu && (this.mysubmenu.dispose(), this.mysubmenu = null), this.submenuContainer && (this.submenuContainer = void 0);
  }
}
class AF extends nm {
  constructor(e, t, i, n) {
    super(e, t, i), this.menuStyles = n;
  }
  render(e) {
    super.render(e), this.label && (this.label.style.borderBottomColor = this.menuStyles.separatorColor ? `${this.menuStyles.separatorColor}` : "");
  }
}
function nX(s) {
  const e = rk, t = e.exec(s);
  if (!t)
    return s;
  const i = !t[1];
  return s.replace(e, i ? "$2$3" : "").trim();
}
function _F(s) {
  const e = gH()[s.id];
  return `.codicon-${s.id}:before { content: '\\${e.toString(16)}'; }`;
}
function sX(s, e) {
  let t = (
    /* css */
    `
.monaco-menu {
	font-size: 13px;
	border-radius: 5px;
	min-width: 160px;
}

${_F(Z.menuSelection)}
${_F(Z.menuSubmenu)}

.monaco-menu .monaco-action-bar {
	text-align: right;
	overflow: hidden;
	white-space: nowrap;
}

.monaco-menu .monaco-action-bar .actions-container {
	display: flex;
	margin: 0 auto;
	padding: 0;
	width: 100%;
	justify-content: flex-end;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: inline-block;
}

.monaco-menu .monaco-action-bar.reverse .actions-container {
	flex-direction: row-reverse;
}

.monaco-menu .monaco-action-bar .action-item {
	cursor: pointer;
	display: inline-block;
	transition: transform 50ms ease;
	position: relative;  /* DO NOT REMOVE - this is the key to preventing the ghosting icon bug in Chrome 42 */
}

.monaco-menu .monaco-action-bar .action-item.disabled {
	cursor: default;
}

.monaco-menu .monaco-action-bar .action-item .icon,
.monaco-menu .monaco-action-bar .action-item .codicon {
	display: inline-block;
}

.monaco-menu .monaco-action-bar .action-item .codicon {
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar .action-label {
	font-size: 11px;
	margin-right: 4px;
}

.monaco-menu .monaco-action-bar .action-item.disabled .action-label,
.monaco-menu .monaco-action-bar .action-item.disabled .action-label:hover {
	color: var(--vscode-disabledForeground);
}

/* Vertical actions */

.monaco-menu .monaco-action-bar.vertical {
	text-align: left;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	display: block;
	border-bottom: 1px solid var(--vscode-menu-separatorBackground);
	padding-top: 1px;
	padding: 30px;
}

.monaco-menu .secondary-actions .monaco-action-bar .action-label {
	margin-left: 6px;
}

/* Action Items */
.monaco-menu .monaco-action-bar .action-item.select-container {
	overflow: hidden; /* somehow the dropdown overflows its container, we prevent it here to not push */
	flex: 1;
	max-width: 170px;
	min-width: 60px;
	display: flex;
	align-items: center;
	justify-content: center;
	margin-right: 10px;
}

.monaco-menu .monaco-action-bar.vertical {
	margin-left: 0;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .actions-container {
	display: block;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	padding: 0;
	transform: none;
	display: flex;
}

.monaco-menu .monaco-action-bar.vertical .action-item.active {
	transform: none;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	flex: 1 1 auto;
	display: flex;
	height: 2em;
	align-items: center;
	position: relative;
	margin: 0 4px;
	border-radius: 4px;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item:hover .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .keybinding {
	opacity: unset;
}

.monaco-menu .monaco-action-bar.vertical .action-label {
	flex: 1 1 auto;
	text-decoration: none;
	padding: 0 1em;
	background: none;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .keybinding,
.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	display: inline-block;
	flex: 2 1 auto;
	padding: 0 1em;
	text-align: right;
	font-size: 12px;
	line-height: 1;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon {
	font-size: 16px !important;
	display: flex;
	align-items: center;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator.codicon::before {
	margin-left: auto;
	margin-right: -20px;
}

.monaco-menu .monaco-action-bar.vertical .action-item.disabled .keybinding,
.monaco-menu .monaco-action-bar.vertical .action-item.disabled .submenu-indicator {
	opacity: 0.4;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator) {
	display: inline-block;
	box-sizing: border-box;
	margin: 0;
}

.monaco-menu .monaco-action-bar.vertical .action-item {
	position: static;
	overflow: visible;
}

.monaco-menu .monaco-action-bar.vertical .action-item .monaco-submenu {
	position: absolute;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	width: 100%;
	height: 0px !important;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator.text {
	padding: 0.7em 1em 0.1em 1em;
	font-weight: bold;
	opacity: 1;
}

.monaco-menu .monaco-action-bar.vertical .action-label:hover {
	color: inherit;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	position: absolute;
	visibility: hidden;
	width: 1em;
	height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item.checked .menu-item-check {
	visibility: visible;
	display: flex;
	align-items: center;
	justify-content: center;
}

/* Context Menu */

.context-view.monaco-menu-container {
	outline: 0;
	border: none;
	animation: fadeIn 0.083s linear;
	-webkit-app-region: no-drag;
}

.context-view.monaco-menu-container :focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical:focus,
.context-view.monaco-menu-container .monaco-action-bar.vertical :focus {
	outline: 0;
}

.hc-black .context-view.monaco-menu-container,
.hc-light .context-view.monaco-menu-container,
:host-context(.hc-black) .context-view.monaco-menu-container,
:host-context(.hc-light) .context-view.monaco-menu-container {
	box-shadow: none;
}

.hc-black .monaco-menu .monaco-action-bar.vertical .action-item.focused,
.hc-light .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-black) .monaco-menu .monaco-action-bar.vertical .action-item.focused,
:host-context(.hc-light) .monaco-menu .monaco-action-bar.vertical .action-item.focused {
	background: none;
}

/* Vertical Action Bar Styles */

.monaco-menu .monaco-action-bar.vertical {
	padding: 4px 0;
}

.monaco-menu .monaco-action-bar.vertical .action-menu-item {
	height: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label:not(.separator),
.monaco-menu .monaco-action-bar.vertical .keybinding {
	font-size: inherit;
	padding: 0 2em;
	max-height: 100%;
}

.monaco-menu .monaco-action-bar.vertical .menu-item-check {
	font-size: inherit;
	width: 2em;
}

.monaco-menu .monaco-action-bar.vertical .action-label.separator {
	font-size: inherit;
	margin: 5px 0 !important;
	padding: 0;
	border-radius: 0;
}

.linux .monaco-menu .monaco-action-bar.vertical .action-label.separator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .action-label.separator {
	margin-left: 0;
	margin-right: 0;
}

.monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	font-size: 60%;
	padding: 0 1.8em;
}

.linux .monaco-menu .monaco-action-bar.vertical .submenu-indicator,
:host-context(.linux) .monaco-menu .monaco-action-bar.vertical .submenu-indicator {
	height: 100%;
	mask-size: 10px 10px;
	-webkit-mask-size: 10px 10px;
}

.monaco-menu .action-item {
	cursor: default;
}`
  );
  if (e) {
    t += `
			/* Arrows */
			.monaco-scrollable-element > .scrollbar > .scra {
				cursor: pointer;
				font-size: 11px !important;
			}

			.monaco-scrollable-element > .visible {
				opacity: 1;

				/* Background rule added for IE9 - to allow clicks on dom node */
				background:rgba(0,0,0,0);

				transition: opacity 100ms linear;
			}
			.monaco-scrollable-element > .invisible {
				opacity: 0;
				pointer-events: none;
			}
			.monaco-scrollable-element > .invisible.fade {
				transition: opacity 800ms linear;
			}

			/* Scrollable Content Inset Shadow */
			.monaco-scrollable-element > .shadow {
				position: absolute;
				display: none;
			}
			.monaco-scrollable-element > .shadow.top {
				display: block;
				top: 0;
				left: 3px;
				height: 3px;
				width: 100%;
			}
			.monaco-scrollable-element > .shadow.left {
				display: block;
				top: 3px;
				left: 0;
				height: 100%;
				width: 3px;
			}
			.monaco-scrollable-element > .shadow.top-left-corner {
				display: block;
				top: 0;
				left: 0;
				height: 3px;
				width: 3px;
			}
		`;
    const i = s.scrollbarShadow;
    i && (t += `
				.monaco-scrollable-element > .shadow.top {
					box-shadow: ${i} 0 6px 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.left {
					box-shadow: ${i} 6px 0 6px -6px inset;
				}

				.monaco-scrollable-element > .shadow.top.left {
					box-shadow: ${i} 6px 6px 6px -6px inset;
				}
			`);
    const n = s.scrollbarSliderBackground;
    n && (t += `
				.monaco-scrollable-element > .scrollbar > .slider {
					background: ${n};
				}
			`);
    const o = s.scrollbarSliderHoverBackground;
    o && (t += `
				.monaco-scrollable-element > .scrollbar > .slider:hover {
					background: ${o};
				}
			`);
    const r = s.scrollbarSliderActiveBackground;
    r && (t += `
				.monaco-scrollable-element > .scrollbar > .slider.active {
					background: ${r};
				}
			`);
  }
  return t;
}
class oX {
  constructor(e, t, i, n) {
    this.contextViewService = e, this.telemetryService = t, this.notificationService = i, this.keybindingService = n, this.focusToReturn = null, this.lastContainer = null, this.block = null, this.blockDisposable = null, this.options = { blockMouse: !0 };
  }
  configure(e) {
    this.options = e;
  }
  showContextMenu(e) {
    const t = e.getActions();
    if (!t.length)
      return;
    this.focusToReturn = ln();
    let i;
    const n = Bi(e.domForShadowRoot) ? e.domForShadowRoot : void 0;
    this.contextViewService.showContextView({
      getAnchor: () => e.getAnchor(),
      canRelayout: !1,
      anchorAlignment: e.anchorAlignment,
      anchorAxisAlignment: e.anchorAxisAlignment,
      render: (o) => {
        this.lastContainer = o;
        const r = e.getMenuClassName ? e.getMenuClassName() : "";
        r && (o.className += " " + r), this.options.blockMouse && (this.block = o.appendChild(de(".context-view-block")), this.block.style.position = "fixed", this.block.style.cursor = "initial", this.block.style.left = "0", this.block.style.top = "0", this.block.style.width = "100%", this.block.style.height = "100%", this.block.style.zIndex = "-1", this.blockDisposable?.dispose(), this.blockDisposable = U(this.block, ee.MOUSE_DOWN, (d) => d.stopPropagation()));
        const a = new X(), l = e.actionRunner || new Au();
        l.onWillRun((d) => this.onActionRun(d, !e.skipTelemetry), this, a), l.onDidRun(this.onDidActionRun, this, a), i = new vf(o, t, {
          actionViewItemProvider: e.getActionViewItem,
          context: e.getActionsContext ? e.getActionsContext() : null,
          actionRunner: l,
          getKeyBinding: e.getKeyBinding ? e.getKeyBinding : (d) => this.keybindingService.lookupKeybinding(d.id)
        }, tX), i.onDidCancel(() => this.contextViewService.hideContextView(!0), null, a), i.onDidBlur(() => this.contextViewService.hideContextView(!0), null, a);
        const c = fe(o);
        return a.add(U(c, ee.BLUR, () => this.contextViewService.hideContextView(!0))), a.add(U(c, ee.MOUSE_DOWN, (d) => {
          if (d.defaultPrevented)
            return;
          const h = new Ir(c, d);
          let u = h.target;
          if (!h.rightButton) {
            for (; u; ) {
              if (u === o)
                return;
              u = u.parentElement;
            }
            this.contextViewService.hideContextView(!0);
          }
        })), jo(a, i);
      },
      focus: () => {
        i?.focus(!!e.autoSelectFirstItem);
      },
      onHide: (o) => {
        e.onHide?.(!!o), this.block && (this.block.remove(), this.block = null), this.blockDisposable?.dispose(), this.blockDisposable = null, this.lastContainer && (ln() === this.lastContainer || yi(ln(), this.lastContainer)) && this.focusToReturn?.focus(), this.lastContainer = null;
      }
    }, n, !!n);
  }
  onActionRun(e, t) {
    t && this.telemetryService.publicLog2("workbenchActionExecuted", { id: e.action.id, from: "contextMenu" }), this.contextViewService.hideContextView(!1);
  }
  onDidActionRun(e) {
    e.error && !Ad(e.error) && this.notificationService.error(e.error);
  }
}
var rX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, cg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let lk = class extends V {
  get contextMenuHandler() {
    return this._contextMenuHandler || (this._contextMenuHandler = new oX(this.contextViewService, this.telemetryService, this.notificationService, this.keybindingService)), this._contextMenuHandler;
  }
  constructor(e, t, i, n, o, r) {
    super(), this.telemetryService = e, this.notificationService = t, this.contextViewService = i, this.keybindingService = n, this.menuService = o, this.contextKeyService = r, this._contextMenuHandler = void 0, this._onDidShowContextMenu = this._store.add(new B()), this.onDidShowContextMenu = this._onDidShowContextMenu.event, this._onDidHideContextMenu = this._store.add(new B());
  }
  configure(e) {
    this.contextMenuHandler.configure(e);
  }
  // ContextMenu
  showContextMenu(e) {
    e = ck.transform(e, this.menuService, this.contextKeyService), this.contextMenuHandler.showContextMenu({
      ...e,
      onHide: (t) => {
        e.onHide?.(t), this._onDidHideContextMenu.fire();
      }
    }), bl.getInstance().resetKeyStatus(), this._onDidShowContextMenu.fire();
  }
};
lk = rX([
  cg(0, eo),
  cg(1, Oi),
  cg(2, Yl),
  cg(3, bt),
  cg(4, sr),
  cg(5, Se)
], lk);
var ck;
(function(s) {
  function e(i) {
    return i && i.menuId instanceof Qe;
  }
  function t(i, n, o) {
    if (!e(i))
      return i;
    const { menuId: r, menuActionOptions: a, contextKeyService: l } = i;
    return {
      ...i,
      getActions: () => {
        const c = [];
        if (r) {
          const d = n.getMenuActions(r, l ?? o, a);
          iX(d, c);
        }
        return i.getActions ? Ri.join(i.getActions(), c) : c;
      }
    };
  }
  s.transform = t;
})(ck || (ck = {}));
var VC;
(function(s) {
  s[s.API = 0] = "API", s[s.USER = 1] = "USER";
})(VC || (VC = {}));
var GN = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zC = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let dk = class {
  constructor(e) {
    this._commandService = e;
  }
  async open(e, t) {
    if (!GM(e, Ie.command))
      return !1;
    if (!t?.allowCommands || (typeof e == "string" && (e = _e.parse(e)), Array.isArray(t.allowCommands) && !t.allowCommands.includes(e.path)))
      return !0;
    let i = [];
    try {
      i = TL(decodeURIComponent(e.query));
    } catch {
      try {
        i = TL(e.query);
      } catch {
      }
    }
    return Array.isArray(i) || (i = [i]), await this._commandService.executeCommand(e.path, ...i), !0;
  }
};
dk = GN([
  zC(0, bi)
], dk);
let hk = class {
  constructor(e) {
    this._editorService = e;
  }
  async open(e, t) {
    typeof e == "string" && (e = _e.parse(e));
    const { selection: i, uri: n } = FK(e);
    return e = n, e.scheme === Ie.file && (e = AJ(e)), await this._editorService.openCodeEditor({
      resource: e,
      options: {
        selection: i,
        source: t?.fromUserGesture ? VC.USER : VC.API,
        ...t?.editorOptions
      }
    }, this._editorService.getFocusedCodeEditor(), t?.openToSide), !0;
  }
};
hk = GN([
  zC(0, Nt)
], hk);
let uk = class {
  constructor(e, t) {
    this._openers = new Nn(), this._validators = new Nn(), this._resolvers = new Nn(), this._resolvedUriTargets = new ws((i) => i.with({ path: null, fragment: null, query: null }).toString()), this._externalOpeners = new Nn(), this._defaultExternalOpener = {
      openExternal: async (i) => (HE(i, Ie.http, Ie.https) ? KH(i) : vt.location.href = i, !0)
    }, this._openers.push({
      open: async (i, n) => n?.openExternal || HE(i, Ie.mailto, Ie.http, Ie.https, Ie.vsls) ? (await this._doOpenExternal(i, n), !0) : !1
    }), this._openers.push(new dk(t)), this._openers.push(new hk(e));
  }
  registerOpener(e) {
    return { dispose: this._openers.unshift(e) };
  }
  async open(e, t) {
    const i = typeof e == "string" ? _e.parse(e) : e, n = this._resolvedUriTargets.get(i) ?? e;
    for (const o of this._validators)
      if (!await o.shouldOpen(n, t))
        return !1;
    for (const o of this._openers)
      if (await o.open(e, t))
        return !0;
    return !1;
  }
  async resolveExternalUri(e, t) {
    for (const i of this._resolvers)
      try {
        const n = await i.resolveExternalUri(e, t);
        if (n)
          return this._resolvedUriTargets.has(n.resolved) || this._resolvedUriTargets.set(n.resolved, e), n;
      } catch {
      }
    throw new Error("Could not resolve external URI: " + e.toString());
  }
  async _doOpenExternal(e, t) {
    const i = typeof e == "string" ? _e.parse(e) : e;
    let n;
    try {
      n = (await this.resolveExternalUri(i, t)).resolved;
    } catch {
      n = i;
    }
    let o;
    if (typeof e == "string" && i.toString() === n.toString() ? o = e : o = encodeURI(n.toString(!0)), t?.allowContributedOpeners) {
      const r = typeof t?.allowContributedOpeners == "string" ? t?.allowContributedOpeners : void 0;
      for (const a of this._externalOpeners)
        if (await a.openExternal(o, {
          sourceUri: i,
          preferredOpenerId: r
        }, ct.None))
          return !0;
    }
    return this._defaultExternalOpener.openExternal(o, { sourceUri: i }, ct.None);
  }
  dispose() {
    this._validators.clear();
  }
};
uk = GN([
  zC(0, Nt),
  zC(1, bi)
], uk);
const Sd = We("editorWorkerService");
var Yt;
(function(s) {
  s[s.Hint = 1] = "Hint", s[s.Info = 2] = "Info", s[s.Warning = 4] = "Warning", s[s.Error = 8] = "Error";
})(Yt || (Yt = {}));
(function(s) {
  function e(r, a) {
    return a - r;
  }
  s.compare = e;
  const t = /* @__PURE__ */ Object.create(null);
  t[s.Error] = f("sev.error", "Error"), t[s.Warning] = f("sev.warning", "Warning"), t[s.Info] = f("sev.info", "Info");
  function i(r) {
    return t[r] || "";
  }
  s.toString = i;
  function n(r) {
    switch (r) {
      case ii.Error:
        return s.Error;
      case ii.Warning:
        return s.Warning;
      case ii.Info:
        return s.Info;
      case ii.Ignore:
        return s.Hint;
    }
  }
  s.fromSeverity = n;
  function o(r) {
    switch (r) {
      case s.Error:
        return ii.Error;
      case s.Warning:
        return ii.Warning;
      case s.Info:
        return ii.Info;
      case s.Hint:
        return ii.Ignore;
    }
  }
  s.toSeverity = o;
})(Yt || (Yt = {}));
var UC;
(function(s) {
  const e = "";
  function t(n) {
    return i(n, !0);
  }
  s.makeKey = t;
  function i(n, o) {
    const r = [e];
    return n.source ? r.push(n.source.replace("¦", "\\¦")) : r.push(e), n.code ? typeof n.code == "string" ? r.push(n.code.replace("¦", "\\¦")) : r.push(n.code.value.replace("¦", "\\¦")) : r.push(e), n.severity !== void 0 && n.severity !== null ? r.push(Yt.toString(n.severity)) : r.push(e), n.message && o ? r.push(n.message.replace("¦", "\\¦")) : r.push(e), n.startLineNumber !== void 0 && n.startLineNumber !== null ? r.push(n.startLineNumber.toString()) : r.push(e), n.startColumn !== void 0 && n.startColumn !== null ? r.push(n.startColumn.toString()) : r.push(e), n.endLineNumber !== void 0 && n.endLineNumber !== null ? r.push(n.endLineNumber.toString()) : r.push(e), n.endColumn !== void 0 && n.endColumn !== null ? r.push(n.endColumn.toString()) : r.push(e), r.push(e), r.join("¦");
  }
  s.makeKeyOptionalMessage = i;
})(UC || (UC = {}));
const Pa = We("markerService"), $3 = L("editor.lineHighlightBackground", null, f("lineHighlight", "Background color for the highlight of line at the cursor position.")), bF = L("editor.lineHighlightBorder", { dark: "#282828", light: "#eeeeee", hcDark: "#f38518", hcLight: Je }, f("lineHighlightBorderBox", "Background color for the border around the line at the cursor position."));
L("editor.rangeHighlightBackground", { dark: "#ffffff0b", light: "#fdff0033", hcDark: null, hcLight: null }, f("rangeHighlight", "Background color of highlighted ranges, like by quick open and find features. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.rangeHighlightBorder", { dark: null, light: null, hcDark: Kt, hcLight: Kt }, f("rangeHighlightBorder", "Background color of the border around highlighted ranges."));
L("editor.symbolHighlightBackground", { dark: Cl, light: Cl, hcDark: null, hcLight: null }, f("symbolHighlight", "Background color of highlighted symbol, like for go to definition or go next/previous symbol. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.symbolHighlightBorder", { dark: null, light: null, hcDark: Kt, hcLight: Kt }, f("symbolHighlightBorder", "Background color of the border around highlighted symbols."));
const cS = L("editorCursor.foreground", { dark: "#AEAFAD", light: Y.black, hcDark: Y.white, hcLight: "#0F4A85" }, f("caret", "Color of the editor cursor.")), jN = L("editorCursor.background", null, f("editorCursorBackground", "The background color of the editor cursor. Allows customizing the color of a character overlapped by a block cursor.")), X3 = L("editorMultiCursor.primary.foreground", cS, f("editorMultiCursorPrimaryForeground", "Color of the primary editor cursor when multiple cursors are present.")), aX = L("editorMultiCursor.primary.background", jN, f("editorMultiCursorPrimaryBackground", "The background color of the primary editor cursor when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), Z3 = L("editorMultiCursor.secondary.foreground", cS, f("editorMultiCursorSecondaryForeground", "Color of secondary editor cursors when multiple cursors are present.")), lX = L("editorMultiCursor.secondary.background", jN, f("editorMultiCursorSecondaryBackground", "The background color of secondary editor cursors when multiple cursors are present. Allows customizing the color of a character overlapped by a block cursor.")), YN = L("editorWhitespace.foreground", { dark: "#e3e4e229", light: "#33333333", hcDark: "#e3e4e229", hcLight: "#CCCCCC" }, f("editorWhitespaces", "Color of whitespace characters in the editor.")), cX = L("editorLineNumber.foreground", { dark: "#858585", light: "#237893", hcDark: Y.white, hcLight: "#292929" }, f("editorLineNumbers", "Color of editor line numbers.")), dX = L("editorIndentGuide.background", YN, f("editorIndentGuides", "Color of the editor indentation guides."), !1, f("deprecatedEditorIndentGuides", "'editorIndentGuide.background' is deprecated. Use 'editorIndentGuide.background1' instead.")), hX = L("editorIndentGuide.activeBackground", YN, f("editorActiveIndentGuide", "Color of the active editor indentation guides."), !1, f("deprecatedEditorActiveIndentGuide", "'editorIndentGuide.activeBackground' is deprecated. Use 'editorIndentGuide.activeBackground1' instead.")), z_ = L("editorIndentGuide.background1", dX, f("editorIndentGuides1", "Color of the editor indentation guides (1).")), uX = L("editorIndentGuide.background2", "#00000000", f("editorIndentGuides2", "Color of the editor indentation guides (2).")), gX = L("editorIndentGuide.background3", "#00000000", f("editorIndentGuides3", "Color of the editor indentation guides (3).")), fX = L("editorIndentGuide.background4", "#00000000", f("editorIndentGuides4", "Color of the editor indentation guides (4).")), mX = L("editorIndentGuide.background5", "#00000000", f("editorIndentGuides5", "Color of the editor indentation guides (5).")), pX = L("editorIndentGuide.background6", "#00000000", f("editorIndentGuides6", "Color of the editor indentation guides (6).")), U_ = L("editorIndentGuide.activeBackground1", hX, f("editorActiveIndentGuide1", "Color of the active editor indentation guides (1).")), AX = L("editorIndentGuide.activeBackground2", "#00000000", f("editorActiveIndentGuide2", "Color of the active editor indentation guides (2).")), _X = L("editorIndentGuide.activeBackground3", "#00000000", f("editorActiveIndentGuide3", "Color of the active editor indentation guides (3).")), bX = L("editorIndentGuide.activeBackground4", "#00000000", f("editorActiveIndentGuide4", "Color of the active editor indentation guides (4).")), wX = L("editorIndentGuide.activeBackground5", "#00000000", f("editorActiveIndentGuide5", "Color of the active editor indentation guides (5).")), CX = L("editorIndentGuide.activeBackground6", "#00000000", f("editorActiveIndentGuide6", "Color of the active editor indentation guides (6).")), vX = L("editorActiveLineNumber.foreground", { dark: "#c6c6c6", light: "#0B216F", hcDark: Kt, hcLight: Kt }, f("editorActiveLineNumber", "Color of editor active line number"), !1, f("deprecatedEditorActiveLineNumber", "Id is deprecated. Use 'editorLineNumber.activeForeground' instead."));
L("editorLineNumber.activeForeground", vX, f("editorActiveLineNumber", "Color of editor active line number"));
const SX = L("editorLineNumber.dimmedForeground", null, f("editorDimmedLineNumber", "Color of the final editor line when editor.renderFinalNewline is set to dimmed."));
L("editorRuler.foreground", { dark: "#5A5A5A", light: Y.lightgrey, hcDark: Y.white, hcLight: "#292929" }, f("editorRuler", "Color of the editor rulers."));
L("editorCodeLens.foreground", { dark: "#999999", light: "#919191", hcDark: "#999999", hcLight: "#292929" }, f("editorCodeLensForeground", "Foreground color of editor CodeLens"));
L("editorBracketMatch.background", { dark: "#0064001a", light: "#0064001a", hcDark: "#0064001a", hcLight: "#0000" }, f("editorBracketMatchBackground", "Background color behind matching brackets"));
L("editorBracketMatch.border", { dark: "#888", light: "#B9B9B9", hcDark: Je, hcLight: Je }, f("editorBracketMatchBorder", "Color for matching brackets boxes"));
const yX = L("editorOverviewRuler.border", { dark: "#7f7f7f4d", light: "#7f7f7f4d", hcDark: "#7f7f7f4d", hcLight: "#666666" }, f("editorOverviewRulerBorder", "Color of the overview ruler border.")), xX = L("editorOverviewRuler.background", null, f("editorOverviewRulerBackground", "Background color of the editor overview ruler."));
L("editorGutter.background", $o, f("editorGutter", "Background color of the editor gutter. The gutter contains the glyph margins and the line numbers."));
L("editorUnnecessaryCode.border", { dark: null, light: null, hcDark: Y.fromHex("#fff").transparent(0.8), hcLight: Je }, f("unnecessaryCodeBorder", "Border color of unnecessary (unused) source code in the editor."));
const EX = L("editorUnnecessaryCode.opacity", { dark: Y.fromHex("#000a"), light: Y.fromHex("#0007"), hcDark: null, hcLight: null }, f("unnecessaryCodeOpacity", `Opacity of unnecessary (unused) source code in the editor. For example, "#000000c0" will render the code with 75% opacity. For high contrast themes, use the  'editorUnnecessaryCode.border' theme color to underline unnecessary code instead of fading it out.`));
L("editorGhostText.border", { dark: null, light: null, hcDark: Y.fromHex("#fff").transparent(0.8), hcLight: Y.fromHex("#292929").transparent(0.8) }, f("editorGhostTextBorder", "Border color of ghost text in the editor."));
L("editorGhostText.foreground", { dark: Y.fromHex("#ffffff56"), light: Y.fromHex("#0007"), hcDark: null, hcLight: null }, f("editorGhostTextForeground", "Foreground color of the ghost text in the editor."));
L("editorGhostText.background", null, f("editorGhostTextBackground", "Background color of the ghost text in the editor."));
const LX = new Y(new qe(0, 122, 204, 0.6)), kX = L("editorOverviewRuler.rangeHighlightForeground", LX, f("overviewRulerRangeHighlight", "Overview ruler marker color for range highlights. The color must not be opaque so as not to hide underlying decorations."), !0), DX = L("editorOverviewRuler.errorForeground", { dark: new Y(new qe(255, 18, 18, 0.7)), light: new Y(new qe(255, 18, 18, 0.7)), hcDark: new Y(new qe(255, 50, 50, 1)), hcLight: "#B5200D" }, f("overviewRuleError", "Overview ruler marker color for errors.")), IX = L("editorOverviewRuler.warningForeground", { dark: zl, light: zl, hcDark: VA, hcLight: VA }, f("overviewRuleWarning", "Overview ruler marker color for warnings.")), MX = L("editorOverviewRuler.infoForeground", { dark: Da, light: Da, hcDark: zA, hcLight: zA }, f("overviewRuleInfo", "Overview ruler marker color for infos.")), eW = L("editorBracketHighlight.foreground1", { dark: "#FFD700", light: "#0431FAFF", hcDark: "#FFD700", hcLight: "#0431FAFF" }, f("editorBracketHighlightForeground1", "Foreground color of brackets (1). Requires enabling bracket pair colorization.")), tW = L("editorBracketHighlight.foreground2", { dark: "#DA70D6", light: "#319331FF", hcDark: "#DA70D6", hcLight: "#319331FF" }, f("editorBracketHighlightForeground2", "Foreground color of brackets (2). Requires enabling bracket pair colorization.")), iW = L("editorBracketHighlight.foreground3", { dark: "#179FFF", light: "#7B3814FF", hcDark: "#87CEFA", hcLight: "#7B3814FF" }, f("editorBracketHighlightForeground3", "Foreground color of brackets (3). Requires enabling bracket pair colorization.")), nW = L("editorBracketHighlight.foreground4", "#00000000", f("editorBracketHighlightForeground4", "Foreground color of brackets (4). Requires enabling bracket pair colorization.")), sW = L("editorBracketHighlight.foreground5", "#00000000", f("editorBracketHighlightForeground5", "Foreground color of brackets (5). Requires enabling bracket pair colorization.")), oW = L("editorBracketHighlight.foreground6", "#00000000", f("editorBracketHighlightForeground6", "Foreground color of brackets (6). Requires enabling bracket pair colorization.")), NX = L("editorBracketHighlight.unexpectedBracket.foreground", { dark: new Y(new qe(255, 18, 18, 0.8)), light: new Y(new qe(255, 18, 18, 0.8)), hcDark: "new Color(new RGBA(255, 50, 50, 1))", hcLight: "#B5200D" }, f("editorBracketHighlightUnexpectedBracketForeground", "Foreground color of unexpected brackets.")), TX = L("editorBracketPairGuide.background1", "#00000000", f("editorBracketPairGuide.background1", "Background color of inactive bracket pair guides (1). Requires enabling bracket pair guides.")), BX = L("editorBracketPairGuide.background2", "#00000000", f("editorBracketPairGuide.background2", "Background color of inactive bracket pair guides (2). Requires enabling bracket pair guides.")), RX = L("editorBracketPairGuide.background3", "#00000000", f("editorBracketPairGuide.background3", "Background color of inactive bracket pair guides (3). Requires enabling bracket pair guides.")), FX = L("editorBracketPairGuide.background4", "#00000000", f("editorBracketPairGuide.background4", "Background color of inactive bracket pair guides (4). Requires enabling bracket pair guides.")), OX = L("editorBracketPairGuide.background5", "#00000000", f("editorBracketPairGuide.background5", "Background color of inactive bracket pair guides (5). Requires enabling bracket pair guides.")), PX = L("editorBracketPairGuide.background6", "#00000000", f("editorBracketPairGuide.background6", "Background color of inactive bracket pair guides (6). Requires enabling bracket pair guides.")), HX = L("editorBracketPairGuide.activeBackground1", "#00000000", f("editorBracketPairGuide.activeBackground1", "Background color of active bracket pair guides (1). Requires enabling bracket pair guides.")), WX = L("editorBracketPairGuide.activeBackground2", "#00000000", f("editorBracketPairGuide.activeBackground2", "Background color of active bracket pair guides (2). Requires enabling bracket pair guides.")), VX = L("editorBracketPairGuide.activeBackground3", "#00000000", f("editorBracketPairGuide.activeBackground3", "Background color of active bracket pair guides (3). Requires enabling bracket pair guides.")), zX = L("editorBracketPairGuide.activeBackground4", "#00000000", f("editorBracketPairGuide.activeBackground4", "Background color of active bracket pair guides (4). Requires enabling bracket pair guides.")), UX = L("editorBracketPairGuide.activeBackground5", "#00000000", f("editorBracketPairGuide.activeBackground5", "Background color of active bracket pair guides (5). Requires enabling bracket pair guides.")), QX = L("editorBracketPairGuide.activeBackground6", "#00000000", f("editorBracketPairGuide.activeBackground6", "Background color of active bracket pair guides (6). Requires enabling bracket pair guides."));
L("editorUnicodeHighlight.border", zl, f("editorUnicodeHighlight.border", "Border color used to highlight unicode characters."));
L("editorUnicodeHighlight.background", Vj, f("editorUnicodeHighlight.background", "Background color used to highlight unicode characters."));
rr((s, e) => {
  const t = s.getColor($o), i = s.getColor($3), n = i && !i.isTransparent() ? i : t;
  n && e.addRule(`.monaco-editor .inputarea.ime-input { background-color: ${n}; }`);
});
function GX(s, e) {
  const t = [], i = [];
  for (const n of s)
    e.has(n) || t.push(n);
  for (const n of e)
    s.has(n) || i.push(n);
  return { removed: t, added: i };
}
function jX(s, e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    s.has(i) && t.add(i);
  return t;
}
var YX = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, wF = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let gk = class extends V {
  constructor(e, t) {
    super(), this._markerService = t, this._onDidChangeMarker = this._register(new B()), this._markerDecorations = new ws(), e.getModels().forEach((i) => this._onModelAdded(i)), this._register(e.onModelAdded(this._onModelAdded, this)), this._register(e.onModelRemoved(this._onModelRemoved, this)), this._register(this._markerService.onMarkerChanged(this._handleMarkerChange, this));
  }
  dispose() {
    super.dispose(), this._markerDecorations.forEach((e) => e.dispose()), this._markerDecorations.clear();
  }
  getMarker(e, t) {
    const i = this._markerDecorations.get(e);
    return i && i.getMarker(t) || null;
  }
  _handleMarkerChange(e) {
    e.forEach((t) => {
      const i = this._markerDecorations.get(t);
      i && this._updateDecorations(i);
    });
  }
  _onModelAdded(e) {
    const t = new KX(e);
    this._markerDecorations.set(e.uri, t), this._updateDecorations(t);
  }
  _onModelRemoved(e) {
    const t = this._markerDecorations.get(e.uri);
    t && (t.dispose(), this._markerDecorations.delete(e.uri)), (e.uri.scheme === Ie.inMemory || e.uri.scheme === Ie.internal || e.uri.scheme === Ie.vscode) && this._markerService?.read({ resource: e.uri }).map((i) => i.owner).forEach((i) => this._markerService.remove(i, [e.uri]));
  }
  _updateDecorations(e) {
    const t = this._markerService.read({ resource: e.model.uri, take: 500 });
    e.update(t) && this._onDidChangeMarker.fire(e.model);
  }
};
gk = YX([
  wF(0, Fi),
  wF(1, Pa)
], gk);
class KX extends V {
  constructor(e) {
    super(), this.model = e, this._map = new QQ(), this._register(we(() => {
      this.model.deltaDecorations([...this._map.values()], []), this._map.clear();
    }));
  }
  update(e) {
    const { added: t, removed: i } = GX(new Set(this._map.keys()), new Set(e));
    if (t.length === 0 && i.length === 0)
      return !1;
    const n = i.map((a) => this._map.get(a)), o = t.map((a) => ({
      range: this._createDecorationRange(this.model, a),
      options: this._createDecorationOption(a)
    })), r = this.model.deltaDecorations(n, o);
    for (const a of i)
      this._map.delete(a);
    for (let a = 0; a < r.length; a++)
      this._map.set(t[a], r[a]);
    return !0;
  }
  getMarker(e) {
    return this._map.getKey(e.id);
  }
  _createDecorationRange(e, t) {
    let i = E.lift(t);
    if (t.severity === Yt.Hint && !this._hasMarkerTag(
      t,
      1
      /* MarkerTag.Unnecessary */
    ) && !this._hasMarkerTag(
      t,
      2
      /* MarkerTag.Deprecated */
    ) && (i = i.setEndPosition(i.startLineNumber, i.startColumn + 2)), i = e.validateRange(i), i.isEmpty()) {
      const n = e.getLineLastNonWhitespaceColumn(i.startLineNumber) || e.getLineMaxColumn(i.startLineNumber);
      if (n === 1 || i.endColumn >= n)
        return i;
      const o = e.getWordAtPosition(i.getStartPosition());
      o && (i = new E(i.startLineNumber, o.startColumn, i.endLineNumber, o.endColumn));
    } else if (t.endColumn === Number.MAX_VALUE && t.startColumn === 1 && i.startLineNumber === i.endLineNumber) {
      const n = e.getLineFirstNonWhitespaceColumn(t.startLineNumber);
      n < i.endColumn && (i = new E(i.startLineNumber, n, i.endLineNumber, i.endColumn), t.startColumn = n);
    }
    return i;
  }
  _createDecorationOption(e) {
    let t, i, n, o, r;
    switch (e.severity) {
      case Yt.Hint:
        this._hasMarkerTag(
          e,
          2
          /* MarkerTag.Deprecated */
        ) ? t = void 0 : this._hasMarkerTag(
          e,
          1
          /* MarkerTag.Unnecessary */
        ) ? t = "squiggly-unnecessary" : t = "squiggly-hint", n = 0;
        break;
      case Yt.Info:
        t = "squiggly-info", i = Wi(MX), n = 10, r = {
          color: Wi(dY),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case Yt.Warning:
        t = "squiggly-warning", i = Wi(IX), n = 20, r = {
          color: Wi(hY),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
      case Yt.Error:
      default:
        t = "squiggly-error", i = Wi(DX), n = 30, r = {
          color: Wi(uY),
          position: 1
          /* MinimapPosition.Inline */
        };
        break;
    }
    return e.tags && (e.tags.indexOf(
      1
      /* MarkerTag.Unnecessary */
    ) !== -1 && (o = "squiggly-inline-unnecessary"), e.tags.indexOf(
      2
      /* MarkerTag.Deprecated */
    ) !== -1 && (o = "squiggly-inline-deprecated")), {
      description: "marker-decoration",
      stickiness: 1,
      className: t,
      showIfCollapsed: !0,
      overviewRuler: {
        color: i,
        position: Bl.Right
      },
      minimap: r,
      zIndex: n,
      inlineClassName: o
    };
  }
  _hasMarkerTag(e, t) {
    return e.tags ? e.tags.indexOf(t) >= 0 : !1;
  }
}
const KN = We("markerDecorationsService");
class wi {
  static _nextVisibleColumn(e, t, i) {
    return e === 9 ? wi.nextRenderTabStop(t, i) : sd(e) || VM(e) ? t + 2 : t + 1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  static visibleColumnFromColumn(e, t, i) {
    const n = Math.min(t - 1, e.length), o = e.substring(0, n), r = new iC(o);
    let a = 0;
    for (; !r.eol(); ) {
      const l = tC(o, n, r.offset);
      r.nextGraphemeLength(), a = this._nextVisibleColumn(l, a, i);
    }
    return a;
  }
  /**
   * Returns a column from a visible column.
   * @see {@link CursorColumns}
   */
  static columnFromVisibleColumn(e, t, i) {
    if (t <= 0)
      return 1;
    const n = e.length, o = new iC(e);
    let r = 0, a = 1;
    for (; !o.eol(); ) {
      const l = tC(e, n, o.offset);
      o.nextGraphemeLength();
      const c = this._nextVisibleColumn(l, r, i), d = o.offset + 1;
      if (c >= t) {
        const h = t - r;
        return c - t < h ? d : a;
      }
      r = c, a = d;
    }
    return n + 1;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextRenderTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static nextIndentTabStop(e, t) {
    return e + t - e % t;
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevRenderTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
  /**
   * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
   * @see {@link CursorColumns}
   */
  static prevIndentTabStop(e, t) {
    return Math.max(0, e - 1 - (e - 1) % t);
  }
}
function JX(s, e, t) {
  let i = 0;
  for (let o = 0; o < s.length; o++)
    s.charAt(o) === "	" ? i = wi.nextIndentTabStop(i, e) : i++;
  let n = "";
  if (!t) {
    const o = Math.floor(i / e);
    i = i % e;
    for (let r = 0; r < o; r++)
      n += "	";
  }
  for (let o = 0; o < i; o++)
    n += " ";
  return n;
}
function rW(s, e, t) {
  let i = Sn(s);
  return i === -1 && (i = s.length), JX(s.substring(0, i), e, t) + s.substring(i);
}
class CF {
  constructor(e, t, i, n) {
    this.range = e, this.nestingLevel = t, this.nestingLevelOfEqualBracketType = i, this.isInvalid = n;
  }
}
class qX {
  constructor(e, t, i, n, o, r) {
    this.range = e, this.openingBracketRange = t, this.closingBracketRange = i, this.nestingLevel = n, this.nestingLevelOfEqualBracketType = o, this.bracketPairNode = r;
  }
  get openingBracketInfo() {
    return this.bracketPairNode.openingBracket.bracketInfo;
  }
}
class $X extends qX {
  constructor(e, t, i, n, o, r, a) {
    super(e, t, i, n, o, r), this.minVisibleColumnIndentation = a;
  }
}
function XX(s, e, t, i) {
  return s !== t ? li(t - s, i) : li(0, i - e);
}
const Xn = 0;
function QC(s) {
  return s === 0;
}
const js = 2 ** 26;
function li(s, e) {
  return s * js + e;
}
function Co(s) {
  const e = s, t = Math.floor(e / js), i = e - t * js;
  return new ad(t, i);
}
function ZX(s) {
  return Math.floor(s / js);
}
function _i(s, e) {
  let t = s + e;
  return e >= js && (t = t - s % js), t;
}
function eZ(s, e) {
  return s.reduce((t, i) => _i(t, e(i)), Xn);
}
function aW(s, e) {
  return s === e;
}
function JA(s, e) {
  const t = s, i = e;
  if (i - t <= 0)
    return Xn;
  const o = Math.floor(t / js), r = Math.floor(i / js), a = i - r * js;
  if (o === r) {
    const l = t - o * js;
    return li(0, a - l);
  } else
    return li(r - o, a);
}
function Sf(s, e) {
  return s < e;
}
function yf(s, e) {
  return s <= e;
}
function Ap(s, e) {
  return s >= e;
}
function Vg(s) {
  return li(s.lineNumber - 1, s.column - 1);
}
function Ih(s, e) {
  const t = s, i = Math.floor(t / js), n = t - i * js, o = e, r = Math.floor(o / js), a = o - r * js;
  return new E(i + 1, n + 1, r + 1, a + 1);
}
function tZ(s) {
  const e = bd(s);
  return li(e.length - 1, e[e.length - 1].length);
}
class vl {
  static fromModelContentChanges(e) {
    return e.map((i) => {
      const n = E.lift(i.range);
      return new vl(Vg(n.getStartPosition()), Vg(n.getEndPosition()), tZ(i.text));
    }).reverse();
  }
  constructor(e, t, i) {
    this.startOffset = e, this.endOffset = t, this.newLength = i;
  }
  toString() {
    return `[${Co(this.startOffset)}...${Co(this.endOffset)}) -> ${Co(this.newLength)}`;
  }
}
class iZ {
  /**
   * @param edits Must be sorted by offset in ascending order.
  */
  constructor(e) {
    this.nextEditIdx = 0, this.deltaOldToNewLineCount = 0, this.deltaOldToNewColumnCount = 0, this.deltaLineIdxInOld = -1, this.edits = e.map((t) => JN.from(t));
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
  */
  getOffsetBeforeChange(e) {
    return this.adjustNextEdit(e), this.translateCurToOld(e);
  }
  /**
   * @param offset Must be equal to or greater than the last offset this method has been called with.
   * Returns null if there is no edit anymore.
  */
  getDistanceToNextChange(e) {
    this.adjustNextEdit(e);
    const t = this.edits[this.nextEditIdx], i = t ? this.translateOldToCur(t.offsetObj) : null;
    return i === null ? null : JA(e, i);
  }
  translateOldToCur(e) {
    return e.lineCount === this.deltaLineIdxInOld ? li(e.lineCount + this.deltaOldToNewLineCount, e.columnCount + this.deltaOldToNewColumnCount) : li(e.lineCount + this.deltaOldToNewLineCount, e.columnCount);
  }
  translateCurToOld(e) {
    const t = Co(e);
    return t.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld ? li(t.lineCount - this.deltaOldToNewLineCount, t.columnCount - this.deltaOldToNewColumnCount) : li(t.lineCount - this.deltaOldToNewLineCount, t.columnCount);
  }
  adjustNextEdit(e) {
    for (; this.nextEditIdx < this.edits.length; ) {
      const t = this.edits[this.nextEditIdx], i = this.translateOldToCur(t.endOffsetAfterObj);
      if (yf(i, e)) {
        this.nextEditIdx++;
        const n = Co(i), o = Co(this.translateOldToCur(t.endOffsetBeforeObj)), r = n.lineCount - o.lineCount;
        this.deltaOldToNewLineCount += r;
        const a = this.deltaLineIdxInOld === t.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0, l = n.columnCount - o.columnCount;
        this.deltaOldToNewColumnCount = a + l, this.deltaLineIdxInOld = t.endOffsetBeforeObj.lineCount;
      } else
        break;
    }
  }
}
class JN {
  static from(e) {
    return new JN(e.startOffset, e.endOffset, e.newLength);
  }
  constructor(e, t, i) {
    this.endOffsetBeforeObj = Co(t), this.endOffsetAfterObj = Co(_i(e, i)), this.offsetObj = Co(e);
  }
}
const Ib = [], ro = class ro {
  static create(e, t) {
    if (e <= 128 && t.length === 0) {
      let i = ro.cache[e];
      return i || (i = new ro(e, t), ro.cache[e] = i), i;
    }
    return new ro(e, t);
  }
  static getEmpty() {
    return this.empty;
  }
  constructor(e, t) {
    this.items = e, this.additionalItems = t;
  }
  add(e, t) {
    const i = t.getKey(e);
    let n = i >> 5;
    if (n === 0) {
      const r = 1 << i | this.items;
      return r === this.items ? this : ro.create(r, this.additionalItems);
    }
    n--;
    const o = this.additionalItems.slice(0);
    for (; o.length < n; )
      o.push(0);
    return o[n] |= 1 << (i & 31), ro.create(this.items, o);
  }
  merge(e) {
    const t = this.items | e.items;
    if (this.additionalItems === Ib && e.additionalItems === Ib)
      return t === this.items ? this : t === e.items ? e : ro.create(t, Ib);
    const i = [];
    for (let n = 0; n < Math.max(this.additionalItems.length, e.additionalItems.length); n++) {
      const o = this.additionalItems[n] || 0, r = e.additionalItems[n] || 0;
      i.push(o | r);
    }
    return ro.create(t, i);
  }
  intersects(e) {
    if (this.items & e.items)
      return !0;
    for (let t = 0; t < Math.min(this.additionalItems.length, e.additionalItems.length); t++)
      if (this.additionalItems[t] & e.additionalItems[t])
        return !0;
    return !1;
  }
};
ro.cache = new Array(129), ro.empty = ro.create(0, Ib);
let As = ro;
const vF = {
  getKey(s) {
    return s;
  }
};
class nZ {
  constructor() {
    this.items = /* @__PURE__ */ new Map();
  }
  getKey(e) {
    let t = this.items.get(e);
    return t === void 0 && (t = this.items.size, this.items.set(e, t)), t;
  }
}
class qN {
  /**
   * The length of the entire node, which should equal the sum of lengths of all children.
  */
  get length() {
    return this._length;
  }
  constructor(e) {
    this._length = e;
  }
}
class qA extends qN {
  static create(e, t, i) {
    let n = e.length;
    return t && (n = _i(n, t.length)), i && (n = _i(n, i.length)), new qA(n, e, t, i, t ? t.missingOpeningBracketIds : As.getEmpty());
  }
  get kind() {
    return 2;
  }
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 3;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this.openingBracket;
      case 1:
        return this.child;
      case 2:
        return this.closingBracket;
    }
    throw new Error("Invalid child index");
  }
  /**
   * Avoid using this property, it allocates an array!
  */
  get children() {
    const e = [];
    return e.push(this.openingBracket), this.child && e.push(this.child), this.closingBracket && e.push(this.closingBracket), e;
  }
  constructor(e, t, i, n, o) {
    super(e), this.openingBracket = t, this.child = i, this.closingBracket = n, this.missingOpeningBracketIds = o;
  }
  canBeReused(e) {
    return !(this.closingBracket === null || e.intersects(this.missingOpeningBracketIds));
  }
  deepClone() {
    return new qA(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return this.child ? this.child.computeMinIndentation(_i(e, this.openingBracket.length), t) : Number.MAX_SAFE_INTEGER;
  }
}
class Ma extends qN {
  /**
   * This method uses more memory-efficient list nodes that can only store 2 or 3 children.
  */
  static create23(e, t, i, n = !1) {
    let o = e.length, r = e.missingOpeningBracketIds;
    if (e.listHeight !== t.listHeight)
      throw new Error("Invalid list heights");
    if (o = _i(o, t.length), r = r.merge(t.missingOpeningBracketIds), i) {
      if (e.listHeight !== i.listHeight)
        throw new Error("Invalid list heights");
      o = _i(o, i.length), r = r.merge(i.missingOpeningBracketIds);
    }
    return n ? new sZ(o, e.listHeight + 1, e, t, i, r) : new $A(o, e.listHeight + 1, e, t, i, r);
  }
  static getEmpty() {
    return new oZ(Xn, 0, [], As.getEmpty());
  }
  get kind() {
    return 4;
  }
  get missingOpeningBracketIds() {
    return this._missingOpeningBracketIds;
  }
  /**
   * Use ListAstNode.create.
  */
  constructor(e, t, i) {
    super(e), this.listHeight = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  throwIfImmutable() {
  }
  makeLastElementMutable() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    if (e === 0)
      return;
    const t = this.getChild(e - 1), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(e - 1, i), i;
  }
  makeFirstElementMutable() {
    if (this.throwIfImmutable(), this.childrenLength === 0)
      return;
    const t = this.getChild(0), i = t.kind === 4 ? t.toMutable() : t;
    return t !== i && this.setChild(0, i), i;
  }
  canBeReused(e) {
    if (e.intersects(this.missingOpeningBracketIds) || this.childrenLength === 0)
      return !1;
    let t = this;
    for (; t.kind === 4; ) {
      const i = t.childrenLength;
      if (i === 0)
        throw new lt();
      t = t.getChild(i - 1);
    }
    return t.canBeReused(e);
  }
  handleChildrenChanged() {
    this.throwIfImmutable();
    const e = this.childrenLength;
    let t = this.getChild(0).length, i = this.getChild(0).missingOpeningBracketIds;
    for (let n = 1; n < e; n++) {
      const o = this.getChild(n);
      t = _i(t, o.length), i = i.merge(o.missingOpeningBracketIds);
    }
    this._length = t, this._missingOpeningBracketIds = i, this.cachedMinIndentation = -1;
  }
  computeMinIndentation(e, t) {
    if (this.cachedMinIndentation !== -1)
      return this.cachedMinIndentation;
    let i = Number.MAX_SAFE_INTEGER, n = e;
    for (let o = 0; o < this.childrenLength; o++) {
      const r = this.getChild(o);
      r && (i = Math.min(i, r.computeMinIndentation(n, t)), n = _i(n, r.length));
    }
    return this.cachedMinIndentation = i, i;
  }
}
class $A extends Ma {
  get childrenLength() {
    return this._item3 !== null ? 3 : 2;
  }
  getChild(e) {
    switch (e) {
      case 0:
        return this._item1;
      case 1:
        return this._item2;
      case 2:
        return this._item3;
    }
    throw new Error("Invalid child index");
  }
  setChild(e, t) {
    switch (e) {
      case 0:
        this._item1 = t;
        return;
      case 1:
        this._item2 = t;
        return;
      case 2:
        this._item3 = t;
        return;
    }
    throw new Error("Invalid child index");
  }
  get children() {
    return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];
  }
  get item1() {
    return this._item1;
  }
  get item2() {
    return this._item2;
  }
  get item3() {
    return this._item3;
  }
  constructor(e, t, i, n, o, r) {
    super(e, t, r), this._item1 = i, this._item2 = n, this._item3 = o;
  }
  deepClone() {
    return new $A(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot append to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = e, this.handleChildrenChanged();
  }
  unappendChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item3;
    return this._item3 = null, this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    if (this._item3)
      throw new Error("Cannot prepend to a full (2,3) tree node");
    this.throwIfImmutable(), this._item3 = this._item2, this._item2 = this._item1, this._item1 = e, this.handleChildrenChanged();
  }
  unprependChild() {
    if (!this._item3)
      throw new Error("Cannot remove from a non-full (2,3) tree node");
    this.throwIfImmutable();
    const e = this._item1;
    return this._item1 = this._item2, this._item2 = this._item3, this._item3 = null, this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class sZ extends $A {
  toMutable() {
    return new $A(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
class GC extends Ma {
  get childrenLength() {
    return this._children.length;
  }
  getChild(e) {
    return this._children[e];
  }
  setChild(e, t) {
    this._children[e] = t;
  }
  get children() {
    return this._children;
  }
  constructor(e, t, i, n) {
    super(e, t, n), this._children = i;
  }
  deepClone() {
    const e = new Array(this._children.length);
    for (let t = 0; t < this._children.length; t++)
      e[t] = this._children[t].deepClone();
    return new GC(this.length, this.listHeight, e, this.missingOpeningBracketIds);
  }
  appendChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.push(e), this.handleChildrenChanged();
  }
  unappendChild() {
    this.throwIfImmutable();
    const e = this._children.pop();
    return this.handleChildrenChanged(), e;
  }
  prependChildOfSameHeight(e) {
    this.throwIfImmutable(), this._children.unshift(e), this.handleChildrenChanged();
  }
  unprependChild() {
    this.throwIfImmutable();
    const e = this._children.shift();
    return this.handleChildrenChanged(), e;
  }
  toMutable() {
    return this;
  }
}
class oZ extends GC {
  toMutable() {
    return new GC(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);
  }
  throwIfImmutable() {
    throw new Error("this instance is immutable");
  }
}
const rZ = [];
class $N extends qN {
  get listHeight() {
    return 0;
  }
  get childrenLength() {
    return 0;
  }
  getChild(e) {
    return null;
  }
  get children() {
    return rZ;
  }
  deepClone() {
    return this;
  }
}
class ih extends $N {
  get kind() {
    return 0;
  }
  get missingOpeningBracketIds() {
    return As.getEmpty();
  }
  canBeReused(e) {
    return !0;
  }
  computeMinIndentation(e, t) {
    const i = Co(e), n = (i.columnCount === 0 ? i.lineCount : i.lineCount + 1) + 1, o = ZX(_i(e, this.length)) + 1;
    let r = Number.MAX_SAFE_INTEGER;
    for (let a = n; a <= o; a++) {
      const l = t.getLineFirstNonWhitespaceColumn(a), c = t.getLineContent(a);
      if (l === 0)
        continue;
      const d = wi.visibleColumnFromColumn(c, l, t.getOptions().tabSize);
      r = Math.min(r, d);
    }
    return r;
  }
}
class jC extends $N {
  static create(e, t, i) {
    return new jC(e, t, i);
  }
  get kind() {
    return 1;
  }
  get missingOpeningBracketIds() {
    return As.getEmpty();
  }
  constructor(e, t, i) {
    super(e), this.bracketInfo = t, this.bracketIds = i;
  }
  get text() {
    return this.bracketInfo.bracketText;
  }
  get languageId() {
    return this.bracketInfo.languageId;
  }
  canBeReused(e) {
    return !1;
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
class aZ extends $N {
  get kind() {
    return 3;
  }
  constructor(e, t) {
    super(t), this.missingOpeningBracketIds = e;
  }
  canBeReused(e) {
    return !e.intersects(this.missingOpeningBracketIds);
  }
  computeMinIndentation(e, t) {
    return Number.MAX_SAFE_INTEGER;
  }
}
let bc = class {
  constructor(e, t, i, n, o) {
    this.length = e, this.kind = t, this.bracketId = i, this.bracketIds = n, this.astNode = o;
  }
};
class lZ {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.reader = new cZ(this.textModel, this.bracketTokens), this._offset = Xn, this.didPeek = !1, this.peeked = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  get offset() {
    return this._offset;
  }
  get length() {
    return li(this.textBufferLineCount - 1, this.textBufferLastLineLength);
  }
  skip(e) {
    this.didPeek = !1, this._offset = _i(this._offset, e);
    const t = Co(this._offset);
    this.reader.setPosition(t.lineCount, t.columnCount);
  }
  read() {
    let e;
    return this.peeked ? (this.didPeek = !1, e = this.peeked) : e = this.reader.read(), e && (this._offset = _i(this._offset, e.length)), e;
  }
  peek() {
    return this.didPeek || (this.peeked = this.reader.read(), this.didPeek = !0), this.peeked;
  }
}
class cZ {
  constructor(e, t) {
    this.textModel = e, this.bracketTokens = t, this.lineIdx = 0, this.line = null, this.lineCharOffset = 0, this.lineTokens = null, this.lineTokenOffset = 0, this.peekedToken = null, this.textBufferLineCount = e.getLineCount(), this.textBufferLastLineLength = e.getLineLength(this.textBufferLineCount);
  }
  setPosition(e, t) {
    e === this.lineIdx ? (this.lineCharOffset = t, this.line !== null && (this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset))) : (this.lineIdx = e, this.lineCharOffset = t, this.line = null), this.peekedToken = null;
  }
  read() {
    if (this.peekedToken) {
      const o = this.peekedToken;
      return this.peekedToken = null, this.lineCharOffset += o.length, o;
    }
    if (this.lineIdx > this.textBufferLineCount - 1 || this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)
      return null;
    this.line === null && (this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.line = this.lineTokens.getLineContent(), this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset));
    const e = this.lineIdx, t = this.lineCharOffset;
    let i = 0;
    for (; ; ) {
      const o = this.lineTokens, r = o.getCount();
      let a = null;
      if (this.lineTokenOffset < r) {
        const l = o.getMetadata(this.lineTokenOffset);
        for (; this.lineTokenOffset + 1 < r && l === o.getMetadata(this.lineTokenOffset + 1); )
          this.lineTokenOffset++;
        const c = xr.getTokenType(l) === 0, d = xr.containsBalancedBrackets(l), h = o.getEndOffset(this.lineTokenOffset);
        if (d && c && this.lineCharOffset < h) {
          const u = o.getLanguageId(this.lineTokenOffset), g = this.line.substring(this.lineCharOffset, h), m = this.bracketTokens.getSingleLanguageBracketTokens(u), p = m.regExpGlobal;
          if (p) {
            p.lastIndex = 0;
            const A = p.exec(g);
            A && (a = m.getToken(A[0]), a && (this.lineCharOffset += A.index));
          }
        }
        if (i += h - this.lineCharOffset, a)
          if (e !== this.lineIdx || t !== this.lineCharOffset) {
            this.peekedToken = a;
            break;
          } else
            return this.lineCharOffset += a.length, a;
        else
          this.lineTokenOffset++, this.lineCharOffset = h;
      } else if (this.lineIdx === this.textBufferLineCount - 1 || (this.lineIdx++, this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1), this.lineTokenOffset = 0, this.line = this.lineTokens.getLineContent(), this.lineCharOffset = 0, i += 33, i > 1e3))
        break;
      if (i > 1500)
        break;
    }
    const n = XX(e, t, this.lineIdx, this.lineCharOffset);
    return new bc(n, 0, -1, As.getEmpty(), new ih(n));
  }
}
class dZ {
  constructor(e, t) {
    this.text = e, this._offset = Xn, this.idx = 0;
    const i = t.getRegExpStr(), n = i ? new RegExp(i + `|
`, "gi") : null, o = [];
    let r, a = 0, l = 0, c = 0, d = 0;
    const h = [];
    for (let m = 0; m < 60; m++)
      h.push(new bc(li(0, m), 0, -1, As.getEmpty(), new ih(li(0, m))));
    const u = [];
    for (let m = 0; m < 60; m++)
      u.push(new bc(li(1, m), 0, -1, As.getEmpty(), new ih(li(1, m))));
    if (n)
      for (n.lastIndex = 0; (r = n.exec(e)) !== null; ) {
        const m = r.index, p = r[0];
        if (p === `
`)
          a++, l = m + 1;
        else {
          if (c !== m) {
            let A;
            if (d === a) {
              const _ = m - c;
              if (_ < h.length)
                A = h[_];
              else {
                const b = li(0, _);
                A = new bc(b, 0, -1, As.getEmpty(), new ih(b));
              }
            } else {
              const _ = a - d, b = m - l;
              if (_ === 1 && b < u.length)
                A = u[b];
              else {
                const C = li(_, b);
                A = new bc(C, 0, -1, As.getEmpty(), new ih(C));
              }
            }
            o.push(A);
          }
          o.push(t.getToken(p)), c = m + p.length, d = a;
        }
      }
    const g = e.length;
    if (c !== g) {
      const m = d === a ? li(0, g - c) : li(a - d, g - l);
      o.push(new bc(m, 0, -1, As.getEmpty(), new ih(m)));
    }
    this.length = li(a, g - l), this.tokens = o;
  }
  get offset() {
    return this._offset;
  }
  read() {
    return this.tokens[this.idx++] || null;
  }
  peek() {
    return this.tokens[this.idx] || null;
  }
  skip(e) {
    throw new Pz();
  }
}
class XN {
  static createFromLanguage(e, t) {
    function i(o) {
      return t.getKey(`${o.languageId}:::${o.bracketText}`);
    }
    const n = /* @__PURE__ */ new Map();
    for (const o of e.bracketsNew.openingBrackets) {
      const r = li(0, o.bracketText.length), a = i(o), l = As.getEmpty().add(a, vF);
      n.set(o.bracketText, new bc(r, 1, a, l, jC.create(r, o, l)));
    }
    for (const o of e.bracketsNew.closingBrackets) {
      const r = li(0, o.bracketText.length);
      let a = As.getEmpty();
      const l = o.getOpeningBrackets();
      for (const c of l)
        a = a.add(i(c), vF);
      n.set(o.bracketText, new bc(r, 2, i(l[0]), a, jC.create(r, o, a)));
    }
    return new XN(n);
  }
  constructor(e) {
    this.map = e, this.hasRegExp = !1, this._regExpGlobal = null;
  }
  getRegExpStr() {
    if (this.isEmpty)
      return null;
    {
      const e = [...this.map.keys()];
      return e.sort(), e.reverse(), e.map((t) => hZ(t)).join("|");
    }
  }
  /**
   * Returns null if there is no such regexp (because there are no brackets).
  */
  get regExpGlobal() {
    if (!this.hasRegExp) {
      const e = this.getRegExpStr();
      this._regExpGlobal = e ? new RegExp(e, "gi") : null, this.hasRegExp = !0;
    }
    return this._regExpGlobal;
  }
  getToken(e) {
    return this.map.get(e.toLowerCase());
  }
  findClosingTokenText(e) {
    for (const [t, i] of this.map)
      if (i.kind === 2 && i.bracketIds.intersects(e))
        return t;
  }
  get isEmpty() {
    return this.map.size === 0;
  }
}
function hZ(s) {
  let e = So(s);
  return /^[\w ]+/.test(s) && (e = `\\b${e}`), /[\w ]+$/.test(s) && (e = `${e}\\b`), e;
}
class uZ {
  constructor(e, t) {
    this.denseKeyProvider = e, this.getLanguageConfiguration = t, this.languageIdToBracketTokens = /* @__PURE__ */ new Map();
  }
  didLanguageChange(e) {
    return this.languageIdToBracketTokens.has(e);
  }
  getSingleLanguageBracketTokens(e) {
    let t = this.languageIdToBracketTokens.get(e);
    return t || (t = XN.createFromLanguage(this.getLanguageConfiguration(e), this.denseKeyProvider), this.languageIdToBracketTokens.set(e, t)), t;
  }
}
function gZ(s) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let e = 0;
  function t() {
    if (e >= s.length)
      return null;
    const r = e, a = s[r].listHeight;
    for (e++; e < s.length && s[e].listHeight === a; )
      e++;
    return e - r >= 2 ? lW(r === 0 && e === s.length ? s : s.slice(r, e), !1) : s[r];
  }
  let i = t(), n = t();
  if (!n)
    return i;
  for (let r = t(); r; r = t())
    SF(i, n) <= SF(n, r) ? (i = Ty(i, n), n = r) : n = Ty(n, r);
  return Ty(i, n);
}
function lW(s, e = !1) {
  if (s.length === 0)
    return null;
  if (s.length === 1)
    return s[0];
  let t = s.length;
  for (; t > 3; ) {
    const i = t >> 1;
    for (let n = 0; n < i; n++) {
      const o = n << 1;
      s[n] = Ma.create23(s[o], s[o + 1], o + 3 === t ? s[o + 2] : null, e);
    }
    t = i;
  }
  return Ma.create23(s[0], s[1], t >= 3 ? s[2] : null, e);
}
function SF(s, e) {
  return Math.abs(s.listHeight - e.listHeight);
}
function Ty(s, e) {
  return s.listHeight === e.listHeight ? Ma.create23(s, e, null, !1) : s.listHeight > e.listHeight ? fZ(s, e) : mZ(e, s);
}
function fZ(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  let n;
  for (; ; ) {
    if (e.listHeight === t.listHeight) {
      n = e;
      break;
    }
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeLastElementMutable();
  }
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = Ma.create23(r.unappendChild(), n, null, !1) : (r.appendChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? Ma.create23(s, n, null, !1) : s;
}
function mZ(s, e) {
  s = s.toMutable();
  let t = s;
  const i = [];
  for (; e.listHeight !== t.listHeight; ) {
    if (t.kind !== 4)
      throw new Error("unexpected");
    i.push(t), t = t.makeFirstElementMutable();
  }
  let n = e;
  for (let o = i.length - 1; o >= 0; o--) {
    const r = i[o];
    n ? r.childrenLength >= 3 ? n = Ma.create23(n, r.unprependChild(), null, !1) : (r.prependChildOfSameHeight(n), n = void 0) : r.handleChildrenChanged();
  }
  return n ? Ma.create23(n, s, null, !1) : s;
}
class pZ {
  constructor(e) {
    this.lastOffset = Xn, this.nextNodes = [e], this.offsets = [Xn], this.idxs = [];
  }
  /**
   * Returns the longest node at `offset` that satisfies the predicate.
   * @param offset must be greater than or equal to the last offset this method has been called with!
  */
  readLongestNodeAt(e, t) {
    if (Sf(e, this.lastOffset))
      throw new Error("Invalid offset");
    for (this.lastOffset = e; ; ) {
      const i = Xm(this.nextNodes);
      if (!i)
        return;
      const n = Xm(this.offsets);
      if (Sf(e, n))
        return;
      if (Sf(n, e))
        if (_i(n, i.length) <= e)
          this.nextNodeAfterCurrent();
        else {
          const o = By(i);
          o !== -1 ? (this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o)) : this.nextNodeAfterCurrent();
        }
      else {
        if (t(i))
          return this.nextNodeAfterCurrent(), i;
        {
          const o = By(i);
          if (o === -1) {
            this.nextNodeAfterCurrent();
            return;
          } else
            this.nextNodes.push(i.getChild(o)), this.offsets.push(n), this.idxs.push(o);
        }
      }
    }
  }
  // Navigates to the longest node that continues after the current node.
  nextNodeAfterCurrent() {
    for (; ; ) {
      const e = Xm(this.offsets), t = Xm(this.nextNodes);
      if (this.nextNodes.pop(), this.offsets.pop(), this.idxs.length === 0)
        break;
      const i = Xm(this.nextNodes), n = By(i, this.idxs[this.idxs.length - 1]);
      if (n !== -1) {
        this.nextNodes.push(i.getChild(n)), this.offsets.push(_i(e, t.length)), this.idxs[this.idxs.length - 1] = n;
        break;
      } else
        this.idxs.pop();
    }
  }
}
function By(s, e = -1) {
  for (; ; ) {
    if (e++, e >= s.childrenLength)
      return -1;
    if (s.getChild(e))
      return e;
  }
}
function Xm(s) {
  return s.length > 0 ? s[s.length - 1] : void 0;
}
function yF(s, e, t, i) {
  return new AZ(s, e, t, i).parseDocument();
}
class AZ {
  constructor(e, t, i, n) {
    if (this.tokenizer = e, this.createImmutableLists = n, this._itemsConstructed = 0, this._itemsFromCache = 0, i && n)
      throw new Error("Not supported");
    this.oldNodeReader = i ? new pZ(i) : void 0, this.positionMapper = new iZ(t);
  }
  parseDocument() {
    this._itemsConstructed = 0, this._itemsFromCache = 0;
    let e = this.parseList(As.getEmpty(), 0);
    return e || (e = Ma.getEmpty()), e;
  }
  parseList(e, t) {
    const i = [];
    for (; ; ) {
      let o = this.tryReadChildFromCache(e);
      if (!o) {
        const r = this.tokenizer.peek();
        if (!r || r.kind === 2 && r.bracketIds.intersects(e))
          break;
        o = this.parseChild(e, t + 1);
      }
      o.kind === 4 && o.childrenLength === 0 || i.push(o);
    }
    return this.oldNodeReader ? gZ(i) : lW(i, this.createImmutableLists);
  }
  tryReadChildFromCache(e) {
    if (this.oldNodeReader) {
      const t = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);
      if (t === null || !QC(t)) {
        const i = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), (n) => t !== null && !Sf(n.length, t) ? !1 : n.canBeReused(e));
        if (i)
          return this._itemsFromCache++, this.tokenizer.skip(i.length), i;
      }
    }
  }
  parseChild(e, t) {
    this._itemsConstructed++;
    const i = this.tokenizer.read();
    switch (i.kind) {
      case 2:
        return new aZ(i.bracketIds, i.length);
      case 0:
        return i.astNode;
      case 1: {
        if (t > 300)
          return new ih(i.length);
        const n = e.merge(i.bracketIds), o = this.parseList(n, t + 1), r = this.tokenizer.peek();
        return r && r.kind === 2 && (r.bracketId === i.bracketId || r.bracketIds.intersects(i.bracketIds)) ? (this.tokenizer.read(), qA.create(i.astNode, o, r.astNode)) : qA.create(i.astNode, o, null);
      }
      default:
        throw new Error("unexpected");
    }
  }
}
function YC(s, e) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const t = new Pl(xF(s)), i = xF(e);
  i.push({ modified: !1, lengthBefore: void 0, lengthAfter: void 0 });
  let n = t.dequeue();
  function o(c) {
    if (c === void 0) {
      const h = t.takeWhile((u) => !0) || [];
      return n && h.unshift(n), h;
    }
    const d = [];
    for (; n && !QC(c); ) {
      const [h, u] = n.splitAt(c);
      d.push(h), c = JA(h.lengthAfter, c), n = u ?? t.dequeue();
    }
    return QC(c) || d.push(new Mc(!1, c, c)), d;
  }
  const r = [];
  function a(c, d, h) {
    if (r.length > 0 && aW(r[r.length - 1].endOffset, c)) {
      const u = r[r.length - 1];
      r[r.length - 1] = new vl(u.startOffset, d, _i(u.newLength, h));
    } else
      r.push({ startOffset: c, endOffset: d, newLength: h });
  }
  let l = Xn;
  for (const c of i) {
    const d = o(c.lengthBefore);
    if (c.modified) {
      const h = eZ(d, (g) => g.lengthBefore), u = _i(l, h);
      a(l, u, c.lengthAfter), l = u;
    } else
      for (const h of d) {
        const u = l;
        l = _i(l, h.lengthBefore), h.modified && a(u, l, h.lengthAfter);
      }
  }
  return r;
}
class Mc {
  constructor(e, t, i) {
    this.modified = e, this.lengthBefore = t, this.lengthAfter = i;
  }
  splitAt(e) {
    const t = JA(e, this.lengthAfter);
    return aW(t, Xn) ? [this, void 0] : this.modified ? [
      new Mc(this.modified, this.lengthBefore, e),
      new Mc(this.modified, Xn, t)
    ] : [
      new Mc(this.modified, e, e),
      new Mc(this.modified, t, t)
    ];
  }
  toString() {
    return `${this.modified ? "M" : "U"}:${Co(this.lengthBefore)} -> ${Co(this.lengthAfter)}`;
  }
}
function xF(s) {
  const e = [];
  let t = Xn;
  for (const i of s) {
    const n = JA(t, i.startOffset);
    QC(n) || e.push(new Mc(!1, n, n));
    const o = JA(i.startOffset, i.endOffset);
    e.push(new Mc(!0, o, i.newLength)), t = i.endOffset;
  }
  return e;
}
class _Z extends V {
  didLanguageChange(e) {
    return this.brackets.didLanguageChange(e);
  }
  constructor(e, t) {
    if (super(), this.textModel = e, this.getLanguageConfiguration = t, this.didChangeEmitter = new B(), this.denseKeyProvider = new nZ(), this.brackets = new uZ(this.denseKeyProvider, this.getLanguageConfiguration), this.onDidChange = this.didChangeEmitter.event, this.queuedTextEditsForInitialAstWithoutTokens = [], this.queuedTextEdits = [], e.tokenization.hasTokens)
      e.tokenization.backgroundTokenizationState === 2 ? (this.initialAstWithoutTokens = void 0, this.astWithTokens = this.parseDocumentFromTextBuffer([], void 0, !1)) : (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens);
    else {
      const i = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId()), n = new dZ(this.textModel.getValue(), i);
      this.initialAstWithoutTokens = yF(n, [], void 0, !0), this.astWithTokens = this.initialAstWithoutTokens;
    }
  }
  //#region TextModel events
  handleDidChangeBackgroundTokenizationState() {
    if (this.textModel.tokenization.backgroundTokenizationState === 2) {
      const e = this.initialAstWithoutTokens === void 0;
      this.initialAstWithoutTokens = void 0, e || this.didChangeEmitter.fire();
    }
  }
  handleDidChangeTokens({ ranges: e }) {
    const t = e.map((i) => new vl(li(i.fromLineNumber - 1, 0), li(i.toLineNumber, 0), li(i.toLineNumber - i.fromLineNumber + 1, 0)));
    this.handleEdits(t, !0), this.initialAstWithoutTokens || this.didChangeEmitter.fire();
  }
  handleContentChanged(e) {
    const t = vl.fromModelContentChanges(e.changes);
    this.handleEdits(t, !1);
  }
  handleEdits(e, t) {
    const i = YC(this.queuedTextEdits, e);
    this.queuedTextEdits = i, this.initialAstWithoutTokens && !t && (this.queuedTextEditsForInitialAstWithoutTokens = YC(this.queuedTextEditsForInitialAstWithoutTokens, e));
  }
  //#endregion
  flushQueue() {
    this.queuedTextEdits.length > 0 && (this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, !1), this.queuedTextEdits = []), this.queuedTextEditsForInitialAstWithoutTokens.length > 0 && (this.initialAstWithoutTokens && (this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, !1)), this.queuedTextEditsForInitialAstWithoutTokens = []);
  }
  /**
   * @pure (only if isPure = true)
  */
  parseDocumentFromTextBuffer(e, t, i) {
    const n = t, o = new lZ(this.textModel, this.brackets);
    return yF(o, e, n, i);
  }
  getBracketsInRange(e, t) {
    this.flushQueue();
    const i = li(e.startLineNumber - 1, e.startColumn - 1), n = li(e.endLineNumber - 1, e.endColumn - 1);
    return new Eh((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens;
      fk(r, Xn, r.length, i, n, o, 0, 0, /* @__PURE__ */ new Map(), t);
    });
  }
  getBracketPairsInRange(e, t) {
    this.flushQueue();
    const i = Vg(e.getStartPosition()), n = Vg(e.getEndPosition());
    return new Eh((o) => {
      const r = this.initialAstWithoutTokens || this.astWithTokens, a = new bZ(o, t, this.textModel);
      mk(r, Xn, r.length, i, n, a, 0, /* @__PURE__ */ new Map());
    });
  }
  getFirstBracketAfter(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return dW(t, Xn, t.length, Vg(e));
  }
  getFirstBracketBefore(e) {
    this.flushQueue();
    const t = this.initialAstWithoutTokens || this.astWithTokens;
    return cW(t, Xn, t.length, Vg(e));
  }
}
function cW(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    const n = [];
    for (const o of s.children)
      t = _i(e, o.length), n.push({ nodeOffsetStart: e, nodeOffsetEnd: t }), e = t;
    for (let o = n.length - 1; o >= 0; o--) {
      const { nodeOffsetStart: r, nodeOffsetEnd: a } = n[o];
      if (Sf(r, i)) {
        const l = cW(s.children[o], r, a, i);
        if (l)
          return l;
      }
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = Ih(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function dW(s, e, t, i) {
  if (s.kind === 4 || s.kind === 2) {
    for (const n of s.children) {
      if (t = _i(e, n.length), Sf(i, t)) {
        const o = dW(n, e, t, i);
        if (o)
          return o;
      }
      e = t;
    }
    return null;
  } else {
    if (s.kind === 3)
      return null;
    if (s.kind === 1) {
      const n = Ih(e, t);
      return {
        bracketInfo: s.bracketInfo,
        range: n
      };
    }
  }
  return null;
}
function fk(s, e, t, i, n, o, r, a, l, c, d = !1) {
  if (r > 200)
    return !0;
  e: for (; ; )
    switch (s.kind) {
      case 4: {
        const h = s.childrenLength;
        for (let u = 0; u < h; u++) {
          const g = s.getChild(u);
          if (g) {
            if (t = _i(e, g.length), yf(e, n) && Ap(t, i)) {
              if (Ap(t, n)) {
                s = g;
                continue e;
              }
              if (!fk(g, e, t, i, n, o, r, 0, l, c))
                return !1;
            }
            e = t;
          }
        }
        return !0;
      }
      case 2: {
        const h = !c || !s.closingBracket || s.closingBracket.bracketInfo.closesColorized(s.openingBracket.bracketInfo);
        let u = 0;
        if (l) {
          let m = l.get(s.openingBracket.text);
          m === void 0 && (m = 0), u = m, h && (m++, l.set(s.openingBracket.text, m));
        }
        const g = s.childrenLength;
        for (let m = 0; m < g; m++) {
          const p = s.getChild(m);
          if (p) {
            if (t = _i(e, p.length), yf(e, n) && Ap(t, i)) {
              if (Ap(t, n) && p.kind !== 1) {
                s = p, h ? (r++, a = u + 1) : a = u;
                continue e;
              }
              if ((h || p.kind !== 1 || !s.closingBracket) && !fk(p, e, t, i, n, o, h ? r + 1 : r, h ? u + 1 : u, l, c, !s.closingBracket))
                return !1;
            }
            e = t;
          }
        }
        return l?.set(s.openingBracket.text, u), !0;
      }
      case 3: {
        const h = Ih(e, t);
        return o(new CF(h, r - 1, 0, !0));
      }
      case 1: {
        const h = Ih(e, t);
        return o(new CF(h, r - 1, a - 1, d));
      }
      case 0:
        return !0;
    }
}
class bZ {
  constructor(e, t, i) {
    this.push = e, this.includeMinIndentation = t, this.textModel = i;
  }
}
function mk(s, e, t, i, n, o, r, a) {
  if (r > 200)
    return !0;
  let l = !0;
  if (s.kind === 2) {
    let c = 0;
    if (a) {
      let u = a.get(s.openingBracket.text);
      u === void 0 && (u = 0), c = u, u++, a.set(s.openingBracket.text, u);
    }
    const d = _i(e, s.openingBracket.length);
    let h = -1;
    if (o.includeMinIndentation && (h = s.computeMinIndentation(e, o.textModel)), l = o.push(new $X(Ih(e, t), Ih(e, d), s.closingBracket ? Ih(_i(d, s.child?.length || Xn), t) : void 0, r, c, s, h)), e = d, l && s.child) {
      const u = s.child;
      if (t = _i(e, u.length), yf(e, n) && Ap(t, i) && (l = mk(u, e, t, i, n, o, r + 1, a), !l))
        return !1;
    }
    a?.set(s.openingBracket.text, c);
  } else {
    let c = e;
    for (const d of s.children) {
      const h = c;
      if (c = _i(c, d.length), yf(h, n) && yf(i, c) && (l = mk(d, h, c, i, n, o, r, a), !l))
        return !1;
    }
  }
  return l;
}
class wZ extends V {
  get canBuildAST() {
    return this.textModel.getValueLength() <= 5e6;
  }
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t, this.bracketPairsTree = this._register(new On()), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.bracketsRequested = !1;
  }
  //#region TextModel events
  handleLanguageConfigurationServiceChange(e) {
    (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) && (this.bracketPairsTree.clear(), this.updateBracketPairsTree());
  }
  handleDidChangeOptions(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeLanguage(e) {
    this.bracketPairsTree.clear(), this.updateBracketPairsTree();
  }
  handleDidChangeContent(e) {
    this.bracketPairsTree.value?.object.handleContentChanged(e);
  }
  handleDidChangeBackgroundTokenizationState() {
    this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();
  }
  handleDidChangeTokens(e) {
    this.bracketPairsTree.value?.object.handleDidChangeTokens(e);
  }
  //#endregion
  updateBracketPairsTree() {
    if (this.bracketsRequested && this.canBuildAST) {
      if (!this.bracketPairsTree.value) {
        const e = new X();
        this.bracketPairsTree.value = CZ(e.add(new _Z(this.textModel, (t) => this.languageConfigurationService.getLanguageConfiguration(t))), e), e.add(this.bracketPairsTree.value.object.onDidChange((t) => this.onDidChangeEmitter.fire(t))), this.onDidChangeEmitter.fire();
      }
    } else
      this.bracketPairsTree.value && (this.bracketPairsTree.clear(), this.onDidChangeEmitter.fire());
  }
  /**
   * Returns all bracket pairs that intersect the given range.
   * The result is sorted by the start position.
  */
  getBracketPairsInRange(e) {
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), this.bracketPairsTree.value?.object.getBracketPairsInRange(e, !1) || Eh.empty;
  }
  getBracketPairsInRangeWithMinIndentation(e) {
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), this.bracketPairsTree.value?.object.getBracketPairsInRange(e, !0) || Eh.empty;
  }
  getBracketsInRange(e, t = !1) {
    return this.bracketsRequested = !0, this.updateBracketPairsTree(), this.bracketPairsTree.value?.object.getBracketsInRange(e, t) || Eh.empty;
  }
  findMatchingBracketUp(e, t, i) {
    const n = this.textModel.validatePosition(t), o = this.textModel.getLanguageIdAtPosition(n.lineNumber, n.column);
    if (this.canBuildAST) {
      const r = this.languageConfigurationService.getLanguageConfiguration(o).bracketsNew.getClosingBracketInfo(e);
      if (!r)
        return null;
      const a = this.getBracketPairsInRange(E.fromPositions(t, t)).findLast((l) => r.closes(l.openingBracketInfo));
      return a ? a.openingBracketRange : null;
    } else {
      const r = e.toLowerCase(), a = this.languageConfigurationService.getLanguageConfiguration(o).brackets;
      if (!a)
        return null;
      const l = a.textIsBracket[r];
      return l ? Mb(this._findMatchingBracketUp(l, n, Ry(i))) : null;
    }
  }
  matchBracket(e, t) {
    if (this.canBuildAST) {
      const i = this.getBracketPairsInRange(E.fromPositions(e, e)).filter((n) => n.closingBracketRange !== void 0 && (n.openingBracketRange.containsPosition(e) || n.closingBracketRange.containsPosition(e))).findLastMaxBy(_o((n) => n.openingBracketRange.containsPosition(e) ? n.openingBracketRange : n.closingBracketRange, E.compareRangesUsingStarts));
      return i ? [i.openingBracketRange, i.closingBracketRange] : null;
    } else {
      const i = Ry(t);
      return this._matchBracket(this.textModel.validatePosition(e), i);
    }
  }
  _establishBracketSearchOffsets(e, t, i, n) {
    const o = t.getCount(), r = t.getLanguageId(n);
    let a = Math.max(0, e.column - 1 - i.maxBracketLength);
    for (let c = n - 1; c >= 0; c--) {
      const d = t.getEndOffset(c);
      if (d <= a)
        break;
      if ($r(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        a = d;
        break;
      }
    }
    let l = Math.min(t.getLineContent().length, e.column - 1 + i.maxBracketLength);
    for (let c = n + 1; c < o; c++) {
      const d = t.getStartOffset(c);
      if (d >= l)
        break;
      if ($r(t.getStandardTokenType(c)) || t.getLanguageId(c) !== r) {
        l = d;
        break;
      }
    }
    return { searchStartOffset: a, searchEndOffset: l };
  }
  _matchBracket(e, t) {
    const i = e.lineNumber, n = this.textModel.tokenization.getLineTokens(i), o = this.textModel.getLineContent(i), r = n.findTokenIndexAtOffset(e.column - 1);
    if (r < 0)
      return null;
    const a = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(r)).brackets;
    if (a && !$r(n.getStandardTokenType(r))) {
      let { searchStartOffset: l, searchEndOffset: c } = this._establishBracketSearchOffsets(e, n, a, r), d = null;
      for (; ; ) {
        const h = To.findNextBracketInRange(a.forwardRegex, i, o, l, c);
        if (!h)
          break;
        if (h.startColumn <= e.column && e.column <= h.endColumn) {
          const u = o.substring(h.startColumn - 1, h.endColumn - 1).toLowerCase(), g = this._matchFoundBracket(h, a.textIsBracket[u], a.textIsOpenBracket[u], t);
          if (g) {
            if (g instanceof dl)
              return null;
            d = g;
          }
        }
        l = h.endColumn - 1;
      }
      if (d)
        return d;
    }
    if (r > 0 && n.getStartOffset(r) === e.column - 1) {
      const l = r - 1, c = this.languageConfigurationService.getLanguageConfiguration(n.getLanguageId(l)).brackets;
      if (c && !$r(n.getStandardTokenType(l))) {
        const { searchStartOffset: d, searchEndOffset: h } = this._establishBracketSearchOffsets(e, n, c, l), u = To.findPrevBracketInRange(c.reversedRegex, i, o, d, h);
        if (u && u.startColumn <= e.column && e.column <= u.endColumn) {
          const g = o.substring(u.startColumn - 1, u.endColumn - 1).toLowerCase(), m = this._matchFoundBracket(u, c.textIsBracket[g], c.textIsOpenBracket[g], t);
          if (m)
            return m instanceof dl ? null : m;
        }
      }
    }
    return null;
  }
  _matchFoundBracket(e, t, i, n) {
    if (!t)
      return null;
    const o = i ? this._findMatchingBracketDown(t, e.getEndPosition(), n) : this._findMatchingBracketUp(t, e.getStartPosition(), n);
    return o ? o instanceof dl ? o : [e, o] : null;
  }
  _findMatchingBracketUp(e, t, i) {
    const n = e.languageId, o = e.reversedRegex;
    let r = -1, a = 0;
    const l = (c, d, h, u) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return dl.INSTANCE;
        const g = To.findPrevBracketInRange(o, c, d, h, u);
        if (!g)
          break;
        const m = d.substring(g.startColumn - 1, g.endColumn - 1).toLowerCase();
        if (e.isOpen(m) ? r++ : e.isClose(m) && r--, r === 0)
          return g;
        u = g.startColumn - 1;
      }
      return null;
    };
    for (let c = t.lineNumber; c >= 1; c--) {
      const d = this.textModel.tokenization.getLineTokens(c), h = d.getCount(), u = this.textModel.getLineContent(c);
      let g = h - 1, m = u.length, p = u.length;
      c === t.lineNumber && (g = d.findTokenIndexAtOffset(t.column - 1), m = t.column - 1, p = t.column - 1);
      let A = !0;
      for (; g >= 0; g--) {
        const _ = d.getLanguageId(g) === n && !$r(d.getStandardTokenType(g));
        if (_)
          A ? m = d.getStartOffset(g) : (m = d.getStartOffset(g), p = d.getEndOffset(g));
        else if (A && m !== p) {
          const b = l(c, u, m, p);
          if (b)
            return b;
        }
        A = _;
      }
      if (A && m !== p) {
        const _ = l(c, u, m, p);
        if (_)
          return _;
      }
    }
    return null;
  }
  _findMatchingBracketDown(e, t, i) {
    const n = e.languageId, o = e.forwardRegex;
    let r = 1, a = 0;
    const l = (d, h, u, g) => {
      for (; ; ) {
        if (i && ++a % 100 === 0 && !i())
          return dl.INSTANCE;
        const m = To.findNextBracketInRange(o, d, h, u, g);
        if (!m)
          break;
        const p = h.substring(m.startColumn - 1, m.endColumn - 1).toLowerCase();
        if (e.isOpen(p) ? r++ : e.isClose(p) && r--, r === 0)
          return m;
        u = m.endColumn - 1;
      }
      return null;
    }, c = this.textModel.getLineCount();
    for (let d = t.lineNumber; d <= c; d++) {
      const h = this.textModel.tokenization.getLineTokens(d), u = h.getCount(), g = this.textModel.getLineContent(d);
      let m = 0, p = 0, A = 0;
      d === t.lineNumber && (m = h.findTokenIndexAtOffset(t.column - 1), p = t.column - 1, A = t.column - 1);
      let _ = !0;
      for (; m < u; m++) {
        const b = h.getLanguageId(m) === n && !$r(h.getStandardTokenType(m));
        if (b)
          _ || (p = h.getStartOffset(m)), A = h.getEndOffset(m);
        else if (_ && p !== A) {
          const C = l(d, g, p, A);
          if (C)
            return C;
        }
        _ = b;
      }
      if (_ && p !== A) {
        const b = l(d, g, p, A);
        if (b)
          return b;
      }
    }
    return null;
  }
  findPrevBracket(e) {
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), this.bracketPairsTree.value?.object.getFirstBracketBefore(t) || null;
    let i = null, n = null, o = null;
    for (let r = t.lineNumber; r >= 1; r--) {
      const a = this.textModel.tokenization.getLineTokens(r), l = a.getCount(), c = this.textModel.getLineContent(r);
      let d = l - 1, h = c.length, u = c.length;
      if (r === t.lineNumber) {
        d = a.findTokenIndexAtOffset(t.column - 1), h = t.column - 1, u = t.column - 1;
        const m = a.getLanguageId(d);
        i !== m && (i = m, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew);
      }
      let g = !0;
      for (; d >= 0; d--) {
        const m = a.getLanguageId(d);
        if (i !== m) {
          if (n && o && g && h !== u) {
            const A = To.findPrevBracketInRange(n.reversedRegex, r, c, h, u);
            if (A)
              return this._toFoundBracket(o, A);
            g = !1;
          }
          i = m, n = this.languageConfigurationService.getLanguageConfiguration(i).brackets, o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew;
        }
        const p = !!n && !$r(a.getStandardTokenType(d));
        if (p)
          g ? h = a.getStartOffset(d) : (h = a.getStartOffset(d), u = a.getEndOffset(d));
        else if (o && n && g && h !== u) {
          const A = To.findPrevBracketInRange(n.reversedRegex, r, c, h, u);
          if (A)
            return this._toFoundBracket(o, A);
        }
        g = p;
      }
      if (o && n && g && h !== u) {
        const m = To.findPrevBracketInRange(n.reversedRegex, r, c, h, u);
        if (m)
          return this._toFoundBracket(o, m);
      }
    }
    return null;
  }
  findNextBracket(e) {
    const t = this.textModel.validatePosition(e);
    if (this.canBuildAST)
      return this.bracketsRequested = !0, this.updateBracketPairsTree(), this.bracketPairsTree.value?.object.getFirstBracketAfter(t) || null;
    const i = this.textModel.getLineCount();
    let n = null, o = null, r = null;
    for (let a = t.lineNumber; a <= i; a++) {
      const l = this.textModel.tokenization.getLineTokens(a), c = l.getCount(), d = this.textModel.getLineContent(a);
      let h = 0, u = 0, g = 0;
      if (a === t.lineNumber) {
        h = l.findTokenIndexAtOffset(t.column - 1), u = t.column - 1, g = t.column - 1;
        const p = l.getLanguageId(h);
        n !== p && (n = p, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew);
      }
      let m = !0;
      for (; h < c; h++) {
        const p = l.getLanguageId(h);
        if (n !== p) {
          if (r && o && m && u !== g) {
            const _ = To.findNextBracketInRange(o.forwardRegex, a, d, u, g);
            if (_)
              return this._toFoundBracket(r, _);
            m = !1;
          }
          n = p, o = this.languageConfigurationService.getLanguageConfiguration(n).brackets, r = this.languageConfigurationService.getLanguageConfiguration(n).bracketsNew;
        }
        const A = !!o && !$r(l.getStandardTokenType(h));
        if (A)
          m || (u = l.getStartOffset(h)), g = l.getEndOffset(h);
        else if (r && o && m && u !== g) {
          const _ = To.findNextBracketInRange(o.forwardRegex, a, d, u, g);
          if (_)
            return this._toFoundBracket(r, _);
        }
        m = A;
      }
      if (r && o && m && u !== g) {
        const p = To.findNextBracketInRange(o.forwardRegex, a, d, u, g);
        if (p)
          return this._toFoundBracket(r, p);
      }
    }
    return null;
  }
  findEnclosingBrackets(e, t) {
    const i = this.textModel.validatePosition(e);
    if (this.canBuildAST) {
      const g = E.fromPositions(i), m = this.getBracketPairsInRange(E.fromPositions(i, i)).findLast((p) => p.closingBracketRange !== void 0 && p.range.strictContainsRange(g));
      return m ? [m.openingBracketRange, m.closingBracketRange] : null;
    }
    const n = Ry(t), o = this.textModel.getLineCount(), r = /* @__PURE__ */ new Map();
    let a = [];
    const l = (g, m) => {
      if (!r.has(g)) {
        const p = [];
        for (let A = 0, _ = m ? m.brackets.length : 0; A < _; A++)
          p[A] = 0;
        r.set(g, p);
      }
      a = r.get(g);
    };
    let c = 0;
    const d = (g, m, p, A, _) => {
      for (; ; ) {
        if (n && ++c % 100 === 0 && !n())
          return dl.INSTANCE;
        const b = To.findNextBracketInRange(g.forwardRegex, m, p, A, _);
        if (!b)
          break;
        const C = p.substring(b.startColumn - 1, b.endColumn - 1).toLowerCase(), w = g.textIsBracket[C];
        if (w && (w.isOpen(C) ? a[w.index]++ : w.isClose(C) && a[w.index]--, a[w.index] === -1))
          return this._matchFoundBracket(b, w, !1, n);
        A = b.endColumn - 1;
      }
      return null;
    };
    let h = null, u = null;
    for (let g = i.lineNumber; g <= o; g++) {
      const m = this.textModel.tokenization.getLineTokens(g), p = m.getCount(), A = this.textModel.getLineContent(g);
      let _ = 0, b = 0, C = 0;
      if (g === i.lineNumber) {
        _ = m.findTokenIndexAtOffset(i.column - 1), b = i.column - 1, C = i.column - 1;
        const S = m.getLanguageId(_);
        h !== S && (h = S, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u));
      }
      let w = !0;
      for (; _ < p; _++) {
        const S = m.getLanguageId(_);
        if (h !== S) {
          if (u && w && b !== C) {
            const y = d(u, g, A, b, C);
            if (y)
              return Mb(y);
            w = !1;
          }
          h = S, u = this.languageConfigurationService.getLanguageConfiguration(h).brackets, l(h, u);
        }
        const x = !!u && !$r(m.getStandardTokenType(_));
        if (x)
          w || (b = m.getStartOffset(_)), C = m.getEndOffset(_);
        else if (u && w && b !== C) {
          const y = d(u, g, A, b, C);
          if (y)
            return Mb(y);
        }
        w = x;
      }
      if (u && w && b !== C) {
        const S = d(u, g, A, b, C);
        if (S)
          return Mb(S);
      }
    }
    return null;
  }
  _toFoundBracket(e, t) {
    if (!t)
      return null;
    let i = this.textModel.getValueInRange(t);
    i = i.toLowerCase();
    const n = e.getBracketInfo(i);
    return n ? {
      range: t,
      bracketInfo: n
    } : null;
  }
}
function CZ(s, e) {
  return {
    object: s,
    dispose: () => e?.dispose()
  };
}
function Ry(s) {
  if (typeof s > "u")
    return () => !0;
  {
    const e = Date.now();
    return () => Date.now() - e <= s;
  }
}
const D1 = class D1 {
  constructor() {
    this._searchCanceledBrand = void 0;
  }
};
D1.INSTANCE = new D1();
let dl = D1;
function Mb(s) {
  return s instanceof dl ? null : s;
}
class vZ extends V {
  constructor(e) {
    super(), this.textModel = e, this.colorProvider = new hW(), this.onDidChangeEmitter = new B(), this.onDidChange = this.onDidChangeEmitter.event, this.colorizationOptions = e.getOptions().bracketPairColorizationOptions, this._register(e.bracketPairs.onDidChange((t) => {
      this.onDidChangeEmitter.fire();
    }));
  }
  //#region TextModel events
  handleDidChangeOptions(e) {
    this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;
  }
  //#endregion
  getDecorationsInRange(e, t, i, n) {
    return n ? [] : t === void 0 ? [] : this.colorizationOptions.enabled ? this.textModel.bracketPairs.getBracketsInRange(e, !0).map((r) => ({
      id: `bracket${r.range.toString()}-${r.nestingLevel}`,
      options: {
        description: "BracketPairColorization",
        inlineClassName: this.colorProvider.getInlineClassName(r, this.colorizationOptions.independentColorPoolPerBracketType)
      },
      ownerId: 0,
      range: r.range
    })).toArray() : [];
  }
  getAllDecorations(e, t) {
    return e === void 0 ? [] : this.colorizationOptions.enabled ? this.getDecorationsInRange(new E(1, 1, this.textModel.getLineCount(), 1), e, t) : [];
  }
}
class hW {
  constructor() {
    this.unexpectedClosingBracketClassName = "unexpected-closing-bracket";
  }
  getInlineClassName(e, t) {
    return e.isInvalid ? this.unexpectedClosingBracketClassName : this.getInlineClassNameOfLevel(t ? e.nestingLevelOfEqualBracketType : e.nestingLevel);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-highlighting-${e % 30}`;
  }
}
rr((s, e) => {
  const t = [
    eW,
    tW,
    iW,
    nW,
    sW,
    oW
  ], i = new hW();
  e.addRule(`.monaco-editor .${i.unexpectedClosingBracketClassName} { color: ${s.getColor(NX)}; }`);
  const n = t.map((o) => s.getColor(o)).filter((o) => !!o).filter((o) => !o.isTransparent());
  for (let o = 0; o < 30; o++) {
    const r = n[o % n.length];
    e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(o)} { color: ${r}; }`);
  }
});
function Nb(s) {
  return s.replace(/\n/g, "\\n").replace(/\r/g, "\\r");
}
class Xi {
  get oldLength() {
    return this.oldText.length;
  }
  get oldEnd() {
    return this.oldPosition + this.oldText.length;
  }
  get newLength() {
    return this.newText.length;
  }
  get newEnd() {
    return this.newPosition + this.newText.length;
  }
  constructor(e, t, i, n) {
    this.oldPosition = e, this.oldText = t, this.newPosition = i, this.newText = n;
  }
  toString() {
    return this.oldText.length === 0 ? `(insert@${this.oldPosition} "${Nb(this.newText)}")` : this.newText.length === 0 ? `(delete@${this.oldPosition} "${Nb(this.oldText)}")` : `(replace@${this.oldPosition} "${Nb(this.oldText)}" with "${Nb(this.newText)}")`;
  }
  static _writeStringSize(e) {
    return 4 + 2 * e.length;
  }
  static _writeString(e, t, i) {
    const n = t.length;
    Cr(e, n, i), i += 4;
    for (let o = 0; o < n; o++)
      tQ(e, t.charCodeAt(o), i), i += 2;
    return i;
  }
  static _readString(e, t) {
    const i = wr(e, t);
    return t += 4, nQ(e, t, i);
  }
  writeSize() {
    return 8 + Xi._writeStringSize(this.oldText) + Xi._writeStringSize(this.newText);
  }
  write(e, t) {
    return Cr(e, this.oldPosition, t), t += 4, Cr(e, this.newPosition, t), t += 4, t = Xi._writeString(e, this.oldText, t), t = Xi._writeString(e, this.newText, t), t;
  }
  static read(e, t, i) {
    const n = wr(e, t);
    t += 4;
    const o = wr(e, t);
    t += 4;
    const r = Xi._readString(e, t);
    t += Xi._writeStringSize(r);
    const a = Xi._readString(e, t);
    return t += Xi._writeStringSize(a), i.push(new Xi(n, r, o, a)), t;
  }
}
function SZ(s, e) {
  return s === null || s.length === 0 ? e : new ea(s, e).compress();
}
class ea {
  constructor(e, t) {
    this._prevEdits = e, this._currEdits = t, this._result = [], this._resultLen = 0, this._prevLen = this._prevEdits.length, this._prevDeltaOffset = 0, this._currLen = this._currEdits.length, this._currDeltaOffset = 0;
  }
  compress() {
    let e = 0, t = 0, i = this._getPrev(e), n = this._getCurr(t);
    for (; e < this._prevLen || t < this._currLen; ) {
      if (i === null) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (n === null) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldEnd <= i.newPosition) {
        this._acceptCurr(n), n = this._getCurr(++t);
        continue;
      }
      if (i.newEnd <= n.oldPosition) {
        this._acceptPrev(i), i = this._getPrev(++e);
        continue;
      }
      if (n.oldPosition < i.newPosition) {
        const [c, d] = ea._splitCurr(n, i.newPosition - n.oldPosition);
        this._acceptCurr(c), n = d;
        continue;
      }
      if (i.newPosition < n.oldPosition) {
        const [c, d] = ea._splitPrev(i, n.oldPosition - i.newPosition);
        this._acceptPrev(c), i = d;
        continue;
      }
      let a, l;
      if (n.oldEnd === i.newEnd)
        a = i, l = n, i = this._getPrev(++e), n = this._getCurr(++t);
      else if (n.oldEnd < i.newEnd) {
        const [c, d] = ea._splitPrev(i, n.oldLength);
        a = c, l = n, i = d, n = this._getCurr(++t);
      } else {
        const [c, d] = ea._splitCurr(n, i.newLength);
        a = i, l = c, i = this._getPrev(++e), n = d;
      }
      this._result[this._resultLen++] = new Xi(a.oldPosition, a.oldText, l.newPosition, l.newText), this._prevDeltaOffset += a.newLength - a.oldLength, this._currDeltaOffset += l.newLength - l.oldLength;
    }
    const o = ea._merge(this._result);
    return ea._removeNoOps(o);
  }
  _acceptCurr(e) {
    this._result[this._resultLen++] = ea._rebaseCurr(this._prevDeltaOffset, e), this._currDeltaOffset += e.newLength - e.oldLength;
  }
  _getCurr(e) {
    return e < this._currLen ? this._currEdits[e] : null;
  }
  _acceptPrev(e) {
    this._result[this._resultLen++] = ea._rebasePrev(this._currDeltaOffset, e), this._prevDeltaOffset += e.newLength - e.oldLength;
  }
  _getPrev(e) {
    return e < this._prevLen ? this._prevEdits[e] : null;
  }
  static _rebaseCurr(e, t) {
    return new Xi(t.oldPosition - e, t.oldText, t.newPosition, t.newText);
  }
  static _rebasePrev(e, t) {
    return new Xi(t.oldPosition, t.oldText, t.newPosition + e, t.newText);
  }
  static _splitPrev(e, t) {
    const i = e.newText.substr(0, t), n = e.newText.substr(t);
    return [
      new Xi(e.oldPosition, e.oldText, e.newPosition, i),
      new Xi(e.oldEnd, "", e.newPosition + t, n)
    ];
  }
  static _splitCurr(e, t) {
    const i = e.oldText.substr(0, t), n = e.oldText.substr(t);
    return [
      new Xi(e.oldPosition, i, e.newPosition, e.newText),
      new Xi(e.oldPosition + t, n, e.newEnd, "")
    ];
  }
  static _merge(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1; o < e.length; o++) {
      const r = e[o];
      n.oldEnd === r.oldPosition ? n = new Xi(n.oldPosition, n.oldText + r.oldText, n.newPosition, n.newText + r.newText) : (t[i++] = n, n = r);
    }
    return t[i++] = n, t;
  }
  static _removeNoOps(e) {
    if (e.length === 0)
      return e;
    const t = [];
    let i = 0;
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      o.oldText !== o.newText && (t[i++] = o);
    }
    return t;
  }
}
function dg(s) {
  return s.toString();
}
class ki {
  static create(e, t) {
    const i = e.getAlternativeVersionId(), n = pk(e);
    return new ki(i, i, n, n, t, t, []);
  }
  constructor(e, t, i, n, o, r, a) {
    this.beforeVersionId = e, this.afterVersionId = t, this.beforeEOL = i, this.afterEOL = n, this.beforeCursorState = o, this.afterCursorState = r, this.changes = a;
  }
  append(e, t, i, n, o) {
    t.length > 0 && (this.changes = SZ(this.changes, t)), this.afterEOL = i, this.afterVersionId = n, this.afterCursorState = o;
  }
  static _writeSelectionsSize(e) {
    return 4 + 4 * 4 * (e ? e.length : 0);
  }
  static _writeSelections(e, t, i) {
    if (Cr(e, t ? t.length : 0, i), i += 4, t)
      for (const n of t)
        Cr(e, n.selectionStartLineNumber, i), i += 4, Cr(e, n.selectionStartColumn, i), i += 4, Cr(e, n.positionLineNumber, i), i += 4, Cr(e, n.positionColumn, i), i += 4;
    return i;
  }
  static _readSelections(e, t, i) {
    const n = wr(e, t);
    t += 4;
    for (let o = 0; o < n; o++) {
      const r = wr(e, t);
      t += 4;
      const a = wr(e, t);
      t += 4;
      const l = wr(e, t);
      t += 4;
      const c = wr(e, t);
      t += 4, i.push(new Ue(r, a, l, c));
    }
    return t;
  }
  serialize() {
    let e = 10 + ki._writeSelectionsSize(this.beforeCursorState) + ki._writeSelectionsSize(this.afterCursorState) + 4;
    for (const n of this.changes)
      e += n.writeSize();
    const t = new Uint8Array(e);
    let i = 0;
    Cr(t, this.beforeVersionId, i), i += 4, Cr(t, this.afterVersionId, i), i += 4, xR(t, this.beforeEOL, i), i += 1, xR(t, this.afterEOL, i), i += 1, i = ki._writeSelections(t, this.beforeCursorState, i), i = ki._writeSelections(t, this.afterCursorState, i), Cr(t, this.changes.length, i), i += 4;
    for (const n of this.changes)
      i = n.write(t, i);
    return t.buffer;
  }
  static deserialize(e) {
    const t = new Uint8Array(e);
    let i = 0;
    const n = wr(t, i);
    i += 4;
    const o = wr(t, i);
    i += 4;
    const r = yR(t, i);
    i += 1;
    const a = yR(t, i);
    i += 1;
    const l = [];
    i = ki._readSelections(t, i, l);
    const c = [];
    i = ki._readSelections(t, i, c);
    const d = wr(t, i);
    i += 4;
    const h = [];
    for (let u = 0; u < d; u++)
      i = Xi.read(t, i, h);
    return new ki(n, o, r, a, l, c, h);
  }
}
class uW {
  get type() {
    return 0;
  }
  get resource() {
    return _e.isUri(this.model) ? this.model : this.model.uri;
  }
  constructor(e, t, i, n) {
    this.label = e, this.code = t, this.model = i, this._data = ki.create(i, n);
  }
  toString() {
    return (this._data instanceof ki ? this._data : ki.deserialize(this._data)).changes.map((t) => t.toString()).join(", ");
  }
  matchesResource(e) {
    return (_e.isUri(this.model) ? this.model : this.model.uri).toString() === e.toString();
  }
  setModel(e) {
    this.model = e;
  }
  canAppend(e) {
    return this.model === e && this._data instanceof ki;
  }
  append(e, t, i, n, o) {
    this._data instanceof ki && this._data.append(e, t, i, n, o);
  }
  close() {
    this._data instanceof ki && (this._data = this._data.serialize());
  }
  open() {
    this._data instanceof ki || (this._data = ki.deserialize(this._data));
  }
  undo() {
    if (_e.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof ki && (this._data = this._data.serialize());
    const e = ki.deserialize(this._data);
    this.model._applyUndo(e.changes, e.beforeEOL, e.beforeVersionId, e.beforeCursorState);
  }
  redo() {
    if (_e.isUri(this.model))
      throw new Error("Invalid SingleModelEditStackElement");
    this._data instanceof ki && (this._data = this._data.serialize());
    const e = ki.deserialize(this._data);
    this.model._applyRedo(e.changes, e.afterEOL, e.afterVersionId, e.afterCursorState);
  }
  heapSize() {
    return this._data instanceof ki && (this._data = this._data.serialize()), this._data.byteLength + 168;
  }
}
class yZ {
  get resources() {
    return this._editStackElementsArr.map((e) => e.resource);
  }
  constructor(e, t, i) {
    this.label = e, this.code = t, this.type = 1, this._isOpen = !0, this._editStackElementsArr = i.slice(0), this._editStackElementsMap = /* @__PURE__ */ new Map();
    for (const n of this._editStackElementsArr) {
      const o = dg(n.resource);
      this._editStackElementsMap.set(o, n);
    }
    this._delegate = null;
  }
  prepareUndoRedo() {
    if (this._delegate)
      return this._delegate.prepareUndoRedo(this);
  }
  matchesResource(e) {
    const t = dg(e);
    return this._editStackElementsMap.has(t);
  }
  setModel(e) {
    const t = dg(_e.isUri(e) ? e : e.uri);
    this._editStackElementsMap.has(t) && this._editStackElementsMap.get(t).setModel(e);
  }
  canAppend(e) {
    if (!this._isOpen)
      return !1;
    const t = dg(e.uri);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).canAppend(e) : !1;
  }
  append(e, t, i, n, o) {
    const r = dg(e.uri);
    this._editStackElementsMap.get(r).append(e, t, i, n, o);
  }
  close() {
    this._isOpen = !1;
  }
  open() {
  }
  undo() {
    this._isOpen = !1;
    for (const e of this._editStackElementsArr)
      e.undo();
  }
  redo() {
    for (const e of this._editStackElementsArr)
      e.redo();
  }
  heapSize(e) {
    const t = dg(e);
    return this._editStackElementsMap.has(t) ? this._editStackElementsMap.get(t).heapSize() : 0;
  }
  split() {
    return this._editStackElementsArr;
  }
  toString() {
    const e = [];
    for (const t of this._editStackElementsArr)
      e.push(`${Xo(t.resource)}: ${t}`);
    return `{${e.join(", ")}}`;
  }
}
function pk(s) {
  return s.getEOL() === `
` ? 0 : 1;
}
function hl(s) {
  return s ? s instanceof uW || s instanceof yZ : !1;
}
class ZN {
  constructor(e, t) {
    this._model = e, this._undoRedoService = t;
  }
  pushStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    hl(e) && e.close();
  }
  popStackElement() {
    const e = this._undoRedoService.getLastElement(this._model.uri);
    hl(e) && e.open();
  }
  clear() {
    this._undoRedoService.removeElements(this._model.uri);
  }
  _getOrCreateEditStackElement(e, t) {
    const i = this._undoRedoService.getLastElement(this._model.uri);
    if (hl(i) && i.canAppend(this._model))
      return i;
    const n = new uW(f("edit", "Typing"), "undoredo.textBufferEdit", this._model, e);
    return this._undoRedoService.pushElement(n, t), n;
  }
  pushEOL(e) {
    const t = this._getOrCreateEditStackElement(null, void 0);
    this._model.setEOL(e), t.append(this._model, [], pk(this._model), this._model.getAlternativeVersionId(), null);
  }
  pushEditOperation(e, t, i, n) {
    const o = this._getOrCreateEditStackElement(e, n), r = this._model.applyEdits(t, !0), a = ZN._computeCursorState(i, r), l = r.map((c, d) => ({ index: d, textChange: c.textChange }));
    return l.sort((c, d) => c.textChange.oldPosition === d.textChange.oldPosition ? c.index - d.index : c.textChange.oldPosition - d.textChange.oldPosition), o.append(this._model, l.map((c) => c.textChange), pk(this._model), this._model.getAlternativeVersionId(), a), a;
  }
  static _computeCursorState(e, t) {
    try {
      return e ? e(t) : null;
    } catch (i) {
      return Pe(i), null;
    }
  }
}
class gW extends V {
  constructor() {
    super(...arguments), this._isDisposed = !1;
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
  assertNotDisposed() {
    if (this._isDisposed)
      throw new Error("TextModelPart is disposed!");
  }
}
function dS(s, e) {
  let t = 0, i = 0;
  const n = s.length;
  for (; i < n; ) {
    const o = s.charCodeAt(i);
    if (o === 32)
      t++;
    else if (o === 9)
      t = t - t % e + e;
    else
      break;
    i++;
  }
  return i === n ? -1 : t;
}
var Mh;
(function(s) {
  s[s.Disabled = 0] = "Disabled", s[s.EnabledForActive = 1] = "EnabledForActive", s[s.Enabled = 2] = "Enabled";
})(Mh || (Mh = {}));
class vh {
  constructor(e, t, i, n, o, r) {
    if (this.visibleColumn = e, this.column = t, this.className = i, this.horizontalLine = n, this.forWrappedLinesAfterColumn = o, this.forWrappedLinesBeforeOrAtColumn = r, e !== -1 == (t !== -1))
      throw new Error();
  }
}
class Hp {
  constructor(e, t) {
    this.top = e, this.endColumn = t;
  }
}
class xZ extends gW {
  constructor(e, t) {
    super(), this.textModel = e, this.languageConfigurationService = t;
  }
  getLanguageConfiguration(e) {
    return this.languageConfigurationService.getLanguageConfiguration(e);
  }
  _computeIndentLevel(e) {
    return dS(this.textModel.getLineContent(e + 1), this.textModel.getOptions().tabSize);
  }
  getActiveIndentGuide(e, t, i) {
    this.assertNotDisposed();
    const n = this.textModel.getLineCount();
    if (e < 1 || e > n)
      throw new lt("Illegal value for lineNumber");
    const o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide);
    let a = -2, l = -1, c = -2, d = -1;
    const h = (y) => {
      if (a !== -1 && (a === -2 || a > y - 1)) {
        a = -1, l = -1;
        for (let D = y - 2; D >= 0; D--) {
          const I = this._computeIndentLevel(D);
          if (I >= 0) {
            a = D, l = I;
            break;
          }
        }
      }
      if (c === -2) {
        c = -1, d = -1;
        for (let D = y; D < n; D++) {
          const I = this._computeIndentLevel(D);
          if (I >= 0) {
            c = D, d = I;
            break;
          }
        }
      }
    };
    let u = -2, g = -1, m = -2, p = -1;
    const A = (y) => {
      if (u === -2) {
        u = -1, g = -1;
        for (let D = y - 2; D >= 0; D--) {
          const I = this._computeIndentLevel(D);
          if (I >= 0) {
            u = D, g = I;
            break;
          }
        }
      }
      if (m !== -1 && (m === -2 || m < y - 1)) {
        m = -1, p = -1;
        for (let D = y; D < n; D++) {
          const I = this._computeIndentLevel(D);
          if (I >= 0) {
            m = D, p = I;
            break;
          }
        }
      }
    };
    let _ = 0, b = !0, C = 0, w = !0, S = 0, x = 0;
    for (let y = 0; b || w; y++) {
      const D = e - y, I = e + y;
      y > 1 && (D < 1 || D < t) && (b = !1), y > 1 && (I > n || I > i) && (w = !1), y > 5e4 && (b = !1, w = !1);
      let Q = -1;
      if (b && D >= 1) {
        const W = this._computeIndentLevel(D - 1);
        W >= 0 ? (c = D - 1, d = W, Q = Math.ceil(W / this.textModel.getOptions().indentSize)) : (h(D), Q = this._getIndentLevelForWhitespaceLine(r, l, d));
      }
      let P = -1;
      if (w && I <= n) {
        const W = this._computeIndentLevel(I - 1);
        W >= 0 ? (u = I - 1, g = W, P = Math.ceil(W / this.textModel.getOptions().indentSize)) : (A(I), P = this._getIndentLevelForWhitespaceLine(r, g, p));
      }
      if (y === 0) {
        x = Q;
        continue;
      }
      if (y === 1) {
        if (I <= n && P >= 0 && x + 1 === P) {
          b = !1, _ = I, C = I, S = P;
          continue;
        }
        if (D >= 1 && Q >= 0 && Q - 1 === x) {
          w = !1, _ = D, C = D, S = Q;
          continue;
        }
        if (_ = e, C = e, S = x, S === 0)
          return { startLineNumber: _, endLineNumber: C, indent: S };
      }
      b && (Q >= S ? _ = D : b = !1), w && (P >= S ? C = I : w = !1);
    }
    return { startLineNumber: _, endLineNumber: C, indent: S };
  }
  getLinesBracketGuides(e, t, i, n) {
    const o = [];
    for (let h = e; h <= t; h++)
      o.push([]);
    const r = !0, a = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new E(e, 1, t, this.textModel.getLineMaxColumn(t))).toArray();
    let l;
    if (i && a.length > 0) {
      const h = (e <= i.lineNumber && i.lineNumber <= t ? a : this.textModel.bracketPairs.getBracketPairsInRange(E.fromPositions(i)).toArray()).filter((u) => E.strictContainsPosition(u.range, i));
      l = gC(h, (u) => r)?.range;
    }
    const c = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType, d = new fW();
    for (const h of a) {
      if (!h.closingBracketRange)
        continue;
      const u = l && h.range.equalsRange(l);
      if (!u && !n.includeInactive)
        continue;
      const g = d.getInlineClassName(h.nestingLevel, h.nestingLevelOfEqualBracketType, c) + (n.highlightActive && u ? " " + d.activeClassName : ""), m = h.openingBracketRange.getStartPosition(), p = h.closingBracketRange.getStartPosition(), A = n.horizontalGuides === Mh.Enabled || n.horizontalGuides === Mh.EnabledForActive && u;
      if (h.range.startLineNumber === h.range.endLineNumber) {
        A && o[h.range.startLineNumber - e].push(new vh(-1, h.openingBracketRange.getEndPosition().column, g, new Hp(!1, p.column), -1, -1));
        continue;
      }
      const _ = this.getVisibleColumnFromPosition(p), b = this.getVisibleColumnFromPosition(h.openingBracketRange.getStartPosition()), C = Math.min(b, _, h.minVisibleColumnIndentation + 1);
      let w = !1;
      Sn(this.textModel.getLineContent(h.closingBracketRange.startLineNumber)) < h.closingBracketRange.startColumn - 1 && (w = !0);
      const y = Math.max(m.lineNumber, e), D = Math.min(p.lineNumber, t), I = w ? 1 : 0;
      for (let Q = y; Q < D + I; Q++)
        o[Q - e].push(new vh(C, -1, g, null, Q === m.lineNumber ? m.column : -1, Q === p.lineNumber ? p.column : -1));
      A && (m.lineNumber >= e && b > C && o[m.lineNumber - e].push(new vh(C, -1, g, new Hp(!1, m.column), -1, -1)), p.lineNumber <= t && _ > C && o[p.lineNumber - e].push(new vh(C, -1, g, new Hp(!w, p.column), -1, -1)));
    }
    for (const h of o)
      h.sort((u, g) => u.visibleColumn - g.visibleColumn);
    return o;
  }
  getVisibleColumnFromPosition(e) {
    return wi.visibleColumnFromColumn(this.textModel.getLineContent(e.lineNumber), e.column, this.textModel.getOptions().tabSize) + 1;
  }
  getLinesIndentGuides(e, t) {
    this.assertNotDisposed();
    const i = this.textModel.getLineCount();
    if (e < 1 || e > i)
      throw new Error("Illegal value for startLineNumber");
    if (t < 1 || t > i)
      throw new Error("Illegal value for endLineNumber");
    const n = this.textModel.getOptions(), o = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules, r = !!(o && o.offSide), a = new Array(t - e + 1);
    let l = -2, c = -1, d = -2, h = -1;
    for (let u = e; u <= t; u++) {
      const g = u - e, m = this._computeIndentLevel(u - 1);
      if (m >= 0) {
        l = u - 1, c = m, a[g] = Math.ceil(m / n.indentSize);
        continue;
      }
      if (l === -2) {
        l = -1, c = -1;
        for (let p = u - 2; p >= 0; p--) {
          const A = this._computeIndentLevel(p);
          if (A >= 0) {
            l = p, c = A;
            break;
          }
        }
      }
      if (d !== -1 && (d === -2 || d < u - 1)) {
        d = -1, h = -1;
        for (let p = u; p < i; p++) {
          const A = this._computeIndentLevel(p);
          if (A >= 0) {
            d = p, h = A;
            break;
          }
        }
      }
      a[g] = this._getIndentLevelForWhitespaceLine(r, c, h);
    }
    return a;
  }
  _getIndentLevelForWhitespaceLine(e, t, i) {
    const n = this.textModel.getOptions();
    return t === -1 || i === -1 ? 0 : t < i ? 1 + Math.floor(t / n.indentSize) : t === i || e ? Math.ceil(i / n.indentSize) : 1 + Math.floor(i / n.indentSize);
  }
}
class fW {
  constructor() {
    this.activeClassName = "indent-active";
  }
  getInlineClassName(e, t, i) {
    return this.getInlineClassNameOfLevel(i ? t : e);
  }
  getInlineClassNameOfLevel(e) {
    return `bracket-indent-guide lvl-${e % 30}`;
  }
}
class EZ {
  constructor() {
    this.spacesDiff = 0, this.looksLikeAlignment = !1;
  }
}
function LZ(s, e, t, i, n) {
  n.spacesDiff = 0, n.looksLikeAlignment = !1;
  let o;
  for (o = 0; o < e && o < i; o++) {
    const u = s.charCodeAt(o), g = t.charCodeAt(o);
    if (u !== g)
      break;
  }
  let r = 0, a = 0;
  for (let u = o; u < e; u++)
    s.charCodeAt(u) === 32 ? r++ : a++;
  let l = 0, c = 0;
  for (let u = o; u < i; u++)
    t.charCodeAt(u) === 32 ? l++ : c++;
  if (r > 0 && a > 0 || l > 0 && c > 0)
    return;
  const d = Math.abs(a - c), h = Math.abs(r - l);
  if (d === 0) {
    n.spacesDiff = h, h > 0 && 0 <= l - 1 && l - 1 < s.length && l < t.length && t.charCodeAt(l) !== 32 && s.charCodeAt(l - 1) === 32 && s.charCodeAt(s.length - 1) === 44 && (n.looksLikeAlignment = !0);
    return;
  }
  if (h % d === 0) {
    n.spacesDiff = h / d;
    return;
  }
}
function EF(s, e, t) {
  const i = Math.min(s.getLineCount(), 1e4);
  let n = 0, o = 0, r = "", a = 0;
  const l = [2, 4, 6, 8, 3, 5, 7], c = 8, d = [0, 0, 0, 0, 0, 0, 0, 0, 0], h = new EZ();
  for (let m = 1; m <= i; m++) {
    const p = s.getLineLength(m), A = s.getLineContent(m), _ = p <= 65536;
    let b = !1, C = 0, w = 0, S = 0;
    for (let y = 0, D = p; y < D; y++) {
      const I = _ ? A.charCodeAt(y) : s.getLineCharCode(m, y);
      if (I === 9)
        S++;
      else if (I === 32)
        w++;
      else {
        b = !0, C = y;
        break;
      }
    }
    if (!b || (S > 0 ? n++ : w > 1 && o++, LZ(r, a, A, C, h), h.looksLikeAlignment && !(t && e === h.spacesDiff)))
      continue;
    const x = h.spacesDiff;
    x <= c && d[x]++, r = A, a = C;
  }
  let u = t;
  n !== o && (u = n < o);
  let g = e;
  if (u) {
    let m = u ? 0 : 0.1 * i;
    l.forEach((p) => {
      const A = d[p];
      A > m && (m = A, g = p);
    }), g === 4 && d[4] > 0 && d[2] > 0 && d[2] >= d[4] / 2 && (g = 2);
  }
  return {
    insertSpaces: u,
    tabSize: g
  };
}
function jn(s) {
  return (s.metadata & 1) >>> 0;
}
function Dt(s, e) {
  s.metadata = s.metadata & 254 | e << 0;
}
function en(s) {
  return (s.metadata & 2) >>> 1 === 1;
}
function Lt(s, e) {
  s.metadata = s.metadata & 253 | (e ? 1 : 0) << 1;
}
function mW(s) {
  return (s.metadata & 4) >>> 2 === 1;
}
function LF(s, e) {
  s.metadata = s.metadata & 251 | (e ? 1 : 0) << 2;
}
function pW(s) {
  return (s.metadata & 64) >>> 6 === 1;
}
function kF(s, e) {
  s.metadata = s.metadata & 191 | (e ? 1 : 0) << 6;
}
function kZ(s) {
  return (s.metadata & 24) >>> 3;
}
function DF(s, e) {
  s.metadata = s.metadata & 231 | e << 3;
}
function DZ(s) {
  return (s.metadata & 32) >>> 5 === 1;
}
function IF(s, e) {
  s.metadata = s.metadata & 223 | (e ? 1 : 0) << 5;
}
class AW {
  constructor(e, t, i) {
    this.metadata = 0, this.parent = this, this.left = this, this.right = this, Dt(
      this,
      1
      /* NodeColor.Red */
    ), this.start = t, this.end = i, this.delta = 0, this.maxEnd = i, this.id = e, this.ownerId = 0, this.options = null, LF(this, !1), kF(this, !1), DF(
      this,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), IF(this, !1), this.cachedVersionId = 0, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = null, Lt(this, !1);
  }
  reset(e, t, i, n) {
    this.start = t, this.end = i, this.maxEnd = i, this.cachedVersionId = e, this.cachedAbsoluteStart = t, this.cachedAbsoluteEnd = i, this.range = n;
  }
  setOptions(e) {
    this.options = e;
    const t = this.options.className;
    LF(this, t === "squiggly-error" || t === "squiggly-warning" || t === "squiggly-info"), kF(this, this.options.glyphMarginClassName !== null), DF(this, this.options.stickiness), IF(this, this.options.collapseOnReplaceEdit);
  }
  setCachedOffsets(e, t, i) {
    this.cachedVersionId !== i && (this.range = null), this.cachedVersionId = i, this.cachedAbsoluteStart = e, this.cachedAbsoluteEnd = t;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const Oe = new AW(null, 0, 0);
Oe.parent = Oe;
Oe.left = Oe;
Oe.right = Oe;
Dt(
  Oe,
  0
  /* NodeColor.Black */
);
class Fy {
  constructor() {
    this.root = Oe, this.requestNormalizeDelta = !1;
  }
  intervalSearch(e, t, i, n, o, r) {
    return this.root === Oe ? [] : OZ(this, e, t, i, n, o, r);
  }
  search(e, t, i, n) {
    return this.root === Oe ? [] : FZ(this, e, t, i, n);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesFromOwner(e) {
    return BZ(this, e);
  }
  /**
   * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!
   */
  collectNodesPostOrder() {
    return RZ(this);
  }
  insert(e) {
    MF(this, e), this._normalizeDeltaIfNecessary();
  }
  delete(e) {
    NF(this, e), this._normalizeDeltaIfNecessary();
  }
  resolveNode(e, t) {
    const i = e;
    let n = 0;
    for (; e !== this.root; )
      e === e.parent.right && (n += e.parent.delta), e = e.parent;
    const o = i.start + n, r = i.end + n;
    i.setCachedOffsets(o, r, t);
  }
  acceptReplace(e, t, i, n) {
    const o = NZ(this, e, e + t);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      NF(this, l);
    }
    this._normalizeDeltaIfNecessary(), TZ(this, e, e + t, i), this._normalizeDeltaIfNecessary();
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r];
      l.start = l.cachedAbsoluteStart, l.end = l.cachedAbsoluteEnd, MZ(l, e, e + t, i, n), l.maxEnd = l.end, MF(this, l);
    }
    this._normalizeDeltaIfNecessary();
  }
  _normalizeDeltaIfNecessary() {
    this.requestNormalizeDelta && (this.requestNormalizeDelta = !1, IZ(this));
  }
}
function IZ(s) {
  let e = s.root, t = 0;
  for (; e !== Oe; ) {
    if (e.left !== Oe && !en(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Oe && !en(e.right)) {
      t += e.delta, e = e.right;
      continue;
    }
    e.start = t + e.start, e.end = t + e.end, e.delta = 0, cd(e), Lt(e, !0), Lt(e.left, !1), Lt(e.right, !1), e === e.parent.right && (t -= e.parent.delta), e = e.parent;
  }
  Lt(s.root, !1);
}
function hg(s, e, t, i) {
  return s < t ? !0 : s > t || i === 1 ? !1 : i === 2 ? !0 : e;
}
function MZ(s, e, t, i, n) {
  const o = kZ(s), r = o === 0 || o === 2, a = o === 1 || o === 2, l = t - e, c = i, d = Math.min(l, c), h = s.start;
  let u = !1;
  const g = s.end;
  let m = !1;
  e <= h && g <= t && DZ(s) && (s.start = e, u = !0, s.end = e, m = !0);
  {
    const A = n ? 1 : l > 0 ? 2 : 0;
    !u && hg(h, r, e, A) && (u = !0), !m && hg(g, a, e, A) && (m = !0);
  }
  if (d > 0 && !n) {
    const A = l > c ? 2 : 0;
    !u && hg(h, r, e + d, A) && (u = !0), !m && hg(g, a, e + d, A) && (m = !0);
  }
  {
    const A = n ? 1 : 0;
    !u && hg(h, r, t, A) && (s.start = e + c, u = !0), !m && hg(g, a, t, A) && (s.end = e + c, m = !0);
  }
  const p = c - l;
  u || (s.start = Math.max(0, h + p)), m || (s.end = Math.max(0, g + p)), s.start > s.end && (s.end = s.start);
}
function NZ(s, e, t) {
  let i = s.root, n = 0, o = 0, r = 0, a = 0;
  const l = [];
  let c = 0;
  for (; i !== Oe; ) {
    if (en(i)) {
      Lt(i.left, !1), Lt(i.right, !1), i === i.parent.right && (n -= i.parent.delta), i = i.parent;
      continue;
    }
    if (!en(i.left)) {
      if (o = n + i.maxEnd, o < e) {
        Lt(i, !0);
        continue;
      }
      if (i.left !== Oe) {
        i = i.left;
        continue;
      }
    }
    if (r = n + i.start, r > t) {
      Lt(i, !0);
      continue;
    }
    if (a = n + i.end, a >= e && (i.setCachedOffsets(r, a, 0), l[c++] = i), Lt(i, !0), i.right !== Oe && !en(i.right)) {
      n += i.delta, i = i.right;
      continue;
    }
  }
  return Lt(s.root, !1), l;
}
function TZ(s, e, t, i) {
  let n = s.root, o = 0, r = 0, a = 0;
  const l = i - (t - e);
  for (; n !== Oe; ) {
    if (en(n)) {
      Lt(n.left, !1), Lt(n.right, !1), n === n.parent.right && (o -= n.parent.delta), cd(n), n = n.parent;
      continue;
    }
    if (!en(n.left)) {
      if (r = o + n.maxEnd, r < e) {
        Lt(n, !0);
        continue;
      }
      if (n.left !== Oe) {
        n = n.left;
        continue;
      }
    }
    if (a = o + n.start, a > t) {
      n.start += l, n.end += l, n.delta += l, (n.delta < -1073741824 || n.delta > 1073741824) && (s.requestNormalizeDelta = !0), Lt(n, !0);
      continue;
    }
    if (Lt(n, !0), n.right !== Oe && !en(n.right)) {
      o += n.delta, n = n.right;
      continue;
    }
  }
  Lt(s.root, !1);
}
function BZ(s, e) {
  let t = s.root;
  const i = [];
  let n = 0;
  for (; t !== Oe; ) {
    if (en(t)) {
      Lt(t.left, !1), Lt(t.right, !1), t = t.parent;
      continue;
    }
    if (t.left !== Oe && !en(t.left)) {
      t = t.left;
      continue;
    }
    if (t.ownerId === e && (i[n++] = t), Lt(t, !0), t.right !== Oe && !en(t.right)) {
      t = t.right;
      continue;
    }
  }
  return Lt(s.root, !1), i;
}
function RZ(s) {
  let e = s.root;
  const t = [];
  let i = 0;
  for (; e !== Oe; ) {
    if (en(e)) {
      Lt(e.left, !1), Lt(e.right, !1), e = e.parent;
      continue;
    }
    if (e.left !== Oe && !en(e.left)) {
      e = e.left;
      continue;
    }
    if (e.right !== Oe && !en(e.right)) {
      e = e.right;
      continue;
    }
    t[i++] = e, Lt(e, !0);
  }
  return Lt(s.root, !1), t;
}
function FZ(s, e, t, i, n) {
  let o = s.root, r = 0, a = 0, l = 0;
  const c = [];
  let d = 0;
  for (; o !== Oe; ) {
    if (en(o)) {
      Lt(o.left, !1), Lt(o.right, !1), o === o.parent.right && (r -= o.parent.delta), o = o.parent;
      continue;
    }
    if (o.left !== Oe && !en(o.left)) {
      o = o.left;
      continue;
    }
    a = r + o.start, l = r + o.end, o.setCachedOffsets(a, l, i);
    let h = !0;
    if (e && o.ownerId && o.ownerId !== e && (h = !1), t && mW(o) && (h = !1), n && !pW(o) && (h = !1), h && (c[d++] = o), Lt(o, !0), o.right !== Oe && !en(o.right)) {
      r += o.delta, o = o.right;
      continue;
    }
  }
  return Lt(s.root, !1), c;
}
function OZ(s, e, t, i, n, o, r) {
  let a = s.root, l = 0, c = 0, d = 0, h = 0;
  const u = [];
  let g = 0;
  for (; a !== Oe; ) {
    if (en(a)) {
      Lt(a.left, !1), Lt(a.right, !1), a === a.parent.right && (l -= a.parent.delta), a = a.parent;
      continue;
    }
    if (!en(a.left)) {
      if (c = l + a.maxEnd, c < e) {
        Lt(a, !0);
        continue;
      }
      if (a.left !== Oe) {
        a = a.left;
        continue;
      }
    }
    if (d = l + a.start, d > t) {
      Lt(a, !0);
      continue;
    }
    if (h = l + a.end, h >= e) {
      a.setCachedOffsets(d, h, o);
      let m = !0;
      i && a.ownerId && a.ownerId !== i && (m = !1), n && mW(a) && (m = !1), r && !pW(a) && (m = !1), m && (u[g++] = a);
    }
    if (Lt(a, !0), a.right !== Oe && !en(a.right)) {
      l += a.delta, a = a.right;
      continue;
    }
  }
  return Lt(s.root, !1), u;
}
function MF(s, e) {
  if (s.root === Oe)
    return e.parent = Oe, e.left = Oe, e.right = Oe, Dt(
      e,
      0
      /* NodeColor.Black */
    ), s.root = e, s.root;
  PZ(s, e), cc(e.parent);
  let t = e;
  for (; t !== s.root && jn(t.parent) === 1; )
    if (t.parent === t.parent.parent.left) {
      const i = t.parent.parent.right;
      jn(i) === 1 ? (Dt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Dt(
        i,
        0
        /* NodeColor.Black */
      ), Dt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.right && (t = t.parent, Wp(s, t)), Dt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Dt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), Vp(s, t.parent.parent));
    } else {
      const i = t.parent.parent.left;
      jn(i) === 1 ? (Dt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Dt(
        i,
        0
        /* NodeColor.Black */
      ), Dt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), t = t.parent.parent) : (t === t.parent.left && (t = t.parent, Vp(s, t)), Dt(
        t.parent,
        0
        /* NodeColor.Black */
      ), Dt(
        t.parent.parent,
        1
        /* NodeColor.Red */
      ), Wp(s, t.parent.parent));
    }
  return Dt(
    s.root,
    0
    /* NodeColor.Black */
  ), e;
}
function PZ(s, e) {
  let t = 0, i = s.root;
  const n = e.start, o = e.end;
  for (; ; )
    if (WZ(n, o, i.start + t, i.end + t) < 0)
      if (i.left === Oe) {
        e.start -= t, e.end -= t, e.maxEnd -= t, i.left = e;
        break;
      } else
        i = i.left;
    else if (i.right === Oe) {
      e.start -= t + i.delta, e.end -= t + i.delta, e.maxEnd -= t + i.delta, i.right = e;
      break;
    } else
      t += i.delta, i = i.right;
  e.parent = i, e.left = Oe, e.right = Oe, Dt(
    e,
    1
    /* NodeColor.Red */
  );
}
function NF(s, e) {
  let t, i;
  if (e.left === Oe ? (t = e.right, i = e, t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta) : e.right === Oe ? (t = e.left, i = e) : (i = HZ(e.right), t = i.right, t.start += i.delta, t.end += i.delta, t.delta += i.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), i.start += e.delta, i.end += e.delta, i.delta = e.delta, (i.delta < -1073741824 || i.delta > 1073741824) && (s.requestNormalizeDelta = !0)), i === s.root) {
    s.root = t, Dt(
      t,
      0
      /* NodeColor.Black */
    ), e.detach(), Oy(), cd(t), s.root.parent = Oe;
    return;
  }
  const n = jn(i) === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? t.parent = i.parent : (i.parent === e ? t.parent = i : t.parent = i.parent, i.left = e.left, i.right = e.right, i.parent = e.parent, Dt(i, jn(e)), e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== Oe && (i.left.parent = i), i.right !== Oe && (i.right.parent = i)), e.detach(), n) {
    cc(t.parent), i !== e && (cc(i), cc(i.parent)), Oy();
    return;
  }
  cc(t), cc(t.parent), i !== e && (cc(i), cc(i.parent));
  let o;
  for (; t !== s.root && jn(t) === 0; )
    t === t.parent.left ? (o = t.parent.right, jn(o) === 1 && (Dt(
      o,
      0
      /* NodeColor.Black */
    ), Dt(
      t.parent,
      1
      /* NodeColor.Red */
    ), Wp(s, t.parent), o = t.parent.right), jn(o.left) === 0 && jn(o.right) === 0 ? (Dt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (jn(o.right) === 0 && (Dt(
      o.left,
      0
      /* NodeColor.Black */
    ), Dt(
      o,
      1
      /* NodeColor.Red */
    ), Vp(s, o), o = t.parent.right), Dt(o, jn(t.parent)), Dt(
      t.parent,
      0
      /* NodeColor.Black */
    ), Dt(
      o.right,
      0
      /* NodeColor.Black */
    ), Wp(s, t.parent), t = s.root)) : (o = t.parent.left, jn(o) === 1 && (Dt(
      o,
      0
      /* NodeColor.Black */
    ), Dt(
      t.parent,
      1
      /* NodeColor.Red */
    ), Vp(s, t.parent), o = t.parent.left), jn(o.left) === 0 && jn(o.right) === 0 ? (Dt(
      o,
      1
      /* NodeColor.Red */
    ), t = t.parent) : (jn(o.left) === 0 && (Dt(
      o.right,
      0
      /* NodeColor.Black */
    ), Dt(
      o,
      1
      /* NodeColor.Red */
    ), Wp(s, o), o = t.parent.left), Dt(o, jn(t.parent)), Dt(
      t.parent,
      0
      /* NodeColor.Black */
    ), Dt(
      o.left,
      0
      /* NodeColor.Black */
    ), Vp(s, t.parent), t = s.root));
  Dt(
    t,
    0
    /* NodeColor.Black */
  ), Oy();
}
function HZ(s) {
  for (; s.left !== Oe; )
    s = s.left;
  return s;
}
function Oy() {
  Oe.parent = Oe, Oe.delta = 0, Oe.start = 0, Oe.end = 0;
}
function Wp(s, e) {
  const t = e.right;
  t.delta += e.delta, (t.delta < -1073741824 || t.delta > 1073741824) && (s.requestNormalizeDelta = !0), t.start += e.delta, t.end += e.delta, e.right = t.left, t.left !== Oe && (t.left.parent = e), t.parent = e.parent, e.parent === Oe ? s.root = t : e === e.parent.left ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t, cd(e), cd(t);
}
function Vp(s, e) {
  const t = e.left;
  e.delta -= t.delta, (e.delta < -1073741824 || e.delta > 1073741824) && (s.requestNormalizeDelta = !0), e.start -= t.delta, e.end -= t.delta, e.left = t.right, t.right !== Oe && (t.right.parent = e), t.parent = e.parent, e.parent === Oe ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t, cd(e), cd(t);
}
function _W(s) {
  let e = s.end;
  if (s.left !== Oe) {
    const t = s.left.maxEnd;
    t > e && (e = t);
  }
  if (s.right !== Oe) {
    const t = s.right.maxEnd + s.delta;
    t > e && (e = t);
  }
  return e;
}
function cd(s) {
  s.maxEnd = _W(s);
}
function cc(s) {
  for (; s !== Oe; ) {
    const e = _W(s);
    if (s.maxEnd === e)
      return;
    s.maxEnd = e, s = s.parent;
  }
}
function WZ(s, e, t, i) {
  return s === t ? e - i : s - t;
}
class Ak {
  constructor(e, t) {
    this.piece = e, this.color = t, this.size_left = 0, this.lf_left = 0, this.parent = this, this.left = this, this.right = this;
  }
  next() {
    if (this.right !== xe)
      return eT(this.right);
    let e = this;
    for (; e.parent !== xe && e.parent.left !== e; )
      e = e.parent;
    return e.parent === xe ? xe : e.parent;
  }
  prev() {
    if (this.left !== xe)
      return bW(this.left);
    let e = this;
    for (; e.parent !== xe && e.parent.right !== e; )
      e = e.parent;
    return e.parent === xe ? xe : e.parent;
  }
  detach() {
    this.parent = null, this.left = null, this.right = null;
  }
}
const xe = new Ak(
  null,
  0
  /* NodeColor.Black */
);
xe.parent = xe;
xe.left = xe;
xe.right = xe;
xe.color = 0;
function eT(s) {
  for (; s.left !== xe; )
    s = s.left;
  return s;
}
function bW(s) {
  for (; s.right !== xe; )
    s = s.right;
  return s;
}
function tT(s) {
  return s === xe ? 0 : s.size_left + s.piece.length + tT(s.right);
}
function iT(s) {
  return s === xe ? 0 : s.lf_left + s.piece.lineFeedCnt + iT(s.right);
}
function Py() {
  xe.parent = xe;
}
function zp(s, e) {
  const t = e.right;
  t.size_left += e.size_left + (e.piece ? e.piece.length : 0), t.lf_left += e.lf_left + (e.piece ? e.piece.lineFeedCnt : 0), e.right = t.left, t.left !== xe && (t.left.parent = e), t.parent = e.parent, e.parent === xe ? s.root = t : e.parent.left === e ? e.parent.left = t : e.parent.right = t, t.left = e, e.parent = t;
}
function Up(s, e) {
  const t = e.left;
  e.left = t.right, t.right !== xe && (t.right.parent = e), t.parent = e.parent, e.size_left -= t.size_left + (t.piece ? t.piece.length : 0), e.lf_left -= t.lf_left + (t.piece ? t.piece.lineFeedCnt : 0), e.parent === xe ? s.root = t : e === e.parent.right ? e.parent.right = t : e.parent.left = t, t.right = e, e.parent = t;
}
function Tb(s, e) {
  let t, i;
  if (e.left === xe ? (i = e, t = i.right) : e.right === xe ? (i = e, t = i.left) : (i = eT(e.right), t = i.right), i === s.root) {
    s.root = t, t.color = 0, e.detach(), Py(), s.root.parent = xe;
    return;
  }
  const n = i.color === 1;
  if (i === i.parent.left ? i.parent.left = t : i.parent.right = t, i === e ? (t.parent = i.parent, _p(s, t)) : (i.parent === e ? t.parent = i : t.parent = i.parent, _p(s, t), i.left = e.left, i.right = e.right, i.parent = e.parent, i.color = e.color, e === s.root ? s.root = i : e === e.parent.left ? e.parent.left = i : e.parent.right = i, i.left !== xe && (i.left.parent = i), i.right !== xe && (i.right.parent = i), i.size_left = e.size_left, i.lf_left = e.lf_left, _p(s, i)), e.detach(), t.parent.left === t) {
    const r = tT(t), a = iT(t);
    if (r !== t.parent.size_left || a !== t.parent.lf_left) {
      const l = r - t.parent.size_left, c = a - t.parent.lf_left;
      t.parent.size_left = r, t.parent.lf_left = a, Xa(s, t.parent, l, c);
    }
  }
  if (_p(s, t.parent), n) {
    Py();
    return;
  }
  let o;
  for (; t !== s.root && t.color === 0; )
    t === t.parent.left ? (o = t.parent.right, o.color === 1 && (o.color = 0, t.parent.color = 1, zp(s, t.parent), o = t.parent.right), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.right.color === 0 && (o.left.color = 0, o.color = 1, Up(s, o), o = t.parent.right), o.color = t.parent.color, t.parent.color = 0, o.right.color = 0, zp(s, t.parent), t = s.root)) : (o = t.parent.left, o.color === 1 && (o.color = 0, t.parent.color = 1, Up(s, t.parent), o = t.parent.left), o.left.color === 0 && o.right.color === 0 ? (o.color = 1, t = t.parent) : (o.left.color === 0 && (o.right.color = 0, o.color = 1, zp(s, o), o = t.parent.left), o.color = t.parent.color, t.parent.color = 0, o.left.color = 0, Up(s, t.parent), t = s.root));
  t.color = 0, Py();
}
function TF(s, e) {
  for (_p(s, e); e !== s.root && e.parent.color === 1; )
    if (e.parent === e.parent.parent.left) {
      const t = e.parent.parent.right;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.right && (e = e.parent, zp(s, e)), e.parent.color = 0, e.parent.parent.color = 1, Up(s, e.parent.parent));
    } else {
      const t = e.parent.parent.left;
      t.color === 1 ? (e.parent.color = 0, t.color = 0, e.parent.parent.color = 1, e = e.parent.parent) : (e === e.parent.left && (e = e.parent, Up(s, e)), e.parent.color = 0, e.parent.parent.color = 1, zp(s, e.parent.parent));
    }
  s.root.color = 0;
}
function Xa(s, e, t, i) {
  for (; e !== s.root && e !== xe; )
    e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
}
function _p(s, e) {
  let t = 0, i = 0;
  if (e !== s.root) {
    for (; e !== s.root && e === e.parent.right; )
      e = e.parent;
    if (e !== s.root)
      for (e = e.parent, t = tT(e.left) - e.size_left, i = iT(e.left) - e.lf_left, e.size_left += t, e.lf_left += i; e !== s.root && (t !== 0 || i !== 0); )
        e.parent.left === e && (e.parent.size_left += t, e.parent.lf_left += i), e = e.parent;
  }
}
const ja = 65535;
function wW(s) {
  let e;
  return s[s.length - 1] < 65536 ? e = new Uint16Array(s.length) : e = new Uint32Array(s.length), e.set(s, 0), e;
}
class VZ {
  constructor(e, t, i, n, o) {
    this.lineStarts = e, this.cr = t, this.lf = i, this.crlf = n, this.isBasicASCII = o;
  }
}
function Za(s, e = !0) {
  const t = [0];
  let i = 1;
  for (let n = 0, o = s.length; n < o; n++) {
    const r = s.charCodeAt(n);
    r === 13 ? n + 1 < o && s.charCodeAt(n + 1) === 10 ? (t[i++] = n + 2, n++) : t[i++] = n + 1 : r === 10 && (t[i++] = n + 1);
  }
  return e ? wW(t) : t;
}
function zZ(s, e) {
  s.length = 0, s[0] = 0;
  let t = 1, i = 0, n = 0, o = 0, r = !0;
  for (let l = 0, c = e.length; l < c; l++) {
    const d = e.charCodeAt(l);
    d === 13 ? l + 1 < c && e.charCodeAt(l + 1) === 10 ? (o++, s[t++] = l + 2, l++) : (i++, s[t++] = l + 1) : d === 10 ? (n++, s[t++] = l + 1) : r && d !== 9 && (d < 32 || d > 126) && (r = !1);
  }
  const a = new VZ(wW(s), i, n, o, r);
  return s.length = 0, a;
}
class ds {
  constructor(e, t, i, n, o) {
    this.bufferIndex = e, this.start = t, this.end = i, this.lineFeedCnt = n, this.length = o;
  }
}
class nh {
  constructor(e, t) {
    this.buffer = e, this.lineStarts = t;
  }
}
class UZ {
  constructor(e, t) {
    this._pieces = [], this._tree = e, this._BOM = t, this._index = 0, e.root !== xe && e.iterate(e.root, (i) => (i !== xe && this._pieces.push(i.piece), !0));
  }
  read() {
    return this._pieces.length === 0 ? this._index === 0 ? (this._index++, this._BOM) : null : this._index > this._pieces.length - 1 ? null : this._index === 0 ? this._BOM + this._tree.getPieceContent(this._pieces[this._index++]) : this._tree.getPieceContent(this._pieces[this._index++]);
  }
}
class QZ {
  constructor(e) {
    this._limit = e, this._cache = [];
  }
  get(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartOffset <= e && i.nodeStartOffset + i.node.piece.length >= e)
        return i;
    }
    return null;
  }
  get2(e) {
    for (let t = this._cache.length - 1; t >= 0; t--) {
      const i = this._cache[t];
      if (i.nodeStartLineNumber && i.nodeStartLineNumber < e && i.nodeStartLineNumber + i.node.piece.lineFeedCnt >= e)
        return i;
    }
    return null;
  }
  set(e) {
    this._cache.length >= this._limit && this._cache.shift(), this._cache.push(e);
  }
  validate(e) {
    let t = !1;
    const i = this._cache;
    for (let n = 0; n < i.length; n++) {
      const o = i[n];
      if (o.node.parent === null || o.nodeStartOffset >= e) {
        i[n] = null, t = !0;
        continue;
      }
    }
    if (t) {
      const n = [];
      for (const o of i)
        o !== null && n.push(o);
      this._cache = n;
    }
  }
}
class GZ {
  constructor(e, t, i) {
    this.create(e, t, i);
  }
  create(e, t, i) {
    this._buffers = [
      new nh("", [0])
    ], this._lastChangeBufferPos = { line: 0, column: 0 }, this.root = xe, this._lineCnt = 1, this._length = 0, this._EOL = t, this._EOLLength = t.length, this._EOLNormalized = i;
    let n = null;
    for (let o = 0, r = e.length; o < r; o++)
      if (e[o].buffer.length > 0) {
        e[o].lineStarts || (e[o].lineStarts = Za(e[o].buffer));
        const a = new ds(o + 1, { line: 0, column: 0 }, { line: e[o].lineStarts.length - 1, column: e[o].buffer.length - e[o].lineStarts[e[o].lineStarts.length - 1] }, e[o].lineStarts.length - 1, e[o].buffer.length);
        this._buffers.push(e[o]), n = this.rbInsertRight(n, a);
      }
    this._searchCache = new QZ(1), this._lastVisitedLine = { lineNumber: 0, value: "" }, this.computeBufferMetadata();
  }
  normalizeEOL(e) {
    const t = ja, i = t - Math.floor(t / 3), n = i * 2;
    let o = "", r = 0;
    const a = [];
    if (this.iterate(this.root, (l) => {
      const c = this.getNodeContent(l), d = c.length;
      if (r <= i || r + d < n)
        return o += c, r += d, !0;
      const h = o.replace(/\r\n|\r|\n/g, e);
      return a.push(new nh(h, Za(h))), o = c, r = d, !0;
    }), r > 0) {
      const l = o.replace(/\r\n|\r|\n/g, e);
      a.push(new nh(l, Za(l)));
    }
    this.create(a, e, !0);
  }
  // #region Buffer API
  getEOL() {
    return this._EOL;
  }
  setEOL(e) {
    this._EOL = e, this._EOLLength = this._EOL.length, this.normalizeEOL(e);
  }
  createSnapshot(e) {
    return new UZ(this, e);
  }
  getOffsetAt(e, t) {
    let i = 0, n = this.root;
    for (; n !== xe; )
      if (n.left !== xe && n.lf_left + 1 >= e)
        n = n.left;
      else if (n.lf_left + n.piece.lineFeedCnt + 1 >= e) {
        i += n.size_left;
        const o = this.getAccumulatedValue(n, e - n.lf_left - 2);
        return i += o + t - 1;
      } else
        e -= n.lf_left + n.piece.lineFeedCnt, i += n.size_left + n.piece.length, n = n.right;
    return i;
  }
  getPositionAt(e) {
    e = Math.floor(e), e = Math.max(0, e);
    let t = this.root, i = 0;
    const n = e;
    for (; t !== xe; )
      if (t.size_left !== 0 && t.size_left >= e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        const o = this.getIndexOf(t, e - t.size_left);
        if (i += t.lf_left + o.index, o.index === 0) {
          const r = this.getOffsetAt(i + 1, 1), a = n - r;
          return new F(i + 1, a + 1);
        }
        return new F(i + 1, o.remainder + 1);
      } else if (e -= t.size_left + t.piece.length, i += t.lf_left + t.piece.lineFeedCnt, t.right === xe) {
        const o = this.getOffsetAt(i + 1, 1), r = n - e - o;
        return new F(i + 1, r + 1);
      } else
        t = t.right;
    return new F(1, 1);
  }
  getValueInRange(e, t) {
    if (e.startLineNumber === e.endLineNumber && e.startColumn === e.endColumn)
      return "";
    const i = this.nodeAt2(e.startLineNumber, e.startColumn), n = this.nodeAt2(e.endLineNumber, e.endColumn), o = this.getValueInRange2(i, n);
    return t ? t !== this._EOL || !this._EOLNormalized ? o.replace(/\r\n|\r|\n/g, t) : t === this.getEOL() && this._EOLNormalized ? o : o.replace(/\r\n|\r|\n/g, t) : o;
  }
  getValueInRange2(e, t) {
    if (e.node === t.node) {
      const a = e.node, l = this._buffers[a.piece.bufferIndex].buffer, c = this.offsetInBuffer(a.piece.bufferIndex, a.piece.start);
      return l.substring(c + e.remainder, c + t.remainder);
    }
    let i = e.node;
    const n = this._buffers[i.piece.bufferIndex].buffer, o = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
    let r = n.substring(o + e.remainder, o + i.piece.length);
    for (i = i.next(); i !== xe; ) {
      const a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (i === t.node) {
        r += a.substring(l, l + t.remainder);
        break;
      } else
        r += a.substr(l, i.piece.length);
      i = i.next();
    }
    return r;
  }
  getLinesContent() {
    const e = [];
    let t = 0, i = "", n = !1;
    return this.iterate(this.root, (o) => {
      if (o === xe)
        return !0;
      const r = o.piece;
      let a = r.length;
      if (a === 0)
        return !0;
      const l = this._buffers[r.bufferIndex].buffer, c = this._buffers[r.bufferIndex].lineStarts, d = r.start.line, h = r.end.line;
      let u = c[d] + r.start.column;
      if (n && (l.charCodeAt(u) === 10 && (u++, a--), e[t++] = i, i = "", n = !1, a === 0))
        return !0;
      if (d === h)
        return !this._EOLNormalized && l.charCodeAt(u + a - 1) === 13 ? (n = !0, i += l.substr(u, a - 1)) : i += l.substr(u, a), !0;
      i += this._EOLNormalized ? l.substring(u, Math.max(u, c[d + 1] - this._EOLLength)) : l.substring(u, c[d + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      for (let g = d + 1; g < h; g++)
        i = this._EOLNormalized ? l.substring(c[g], c[g + 1] - this._EOLLength) : l.substring(c[g], c[g + 1]).replace(/(\r\n|\r|\n)$/, ""), e[t++] = i;
      return !this._EOLNormalized && l.charCodeAt(c[h] + r.end.column - 1) === 13 ? (n = !0, r.end.column === 0 ? t-- : i = l.substr(c[h], r.end.column - 1)) : i = l.substr(c[h], r.end.column), !0;
    }), n && (e[t++] = i, i = ""), e[t++] = i, e;
  }
  getLength() {
    return this._length;
  }
  getLineCount() {
    return this._lineCnt;
  }
  getLineContent(e) {
    return this._lastVisitedLine.lineNumber === e ? this._lastVisitedLine.value : (this._lastVisitedLine.lineNumber = e, e === this._lineCnt ? this._lastVisitedLine.value = this.getLineRawContent(e) : this._EOLNormalized ? this._lastVisitedLine.value = this.getLineRawContent(e, this._EOLLength) : this._lastVisitedLine.value = this.getLineRawContent(e).replace(/(\r\n|\r|\n)$/, ""), this._lastVisitedLine.value);
  }
  _getCharCode(e) {
    if (e.remainder === e.node.piece.length) {
      const t = e.node.next();
      if (!t)
        return 0;
      const i = this._buffers[t.piece.bufferIndex], n = this.offsetInBuffer(t.piece.bufferIndex, t.piece.start);
      return i.buffer.charCodeAt(n);
    } else {
      const t = this._buffers[e.node.piece.bufferIndex], n = this.offsetInBuffer(e.node.piece.bufferIndex, e.node.piece.start) + e.remainder;
      return t.buffer.charCodeAt(n);
    }
  }
  getLineCharCode(e, t) {
    const i = this.nodeAt2(e, t + 1);
    return this._getCharCode(i);
  }
  getLineLength(e) {
    if (e === this.getLineCount()) {
      const t = this.getOffsetAt(e, 1);
      return this.getLength() - t;
    }
    return this.getOffsetAt(e + 1, 1) - this.getOffsetAt(e, 1) - this._EOLLength;
  }
  findMatchesInNode(e, t, i, n, o, r, a, l, c, d, h) {
    const u = this._buffers[e.piece.bufferIndex], g = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start), m = this.offsetInBuffer(e.piece.bufferIndex, o), p = this.offsetInBuffer(e.piece.bufferIndex, r);
    let A;
    const _ = { line: 0, column: 0 };
    let b, C;
    t._wordSeparators ? (b = u.buffer.substring(m, p), C = (w) => w + m, t.reset(0)) : (b = u.buffer, C = (w) => w, t.reset(m));
    do
      if (A = t.next(b), A) {
        if (C(A.index) >= p)
          return d;
        this.positionInBuffer(e, C(A.index) - g, _);
        const w = this.getLineFeedCnt(e.piece.bufferIndex, o, _), S = _.line === o.line ? _.column - o.column + n : _.column + 1, x = S + A[0].length;
        if (h[d++] = $d(new E(i + w, S, i + w, x), A, l), C(A.index) + A[0].length >= p || d >= c)
          return d;
      }
    while (A);
    return d;
  }
  findMatchesLineByLine(e, t, i, n) {
    const o = [];
    let r = 0;
    const a = new Bg(t.wordSeparators, t.regex);
    let l = this.nodeAt2(e.startLineNumber, e.startColumn);
    if (l === null)
      return [];
    const c = this.nodeAt2(e.endLineNumber, e.endColumn);
    if (c === null)
      return [];
    let d = this.positionInBuffer(l.node, l.remainder);
    const h = this.positionInBuffer(c.node, c.remainder);
    if (l.node === c.node)
      return this.findMatchesInNode(l.node, a, e.startLineNumber, e.startColumn, d, h, t, i, n, r, o), o;
    let u = e.startLineNumber, g = l.node;
    for (; g !== c.node; ) {
      const p = this.getLineFeedCnt(g.piece.bufferIndex, d, g.piece.end);
      if (p >= 1) {
        const _ = this._buffers[g.piece.bufferIndex].lineStarts, b = this.offsetInBuffer(g.piece.bufferIndex, g.piece.start), C = _[d.line + p], w = u === e.startLineNumber ? e.startColumn : 1;
        if (r = this.findMatchesInNode(g, a, u, w, d, this.positionInBuffer(g, C - b), t, i, n, r, o), r >= n)
          return o;
        u += p;
      }
      const A = u === e.startLineNumber ? e.startColumn - 1 : 0;
      if (u === e.endLineNumber) {
        const _ = this.getLineContent(u).substring(A, e.endColumn - 1);
        return r = this._findMatchesInLine(t, a, _, e.endLineNumber, A, r, o, i, n), o;
      }
      if (r = this._findMatchesInLine(t, a, this.getLineContent(u).substr(A), u, A, r, o, i, n), r >= n)
        return o;
      u++, l = this.nodeAt2(u, 1), g = l.node, d = this.positionInBuffer(l.node, l.remainder);
    }
    if (u === e.endLineNumber) {
      const p = u === e.startLineNumber ? e.startColumn - 1 : 0, A = this.getLineContent(u).substring(p, e.endColumn - 1);
      return r = this._findMatchesInLine(t, a, A, e.endLineNumber, p, r, o, i, n), o;
    }
    const m = u === e.startLineNumber ? e.startColumn : 1;
    return r = this.findMatchesInNode(c.node, a, u, m, d, h, t, i, n, r, o), o;
  }
  _findMatchesInLine(e, t, i, n, o, r, a, l, c) {
    const d = e.wordSeparators;
    if (!l && e.simpleSearch) {
      const u = e.simpleSearch, g = u.length, m = i.length;
      let p = -g;
      for (; (p = i.indexOf(u, p + g)) !== -1; )
        if ((!d || rN(d, i, m, p, g)) && (a[r++] = new RA(new E(n, p + 1 + o, n, p + 1 + g + o), null), r >= c))
          return r;
      return r;
    }
    let h;
    t.reset(0);
    do
      if (h = t.next(i), h && (a[r++] = $d(new E(n, h.index + 1 + o, n, h.index + 1 + h[0].length + o), h, l), r >= c))
        return r;
    while (h);
    return r;
  }
  // #endregion
  // #region Piece Table
  insert(e, t, i = !1) {
    if (this._EOLNormalized = this._EOLNormalized && i, this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", this.root !== xe) {
      const { node: n, remainder: o, nodeStartOffset: r } = this.nodeAt(e), a = n.piece, l = a.bufferIndex, c = this.positionInBuffer(n, o);
      if (n.piece.bufferIndex === 0 && a.end.line === this._lastChangeBufferPos.line && a.end.column === this._lastChangeBufferPos.column && r + a.length === e && t.length < ja) {
        this.appendToNode(n, t), this.computeBufferMetadata();
        return;
      }
      if (r === e)
        this.insertContentToNodeLeft(t, n), this._searchCache.validate(e);
      else if (r + n.piece.length > e) {
        const d = [];
        let h = new ds(a.bufferIndex, c, a.end, this.getLineFeedCnt(a.bufferIndex, c, a.end), this.offsetInBuffer(l, a.end) - this.offsetInBuffer(l, c));
        if (this.shouldCheckCRLF() && this.endWithCR(t) && this.nodeCharCodeAt(n, o) === 10) {
          const p = { line: h.start.line + 1, column: 0 };
          h = new ds(h.bufferIndex, p, h.end, this.getLineFeedCnt(h.bufferIndex, p, h.end), h.length - 1), t += `
`;
        }
        if (this.shouldCheckCRLF() && this.startWithLF(t))
          if (this.nodeCharCodeAt(n, o - 1) === 13) {
            const p = this.positionInBuffer(n, o - 1);
            this.deleteNodeTail(n, p), t = "\r" + t, n.piece.length === 0 && d.push(n);
          } else
            this.deleteNodeTail(n, c);
        else
          this.deleteNodeTail(n, c);
        const u = this.createNewPieces(t);
        h.length > 0 && this.rbInsertRight(n, h);
        let g = n;
        for (let m = 0; m < u.length; m++)
          g = this.rbInsertRight(g, u[m]);
        this.deleteNodes(d);
      } else
        this.insertContentToNodeRight(t, n);
    } else {
      const n = this.createNewPieces(t);
      let o = this.rbInsertLeft(null, n[0]);
      for (let r = 1; r < n.length; r++)
        o = this.rbInsertRight(o, n[r]);
    }
    this.computeBufferMetadata();
  }
  delete(e, t) {
    if (this._lastVisitedLine.lineNumber = 0, this._lastVisitedLine.value = "", t <= 0 || this.root === xe)
      return;
    const i = this.nodeAt(e), n = this.nodeAt(e + t), o = i.node, r = n.node;
    if (o === r) {
      const u = this.positionInBuffer(o, i.remainder), g = this.positionInBuffer(o, n.remainder);
      if (i.nodeStartOffset === e) {
        if (t === o.piece.length) {
          const m = o.next();
          Tb(this, o), this.validateCRLFWithPrevNode(m), this.computeBufferMetadata();
          return;
        }
        this.deleteNodeHead(o, g), this._searchCache.validate(e), this.validateCRLFWithPrevNode(o), this.computeBufferMetadata();
        return;
      }
      if (i.nodeStartOffset + o.piece.length === e + t) {
        this.deleteNodeTail(o, u), this.validateCRLFWithNextNode(o), this.computeBufferMetadata();
        return;
      }
      this.shrinkNode(o, u, g), this.computeBufferMetadata();
      return;
    }
    const a = [], l = this.positionInBuffer(o, i.remainder);
    this.deleteNodeTail(o, l), this._searchCache.validate(e), o.piece.length === 0 && a.push(o);
    const c = this.positionInBuffer(r, n.remainder);
    this.deleteNodeHead(r, c), r.piece.length === 0 && a.push(r);
    const d = o.next();
    for (let u = d; u !== xe && u !== r; u = u.next())
      a.push(u);
    const h = o.piece.length === 0 ? o.prev() : o;
    this.deleteNodes(a), this.validateCRLFWithNextNode(h), this.computeBufferMetadata();
  }
  insertContentToNodeLeft(e, t) {
    const i = [];
    if (this.shouldCheckCRLF() && this.endWithCR(e) && this.startWithLF(t)) {
      const r = t.piece, a = { line: r.start.line + 1, column: 0 }, l = new ds(r.bufferIndex, a, r.end, this.getLineFeedCnt(r.bufferIndex, a, r.end), r.length - 1);
      t.piece = l, e += `
`, Xa(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    }
    const n = this.createNewPieces(e);
    let o = this.rbInsertLeft(t, n[n.length - 1]);
    for (let r = n.length - 2; r >= 0; r--)
      o = this.rbInsertLeft(o, n[r]);
    this.validateCRLFWithPrevNode(o), this.deleteNodes(i);
  }
  insertContentToNodeRight(e, t) {
    this.adjustCarriageReturnFromNext(e, t) && (e += `
`);
    const i = this.createNewPieces(e), n = this.rbInsertRight(t, i[0]);
    let o = n;
    for (let r = 1; r < i.length; r++)
      o = this.rbInsertRight(o, i[r]);
    this.validateCRLFWithPrevNode(n);
  }
  positionInBuffer(e, t, i) {
    const n = e.piece, o = e.piece.bufferIndex, r = this._buffers[o].lineStarts, l = r[n.start.line] + n.start.column + t;
    let c = n.start.line, d = n.end.line, h = 0, u = 0, g = 0;
    for (; c <= d && (h = c + (d - c) / 2 | 0, g = r[h], h !== d); )
      if (u = r[h + 1], l < g)
        d = h - 1;
      else if (l >= u)
        c = h + 1;
      else
        break;
    return i ? (i.line = h, i.column = l - g, null) : {
      line: h,
      column: l - g
    };
  }
  getLineFeedCnt(e, t, i) {
    if (i.column === 0)
      return i.line - t.line;
    const n = this._buffers[e].lineStarts;
    if (i.line === n.length - 1)
      return i.line - t.line;
    const o = n[i.line + 1], r = n[i.line] + i.column;
    if (o > r + 1)
      return i.line - t.line;
    const a = r - 1;
    return this._buffers[e].buffer.charCodeAt(a) === 13 ? i.line - t.line + 1 : i.line - t.line;
  }
  offsetInBuffer(e, t) {
    return this._buffers[e].lineStarts[t.line] + t.column;
  }
  deleteNodes(e) {
    for (let t = 0; t < e.length; t++)
      Tb(this, e[t]);
  }
  createNewPieces(e) {
    if (e.length > ja) {
      const d = [];
      for (; e.length > ja; ) {
        const u = e.charCodeAt(ja - 1);
        let g;
        u === 13 || u >= 55296 && u <= 56319 ? (g = e.substring(0, ja - 1), e = e.substring(ja - 1)) : (g = e.substring(0, ja), e = e.substring(ja));
        const m = Za(g);
        d.push(new ds(
          this._buffers.length,
          /* buffer index */
          { line: 0, column: 0 },
          { line: m.length - 1, column: g.length - m[m.length - 1] },
          m.length - 1,
          g.length
        )), this._buffers.push(new nh(g, m));
      }
      const h = Za(e);
      return d.push(new ds(
        this._buffers.length,
        /* buffer index */
        { line: 0, column: 0 },
        { line: h.length - 1, column: e.length - h[h.length - 1] },
        h.length - 1,
        e.length
      )), this._buffers.push(new nh(e, h)), d;
    }
    let t = this._buffers[0].buffer.length;
    const i = Za(e, !1);
    let n = this._lastChangeBufferPos;
    if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === t && t !== 0 && this.startWithLF(e) && this.endWithCR(this._buffers[0].buffer)) {
      this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 }, n = this._lastChangeBufferPos;
      for (let d = 0; d < i.length; d++)
        i[d] += t + 1;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += "_" + e, t += 1;
    } else {
      if (t !== 0)
        for (let d = 0; d < i.length; d++)
          i[d] += t;
      this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(i.slice(1)), this._buffers[0].buffer += e;
    }
    const o = this._buffers[0].buffer.length, r = this._buffers[0].lineStarts.length - 1, a = o - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = new ds(
      0,
      /** todo@peng */
      n,
      l,
      this.getLineFeedCnt(0, n, l),
      o - t
    );
    return this._lastChangeBufferPos = l, [c];
  }
  getLineRawContent(e, t = 0) {
    let i = this.root, n = "";
    const o = this._searchCache.get2(e);
    if (o) {
      i = o.node;
      const r = this.getAccumulatedValue(i, e - o.nodeStartLineNumber - 1), a = this._buffers[i.piece.bufferIndex].buffer, l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
      if (o.nodeStartLineNumber + i.piece.lineFeedCnt === e)
        n = a.substring(l + r, l + i.piece.length);
      else {
        const c = this.getAccumulatedValue(i, e - o.nodeStartLineNumber);
        return a.substring(l + r, l + c - t);
      }
    } else {
      let r = 0;
      const a = e;
      for (; i !== xe; )
        if (i.left !== xe && i.lf_left >= e - 1)
          i = i.left;
        else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this.getAccumulatedValue(i, e - i.lf_left - 1), d = this._buffers[i.piece.bufferIndex].buffer, h = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          return r += i.size_left, this._searchCache.set({
            node: i,
            nodeStartOffset: r,
            nodeStartLineNumber: a - (e - 1 - i.lf_left)
          }), d.substring(h + l, h + c - t);
        } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
          const l = this.getAccumulatedValue(i, e - i.lf_left - 2), c = this._buffers[i.piece.bufferIndex].buffer, d = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
          n = c.substring(d + l, d + i.piece.length);
          break;
        } else
          e -= i.lf_left + i.piece.lineFeedCnt, r += i.size_left + i.piece.length, i = i.right;
    }
    for (i = i.next(); i !== xe; ) {
      const r = this._buffers[i.piece.bufferIndex].buffer;
      if (i.piece.lineFeedCnt > 0) {
        const a = this.getAccumulatedValue(i, 0), l = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        return n += r.substring(l, l + a - t), n;
      } else {
        const a = this.offsetInBuffer(i.piece.bufferIndex, i.piece.start);
        n += r.substr(a, i.piece.length);
      }
      i = i.next();
    }
    return n;
  }
  computeBufferMetadata() {
    let e = this.root, t = 1, i = 0;
    for (; e !== xe; )
      t += e.lf_left + e.piece.lineFeedCnt, i += e.size_left + e.piece.length, e = e.right;
    this._lineCnt = t, this._length = i, this._searchCache.validate(this._length);
  }
  // #region node operations
  getIndexOf(e, t) {
    const i = e.piece, n = this.positionInBuffer(e, t), o = n.line - i.start.line;
    if (this.offsetInBuffer(i.bufferIndex, i.end) - this.offsetInBuffer(i.bufferIndex, i.start) === t) {
      const r = this.getLineFeedCnt(e.piece.bufferIndex, i.start, n);
      if (r !== o)
        return { index: r, remainder: 0 };
    }
    return { index: o, remainder: n.column };
  }
  getAccumulatedValue(e, t) {
    if (t < 0)
      return 0;
    const i = e.piece, n = this._buffers[i.bufferIndex].lineStarts, o = i.start.line + t + 1;
    return o > i.end.line ? n[i.end.line] + i.end.column - n[i.start.line] - i.start.column : n[o] - n[i.start.line] - i.start.column;
  }
  deleteNodeTail(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.end), r = t, a = this.offsetInBuffer(i.bufferIndex, r), l = this.getLineFeedCnt(i.bufferIndex, i.start, r), c = l - n, d = a - o, h = i.length + d;
    e.piece = new ds(i.bufferIndex, i.start, r, l, h), Xa(this, e, d, c);
  }
  deleteNodeHead(e, t) {
    const i = e.piece, n = i.lineFeedCnt, o = this.offsetInBuffer(i.bufferIndex, i.start), r = t, a = this.getLineFeedCnt(i.bufferIndex, r, i.end), l = this.offsetInBuffer(i.bufferIndex, r), c = a - n, d = o - l, h = i.length + d;
    e.piece = new ds(i.bufferIndex, r, i.end, a, h), Xa(this, e, d, c);
  }
  shrinkNode(e, t, i) {
    const n = e.piece, o = n.start, r = n.end, a = n.length, l = n.lineFeedCnt, c = t, d = this.getLineFeedCnt(n.bufferIndex, n.start, c), h = this.offsetInBuffer(n.bufferIndex, t) - this.offsetInBuffer(n.bufferIndex, o);
    e.piece = new ds(n.bufferIndex, n.start, c, d, h), Xa(this, e, h - a, d - l);
    const u = new ds(n.bufferIndex, i, r, this.getLineFeedCnt(n.bufferIndex, i, r), this.offsetInBuffer(n.bufferIndex, r) - this.offsetInBuffer(n.bufferIndex, i)), g = this.rbInsertRight(e, u);
    this.validateCRLFWithPrevNode(g);
  }
  appendToNode(e, t) {
    this.adjustCarriageReturnFromNext(t, e) && (t += `
`);
    const i = this.shouldCheckCRLF() && this.startWithLF(t) && this.endWithCR(e), n = this._buffers[0].buffer.length;
    this._buffers[0].buffer += t;
    const o = Za(t, !1);
    for (let g = 0; g < o.length; g++)
      o[g] += n;
    if (i) {
      const g = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];
      this._buffers[0].lineStarts.pop(), this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: n - g };
    }
    this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(o.slice(1));
    const r = this._buffers[0].lineStarts.length - 1, a = this._buffers[0].buffer.length - this._buffers[0].lineStarts[r], l = { line: r, column: a }, c = e.piece.length + t.length, d = e.piece.lineFeedCnt, h = this.getLineFeedCnt(0, e.piece.start, l), u = h - d;
    e.piece = new ds(e.piece.bufferIndex, e.piece.start, l, h, c), this._lastChangeBufferPos = l, Xa(this, e, t.length, u);
  }
  nodeAt(e) {
    let t = this.root;
    const i = this._searchCache.get(e);
    if (i)
      return {
        node: i.node,
        nodeStartOffset: i.nodeStartOffset,
        remainder: e - i.nodeStartOffset
      };
    let n = 0;
    for (; t !== xe; )
      if (t.size_left > e)
        t = t.left;
      else if (t.size_left + t.piece.length >= e) {
        n += t.size_left;
        const o = {
          node: t,
          remainder: e - t.size_left,
          nodeStartOffset: n
        };
        return this._searchCache.set(o), o;
      } else
        e -= t.size_left + t.piece.length, n += t.size_left + t.piece.length, t = t.right;
    return null;
  }
  nodeAt2(e, t) {
    let i = this.root, n = 0;
    for (; i !== xe; )
      if (i.left !== xe && i.lf_left >= e - 1)
        i = i.left;
      else if (i.lf_left + i.piece.lineFeedCnt > e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2), r = this.getAccumulatedValue(i, e - i.lf_left - 1);
        return n += i.size_left, {
          node: i,
          remainder: Math.min(o + t - 1, r),
          nodeStartOffset: n
        };
      } else if (i.lf_left + i.piece.lineFeedCnt === e - 1) {
        const o = this.getAccumulatedValue(i, e - i.lf_left - 2);
        if (o + t - 1 <= i.piece.length)
          return {
            node: i,
            remainder: o + t - 1,
            nodeStartOffset: n
          };
        t -= i.piece.length - o;
        break;
      } else
        e -= i.lf_left + i.piece.lineFeedCnt, n += i.size_left + i.piece.length, i = i.right;
    for (i = i.next(); i !== xe; ) {
      if (i.piece.lineFeedCnt > 0) {
        const o = this.getAccumulatedValue(i, 0), r = this.offsetOfNode(i);
        return {
          node: i,
          remainder: Math.min(t - 1, o),
          nodeStartOffset: r
        };
      } else if (i.piece.length >= t - 1) {
        const o = this.offsetOfNode(i);
        return {
          node: i,
          remainder: t - 1,
          nodeStartOffset: o
        };
      } else
        t -= i.piece.length;
      i = i.next();
    }
    return null;
  }
  nodeCharCodeAt(e, t) {
    if (e.piece.lineFeedCnt < 1)
      return -1;
    const i = this._buffers[e.piece.bufferIndex], n = this.offsetInBuffer(e.piece.bufferIndex, e.piece.start) + t;
    return i.buffer.charCodeAt(n);
  }
  offsetOfNode(e) {
    if (!e)
      return 0;
    let t = e.size_left;
    for (; e !== this.root; )
      e.parent.right === e && (t += e.parent.size_left + e.parent.piece.length), e = e.parent;
    return t;
  }
  // #endregion
  // #region CRLF
  shouldCheckCRLF() {
    return !(this._EOLNormalized && this._EOL === `
`);
  }
  startWithLF(e) {
    if (typeof e == "string")
      return e.charCodeAt(0) === 10;
    if (e === xe || e.piece.lineFeedCnt === 0)
      return !1;
    const t = e.piece, i = this._buffers[t.bufferIndex].lineStarts, n = t.start.line, o = i[n] + t.start.column;
    return n === i.length - 1 || i[n + 1] > o + 1 ? !1 : this._buffers[t.bufferIndex].buffer.charCodeAt(o) === 10;
  }
  endWithCR(e) {
    return typeof e == "string" ? e.charCodeAt(e.length - 1) === 13 : e === xe || e.piece.lineFeedCnt === 0 ? !1 : this.nodeCharCodeAt(e, e.piece.length - 1) === 13;
  }
  validateCRLFWithPrevNode(e) {
    if (this.shouldCheckCRLF() && this.startWithLF(e)) {
      const t = e.prev();
      this.endWithCR(t) && this.fixCRLF(t, e);
    }
  }
  validateCRLFWithNextNode(e) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const t = e.next();
      this.startWithLF(t) && this.fixCRLF(e, t);
    }
  }
  fixCRLF(e, t) {
    const i = [], n = this._buffers[e.piece.bufferIndex].lineStarts;
    let o;
    e.piece.end.column === 0 ? o = { line: e.piece.end.line - 1, column: n[e.piece.end.line] - n[e.piece.end.line - 1] - 1 } : o = { line: e.piece.end.line, column: e.piece.end.column - 1 };
    const r = e.piece.length - 1, a = e.piece.lineFeedCnt - 1;
    e.piece = new ds(e.piece.bufferIndex, e.piece.start, o, a, r), Xa(this, e, -1, -1), e.piece.length === 0 && i.push(e);
    const l = { line: t.piece.start.line + 1, column: 0 }, c = t.piece.length - 1, d = this.getLineFeedCnt(t.piece.bufferIndex, l, t.piece.end);
    t.piece = new ds(t.piece.bufferIndex, l, t.piece.end, d, c), Xa(this, t, -1, -1), t.piece.length === 0 && i.push(t);
    const h = this.createNewPieces(`\r
`);
    this.rbInsertRight(e, h[0]);
    for (let u = 0; u < i.length; u++)
      Tb(this, i[u]);
  }
  adjustCarriageReturnFromNext(e, t) {
    if (this.shouldCheckCRLF() && this.endWithCR(e)) {
      const i = t.next();
      if (this.startWithLF(i)) {
        if (e += `
`, i.piece.length === 1)
          Tb(this, i);
        else {
          const n = i.piece, o = { line: n.start.line + 1, column: 0 }, r = n.length - 1, a = this.getLineFeedCnt(n.bufferIndex, o, n.end);
          i.piece = new ds(n.bufferIndex, o, n.end, a, r), Xa(this, i, -1, -1);
        }
        return !0;
      }
    }
    return !1;
  }
  // #endregion
  // #endregion
  // #region Tree operations
  iterate(e, t) {
    if (e === xe)
      return t(xe);
    const i = this.iterate(e.left, t);
    return i && t(e) && this.iterate(e.right, t);
  }
  getNodeContent(e) {
    if (e === xe)
      return "";
    const t = this._buffers[e.piece.bufferIndex], i = e.piece, n = this.offsetInBuffer(i.bufferIndex, i.start), o = this.offsetInBuffer(i.bufferIndex, i.end);
    return t.buffer.substring(n, o);
  }
  getPieceContent(e) {
    const t = this._buffers[e.bufferIndex], i = this.offsetInBuffer(e.bufferIndex, e.start), n = this.offsetInBuffer(e.bufferIndex, e.end);
    return t.buffer.substring(i, n);
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b    <----   a    b
   *                         /
   *                        z
   */
  rbInsertRight(e, t) {
    const i = new Ak(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = xe, i.right = xe, i.parent = xe, i.size_left = 0, i.lf_left = 0, this.root === xe)
      this.root = i, i.color = 0;
    else if (e.right === xe)
      e.right = i, i.parent = e;
    else {
      const o = eT(e.right);
      o.left = i, i.parent = o;
    }
    return TF(this, i), i;
  }
  /**
   *      node              node
   *     /  \              /  \
   *    a   b     ---->   a    b
   *                       \
   *                        z
   */
  rbInsertLeft(e, t) {
    const i = new Ak(
      t,
      1
      /* NodeColor.Red */
    );
    if (i.left = xe, i.right = xe, i.parent = xe, i.size_left = 0, i.lf_left = 0, this.root === xe)
      this.root = i, i.color = 0;
    else if (e.left === xe)
      e.left = i, i.parent = e;
    else {
      const n = bW(e.left);
      n.right = i, i.parent = n;
    }
    return TF(this, i), i;
  }
}
class xf extends V {
  constructor(e, t, i, n, o, r, a) {
    super(), this._onDidChangeContent = this._register(new B()), this._BOM = t, this._mightContainNonBasicASCII = !r, this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._pieceTree = new GZ(e, i, a);
  }
  mightContainRTL() {
    return this._mightContainRTL;
  }
  mightContainUnusualLineTerminators() {
    return this._mightContainUnusualLineTerminators;
  }
  resetMightContainUnusualLineTerminators() {
    this._mightContainUnusualLineTerminators = !1;
  }
  mightContainNonBasicASCII() {
    return this._mightContainNonBasicASCII;
  }
  getBOM() {
    return this._BOM;
  }
  getEOL() {
    return this._pieceTree.getEOL();
  }
  createSnapshot(e) {
    return this._pieceTree.createSnapshot(e ? this._BOM : "");
  }
  getOffsetAt(e, t) {
    return this._pieceTree.getOffsetAt(e, t);
  }
  getPositionAt(e) {
    return this._pieceTree.getPositionAt(e);
  }
  getRangeAt(e, t) {
    const i = e + t, n = this.getPositionAt(e), o = this.getPositionAt(i);
    return new E(n.lineNumber, n.column, o.lineNumber, o.column);
  }
  getValueInRange(e, t = 0) {
    if (e.isEmpty())
      return "";
    const i = this._getEndOfLine(t);
    return this._pieceTree.getValueInRange(e, i);
  }
  getValueLengthInRange(e, t = 0) {
    if (e.isEmpty())
      return 0;
    if (e.startLineNumber === e.endLineNumber)
      return e.endColumn - e.startColumn;
    const i = this.getOffsetAt(e.startLineNumber, e.startColumn), n = this.getOffsetAt(e.endLineNumber, e.endColumn);
    let o = 0;
    const r = this._getEndOfLine(t), a = this.getEOL();
    if (r.length !== a.length) {
      const l = r.length - a.length, c = e.endLineNumber - e.startLineNumber;
      o = l * c;
    }
    return n - i + o;
  }
  getCharacterCountInRange(e, t = 0) {
    if (this._mightContainNonBasicASCII) {
      let i = 0;
      const n = e.startLineNumber, o = e.endLineNumber;
      for (let r = n; r <= o; r++) {
        const a = this.getLineContent(r), l = r === n ? e.startColumn - 1 : 0, c = r === o ? e.endColumn - 1 : a.length;
        for (let d = l; d < c; d++)
          Si(a.charCodeAt(d)) ? (i = i + 1, d = d + 1) : i = i + 1;
      }
      return i += this._getEndOfLine(t).length * (o - n), i;
    }
    return this.getValueLengthInRange(e, t);
  }
  getLength() {
    return this._pieceTree.getLength();
  }
  getLineCount() {
    return this._pieceTree.getLineCount();
  }
  getLinesContent() {
    return this._pieceTree.getLinesContent();
  }
  getLineContent(e) {
    return this._pieceTree.getLineContent(e);
  }
  getLineCharCode(e, t) {
    return this._pieceTree.getLineCharCode(e, t);
  }
  getLineLength(e) {
    return this._pieceTree.getLineLength(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Sn(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ru(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  _getEndOfLine(e) {
    switch (e) {
      case 1:
        return `
`;
      case 2:
        return `\r
`;
      case 0:
        return this.getEOL();
      default:
        throw new Error("Unknown EOL preference");
    }
  }
  setEOL(e) {
    this._pieceTree.setEOL(e);
  }
  applyEdits(e, t, i) {
    let n = this._mightContainRTL, o = this._mightContainUnusualLineTerminators, r = this._mightContainNonBasicASCII, a = !0, l = [];
    for (let p = 0; p < e.length; p++) {
      const A = e[p];
      a && A._isTracked && (a = !1);
      const _ = A.range;
      if (A.text) {
        let x = !0;
        r || (x = !WM(A.text), r = x), !n && x && (n = DA(A.text)), !o && x && (o = CH(A.text));
      }
      let b = "", C = 0, w = 0, S = 0;
      if (A.text) {
        let x;
        [C, w, S, x] = bu(A.text);
        const y = this.getEOL();
        x === 0 || x === (y === `\r
` ? 2 : 1) ? b = A.text : b = A.text.replace(/\r\n|\r|\n/g, y);
      }
      l[p] = {
        sortIndex: p,
        identifier: A.identifier || null,
        range: _,
        rangeOffset: this.getOffsetAt(_.startLineNumber, _.startColumn),
        rangeLength: this.getValueLengthInRange(_),
        text: b,
        eolCount: C,
        firstLineLength: w,
        lastLineLength: S,
        forceMoveMarkers: !!A.forceMoveMarkers,
        isAutoWhitespaceEdit: A.isAutoWhitespaceEdit || !1
      };
    }
    l.sort(xf._sortOpsAscending);
    let c = !1;
    for (let p = 0, A = l.length - 1; p < A; p++) {
      const _ = l[p].range.getEndPosition(), b = l[p + 1].range.getStartPosition();
      if (b.isBeforeOrEqual(_)) {
        if (b.isBefore(_))
          throw new Error("Overlapping ranges are not allowed!");
        c = !0;
      }
    }
    a && (l = this._reduceOperations(l));
    const d = i || t ? xf._getInverseEditRanges(l) : [], h = [];
    if (t)
      for (let p = 0; p < l.length; p++) {
        const A = l[p], _ = d[p];
        if (A.isAutoWhitespaceEdit && A.range.isEmpty())
          for (let b = _.startLineNumber; b <= _.endLineNumber; b++) {
            let C = "";
            b === _.startLineNumber && (C = this.getLineContent(A.range.startLineNumber), Sn(C) !== -1) || h.push({ lineNumber: b, oldContent: C });
          }
      }
    let u = null;
    if (i) {
      let p = 0;
      u = [];
      for (let A = 0; A < l.length; A++) {
        const _ = l[A], b = d[A], C = this.getValueInRange(_.range), w = _.rangeOffset + p;
        p += _.text.length - C.length, u[A] = {
          sortIndex: _.sortIndex,
          identifier: _.identifier,
          range: b,
          text: C,
          textChange: new Xi(_.rangeOffset, C, w, _.text)
        };
      }
      c || u.sort((A, _) => A.sortIndex - _.sortIndex);
    }
    this._mightContainRTL = n, this._mightContainUnusualLineTerminators = o, this._mightContainNonBasicASCII = r;
    const g = this._doApplyEdits(l);
    let m = null;
    if (t && h.length > 0) {
      h.sort((p, A) => A.lineNumber - p.lineNumber), m = [];
      for (let p = 0, A = h.length; p < A; p++) {
        const _ = h[p].lineNumber;
        if (p > 0 && h[p - 1].lineNumber === _)
          continue;
        const b = h[p].oldContent, C = this.getLineContent(_);
        C.length === 0 || C === b || Sn(C) !== -1 || m.push(_);
      }
    }
    return this._onDidChangeContent.fire(), new KQ(u, g, m);
  }
  /**
   * Transform operations such that they represent the same logic edit,
   * but that they also do not cause OOM crashes.
   */
  _reduceOperations(e) {
    return e.length < 1e3 ? e : [this._toSingleEditOperation(e)];
  }
  _toSingleEditOperation(e) {
    let t = !1;
    const i = e[0].range, n = e[e.length - 1].range, o = new E(i.startLineNumber, i.startColumn, n.endLineNumber, n.endColumn);
    let r = i.startLineNumber, a = i.startColumn;
    const l = [];
    for (let g = 0, m = e.length; g < m; g++) {
      const p = e[g], A = p.range;
      t = t || p.forceMoveMarkers, l.push(this.getValueInRange(new E(r, a, A.startLineNumber, A.startColumn))), p.text.length > 0 && l.push(p.text), r = A.endLineNumber, a = A.endColumn;
    }
    const c = l.join(""), [d, h, u] = bu(c);
    return {
      sortIndex: 0,
      identifier: e[0].identifier,
      range: o,
      rangeOffset: this.getOffsetAt(o.startLineNumber, o.startColumn),
      rangeLength: this.getValueLengthInRange(
        o,
        0
        /* EndOfLinePreference.TextDefined */
      ),
      text: c,
      eolCount: d,
      firstLineLength: h,
      lastLineLength: u,
      forceMoveMarkers: t,
      isAutoWhitespaceEdit: !1
    };
  }
  _doApplyEdits(e) {
    e.sort(xf._sortOpsDescending);
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i], o = n.range.startLineNumber, r = n.range.startColumn, a = n.range.endLineNumber, l = n.range.endColumn;
      if (o === a && r === l && n.text.length === 0)
        continue;
      n.text ? (this._pieceTree.delete(n.rangeOffset, n.rangeLength), this._pieceTree.insert(n.rangeOffset, n.text, !0)) : this._pieceTree.delete(n.rangeOffset, n.rangeLength);
      const c = new E(o, r, a, l);
      t.push({
        range: c,
        rangeLength: n.rangeLength,
        text: n.text,
        rangeOffset: n.rangeOffset,
        forceMoveMarkers: n.forceMoveMarkers
      });
    }
    return t;
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._pieceTree.findMatchesLineByLine(e, t, i, n);
  }
  /**
   * Assumes `operations` are validated and sorted ascending
   */
  static _getInverseEditRanges(e) {
    const t = [];
    let i = 0, n = 0, o = null;
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      let c, d;
      o ? o.range.endLineNumber === l.range.startLineNumber ? (c = i, d = n + (l.range.startColumn - o.range.endColumn)) : (c = i + (l.range.startLineNumber - o.range.endLineNumber), d = l.range.startColumn) : (c = l.range.startLineNumber, d = l.range.startColumn);
      let h;
      if (l.text.length > 0) {
        const u = l.eolCount + 1;
        u === 1 ? h = new E(c, d, c, d + l.firstLineLength) : h = new E(c, d, c + u - 1, l.lastLineLength + 1);
      } else
        h = new E(c, d, c, d);
      i = h.endLineNumber, n = h.endColumn, t.push(h), o = l;
    }
    return t;
  }
  static _sortOpsAscending(e, t) {
    const i = E.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? e.sortIndex - t.sortIndex : i;
  }
  static _sortOpsDescending(e, t) {
    const i = E.compareRangesUsingEnds(e.range, t.range);
    return i === 0 ? t.sortIndex - e.sortIndex : -i;
  }
}
class jZ {
  constructor(e, t, i, n, o, r, a, l, c) {
    this._chunks = e, this._bom = t, this._cr = i, this._lf = n, this._crlf = o, this._containsRTL = r, this._containsUnusualLineTerminators = a, this._isBasicASCII = l, this._normalizeEOL = c;
  }
  _getEOL(e) {
    const t = this._cr + this._lf + this._crlf, i = this._cr + this._crlf;
    return t === 0 ? e === 1 ? `
` : `\r
` : i > t / 2 ? `\r
` : `
`;
  }
  create(e) {
    const t = this._getEOL(e), i = this._chunks;
    if (this._normalizeEOL && (t === `\r
` && (this._cr > 0 || this._lf > 0) || t === `
` && (this._cr > 0 || this._crlf > 0)))
      for (let o = 0, r = i.length; o < r; o++) {
        const a = i[o].buffer.replace(/\r\n|\r|\n/g, t), l = Za(a);
        i[o] = new nh(a, l);
      }
    const n = new xf(i, this._bom, t, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);
    return { textBuffer: n, disposable: n };
  }
}
class CW {
  constructor() {
    this.chunks = [], this.BOM = "", this._hasPreviousChar = !1, this._previousChar = 0, this._tmpLineStarts = [], this.cr = 0, this.lf = 0, this.crlf = 0, this.containsRTL = !1, this.containsUnusualLineTerminators = !1, this.isBasicASCII = !0;
  }
  acceptChunk(e) {
    if (e.length === 0)
      return;
    this.chunks.length === 0 && zM(e) && (this.BOM = F7, e = e.substr(1));
    const t = e.charCodeAt(e.length - 1);
    t === 13 || t >= 55296 && t <= 56319 ? (this._acceptChunk1(e.substr(0, e.length - 1), !1), this._hasPreviousChar = !0, this._previousChar = t) : (this._acceptChunk1(e, !1), this._hasPreviousChar = !1, this._previousChar = t);
  }
  _acceptChunk1(e, t) {
    !t && e.length === 0 || (this._hasPreviousChar ? this._acceptChunk2(String.fromCharCode(this._previousChar) + e) : this._acceptChunk2(e));
  }
  _acceptChunk2(e) {
    const t = zZ(this._tmpLineStarts, e);
    this.chunks.push(new nh(e, t.lineStarts)), this.cr += t.cr, this.lf += t.lf, this.crlf += t.crlf, t.isBasicASCII || (this.isBasicASCII = !1, this.containsRTL || (this.containsRTL = DA(e)), this.containsUnusualLineTerminators || (this.containsUnusualLineTerminators = CH(e)));
  }
  finish(e = !0) {
    return this._finish(), new jZ(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, e);
  }
  _finish() {
    if (this.chunks.length === 0 && this._acceptChunk1("", !0), this._hasPreviousChar) {
      this._hasPreviousChar = !1;
      const e = this.chunks[this.chunks.length - 1];
      e.buffer += String.fromCharCode(this._previousChar);
      const t = Za(e.buffer);
      e.lineStarts = t, this._previousChar === 13 && this.cr++;
    }
  }
}
class YZ {
  constructor(e) {
    this._default = e, this._store = [];
  }
  get(e) {
    return e < this._store.length ? this._store[e] : this._default;
  }
  set(e, t) {
    for (; e >= this._store.length; )
      this._store[this._store.length] = this._default;
    this._store[e] = t;
  }
  replace(e, t, i) {
    if (e >= this._store.length)
      return;
    if (t === 0) {
      this.insert(e, i);
      return;
    } else if (i === 0) {
      this.delete(e, t);
      return;
    }
    const n = this._store.slice(0, e), o = this._store.slice(e + t), r = KZ(i, this._default);
    this._store = n.concat(r, o);
  }
  delete(e, t) {
    t === 0 || e >= this._store.length || this._store.splice(e, t);
  }
  insert(e, t) {
    if (t === 0 || e >= this._store.length)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = this._default;
    this._store = f0(this._store, e, i);
  }
}
function KZ(s, e) {
  const t = [];
  for (let i = 0; i < s; i++)
    t[i] = e;
  return t;
}
class JZ {
  /**
   * (Inclusive) start line number for these tokens.
   */
  get startLineNumber() {
    return this._startLineNumber;
  }
  /**
   * (Inclusive) end line number for these tokens.
   */
  get endLineNumber() {
    return this._startLineNumber + this._tokens.length - 1;
  }
  constructor(e, t) {
    this._startLineNumber = e, this._tokens = t;
  }
  /**
   * @see {@link _tokens}
   */
  getLineTokens(e) {
    return this._tokens[e - this._startLineNumber];
  }
  appendLineTokens(e) {
    this._tokens.push(e);
  }
}
class _k {
  constructor() {
    this._tokens = [];
  }
  add(e, t) {
    if (this._tokens.length > 0) {
      const i = this._tokens[this._tokens.length - 1];
      if (i.endLineNumber + 1 === e) {
        i.appendLineTokens(t);
        return;
      }
    }
    this._tokens.push(new JZ(e, [t]));
  }
  finalize() {
    return this._tokens;
  }
}
class qZ {
  constructor(e, t) {
    this.tokenizationSupport = t, this.initialState = this.tokenizationSupport.getInitialState(), this.store = new bk(e);
  }
  getStartState(e) {
    return this.store.getStartState(e, this.initialState);
  }
  getFirstInvalidLine() {
    return this.store.getFirstInvalidLine(this.initialState);
  }
}
class $Z extends qZ {
  constructor(e, t, i, n) {
    super(e, t), this._textModel = i, this._languageIdCodec = n;
  }
  updateTokensUntilLine(e, t) {
    const i = this._textModel.getLanguageId();
    for (; ; ) {
      const n = this.getFirstInvalidLine();
      if (!n || n.lineNumber > t)
        break;
      const o = this._textModel.getLineContent(n.lineNumber), r = Zm(this._languageIdCodec, i, this.tokenizationSupport, o, !0, n.startState);
      e.add(n.lineNumber, r.tokens), this.store.setEndState(n.lineNumber, r.endState);
    }
  }
  /** assumes state is up to date */
  getTokenTypeIfInsertingCharacter(e, t) {
    const i = this.getStartState(e.lineNumber);
    if (!i)
      return 0;
    const n = this._textModel.getLanguageId(), o = this._textModel.getLineContent(e.lineNumber), r = o.substring(0, e.column - 1) + t + o.substring(e.column - 1), a = Zm(this._languageIdCodec, n, this.tokenizationSupport, r, !0, i), l = new Gi(a.tokens, r, this._languageIdCodec);
    if (l.getCount() === 0)
      return 0;
    const c = l.findTokenIndexAtOffset(e.column - 1);
    return l.getStandardTokenType(c);
  }
  /** assumes state is up to date */
  tokenizeLineWithEdit(e, t, i) {
    const n = e.lineNumber, o = e.column, r = this.getStartState(n);
    if (!r)
      return null;
    const a = this._textModel.getLineContent(n), l = a.substring(0, o - 1) + i + a.substring(o - 1 + t), c = this._textModel.getLanguageIdAtPosition(n, 0), d = Zm(this._languageIdCodec, c, this.tokenizationSupport, l, !0, r);
    return new Gi(d.tokens, l, this._languageIdCodec);
  }
  hasAccurateTokensForLine(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t;
  }
  isCheapToTokenize(e) {
    const t = this.store.getFirstInvalidEndStateLineNumberOrMax();
    return e < t || e === t && this._textModel.getLineLength(e) < 2048;
  }
  /**
   * The result is not cached.
   */
  tokenizeHeuristically(e, t, i) {
    if (i <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return { heuristicTokens: !1 };
    if (t <= this.store.getFirstInvalidEndStateLineNumberOrMax())
      return this.updateTokensUntilLine(e, i), { heuristicTokens: !1 };
    let n = this.guessStartState(t);
    const o = this._textModel.getLanguageId();
    for (let r = t; r <= i; r++) {
      const a = this._textModel.getLineContent(r), l = Zm(this._languageIdCodec, o, this.tokenizationSupport, a, !0, n);
      e.add(r, l.tokens), n = l.endState;
    }
    return { heuristicTokens: !0 };
  }
  guessStartState(e) {
    let t = this._textModel.getLineFirstNonWhitespaceColumn(e);
    const i = [];
    let n = null;
    for (let a = e - 1; t > 1 && a >= 1; a--) {
      const l = this._textModel.getLineFirstNonWhitespaceColumn(a);
      if (l !== 0 && l < t && (i.push(this._textModel.getLineContent(a)), t = l, n = this.getStartState(a), n))
        break;
    }
    n || (n = this.tokenizationSupport.getInitialState()), i.reverse();
    const o = this._textModel.getLanguageId();
    let r = n;
    for (const a of i)
      r = Zm(this._languageIdCodec, o, this.tokenizationSupport, a, !1, r).endState;
    return r;
  }
}
class bk {
  constructor(e) {
    this.lineCount = e, this._tokenizationStateStore = new XZ(), this._invalidEndStatesLineNumbers = new ZZ(), this._invalidEndStatesLineNumbers.addRange(new Be(1, e + 1));
  }
  getEndState(e) {
    return this._tokenizationStateStore.getEndState(e);
  }
  /**
   * @returns if the end state has changed.
   */
  setEndState(e, t) {
    if (!t)
      throw new lt("Cannot set null/undefined state");
    this._invalidEndStatesLineNumbers.delete(e);
    const i = this._tokenizationStateStore.setEndState(e, t);
    return i && e < this.lineCount && this._invalidEndStatesLineNumbers.addRange(new Be(e + 1, e + 2)), i;
  }
  acceptChange(e, t) {
    this.lineCount += t - e.length, this._tokenizationStateStore.acceptChange(e, t), this._invalidEndStatesLineNumbers.addRangeAndResize(new Be(e.startLineNumber, e.endLineNumberExclusive), t);
  }
  acceptChanges(e) {
    for (const t of e) {
      const [i] = bu(t.text);
      this.acceptChange(new Ee(t.range.startLineNumber, t.range.endLineNumber + 1), i + 1);
    }
  }
  invalidateEndStateRange(e) {
    this._invalidEndStatesLineNumbers.addRange(new Be(e.startLineNumber, e.endLineNumberExclusive));
  }
  getFirstInvalidEndStateLineNumber() {
    return this._invalidEndStatesLineNumbers.min;
  }
  getFirstInvalidEndStateLineNumberOrMax() {
    return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;
  }
  allStatesValid() {
    return this._invalidEndStatesLineNumbers.min === null;
  }
  getStartState(e, t) {
    return e === 1 ? t : this.getEndState(e - 1);
  }
  getFirstInvalidLine(e) {
    const t = this.getFirstInvalidEndStateLineNumber();
    if (t === null)
      return null;
    const i = this.getStartState(t, e);
    if (!i)
      throw new lt("Start state must be defined");
    return { lineNumber: t, startState: i };
  }
}
class XZ {
  constructor() {
    this._lineEndStates = new YZ(null);
  }
  getEndState(e) {
    return this._lineEndStates.get(e);
  }
  setEndState(e, t) {
    const i = this._lineEndStates.get(e);
    return i && i.equals(t) ? !1 : (this._lineEndStates.set(e, t), !0);
  }
  acceptChange(e, t) {
    let i = e.length;
    t > 0 && i > 0 && (i--, t--), this._lineEndStates.replace(e.startLineNumber, i, t);
  }
}
class ZZ {
  constructor() {
    this._ranges = [];
  }
  get min() {
    return this._ranges.length === 0 ? null : this._ranges[0].start;
  }
  delete(e) {
    const t = this._ranges.findIndex((i) => i.contains(e));
    if (t !== -1) {
      const i = this._ranges[t];
      i.start === e ? i.endExclusive === e + 1 ? this._ranges.splice(t, 1) : this._ranges[t] = new Be(e + 1, i.endExclusive) : i.endExclusive === e + 1 ? this._ranges[t] = new Be(i.start, e) : this._ranges.splice(t, 1, new Be(i.start, e), new Be(e + 1, i.endExclusive));
    }
  }
  addRange(e) {
    Be.addRange(e, this._ranges);
  }
  addRangeAndResize(e, t) {
    let i = 0;
    for (; !(i >= this._ranges.length || e.start <= this._ranges[i].endExclusive); )
      i++;
    let n = i;
    for (; !(n >= this._ranges.length || e.endExclusive < this._ranges[n].start); )
      n++;
    const o = t - e.length;
    for (let r = n; r < this._ranges.length; r++)
      this._ranges[r] = this._ranges[r].delta(o);
    if (i === n) {
      const r = new Be(e.start, e.start + t);
      r.isEmpty || this._ranges.splice(i, 0, r);
    } else {
      const r = Math.min(e.start, this._ranges[i].start), a = Math.max(e.endExclusive, this._ranges[n - 1].endExclusive), l = new Be(r, a + o);
      l.isEmpty ? this._ranges.splice(i, n - i) : this._ranges.splice(i, n - i, l);
    }
  }
  toString() {
    return this._ranges.map((e) => e.toString()).join(" + ");
  }
}
function Zm(s, e, t, i, n, o) {
  let r = null;
  if (t)
    try {
      r = t.tokenizeEncoded(i, n, o.clone());
    } catch (a) {
      Pe(a);
    }
  return r || (r = TN(s.encodeLanguageId(e), o)), Gi.convertToEndOffset(r.tokens, i.length), r;
}
class eee {
  constructor(e, t) {
    this._tokenizerWithStateStore = e, this._backgroundTokenStore = t, this._isDisposed = !1, this._isScheduled = !1;
  }
  dispose() {
    this._isDisposed = !0;
  }
  handleChanges() {
    this._beginBackgroundTokenization();
  }
  _beginBackgroundTokenization() {
    this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._isScheduled = !0, LH((e) => {
      this._isScheduled = !1, this._backgroundTokenizeWithDeadline(e);
    }));
  }
  /**
   * Tokenize until the deadline occurs, but try to yield every 1-2ms.
   */
  _backgroundTokenizeWithDeadline(e) {
    const t = Date.now() + e.timeRemaining(), i = () => {
      this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize() || (this._backgroundTokenizeForAtLeast1ms(), Date.now() < t ? J4(i) : this._beginBackgroundTokenization());
    };
    i();
  }
  /**
   * Tokenize for at least 1ms.
   */
  _backgroundTokenizeForAtLeast1ms() {
    const e = this._tokenizerWithStateStore._textModel.getLineCount(), t = new _k(), i = es.create(!1);
    do
      if (i.elapsed() > 1 || this._tokenizeOneInvalidLine(t) >= e)
        break;
    while (this._hasLinesToTokenize());
    this._backgroundTokenStore.setTokens(t.finalize()), this.checkFinished();
  }
  _hasLinesToTokenize() {
    return this._tokenizerWithStateStore ? !this._tokenizerWithStateStore.store.allStatesValid() : !1;
  }
  _tokenizeOneInvalidLine(e) {
    const t = this._tokenizerWithStateStore?.getFirstInvalidLine();
    return t ? (this._tokenizerWithStateStore.updateTokensUntilLine(e, t.lineNumber), t.lineNumber) : this._tokenizerWithStateStore._textModel.getLineCount() + 1;
  }
  checkFinished() {
    this._isDisposed || this._tokenizerWithStateStore.store.allStatesValid() && this._backgroundTokenStore.backgroundTokenizationFinished();
  }
  requestTokens(e, t) {
    this._tokenizerWithStateStore.store.invalidateEndStateRange(new Ee(e, t));
  }
}
class tee {
  constructor() {
    this._onDidChangeVisibleRanges = new B(), this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event, this._views = /* @__PURE__ */ new Set();
  }
  attachView() {
    const e = new iee((t) => {
      this._onDidChangeVisibleRanges.fire({ view: e, state: t });
    });
    return this._views.add(e), e;
  }
  detachView(e) {
    this._views.delete(e), this._onDidChangeVisibleRanges.fire({ view: e, state: void 0 });
  }
}
class iee {
  constructor(e) {
    this.handleStateChange = e;
  }
  setVisibleLines(e, t) {
    const i = e.map((n) => new Ee(n.startLineNumber, n.endLineNumber + 1));
    this.handleStateChange({ visibleLineRanges: i, stabilized: t });
  }
}
class nee extends V {
  get lineRanges() {
    return this._lineRanges;
  }
  constructor(e) {
    super(), this._refreshTokens = e, this.runner = this._register(new zt(() => this.update(), 50)), this._computedLineRanges = [], this._lineRanges = [];
  }
  update() {
    pi(this._computedLineRanges, this._lineRanges, (e, t) => e.equals(t)) || (this._computedLineRanges = this._lineRanges, this._refreshTokens());
  }
  handleStateChange(e) {
    this._lineRanges = e.visibleLineRanges, e.stabilized ? (this.runner.cancel(), this.update()) : this.runner.schedule();
  }
}
class vW extends V {
  get backgroundTokenizationState() {
    return this._backgroundTokenizationState;
  }
  constructor(e, t, i) {
    super(), this._languageIdCodec = e, this._textModel = t, this.getLanguageId = i, this._backgroundTokenizationState = 1, this._onDidChangeBackgroundTokenizationState = this._register(new B()), this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event, this._onDidChangeTokens = this._register(new B()), this.onDidChangeTokens = this._onDidChangeTokens.event;
  }
  tokenizeIfCheap(e) {
    this.isCheapToTokenize(e) && this.forceTokenization(e);
  }
}
class BF extends vW {
  constructor(e, t, i, n) {
    super(t, i, n), this._treeSitterService = e, this._tokenizationSupport = null, this._initialize();
  }
  _initialize() {
    const e = this.getLanguageId();
    (!this._tokenizationSupport || this._lastLanguageId !== e) && (this._lastLanguageId = e, this._tokenizationSupport = Px.get(e));
  }
  getLineTokens(e) {
    const t = this._textModel.getLineContent(e);
    if (this._tokenizationSupport) {
      const i = this._tokenizationSupport.tokenizeEncoded(e, this._textModel);
      if (i)
        return new Gi(i, t, this._languageIdCodec);
    }
    return Gi.createEmpty(t, this._languageIdCodec);
  }
  resetTokenization(e = !0) {
    e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    }), this._initialize();
  }
  handleDidChangeAttached() {
  }
  handleDidChangeContent(e) {
    e.isFlush && this.resetTokenization(!1);
  }
  forceTokenization(e) {
  }
  hasAccurateTokensForLine(e) {
    return !0;
  }
  isCheapToTokenize(e) {
    return !0;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return 0;
  }
  tokenizeLineWithEdit(e, t, i) {
    return null;
  }
  get hasTokens() {
    return this._treeSitterService.getParseResult(this._textModel) !== void 0;
  }
}
const SW = We("treeSitterParserService"), el = new Uint32Array(0).buffer;
class la {
  static deleteBeginning(e, t) {
    return e === null || e === el ? e : la.delete(e, 0, t);
  }
  static deleteEnding(e, t) {
    if (e === null || e === el)
      return e;
    const i = pl(e), n = i[i.length - 2];
    return la.delete(e, t, n);
  }
  static delete(e, t, i) {
    if (e === null || e === el || t === i)
      return e;
    const n = pl(e), o = n.length >>> 1;
    if (t === 0 && n[n.length - 2] === i)
      return el;
    const r = Gi.findIndexInTokensArray(n, t), a = r > 0 ? n[r - 1 << 1] : 0, l = n[r << 1];
    if (i < l) {
      const g = i - t;
      for (let m = r; m < o; m++)
        n[m << 1] -= g;
      return e;
    }
    let c, d;
    a !== t ? (n[r << 1] = t, c = r + 1 << 1, d = t) : (c = r << 1, d = a);
    const h = i - t;
    for (let g = r + 1; g < o; g++) {
      const m = n[g << 1] - h;
      m > d && (n[c++] = m, n[c++] = n[(g << 1) + 1], d = m);
    }
    if (c === n.length)
      return e;
    const u = new Uint32Array(c);
    return u.set(n.subarray(0, c), 0), u.buffer;
  }
  static append(e, t) {
    if (t === el)
      return e;
    if (e === el)
      return t;
    if (e === null)
      return e;
    if (t === null)
      return null;
    const i = pl(e), n = pl(t), o = n.length >>> 1, r = new Uint32Array(i.length + n.length);
    r.set(i, 0);
    let a = i.length;
    const l = i[i.length - 2];
    for (let c = 0; c < o; c++)
      r[a++] = n[c << 1] + l, r[a++] = n[(c << 1) + 1];
    return r.buffer;
  }
  static insert(e, t, i) {
    if (e === null || e === el)
      return e;
    const n = pl(e), o = n.length >>> 1;
    let r = Gi.findIndexInTokensArray(n, t);
    r > 0 && n[r - 1 << 1] === t && r--;
    for (let a = r; a < o; a++)
      n[a << 1] += i;
    return e;
  }
}
function pl(s) {
  return s instanceof Uint32Array ? s : new Uint32Array(s);
}
class XA {
  constructor(e) {
    this._lineTokens = [], this._len = 0, this._languageIdCodec = e;
  }
  flush() {
    this._lineTokens = [], this._len = 0;
  }
  get hasTokens() {
    return this._lineTokens.length > 0;
  }
  getTokens(e, t, i) {
    let n = null;
    if (t < this._len && (n = this._lineTokens[t]), n !== null && n !== el)
      return new Gi(pl(n), i, this._languageIdCodec);
    const o = new Uint32Array(2);
    return o[0] = i.length, o[1] = RF(this._languageIdCodec.encodeLanguageId(e)), new Gi(o, i, this._languageIdCodec);
  }
  static _massageTokens(e, t, i) {
    const n = i ? pl(i) : null;
    if (t === 0) {
      let o = !1;
      if (n && n.length > 1 && (o = xr.getLanguageId(n[1]) !== e), !o)
        return el;
    }
    if (!n || n.length === 0) {
      const o = new Uint32Array(2);
      return o[0] = t, o[1] = RF(e), o.buffer;
    }
    return n[n.length - 2] = t, n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n;
  }
  _ensureLine(e) {
    for (; e >= this._len; )
      this._lineTokens[this._len] = null, this._len++;
  }
  _deleteLines(e, t) {
    t !== 0 && (e + t > this._len && (t = this._len - e), this._lineTokens.splice(e, t), this._len -= t);
  }
  _insertLines(e, t) {
    if (t === 0)
      return;
    const i = [];
    for (let n = 0; n < t; n++)
      i[n] = null;
    this._lineTokens = f0(this._lineTokens, e, i), this._len += t;
  }
  setTokens(e, t, i, n, o) {
    const r = XA._massageTokens(this._languageIdCodec.encodeLanguageId(e), i, n);
    this._ensureLine(t);
    const a = this._lineTokens[t];
    return this._lineTokens[t] = r, o ? !XA._equals(a, r) : !1;
  }
  static _equals(e, t) {
    if (!e || !t)
      return !e && !t;
    const i = pl(e), n = pl(t);
    if (i.length !== n.length)
      return !1;
    for (let o = 0, r = i.length; o < r; o++)
      if (i[o] !== n[o])
        return !1;
    return !0;
  }
  //#region Editing
  acceptEdit(e, t, i) {
    this._acceptDeleteRange(e), this._acceptInsertText(new F(e.startLineNumber, e.startColumn), t, i);
  }
  _acceptDeleteRange(e) {
    const t = e.startLineNumber - 1;
    if (t >= this._len)
      return;
    if (e.startLineNumber === e.endLineNumber) {
      if (e.startColumn === e.endColumn)
        return;
      this._lineTokens[t] = la.delete(this._lineTokens[t], e.startColumn - 1, e.endColumn - 1);
      return;
    }
    this._lineTokens[t] = la.deleteEnding(this._lineTokens[t], e.startColumn - 1);
    const i = e.endLineNumber - 1;
    let n = null;
    i < this._len && (n = la.deleteBeginning(this._lineTokens[i], e.endColumn - 1)), this._lineTokens[t] = la.append(this._lineTokens[t], n), this._deleteLines(e.startLineNumber, e.endLineNumber - e.startLineNumber);
  }
  _acceptInsertText(e, t, i) {
    if (t === 0 && i === 0)
      return;
    const n = e.lineNumber - 1;
    if (!(n >= this._len)) {
      if (t === 0) {
        this._lineTokens[n] = la.insert(this._lineTokens[n], e.column - 1, i);
        return;
      }
      this._lineTokens[n] = la.deleteEnding(this._lineTokens[n], e.column - 1), this._lineTokens[n] = la.insert(this._lineTokens[n], e.column - 1, i), this._insertLines(e.lineNumber, t);
    }
  }
  //#endregion
  setMultilineTokens(e, t) {
    if (e.length === 0)
      return { changes: [] };
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      let a = 0, l = 0, c = !1;
      for (let d = r.startLineNumber; d <= r.endLineNumber; d++)
        c ? (this.setTokens(t.getLanguageId(), d - 1, t.getLineLength(d), r.getLineTokens(d), !1), l = d) : this.setTokens(t.getLanguageId(), d - 1, t.getLineLength(d), r.getLineTokens(d), !0) && (c = !0, a = d, l = d);
      c && i.push({ fromLineNumber: a, toLineNumber: l });
    }
    return { changes: i };
  }
}
function RF(s) {
  return (s << 0 | 0 | 0 | 32768 | 2 << 24 | 1024) >>> 0;
}
class nT {
  constructor(e) {
    this._pieces = [], this._isComplete = !1, this._languageIdCodec = e;
  }
  flush() {
    this._pieces = [], this._isComplete = !1;
  }
  isEmpty() {
    return this._pieces.length === 0;
  }
  set(e, t) {
    this._pieces = e || [], this._isComplete = t;
  }
  setPartial(e, t) {
    let i = e;
    if (t.length > 0) {
      const o = t[0].getRange(), r = t[t.length - 1].getRange();
      if (!o || !r)
        return e;
      i = e.plusRange(o).plusRange(r);
    }
    let n = null;
    for (let o = 0, r = this._pieces.length; o < r; o++) {
      const a = this._pieces[o];
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        break;
      }
      if (a.removeTokens(i), a.isEmpty()) {
        this._pieces.splice(o, 1), o--, r--;
        continue;
      }
      if (a.endLineNumber < i.startLineNumber)
        continue;
      if (a.startLineNumber > i.endLineNumber) {
        n = n || { index: o };
        continue;
      }
      const [l, c] = a.split(i);
      if (l.isEmpty()) {
        n = n || { index: o };
        continue;
      }
      c.isEmpty() || (this._pieces.splice(o, 1, l, c), o++, r++, n = n || { index: o });
    }
    return n = n || { index: this._pieces.length }, t.length > 0 && (this._pieces = f0(this._pieces, n.index, t)), i;
  }
  isComplete() {
    return this._isComplete;
  }
  addSparseTokens(e, t) {
    if (t.getLineContent().length === 0)
      return t;
    const i = this._pieces;
    if (i.length === 0)
      return t;
    const n = nT._findFirstPieceWithLine(i, e), o = i[n].getLineTokens(e);
    if (!o)
      return t;
    const r = t.getCount(), a = o.getCount();
    let l = 0;
    const c = [];
    let d = 0, h = 0;
    const u = (g, m) => {
      g !== h && (h = g, c[d++] = g, c[d++] = m);
    };
    for (let g = 0; g < a; g++) {
      const m = o.getStartCharacter(g), p = o.getEndCharacter(g), A = o.getMetadata(g), _ = ((A & 1 ? 2048 : 0) | (A & 2 ? 4096 : 0) | (A & 4 ? 8192 : 0) | (A & 8 ? 16384 : 0) | (A & 16 ? 16744448 : 0) | (A & 32 ? 4278190080 : 0)) >>> 0, b = ~_ >>> 0;
      for (; l < r && t.getEndOffset(l) <= m; )
        u(t.getEndOffset(l), t.getMetadata(l)), l++;
      for (l < r && t.getStartOffset(l) < m && u(m, t.getMetadata(l)); l < r && t.getEndOffset(l) < p; )
        u(t.getEndOffset(l), t.getMetadata(l) & b | A & _), l++;
      if (l < r)
        u(p, t.getMetadata(l) & b | A & _), t.getEndOffset(l) === p && l++;
      else {
        const C = Math.min(Math.max(0, l - 1), r - 1);
        u(p, t.getMetadata(C) & b | A & _);
      }
    }
    for (; l < r; )
      u(t.getEndOffset(l), t.getMetadata(l)), l++;
    return new Gi(new Uint32Array(c), t.getLineContent(), this._languageIdCodec);
  }
  static _findFirstPieceWithLine(e, t) {
    let i = 0, n = e.length - 1;
    for (; i < n; ) {
      let o = i + Math.floor((n - i) / 2);
      if (e[o].endLineNumber < t)
        i = o + 1;
      else if (e[o].startLineNumber > t)
        n = o - 1;
      else {
        for (; o > i && e[o - 1].startLineNumber <= t && t <= e[o - 1].endLineNumber; )
          o--;
        return o;
      }
    }
    return i;
  }
  acceptEdit(e, t, i, n, o) {
    for (const r of this._pieces)
      r.acceptEdit(e, t, i, n, o);
  }
}
var see = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Hy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, kw;
let wk = kw = class extends gW {
  constructor(e, t, i, n, o, r, a) {
    super(), this._textModel = e, this._bracketPairsTextModelPart = t, this._languageId = i, this._attachedViews = n, this._languageService = o, this._languageConfigurationService = r, this._treeSitterService = a, this._semanticTokens = new nT(this._languageService.languageIdCodec), this._onDidChangeLanguage = this._register(new B()), this.onDidChangeLanguage = this._onDidChangeLanguage.event, this._onDidChangeLanguageConfiguration = this._register(new B()), this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event, this._onDidChangeTokens = this._register(new B()), this.onDidChangeTokens = this._onDidChangeTokens.event, this._tokensDisposables = this._register(new X()), this._register(this._languageConfigurationService.onDidChange((l) => {
      l.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
    })), this._register(te.filter(Px.onDidChange, (l) => l.changedLanguages.includes(this._languageId))(() => {
      this.createPreferredTokenProvider();
    })), this.createPreferredTokenProvider();
  }
  createGrammarTokens() {
    return this._register(new FF(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));
  }
  createTreeSitterTokens() {
    return this._register(new BF(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));
  }
  createTokens(e) {
    const t = this._tokens !== void 0;
    this._tokens?.dispose(), this._tokens = e ? this.createTreeSitterTokens() : this.createGrammarTokens(), this._tokensDisposables.clear(), this._tokensDisposables.add(this._tokens.onDidChangeTokens((i) => {
      this._emitModelTokensChangedEvent(i);
    })), this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState((i) => {
      this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();
    })), t && this._tokens.resetTokenization();
  }
  createPreferredTokenProvider() {
    Px.get(this._languageId) ? this._tokens instanceof BF || this.createTokens(!0) : this._tokens instanceof FF || this.createTokens(!1);
  }
  handleLanguageConfigurationServiceChange(e) {
    e.affects(this._languageId) && this._onDidChangeLanguageConfiguration.fire({});
  }
  handleDidChangeContent(e) {
    if (e.isFlush)
      this._semanticTokens.flush();
    else if (!e.isEolChange)
      for (const t of e.changes) {
        const [i, n, o] = bu(t.text);
        this._semanticTokens.acceptEdit(
          t.range,
          i,
          n,
          o,
          t.text.length > 0 ? t.text.charCodeAt(0) : 0
          /* CharCode.Null */
        );
      }
    this._tokens.handleDidChangeContent(e);
  }
  handleDidChangeAttached() {
    this._tokens.handleDidChangeAttached();
  }
  /**
   * Includes grammar and semantic tokens.
   */
  getLineTokens(e) {
    this.validateLineNumber(e);
    const t = this._tokens.getLineTokens(e);
    return this._semanticTokens.addSparseTokens(e, t);
  }
  _emitModelTokensChangedEvent(e) {
    this._textModel._isDisposing() || (this._bracketPairsTextModelPart.handleDidChangeTokens(e), this._onDidChangeTokens.fire(e));
  }
  // #region Grammar Tokens
  validateLineNumber(e) {
    if (e < 1 || e > this._textModel.getLineCount())
      throw new lt("Illegal value for lineNumber");
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
  resetTokenization() {
    this._tokens.resetTokenization();
  }
  get backgroundTokenizationState() {
    return this._tokens.backgroundTokenizationState;
  }
  forceTokenization(e) {
    this.validateLineNumber(e), this._tokens.forceTokenization(e);
  }
  hasAccurateTokensForLine(e) {
    return this.validateLineNumber(e), this._tokens.hasAccurateTokensForLine(e);
  }
  isCheapToTokenize(e) {
    return this.validateLineNumber(e), this._tokens.isCheapToTokenize(e);
  }
  tokenizeIfCheap(e) {
    this.validateLineNumber(e), this._tokens.tokenizeIfCheap(e);
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    return this._tokens.getTokenTypeIfInsertingCharacter(e, t, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    return this._tokens.tokenizeLineWithEdit(e, t, i);
  }
  // #endregion
  // #region Semantic Tokens
  setSemanticTokens(e, t) {
    this._semanticTokens.set(e, t), this._emitModelTokensChangedEvent({
      semanticTokensApplied: e !== null,
      ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }]
    });
  }
  hasCompleteSemanticTokens() {
    return this._semanticTokens.isComplete();
  }
  hasSomeSemanticTokens() {
    return !this._semanticTokens.isEmpty();
  }
  setPartialSemanticTokens(e, t) {
    if (this.hasCompleteSemanticTokens())
      return;
    const i = this._textModel.validateRange(this._semanticTokens.setPartial(e, t));
    this._emitModelTokensChangedEvent({
      semanticTokensApplied: !0,
      ranges: [
        {
          fromLineNumber: i.startLineNumber,
          toLineNumber: i.endLineNumber
        }
      ]
    });
  }
  // #endregion
  // #region Utility Methods
  getWordAtPosition(e) {
    this.assertNotDisposed();
    const t = this._textModel.validatePosition(e), i = this._textModel.getLineContent(t.lineNumber), n = this.getLineTokens(t.lineNumber), o = n.findTokenIndexAtOffset(t.column - 1), [r, a] = kw._findLanguageBoundaries(n, o), l = SA(t.column, this.getLanguageConfiguration(n.getLanguageId(o)).getWordDefinition(), i.substring(r, a), r);
    if (l && l.startColumn <= e.column && e.column <= l.endColumn)
      return l;
    if (o > 0 && r === t.column - 1) {
      const [c, d] = kw._findLanguageBoundaries(n, o - 1), h = SA(t.column, this.getLanguageConfiguration(n.getLanguageId(o - 1)).getWordDefinition(), i.substring(c, d), c);
      if (h && h.startColumn <= e.column && e.column <= h.endColumn)
        return h;
    }
    return null;
  }
  getLanguageConfiguration(e) {
    return this._languageConfigurationService.getLanguageConfiguration(e);
  }
  static _findLanguageBoundaries(e, t) {
    const i = e.getLanguageId(t);
    let n = 0;
    for (let r = t; r >= 0 && e.getLanguageId(r) === i; r--)
      n = e.getStartOffset(r);
    let o = e.getLineContent().length;
    for (let r = t, a = e.getCount(); r < a && e.getLanguageId(r) === i; r++)
      o = e.getEndOffset(r);
    return [n, o];
  }
  getWordUntilPosition(e) {
    const t = this.getWordAtPosition(e);
    return t ? {
      word: t.word.substr(0, e.column - t.startColumn),
      startColumn: t.startColumn,
      endColumn: e.column
    } : { word: "", startColumn: e.column, endColumn: e.column };
  }
  // #endregion
  // #region Language Id handling
  getLanguageId() {
    return this._languageId;
  }
  getLanguageIdAtPosition(e, t) {
    const i = this._textModel.validatePosition(new F(e, t)), n = this.getLineTokens(i.lineNumber);
    return n.getLanguageId(n.findTokenIndexAtOffset(i.column - 1));
  }
  setLanguageId(e, t = "api") {
    if (this._languageId === e)
      return;
    const i = {
      oldLanguage: this._languageId,
      newLanguage: e,
      source: t
    };
    this._languageId = e, this._bracketPairsTextModelPart.handleDidChangeLanguage(i), this._tokens.resetTokenization(), this.createPreferredTokenProvider(), this._onDidChangeLanguage.fire(i), this._onDidChangeLanguageConfiguration.fire({});
  }
};
wk = kw = see([
  Hy(4, si),
  Hy(5, tn),
  Hy(6, SW)
], wk);
class FF extends vW {
  constructor(e, t, i, n) {
    super(e, t, i), this._tokenizer = null, this._defaultBackgroundTokenizer = null, this._backgroundTokenizer = this._register(new On()), this._tokens = new XA(this._languageIdCodec), this._debugBackgroundTokenizer = this._register(new On()), this._attachedViewStates = this._register(new IM()), this._register(ci.onDidChange((o) => {
      const r = this.getLanguageId();
      o.changedLanguages.indexOf(r) !== -1 && this.resetTokenization();
    })), this.resetTokenization(), this._register(n.onDidChangeVisibleRanges(({ view: o, state: r }) => {
      if (r) {
        let a = this._attachedViewStates.get(o);
        a || (a = new nee(() => this.refreshRanges(a.lineRanges)), this._attachedViewStates.set(o, a)), a.handleStateChange(r);
      } else
        this._attachedViewStates.deleteAndDispose(o);
    }));
  }
  resetTokenization(e = !0) {
    this._tokens.flush(), this._debugBackgroundTokens?.flush(), this._debugBackgroundStates && (this._debugBackgroundStates = new bk(this._textModel.getLineCount())), e && this._onDidChangeTokens.fire({
      semanticTokensApplied: !1,
      ranges: [
        {
          fromLineNumber: 1,
          toLineNumber: this._textModel.getLineCount()
        }
      ]
    });
    const t = () => {
      if (this._textModel.isTooLargeForTokenization())
        return [null, null];
      const o = ci.get(this.getLanguageId());
      if (!o)
        return [null, null];
      let r;
      try {
        r = o.getInitialState();
      } catch (a) {
        return Pe(a), [null, null];
      }
      return [o, r];
    }, [i, n] = t();
    if (i && n ? this._tokenizer = new $Z(this._textModel.getLineCount(), i, this._textModel, this._languageIdCodec) : this._tokenizer = null, this._backgroundTokenizer.clear(), this._defaultBackgroundTokenizer = null, this._tokenizer) {
      const o = {
        setTokens: (r) => {
          this.setTokens(r);
        },
        backgroundTokenizationFinished: () => {
          if (this._backgroundTokenizationState === 2)
            return;
          const r = 2;
          this._backgroundTokenizationState = r, this._onDidChangeBackgroundTokenizationState.fire();
        },
        setEndState: (r, a) => {
          if (!this._tokenizer)
            return;
          const l = this._tokenizer.store.getFirstInvalidEndStateLineNumber();
          l !== null && r >= l && this._tokenizer?.store.setEndState(r, a);
        }
      };
      i && i.createBackgroundTokenizer && !i.backgroundTokenizerShouldOnlyVerifyTokens && (this._backgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, o)), !this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization() && (this._backgroundTokenizer.value = this._defaultBackgroundTokenizer = new eee(this._tokenizer, o), this._defaultBackgroundTokenizer.handleChanges()), i?.backgroundTokenizerShouldOnlyVerifyTokens && i.createBackgroundTokenizer ? (this._debugBackgroundTokens = new XA(this._languageIdCodec), this._debugBackgroundStates = new bk(this._textModel.getLineCount()), this._debugBackgroundTokenizer.clear(), this._debugBackgroundTokenizer.value = i.createBackgroundTokenizer(this._textModel, {
        setTokens: (r) => {
          this._debugBackgroundTokens?.setMultilineTokens(r, this._textModel);
        },
        backgroundTokenizationFinished() {
        },
        setEndState: (r, a) => {
          this._debugBackgroundStates?.setEndState(r, a);
        }
      })) : (this._debugBackgroundTokens = void 0, this._debugBackgroundStates = void 0, this._debugBackgroundTokenizer.value = void 0);
    }
    this.refreshAllVisibleLineTokens();
  }
  handleDidChangeAttached() {
    this._defaultBackgroundTokenizer?.handleChanges();
  }
  handleDidChangeContent(e) {
    if (e.isFlush)
      this.resetTokenization(!1);
    else if (!e.isEolChange) {
      for (const t of e.changes) {
        const [i, n] = bu(t.text);
        this._tokens.acceptEdit(t.range, i, n), this._debugBackgroundTokens?.acceptEdit(t.range, i, n);
      }
      this._debugBackgroundStates?.acceptChanges(e.changes), this._tokenizer && this._tokenizer.store.acceptChanges(e.changes), this._defaultBackgroundTokenizer?.handleChanges();
    }
  }
  setTokens(e) {
    const { changes: t } = this._tokens.setMultilineTokens(e, this._textModel);
    return t.length > 0 && this._onDidChangeTokens.fire({ semanticTokensApplied: !1, ranges: t }), { changes: t };
  }
  refreshAllVisibleLineTokens() {
    const e = Ee.joinMany([...this._attachedViewStates].map(([t, i]) => i.lineRanges));
    this.refreshRanges(e);
  }
  refreshRanges(e) {
    for (const t of e)
      this.refreshRange(t.startLineNumber, t.endLineNumberExclusive - 1);
  }
  refreshRange(e, t) {
    if (!this._tokenizer)
      return;
    e = Math.max(1, Math.min(this._textModel.getLineCount(), e)), t = Math.min(this._textModel.getLineCount(), t);
    const i = new _k(), { heuristicTokens: n } = this._tokenizer.tokenizeHeuristically(i, e, t), o = this.setTokens(i.finalize());
    if (n)
      for (const r of o.changes)
        this._backgroundTokenizer.value?.requestTokens(r.fromLineNumber, r.toLineNumber + 1);
    this._defaultBackgroundTokenizer?.checkFinished();
  }
  forceTokenization(e) {
    const t = new _k();
    this._tokenizer?.updateTokensUntilLine(t, e), this.setTokens(t.finalize()), this._defaultBackgroundTokenizer?.checkFinished();
  }
  hasAccurateTokensForLine(e) {
    return this._tokenizer ? this._tokenizer.hasAccurateTokensForLine(e) : !0;
  }
  isCheapToTokenize(e) {
    return this._tokenizer ? this._tokenizer.isCheapToTokenize(e) : !0;
  }
  getLineTokens(e) {
    const t = this._textModel.getLineContent(e), i = this._tokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
    if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer && this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > e && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > e) {
      const n = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), e - 1, t);
      !i.equals(n) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens && this._debugBackgroundTokenizer.value.reportMismatchingTokens(e);
    }
    return i;
  }
  getTokenTypeIfInsertingCharacter(e, t, i) {
    if (!this._tokenizer)
      return 0;
    const n = this._textModel.validatePosition(new F(e, t));
    return this.forceTokenization(n.lineNumber), this._tokenizer.getTokenTypeIfInsertingCharacter(n, i);
  }
  tokenizeLineWithEdit(e, t, i) {
    if (!this._tokenizer)
      return null;
    const n = this._textModel.validatePosition(e);
    return this.forceTokenization(n.lineNumber), this._tokenizer.tokenizeLineWithEdit(n, t, i);
  }
  get hasTokens() {
    return this._tokens.hasTokens;
  }
}
class oee {
  constructor() {
    this.changeType = 1;
  }
}
class Rr {
  static applyInjectedText(e, t) {
    if (!t || t.length === 0)
      return e;
    let i = "", n = 0;
    for (const o of t)
      i += e.substring(n, o.column - 1), n = o.column - 1, i += o.options.content;
    return i += e.substring(n), i;
  }
  static fromDecorations(e) {
    const t = [];
    for (const i of e)
      i.options.before && i.options.before.content.length > 0 && t.push(new Rr(i.ownerId, i.range.startLineNumber, i.range.startColumn, i.options.before, 0)), i.options.after && i.options.after.content.length > 0 && t.push(new Rr(i.ownerId, i.range.endLineNumber, i.range.endColumn, i.options.after, 1));
    return t.sort((i, n) => i.lineNumber === n.lineNumber ? i.column === n.column ? i.order - n.order : i.column - n.column : i.lineNumber - n.lineNumber), t;
  }
  constructor(e, t, i, n, o) {
    this.ownerId = e, this.lineNumber = t, this.column = i, this.options = n, this.order = o;
  }
}
class OF {
  constructor(e, t, i) {
    this.changeType = 2, this.lineNumber = e, this.detail = t, this.injectedText = i;
  }
}
class ree {
  constructor(e, t) {
    this.changeType = 3, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class aee {
  constructor(e, t, i, n) {
    this.changeType = 4, this.injectedTexts = n, this.fromLineNumber = e, this.toLineNumber = t, this.detail = i;
  }
}
class lee {
  constructor() {
    this.changeType = 5;
  }
}
class Ef {
  constructor(e, t, i, n) {
    this.changes = e, this.versionId = t, this.isUndoing = i, this.isRedoing = n, this.resultingSelection = null;
  }
  containsEvent(e) {
    for (let t = 0, i = this.changes.length; t < i; t++)
      if (this.changes[t].changeType === e)
        return !0;
    return !1;
  }
  static merge(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.versionId, o = e.isUndoing || t.isUndoing, r = e.isRedoing || t.isRedoing;
    return new Ef(i, n, o, r);
  }
}
class yW {
  constructor(e) {
    this.changes = e;
  }
}
class Nh {
  constructor(e, t) {
    this.rawContentChangedEvent = e, this.contentChangedEvent = t;
  }
  merge(e) {
    const t = Ef.merge(this.rawContentChangedEvent, e.rawContentChangedEvent), i = Nh._mergeChangeEvents(this.contentChangedEvent, e.contentChangedEvent);
    return new Nh(t, i);
  }
  static _mergeChangeEvents(e, t) {
    const i = [].concat(e.changes).concat(t.changes), n = t.eol, o = t.versionId, r = e.isUndoing || t.isUndoing, a = e.isRedoing || t.isRedoing, l = e.isFlush || t.isFlush, c = e.isEolChange && t.isEolChange;
    return {
      changes: i,
      eol: n,
      isEolChange: c,
      versionId: o,
      isUndoing: r,
      isRedoing: a,
      isFlush: l
    };
  }
}
var cee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Bb = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Gd;
function dee(s) {
  const e = new CW();
  return e.acceptChunk(s), e.finish();
}
function hee(s) {
  const e = new CW();
  let t;
  for (; typeof (t = s.read()) == "string"; )
    e.acceptChunk(t);
  return e.finish();
}
function PF(s, e) {
  let t;
  return typeof s == "string" ? t = dee(s) : jQ(s) ? t = hee(s) : t = s, t.create(e);
}
let Rb = 0;
const uee = 999, gee = 1e4;
class fee {
  constructor(e) {
    this._source = e, this._eos = !1;
  }
  read() {
    if (this._eos)
      return null;
    const e = [];
    let t = 0, i = 0;
    do {
      const n = this._source.read();
      if (n === null)
        return this._eos = !0, t === 0 ? null : e.join("");
      if (n.length > 0 && (e[t++] = n, i += n.length), i >= 64 * 1024)
        return e.join("");
    } while (!0);
  }
}
const ep = () => {
  throw new Error("Invalid change accessor");
};
var Lr;
let ZA = (Lr = class extends V {
  static resolveOptions(e, t) {
    if (t.detectIndentation) {
      const i = EF(e, t.tabSize, t.insertSpaces);
      return new _w({
        tabSize: i.tabSize,
        indentSize: "tabSize",
        // TODO@Alex: guess indentSize independent of tabSize
        insertSpaces: i.insertSpaces,
        trimAutoWhitespace: t.trimAutoWhitespace,
        defaultEOL: t.defaultEOL,
        bracketPairColorizationOptions: t.bracketPairColorizationOptions
      });
    }
    return new _w(t);
  }
  get onDidChangeLanguage() {
    return this._tokenizationTextModelPart.onDidChangeLanguage;
  }
  get onDidChangeLanguageConfiguration() {
    return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration;
  }
  get onDidChangeTokens() {
    return this._tokenizationTextModelPart.onDidChangeTokens;
  }
  onDidChangeContent(e) {
    return this._eventEmitter.slowEvent((t) => e(t.contentChangedEvent));
  }
  onDidChangeContentOrInjectedText(e) {
    return jo(this._eventEmitter.fastEvent((t) => e(t)), this._onDidChangeInjectedText.event((t) => e(t)));
  }
  _isDisposing() {
    return this.__isDisposing;
  }
  get tokenization() {
    return this._tokenizationTextModelPart;
  }
  get bracketPairs() {
    return this._bracketPairs;
  }
  get guides() {
    return this._guidesTextModelPart;
  }
  constructor(e, t, i, n = null, o, r, a, l) {
    super(), this._undoRedoService = o, this._languageService = r, this._languageConfigurationService = a, this.instantiationService = l, this._onWillDispose = this._register(new B()), this.onWillDispose = this._onWillDispose.event, this._onDidChangeDecorations = this._register(new wee((m) => this.handleBeforeFireDecorationsChangedEvent(m))), this.onDidChangeDecorations = this._onDidChangeDecorations.event, this._onDidChangeOptions = this._register(new B()), this.onDidChangeOptions = this._onDidChangeOptions.event, this._onDidChangeAttached = this._register(new B()), this.onDidChangeAttached = this._onDidChangeAttached.event, this._onDidChangeInjectedText = this._register(new B()), this._eventEmitter = this._register(new Cee()), this._languageSelectionListener = this._register(new On()), this._deltaDecorationCallCnt = 0, this._attachedViews = new tee(), Rb++, this.id = "$model" + Rb, this.isForSimpleWidget = i.isForSimpleWidget, typeof n > "u" || n === null ? this._associatedResource = _e.parse("inmemory://model/" + Rb) : this._associatedResource = n, this._attachedEditorCount = 0;
    const { textBuffer: c, disposable: d } = PF(e, i.defaultEOL);
    this._buffer = c, this._bufferDisposable = d, this._options = Gd.resolveOptions(this._buffer, i);
    const h = typeof t == "string" ? t : t.languageId;
    typeof t != "string" && (this._languageSelectionListener.value = t.onDidChange(() => this._setLanguage(t.languageId))), this._bracketPairs = this._register(new wZ(this, this._languageConfigurationService)), this._guidesTextModelPart = this._register(new xZ(this, this._languageConfigurationService)), this._decorationProvider = this._register(new vZ(this)), this._tokenizationTextModelPart = this.instantiationService.createInstance(wk, this, this._bracketPairs, h, this._attachedViews);
    const u = this._buffer.getLineCount(), g = this._buffer.getValueLengthInRange(
      new E(1, 1, u, this._buffer.getLineLength(u) + 1),
      0
      /* model.EndOfLinePreference.TextDefined */
    );
    i.largeFileOptimizations ? (this._isTooLargeForTokenization = g > Gd.LARGE_FILE_SIZE_THRESHOLD || u > Gd.LARGE_FILE_LINE_COUNT_THRESHOLD, this._isTooLargeForHeapOperation = g > Gd.LARGE_FILE_HEAP_OPERATION_THRESHOLD) : (this._isTooLargeForTokenization = !1, this._isTooLargeForHeapOperation = !1), this._isTooLargeForSyncing = g > Gd._MODEL_SYNC_LIMIT, this._versionId = 1, this._alternativeVersionId = 1, this._initialUndoRedoSnapshot = null, this._isDisposed = !1, this.__isDisposing = !1, this._instanceId = vH(Rb), this._lastDecorationId = 0, this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new HF(), this._commandManager = new ZN(this, this._undoRedoService), this._isUndoing = !1, this._isRedoing = !1, this._trimAutoWhitespaceLines = null, this._register(this._decorationProvider.onDidChange(() => {
      this._onDidChangeDecorations.beginDeferredEmit(), this._onDidChangeDecorations.fire(), this._onDidChangeDecorations.endDeferredEmit();
    })), this._languageService.requestRichLanguageFeatures(h), this._register(this._languageConfigurationService.onDidChange((m) => {
      this._bracketPairs.handleLanguageConfigurationServiceChange(m), this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(m);
    }));
  }
  dispose() {
    this.__isDisposing = !0, this._onWillDispose.fire(), this._tokenizationTextModelPart.dispose(), this._isDisposed = !0, super.dispose(), this._bufferDisposable.dispose(), this.__isDisposing = !1;
    const e = new xf([], "", `
`, !1, !1, !0, !0);
    e.dispose(), this._buffer = e, this._bufferDisposable = V.None;
  }
  _assertNotDisposed() {
    if (this._isDisposed)
      throw new lt("Model is disposed!");
  }
  _emitContentChangedEvent(e, t) {
    this.__isDisposing || (this._tokenizationTextModelPart.handleDidChangeContent(t), this._bracketPairs.handleDidChangeContent(t), this._eventEmitter.fire(new Nh(e, t)));
  }
  setValue(e) {
    if (this._assertNotDisposed(), e == null)
      throw Go();
    const { textBuffer: t, disposable: i } = PF(e, this._options.defaultEOL);
    this._setValueFromTextBuffer(t, i);
  }
  _createContentChanged2(e, t, i, n, o, r, a, l) {
    return {
      changes: [{
        range: e,
        rangeOffset: t,
        rangeLength: i,
        text: n
      }],
      eol: this._buffer.getEOL(),
      isEolChange: l,
      versionId: this.getVersionId(),
      isUndoing: o,
      isRedoing: r,
      isFlush: a
    };
  }
  _setValueFromTextBuffer(e, t) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._buffer = e, this._bufferDisposable.dispose(), this._bufferDisposable = t, this._increaseVersionId(), this._decorations = /* @__PURE__ */ Object.create(null), this._decorationsTree = new HF(), this._commandManager.clear(), this._trimAutoWhitespaceLines = null, this._emitContentChangedEvent(new Ef([
      new oee()
    ], this._versionId, !1, !1), this._createContentChanged2(new E(1, 1, o, r), 0, n, this.getValue(), !1, !1, !0, !1));
  }
  setEOL(e) {
    this._assertNotDisposed();
    const t = e === 1 ? `\r
` : `
`;
    if (this._buffer.getEOL() === t)
      return;
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i), o = this.getLineCount(), r = this.getLineMaxColumn(o);
    this._onBeforeEOLChange(), this._buffer.setEOL(t), this._increaseVersionId(), this._onAfterEOLChange(), this._emitContentChangedEvent(new Ef([
      new lee()
    ], this._versionId, !1, !1), this._createContentChanged2(new E(1, 1, o, r), 0, n, this.getValue(), !1, !1, !1, !0));
  }
  _onBeforeEOLChange() {
    this._decorationsTree.ensureAllNodesHaveRanges(this);
  }
  _onAfterEOLChange() {
    const e = this.getVersionId(), t = this._decorationsTree.collectNodesPostOrder();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i], r = o.range, a = o.cachedAbsoluteStart - o.start, l = this._buffer.getOffsetAt(r.startLineNumber, r.startColumn), c = this._buffer.getOffsetAt(r.endLineNumber, r.endColumn);
      o.cachedAbsoluteStart = l, o.cachedAbsoluteEnd = c, o.cachedVersionId = e, o.start = l - a, o.end = c - a, cd(o);
    }
  }
  onBeforeAttached() {
    return this._attachedEditorCount++, this._attachedEditorCount === 1 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.attachView();
  }
  onBeforeDetached(e) {
    this._attachedEditorCount--, this._attachedEditorCount === 0 && (this._tokenizationTextModelPart.handleDidChangeAttached(), this._onDidChangeAttached.fire(void 0)), this._attachedViews.detachView(e);
  }
  isAttachedToEditor() {
    return this._attachedEditorCount > 0;
  }
  getAttachedEditorCount() {
    return this._attachedEditorCount;
  }
  isTooLargeForSyncing() {
    return this._isTooLargeForSyncing;
  }
  isTooLargeForTokenization() {
    return this._isTooLargeForTokenization;
  }
  isTooLargeForHeapOperation() {
    return this._isTooLargeForHeapOperation;
  }
  isDisposed() {
    return this._isDisposed;
  }
  isDominatedByLongLines() {
    if (this._assertNotDisposed(), this.isTooLargeForTokenization())
      return !1;
    let e = 0, t = 0;
    const i = this._buffer.getLineCount();
    for (let n = 1; n <= i; n++) {
      const o = this._buffer.getLineLength(n);
      o >= gee ? t += o : e += o;
    }
    return t > e;
  }
  get uri() {
    return this._associatedResource;
  }
  //#region Options
  getOptions() {
    return this._assertNotDisposed(), this._options;
  }
  getFormattingOptions() {
    return {
      tabSize: this._options.indentSize,
      insertSpaces: this._options.insertSpaces
    };
  }
  updateOptions(e) {
    this._assertNotDisposed();
    const t = typeof e.tabSize < "u" ? e.tabSize : this._options.tabSize, i = typeof e.indentSize < "u" ? e.indentSize : this._options.originalIndentSize, n = typeof e.insertSpaces < "u" ? e.insertSpaces : this._options.insertSpaces, o = typeof e.trimAutoWhitespace < "u" ? e.trimAutoWhitespace : this._options.trimAutoWhitespace, r = typeof e.bracketColorizationOptions < "u" ? e.bracketColorizationOptions : this._options.bracketPairColorizationOptions, a = new _w({
      tabSize: t,
      indentSize: i,
      insertSpaces: n,
      defaultEOL: this._options.defaultEOL,
      trimAutoWhitespace: o,
      bracketPairColorizationOptions: r
    });
    if (this._options.equals(a))
      return;
    const l = this._options.createChangeEvent(a);
    this._options = a, this._bracketPairs.handleDidChangeOptions(l), this._decorationProvider.handleDidChangeOptions(l), this._onDidChangeOptions.fire(l);
  }
  detectIndentation(e, t) {
    this._assertNotDisposed();
    const i = EF(this._buffer, t, e);
    this.updateOptions({
      insertSpaces: i.insertSpaces,
      tabSize: i.tabSize,
      indentSize: i.tabSize
      // TODO@Alex: guess indentSize independent of tabSize
    });
  }
  normalizeIndentation(e) {
    return this._assertNotDisposed(), rW(e, this._options.indentSize, this._options.insertSpaces);
  }
  //#endregion
  //#region Reading
  getVersionId() {
    return this._assertNotDisposed(), this._versionId;
  }
  mightContainRTL() {
    return this._buffer.mightContainRTL();
  }
  mightContainUnusualLineTerminators() {
    return this._buffer.mightContainUnusualLineTerminators();
  }
  removeUnusualLineTerminators(e = null) {
    const t = this.findMatches(
      wH.source,
      !1,
      !0,
      !1,
      null,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    );
    this._buffer.resetMightContainUnusualLineTerminators(), this.pushEditOperations(e, t.map((i) => ({ range: i.range, text: null })), () => null);
  }
  mightContainNonBasicASCII() {
    return this._buffer.mightContainNonBasicASCII();
  }
  getAlternativeVersionId() {
    return this._assertNotDisposed(), this._alternativeVersionId;
  }
  getInitialUndoRedoSnapshot() {
    return this._assertNotDisposed(), this._initialUndoRedoSnapshot;
  }
  getOffsetAt(e) {
    this._assertNotDisposed();
    const t = this._validatePosition(
      e.lineNumber,
      e.column,
      0
      /* StringOffsetValidationType.Relaxed */
    );
    return this._buffer.getOffsetAt(t.lineNumber, t.column);
  }
  getPositionAt(e) {
    this._assertNotDisposed();
    const t = Math.min(this._buffer.getLength(), Math.max(0, e));
    return this._buffer.getPositionAt(t);
  }
  _increaseVersionId() {
    this._versionId = this._versionId + 1, this._alternativeVersionId = this._versionId;
  }
  _overwriteVersionId(e) {
    this._versionId = e;
  }
  _overwriteAlternativeVersionId(e) {
    this._alternativeVersionId = e;
  }
  _overwriteInitialUndoRedoSnapshot(e) {
    this._initialUndoRedoSnapshot = e;
  }
  getValue(e, t = !1) {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new lt("Operation would exceed heap memory limits");
    const i = this.getFullModelRange(), n = this.getValueInRange(i, e);
    return t ? this._buffer.getBOM() + n : n;
  }
  createSnapshot(e = !1) {
    return new fee(this._buffer.createSnapshot(e));
  }
  getValueLength(e, t = !1) {
    this._assertNotDisposed();
    const i = this.getFullModelRange(), n = this.getValueLengthInRange(i, e);
    return t ? this._buffer.getBOM().length + n : n;
  }
  getValueInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueInRange(this.validateRange(e), t);
  }
  getValueLengthInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getValueLengthInRange(this.validateRange(e), t);
  }
  getCharacterCountInRange(e, t = 0) {
    return this._assertNotDisposed(), this._buffer.getCharacterCountInRange(this.validateRange(e), t);
  }
  getLineCount() {
    return this._assertNotDisposed(), this._buffer.getLineCount();
  }
  getLineContent(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new lt("Illegal value for lineNumber");
    return this._buffer.getLineContent(e);
  }
  getLineLength(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new lt("Illegal value for lineNumber");
    return this._buffer.getLineLength(e);
  }
  getLinesContent() {
    if (this._assertNotDisposed(), this.isTooLargeForHeapOperation())
      throw new lt("Operation would exceed heap memory limits");
    return this._buffer.getLinesContent();
  }
  getEOL() {
    return this._assertNotDisposed(), this._buffer.getEOL();
  }
  getEndOfLineSequence() {
    return this._assertNotDisposed(), this._buffer.getEOL() === `
` ? 0 : 1;
  }
  getLineMinColumn(e) {
    return this._assertNotDisposed(), 1;
  }
  getLineMaxColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new lt("Illegal value for lineNumber");
    return this._buffer.getLineLength(e) + 1;
  }
  getLineFirstNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new lt("Illegal value for lineNumber");
    return this._buffer.getLineFirstNonWhitespaceColumn(e);
  }
  getLineLastNonWhitespaceColumn(e) {
    if (this._assertNotDisposed(), e < 1 || e > this.getLineCount())
      throw new lt("Illegal value for lineNumber");
    return this._buffer.getLineLastNonWhitespaceColumn(e);
  }
  /**
   * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.
   * Will try to not allocate if possible.
   */
  _validateRangeRelaxedNoAllocations(e) {
    const t = this._buffer.getLineCount(), i = e.startLineNumber, n = e.startColumn;
    let o = Math.floor(typeof i == "number" && !isNaN(i) ? i : 1), r = Math.floor(typeof n == "number" && !isNaN(n) ? n : 1);
    if (o < 1)
      o = 1, r = 1;
    else if (o > t)
      o = t, r = this.getLineMaxColumn(o);
    else if (r <= 1)
      r = 1;
    else {
      const h = this.getLineMaxColumn(o);
      r >= h && (r = h);
    }
    const a = e.endLineNumber, l = e.endColumn;
    let c = Math.floor(typeof a == "number" && !isNaN(a) ? a : 1), d = Math.floor(typeof l == "number" && !isNaN(l) ? l : 1);
    if (c < 1)
      c = 1, d = 1;
    else if (c > t)
      c = t, d = this.getLineMaxColumn(c);
    else if (d <= 1)
      d = 1;
    else {
      const h = this.getLineMaxColumn(c);
      d >= h && (d = h);
    }
    return i === o && n === r && a === c && l === d && e instanceof E && !(e instanceof Ue) ? e : new E(o, r, c, d);
  }
  _isValidPosition(e, t, i) {
    if (typeof e != "number" || typeof t != "number" || isNaN(e) || isNaN(t) || e < 1 || t < 1 || (e | 0) !== e || (t | 0) !== t)
      return !1;
    const n = this._buffer.getLineCount();
    if (e > n)
      return !1;
    if (t === 1)
      return !0;
    const o = this.getLineMaxColumn(e);
    if (t > o)
      return !1;
    if (i === 1) {
      const r = this._buffer.getLineCharCode(e, t - 2);
      if (Si(r))
        return !1;
    }
    return !0;
  }
  _validatePosition(e, t, i) {
    const n = Math.floor(typeof e == "number" && !isNaN(e) ? e : 1), o = Math.floor(typeof t == "number" && !isNaN(t) ? t : 1), r = this._buffer.getLineCount();
    if (n < 1)
      return new F(1, 1);
    if (n > r)
      return new F(r, this.getLineMaxColumn(r));
    if (o <= 1)
      return new F(n, 1);
    const a = this.getLineMaxColumn(n);
    if (o >= a)
      return new F(n, a);
    if (i === 1) {
      const l = this._buffer.getLineCharCode(n, o - 2);
      if (Si(l))
        return new F(n, o - 1);
    }
    return new F(n, o);
  }
  validatePosition(e) {
    return this._assertNotDisposed(), e instanceof F && this._isValidPosition(e.lineNumber, e.column, 1) ? e : this._validatePosition(e.lineNumber, e.column, 1);
  }
  _isValidRange(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn;
    if (!this._isValidPosition(
      i,
      n,
      0
      /* StringOffsetValidationType.Relaxed */
    ) || !this._isValidPosition(
      o,
      r,
      0
      /* StringOffsetValidationType.Relaxed */
    ))
      return !1;
    if (t === 1) {
      const a = n > 1 ? this._buffer.getLineCharCode(i, n - 2) : 0, l = r > 1 && r <= this._buffer.getLineLength(o) ? this._buffer.getLineCharCode(o, r - 2) : 0, c = Si(a), d = Si(l);
      return !c && !d;
    }
    return !0;
  }
  validateRange(e) {
    if (this._assertNotDisposed(), e instanceof E && !(e instanceof Ue) && this._isValidRange(e, 1))
      return e;
    const i = this._validatePosition(
      e.startLineNumber,
      e.startColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), n = this._validatePosition(
      e.endLineNumber,
      e.endColumn,
      0
      /* StringOffsetValidationType.Relaxed */
    ), o = i.lineNumber, r = i.column, a = n.lineNumber, l = n.column;
    {
      const c = r > 1 ? this._buffer.getLineCharCode(o, r - 2) : 0, d = l > 1 && l <= this._buffer.getLineLength(a) ? this._buffer.getLineCharCode(a, l - 2) : 0, h = Si(c), u = Si(d);
      return !h && !u ? new E(o, r, a, l) : o === a && r === l ? new E(o, r - 1, a, l - 1) : h && u ? new E(o, r - 1, a, l + 1) : h ? new E(o, r - 1, a, l) : new E(o, r, a, l + 1);
    }
  }
  modifyPosition(e, t) {
    this._assertNotDisposed();
    const i = this.getOffsetAt(e) + t;
    return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, i)));
  }
  getFullModelRange() {
    this._assertNotDisposed();
    const e = this.getLineCount();
    return new E(1, 1, e, this.getLineMaxColumn(e));
  }
  findMatchesLineByLine(e, t, i, n) {
    return this._buffer.findMatchesLineByLine(e, t, i, n);
  }
  findMatches(e, t, i, n, o, r, a = uee) {
    this._assertNotDisposed();
    let l = null;
    t !== null && (Array.isArray(t) || (t = [t]), t.every((h) => E.isIRange(h)) && (l = t.map((h) => this.validateRange(h)))), l === null && (l = [this.getFullModelRange()]), l = l.sort((h, u) => h.startLineNumber - u.startLineNumber || h.startColumn - u.startColumn);
    const c = [];
    c.push(l.reduce((h, u) => E.areIntersecting(h, u) ? h.plusRange(u) : (c.push(h), u)));
    let d;
    if (!i && e.indexOf(`
`) < 0) {
      const u = new Qd(e, i, n, o).parseSearchRequest();
      if (!u)
        return [];
      d = (g) => this.findMatchesLineByLine(g, u, r, a);
    } else
      d = (h) => mb.findMatches(this, new Qd(e, i, n, o), h, r, a);
    return c.map(d).reduce((h, u) => h.concat(u), []);
  }
  findNextMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    if (!i && e.indexOf(`
`) < 0) {
      const c = new Qd(e, i, n, o).parseSearchRequest();
      if (!c)
        return null;
      const d = this.getLineCount();
      let h = new E(a.lineNumber, a.column, d, this.getLineMaxColumn(d)), u = this.findMatchesLineByLine(h, c, r, 1);
      return mb.findNextMatch(this, new Qd(e, i, n, o), a, r), u.length > 0 || (h = new E(1, 1, a.lineNumber, this.getLineMaxColumn(a.lineNumber)), u = this.findMatchesLineByLine(h, c, r, 1), u.length > 0) ? u[0] : null;
    }
    return mb.findNextMatch(this, new Qd(e, i, n, o), a, r);
  }
  findPreviousMatch(e, t, i, n, o, r) {
    this._assertNotDisposed();
    const a = this.validatePosition(t);
    return mb.findPreviousMatch(this, new Qd(e, i, n, o), a, r);
  }
  //#endregion
  //#region Editing
  pushStackElement() {
    this._commandManager.pushStackElement();
  }
  popStackElement() {
    this._commandManager.popStackElement();
  }
  pushEOL(e) {
    if ((this.getEOL() === `
` ? 0 : 1) !== e)
      try {
        this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEOL(e);
      } finally {
        this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
      }
  }
  _validateEditOperation(e) {
    return e instanceof py ? e : new py(e.identifier || null, this.validateRange(e.range), e.text, e.forceMoveMarkers || !1, e.isAutoWhitespaceEdit || !1, e._isTracked || !1);
  }
  _validateEditOperations(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this._validateEditOperation(e[i]);
    return t;
  }
  pushEditOperations(e, t, i, n) {
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._pushEditOperations(e, this._validateEditOperations(t), i, n);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _pushEditOperations(e, t, i, n) {
    if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {
      const o = t.map((a) => ({
        range: this.validateRange(a.range),
        text: a.text
      }));
      let r = !0;
      if (e)
        for (let a = 0, l = e.length; a < l; a++) {
          const c = e[a];
          let d = !1;
          for (let h = 0, u = o.length; h < u; h++) {
            const g = o[h].range, m = g.startLineNumber > c.endLineNumber, p = c.startLineNumber > g.endLineNumber;
            if (!m && !p) {
              d = !0;
              break;
            }
          }
          if (!d) {
            r = !1;
            break;
          }
        }
      if (r)
        for (let a = 0, l = this._trimAutoWhitespaceLines.length; a < l; a++) {
          const c = this._trimAutoWhitespaceLines[a], d = this.getLineMaxColumn(c);
          let h = !0;
          for (let u = 0, g = o.length; u < g; u++) {
            const m = o[u].range, p = o[u].text;
            if (!(c < m.startLineNumber || c > m.endLineNumber) && !(c === m.startLineNumber && m.startColumn === d && m.isEmpty() && p && p.length > 0 && p.charAt(0) === `
`) && !(c === m.startLineNumber && m.startColumn === 1 && m.isEmpty() && p && p.length > 0 && p.charAt(p.length - 1) === `
`)) {
              h = !1;
              break;
            }
          }
          if (h) {
            const u = new E(c, 1, c, d);
            t.push(new py(null, u, null, !1, !1, !1));
          }
        }
      this._trimAutoWhitespaceLines = null;
    }
    return this._initialUndoRedoSnapshot === null && (this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri)), this._commandManager.pushEditOperation(e, t, i, n);
  }
  _applyUndo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.newPosition), l = this.getPositionAt(r.newEnd);
      return {
        range: new E(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.oldText
      };
    });
    this._applyUndoRedoEdits(o, t, !0, !1, i, n);
  }
  _applyRedo(e, t, i, n) {
    const o = e.map((r) => {
      const a = this.getPositionAt(r.oldPosition), l = this.getPositionAt(r.oldEnd);
      return {
        range: new E(a.lineNumber, a.column, l.lineNumber, l.column),
        text: r.newText
      };
    });
    this._applyUndoRedoEdits(o, t, !1, !0, i, n);
  }
  _applyUndoRedoEdits(e, t, i, n, o, r) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit(), this._isUndoing = i, this._isRedoing = n, this.applyEdits(e, !1), this.setEOL(t), this._overwriteAlternativeVersionId(o);
    } finally {
      this._isUndoing = !1, this._isRedoing = !1, this._eventEmitter.endDeferredEmit(r), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  applyEdits(e, t = !1) {
    try {
      this._onDidChangeDecorations.beginDeferredEmit(), this._eventEmitter.beginDeferredEmit();
      const i = this._validateEditOperations(e);
      return this._doApplyEdits(i, t);
    } finally {
      this._eventEmitter.endDeferredEmit(), this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _doApplyEdits(e, t) {
    const i = this._buffer.getLineCount(), n = this._buffer.applyEdits(e, this._options.trimAutoWhitespace, t), o = this._buffer.getLineCount(), r = n.changes;
    if (this._trimAutoWhitespaceLines = n.trimAutoWhitespaceLineNumbers, r.length !== 0) {
      for (let c = 0, d = r.length; c < d; c++) {
        const h = r[c];
        this._decorationsTree.acceptReplace(h.rangeOffset, h.rangeLength, h.text.length, h.forceMoveMarkers);
      }
      const a = [];
      this._increaseVersionId();
      let l = i;
      for (let c = 0, d = r.length; c < d; c++) {
        const h = r[c], [u] = bu(h.text);
        this._onDidChangeDecorations.fire();
        const g = h.range.startLineNumber, m = h.range.endLineNumber, p = m - g, A = u, _ = Math.min(p, A), b = A - p, C = o - l - b + g, w = C, S = C + A, x = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new F(w, 1)), this.getOffsetAt(new F(S, this.getLineMaxColumn(S))), 0), y = Rr.fromDecorations(x), D = new Pl(y);
        for (let I = _; I >= 0; I--) {
          const Q = g + I, P = C + I;
          D.takeFromEndWhile((j) => j.lineNumber > P);
          const W = D.takeFromEndWhile((j) => j.lineNumber === P);
          a.push(new OF(Q, this.getLineContent(P), W));
        }
        if (_ < p) {
          const I = g + _;
          a.push(new ree(I + 1, m));
        }
        if (_ < A) {
          const I = new Pl(y), Q = g + _, P = A - _, W = o - l - P + Q + 1, j = [], H = [];
          for (let J = 0; J < P; J++) {
            const se = W + J;
            H[J] = this.getLineContent(se), I.takeWhile((ce) => ce.lineNumber < se), j[J] = I.takeWhile((ce) => ce.lineNumber === se);
          }
          a.push(new aee(Q + 1, g + A, H, j));
        }
        l += b;
      }
      this._emitContentChangedEvent(new Ef(a, this.getVersionId(), this._isUndoing, this._isRedoing), {
        changes: r,
        eol: this._buffer.getEOL(),
        isEolChange: !1,
        versionId: this.getVersionId(),
        isUndoing: this._isUndoing,
        isRedoing: this._isRedoing,
        isFlush: !1
      });
    }
    return n.reverseEdits === null ? void 0 : n.reverseEdits;
  }
  undo() {
    return this._undoRedoService.undo(this.uri);
  }
  canUndo() {
    return this._undoRedoService.canUndo(this.uri);
  }
  redo() {
    return this._undoRedoService.redo(this.uri);
  }
  canRedo() {
    return this._undoRedoService.canRedo(this.uri);
  }
  //#endregion
  //#region Decorations
  handleBeforeFireDecorationsChangedEvent(e) {
    if (e === null || e.size === 0)
      return;
    const i = Array.from(e).map((n) => new OF(n, this.getLineContent(n), this._getInjectedTextInLine(n)));
    this._onDidChangeInjectedText.fire(new yW(i));
  }
  changeDecorations(e, t = 0) {
    this._assertNotDisposed();
    try {
      return this._onDidChangeDecorations.beginDeferredEmit(), this._changeDecorations(t, e);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  _changeDecorations(e, t) {
    const i = {
      addDecoration: (o, r) => this._deltaDecorationsImpl(e, [], [{ range: o, options: r }])[0],
      changeDecoration: (o, r) => {
        this._changeDecorationImpl(o, r);
      },
      changeDecorationOptions: (o, r) => {
        this._changeDecorationOptionsImpl(o, VF(r));
      },
      removeDecoration: (o) => {
        this._deltaDecorationsImpl(e, [o], []);
      },
      deltaDecorations: (o, r) => o.length === 0 && r.length === 0 ? [] : this._deltaDecorationsImpl(e, o, r)
    };
    let n = null;
    try {
      n = t(i);
    } catch (o) {
      Pe(o);
    }
    return i.addDecoration = ep, i.changeDecoration = ep, i.changeDecorationOptions = ep, i.removeDecoration = ep, i.deltaDecorations = ep, n;
  }
  deltaDecorations(e, t, i = 0) {
    if (this._assertNotDisposed(), e || (e = []), e.length === 0 && t.length === 0)
      return [];
    try {
      return this._deltaDecorationCallCnt++, this._deltaDecorationCallCnt > 1 && (console.warn("Invoking deltaDecorations recursively could lead to leaking decorations."), Pe(new Error("Invoking deltaDecorations recursively could lead to leaking decorations."))), this._onDidChangeDecorations.beginDeferredEmit(), this._deltaDecorationsImpl(i, e, t);
    } finally {
      this._onDidChangeDecorations.endDeferredEmit(), this._deltaDecorationCallCnt--;
    }
  }
  _getTrackedRange(e) {
    return this.getDecorationRange(e);
  }
  _setTrackedRange(e, t, i) {
    const n = e ? this._decorations[e] : null;
    if (!n)
      return t ? this._deltaDecorationsImpl(0, [], [{ range: t, options: WF[i] }], !0)[0] : null;
    if (!t)
      return this._decorationsTree.delete(n), delete this._decorations[n.id], null;
    const o = this._validateRangeRelaxedNoAllocations(t), r = this._buffer.getOffsetAt(o.startLineNumber, o.startColumn), a = this._buffer.getOffsetAt(o.endLineNumber, o.endColumn);
    return this._decorationsTree.delete(n), n.reset(this.getVersionId(), r, a, o), n.setOptions(WF[i]), this._decorationsTree.insert(n), n.id;
  }
  removeAllDecorationsWithOwnerId(e) {
    if (this._isDisposed)
      return;
    const t = this._decorationsTree.collectNodesFromOwner(e);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      this._decorationsTree.delete(o), delete this._decorations[o.id];
    }
  }
  getDecorationOptions(e) {
    const t = this._decorations[e];
    return t ? t.options : null;
  }
  getDecorationRange(e) {
    const t = this._decorations[e];
    return t ? this._decorationsTree.getNodeRange(this, t) : null;
  }
  getLineDecorations(e, t = 0, i = !1) {
    return e < 1 || e > this.getLineCount() ? [] : this.getLinesDecorations(e, e, t, i);
  }
  getLinesDecorations(e, t, i = 0, n = !1, o = !1) {
    const r = this.getLineCount(), a = Math.min(r, Math.max(1, e)), l = Math.min(r, Math.max(1, t)), c = this.getLineMaxColumn(l), d = new E(a, 1, l, c), h = this._getDecorationsInRange(d, i, n, o);
    return Sx(h, this._decorationProvider.getDecorationsInRange(d, i, n)), h;
  }
  getDecorationsInRange(e, t = 0, i = !1, n = !1, o = !1) {
    const r = this.validateRange(e), a = this._getDecorationsInRange(r, t, i, o);
    return Sx(a, this._decorationProvider.getDecorationsInRange(r, t, i, n)), a;
  }
  getOverviewRulerDecorations(e = 0, t = !1) {
    return this._decorationsTree.getAll(this, e, t, !0, !1);
  }
  getInjectedTextDecorations(e = 0) {
    return this._decorationsTree.getAllInjectedText(this, e);
  }
  _getInjectedTextInLine(e) {
    const t = this._buffer.getOffsetAt(e, 1), i = t + this._buffer.getLineLength(e), n = this._decorationsTree.getInjectedTextInInterval(this, t, i, 0);
    return Rr.fromDecorations(n).filter((o) => o.lineNumber === e);
  }
  getAllDecorations(e = 0, t = !1) {
    let i = this._decorationsTree.getAll(this, e, t, !1, !1);
    return i = i.concat(this._decorationProvider.getAllDecorations(e, t)), i;
  }
  getAllMarginDecorations(e = 0) {
    return this._decorationsTree.getAll(this, e, !1, !1, !0);
  }
  _getDecorationsInRange(e, t, i, n) {
    const o = this._buffer.getOffsetAt(e.startLineNumber, e.startColumn), r = this._buffer.getOffsetAt(e.endLineNumber, e.endColumn);
    return this._decorationsTree.getAllInInterval(this, o, r, t, i, n);
  }
  getRangeAt(e, t) {
    return this._buffer.getRangeAt(e, t - e);
  }
  _changeDecorationImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    if (i.options.after) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.endLineNumber);
    }
    if (i.options.before) {
      const a = this.getDecorationRange(e);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(a.startLineNumber);
    }
    const n = this._validateRangeRelaxedNoAllocations(t), o = this._buffer.getOffsetAt(n.startLineNumber, n.startColumn), r = this._buffer.getOffsetAt(n.endLineNumber, n.endColumn);
    this._decorationsTree.delete(i), i.reset(this.getVersionId(), o, r, n), this._decorationsTree.insert(i), this._onDidChangeDecorations.checkAffectedAndFire(i.options), i.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.endLineNumber), i.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(n.startLineNumber);
  }
  _changeDecorationOptionsImpl(e, t) {
    const i = this._decorations[e];
    if (!i)
      return;
    const n = !!(i.options.overviewRuler && i.options.overviewRuler.color), o = !!(t.overviewRuler && t.overviewRuler.color);
    if (this._onDidChangeDecorations.checkAffectedAndFire(i.options), this._onDidChangeDecorations.checkAffectedAndFire(t), i.options.after || t.after) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.endLineNumber);
    }
    if (i.options.before || t.before) {
      const l = this._decorationsTree.getNodeRange(this, i);
      this._onDidChangeDecorations.recordLineAffectedByInjectedText(l.startLineNumber);
    }
    const r = n !== o, a = pee(t) !== Dw(i);
    r || a ? (this._decorationsTree.delete(i), i.setOptions(t), this._decorationsTree.insert(i)) : i.setOptions(t);
  }
  _deltaDecorationsImpl(e, t, i, n = !1) {
    const o = this.getVersionId(), r = t.length;
    let a = 0;
    const l = i.length;
    let c = 0;
    this._onDidChangeDecorations.beginDeferredEmit();
    try {
      const d = new Array(l);
      for (; a < r || c < l; ) {
        let h = null;
        if (a < r) {
          do
            h = this._decorations[t[a++]];
          while (!h && a < r);
          if (h) {
            if (h.options.after) {
              const u = this._decorationsTree.getNodeRange(this, h);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.endLineNumber);
            }
            if (h.options.before) {
              const u = this._decorationsTree.getNodeRange(this, h);
              this._onDidChangeDecorations.recordLineAffectedByInjectedText(u.startLineNumber);
            }
            this._decorationsTree.delete(h), n || this._onDidChangeDecorations.checkAffectedAndFire(h.options);
          }
        }
        if (c < l) {
          if (!h) {
            const _ = ++this._lastDecorationId, b = `${this._instanceId};${_}`;
            h = new AW(b, 0, 0), this._decorations[b] = h;
          }
          const u = i[c], g = this._validateRangeRelaxedNoAllocations(u.range), m = VF(u.options), p = this._buffer.getOffsetAt(g.startLineNumber, g.startColumn), A = this._buffer.getOffsetAt(g.endLineNumber, g.endColumn);
          h.ownerId = e, h.reset(o, p, A, g), h.setOptions(m), h.options.after && this._onDidChangeDecorations.recordLineAffectedByInjectedText(g.endLineNumber), h.options.before && this._onDidChangeDecorations.recordLineAffectedByInjectedText(g.startLineNumber), n || this._onDidChangeDecorations.checkAffectedAndFire(m), this._decorationsTree.insert(h), d[c] = h.id, c++;
        } else
          h && delete this._decorations[h.id];
      }
      return d;
    } finally {
      this._onDidChangeDecorations.endDeferredEmit();
    }
  }
  //#endregion
  //#region Tokenization
  // TODO move them to the tokenization part.
  getLanguageId() {
    return this.tokenization.getLanguageId();
  }
  setLanguage(e, t) {
    typeof e == "string" ? (this._languageSelectionListener.clear(), this._setLanguage(e, t)) : (this._languageSelectionListener.value = e.onDidChange(() => this._setLanguage(e.languageId, t)), this._setLanguage(e.languageId, t));
  }
  _setLanguage(e, t) {
    this.tokenization.setLanguageId(e, t), this._languageService.requestRichLanguageFeatures(e);
  }
  getLanguageIdAtPosition(e, t) {
    return this.tokenization.getLanguageIdAtPosition(e, t);
  }
  getWordAtPosition(e) {
    return this._tokenizationTextModelPart.getWordAtPosition(e);
  }
  getWordUntilPosition(e) {
    return this._tokenizationTextModelPart.getWordUntilPosition(e);
  }
  //#endregion
  normalizePosition(e, t) {
    return e;
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return mee(this.getLineContent(e)) + 1;
  }
}, Gd = Lr, Lr._MODEL_SYNC_LIMIT = 50 * 1024 * 1024, Lr.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024, Lr.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1e3, Lr.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024, Lr.DEFAULT_CREATION_OPTIONS = {
  isForSimpleWidget: !1,
  tabSize: an.tabSize,
  indentSize: an.indentSize,
  insertSpaces: an.insertSpaces,
  detectIndentation: !1,
  defaultEOL: 1,
  trimAutoWhitespace: an.trimAutoWhitespace,
  largeFileOptimizations: an.largeFileOptimizations,
  bracketPairColorizationOptions: an.bracketPairColorizationOptions
}, Lr);
ZA = Gd = cee([
  Bb(4, hN),
  Bb(5, si),
  Bb(6, tn),
  Bb(7, ke)
], ZA);
function mee(s) {
  let e = 0;
  for (const t of s)
    if (t === " " || t === "	")
      e++;
    else
      break;
  return e;
}
function Wy(s) {
  return !!(s.options.overviewRuler && s.options.overviewRuler.color);
}
function pee(s) {
  return !!s.after || !!s.before;
}
function Dw(s) {
  return !!s.options.after || !!s.options.before;
}
class HF {
  constructor() {
    this._decorationsTree0 = new Fy(), this._decorationsTree1 = new Fy(), this._injectedTextDecorationsTree = new Fy();
  }
  ensureAllNodesHaveRanges(e) {
    this.getAll(e, 0, !1, !1, !1);
  }
  _ensureNodesHaveRanges(e, t) {
    for (const i of t)
      i.range === null && (i.range = e.getRangeAt(i.cachedAbsoluteStart, i.cachedAbsoluteEnd));
    return t;
  }
  getAllInInterval(e, t, i, n, o, r) {
    const a = e.getVersionId(), l = this._intervalSearch(t, i, n, o, a, r);
    return this._ensureNodesHaveRanges(e, l);
  }
  _intervalSearch(e, t, i, n, o, r) {
    const a = this._decorationsTree0.intervalSearch(e, t, i, n, o, r), l = this._decorationsTree1.intervalSearch(e, t, i, n, o, r), c = this._injectedTextDecorationsTree.intervalSearch(e, t, i, n, o, r);
    return a.concat(l).concat(c);
  }
  getInjectedTextInInterval(e, t, i, n) {
    const o = e.getVersionId(), r = this._injectedTextDecorationsTree.intervalSearch(t, i, n, !1, o, !1);
    return this._ensureNodesHaveRanges(e, r).filter((a) => a.options.showIfCollapsed || !a.range.isEmpty());
  }
  getAllInjectedText(e, t) {
    const i = e.getVersionId(), n = this._injectedTextDecorationsTree.search(t, !1, i, !1);
    return this._ensureNodesHaveRanges(e, n).filter((o) => o.options.showIfCollapsed || !o.range.isEmpty());
  }
  getAll(e, t, i, n, o) {
    const r = e.getVersionId(), a = this._search(t, i, n, r, o);
    return this._ensureNodesHaveRanges(e, a);
  }
  _search(e, t, i, n, o) {
    if (i)
      return this._decorationsTree1.search(e, t, n, o);
    {
      const r = this._decorationsTree0.search(e, t, n, o), a = this._decorationsTree1.search(e, t, n, o), l = this._injectedTextDecorationsTree.search(e, t, n, o);
      return r.concat(a).concat(l);
    }
  }
  collectNodesFromOwner(e) {
    const t = this._decorationsTree0.collectNodesFromOwner(e), i = this._decorationsTree1.collectNodesFromOwner(e), n = this._injectedTextDecorationsTree.collectNodesFromOwner(e);
    return t.concat(i).concat(n);
  }
  collectNodesPostOrder() {
    const e = this._decorationsTree0.collectNodesPostOrder(), t = this._decorationsTree1.collectNodesPostOrder(), i = this._injectedTextDecorationsTree.collectNodesPostOrder();
    return e.concat(t).concat(i);
  }
  insert(e) {
    Dw(e) ? this._injectedTextDecorationsTree.insert(e) : Wy(e) ? this._decorationsTree1.insert(e) : this._decorationsTree0.insert(e);
  }
  delete(e) {
    Dw(e) ? this._injectedTextDecorationsTree.delete(e) : Wy(e) ? this._decorationsTree1.delete(e) : this._decorationsTree0.delete(e);
  }
  getNodeRange(e, t) {
    const i = e.getVersionId();
    return t.cachedVersionId !== i && this._resolveNode(t, i), t.range === null && (t.range = e.getRangeAt(t.cachedAbsoluteStart, t.cachedAbsoluteEnd)), t.range;
  }
  _resolveNode(e, t) {
    Dw(e) ? this._injectedTextDecorationsTree.resolveNode(e, t) : Wy(e) ? this._decorationsTree1.resolveNode(e, t) : this._decorationsTree0.resolveNode(e, t);
  }
  acceptReplace(e, t, i, n) {
    this._decorationsTree0.acceptReplace(e, t, i, n), this._decorationsTree1.acceptReplace(e, t, i, n), this._injectedTextDecorationsTree.acceptReplace(e, t, i, n);
  }
}
function Yr(s) {
  return s.replace(/[^a-z0-9\-_]/gi, " ");
}
class xW {
  constructor(e) {
    this.color = e.color || "", this.darkColor = e.darkColor || "";
  }
}
class Aee extends xW {
  constructor(e) {
    super(e), this._resolvedColor = null, this.position = typeof e.position == "number" ? e.position : Bl.Center;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = null;
  }
  _resolveColor(e, t) {
    if (typeof e == "string")
      return e;
    const i = e ? t.getColor(e.id) : null;
    return i ? i.toString() : "";
  }
}
class _ee {
  constructor(e) {
    this.position = e?.position ?? qo.Center, this.persistLane = e?.persistLane;
  }
}
class bee extends xW {
  constructor(e) {
    super(e), this.position = e.position, this.sectionHeaderStyle = e.sectionHeaderStyle ?? null, this.sectionHeaderText = e.sectionHeaderText ?? null;
  }
  getColor(e) {
    return this._resolvedColor || (e.type !== "light" && this.darkColor ? this._resolvedColor = this._resolveColor(this.darkColor, e) : this._resolvedColor = this._resolveColor(this.color, e)), this._resolvedColor;
  }
  invalidateCachedColor() {
    this._resolvedColor = void 0;
  }
  _resolveColor(e, t) {
    return typeof e == "string" ? Y.fromHex(e) : t.getColor(e.id);
  }
}
class dd {
  static from(e) {
    return e instanceof dd ? e : new dd(e);
  }
  constructor(e) {
    this.content = e.content || "", this.inlineClassName = e.inlineClassName || null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.attachedData = e.attachedData || null, this.cursorStops = e.cursorStops || null;
  }
}
class He {
  static register(e) {
    return new He(e);
  }
  static createDynamic(e) {
    return new He(e);
  }
  constructor(e) {
    this.description = e.description, this.blockClassName = e.blockClassName ? Yr(e.blockClassName) : null, this.blockDoesNotCollapse = e.blockDoesNotCollapse ?? null, this.blockIsAfterEnd = e.blockIsAfterEnd ?? null, this.blockPadding = e.blockPadding ?? null, this.stickiness = e.stickiness || 0, this.zIndex = e.zIndex || 0, this.className = e.className ? Yr(e.className) : null, this.shouldFillLineOnLineBreak = e.shouldFillLineOnLineBreak ?? null, this.hoverMessage = e.hoverMessage || null, this.glyphMarginHoverMessage = e.glyphMarginHoverMessage || null, this.lineNumberHoverMessage = e.lineNumberHoverMessage || null, this.isWholeLine = e.isWholeLine || !1, this.showIfCollapsed = e.showIfCollapsed || !1, this.collapseOnReplaceEdit = e.collapseOnReplaceEdit || !1, this.overviewRuler = e.overviewRuler ? new Aee(e.overviewRuler) : null, this.minimap = e.minimap ? new bee(e.minimap) : null, this.glyphMargin = e.glyphMarginClassName ? new _ee(e.glyphMargin) : null, this.glyphMarginClassName = e.glyphMarginClassName ? Yr(e.glyphMarginClassName) : null, this.linesDecorationsClassName = e.linesDecorationsClassName ? Yr(e.linesDecorationsClassName) : null, this.lineNumberClassName = e.lineNumberClassName ? Yr(e.lineNumberClassName) : null, this.linesDecorationsTooltip = e.linesDecorationsTooltip ? k7(e.linesDecorationsTooltip) : null, this.firstLineDecorationClassName = e.firstLineDecorationClassName ? Yr(e.firstLineDecorationClassName) : null, this.marginClassName = e.marginClassName ? Yr(e.marginClassName) : null, this.inlineClassName = e.inlineClassName ? Yr(e.inlineClassName) : null, this.inlineClassNameAffectsLetterSpacing = e.inlineClassNameAffectsLetterSpacing || !1, this.beforeContentClassName = e.beforeContentClassName ? Yr(e.beforeContentClassName) : null, this.afterContentClassName = e.afterContentClassName ? Yr(e.afterContentClassName) : null, this.after = e.after ? dd.from(e.after) : null, this.before = e.before ? dd.from(e.before) : null, this.hideInCommentTokens = e.hideInCommentTokens ?? !1, this.hideInStringTokens = e.hideInStringTokens ?? !1;
  }
}
He.EMPTY = He.register({ description: "empty" });
const WF = [
  He.register({
    description: "tracked-range-always-grows-when-typing-at-edges",
    stickiness: 0
    /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
  }),
  He.register({
    description: "tracked-range-never-grows-when-typing-at-edges",
    stickiness: 1
    /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
  }),
  He.register({
    description: "tracked-range-grows-only-when-typing-before",
    stickiness: 2
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */
  }),
  He.register({
    description: "tracked-range-grows-only-when-typing-after",
    stickiness: 3
    /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  })
];
function VF(s) {
  return s instanceof He ? s : He.createDynamic(s);
}
class wee extends V {
  constructor(e) {
    super(), this.handleBeforeFire = e, this._actual = this._register(new B()), this.event = this._actual.event, this._affectedInjectedTextLines = null, this._deferredCnt = 0, this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._affectsLineNumber = !1;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit() {
    this._deferredCnt--, this._deferredCnt === 0 && (this._shouldFireDeferred && this.doFire(), this._affectedInjectedTextLines?.clear(), this._affectedInjectedTextLines = null);
  }
  recordLineAffectedByInjectedText(e) {
    this._affectedInjectedTextLines || (this._affectedInjectedTextLines = /* @__PURE__ */ new Set()), this._affectedInjectedTextLines.add(e);
  }
  checkAffectedAndFire(e) {
    this._affectsMinimap || (this._affectsMinimap = !!e.minimap?.position), this._affectsOverviewRuler || (this._affectsOverviewRuler = !!e.overviewRuler?.color), this._affectsGlyphMargin || (this._affectsGlyphMargin = !!e.glyphMarginClassName), this._affectsLineNumber || (this._affectsLineNumber = !!e.lineNumberClassName), this.tryFire();
  }
  fire() {
    this._affectsMinimap = !0, this._affectsOverviewRuler = !0, this._affectsGlyphMargin = !0, this.tryFire();
  }
  tryFire() {
    this._deferredCnt === 0 ? this.doFire() : this._shouldFireDeferred = !0;
  }
  doFire() {
    this.handleBeforeFire(this._affectedInjectedTextLines);
    const e = {
      affectsMinimap: this._affectsMinimap,
      affectsOverviewRuler: this._affectsOverviewRuler,
      affectsGlyphMargin: this._affectsGlyphMargin,
      affectsLineNumber: this._affectsLineNumber
    };
    this._shouldFireDeferred = !1, this._affectsMinimap = !1, this._affectsOverviewRuler = !1, this._affectsGlyphMargin = !1, this._actual.fire(e);
  }
}
class Cee extends V {
  constructor() {
    super(), this._fastEmitter = this._register(new B()), this.fastEvent = this._fastEmitter.event, this._slowEmitter = this._register(new B()), this.slowEvent = this._slowEmitter.event, this._deferredCnt = 0, this._deferredEvent = null;
  }
  beginDeferredEmit() {
    this._deferredCnt++;
  }
  endDeferredEmit(e = null) {
    if (this._deferredCnt--, this._deferredCnt === 0 && this._deferredEvent !== null) {
      this._deferredEvent.rawContentChangedEvent.resultingSelection = e;
      const t = this._deferredEvent;
      this._deferredEvent = null, this._fastEmitter.fire(t), this._slowEmitter.fire(t);
    }
  }
  fire(e) {
    if (this._deferredCnt > 0) {
      this._deferredEvent ? this._deferredEvent = this._deferredEvent.merge(e) : this._deferredEvent = e;
      return;
    }
    this._fastEmitter.fire(e), this._slowEmitter.fire(e);
  }
}
var vee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Fb = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Cg;
function Bd(s) {
  return s.toString();
}
let See = class {
  constructor(e, t, i) {
    this.model = e, this._modelEventListeners = new X(), this.model = e, this._modelEventListeners.add(e.onWillDispose(() => t(e))), this._modelEventListeners.add(e.onDidChangeLanguage((n) => i(e, n)));
  }
  dispose() {
    this._modelEventListeners.dispose();
  }
};
const yee = Fn || ze ? 1 : 2;
class xee {
  constructor(e, t, i, n, o, r, a, l) {
    this.uri = e, this.initialUndoRedoSnapshot = t, this.time = i, this.sharesUndoRedoStack = n, this.heapSize = o, this.sha1 = r, this.versionId = a, this.alternativeVersionId = l;
  }
}
var Fh;
let Ck = (Fh = class extends V {
  constructor(e, t, i, n) {
    super(), this._configurationService = e, this._resourcePropertiesService = t, this._undoRedoService = i, this._instantiationService = n, this._onModelAdded = this._register(new B()), this.onModelAdded = this._onModelAdded.event, this._onModelRemoved = this._register(new B()), this.onModelRemoved = this._onModelRemoved.event, this._onModelModeChanged = this._register(new B()), this.onModelLanguageChanged = this._onModelModeChanged.event, this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null), this._models = {}, this._disposedModels = /* @__PURE__ */ new Map(), this._disposedModelsHeapSize = 0, this._register(this._configurationService.onDidChangeConfiguration((o) => this._updateModelOptions(o))), this._updateModelOptions(void 0);
  }
  static _readModelOptions(e, t) {
    let i = an.tabSize;
    if (e.editor && typeof e.editor.tabSize < "u") {
      const u = parseInt(e.editor.tabSize, 10);
      isNaN(u) || (i = u), i < 1 && (i = 1);
    }
    let n = "tabSize";
    if (e.editor && typeof e.editor.indentSize < "u" && e.editor.indentSize !== "tabSize") {
      const u = parseInt(e.editor.indentSize, 10);
      isNaN(u) || (n = Math.max(u, 1));
    }
    let o = an.insertSpaces;
    e.editor && typeof e.editor.insertSpaces < "u" && (o = e.editor.insertSpaces === "false" ? !1 : !!e.editor.insertSpaces);
    let r = yee;
    const a = e.eol;
    a === `\r
` ? r = 2 : a === `
` && (r = 1);
    let l = an.trimAutoWhitespace;
    e.editor && typeof e.editor.trimAutoWhitespace < "u" && (l = e.editor.trimAutoWhitespace === "false" ? !1 : !!e.editor.trimAutoWhitespace);
    let c = an.detectIndentation;
    e.editor && typeof e.editor.detectIndentation < "u" && (c = e.editor.detectIndentation === "false" ? !1 : !!e.editor.detectIndentation);
    let d = an.largeFileOptimizations;
    e.editor && typeof e.editor.largeFileOptimizations < "u" && (d = e.editor.largeFileOptimizations === "false" ? !1 : !!e.editor.largeFileOptimizations);
    let h = an.bracketPairColorizationOptions;
    return e.editor?.bracketPairColorization && typeof e.editor.bracketPairColorization == "object" && (h = {
      enabled: !!e.editor.bracketPairColorization.enabled,
      independentColorPoolPerBracketType: !!e.editor.bracketPairColorization.independentColorPoolPerBracketType
    }), {
      isForSimpleWidget: t,
      tabSize: i,
      indentSize: n,
      insertSpaces: o,
      detectIndentation: c,
      defaultEOL: r,
      trimAutoWhitespace: l,
      largeFileOptimizations: d,
      bracketPairColorizationOptions: h
    };
  }
  _getEOL(e, t) {
    if (e)
      return this._resourcePropertiesService.getEOL(e, t);
    const i = this._configurationService.getValue("files.eol", { overrideIdentifier: t });
    return i && typeof i == "string" && i !== "auto" ? i : Us === 3 || Us === 2 ? `
` : `\r
`;
  }
  _shouldRestoreUndoStack() {
    const e = this._configurationService.getValue("files.restoreUndoStack");
    return typeof e == "boolean" ? e : !0;
  }
  getCreationOptions(e, t, i) {
    const n = typeof e == "string" ? e : e.languageId;
    let o = this._modelCreationOptionsByLanguageAndResource[n + t];
    if (!o) {
      const r = this._configurationService.getValue("editor", { overrideIdentifier: n, resource: t }), a = this._getEOL(t, n);
      o = Cg._readModelOptions({ editor: r, eol: a }, i), this._modelCreationOptionsByLanguageAndResource[n + t] = o;
    }
    return o;
  }
  _updateModelOptions(e) {
    const t = this._modelCreationOptionsByLanguageAndResource;
    this._modelCreationOptionsByLanguageAndResource = /* @__PURE__ */ Object.create(null);
    const i = Object.keys(this._models);
    for (let n = 0, o = i.length; n < o; n++) {
      const r = i[n], a = this._models[r], l = a.model.getLanguageId(), c = a.model.uri;
      if (e && !e.affectsConfiguration("editor", { overrideIdentifier: l, resource: c }) && !e.affectsConfiguration("files.eol", { overrideIdentifier: l, resource: c }))
        continue;
      const d = t[l + c], h = this.getCreationOptions(l, c, a.model.isForSimpleWidget);
      Cg._setModelOptionsForModel(a.model, h, d);
    }
  }
  static _setModelOptionsForModel(e, t, i) {
    i && i.defaultEOL !== t.defaultEOL && e.getLineCount() === 1 && e.setEOL(
      t.defaultEOL === 1 ? 0 : 1
      /* EndOfLineSequence.CRLF */
    ), !(i && i.detectIndentation === t.detectIndentation && i.insertSpaces === t.insertSpaces && i.tabSize === t.tabSize && i.indentSize === t.indentSize && i.trimAutoWhitespace === t.trimAutoWhitespace && bs(i.bracketPairColorizationOptions, t.bracketPairColorizationOptions)) && (t.detectIndentation ? (e.detectIndentation(t.insertSpaces, t.tabSize), e.updateOptions({
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    })) : e.updateOptions({
      insertSpaces: t.insertSpaces,
      tabSize: t.tabSize,
      indentSize: t.indentSize,
      trimAutoWhitespace: t.trimAutoWhitespace,
      bracketColorizationOptions: t.bracketPairColorizationOptions
    }));
  }
  // --- begin IModelService
  _insertDisposedModel(e) {
    this._disposedModels.set(Bd(e.uri), e), this._disposedModelsHeapSize += e.heapSize;
  }
  _removeDisposedModel(e) {
    const t = this._disposedModels.get(Bd(e));
    return t && (this._disposedModelsHeapSize -= t.heapSize), this._disposedModels.delete(Bd(e)), t;
  }
  _ensureDisposedModelsHeapSize(e) {
    if (this._disposedModelsHeapSize > e) {
      const t = [];
      for (this._disposedModels.forEach((i) => {
        i.sharesUndoRedoStack || t.push(i);
      }), t.sort((i, n) => i.time - n.time); t.length > 0 && this._disposedModelsHeapSize > e; ) {
        const i = t.shift();
        this._removeDisposedModel(i.uri), i.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(i.initialUndoRedoSnapshot);
      }
    }
  }
  _createModelData(e, t, i, n) {
    const o = this.getCreationOptions(t, i, n), r = this._instantiationService.createInstance(ZA, e, t, o, i);
    if (i && this._disposedModels.has(Bd(i))) {
      const c = this._removeDisposedModel(i), d = this._undoRedoService.getElements(i), h = this._getSHA1Computer(), u = h.canComputeSHA1(r) ? h.computeSHA1(r) === c.sha1 : !1;
      if (u || c.sharesUndoRedoStack) {
        for (const g of d.past)
          hl(g) && g.matchesResource(i) && g.setModel(r);
        for (const g of d.future)
          hl(g) && g.matchesResource(i) && g.setModel(r);
        this._undoRedoService.setElementsValidFlag(i, !0, (g) => hl(g) && g.matchesResource(i)), u && (r._overwriteVersionId(c.versionId), r._overwriteAlternativeVersionId(c.alternativeVersionId), r._overwriteInitialUndoRedoSnapshot(c.initialUndoRedoSnapshot));
      } else
        c.initialUndoRedoSnapshot !== null && this._undoRedoService.restoreSnapshot(c.initialUndoRedoSnapshot);
    }
    const a = Bd(r.uri);
    if (this._models[a])
      throw new Error("ModelService: Cannot add model because it already exists!");
    const l = new See(r, (c) => this._onWillDispose(c), (c, d) => this._onDidChangeLanguage(c, d));
    return this._models[a] = l, l;
  }
  createModel(e, t, i, n = !1) {
    let o;
    return t ? o = this._createModelData(e, t, i, n) : o = this._createModelData(e, Js, i, n), this._onModelAdded.fire(o.model), o.model;
  }
  getModels() {
    const e = [], t = Object.keys(this._models);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push(this._models[o].model);
    }
    return e;
  }
  getModel(e) {
    const t = Bd(e), i = this._models[t];
    return i ? i.model : null;
  }
  // --- end IModelService
  _schemaShouldMaintainUndoRedoElements(e) {
    return e.scheme === Ie.file || e.scheme === Ie.vscodeRemote || e.scheme === Ie.vscodeUserData || e.scheme === Ie.vscodeNotebookCell || e.scheme === "fake-fs";
  }
  _onWillDispose(e) {
    const t = Bd(e.uri), i = this._models[t], n = this._undoRedoService.getUriComparisonKey(e.uri) !== e.uri.toString();
    let o = !1, r = 0;
    if (n || this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(e.uri)) {
      const c = this._undoRedoService.getElements(e.uri);
      if (c.past.length > 0 || c.future.length > 0) {
        for (const d of c.past)
          hl(d) && d.matchesResource(e.uri) && (o = !0, r += d.heapSize(e.uri), d.setModel(e.uri));
        for (const d of c.future)
          hl(d) && d.matchesResource(e.uri) && (o = !0, r += d.heapSize(e.uri), d.setModel(e.uri));
      }
    }
    const a = Cg.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK, l = this._getSHA1Computer();
    if (o)
      if (!n && (r > a || !l.canComputeSHA1(e))) {
        const c = i.model.getInitialUndoRedoSnapshot();
        c !== null && this._undoRedoService.restoreSnapshot(c);
      } else
        this._ensureDisposedModelsHeapSize(a - r), this._undoRedoService.setElementsValidFlag(e.uri, !1, (c) => hl(c) && c.matchesResource(e.uri)), this._insertDisposedModel(new xee(e.uri, i.model.getInitialUndoRedoSnapshot(), Date.now(), n, r, l.computeSHA1(e), e.getVersionId(), e.getAlternativeVersionId()));
    else if (!n) {
      const c = i.model.getInitialUndoRedoSnapshot();
      c !== null && this._undoRedoService.restoreSnapshot(c);
    }
    delete this._models[t], i.dispose(), delete this._modelCreationOptionsByLanguageAndResource[e.getLanguageId() + e.uri], this._onModelRemoved.fire(e);
  }
  _onDidChangeLanguage(e, t) {
    const i = t.oldLanguage, n = e.getLanguageId(), o = this.getCreationOptions(i, e.uri, e.isForSimpleWidget), r = this.getCreationOptions(n, e.uri, e.isForSimpleWidget);
    Cg._setModelOptionsForModel(e, r, o), this._onModelModeChanged.fire({ model: e, oldLanguageId: i });
  }
  _getSHA1Computer() {
    return new vk();
  }
}, Cg = Fh, Fh.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024, Fh);
Ck = Cg = vee([
  Fb(0, ht),
  Fb(1, k5),
  Fb(2, hN),
  Fb(3, ke)
], Ck);
const I1 = class I1 {
  // takes 200ms to compute a sha1 on a 10MB model on a new machine
  canComputeSHA1(e) {
    return e.getValueLength() <= I1.MAX_MODEL_SIZE;
  }
  computeSHA1(e) {
    const t = new zE(), i = e.createSnapshot();
    let n;
    for (; n = i.read(); )
      t.update(n);
    return t.digest();
  }
};
I1.MAX_MODEL_SIZE = 10 * 1024 * 1024;
let vk = I1;
var Sk;
(function(s) {
  s[s.PRESERVE = 0] = "PRESERVE", s[s.LAST = 1] = "LAST";
})(Sk || (Sk = {}));
const EW = {
  Quickaccess: "workbench.contributions.quickaccess"
};
class Eee {
  constructor() {
    this.providers = [], this.defaultProvider = void 0;
  }
  registerQuickAccessProvider(e) {
    return e.prefix.length === 0 ? this.defaultProvider = e : this.providers.push(e), this.providers.sort((t, i) => i.prefix.length - t.prefix.length), we(() => {
      this.providers.splice(this.providers.indexOf(e), 1), this.defaultProvider === e && (this.defaultProvider = void 0);
    });
  }
  getQuickAccessProviders() {
    return mm([this.defaultProvider, ...this.providers]);
  }
  getQuickAccessProvider(e) {
    return e && this.providers.find((i) => e.startsWith(i.prefix)) || void 0 || this.defaultProvider;
  }
}
ji.add(EW.Quickaccess, new Eee());
const Lee = { ctrlCmd: !1, alt: !1 };
var sm;
(function(s) {
  s[s.Blur = 1] = "Blur", s[s.Gesture = 2] = "Gesture", s[s.Other = 3] = "Other";
})(sm || (sm = {}));
var ca;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.FIRST = 1] = "FIRST", s[s.SECOND = 2] = "SECOND", s[s.LAST = 3] = "LAST";
})(ca || (ca = {}));
var yt;
(function(s) {
  s[s.First = 1] = "First", s[s.Second = 2] = "Second", s[s.Last = 3] = "Last", s[s.Next = 4] = "Next", s[s.Previous = 5] = "Previous", s[s.NextPage = 6] = "NextPage", s[s.PreviousPage = 7] = "PreviousPage", s[s.NextSeparator = 8] = "NextSeparator", s[s.PreviousSeparator = 9] = "PreviousSeparator";
})(yt || (yt = {}));
var KC;
(function(s) {
  s[s.Title = 1] = "Title", s[s.Inline = 2] = "Inline";
})(KC || (KC = {}));
const Q_ = We("quickInputService");
var kee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zF = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let yk = class extends V {
  constructor(e, t) {
    super(), this.quickInputService = e, this.instantiationService = t, this.registry = ji.as(EW.Quickaccess), this.mapProviderToDescriptor = /* @__PURE__ */ new Map(), this.lastAcceptedPickerValues = /* @__PURE__ */ new Map(), this.visibleQuickAccess = void 0;
  }
  show(e = "", t) {
    this.doShowOrPick(e, !1, t);
  }
  doShowOrPick(e, t, i) {
    const [n, o] = this.getOrInstantiateProvider(e, i?.enabledProviderPrefixes), r = this.visibleQuickAccess, a = r?.descriptor;
    if (r && o && a === o) {
      e !== o.prefix && !i?.preserveValue && (r.picker.value = e), this.adjustValueSelection(r.picker, o, i);
      return;
    }
    if (o && !i?.preserveValue) {
      let m;
      if (r && a && a !== o) {
        const p = r.value.substr(a.prefix.length);
        p && (m = `${o.prefix}${p}`);
      }
      if (!m) {
        const p = n?.defaultFilterValue;
        p === Sk.LAST ? m = this.lastAcceptedPickerValues.get(o) : typeof p == "string" && (m = `${o.prefix}${p}`);
      }
      typeof m == "string" && (e = m);
    }
    const l = r?.picker?.valueSelection, c = r?.picker?.value, d = new X(), h = d.add(this.quickInputService.createQuickPick({ useSeparators: !0 }));
    h.value = e, this.adjustValueSelection(h, o, i), h.placeholder = i?.placeholder ?? o?.placeholder, h.quickNavigate = i?.quickNavigateConfiguration, h.hideInput = !!h.quickNavigate && !r, (typeof i?.itemActivation == "number" || i?.quickNavigateConfiguration) && (h.itemActivation = i?.itemActivation ?? ca.SECOND), h.contextKey = o?.contextKey, h.filterValue = (m) => m.substring(o ? o.prefix.length : 0);
    let u;
    t && (u = new DH(), d.add(te.once(h.onWillAccept)((m) => {
      m.veto(), h.hide();
    }))), d.add(this.registerPickerListeners(h, n, o, e, i));
    const g = d.add(new vs());
    if (n && d.add(n.provide(h, g.token, i?.providerOptions)), te.once(h.onDidHide)(() => {
      h.selectedItems.length === 0 && g.cancel(), d.dispose(), u?.complete(h.selectedItems.slice(0));
    }), h.show(), l && c === e && (h.valueSelection = l), t)
      return u?.p;
  }
  adjustValueSelection(e, t, i) {
    let n;
    i?.preserveValue ? n = [e.value.length, e.value.length] : n = [t?.prefix.length ?? 0, e.value.length], e.valueSelection = n;
  }
  registerPickerListeners(e, t, i, n, o) {
    const r = new X(), a = this.visibleQuickAccess = { picker: e, descriptor: i, value: n };
    return r.add(we(() => {
      a === this.visibleQuickAccess && (this.visibleQuickAccess = void 0);
    })), r.add(e.onDidChangeValue((l) => {
      const [c] = this.getOrInstantiateProvider(l, o?.enabledProviderPrefixes);
      c !== t ? this.show(l, {
        enabledProviderPrefixes: o?.enabledProviderPrefixes,
        // do not rewrite value from user typing!
        preserveValue: !0,
        // persist the value of the providerOptions from the original showing
        providerOptions: o?.providerOptions
      }) : a.value = l;
    })), i && r.add(e.onDidAccept(() => {
      this.lastAcceptedPickerValues.set(i, e.value);
    })), r;
  }
  getOrInstantiateProvider(e, t) {
    const i = this.registry.getQuickAccessProvider(e);
    if (!i || t && !t?.includes(i.prefix))
      return [void 0, void 0];
    let n = this.mapProviderToDescriptor.get(i);
    return n || (n = this.instantiationService.createInstance(i.ctor), this.mapProviderToDescriptor.set(i, n)), [n, i];
  }
};
yk = kee([
  zF(0, Q_),
  zF(1, ke)
], yk);
class xm extends to {
  constructor(e) {
    super(), this._onChange = this._register(new B()), this.onChange = this._onChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._opts = e, this._checked = this._opts.isChecked;
    const t = ["monaco-custom-toggle"];
    this._opts.icon && (this._icon = this._opts.icon, t.push(...pe.asClassNameArray(this._icon))), this._opts.actionClassName && t.push(...this._opts.actionClassName.split(" ")), this._checked && t.push("checked"), this.domNode = document.createElement("div"), this._hover = this._register(Oa().setupManagedHover(e.hoverDelegate ?? Ls("mouse"), this.domNode, this._opts.title)), this.domNode.classList.add(...t), this._opts.notFocusable || (this.domNode.tabIndex = 0), this.domNode.setAttribute("role", "checkbox"), this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.setAttribute("aria-label", this._opts.title), this.applyStyles(), this.onclick(this.domNode, (i) => {
      this.enabled && (this.checked = !this._checked, this._onChange.fire(!1), i.preventDefault());
    }), this._register(this.ignoreGesture(this.domNode)), this.onkeydown(this.domNode, (i) => {
      if (i.keyCode === 10 || i.keyCode === 3) {
        this.checked = !this._checked, this._onChange.fire(!0), i.preventDefault(), i.stopPropagation();
        return;
      }
      this._onKeyDown.fire(i);
    });
  }
  get enabled() {
    return this.domNode.getAttribute("aria-disabled") !== "true";
  }
  focus() {
    this.domNode.focus();
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    this._checked = e, this.domNode.setAttribute("aria-checked", String(this._checked)), this.domNode.classList.toggle("checked", this._checked), this.applyStyles();
  }
  width() {
    return 22;
  }
  applyStyles() {
    this.domNode && (this.domNode.style.borderColor = this._checked && this._opts.inputActiveOptionBorder || "", this.domNode.style.color = this._checked && this._opts.inputActiveOptionForeground || "inherit", this.domNode.style.backgroundColor = this._checked && this._opts.inputActiveOptionBackground || "");
  }
  enable() {
    this.domNode.setAttribute("aria-disabled", String(!1));
  }
  disable() {
    this.domNode.setAttribute("aria-disabled", String(!0));
  }
}
var Dee = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class LW {
  constructor(e) {
    this.nodes = e;
  }
  toString() {
    return this.nodes.map((e) => typeof e == "string" ? e : e.label).join("");
  }
}
Dee([
  oi
], LW.prototype, "toString", null);
const Iee = /\[([^\]]+)\]\(((?:https?:\/\/|command:|file:)[^\)\s]+)(?: (["'])(.+?)(\3))?\)/gi;
function Mee(s) {
  const e = [];
  let t = 0, i;
  for (; i = Iee.exec(s); ) {
    i.index - t > 0 && e.push(s.substring(t, i.index));
    const [, n, o, , r] = i;
    r ? e.push({ label: n, href: o, title: r }) : e.push({ label: n, href: o }), t = i.index + i[0].length;
  }
  return t < s.length && e.push(s.substring(t)), new LW(e);
}
const Vy = {}, Nee = new MN("quick-input-button-icon-");
function Tee(s) {
  if (!s)
    return;
  let e;
  const t = s.dark.toString();
  return Vy[t] ? e = Vy[t] : (e = Nee.nextId(), aC(`.${e}, .hc-light .${e}`, `background-image: ${Vl(s.light || s.dark)}`), aC(`.vs-dark .${e}, .hc-black .${e}`, `background-image: ${Vl(s.dark)}`), Vy[t] = e), e;
}
function Qp(s, e, t) {
  let i = s.iconClass || Tee(s.iconPath);
  return s.alwaysVisible && (i = i ? `${i} always-visible` : "always-visible"), {
    id: e,
    label: "",
    tooltip: s.tooltip || "",
    class: i,
    enabled: !0,
    run: t
  };
}
function Bee(s, e, t) {
  Rn(e);
  const i = Mee(s);
  let n = 0;
  for (const o of i.nodes)
    if (typeof o == "string")
      e.append(...kh(o));
    else {
      let r = o.title;
      !r && o.href.startsWith("command:") ? r = f("executeCommand", "Click to execute command '{0}'", o.href.substring(8)) : r || (r = o.href);
      const a = de("a", { href: o.href, title: r, tabIndex: n++ }, o.label);
      a.style.textDecoration = "underline";
      const l = (g) => {
        j6(g) && Ve.stop(g, !0), t.callback(o.href);
      }, c = t.disposables.add(new Ke(a, ee.CLICK)).event, d = t.disposables.add(new Ke(a, ee.KEY_DOWN)).event, h = te.chain(d, (g) => g.filter((m) => {
        const p = new Mt(m);
        return p.equals(
          10
          /* KeyCode.Space */
        ) || p.equals(
          3
          /* KeyCode.Enter */
        );
      }));
      t.disposables.add(xn.addTarget(a));
      const u = t.disposables.add(new Ke(a, Et.Tap)).event;
      te.any(c, u, h)(l, null, t.disposables), e.appendChild(a);
    }
}
var Ree = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, UF = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const kW = "inQuickInput", Fee = new le(kW, !1, f("inQuickInput", "Whether keyboard focus is inside the quick input control")), Oee = ne.has(kW), DW = "quickInputType", Pee = new le(DW, void 0, f("quickInputType", "The type of the currently visible quick input")), IW = "cursorAtEndOfQuickInputBox", Hee = new le(IW, !1, f("cursorAtEndOfQuickInputBox", "Whether the cursor in the quick input is at the end of the input box")), Wee = ne.has(IW), xk = {
  iconClass: pe.asClassName(Z.quickInputBack),
  tooltip: f("quickInput.back", "Back")
}, M1 = class M1 extends V {
  constructor(e) {
    super(), this.ui = e, this._widgetUpdated = !1, this.visible = !1, this._enabled = !0, this._busy = !1, this._ignoreFocusOut = !1, this._leftButtons = [], this._rightButtons = [], this._inlineButtons = [], this.buttonsUpdated = !1, this._toggles = [], this.togglesUpdated = !1, this.noValidationMessage = M1.noPromptMessage, this._severity = ii.Ignore, this.onDidTriggerButtonEmitter = this._register(new B()), this.onDidHideEmitter = this._register(new B()), this.onWillHideEmitter = this._register(new B()), this.onDisposeEmitter = this._register(new B()), this.visibleDisposables = this._register(new X()), this.onDidHide = this.onDidHideEmitter.event;
  }
  get title() {
    return this._title;
  }
  set title(e) {
    this._title = e, this.update();
  }
  get description() {
    return this._description;
  }
  set description(e) {
    this._description = e, this.update();
  }
  get step() {
    return this._steps;
  }
  set step(e) {
    this._steps = e, this.update();
  }
  get totalSteps() {
    return this._totalSteps;
  }
  set totalSteps(e) {
    this._totalSteps = e, this.update();
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e, this.update();
  }
  get contextKey() {
    return this._contextKey;
  }
  set contextKey(e) {
    this._contextKey = e, this.update();
  }
  get busy() {
    return this._busy;
  }
  set busy(e) {
    this._busy = e, this.update();
  }
  get ignoreFocusOut() {
    return this._ignoreFocusOut;
  }
  set ignoreFocusOut(e) {
    const t = this._ignoreFocusOut !== e && !Ea;
    this._ignoreFocusOut = e && !Ea, t && this.update();
  }
  get titleButtons() {
    return this._leftButtons.length ? [...this._leftButtons, this._rightButtons] : this._rightButtons;
  }
  get buttons() {
    return [
      ...this._leftButtons,
      ...this._rightButtons,
      ...this._inlineButtons
    ];
  }
  set buttons(e) {
    this._leftButtons = e.filter((t) => t === xk), this._rightButtons = e.filter((t) => t !== xk && t.location !== KC.Inline), this._inlineButtons = e.filter((t) => t.location === KC.Inline), this.buttonsUpdated = !0, this.update();
  }
  get toggles() {
    return this._toggles;
  }
  set toggles(e) {
    this._toggles = e ?? [], this.togglesUpdated = !0, this.update();
  }
  get validationMessage() {
    return this._validationMessage;
  }
  set validationMessage(e) {
    this._validationMessage = e, this.update();
  }
  get severity() {
    return this._severity;
  }
  set severity(e) {
    this._severity = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.onDidTriggerButton((e) => {
      this.buttons.indexOf(e) !== -1 && this.onDidTriggerButtonEmitter.fire(e);
    })), this.ui.show(this), this.visible = !0, this._lastValidationMessage = void 0, this._lastSeverity = void 0, this.buttons.length && (this.buttonsUpdated = !0), this.toggles.length && (this.togglesUpdated = !0), this.update());
  }
  hide() {
    this.visible && this.ui.hide();
  }
  didHide(e = sm.Other) {
    this.visible = !1, this.visibleDisposables.clear(), this.onDidHideEmitter.fire({ reason: e });
  }
  willHide(e = sm.Other) {
    this.onWillHideEmitter.fire({ reason: e });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.getTitle();
    e && this.ui.title.textContent !== e ? this.ui.title.textContent = e : !e && this.ui.title.innerHTML !== "&nbsp;" && (this.ui.title.innerText = " ");
    const t = this.getDescription();
    if (this.ui.description1.textContent !== t && (this.ui.description1.textContent = t), this.ui.description2.textContent !== t && (this.ui.description2.textContent = t), this._widgetUpdated && (this._widgetUpdated = !1, this._widget ? Rn(this.ui.widget, this._widget) : Rn(this.ui.widget)), this.busy && !this.busyDelay && (this.busyDelay = new nr(), this.busyDelay.setIfNotSet(() => {
      this.visible && this.ui.progressBar.infinite();
    }, 800)), !this.busy && this.busyDelay && (this.ui.progressBar.stop(), this.busyDelay.cancel(), this.busyDelay = void 0), this.buttonsUpdated) {
      this.buttonsUpdated = !1, this.ui.leftActionBar.clear();
      const n = this._leftButtons.map((a, l) => Qp(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
      this.ui.leftActionBar.push(n, { icon: !0, label: !1 }), this.ui.rightActionBar.clear();
      const o = this._rightButtons.map((a, l) => Qp(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
      this.ui.rightActionBar.push(o, { icon: !0, label: !1 }), this.ui.inlineActionBar.clear();
      const r = this._inlineButtons.map((a, l) => Qp(a, `id-${l}`, async () => this.onDidTriggerButtonEmitter.fire(a)));
      this.ui.inlineActionBar.push(r, { icon: !0, label: !1 });
    }
    if (this.togglesUpdated) {
      this.togglesUpdated = !1;
      const n = this.toggles?.filter((o) => o instanceof xm) ?? [];
      this.ui.inputBox.toggles = n;
    }
    this.ui.ignoreFocusOut = this.ignoreFocusOut, this.ui.setEnabled(this.enabled), this.ui.setContextKey(this.contextKey);
    const i = this.validationMessage || this.noValidationMessage;
    this._lastValidationMessage !== i && (this._lastValidationMessage = i, Rn(this.ui.message), Bee(i, this.ui.message, {
      callback: (n) => {
        this.ui.linkOpenerDelegate(n);
      },
      disposables: this.visibleDisposables
    })), this._lastSeverity !== this.severity && (this._lastSeverity = this.severity, this.showMessageDecoration(this.severity));
  }
  getTitle() {
    return this.title && this.step ? `${this.title} (${this.getSteps()})` : this.title ? this.title : this.step ? this.getSteps() : "";
  }
  getDescription() {
    return this.description || "";
  }
  getSteps() {
    return this.step && this.totalSteps ? f("quickInput.steps", "{0}/{1}", this.step, this.totalSteps) : this.step ? String(this.step) : "";
  }
  showMessageDecoration(e) {
    if (this.ui.inputBox.showDecoration(e), e !== ii.Ignore) {
      const t = this.ui.inputBox.stylesForType(e);
      this.ui.message.style.color = t.foreground ? `${t.foreground}` : "", this.ui.message.style.backgroundColor = t.background ? `${t.background}` : "", this.ui.message.style.border = t.border ? `1px solid ${t.border}` : "", this.ui.message.style.marginBottom = "-2px";
    } else
      this.ui.message.style.color = "", this.ui.message.style.backgroundColor = "", this.ui.message.style.border = "", this.ui.message.style.marginBottom = "";
  }
  dispose() {
    this.hide(), this.onDisposeEmitter.fire(), super.dispose();
  }
};
M1.noPromptMessage = f("inputModeEntry", "Press 'Enter' to confirm your input or 'Escape' to cancel");
let JC = M1;
const N1 = class N1 extends JC {
  constructor() {
    super(...arguments), this._value = "", this.onDidChangeValueEmitter = this._register(new B()), this.onWillAcceptEmitter = this._register(new B()), this.onDidAcceptEmitter = this._register(new B()), this.onDidCustomEmitter = this._register(new B()), this._items = [], this.itemsUpdated = !1, this._canSelectMany = !1, this._canAcceptInBackground = !1, this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._keepScrollPosition = !1, this._itemActivation = ca.FIRST, this._activeItems = [], this.activeItemsUpdated = !1, this.activeItemsToConfirm = [], this.onDidChangeActiveEmitter = this._register(new B()), this._selectedItems = [], this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = [], this.onDidChangeSelectionEmitter = this._register(new B()), this.onDidTriggerItemButtonEmitter = this._register(new B()), this.onDidTriggerSeparatorButtonEmitter = this._register(new B()), this.valueSelectionUpdated = !0, this._ok = "default", this._customButton = !1, this._focusEventBufferer = new k_(), this.type = "quickPick", this.filterValue = (e) => e, this.onDidChangeValue = this.onDidChangeValueEmitter.event, this.onWillAccept = this.onWillAcceptEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event, this.onDidChangeActive = this.onDidChangeActiveEmitter.event, this.onDidChangeSelection = this.onDidChangeSelectionEmitter.event, this.onDidTriggerItemButton = this.onDidTriggerItemButtonEmitter.event, this.onDidTriggerSeparatorButton = this.onDidTriggerSeparatorButtonEmitter.event;
  }
  get quickNavigate() {
    return this._quickNavigate;
  }
  set quickNavigate(e) {
    this._quickNavigate = e, this.update();
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this.doSetValue(e);
  }
  doSetValue(e, t) {
    this._value !== e && (this._value = e, t || this.update(), this.visible && this.ui.list.filter(this.filterValue(this._value)) && this.trySelectFirst(), this.onDidChangeValueEmitter.fire(this._value));
  }
  set ariaLabel(e) {
    this._ariaLabel = e, this.update();
  }
  get ariaLabel() {
    return this._ariaLabel;
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get items() {
    return this._items;
  }
  get scrollTop() {
    return this.ui.list.scrollTop;
  }
  set scrollTop(e) {
    this.ui.list.scrollTop = e;
  }
  set items(e) {
    this._items = e, this.itemsUpdated = !0, this.update();
  }
  get canSelectMany() {
    return this._canSelectMany;
  }
  set canSelectMany(e) {
    this._canSelectMany = e, this.update();
  }
  get canAcceptInBackground() {
    return this._canAcceptInBackground;
  }
  set canAcceptInBackground(e) {
    this._canAcceptInBackground = e;
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e, this.update();
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e, this.update();
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e, this.update();
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e, this.update();
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e, this.update();
  }
  get keepScrollPosition() {
    return this._keepScrollPosition;
  }
  set keepScrollPosition(e) {
    this._keepScrollPosition = e;
  }
  get itemActivation() {
    return this._itemActivation;
  }
  set itemActivation(e) {
    this._itemActivation = e;
  }
  get activeItems() {
    return this._activeItems;
  }
  set activeItems(e) {
    this._activeItems = e, this.activeItemsUpdated = !0, this.update();
  }
  get selectedItems() {
    return this._selectedItems;
  }
  set selectedItems(e) {
    this._selectedItems = e, this.selectedItemsUpdated = !0, this.update();
  }
  get keyMods() {
    return this._quickNavigate ? Lee : this.ui.keyMods;
  }
  get valueSelection() {
    const e = this.ui.inputBox.getSelection();
    if (e)
      return [e.start, e.end];
  }
  set valueSelection(e) {
    this._valueSelection = e, this.valueSelectionUpdated = !0, this.update();
  }
  get customButton() {
    return this._customButton;
  }
  set customButton(e) {
    this._customButton = e, this.update();
  }
  get customLabel() {
    return this._customButtonLabel;
  }
  set customLabel(e) {
    this._customButtonLabel = e, this.update();
  }
  get customHover() {
    return this._customButtonHover;
  }
  set customHover(e) {
    this._customButtonHover = e, this.update();
  }
  get ok() {
    return this._ok;
  }
  set ok(e) {
    this._ok = e, this.update();
  }
  get hideInput() {
    return !!this._hideInput;
  }
  set hideInput(e) {
    this._hideInput = e, this.update();
  }
  trySelectFirst() {
    this.canSelectMany || this.ui.list.focus(yt.First);
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      this.doSetValue(
        e,
        !0
        /* skip update since this originates from the UI */
      );
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => {
      this.canSelectMany ? this.ui.list.getCheckedElements().length || (this._selectedItems = [], this.onDidChangeSelectionEmitter.fire(this.selectedItems)) : this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems)), this.handleAccept(!1);
    })), this.visibleDisposables.add(this.ui.onDidCustom(() => {
      this.onDidCustomEmitter.fire();
    })), this.visibleDisposables.add(this._focusEventBufferer.wrapEvent(
      this.ui.list.onDidChangeFocus,
      // Only fire the last event
      (e, t) => t
    )((e) => {
      this.activeItemsUpdated || this.activeItemsToConfirm !== this._activeItems && pi(e, this._activeItems, (t, i) => t === i) || (this._activeItems = e, this.onDidChangeActiveEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onDidChangeSelection(({ items: e, event: t }) => {
      if (this.canSelectMany) {
        e.length && this.ui.list.setSelectedElements([]);
        return;
      }
      this.selectedItemsToConfirm !== this._selectedItems && pi(e, this._selectedItems, (i, n) => i === n) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e), e.length && this.handleAccept(
        qM(t) && t.button === 1
        /* mouse middle click */
      ));
    })), this.visibleDisposables.add(this.ui.list.onChangedCheckedElements((e) => {
      !this.canSelectMany || !this.visible || this.selectedItemsToConfirm !== this._selectedItems && pi(e, this._selectedItems, (t, i) => t === i) || (this._selectedItems = e, this.onDidChangeSelectionEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.list.onButtonTriggered((e) => this.onDidTriggerItemButtonEmitter.fire(e))), this.visibleDisposables.add(this.ui.list.onSeparatorButtonTriggered((e) => this.onDidTriggerSeparatorButtonEmitter.fire(e))), this.visibleDisposables.add(this.registerQuickNavigation()), this.valueSelectionUpdated = !0), super.show();
  }
  handleAccept(e) {
    let t = !1;
    this.onWillAcceptEmitter.fire({ veto: () => t = !0 }), t || this.onDidAcceptEmitter.fire({ inBackground: e });
  }
  registerQuickNavigation() {
    return U(this.ui.container, ee.KEY_UP, (e) => {
      if (this.canSelectMany || !this._quickNavigate)
        return;
      const t = new Mt(e), i = t.keyCode;
      this._quickNavigate.keybindings.some((r) => {
        const a = r.getChords();
        return a.length > 1 ? !1 : a[0].shiftKey && i === 4 ? !(t.ctrlKey || t.altKey || t.metaKey) : !!(a[0].altKey && i === 6 || a[0].ctrlKey && i === 5 || a[0].metaKey && i === 57);
      }) && (this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(!1)), this._quickNavigate = void 0);
    });
  }
  update() {
    if (!this.visible)
      return;
    const e = this.keepScrollPosition ? this.scrollTop : 0, t = !!this.description, i = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: t,
      checkAll: this.canSelectMany && !this._hideCheckAll,
      checkBox: this.canSelectMany,
      inputBox: !this._hideInput,
      progressBar: !this._hideInput || t,
      visibleCount: !0,
      count: this.canSelectMany && !this._hideCountBadge,
      ok: this.ok === "default" ? this.canSelectMany : this.ok,
      list: !0,
      message: !!this.validationMessage,
      customButton: this.customButton
    };
    this.ui.setVisibilities(i), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || "");
    let n = this.ariaLabel;
    !n && i.inputBox && (n = this.placeholder || N1.DEFAULT_ARIA_LABEL, this.title && (n += ` - ${this.title}`)), this.ui.list.ariaLabel !== n && (this.ui.list.ariaLabel = n ?? null), this.ui.list.matchOnDescription = this.matchOnDescription, this.ui.list.matchOnDetail = this.matchOnDetail, this.ui.list.matchOnLabel = this.matchOnLabel, this.ui.list.matchOnLabelMode = this.matchOnLabelMode, this.ui.list.sortByLabel = this.sortByLabel, this.itemsUpdated && (this.itemsUpdated = !1, this._focusEventBufferer.bufferEvents(() => {
      switch (this.ui.list.setElements(this.items), this.ui.list.shouldLoop = !this.canSelectMany, this.ui.list.filter(this.filterValue(this.ui.inputBox.value)), this._itemActivation) {
        case ca.NONE:
          this._itemActivation = ca.FIRST;
          break;
        case ca.SECOND:
          this.ui.list.focus(yt.Second), this._itemActivation = ca.FIRST;
          break;
        case ca.LAST:
          this.ui.list.focus(yt.Last), this._itemActivation = ca.FIRST;
          break;
        default:
          this.trySelectFirst();
          break;
      }
    })), this.ui.container.classList.contains("show-checkboxes") !== !!this.canSelectMany && (this.canSelectMany ? this.ui.list.clearFocus() : this.trySelectFirst()), this.activeItemsUpdated && (this.activeItemsUpdated = !1, this.activeItemsToConfirm = this._activeItems, this.ui.list.setFocusedElements(this.activeItems), this.activeItemsToConfirm === this._activeItems && (this.activeItemsToConfirm = null)), this.selectedItemsUpdated && (this.selectedItemsUpdated = !1, this.selectedItemsToConfirm = this._selectedItems, this.canSelectMany ? this.ui.list.setCheckedElements(this.selectedItems) : this.ui.list.setSelectedElements(this.selectedItems), this.selectedItemsToConfirm === this._selectedItems && (this.selectedItemsToConfirm = null)), this.ui.customButton.label = this.customLabel || "", this.ui.customButton.element.title = this.customHover || "", i.inputBox || (this.ui.list.domFocus(), this.canSelectMany && this.ui.list.focus(yt.First)), this.keepScrollPosition && (this.scrollTop = e);
  }
  focus(e) {
    this.ui.list.focus(e), this.canSelectMany && this.ui.list.domFocus();
  }
  accept(e) {
    e && !this._canAcceptInBackground || this.activeItems[0] && (this._selectedItems = [this.activeItems[0]], this.onDidChangeSelectionEmitter.fire(this.selectedItems), this.handleAccept(e ?? !1));
  }
};
N1.DEFAULT_ARIA_LABEL = f("quickInputBox.ariaLabel", "Type to narrow down results.");
let qC = N1, Vee = class extends JC {
  constructor() {
    super(...arguments), this._value = "", this.valueSelectionUpdated = !0, this._password = !1, this.onDidValueChangeEmitter = this._register(new B()), this.onDidAcceptEmitter = this._register(new B()), this.type = "inputBox", this.onDidChangeValue = this.onDidValueChangeEmitter.event, this.onDidAccept = this.onDidAcceptEmitter.event;
  }
  get value() {
    return this._value;
  }
  set value(e) {
    this._value = e || "", this.update();
  }
  get placeholder() {
    return this._placeholder;
  }
  set placeholder(e) {
    this._placeholder = e, this.update();
  }
  get password() {
    return this._password;
  }
  set password(e) {
    this._password = e, this.update();
  }
  show() {
    this.visible || (this.visibleDisposables.add(this.ui.inputBox.onDidChange((e) => {
      e !== this.value && (this._value = e, this.onDidValueChangeEmitter.fire(e));
    })), this.visibleDisposables.add(this.ui.onDidAccept(() => this.onDidAcceptEmitter.fire())), this.valueSelectionUpdated = !0), super.show();
  }
  update() {
    if (!this.visible)
      return;
    this.ui.container.classList.remove("hidden-input");
    const e = {
      title: !!this.title || !!this.step || !!this.titleButtons.length,
      description: !!this.description || !!this.step,
      inputBox: !0,
      message: !0,
      progressBar: !0
    };
    this.ui.setVisibilities(e), super.update(), this.ui.inputBox.value !== this.value && (this.ui.inputBox.value = this.value), this.valueSelectionUpdated && (this.valueSelectionUpdated = !1, this.ui.inputBox.select(this._valueSelection && { start: this._valueSelection[0], end: this._valueSelection[1] })), this.ui.inputBox.placeholder !== (this.placeholder || "") && (this.ui.inputBox.placeholder = this.placeholder || ""), this.ui.inputBox.password !== this.password && (this.ui.inputBox.password = this.password);
  }
}, Ek = class extends Kf {
  constructor(e, t) {
    super("element", !1, (i) => this.getOverrideOptions(i), e, t);
  }
  getOverrideOptions(e) {
    const t = (Bi(e.content) ? e.content.textContent ?? "" : typeof e.content == "string" ? e.content : e.content.value).includes(`
`);
    return {
      persistence: {
        hideOnKeyDown: !1
      },
      appearance: {
        showHoverHint: t,
        skipFadeInAnimation: !0
      }
    };
  }
};
Ek = Ree([
  UF(0, ht),
  UF(1, jl)
], Ek);
Y.white.toString(), Y.white.toString();
class Lk extends V {
  get onDidClick() {
    return this._onDidClick.event;
  }
  constructor(e, t) {
    super(), this._label = "", this._onDidClick = this._register(new B()), this._onDidEscape = this._register(new B()), this.options = t, this._element = document.createElement("a"), this._element.classList.add("monaco-button"), this._element.tabIndex = 0, this._element.setAttribute("role", "button"), this._element.classList.toggle("secondary", !!t.secondary);
    const i = t.secondary ? t.buttonSecondaryBackground : t.buttonBackground, n = t.secondary ? t.buttonSecondaryForeground : t.buttonForeground;
    this._element.style.color = n || "", this._element.style.backgroundColor = i || "", t.supportShortLabel && (this._labelShortElement = document.createElement("div"), this._labelShortElement.classList.add("monaco-button-label-short"), this._element.appendChild(this._labelShortElement), this._labelElement = document.createElement("div"), this._labelElement.classList.add("monaco-button-label"), this._element.appendChild(this._labelElement), this._element.classList.add("monaco-text-button-with-short-label")), typeof t.title == "string" && this.setTitle(t.title), typeof t.ariaLabel == "string" && this._element.setAttribute("aria-label", t.ariaLabel), e.appendChild(this._element), this._register(xn.addTarget(this._element)), [ee.CLICK, Et.Tap].forEach((o) => {
      this._register(U(this._element, o, (r) => {
        if (!this.enabled) {
          Ve.stop(r);
          return;
        }
        this._onDidClick.fire(r);
      }));
    }), this._register(U(this._element, ee.KEY_DOWN, (o) => {
      const r = new Mt(o);
      let a = !1;
      this.enabled && (r.equals(
        3
        /* KeyCode.Enter */
      ) || r.equals(
        10
        /* KeyCode.Space */
      )) ? (this._onDidClick.fire(o), a = !0) : r.equals(
        9
        /* KeyCode.Escape */
      ) && (this._onDidEscape.fire(o), this._element.blur(), a = !0), a && Ve.stop(r, !0);
    })), this._register(U(this._element, ee.MOUSE_OVER, (o) => {
      this._element.classList.contains("disabled") || this.updateBackground(!0);
    })), this._register(U(this._element, ee.MOUSE_OUT, (o) => {
      this.updateBackground(!1);
    })), this.focusTracker = this._register(Wl(this._element)), this._register(this.focusTracker.onDidFocus(() => {
      this.enabled && this.updateBackground(!0);
    })), this._register(this.focusTracker.onDidBlur(() => {
      this.enabled && this.updateBackground(!1);
    }));
  }
  dispose() {
    super.dispose(), this._element.remove();
  }
  getContentElements(e) {
    const t = [];
    for (let i of kh(e))
      if (typeof i == "string") {
        if (i = i.trim(), i === "")
          continue;
        const n = document.createElement("span");
        n.textContent = i, t.push(n);
      } else
        t.push(i);
    return t;
  }
  updateBackground(e) {
    let t;
    this.options.secondary ? t = e ? this.options.buttonSecondaryHoverBackground : this.options.buttonSecondaryBackground : t = e ? this.options.buttonHoverBackground : this.options.buttonBackground, t && (this._element.style.backgroundColor = t);
  }
  get element() {
    return this._element;
  }
  set label(e) {
    if (this._label === e || Sa(this._label) && Sa(e) && _J(this._label, e))
      return;
    this._element.classList.add("monaco-text-button");
    const t = this.options.supportShortLabel ? this._labelElement : this._element;
    if (Sa(e)) {
      const n = Z0(e, { inline: !0 });
      n.dispose();
      const o = n.element.querySelector("p")?.innerHTML;
      if (o) {
        const r = RH(o, { ADD_TAGS: ["b", "i", "u", "code", "span"], ALLOWED_ATTR: ["class"], RETURN_TRUSTED_TYPE: !0 });
        t.innerHTML = r;
      } else
        Rn(t);
    } else
      this.options.supportIcons ? Rn(t, ...this.getContentElements(e)) : t.textContent = e;
    let i = "";
    typeof this.options.title == "string" ? i = this.options.title : this.options.title && (i = DJ(e)), this.setTitle(i), typeof this.options.ariaLabel == "string" ? this._element.setAttribute("aria-label", this.options.ariaLabel) : this.options.ariaLabel && this._element.setAttribute("aria-label", i), this._label = e;
  }
  get label() {
    return this._label;
  }
  set icon(e) {
    this._element.classList.add(...pe.asClassNameArray(e));
  }
  set enabled(e) {
    e ? (this._element.classList.remove("disabled"), this._element.setAttribute("aria-disabled", String(!1)), this._element.tabIndex = 0) : (this._element.classList.add("disabled"), this._element.setAttribute("aria-disabled", String(!0)));
  }
  get enabled() {
    return !this._element.classList.contains("disabled");
  }
  setTitle(e) {
    !this._hover && e !== "" ? this._hover = this._register(Oa().setupManagedHover(this.options.hoverDelegate ?? Ls("mouse"), this._element, e)) : this._hover && this._hover.update(e);
  }
}
class kk {
  constructor(e, t, i) {
    this.options = t, this.styles = i, this.count = 0, this.element = K(e, de(".monaco-count-badge")), this.countFormat = this.options.countFormat || "{0}", this.titleFormat = this.options.titleFormat || "", this.setCount(this.options.count || 0);
  }
  setCount(e) {
    this.count = e, this.render();
  }
  setTitleFormat(e) {
    this.titleFormat = e, this.render();
  }
  render() {
    this.element.textContent = Vf(this.countFormat, this.count), this.element.title = Vf(this.titleFormat, this.count), this.element.style.backgroundColor = this.styles.badgeBackground ?? "", this.element.style.color = this.styles.badgeForeground ?? "", this.styles.badgeBorder && (this.element.style.border = `1px solid ${this.styles.badgeBorder}`);
  }
}
const QF = "done", GF = "active", zy = "infinite", Uy = "infinite-long-running", jF = "discrete", T1 = class T1 extends V {
  constructor(e, t) {
    super(), this.progressSignal = this._register(new On()), this.workedVal = 0, this.showDelayedScheduler = this._register(new zt(() => ps(this.element), 0)), this.longRunningScheduler = this._register(new zt(() => this.infiniteLongRunning(), T1.LONG_RUNNING_INFINITE_THRESHOLD)), this.create(e, t);
  }
  create(e, t) {
    this.element = document.createElement("div"), this.element.classList.add("monaco-progress-container"), this.element.setAttribute("role", "progressbar"), this.element.setAttribute("aria-valuemin", "0"), e.appendChild(this.element), this.bit = document.createElement("div"), this.bit.classList.add("progress-bit"), this.bit.style.backgroundColor = t?.progressBarBackground || "#0E70C0", this.element.appendChild(this.bit);
  }
  off() {
    this.bit.style.width = "inherit", this.bit.style.opacity = "1", this.element.classList.remove(GF, zy, Uy, jF), this.workedVal = 0, this.totalWork = void 0, this.longRunningScheduler.cancel(), this.progressSignal.clear();
  }
  /**
   * Stops the progressbar from showing any progress instantly without fading out.
   */
  stop() {
    return this.doDone(!1);
  }
  doDone(e) {
    return this.element.classList.add(QF), this.element.classList.contains(zy) ? (this.bit.style.opacity = "0", e ? setTimeout(() => this.off(), 200) : this.off()) : (this.bit.style.width = "inherit", e ? setTimeout(() => this.off(), 200) : this.off()), this;
  }
  /**
   * Use this mode to indicate progress that has no total number of work units.
   */
  infinite() {
    return this.bit.style.width = "2%", this.bit.style.opacity = "1", this.element.classList.remove(jF, QF, Uy), this.element.classList.add(GF, zy), this.longRunningScheduler.schedule(), this;
  }
  infiniteLongRunning() {
    this.element.classList.add(Uy);
  }
  getContainer() {
    return this.element;
  }
};
T1.LONG_RUNNING_INFINITE_THRESHOLD = 1e4;
let Dk = T1;
const zee = f("caseDescription", "Match Case"), Uee = f("wordsDescription", "Match Whole Word"), Qee = f("regexDescription", "Use Regular Expression");
class MW extends xm {
  constructor(e) {
    super({
      icon: Z.caseSensitive,
      title: zee + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Ls("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class NW extends xm {
  constructor(e) {
    super({
      icon: Z.wholeWord,
      title: Uee + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Ls("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class TW extends xm {
  constructor(e) {
    super({
      icon: Z.regex,
      title: Qee + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Ls("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class Gee {
  constructor(e, t = 0, i = e.length, n = t - 1) {
    this.items = e, this.start = t, this.end = i, this.index = n;
  }
  current() {
    return this.index === this.start - 1 || this.index === this.end ? null : this.items[this.index];
  }
  next() {
    return this.index = Math.min(this.index + 1, this.end), this.current();
  }
  previous() {
    return this.index = Math.max(this.index - 1, this.start - 1), this.current();
  }
  first() {
    return this.index = this.start, this.current();
  }
  last() {
    return this.index = this.end - 1, this.current();
  }
}
class jee {
  constructor(e = [], t = 10) {
    this._initialize(e), this._limit = t, this._onChange();
  }
  getHistory() {
    return this._elements;
  }
  add(e) {
    this._history.delete(e), this._history.add(e), this._onChange();
  }
  next() {
    return this._navigator.next();
  }
  previous() {
    return this._currentPosition() !== 0 ? this._navigator.previous() : null;
  }
  current() {
    return this._navigator.current();
  }
  first() {
    return this._navigator.first();
  }
  last() {
    return this._navigator.last();
  }
  isLast() {
    return this._currentPosition() >= this._elements.length - 1;
  }
  isNowhere() {
    return this._navigator.current() === null;
  }
  has(e) {
    return this._history.has(e);
  }
  _onChange() {
    this._reduceToLimit();
    const e = this._elements;
    this._navigator = new Gee(e, 0, e.length, e.length);
  }
  _reduceToLimit() {
    const e = this._elements;
    e.length > this._limit && this._initialize(e.slice(e.length - this._limit));
  }
  _currentPosition() {
    const e = this._navigator.current();
    return e ? this._elements.indexOf(e) : -1;
  }
  _initialize(e) {
    this._history = /* @__PURE__ */ new Set();
    for (const t of e)
      this._history.add(t);
  }
  get _elements() {
    const e = [];
    return this._history.forEach((t) => e.push(t)), e;
  }
}
const tp = de;
class Yee extends to {
  constructor(e, t, i) {
    super(), this.state = "idle", this.maxHeight = Number.POSITIVE_INFINITY, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._onDidHeightChange = this._register(new B()), this.onDidHeightChange = this._onDidHeightChange.event, this.contextViewProvider = t, this.options = i, this.message = null, this.placeholder = this.options.placeholder || "", this.tooltip = this.options.tooltip ?? (this.placeholder || ""), this.ariaLabel = this.options.ariaLabel || "", this.options.validationOptions && (this.validation = this.options.validationOptions.validation), this.element = K(e, tp(".monaco-inputbox.idle"));
    const n = this.options.flexibleHeight ? "textarea" : "input", o = K(this.element, tp(".ibwrapper"));
    if (this.input = K(o, tp(n + ".input.empty")), this.input.setAttribute("autocorrect", "off"), this.input.setAttribute("autocapitalize", "off"), this.input.setAttribute("spellcheck", "false"), this.onfocus(this.input, () => this.element.classList.add("synthetic-focus")), this.onblur(this.input, () => this.element.classList.remove("synthetic-focus")), this.options.flexibleHeight) {
      this.maxHeight = typeof this.options.flexibleMaxHeight == "number" ? this.options.flexibleMaxHeight : Number.POSITIVE_INFINITY, this.mirror = K(o, tp("div.mirror")), this.mirror.innerText = " ", this.scrollableElement = new c3(this.element, {
        vertical: 1
        /* ScrollbarVisibility.Auto */
      }), this.options.flexibleWidth && (this.input.setAttribute("wrap", "off"), this.mirror.style.whiteSpace = "pre", this.mirror.style.wordWrap = "initial"), K(e, this.scrollableElement.getDomNode()), this._register(this.scrollableElement), this._register(this.scrollableElement.onScroll((l) => this.input.scrollTop = l.scrollTop));
      const r = this._register(new Ke(e.ownerDocument, "selectionchange")), a = te.filter(r.event, () => e.ownerDocument.getSelection()?.anchorNode === o);
      this._register(a(this.updateScrollDimensions, this)), this._register(this.onDidHeightChange(this.updateScrollDimensions, this));
    } else
      this.input.type = this.options.type || "text", this.input.setAttribute("wrap", "off");
    this.ariaLabel && this.input.setAttribute("aria-label", this.ariaLabel), this.placeholder && !this.options.showPlaceholderOnFocus && this.setPlaceHolder(this.placeholder), this.tooltip && this.setTooltip(this.tooltip), this.oninput(this.input, () => this.onValueChange()), this.onblur(this.input, () => this.onBlur()), this.onfocus(this.input, () => this.onFocus()), this._register(this.ignoreGesture(this.input)), setTimeout(() => this.updateMirror(), 0), this.options.actions && (this.actionbar = this._register(new wo(this.element)), this.actionbar.push(this.options.actions, { icon: !0, label: !1 })), this.applyStyles();
  }
  onBlur() {
    this._hideMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", "");
  }
  onFocus() {
    this._showMessage(), this.options.showPlaceholderOnFocus && this.input.setAttribute("placeholder", this.placeholder || "");
  }
  setPlaceHolder(e) {
    this.placeholder = e, this.input.setAttribute("placeholder", e);
  }
  setTooltip(e) {
    this.tooltip = e, this.hover ? this.hover.update(e) : this.hover = this._register(Oa().setupManagedHover(Ls("mouse"), this.input, e));
  }
  get inputElement() {
    return this.input;
  }
  get value() {
    return this.input.value;
  }
  set value(e) {
    this.input.value !== e && (this.input.value = e, this.onValueChange());
  }
  get height() {
    return typeof this.cachedHeight == "number" ? this.cachedHeight : _h(this.element);
  }
  focus() {
    this.input.focus();
  }
  blur() {
    this.input.blur();
  }
  hasFocus() {
    return x0(this.input);
  }
  select(e = null) {
    this.input.select(), e && (this.input.setSelectionRange(e.start, e.end), e.end === this.input.value.length && (this.input.scrollLeft = this.input.scrollWidth));
  }
  isSelectionAtEnd() {
    return this.input.selectionEnd === this.input.value.length && this.input.selectionStart === this.input.selectionEnd;
  }
  getSelection() {
    const e = this.input.selectionStart;
    if (e === null)
      return null;
    const t = this.input.selectionEnd ?? e;
    return {
      start: e,
      end: t
    };
  }
  enable() {
    this.input.removeAttribute("disabled");
  }
  disable() {
    this.blur(), this.input.disabled = !0, this._hideMessage();
  }
  set paddingRight(e) {
    this.input.style.width = `calc(100% - ${e}px)`, this.mirror && (this.mirror.style.paddingRight = e + "px");
  }
  updateScrollDimensions() {
    if (typeof this.cachedContentHeight != "number" || typeof this.cachedHeight != "number" || !this.scrollableElement)
      return;
    const e = this.cachedContentHeight, t = this.cachedHeight, i = this.input.scrollTop;
    this.scrollableElement.setScrollDimensions({ scrollHeight: e, height: t }), this.scrollableElement.setScrollPosition({ scrollTop: i });
  }
  showMessage(e, t) {
    if (this.state === "open" && bs(this.message, e))
      return;
    this.message = e, this.element.classList.remove("idle"), this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add(this.classForType(e.type));
    const i = this.stylesForType(this.message.type);
    this.element.style.border = `1px solid ${Tl(i.border, "transparent")}`, this.message.content && (this.hasFocus() || t) && this._showMessage();
  }
  hideMessage() {
    this.message = null, this.element.classList.remove("info"), this.element.classList.remove("warning"), this.element.classList.remove("error"), this.element.classList.add("idle"), this._hideMessage(), this.applyStyles();
  }
  validate() {
    let e = null;
    return this.validation && (e = this.validation(this.value), e ? (this.inputElement.setAttribute("aria-invalid", "true"), this.showMessage(e)) : this.inputElement.hasAttribute("aria-invalid") && (this.inputElement.removeAttribute("aria-invalid"), this.hideMessage())), e?.type;
  }
  stylesForType(e) {
    const t = this.options.inputBoxStyles;
    switch (e) {
      case 1:
        return { border: t.inputValidationInfoBorder, background: t.inputValidationInfoBackground, foreground: t.inputValidationInfoForeground };
      case 2:
        return { border: t.inputValidationWarningBorder, background: t.inputValidationWarningBackground, foreground: t.inputValidationWarningForeground };
      default:
        return { border: t.inputValidationErrorBorder, background: t.inputValidationErrorBackground, foreground: t.inputValidationErrorForeground };
    }
  }
  classForType(e) {
    switch (e) {
      case 1:
        return "info";
      case 2:
        return "warning";
      default:
        return "error";
    }
  }
  _showMessage() {
    if (!this.contextViewProvider || !this.message)
      return;
    let e;
    const t = () => e.style.width = Rs(this.element) + "px";
    this.contextViewProvider.showContextView({
      getAnchor: () => this.element,
      anchorAlignment: 1,
      render: (n) => {
        if (!this.message)
          return null;
        e = K(n, tp(".monaco-inputbox-container")), t();
        const o = {
          inline: !0,
          className: "monaco-inputbox-message"
        }, r = this.message.formatContent ? PK(this.message.content, o) : OK(this.message.content, o);
        r.classList.add(this.classForType(this.message.type));
        const a = this.stylesForType(this.message.type);
        return r.style.backgroundColor = a.background ?? "", r.style.color = a.foreground ?? "", r.style.border = a.border ? `1px solid ${a.border}` : "", K(e, r), null;
      },
      onHide: () => {
        this.state = "closed";
      },
      layout: t
    });
    let i;
    this.message.type === 3 ? i = f("alertErrorMessage", "Error: {0}", this.message.content) : this.message.type === 2 ? i = f("alertWarningMessage", "Warning: {0}", this.message.content) : i = f("alertInfoMessage", "Info: {0}", this.message.content), Ia(i), this.state = "open";
  }
  _hideMessage() {
    this.contextViewProvider && (this.state === "open" && this.contextViewProvider.hideContextView(), this.state = "idle");
  }
  onValueChange() {
    this._onDidChange.fire(this.value), this.validate(), this.updateMirror(), this.input.classList.toggle("empty", !this.value), this.state === "open" && this.contextViewProvider && this.contextViewProvider.layout();
  }
  updateMirror() {
    if (!this.mirror)
      return;
    const e = this.value, i = e.charCodeAt(e.length - 1) === 10 ? " " : "";
    (e + i).replace(/\u000c/g, "") ? this.mirror.textContent = e + i : this.mirror.innerText = " ", this.layout();
  }
  applyStyles() {
    const e = this.options.inputBoxStyles, t = e.inputBackground ?? "", i = e.inputForeground ?? "", n = e.inputBorder ?? "";
    this.element.style.backgroundColor = t, this.element.style.color = i, this.input.style.backgroundColor = "inherit", this.input.style.color = i, this.element.style.border = `1px solid ${Tl(n, "transparent")}`;
  }
  layout() {
    if (!this.mirror)
      return;
    const e = this.cachedContentHeight;
    this.cachedContentHeight = _h(this.mirror), e !== this.cachedContentHeight && (this.cachedHeight = Math.min(this.cachedContentHeight, this.maxHeight), this.input.style.height = this.cachedHeight + "px", this._onDidHeightChange.fire(this.cachedContentHeight));
  }
  insertAtCursor(e) {
    const t = this.inputElement, i = t.selectionStart, n = t.selectionEnd, o = t.value;
    i !== null && n !== null && (this.value = o.substr(0, i) + e + o.substr(n), t.setSelectionRange(i + 1, i + 1), this.layout());
  }
  dispose() {
    this._hideMessage(), this.message = null, this.actionbar?.dispose(), super.dispose();
  }
}
class BW extends Yee {
  constructor(e, t, i) {
    const n = f({
      key: "history.inputbox.hint.suffix.noparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field ends in a closing parenthesis ")", for example "Filter (e.g. text, !exclude)". The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " or {0} for history", "⇅"), o = f({
      key: "history.inputbox.hint.suffix.inparens",
      comment: ['Text is the suffix of an input field placeholder coming after the action the input field performs, this will be used when the input field does NOT end in a closing parenthesis (eg. "Find"). The character inserted into the final string is ⇅ to represent the up and down arrow keys.']
    }, " ({0} for history)", "⇅");
    super(e, t, i), this._onDidFocus = this._register(new B()), this.onDidFocus = this._onDidFocus.event, this._onDidBlur = this._register(new B()), this.onDidBlur = this._onDidBlur.event, this.history = new jee(i.history, 100);
    const r = () => {
      if (i.showHistoryHint && i.showHistoryHint() && !this.placeholder.endsWith(n) && !this.placeholder.endsWith(o) && this.history.getHistory().length) {
        const a = this.placeholder.endsWith(")") ? n : o, l = this.placeholder + a;
        i.showPlaceholderOnFocus && !x0(this.input) ? this.placeholder = l : this.setPlaceHolder(l);
      }
    };
    this.observer = new MutationObserver((a, l) => {
      a.forEach((c) => {
        c.target.textContent || r();
      });
    }), this.observer.observe(this.input, { attributeFilter: ["class"] }), this.onfocus(this.input, () => r()), this.onblur(this.input, () => {
      const a = (l) => {
        if (this.placeholder.endsWith(l)) {
          const c = this.placeholder.slice(0, this.placeholder.length - l.length);
          return i.showPlaceholderOnFocus ? this.placeholder = c : this.setPlaceHolder(c), !0;
        } else
          return !1;
      };
      a(o) || a(n);
    });
  }
  dispose() {
    super.dispose(), this.observer && (this.observer.disconnect(), this.observer = void 0);
  }
  addToHistory(e) {
    this.value && (e || this.value !== this.getCurrentValue()) && this.history.add(this.value);
  }
  isAtLastInHistory() {
    return this.history.isLast();
  }
  isNowhereInHistory() {
    return this.history.isNowhere();
  }
  showNextValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getNextValue();
    e && (e = e === this.value ? this.getNextValue() : e), this.value = e ?? "", vu(this.value ? this.value : f("clearedInput", "Cleared Input"));
  }
  showPreviousValue() {
    this.history.has(this.value) || this.addToHistory();
    let e = this.getPreviousValue();
    e && (e = e === this.value ? this.getPreviousValue() : e), e && (this.value = e, vu(this.value));
  }
  setPlaceHolder(e) {
    super.setPlaceHolder(e), this.setTooltip(e);
  }
  onBlur() {
    super.onBlur(), this._onDidBlur.fire();
  }
  onFocus() {
    super.onFocus(), this._onDidFocus.fire();
  }
  getCurrentValue() {
    let e = this.history.current();
    return e || (e = this.history.last(), this.history.next()), e;
  }
  getPreviousValue() {
    return this.history.previous() || this.history.first();
  }
  getNextValue() {
    return this.history.next();
  }
}
const Kee = f("defaultLabel", "input");
class RW extends to {
  constructor(e, t, i) {
    super(), this.fixFocusOnOptionClickEnabled = !0, this.imeSessionInProgress = !1, this.additionalTogglesDisposables = this._register(new On()), this.additionalToggles = [], this._onDidOptionChange = this._register(new B()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new B()), this.onMouseDown = this._onMouseDown.event, this._onInput = this._register(new B()), this._onKeyUp = this._register(new B()), this._onCaseSensitiveKeyDown = this._register(new B()), this.onCaseSensitiveKeyDown = this._onCaseSensitiveKeyDown.event, this._onRegexKeyDown = this._register(new B()), this.onRegexKeyDown = this._onRegexKeyDown.event, this._lastHighlightFindOptions = 0, this.placeholder = i.placeholder || "", this.validation = i.validation, this.label = i.label || Kee, this.showCommonFindToggles = !!i.showCommonFindToggles;
    const n = i.appendCaseSensitiveLabel || "", o = i.appendWholeWordsLabel || "", r = i.appendRegexLabel || "", a = i.history || [], l = !!i.flexibleHeight, c = !!i.flexibleWidth, d = i.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new BW(this.domNode, t, {
      placeholder: this.placeholder || "",
      ariaLabel: this.label || "",
      validationOptions: {
        validation: this.validation
      },
      history: a,
      showHistoryHint: i.showHistoryHint,
      flexibleHeight: l,
      flexibleWidth: c,
      flexibleMaxHeight: d,
      inputBoxStyles: i.inputBoxStyles
    }));
    const h = this._register(im());
    if (this.showCommonFindToggles) {
      this.regex = this._register(new TW({
        appendTitle: r,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.regex.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.regex.onKeyDown((g) => {
        this._onRegexKeyDown.fire(g);
      })), this.wholeWords = this._register(new NW({
        appendTitle: o,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.wholeWords.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this.caseSensitive = this._register(new MW({
        appendTitle: n,
        isChecked: !1,
        hoverDelegate: h,
        ...i.toggleStyles
      })), this._register(this.caseSensitive.onChange((g) => {
        this._onDidOptionChange.fire(g), !g && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
      })), this._register(this.caseSensitive.onKeyDown((g) => {
        this._onCaseSensitiveKeyDown.fire(g);
      }));
      const u = [this.caseSensitive.domNode, this.wholeWords.domNode, this.regex.domNode];
      this.onkeydown(this.domNode, (g) => {
        if (g.equals(
          15
          /* KeyCode.LeftArrow */
        ) || g.equals(
          17
          /* KeyCode.RightArrow */
        ) || g.equals(
          9
          /* KeyCode.Escape */
        )) {
          const m = u.indexOf(this.domNode.ownerDocument.activeElement);
          if (m >= 0) {
            let p = -1;
            g.equals(
              17
              /* KeyCode.RightArrow */
            ) ? p = (m + 1) % u.length : g.equals(
              15
              /* KeyCode.LeftArrow */
            ) && (m === 0 ? p = u.length - 1 : p = m - 1), g.equals(
              9
              /* KeyCode.Escape */
            ) ? (u[m].blur(), this.inputBox.focus()) : p >= 0 && u[p].focus(), Ve.stop(g, !0);
          }
        }
      });
    }
    this.controls = document.createElement("div"), this.controls.className = "controls", this.controls.style.display = this.showCommonFindToggles ? "" : "none", this.caseSensitive && this.controls.append(this.caseSensitive.domNode), this.wholeWords && this.controls.appendChild(this.wholeWords.domNode), this.regex && this.controls.appendChild(this.regex.domNode), this.setAdditionalToggles(i?.additionalToggles), this.controls && this.domNode.appendChild(this.controls), e?.appendChild(this.domNode), this._register(U(this.inputBox.inputElement, "compositionstart", (u) => {
      this.imeSessionInProgress = !0;
    })), this._register(U(this.inputBox.inputElement, "compositionend", (u) => {
      this.imeSessionInProgress = !1, this._onInput.fire();
    })), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  get onDidChange() {
    return this.inputBox.onDidChange;
  }
  layout(e) {
    this.inputBox.layout(), this.updateInputBoxPadding(e.collapsedFindWidget);
  }
  enable() {
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.regex?.enable(), this.wholeWords?.enable(), this.caseSensitive?.enable();
    for (const e of this.additionalToggles)
      e.enable();
  }
  disable() {
    this.domNode.classList.add("disabled"), this.inputBox.disable(), this.regex?.disable(), this.wholeWords?.disable(), this.caseSensitive?.disable();
    for (const e of this.additionalToggles)
      e.disable();
  }
  setFocusInputOnOptionClick(e) {
    this.fixFocusOnOptionClickEnabled = e;
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  setAdditionalToggles(e) {
    for (const t of this.additionalToggles)
      t.domNode.remove();
    this.additionalToggles = [], this.additionalTogglesDisposables.value = new X();
    for (const t of e ?? [])
      this.additionalTogglesDisposables.value.add(t), this.controls.appendChild(t.domNode), this.additionalTogglesDisposables.value.add(t.onChange((i) => {
        this._onDidOptionChange.fire(i), !i && this.fixFocusOnOptionClickEnabled && this.inputBox.focus();
      })), this.additionalToggles.push(t);
    this.additionalToggles.length > 0 && (this.controls.style.display = ""), this.updateInputBoxPadding();
  }
  updateInputBoxPadding(e = !1) {
    e ? this.inputBox.paddingRight = 0 : this.inputBox.paddingRight = (this.caseSensitive?.width() ?? 0) + (this.wholeWords?.width() ?? 0) + (this.regex?.width() ?? 0) + this.additionalToggles.reduce((t, i) => t + i.width(), 0);
  }
  getValue() {
    return this.inputBox.value;
  }
  setValue(e) {
    this.inputBox.value !== e && (this.inputBox.value = e);
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getCaseSensitive() {
    return this.caseSensitive?.checked ?? !1;
  }
  setCaseSensitive(e) {
    this.caseSensitive && (this.caseSensitive.checked = e);
  }
  getWholeWords() {
    return this.wholeWords?.checked ?? !1;
  }
  setWholeWords(e) {
    this.wholeWords && (this.wholeWords.checked = e);
  }
  getRegex() {
    return this.regex?.checked ?? !1;
  }
  setRegex(e) {
    this.regex && (this.regex.checked = e, this.validate());
  }
  focusOnCaseSensitive() {
    this.caseSensitive?.focus();
  }
  highlightFindOptions() {
    this.domNode.classList.remove("highlight-" + this._lastHighlightFindOptions), this._lastHighlightFindOptions = 1 - this._lastHighlightFindOptions, this.domNode.classList.add("highlight-" + this._lastHighlightFindOptions);
  }
  validate() {
    this.inputBox.validate();
  }
  showMessage(e) {
    this.inputBox.showMessage(e);
  }
  clearMessage() {
    this.inputBox.hideMessage();
  }
}
const Jee = de;
class qee extends V {
  constructor(e, t, i) {
    super(), this.parent = e, this.onKeyDown = (o) => Xt(this.findInput.inputBox.inputElement, ee.KEY_DOWN, o), this.onDidChange = (o) => this.findInput.onDidChange(o), this.container = K(this.parent, Jee(".quick-input-box")), this.findInput = this._register(new RW(this.container, void 0, { label: "", inputBoxStyles: t, toggleStyles: i }));
    const n = this.findInput.inputBox.inputElement;
    n.role = "combobox", n.ariaHasPopup = "menu", n.ariaAutoComplete = "list", n.ariaExpanded = "true";
  }
  get value() {
    return this.findInput.getValue();
  }
  set value(e) {
    this.findInput.setValue(e);
  }
  select(e = null) {
    this.findInput.inputBox.select(e);
  }
  getSelection() {
    return this.findInput.inputBox.getSelection();
  }
  isSelectionAtEnd() {
    return this.findInput.inputBox.isSelectionAtEnd();
  }
  get placeholder() {
    return this.findInput.inputBox.inputElement.getAttribute("placeholder") || "";
  }
  set placeholder(e) {
    this.findInput.inputBox.setPlaceHolder(e);
  }
  get password() {
    return this.findInput.inputBox.inputElement.type === "password";
  }
  set password(e) {
    this.findInput.inputBox.inputElement.type = e ? "password" : "text";
  }
  set enabled(e) {
    this.findInput.inputBox.inputElement.toggleAttribute("readonly", !e);
  }
  set toggles(e) {
    this.findInput.setAdditionalToggles(e);
  }
  setAttribute(e, t) {
    this.findInput.inputBox.inputElement.setAttribute(e, t);
  }
  showDecoration(e) {
    e === ii.Ignore ? this.findInput.clearMessage() : this.findInput.showMessage({ type: e === ii.Info ? 1 : e === ii.Warning ? 2 : 3, content: "" });
  }
  stylesForType(e) {
    return this.findInput.inputBox.stylesForType(
      e === ii.Info ? 1 : e === ii.Warning ? 2 : 3
      /* MessageType.ERROR */
    );
  }
  setFocus() {
    this.findInput.focus();
  }
  layout() {
    this.findInput.inputBox.layout();
  }
}
class $ee {
  get templateId() {
    return this.renderer.templateId;
  }
  constructor(e, t) {
    this.renderer = e, this.modelProvider = t;
  }
  renderTemplate(e) {
    return { data: this.renderer.renderTemplate(e), disposable: V.None };
  }
  renderElement(e, t, i, n) {
    if (i.disposable?.dispose(), !i.data)
      return;
    const o = this.modelProvider();
    if (o.isResolved(e))
      return this.renderer.renderElement(o.get(e), e, i.data, n);
    const r = new vs(), a = o.resolve(e, r.token);
    i.disposable = { dispose: () => r.cancel() }, this.renderer.renderPlaceholder(e, i.data), a.then((l) => this.renderer.renderElement(l, e, i.data, n));
  }
  disposeTemplate(e) {
    e.disposable && (e.disposable.dispose(), e.disposable = void 0), e.data && (this.renderer.disposeTemplate(e.data), e.data = void 0);
  }
}
class Xee {
  constructor(e, t) {
    this.modelProvider = e, this.accessibilityProvider = t;
  }
  getWidgetAriaLabel() {
    return this.accessibilityProvider.getWidgetAriaLabel();
  }
  getAriaLabel(e) {
    const t = this.modelProvider();
    return t.isResolved(e) ? this.accessibilityProvider.getAriaLabel(t.get(e)) : null;
  }
}
function Zee(s, e) {
  return {
    ...e,
    accessibilityProvider: e.accessibilityProvider && new Xee(s, e.accessibilityProvider)
  };
}
class ete {
  constructor(e, t, i, n, o = {}) {
    const r = () => this.model, a = n.map((l) => new $ee(l, r));
    this.list = new ko(e, t, i, a, Zee(r, o));
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  getHTMLElement() {
    return this.list.getHTMLElement();
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get widget() {
    return this.list;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  get onMouseDblClick() {
    return te.map(this.list.onMouseDblClick, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onPointer() {
    return te.map(this.list.onPointer, ({ element: e, index: t, browserEvent: i }) => ({ element: e === void 0 ? void 0 : this._model.get(e), index: t, browserEvent: i }));
  }
  get onDidChangeSelection() {
    return te.map(this.list.onDidChangeSelection, ({ elements: e, indexes: t, browserEvent: i }) => ({ elements: e.map((n) => this._model.get(n)), indexes: t, browserEvent: i }));
  }
  get model() {
    return this._model;
  }
  set model(e) {
    this._model = e, this.list.splice(0, this.list.length, Yn(e.length));
  }
  getFocus() {
    return this.list.getFocus();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getSelectedElements() {
    return this.getSelection().map((e) => this.model.get(e));
  }
  style(e) {
    this.list.style(e);
  }
  dispose() {
    this.list.dispose();
  }
}
var Em = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
const tte = !1;
var $C;
(function(s) {
  s.North = "north", s.South = "south", s.East = "east", s.West = "west";
})($C || ($C = {}));
let ite = 4;
const nte = new B();
let ste = 300;
const ote = new B();
class sT {
  constructor(e) {
    this.el = e, this.disposables = new X();
  }
  get onPointerMove() {
    return this.disposables.add(new Ke(fe(this.el), "mousemove")).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Ke(fe(this.el), "mouseup")).event;
  }
  dispose() {
    this.disposables.dispose();
  }
}
Em([
  oi
], sT.prototype, "onPointerMove", null);
Em([
  oi
], sT.prototype, "onPointerUp", null);
class oT {
  get onPointerMove() {
    return this.disposables.add(new Ke(this.el, Et.Change)).event;
  }
  get onPointerUp() {
    return this.disposables.add(new Ke(this.el, Et.End)).event;
  }
  constructor(e) {
    this.el = e, this.disposables = new X();
  }
  dispose() {
    this.disposables.dispose();
  }
}
Em([
  oi
], oT.prototype, "onPointerMove", null);
Em([
  oi
], oT.prototype, "onPointerUp", null);
class XC {
  get onPointerMove() {
    return this.factory.onPointerMove;
  }
  get onPointerUp() {
    return this.factory.onPointerUp;
  }
  constructor(e) {
    this.factory = e;
  }
  dispose() {
  }
}
Em([
  oi
], XC.prototype, "onPointerMove", null);
Em([
  oi
], XC.prototype, "onPointerUp", null);
const YF = "pointer-events-disabled";
class rn extends V {
  get state() {
    return this._state;
  }
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  /**
   * The state of a sash defines whether it can be interacted with by the user
   * as well as what mouse cursor to use, when hovered.
   */
  set state(e) {
    this._state !== e && (this.el.classList.toggle(
      "disabled",
      e === 0
      /* SashState.Disabled */
    ), this.el.classList.toggle(
      "minimum",
      e === 1
      /* SashState.AtMinimum */
    ), this.el.classList.toggle(
      "maximum",
      e === 2
      /* SashState.AtMaximum */
    ), this._state = e, this.onDidEnablementChange.fire(e));
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the start of this one. A corner sash will be created
   * automatically at that location.
   *
   * The start of a horizontal sash is its left-most position.
   * The start of a vertical sash is its top-most position.
   */
  set orthogonalStartSash(e) {
    if (this._orthogonalStartSash !== e) {
      if (this.orthogonalStartDragHandleDisposables.clear(), this.orthogonalStartSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalStartDragHandleDisposables.clear(), i !== 0 && (this._orthogonalStartDragHandle = K(this.el, de(".orthogonal-drag-handle.start")), this.orthogonalStartDragHandleDisposables.add(we(() => this._orthogonalStartDragHandle.remove())), this.orthogonalStartDragHandleDisposables.add(new Ke(this._orthogonalStartDragHandle, "mouseenter")).event(() => rn.onMouseEnter(e), void 0, this.orthogonalStartDragHandleDisposables), this.orthogonalStartDragHandleDisposables.add(new Ke(this._orthogonalStartDragHandle, "mouseleave")).event(() => rn.onMouseLeave(e), void 0, this.orthogonalStartDragHandleDisposables));
        };
        this.orthogonalStartSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalStartSash = e;
    }
  }
  /**
   * A reference to another sash, perpendicular to this one, which
   * aligns at the end of this one. A corner sash will be created
   * automatically at that location.
   *
   * The end of a horizontal sash is its right-most position.
   * The end of a vertical sash is its bottom-most position.
   */
  set orthogonalEndSash(e) {
    if (this._orthogonalEndSash !== e) {
      if (this.orthogonalEndDragHandleDisposables.clear(), this.orthogonalEndSashDisposables.clear(), e) {
        const t = (i) => {
          this.orthogonalEndDragHandleDisposables.clear(), i !== 0 && (this._orthogonalEndDragHandle = K(this.el, de(".orthogonal-drag-handle.end")), this.orthogonalEndDragHandleDisposables.add(we(() => this._orthogonalEndDragHandle.remove())), this.orthogonalEndDragHandleDisposables.add(new Ke(this._orthogonalEndDragHandle, "mouseenter")).event(() => rn.onMouseEnter(e), void 0, this.orthogonalEndDragHandleDisposables), this.orthogonalEndDragHandleDisposables.add(new Ke(this._orthogonalEndDragHandle, "mouseleave")).event(() => rn.onMouseLeave(e), void 0, this.orthogonalEndDragHandleDisposables));
        };
        this.orthogonalEndSashDisposables.add(e.onDidEnablementChange.event(t, this)), t(e.state);
      }
      this._orthogonalEndSash = e;
    }
  }
  constructor(e, t, i) {
    super(), this.hoverDelay = ste, this.hoverDelayer = this._register(new Gl(this.hoverDelay)), this._state = 3, this.onDidEnablementChange = this._register(new B()), this._onDidStart = this._register(new B()), this._onDidChange = this._register(new B()), this._onDidReset = this._register(new B()), this._onDidEnd = this._register(new B()), this.orthogonalStartSashDisposables = this._register(new X()), this.orthogonalStartDragHandleDisposables = this._register(new X()), this.orthogonalEndSashDisposables = this._register(new X()), this.orthogonalEndDragHandleDisposables = this._register(new X()), this.onDidStart = this._onDidStart.event, this.onDidChange = this._onDidChange.event, this.onDidReset = this._onDidReset.event, this.onDidEnd = this._onDidEnd.event, this.linkedSash = void 0, this.el = K(e, de(".monaco-sash")), i.orthogonalEdge && this.el.classList.add(`orthogonal-edge-${i.orthogonalEdge}`), ze && this.el.classList.add("mac");
    const n = this._register(new Ke(this.el, "mousedown")).event;
    this._register(n((h) => this.onPointerStart(h, new sT(e)), this));
    const o = this._register(new Ke(this.el, "dblclick")).event;
    this._register(o(this.onPointerDoublePress, this));
    const r = this._register(new Ke(this.el, "mouseenter")).event;
    this._register(r(() => rn.onMouseEnter(this)));
    const a = this._register(new Ke(this.el, "mouseleave")).event;
    this._register(a(() => rn.onMouseLeave(this))), this._register(xn.addTarget(this.el));
    const l = this._register(new Ke(this.el, Et.Start)).event;
    this._register(l((h) => this.onPointerStart(h, new oT(this.el)), this));
    const c = this._register(new Ke(this.el, Et.Tap)).event;
    let d;
    this._register(c((h) => {
      if (d) {
        clearTimeout(d), d = void 0, this.onPointerDoublePress(h);
        return;
      }
      clearTimeout(d), d = setTimeout(() => d = void 0, 250);
    }, this)), typeof i.size == "number" ? (this.size = i.size, i.orientation === 0 ? this.el.style.width = `${this.size}px` : this.el.style.height = `${this.size}px`) : (this.size = ite, this._register(nte.event((h) => {
      this.size = h, this.layout();
    }))), this._register(ote.event((h) => this.hoverDelay = h)), this.layoutProvider = t, this.orthogonalStartSash = i.orthogonalStartSash, this.orthogonalEndSash = i.orthogonalEndSash, this.orientation = i.orientation || 0, this.orientation === 1 ? (this.el.classList.add("horizontal"), this.el.classList.remove("vertical")) : (this.el.classList.remove("horizontal"), this.el.classList.add("vertical")), this.el.classList.toggle("debug", tte), this.layout();
  }
  onPointerStart(e, t) {
    Ve.stop(e);
    let i = !1;
    if (!e.__orthogonalSashEvent) {
      const m = this.getOrthogonalSash(e);
      m && (i = !0, e.__orthogonalSashEvent = !0, m.onPointerStart(e, new XC(t)));
    }
    if (this.linkedSash && !e.__linkedSashEvent && (e.__linkedSashEvent = !0, this.linkedSash.onPointerStart(e, new XC(t))), !this.state)
      return;
    const n = this.el.ownerDocument.getElementsByTagName("iframe");
    for (const m of n)
      m.classList.add(YF);
    const o = e.pageX, r = e.pageY, a = e.altKey, l = { startX: o, currentX: o, startY: r, currentY: r, altKey: a };
    this.el.classList.add("active"), this._onDidStart.fire(l);
    const c = xo(this.el), d = () => {
      let m = "";
      i ? m = "all-scroll" : this.orientation === 1 ? this.state === 1 ? m = "s-resize" : this.state === 2 ? m = "n-resize" : m = ze ? "row-resize" : "ns-resize" : this.state === 1 ? m = "e-resize" : this.state === 2 ? m = "w-resize" : m = ze ? "col-resize" : "ew-resize", c.textContent = `* { cursor: ${m} !important; }`;
    }, h = new X();
    d(), i || this.onDidEnablementChange.event(d, null, h);
    const u = (m) => {
      Ve.stop(m, !1);
      const p = { startX: o, currentX: m.pageX, startY: r, currentY: m.pageY, altKey: a };
      this._onDidChange.fire(p);
    }, g = (m) => {
      Ve.stop(m, !1), c.remove(), this.el.classList.remove("active"), this._onDidEnd.fire(), h.dispose();
      for (const p of n)
        p.classList.remove(YF);
    };
    t.onPointerMove(u, null, h), t.onPointerUp(g, null, h), h.add(t);
  }
  onPointerDoublePress(e) {
    const t = this.getOrthogonalSash(e);
    t && t._onDidReset.fire(), this.linkedSash && this.linkedSash._onDidReset.fire(), this._onDidReset.fire();
  }
  static onMouseEnter(e, t = !1) {
    e.el.classList.contains("active") ? (e.hoverDelayer.cancel(), e.el.classList.add("hover")) : e.hoverDelayer.trigger(() => e.el.classList.add("hover"), e.hoverDelay).then(void 0, () => {
    }), !t && e.linkedSash && rn.onMouseEnter(e.linkedSash, !0);
  }
  static onMouseLeave(e, t = !1) {
    e.hoverDelayer.cancel(), e.el.classList.remove("hover"), !t && e.linkedSash && rn.onMouseLeave(e.linkedSash, !0);
  }
  /**
   * Forcefully stop any user interactions with this sash.
   * Useful when hiding a parent component, while the user is still
   * interacting with the sash.
   */
  clearSashHoverState() {
    rn.onMouseLeave(this);
  }
  /**
   * Layout the sash. The sash will size and position itself
   * based on its provided {@link ISashLayoutProvider layout provider}.
   */
  layout() {
    if (this.orientation === 0) {
      const e = this.layoutProvider;
      this.el.style.left = e.getVerticalSashLeft(this) - this.size / 2 + "px", e.getVerticalSashTop && (this.el.style.top = e.getVerticalSashTop(this) + "px"), e.getVerticalSashHeight && (this.el.style.height = e.getVerticalSashHeight(this) + "px");
    } else {
      const e = this.layoutProvider;
      this.el.style.top = e.getHorizontalSashTop(this) - this.size / 2 + "px", e.getHorizontalSashLeft && (this.el.style.left = e.getHorizontalSashLeft(this) + "px"), e.getHorizontalSashWidth && (this.el.style.width = e.getHorizontalSashWidth(this) + "px");
    }
  }
  getOrthogonalSash(e) {
    const t = e.initialTarget ?? e.target;
    if (!(!t || !Bi(t)) && t.classList.contains("orthogonal-drag-handle"))
      return t.classList.contains("start") ? this.orthogonalStartSash : this.orthogonalEndSash;
  }
  dispose() {
    super.dispose(), this.el.remove();
  }
}
const rte = {
  separatorBorder: Y.transparent
};
class FW {
  set size(e) {
    this._size = e;
  }
  get size() {
    return this._size;
  }
  get visible() {
    return typeof this._cachedVisibleSize > "u";
  }
  setVisible(e, t) {
    if (e !== this.visible) {
      e ? (this.size = kn(this._cachedVisibleSize, this.viewMinimumSize, this.viewMaximumSize), this._cachedVisibleSize = void 0) : (this._cachedVisibleSize = typeof t == "number" ? t : this.size, this.size = 0), this.container.classList.toggle("visible", e);
      try {
        this.view.setVisible?.(e);
      } catch (i) {
        console.error("Splitview: Failed to set visible view"), console.error(i);
      }
    }
  }
  get minimumSize() {
    return this.visible ? this.view.minimumSize : 0;
  }
  get viewMinimumSize() {
    return this.view.minimumSize;
  }
  get maximumSize() {
    return this.visible ? this.view.maximumSize : 0;
  }
  get viewMaximumSize() {
    return this.view.maximumSize;
  }
  get priority() {
    return this.view.priority;
  }
  get proportionalLayout() {
    return this.view.proportionalLayout ?? !0;
  }
  get snap() {
    return !!this.view.snap;
  }
  set enabled(e) {
    this.container.style.pointerEvents = e ? "" : "none";
  }
  constructor(e, t, i, n) {
    this.container = e, this.view = t, this.disposable = n, this._cachedVisibleSize = void 0, typeof i == "number" ? (this._size = i, this._cachedVisibleSize = void 0, e.classList.add("visible")) : (this._size = 0, this._cachedVisibleSize = i.cachedVisibleSize);
  }
  layout(e, t) {
    this.layoutContainer(e);
    try {
      this.view.layout(this.size, e, t);
    } catch (i) {
      console.error("Splitview: Failed to layout view"), console.error(i);
    }
  }
  dispose() {
    this.disposable.dispose();
  }
}
class ate extends FW {
  layoutContainer(e) {
    this.container.style.top = `${e}px`, this.container.style.height = `${this.size}px`;
  }
}
class lte extends FW {
  layoutContainer(e) {
    this.container.style.left = `${e}px`, this.container.style.width = `${this.size}px`;
  }
}
var tl;
(function(s) {
  s[s.Idle = 0] = "Idle", s[s.Busy = 1] = "Busy";
})(tl || (tl = {}));
var ZC;
(function(s) {
  s.Distribute = { type: "distribute" };
  function e(n) {
    return { type: "split", index: n };
  }
  s.Split = e;
  function t(n) {
    return { type: "auto", index: n };
  }
  s.Auto = t;
  function i(n) {
    return { type: "invisible", cachedVisibleSize: n };
  }
  s.Invisible = i;
})(ZC || (ZC = {}));
class OW extends V {
  get orthogonalStartSash() {
    return this._orthogonalStartSash;
  }
  get orthogonalEndSash() {
    return this._orthogonalEndSash;
  }
  get startSnappingEnabled() {
    return this._startSnappingEnabled;
  }
  get endSnappingEnabled() {
    return this._endSnappingEnabled;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the left- or top-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalStartSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalStartSash = e;
    this._orthogonalStartSash = e;
  }
  /**
   * A reference to a sash, perpendicular to all sashes in this {@link SplitView},
   * located at the right- or bottom-most side of the SplitView.
   * Corner sashes will be created automatically at the intersections.
   */
  set orthogonalEndSash(e) {
    for (const t of this.sashItems)
      t.sash.orthogonalEndSash = e;
    this._orthogonalEndSash = e;
  }
  /**
   * Enable/disable snapping at the beginning of this {@link SplitView}.
   */
  set startSnappingEnabled(e) {
    this._startSnappingEnabled !== e && (this._startSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Enable/disable snapping at the end of this {@link SplitView}.
   */
  set endSnappingEnabled(e) {
    this._endSnappingEnabled !== e && (this._endSnappingEnabled = e, this.updateSashEnablement());
  }
  /**
   * Create a new {@link SplitView} instance.
   */
  constructor(e, t = {}) {
    super(), this.size = 0, this._contentSize = 0, this.proportions = void 0, this.viewItems = [], this.sashItems = [], this.state = tl.Idle, this._onDidSashChange = this._register(new B()), this._onDidSashReset = this._register(new B()), this._startSnappingEnabled = !0, this._endSnappingEnabled = !0, this.onDidSashChange = this._onDidSashChange.event, this.onDidSashReset = this._onDidSashReset.event, this.orientation = t.orientation ?? 0, this.inverseAltBehavior = t.inverseAltBehavior ?? !1, this.proportionalLayout = t.proportionalLayout ?? !0, this.getSashOrthogonalSize = t.getSashOrthogonalSize, this.el = document.createElement("div"), this.el.classList.add("monaco-split-view2"), this.el.classList.add(this.orientation === 0 ? "vertical" : "horizontal"), e.appendChild(this.el), this.sashContainer = K(this.el, de(".sash-container")), this.viewContainer = de(".split-view-container"), this.scrollable = this._register(new vm({
      forceIntegerValues: !0,
      smoothScrollDuration: 125,
      scheduleAtNextAnimationFrame: (n) => ys(fe(this.el), n)
    })), this.scrollableElement = this._register(new Y0(this.viewContainer, {
      vertical: this.orientation === 0 ? t.scrollbarVisibility ?? 1 : 2,
      horizontal: this.orientation === 1 ? t.scrollbarVisibility ?? 1 : 2
      /* ScrollbarVisibility.Hidden */
    }, this.scrollable));
    const i = this._register(new Ke(this.viewContainer, "scroll")).event;
    this._register(i((n) => {
      const o = this.scrollableElement.getScrollPosition(), r = Math.abs(this.viewContainer.scrollLeft - o.scrollLeft) <= 1 ? void 0 : this.viewContainer.scrollLeft, a = Math.abs(this.viewContainer.scrollTop - o.scrollTop) <= 1 ? void 0 : this.viewContainer.scrollTop;
      (r !== void 0 || a !== void 0) && this.scrollableElement.setScrollPosition({ scrollLeft: r, scrollTop: a });
    })), this.onDidScroll = this.scrollableElement.onScroll, this._register(this.onDidScroll((n) => {
      n.scrollTopChanged && (this.viewContainer.scrollTop = n.scrollTop), n.scrollLeftChanged && (this.viewContainer.scrollLeft = n.scrollLeft);
    })), K(this.el, this.scrollableElement.getDomNode()), this.style(t.styles || rte), t.descriptor && (this.size = t.descriptor.size, t.descriptor.views.forEach((n, o) => {
      const r = Mn(n.visible) || n.visible ? n.size : { type: "invisible", cachedVisibleSize: n.size }, a = n.view;
      this.doAddView(a, r, o, !0);
    }), this._contentSize = this.viewItems.reduce((n, o) => n + o.size, 0), this.saveProportions());
  }
  style(e) {
    e.separatorBorder.isTransparent() ? (this.el.classList.remove("separator-border"), this.el.style.removeProperty("--separator-border")) : (this.el.classList.add("separator-border"), this.el.style.setProperty("--separator-border", e.separatorBorder.toString()));
  }
  /**
   * Add a {@link IView view} to this {@link SplitView}.
   *
   * @param view The view to add.
   * @param size Either a fixed size, or a dynamic {@link Sizing} strategy.
   * @param index The index to insert the view on.
   * @param skipLayout Whether layout should be skipped.
   */
  addView(e, t, i = this.viewItems.length, n) {
    this.doAddView(e, t, i, n);
  }
  /**
   * Layout the {@link SplitView}.
   *
   * @param size The entire size of the {@link SplitView}.
   * @param layoutContext An optional layout context to pass along to {@link IView views}.
   */
  layout(e, t) {
    const i = Math.max(this.size, this._contentSize);
    if (this.size = e, this.layoutContext = t, this.proportions) {
      let n = 0;
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" ? n += a : e -= r.size;
      }
      for (let o = 0; o < this.viewItems.length; o++) {
        const r = this.viewItems[o], a = this.proportions[o];
        typeof a == "number" && n > 0 && (r.size = kn(Math.round(a * e / n), r.minimumSize, r.maximumSize));
      }
    } else {
      const n = Yn(this.viewItems.length), o = n.filter(
        (a) => this.viewItems[a].priority === 1
        /* LayoutPriority.Low */
      ), r = n.filter(
        (a) => this.viewItems[a].priority === 2
        /* LayoutPriority.High */
      );
      this.resize(this.viewItems.length - 1, e - i, void 0, o, r);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  saveProportions() {
    this.proportionalLayout && this._contentSize > 0 && (this.proportions = this.viewItems.map((e) => e.proportionalLayout && e.visible ? e.size / this._contentSize : void 0));
  }
  onSashStart({ sash: e, start: t, alt: i }) {
    for (const a of this.viewItems)
      a.enabled = !1;
    const n = this.sashItems.findIndex((a) => a.sash === e), o = jo(U(this.el.ownerDocument.body, "keydown", (a) => r(this.sashDragState.current, a.altKey)), U(this.el.ownerDocument.body, "keyup", () => r(this.sashDragState.current, !1))), r = (a, l) => {
      const c = this.viewItems.map((m) => m.size);
      let d = Number.NEGATIVE_INFINITY, h = Number.POSITIVE_INFINITY;
      if (this.inverseAltBehavior && (l = !l), l)
        if (n === this.sashItems.length - 1) {
          const p = this.viewItems[n];
          d = (p.minimumSize - p.size) / 2, h = (p.maximumSize - p.size) / 2;
        } else {
          const p = this.viewItems[n + 1];
          d = (p.size - p.maximumSize) / 2, h = (p.size - p.minimumSize) / 2;
        }
      let u, g;
      if (!l) {
        const m = Yn(n, -1), p = Yn(n + 1, this.viewItems.length), A = m.reduce((D, I) => D + (this.viewItems[I].minimumSize - c[I]), 0), _ = m.reduce((D, I) => D + (this.viewItems[I].viewMaximumSize - c[I]), 0), b = p.length === 0 ? Number.POSITIVE_INFINITY : p.reduce((D, I) => D + (c[I] - this.viewItems[I].minimumSize), 0), C = p.length === 0 ? Number.NEGATIVE_INFINITY : p.reduce((D, I) => D + (c[I] - this.viewItems[I].viewMaximumSize), 0), w = Math.max(A, C), S = Math.min(b, _), x = this.findFirstSnapIndex(m), y = this.findFirstSnapIndex(p);
        if (typeof x == "number") {
          const D = this.viewItems[x], I = Math.floor(D.viewMinimumSize / 2);
          u = {
            index: x,
            limitDelta: D.visible ? w - I : w + I,
            size: D.size
          };
        }
        if (typeof y == "number") {
          const D = this.viewItems[y], I = Math.floor(D.viewMinimumSize / 2);
          g = {
            index: y,
            limitDelta: D.visible ? S + I : S - I,
            size: D.size
          };
        }
      }
      this.sashDragState = { start: a, current: a, index: n, sizes: c, minDelta: d, maxDelta: h, alt: l, snapBefore: u, snapAfter: g, disposable: o };
    };
    r(t, i);
  }
  onSashChange({ current: e }) {
    const { index: t, start: i, sizes: n, alt: o, minDelta: r, maxDelta: a, snapBefore: l, snapAfter: c } = this.sashDragState;
    this.sashDragState.current = e;
    const d = e - i, h = this.resize(t, d, n, void 0, void 0, r, a, l, c);
    if (o) {
      const u = t === this.sashItems.length - 1, g = this.viewItems.map((C) => C.size), m = u ? t : t + 1, p = this.viewItems[m], A = p.size - p.maximumSize, _ = p.size - p.minimumSize, b = u ? t - 1 : t + 1;
      this.resize(b, -h, g, void 0, void 0, A, _);
    }
    this.distributeEmptySpace(), this.layoutViews();
  }
  onSashEnd(e) {
    this._onDidSashChange.fire(e), this.sashDragState.disposable.dispose(), this.saveProportions();
    for (const t of this.viewItems)
      t.enabled = !0;
  }
  onViewChange(e, t) {
    const i = this.viewItems.indexOf(e);
    i < 0 || i >= this.viewItems.length || (t = typeof t == "number" ? t : e.size, t = kn(t, e.minimumSize, e.maximumSize), this.inverseAltBehavior && i > 0 ? (this.resize(i - 1, Math.floor((e.size - t) / 2)), this.distributeEmptySpace(), this.layoutViews()) : (e.size = t, this.relayout([i], void 0)));
  }
  /**
   * Resize a {@link IView view} within the {@link SplitView}.
   *
   * @param index The {@link IView view} index.
   * @param size The {@link IView view} size.
   */
  resizeView(e, t) {
    if (!(e < 0 || e >= this.viewItems.length)) {
      if (this.state !== tl.Idle)
        throw new Error("Cant modify splitview");
      this.state = tl.Busy;
      try {
        const i = Yn(this.viewItems.length).filter((a) => a !== e), n = [...i.filter(
          (a) => this.viewItems[a].priority === 1
          /* LayoutPriority.Low */
        ), e], o = i.filter(
          (a) => this.viewItems[a].priority === 2
          /* LayoutPriority.High */
        ), r = this.viewItems[e];
        t = Math.round(t), t = kn(t, r.minimumSize, Math.min(r.maximumSize, this.size)), r.size = t, this.relayout(n, o);
      } finally {
        this.state = tl.Idle;
      }
    }
  }
  /**
   * Distribute the entire {@link SplitView} size among all {@link IView views}.
   */
  distributeViewSizes() {
    const e = [];
    let t = 0;
    for (const a of this.viewItems)
      a.maximumSize - a.minimumSize > 0 && (e.push(a), t += a.size);
    const i = Math.floor(t / e.length);
    for (const a of e)
      a.size = kn(i, a.minimumSize, a.maximumSize);
    const n = Yn(this.viewItems.length), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    this.relayout(o, r);
  }
  /**
   * Returns the size of a {@link IView view}.
   */
  getViewSize(e) {
    return e < 0 || e >= this.viewItems.length ? -1 : this.viewItems[e].size;
  }
  doAddView(e, t, i = this.viewItems.length, n) {
    if (this.state !== tl.Idle)
      throw new Error("Cant modify splitview");
    this.state = tl.Busy;
    try {
      const o = de(".split-view-view");
      i === this.viewItems.length ? this.viewContainer.appendChild(o) : this.viewContainer.insertBefore(o, this.viewContainer.children.item(i));
      const r = e.onDidChange((u) => this.onViewChange(d, u)), a = we(() => o.remove()), l = jo(r, a);
      let c;
      typeof t == "number" ? c = t : (t.type === "auto" && (this.areViewsDistributed() ? t = { type: "distribute" } : t = { type: "split", index: t.index }), t.type === "split" ? c = this.getViewSize(t.index) / 2 : t.type === "invisible" ? c = { cachedVisibleSize: t.cachedVisibleSize } : c = e.minimumSize);
      const d = this.orientation === 0 ? new ate(o, e, c, l) : new lte(o, e, c, l);
      if (this.viewItems.splice(i, 0, d), this.viewItems.length > 1) {
        const u = { orthogonalStartSash: this.orthogonalStartSash, orthogonalEndSash: this.orthogonalEndSash }, g = this.orientation === 0 ? new rn(this.sashContainer, { getHorizontalSashTop: (D) => this.getSashPosition(D), getHorizontalSashWidth: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 1
          /* Orientation.HORIZONTAL */
        }) : new rn(this.sashContainer, { getVerticalSashLeft: (D) => this.getSashPosition(D), getVerticalSashHeight: this.getSashOrthogonalSize }, {
          ...u,
          orientation: 0
          /* Orientation.VERTICAL */
        }), m = this.orientation === 0 ? (D) => ({ sash: g, start: D.startY, current: D.currentY, alt: D.altKey }) : (D) => ({ sash: g, start: D.startX, current: D.currentX, alt: D.altKey }), A = te.map(g.onDidStart, m)(this.onSashStart, this), b = te.map(g.onDidChange, m)(this.onSashChange, this), w = te.map(g.onDidEnd, () => this.sashItems.findIndex((D) => D.sash === g))(this.onSashEnd, this), S = g.onDidReset(() => {
          const D = this.sashItems.findIndex((j) => j.sash === g), I = Yn(D, -1), Q = Yn(D + 1, this.viewItems.length), P = this.findFirstSnapIndex(I), W = this.findFirstSnapIndex(Q);
          typeof P == "number" && !this.viewItems[P].visible || typeof W == "number" && !this.viewItems[W].visible || this._onDidSashReset.fire(D);
        }), x = jo(A, b, w, S, g), y = { sash: g, disposable: x };
        this.sashItems.splice(i - 1, 0, y);
      }
      o.appendChild(e.element);
      let h;
      typeof t != "number" && t.type === "split" && (h = [t.index]), n || this.relayout([i], h), !n && typeof t != "number" && t.type === "distribute" && this.distributeViewSizes();
    } finally {
      this.state = tl.Idle;
    }
  }
  relayout(e, t) {
    const i = this.viewItems.reduce((n, o) => n + o.size, 0);
    this.resize(this.viewItems.length - 1, this.size - i, void 0, e, t), this.distributeEmptySpace(), this.layoutViews(), this.saveProportions();
  }
  resize(e, t, i = this.viewItems.map((d) => d.size), n, o, r = Number.NEGATIVE_INFINITY, a = Number.POSITIVE_INFINITY, l, c) {
    if (e < 0 || e >= this.viewItems.length)
      return 0;
    const d = Yn(e, -1), h = Yn(e + 1, this.viewItems.length);
    if (o)
      for (const y of o)
        VS(d, y), VS(h, y);
    if (n)
      for (const y of n)
        sb(d, y), sb(h, y);
    const u = d.map((y) => this.viewItems[y]), g = d.map((y) => i[y]), m = h.map((y) => this.viewItems[y]), p = h.map((y) => i[y]), A = d.reduce((y, D) => y + (this.viewItems[D].minimumSize - i[D]), 0), _ = d.reduce((y, D) => y + (this.viewItems[D].maximumSize - i[D]), 0), b = h.length === 0 ? Number.POSITIVE_INFINITY : h.reduce((y, D) => y + (i[D] - this.viewItems[D].minimumSize), 0), C = h.length === 0 ? Number.NEGATIVE_INFINITY : h.reduce((y, D) => y + (i[D] - this.viewItems[D].maximumSize), 0), w = Math.max(A, C, r), S = Math.min(b, _, a);
    let x = !1;
    if (l) {
      const y = this.viewItems[l.index], D = t >= l.limitDelta;
      x = D !== y.visible, y.setVisible(D, l.size);
    }
    if (!x && c) {
      const y = this.viewItems[c.index], D = t < c.limitDelta;
      x = D !== y.visible, y.setVisible(D, c.size);
    }
    if (x)
      return this.resize(e, t, i, n, o, r, a);
    t = kn(t, w, S);
    for (let y = 0, D = t; y < u.length; y++) {
      const I = u[y], Q = kn(g[y] + D, I.minimumSize, I.maximumSize), P = Q - g[y];
      D -= P, I.size = Q;
    }
    for (let y = 0, D = t; y < m.length; y++) {
      const I = m[y], Q = kn(p[y] - D, I.minimumSize, I.maximumSize), P = Q - p[y];
      D += P, I.size = Q;
    }
    return t;
  }
  distributeEmptySpace(e) {
    const t = this.viewItems.reduce((a, l) => a + l.size, 0);
    let i = this.size - t;
    const n = Yn(this.viewItems.length - 1, -1), o = n.filter(
      (a) => this.viewItems[a].priority === 1
      /* LayoutPriority.Low */
    ), r = n.filter(
      (a) => this.viewItems[a].priority === 2
      /* LayoutPriority.High */
    );
    for (const a of r)
      VS(n, a);
    for (const a of o)
      sb(n, a);
    typeof e == "number" && sb(n, e);
    for (let a = 0; i !== 0 && a < n.length; a++) {
      const l = this.viewItems[n[a]], c = kn(l.size + i, l.minimumSize, l.maximumSize), d = c - l.size;
      i -= d, l.size = c;
    }
  }
  layoutViews() {
    this._contentSize = this.viewItems.reduce((t, i) => t + i.size, 0);
    let e = 0;
    for (const t of this.viewItems)
      t.layout(e, this.layoutContext), e += t.size;
    this.sashItems.forEach((t) => t.sash.layout()), this.updateSashEnablement(), this.updateScrollableElement();
  }
  updateScrollableElement() {
    this.orientation === 0 ? this.scrollableElement.setScrollDimensions({
      height: this.size,
      scrollHeight: this._contentSize
    }) : this.scrollableElement.setScrollDimensions({
      width: this.size,
      scrollWidth: this._contentSize
    });
  }
  updateSashEnablement() {
    let e = !1;
    const t = this.viewItems.map((l) => e = l.size - l.minimumSize > 0 || e);
    e = !1;
    const i = this.viewItems.map((l) => e = l.maximumSize - l.size > 0 || e), n = [...this.viewItems].reverse();
    e = !1;
    const o = n.map((l) => e = l.size - l.minimumSize > 0 || e).reverse();
    e = !1;
    const r = n.map((l) => e = l.maximumSize - l.size > 0 || e).reverse();
    let a = 0;
    for (let l = 0; l < this.sashItems.length; l++) {
      const { sash: c } = this.sashItems[l], d = this.viewItems[l];
      a += d.size;
      const h = !(t[l] && r[l + 1]), u = !(i[l] && o[l + 1]);
      if (h && u) {
        const g = Yn(l, -1), m = Yn(l + 1, this.viewItems.length), p = this.findFirstSnapIndex(g), A = this.findFirstSnapIndex(m), _ = typeof p == "number" && !this.viewItems[p].visible, b = typeof A == "number" && !this.viewItems[A].visible;
        _ && o[l] && (a > 0 || this.startSnappingEnabled) ? c.state = 1 : b && t[l] && (a < this._contentSize || this.endSnappingEnabled) ? c.state = 2 : c.state = 0;
      } else h && !u ? c.state = 1 : !h && u ? c.state = 2 : c.state = 3;
    }
  }
  getSashPosition(e) {
    let t = 0;
    for (let i = 0; i < this.sashItems.length; i++)
      if (t += this.viewItems[i].size, this.sashItems[i].sash === e)
        return t;
    return 0;
  }
  findFirstSnapIndex(e) {
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.snap)
        return t;
    }
    for (const t of e) {
      const i = this.viewItems[t];
      if (i.visible && i.maximumSize - i.minimumSize > 0)
        return;
      if (!i.visible && i.snap)
        return t;
    }
  }
  areViewsDistributed() {
    let e, t;
    for (const i of this.viewItems)
      if (e = e === void 0 ? i.size : Math.min(e, i.size), t = t === void 0 ? i.size : Math.max(t, i.size), t - e > 2)
        return !1;
    return !0;
  }
  dispose() {
    this.sashDragState?.disposable.dispose(), Ct(this.viewItems), this.viewItems = [], this.sashItems.forEach((e) => e.disposable.dispose()), this.sashItems = [], super.dispose();
  }
}
const B1 = class B1 {
  constructor(e, t, i) {
    this.columns = e, this.getColumnSize = i, this.templateId = B1.TemplateId, this.renderedTemplates = /* @__PURE__ */ new Set();
    const n = new Map(t.map((o) => [o.templateId, o]));
    this.renderers = [];
    for (const o of e) {
      const r = n.get(o.templateId);
      if (!r)
        throw new Error(`Table cell renderer for template id ${o.templateId} not found.`);
      this.renderers.push(r);
    }
  }
  renderTemplate(e) {
    const t = K(e, de(".monaco-table-tr")), i = [], n = [];
    for (let r = 0; r < this.columns.length; r++) {
      const a = this.renderers[r], l = K(t, de(".monaco-table-td", { "data-col-index": r }));
      l.style.width = `${this.getColumnSize(r)}px`, i.push(l), n.push(a.renderTemplate(l));
    }
    const o = { container: e, cellContainers: i, cellTemplateData: n };
    return this.renderedTemplates.add(o), o;
  }
  renderElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const a = this.columns[o].project(e);
      this.renderers[o].renderElement(a, t, i.cellTemplateData[o], n);
    }
  }
  disposeElement(e, t, i, n) {
    for (let o = 0; o < this.columns.length; o++) {
      const r = this.renderers[o];
      if (r.disposeElement) {
        const l = this.columns[o].project(e);
        r.disposeElement(l, t, i.cellTemplateData[o], n);
      }
    }
  }
  disposeTemplate(e) {
    for (let t = 0; t < this.columns.length; t++)
      this.renderers[t].disposeTemplate(e.cellTemplateData[t]);
    Bn(e.container), this.renderedTemplates.delete(e);
  }
  layoutColumn(e, t) {
    for (const { cellContainers: i } of this.renderedTemplates)
      i[e].style.width = `${t}px`;
  }
};
B1.TemplateId = "row";
let ev = B1;
function cte(s) {
  return {
    getHeight(e) {
      return s.getHeight(e);
    },
    getTemplateId() {
      return ev.TemplateId;
    }
  };
}
class dte extends V {
  get minimumSize() {
    return this.column.minimumWidth ?? 120;
  }
  get maximumSize() {
    return this.column.maximumWidth ?? Number.POSITIVE_INFINITY;
  }
  get onDidChange() {
    return this.column.onDidChangeWidthConstraints ?? te.None;
  }
  constructor(e, t) {
    super(), this.column = e, this.index = t, this._onDidLayout = new B(), this.onDidLayout = this._onDidLayout.event, this.element = de(".monaco-table-th", { "data-col-index": t }, e.label), e.tooltip && this._register(Oa().setupManagedHover(Ls("mouse"), this.element, e.tooltip));
  }
  layout(e) {
    this._onDidLayout.fire([this.index, e]);
  }
}
const R1 = class R1 {
  get onDidChangeFocus() {
    return this.list.onDidChangeFocus;
  }
  get onDidChangeSelection() {
    return this.list.onDidChangeSelection;
  }
  get onDidScroll() {
    return this.list.onDidScroll;
  }
  get onMouseDblClick() {
    return this.list.onMouseDblClick;
  }
  get onPointer() {
    return this.list.onPointer;
  }
  get onDidFocus() {
    return this.list.onDidFocus;
  }
  get scrollTop() {
    return this.list.scrollTop;
  }
  set scrollTop(e) {
    this.list.scrollTop = e;
  }
  get scrollHeight() {
    return this.list.scrollHeight;
  }
  get renderHeight() {
    return this.list.renderHeight;
  }
  get onDidDispose() {
    return this.list.onDidDispose;
  }
  constructor(e, t, i, n, o, r) {
    this.virtualDelegate = i, this.columns = n, this.domId = `table_id_${++R1.InstanceCount}`, this.disposables = new X(), this.cachedWidth = 0, this.cachedHeight = 0, this.domNode = K(t, de(`.monaco-table.${this.domId}`));
    const a = n.map((d, h) => this.disposables.add(new dte(d, h))), l = {
      size: a.reduce((d, h) => d + h.column.weight, 0),
      views: a.map((d) => ({ size: d.column.weight, view: d }))
    };
    this.splitview = this.disposables.add(new OW(this.domNode, {
      orientation: 1,
      scrollbarVisibility: 2,
      getSashOrthogonalSize: () => this.cachedHeight,
      descriptor: l
    })), this.splitview.el.style.height = `${i.headerRowHeight}px`, this.splitview.el.style.lineHeight = `${i.headerRowHeight}px`;
    const c = new ev(n, o, (d) => this.splitview.getViewSize(d));
    this.list = this.disposables.add(new ko(e, this.domNode, cte(i), [c], r)), te.any(...a.map((d) => d.onDidLayout))(([d, h]) => c.layoutColumn(d, h), null, this.disposables), this.splitview.onDidSashReset((d) => {
      const h = n.reduce((g, m) => g + m.weight, 0), u = n[d].weight / h * this.cachedWidth;
      this.splitview.resizeView(d, u);
    }, null, this.disposables), this.styleElement = xo(this.domNode), this.style(T$);
  }
  updateOptions(e) {
    this.list.updateOptions(e);
  }
  splice(e, t, i = []) {
    this.list.splice(e, t, i);
  }
  getHTMLElement() {
    return this.domNode;
  }
  style(e) {
    const t = [];
    t.push(`.monaco-table.${this.domId} > .monaco-split-view2 .monaco-sash.vertical::before {
			top: ${this.virtualDelegate.headerRowHeight + 1}px;
			height: calc(100% - ${this.virtualDelegate.headerRowHeight}px);
		}`), this.styleElement.textContent = t.join(`
`), this.list.style(e);
  }
  getSelectedElements() {
    return this.list.getSelectedElements();
  }
  getSelection() {
    return this.list.getSelection();
  }
  getFocus() {
    return this.list.getFocus();
  }
  dispose() {
    this.disposables.dispose();
  }
};
R1.InstanceCount = 0;
let Ik = R1;
var Fs;
(function(s) {
  s[s.Expanded = 0] = "Expanded", s[s.Collapsed = 1] = "Collapsed", s[s.PreserveOrExpanded = 2] = "PreserveOrExpanded", s[s.PreserveOrCollapsed = 3] = "PreserveOrCollapsed";
})(Fs || (Fs = {}));
var Sh;
(function(s) {
  s[s.Unknown = 0] = "Unknown", s[s.Twistie = 1] = "Twistie", s[s.Element = 2] = "Element", s[s.Filter = 3] = "Filter";
})(Sh || (Sh = {}));
class Vs extends Error {
  constructor(e, t) {
    super(`TreeError [${e}] ${t}`);
  }
}
class rT {
  constructor(e) {
    this.fn = e, this._map = /* @__PURE__ */ new WeakMap();
  }
  map(e) {
    let t = this._map.get(e);
    return t || (t = this.fn(e), this._map.set(e, t)), t;
  }
}
function aT(s) {
  return typeof s == "object" && "visibility" in s && "data" in s;
}
function e_(s) {
  switch (s) {
    case !0:
      return 1;
    case !1:
      return 0;
    default:
      return s;
  }
}
function Qy(s) {
  return typeof s.collapsible == "boolean";
}
class hte {
  constructor(e, t, i, n = {}) {
    this.user = e, this.list = t, this.rootRef = [], this.eventBufferer = new k_(), this._onDidChangeCollapseState = new B(), this.onDidChangeCollapseState = this.eventBufferer.wrapEvent(this._onDidChangeCollapseState.event), this._onDidChangeRenderNodeCount = new B(), this.onDidChangeRenderNodeCount = this.eventBufferer.wrapEvent(this._onDidChangeRenderNodeCount.event), this._onDidSplice = new B(), this.onDidSplice = this._onDidSplice.event, this.refilterDelayer = new Gl(xH), this.collapseByDefault = typeof n.collapseByDefault > "u" ? !1 : n.collapseByDefault, this.allowNonCollapsibleParents = n.allowNonCollapsibleParents ?? !1, this.filter = n.filter, this.autoExpandSingleChildren = typeof n.autoExpandSingleChildren > "u" ? !1 : n.autoExpandSingleChildren, this.root = {
      parent: void 0,
      element: i,
      children: [],
      depth: 0,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: !1,
      collapsed: !1,
      renderNodeCount: 0,
      visibility: 1,
      visible: !0,
      filterData: void 0
    };
  }
  splice(e, t, i = nt.empty(), n = {}) {
    if (e.length === 0)
      throw new Vs(this.user, "Invalid tree location");
    n.diffIdentityProvider ? this.spliceSmart(n.diffIdentityProvider, e, t, i, n) : this.spliceSimple(e, t, i, n);
  }
  spliceSmart(e, t, i, n = nt.empty(), o, r = o.diffDepth ?? 0) {
    const { parentNode: a } = this.getParentNodeWithListIndex(t);
    if (!a.lastDiffIds)
      return this.spliceSimple(t, i, n, o);
    const l = [...n], c = t[t.length - 1], d = new ml({ getElements: () => a.lastDiffIds }, {
      getElements: () => [
        ...a.children.slice(0, c),
        ...l,
        ...a.children.slice(c + i)
      ].map((p) => e.getId(p.element).toString())
    }).ComputeDiff(!1);
    if (d.quitEarly)
      return a.lastDiffIds = void 0, this.spliceSimple(t, i, l, o);
    const h = t.slice(0, -1), u = (p, A, _) => {
      if (r > 0)
        for (let b = 0; b < _; b++)
          p--, A--, this.spliceSmart(e, [...h, p, 0], Number.MAX_SAFE_INTEGER, l[A].children, o, r - 1);
    };
    let g = Math.min(a.children.length, c + i), m = l.length;
    for (const p of d.changes.sort((A, _) => _.originalStart - A.originalStart))
      u(g, m, g - (p.originalStart + p.originalLength)), g = p.originalStart, m = p.modifiedStart - c, this.spliceSimple([...h, g], p.originalLength, nt.slice(l, m, m + p.modifiedLength), o);
    u(g, m, g);
  }
  spliceSimple(e, t, i = nt.empty(), { onDidCreateNode: n, onDidDeleteNode: o, diffIdentityProvider: r }) {
    const { parentNode: a, listIndex: l, revealed: c, visible: d } = this.getParentNodeWithListIndex(e), h = [], u = nt.map(i, (S) => this.createTreeNode(S, a, a.visible ? 1 : 0, c, h, n)), g = e[e.length - 1];
    let m = 0;
    for (let S = g; S >= 0 && S < a.children.length; S--) {
      const x = a.children[S];
      if (x.visible) {
        m = x.visibleChildIndex;
        break;
      }
    }
    const p = [];
    let A = 0, _ = 0;
    for (const S of u)
      p.push(S), _ += S.renderNodeCount, S.visible && (S.visibleChildIndex = m + A++);
    const b = OB(a.children, g, t, p);
    r ? a.lastDiffIds ? OB(a.lastDiffIds, g, t, p.map((S) => r.getId(S.element).toString())) : a.lastDiffIds = a.children.map((S) => r.getId(S.element).toString()) : a.lastDiffIds = void 0;
    let C = 0;
    for (const S of b)
      S.visible && C++;
    if (C !== 0)
      for (let S = g + p.length; S < a.children.length; S++) {
        const x = a.children[S];
        x.visible && (x.visibleChildIndex -= C);
      }
    if (a.visibleChildrenCount += A - C, c && d) {
      const S = b.reduce((x, y) => x + (y.visible ? y.renderNodeCount : 0), 0);
      this._updateAncestorsRenderNodeCount(a, _ - S), this.list.splice(l, S, h);
    }
    if (b.length > 0 && o) {
      const S = (x) => {
        o(x), x.children.forEach(S);
      };
      b.forEach(S);
    }
    this._onDidSplice.fire({ insertedNodes: p, deletedNodes: b });
    let w = a;
    for (; w; ) {
      if (w.visibility === 2) {
        this.refilterDelayer.trigger(() => this.refilter());
        break;
      }
      w = w.parent;
    }
  }
  rerender(e) {
    if (e.length === 0)
      throw new Vs(this.user, "Invalid tree location");
    const { node: t, listIndex: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    t.visible && n && this.list.splice(i, 1, [t]);
  }
  has(e) {
    return this.hasTreeNode(e);
  }
  getListIndex(e) {
    const { listIndex: t, visible: i, revealed: n } = this.getTreeNodeWithListIndex(e);
    return i && n ? t : -1;
  }
  getListRenderCount(e) {
    return this.getTreeNode(e).renderNodeCount;
  }
  isCollapsible(e) {
    return this.getTreeNode(e).collapsible;
  }
  setCollapsible(e, t) {
    const i = this.getTreeNode(e);
    typeof t > "u" && (t = !i.collapsible);
    const n = { collapsible: t };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, n));
  }
  isCollapsed(e) {
    return this.getTreeNode(e).collapsed;
  }
  setCollapsed(e, t, i) {
    const n = this.getTreeNode(e);
    typeof t > "u" && (t = !n.collapsed);
    const o = { collapsed: t, recursive: i || !1 };
    return this.eventBufferer.bufferEvents(() => this._setCollapseState(e, o));
  }
  _setCollapseState(e, t) {
    const { node: i, listIndex: n, revealed: o } = this.getTreeNodeWithListIndex(e), r = this._setListNodeCollapseState(i, n, o, t);
    if (i !== this.root && this.autoExpandSingleChildren && r && !Qy(t) && i.collapsible && !i.collapsed && !t.recursive) {
      let a = -1;
      for (let l = 0; l < i.children.length; l++)
        if (i.children[l].visible)
          if (a > -1) {
            a = -1;
            break;
          } else
            a = l;
      a > -1 && this._setCollapseState([...e, a], t);
    }
    return r;
  }
  _setListNodeCollapseState(e, t, i, n) {
    const o = this._setNodeCollapseState(e, n, !1);
    if (!i || !e.visible || !o)
      return o;
    const r = e.renderNodeCount, a = this.updateNodeAfterCollapseChange(e), l = r - (t === -1 ? 0 : 1);
    return this.list.splice(t + 1, l, a.slice(1)), o;
  }
  _setNodeCollapseState(e, t, i) {
    let n;
    if (e === this.root ? n = !1 : (Qy(t) ? (n = e.collapsible !== t.collapsible, e.collapsible = t.collapsible) : e.collapsible ? (n = e.collapsed !== t.collapsed, e.collapsed = t.collapsed) : n = !1, n && this._onDidChangeCollapseState.fire({ node: e, deep: i })), !Qy(t) && t.recursive)
      for (const o of e.children)
        n = this._setNodeCollapseState(o, t, !0) || n;
    return n;
  }
  expandTo(e) {
    this.eventBufferer.bufferEvents(() => {
      let t = this.getTreeNode(e);
      for (; t.parent; )
        t = t.parent, e = e.slice(0, e.length - 1), t.collapsed && this._setCollapseState(e, { collapsed: !1, recursive: !1 });
    });
  }
  refilter() {
    const e = this.root.renderNodeCount, t = this.updateNodeAfterFilterChange(this.root);
    this.list.splice(0, e, t), this.refilterDelayer.cancel();
  }
  createTreeNode(e, t, i, n, o, r) {
    const a = {
      parent: t,
      element: e.element,
      children: [],
      depth: t.depth + 1,
      visibleChildrenCount: 0,
      visibleChildIndex: -1,
      collapsible: typeof e.collapsible == "boolean" ? e.collapsible : typeof e.collapsed < "u",
      collapsed: typeof e.collapsed > "u" ? this.collapseByDefault : e.collapsed,
      renderNodeCount: 1,
      visibility: 1,
      visible: !0,
      filterData: void 0
    }, l = this._filterNode(a, i);
    a.visibility = l, n && o.push(a);
    const c = e.children || nt.empty(), d = n && l !== 0 && !a.collapsed;
    let h = 0, u = 1;
    for (const g of c) {
      const m = this.createTreeNode(g, a, l, d, o, r);
      a.children.push(m), u += m.renderNodeCount, m.visible && (m.visibleChildIndex = h++);
    }
    return this.allowNonCollapsibleParents || (a.collapsible = a.collapsible || a.children.length > 0), a.visibleChildrenCount = h, a.visible = l === 2 ? h > 0 : l === 1, a.visible ? a.collapsed || (a.renderNodeCount = u) : (a.renderNodeCount = 0, n && o.pop()), r?.(a), a;
  }
  updateNodeAfterCollapseChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterCollapseChange(e, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterCollapseChange(e, t) {
    if (e.visible === !1)
      return 0;
    if (t.push(e), e.renderNodeCount = 1, !e.collapsed)
      for (const i of e.children)
        e.renderNodeCount += this._updateNodeAfterCollapseChange(i, t);
    return this._onDidChangeRenderNodeCount.fire(e), e.renderNodeCount;
  }
  updateNodeAfterFilterChange(e) {
    const t = e.renderNodeCount, i = [];
    return this._updateNodeAfterFilterChange(e, e.visible ? 1 : 0, i), this._updateAncestorsRenderNodeCount(e.parent, i.length - t), i;
  }
  _updateNodeAfterFilterChange(e, t, i, n = !0) {
    let o;
    if (e !== this.root) {
      if (o = this._filterNode(e, t), o === 0)
        return e.visible = !1, e.renderNodeCount = 0, !1;
      n && i.push(e);
    }
    const r = i.length;
    e.renderNodeCount = e === this.root ? 0 : 1;
    let a = !1;
    if (!e.collapsed || o !== 0) {
      let l = 0;
      for (const c of e.children)
        a = this._updateNodeAfterFilterChange(c, o, i, n && !e.collapsed) || a, c.visible && (c.visibleChildIndex = l++);
      e.visibleChildrenCount = l;
    } else
      e.visibleChildrenCount = 0;
    return e !== this.root && (e.visible = o === 2 ? a : o === 1, e.visibility = o), e.visible ? e.collapsed || (e.renderNodeCount += i.length - r) : (e.renderNodeCount = 0, n && i.pop()), this._onDidChangeRenderNodeCount.fire(e), e.visible;
  }
  _updateAncestorsRenderNodeCount(e, t) {
    if (t !== 0)
      for (; e; )
        e.renderNodeCount += t, this._onDidChangeRenderNodeCount.fire(e), e = e.parent;
  }
  _filterNode(e, t) {
    const i = this.filter ? this.filter.filter(e.element, t) : 1;
    return typeof i == "boolean" ? (e.filterData = void 0, i ? 1 : 0) : aT(i) ? (e.filterData = i.data, e_(i.visibility)) : (e.filterData = void 0, e_(i));
  }
  // cheap
  hasTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return !0;
    const [i, ...n] = e;
    return i < 0 || i > t.children.length ? !1 : this.hasTreeNode(n, t.children[i]);
  }
  // cheap
  getTreeNode(e, t = this.root) {
    if (!e || e.length === 0)
      return t;
    const [i, ...n] = e;
    if (i < 0 || i > t.children.length)
      throw new Vs(this.user, "Invalid tree location");
    return this.getTreeNode(n, t.children[i]);
  }
  // expensive
  getTreeNodeWithListIndex(e) {
    if (e.length === 0)
      return { node: this.root, listIndex: -1, revealed: !0, visible: !1 };
    const { parentNode: t, listIndex: i, revealed: n, visible: o } = this.getParentNodeWithListIndex(e), r = e[e.length - 1];
    if (r < 0 || r > t.children.length)
      throw new Vs(this.user, "Invalid tree location");
    const a = t.children[r];
    return { node: a, listIndex: i, revealed: n, visible: o && a.visible };
  }
  getParentNodeWithListIndex(e, t = this.root, i = 0, n = !0, o = !0) {
    const [r, ...a] = e;
    if (r < 0 || r > t.children.length)
      throw new Vs(this.user, "Invalid tree location");
    for (let l = 0; l < r; l++)
      i += t.children[l].renderNodeCount;
    return n = n && !t.collapsed, o = o && t.visible, a.length === 0 ? { parentNode: t, listIndex: i, revealed: n, visible: o } : this.getParentNodeWithListIndex(a, t.children[r], i + 1, n, o);
  }
  getNode(e = []) {
    return this.getTreeNode(e);
  }
  // TODO@joao perf!
  getNodeLocation(e) {
    const t = [];
    let i = e;
    for (; i.parent; )
      t.push(i.parent.children.indexOf(i)), i = i.parent;
    return t.reverse();
  }
  getParentNodeLocation(e) {
    if (e.length !== 0)
      return e.length === 1 ? [] : A9(e)[0];
  }
  getFirstElementChild(e) {
    const t = this.getTreeNode(e);
    if (t.children.length !== 0)
      return t.children[0].element;
  }
}
class ute extends W_ {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function Gy(s) {
  return s instanceof W_ ? new ute(s) : s;
}
class gte {
  constructor(e, t) {
    this.modelProvider = e, this.dnd = t, this.autoExpandDisposable = V.None, this.disposables = new X();
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart?.(Gy(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    const a = this.dnd.onDragOver(Gy(e), t && t.element, i, n, o), l = this.autoExpandNode !== t;
    if (l && (this.autoExpandDisposable.dispose(), this.autoExpandNode = t), typeof t > "u")
      return a;
    if (l && typeof a != "boolean" && a.autoExpand && (this.autoExpandDisposable = zf(() => {
      const g = this.modelProvider(), m = g.getNodeLocation(t);
      g.isCollapsed(m) && g.setCollapsed(m, !1), this.autoExpandNode = void 0;
    }, 500, this.disposables)), typeof a == "boolean" || !a.accept || typeof a.bubble > "u" || a.feedback) {
      if (!r) {
        const g = typeof a == "boolean" ? a : a.accept, m = typeof a == "boolean" ? void 0 : a.effect;
        return { accept: g, effect: m, feedback: [i] };
      }
      return a;
    }
    if (a.bubble === 1) {
      const g = this.modelProvider(), m = g.getNodeLocation(t), p = g.getParentNodeLocation(m), A = g.getNode(p), _ = p && g.getListIndex(p);
      return this.onDragOver(e, A, _, n, o, !1);
    }
    const c = this.modelProvider(), d = c.getNodeLocation(t), h = c.getListIndex(d), u = c.getListRenderCount(d);
    return { ...a, feedback: Yn(h, h + u) };
  }
  drop(e, t, i, n, o) {
    this.autoExpandDisposable.dispose(), this.autoExpandNode = void 0, this.dnd.drop(Gy(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd?.(e);
  }
  dispose() {
    this.disposables.dispose(), this.dnd.dispose();
  }
}
function fte(s, e) {
  return e && {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(t.element);
      }
    },
    dnd: e.dnd && new gte(s, e.dnd),
    multipleSelectionController: e.multipleSelectionController && {
      isSelectionSingleChangeEvent(t) {
        return e.multipleSelectionController.isSelectionSingleChangeEvent({ ...t, element: t.element });
      },
      isSelectionRangeChangeEvent(t) {
        return e.multipleSelectionController.isSelectionRangeChangeEvent({ ...t, element: t.element });
      }
    },
    accessibilityProvider: e.accessibilityProvider && {
      ...e.accessibilityProvider,
      getSetSize(t) {
        const i = s(), n = i.getNodeLocation(t), o = i.getParentNodeLocation(n);
        return i.getNode(o).visibleChildrenCount;
      },
      getPosInSet(t) {
        return t.visibleChildIndex + 1;
      },
      isChecked: e.accessibilityProvider && e.accessibilityProvider.isChecked ? (t) => e.accessibilityProvider.isChecked(t.element) : void 0,
      getRole: e.accessibilityProvider && e.accessibilityProvider.getRole ? (t) => e.accessibilityProvider.getRole(t.element) : () => "treeitem",
      getAriaLabel(t) {
        return e.accessibilityProvider.getAriaLabel(t.element);
      },
      getWidgetAriaLabel() {
        return e.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: e.accessibilityProvider && e.accessibilityProvider.getWidgetRole ? () => e.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: e.accessibilityProvider && e.accessibilityProvider.getAriaLevel ? (t) => e.accessibilityProvider.getAriaLevel(t.element) : (t) => t.depth,
      getActiveDescendantId: e.accessibilityProvider.getActiveDescendantId && ((t) => e.accessibilityProvider.getActiveDescendantId(t.element))
    },
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(t) {
        return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t.element);
      }
    }
  };
}
class lT {
  constructor(e) {
    this.delegate = e;
  }
  getHeight(e) {
    return this.delegate.getHeight(e.element);
  }
  getTemplateId(e) {
    return this.delegate.getTemplateId(e.element);
  }
  hasDynamicHeight(e) {
    return !!this.delegate.hasDynamicHeight && this.delegate.hasDynamicHeight(e.element);
  }
  setDynamicHeight(e, t) {
    this.delegate.setDynamicHeight?.(e.element, t);
  }
}
var om;
(function(s) {
  s.None = "none", s.OnHover = "onHover", s.Always = "always";
})(om || (om = {}));
class mte {
  get elements() {
    return this._elements;
  }
  constructor(e, t = []) {
    this._elements = t, this.disposables = new X(), this.onDidChange = te.forEach(e, (i) => this._elements = i, this.disposables);
  }
  dispose() {
    this.disposables.dispose();
  }
}
const fA = class fA {
  constructor(e, t, i, n, o, r = {}) {
    this.renderer = e, this.modelProvider = t, this.activeNodes = n, this.renderedIndentGuides = o, this.renderedElements = /* @__PURE__ */ new Map(), this.renderedNodes = /* @__PURE__ */ new Map(), this.indent = fA.DefaultIndent, this.hideTwistiesOfChildlessElements = !1, this.shouldRenderIndentGuides = !1, this.activeIndentNodes = /* @__PURE__ */ new Set(), this.indentGuidesDisposable = V.None, this.disposables = new X(), this.templateId = e.templateId, this.updateOptions(r), te.map(i, (a) => a.node)(this.onDidChangeNodeTwistieState, this, this.disposables), e.onDidChangeTwistieState?.(this.onDidChangeTwistieState, this, this.disposables);
  }
  updateOptions(e = {}) {
    if (typeof e.indent < "u") {
      const t = kn(e.indent, 0, 40);
      if (t !== this.indent) {
        this.indent = t;
        for (const [i, n] of this.renderedNodes)
          this.renderTreeElement(i, n);
      }
    }
    if (typeof e.renderIndentGuides < "u") {
      const t = e.renderIndentGuides !== om.None;
      if (t !== this.shouldRenderIndentGuides) {
        this.shouldRenderIndentGuides = t;
        for (const [i, n] of this.renderedNodes)
          this._renderIndentGuides(i, n);
        if (this.indentGuidesDisposable.dispose(), t) {
          const i = new X();
          this.activeNodes.onDidChange(this._onDidChangeActiveNodes, this, i), this.indentGuidesDisposable = i, this._onDidChangeActiveNodes(this.activeNodes.elements);
        }
      }
    }
    typeof e.hideTwistiesOfChildlessElements < "u" && (this.hideTwistiesOfChildlessElements = e.hideTwistiesOfChildlessElements);
  }
  renderTemplate(e) {
    const t = K(e, de(".monaco-tl-row")), i = K(t, de(".monaco-tl-indent")), n = K(t, de(".monaco-tl-twistie")), o = K(t, de(".monaco-tl-contents")), r = this.renderer.renderTemplate(o);
    return { container: e, indent: i, twistie: n, indentGuidesDisposable: V.None, templateData: r };
  }
  renderElement(e, t, i, n) {
    this.renderedNodes.set(e, i), this.renderedElements.set(e.element, e), this.renderTreeElement(e, i), this.renderer.renderElement(e, t, i.templateData, n);
  }
  disposeElement(e, t, i, n) {
    i.indentGuidesDisposable.dispose(), this.renderer.disposeElement?.(e, t, i.templateData, n), typeof n == "number" && (this.renderedNodes.delete(e), this.renderedElements.delete(e.element));
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  onDidChangeTwistieState(e) {
    const t = this.renderedElements.get(e);
    t && this.onDidChangeNodeTwistieState(t);
  }
  onDidChangeNodeTwistieState(e) {
    const t = this.renderedNodes.get(e);
    t && (this._onDidChangeActiveNodes(this.activeNodes.elements), this.renderTreeElement(e, t));
  }
  renderTreeElement(e, t) {
    const i = fA.DefaultIndent + (e.depth - 1) * this.indent;
    t.twistie.style.paddingLeft = `${i}px`, t.indent.style.width = `${i + this.indent - 16}px`, e.collapsible ? t.container.setAttribute("aria-expanded", String(!e.collapsed)) : t.container.removeAttribute("aria-expanded"), t.twistie.classList.remove(...pe.asClassNameArray(Z.treeItemExpanded));
    let n = !1;
    this.renderer.renderTwistie && (n = this.renderer.renderTwistie(e.element, t.twistie)), e.collapsible && (!this.hideTwistiesOfChildlessElements || e.visibleChildrenCount > 0) ? (n || t.twistie.classList.add(...pe.asClassNameArray(Z.treeItemExpanded)), t.twistie.classList.add("collapsible"), t.twistie.classList.toggle("collapsed", e.collapsed)) : t.twistie.classList.remove("collapsible", "collapsed"), this._renderIndentGuides(e, t);
  }
  _renderIndentGuides(e, t) {
    if (Bn(t.indent), t.indentGuidesDisposable.dispose(), !this.shouldRenderIndentGuides)
      return;
    const i = new X(), n = this.modelProvider();
    for (; ; ) {
      const o = n.getNodeLocation(e), r = n.getParentNodeLocation(o);
      if (!r)
        break;
      const a = n.getNode(r), l = de(".indent-guide", { style: `width: ${this.indent}px` });
      this.activeIndentNodes.has(a) && l.classList.add("active"), t.indent.childElementCount === 0 ? t.indent.appendChild(l) : t.indent.insertBefore(l, t.indent.firstElementChild), this.renderedIndentGuides.add(a, l), i.add(we(() => this.renderedIndentGuides.delete(a, l))), e = a;
    }
    t.indentGuidesDisposable = i;
  }
  _onDidChangeActiveNodes(e) {
    if (!this.shouldRenderIndentGuides)
      return;
    const t = /* @__PURE__ */ new Set(), i = this.modelProvider();
    e.forEach((n) => {
      const o = i.getNodeLocation(n);
      try {
        const r = i.getParentNodeLocation(o);
        n.collapsible && n.children.length > 0 && !n.collapsed ? t.add(n) : r && t.add(i.getNode(r));
      } catch {
      }
    }), this.activeIndentNodes.forEach((n) => {
      t.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.remove("active"));
    }), t.forEach((n) => {
      this.activeIndentNodes.has(n) || this.renderedIndentGuides.forEach(n, (o) => o.classList.add("active"));
    }), this.activeIndentNodes = t;
  }
  dispose() {
    this.renderedNodes.clear(), this.renderedElements.clear(), this.indentGuidesDisposable.dispose(), Ct(this.disposables);
  }
};
fA.DefaultIndent = 8;
let Mk = fA;
class pte {
  get totalCount() {
    return this._totalCount;
  }
  get matchCount() {
    return this._matchCount;
  }
  constructor(e, t, i) {
    this.tree = e, this.keyboardNavigationLabelProvider = t, this._filter = i, this._totalCount = 0, this._matchCount = 0, this._pattern = "", this._lowercasePattern = "", this.disposables = new X(), e.onWillRefilter(this.reset, this, this.disposables);
  }
  filter(e, t) {
    let i = 1;
    if (this._filter) {
      const r = this._filter.filter(e, t);
      if (typeof r == "boolean" ? i = r ? 1 : 0 : aT(r) ? i = e_(r.visibility) : i = r, i === 0)
        return !1;
    }
    if (this._totalCount++, !this._pattern)
      return this._matchCount++, { data: Tr.Default, visibility: i };
    const n = this.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e), o = Array.isArray(n) ? n : [n];
    for (const r of o) {
      const a = r && r.toString();
      if (typeof a > "u")
        return { data: Tr.Default, visibility: i };
      let l;
      if (this.tree.findMatchType === yu.Contiguous) {
        const c = a.toLowerCase().indexOf(this._lowercasePattern);
        if (c > -1) {
          l = [Number.MAX_SAFE_INTEGER, 0];
          for (let d = this._lowercasePattern.length; d > 0; d--)
            l.push(c + d - 1);
        }
      } else
        l = $f(this._pattern, this._lowercasePattern, 0, a, a.toLowerCase(), 0, { firstMatchCanBeWeak: !0, boostFullMatch: !0 });
      if (l)
        return this._matchCount++, o.length === 1 ? { data: l, visibility: i } : { data: { label: a, score: l }, visibility: i };
    }
    return this.tree.findMode === Sl.Filter ? typeof this.tree.options.defaultFindVisibility == "number" ? this.tree.options.defaultFindVisibility : this.tree.options.defaultFindVisibility ? this.tree.options.defaultFindVisibility(e) : 2 : { data: Tr.Default, visibility: i };
  }
  reset() {
    this._totalCount = 0, this._matchCount = 0;
  }
  dispose() {
    Ct(this.disposables);
  }
}
var Sl;
(function(s) {
  s[s.Highlight = 0] = "Highlight", s[s.Filter = 1] = "Filter";
})(Sl || (Sl = {}));
var yu;
(function(s) {
  s[s.Fuzzy = 0] = "Fuzzy", s[s.Contiguous = 1] = "Contiguous";
})(yu || (yu = {}));
let Ate = class {
  get pattern() {
    return this._pattern;
  }
  get mode() {
    return this._mode;
  }
  set mode(e) {
    e !== this._mode && (this._mode = e, this.widget && (this.widget.mode = this._mode), this.tree.refilter(), this.render(), this._onDidChangeMode.fire(e));
  }
  get matchType() {
    return this._matchType;
  }
  set matchType(e) {
    e !== this._matchType && (this._matchType = e, this.widget && (this.widget.matchType = this._matchType), this.tree.refilter(), this.render(), this._onDidChangeMatchType.fire(e));
  }
  constructor(e, t, i, n, o, r = {}) {
    this.tree = e, this.view = i, this.filter = n, this.contextViewProvider = o, this.options = r, this._pattern = "", this.width = 0, this._onDidChangeMode = new B(), this.onDidChangeMode = this._onDidChangeMode.event, this._onDidChangeMatchType = new B(), this.onDidChangeMatchType = this._onDidChangeMatchType.event, this._onDidChangePattern = new B(), this._onDidChangeOpenState = new B(), this.onDidChangeOpenState = this._onDidChangeOpenState.event, this.enabledDisposables = new X(), this.disposables = new X(), this._mode = e.options.defaultFindMode ?? Sl.Highlight, this._matchType = e.options.defaultFindMatchType ?? yu.Fuzzy, t.onDidSplice(this.onDidSpliceModel, this, this.disposables);
  }
  updateOptions(e = {}) {
    e.defaultFindMode !== void 0 && (this.mode = e.defaultFindMode), e.defaultFindMatchType !== void 0 && (this.matchType = e.defaultFindMatchType);
  }
  onDidSpliceModel() {
    !this.widget || this.pattern.length === 0 || (this.tree.refilter(), this.render());
  }
  render() {
    const e = this.filter.totalCount > 0 && this.filter.matchCount === 0;
    this.pattern && e ? (Ia(f("replFindNoResults", "No results")), this.tree.options.showNotFoundMessage ?? !0 ? this.widget?.showMessage({ type: 2, content: f("not found", "No elements found.") }) : this.widget?.showMessage({
      type: 2
      /* MessageType.WARNING */
    })) : (this.widget?.clearMessage(), this.pattern && Ia(f("replFindResults", "{0} results", this.filter.matchCount)));
  }
  shouldAllowFocus(e) {
    return !this.widget || !this.pattern || this.filter.totalCount > 0 && this.filter.matchCount <= 1 ? !0 : !Tr.isDefault(e.filterData);
  }
  layout(e) {
    this.width = e, this.widget?.layout(e);
  }
  dispose() {
    this._history = void 0, this._onDidChangePattern.dispose(), this.enabledDisposables.dispose(), this.disposables.dispose();
  }
};
function _te(s, e) {
  return s.position === e.position && PW(s, e);
}
function PW(s, e) {
  return s.node.element === e.node.element && s.startIndex === e.startIndex && s.height === e.height && s.endIndex === e.endIndex;
}
class bte {
  constructor(e = []) {
    this.stickyNodes = e;
  }
  get count() {
    return this.stickyNodes.length;
  }
  equal(e) {
    return pi(this.stickyNodes, e.stickyNodes, _te);
  }
  lastNodePartiallyVisible() {
    if (this.count === 0)
      return !1;
    const e = this.stickyNodes[this.count - 1];
    if (this.count === 1)
      return e.position !== 0;
    const t = this.stickyNodes[this.count - 2];
    return t.position + t.height !== e.position;
  }
  animationStateChanged(e) {
    if (!pi(this.stickyNodes, e.stickyNodes, PW) || this.count === 0)
      return !1;
    const t = this.stickyNodes[this.count - 1], i = e.stickyNodes[e.count - 1];
    return t.position !== i.position;
  }
}
class wte {
  constrainStickyScrollNodes(e, t, i) {
    for (let n = 0; n < e.length; n++) {
      const o = e[n];
      if (o.position + o.height > i || n >= t)
        return e.slice(0, n);
    }
    return e;
  }
}
class KF extends V {
  constructor(e, t, i, n, o, r = {}) {
    super(), this.tree = e, this.model = t, this.view = i, this.treeDelegate = o, this.maxWidgetViewRatio = 0.4;
    const a = this.validateStickySettings(r);
    this.stickyScrollMaxItemCount = a.stickyScrollMaxItemCount, this.stickyScrollDelegate = r.stickyScrollDelegate ?? new wte(), this._widget = this._register(new Cte(i.getScrollableElement(), i, e, n, o, r.accessibilityProvider)), this.onDidChangeHasFocus = this._widget.onDidChangeHasFocus, this.onContextMenu = this._widget.onContextMenu, this._register(i.onDidScroll(() => this.update())), this._register(i.onDidChangeContentHeight(() => this.update())), this._register(e.onDidChangeCollapseState(() => this.update())), this.update();
  }
  get height() {
    return this._widget.height;
  }
  getNodeAtHeight(e) {
    let t;
    if (e === 0 ? t = this.view.firstVisibleIndex : t = this.view.indexAt(e + this.view.scrollTop), !(t < 0 || t >= this.view.length))
      return this.view.element(t);
  }
  update() {
    const e = this.getNodeAtHeight(0);
    if (!e || this.tree.scrollTop === 0) {
      this._widget.setState(void 0);
      return;
    }
    const t = this.findStickyState(e);
    this._widget.setState(t);
  }
  findStickyState(e) {
    const t = [];
    let i = e, n = 0, o = this.getNextStickyNode(i, void 0, n);
    for (; o && (t.push(o), n += o.height, !(t.length <= this.stickyScrollMaxItemCount && (i = this.getNextVisibleNode(o), !i))); )
      o = this.getNextStickyNode(i, o.node, n);
    const r = this.constrainStickyNodes(t);
    return r.length ? new bte(r) : void 0;
  }
  getNextVisibleNode(e) {
    return this.getNodeAtHeight(e.position + e.height);
  }
  getNextStickyNode(e, t, i) {
    const n = this.getAncestorUnderPrevious(e, t);
    if (n && !(n === e && (!this.nodeIsUncollapsedParent(e) || this.nodeTopAlignsWithStickyNodesBottom(e, i))))
      return this.createStickyScrollNode(n, i);
  }
  nodeTopAlignsWithStickyNodesBottom(e, t) {
    const i = this.getNodeIndex(e), n = this.view.getElementTop(i), o = t;
    return this.view.scrollTop === n - o;
  }
  createStickyScrollNode(e, t) {
    const i = this.treeDelegate.getHeight(e), { startIndex: n, endIndex: o } = this.getNodeRange(e), r = this.calculateStickyNodePosition(o, t, i);
    return { node: e, position: r, height: i, startIndex: n, endIndex: o };
  }
  getAncestorUnderPrevious(e, t = void 0) {
    let i = e, n = this.getParentNode(i);
    for (; n; ) {
      if (n === t)
        return i;
      i = n, n = this.getParentNode(i);
    }
    if (t === void 0)
      return i;
  }
  calculateStickyNodePosition(e, t, i) {
    let n = this.view.getRelativeTop(e);
    if (n === null && this.view.firstVisibleIndex === e && e + 1 < this.view.length) {
      const c = this.treeDelegate.getHeight(this.view.element(e)), d = this.view.getRelativeTop(e + 1);
      n = d ? d - c / this.view.renderHeight : null;
    }
    if (n === null)
      return t;
    const o = this.view.element(e), r = this.treeDelegate.getHeight(o), l = n * this.view.renderHeight + r;
    return t + i > l && t <= l ? l - i : t;
  }
  constrainStickyNodes(e) {
    if (e.length === 0)
      return [];
    const t = this.view.renderHeight * this.maxWidgetViewRatio, i = e[e.length - 1];
    if (e.length <= this.stickyScrollMaxItemCount && i.position + i.height <= t)
      return e;
    const n = this.stickyScrollDelegate.constrainStickyScrollNodes(e, this.stickyScrollMaxItemCount, t);
    if (!n.length)
      return [];
    const o = n[n.length - 1];
    if (n.length > this.stickyScrollMaxItemCount || o.position + o.height > t)
      throw new Error("stickyScrollDelegate violates constraints");
    return n;
  }
  getParentNode(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getParentNodeLocation(t);
    return i ? this.model.getNode(i) : void 0;
  }
  nodeIsUncollapsedParent(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListRenderCount(t) > 1;
  }
  getNodeIndex(e) {
    const t = this.model.getNodeLocation(e);
    return this.model.getListIndex(t);
  }
  getNodeRange(e) {
    const t = this.model.getNodeLocation(e), i = this.model.getListIndex(t);
    if (i < 0)
      throw new Error("Node not found in tree");
    const n = this.model.getListRenderCount(t), o = i + n - 1;
    return { startIndex: i, endIndex: o };
  }
  nodePositionTopBelowWidget(e) {
    const t = [];
    let i = this.getParentNode(e);
    for (; i; )
      t.push(i), i = this.getParentNode(i);
    let n = 0;
    for (let o = 0; o < t.length && o < this.stickyScrollMaxItemCount; o++)
      n += this.treeDelegate.getHeight(t[o]);
    return n;
  }
  domFocus() {
    this._widget.domFocus();
  }
  // Whether sticky scroll was the last focused part in the tree or not
  focusedLast() {
    return this._widget.focusedLast();
  }
  updateOptions(e = {}) {
    if (!e.stickyScrollMaxItemCount)
      return;
    const t = this.validateStickySettings(e);
    this.stickyScrollMaxItemCount !== t.stickyScrollMaxItemCount && (this.stickyScrollMaxItemCount = t.stickyScrollMaxItemCount, this.update());
  }
  validateStickySettings(e) {
    let t = 7;
    return typeof e.stickyScrollMaxItemCount == "number" && (t = Math.max(e.stickyScrollMaxItemCount, 1)), { stickyScrollMaxItemCount: t };
  }
}
class Cte {
  constructor(e, t, i, n, o, r) {
    this.view = t, this.tree = i, this.treeRenderers = n, this.treeDelegate = o, this.accessibilityProvider = r, this._previousElements = [], this._previousStateDisposables = new X(), this._rootDomNode = de(".monaco-tree-sticky-container.empty"), e.appendChild(this._rootDomNode);
    const a = de(".monaco-tree-sticky-container-shadow");
    this._rootDomNode.appendChild(a), this.stickyScrollFocus = new vte(this._rootDomNode, t), this.onDidChangeHasFocus = this.stickyScrollFocus.onDidChangeHasFocus, this.onContextMenu = this.stickyScrollFocus.onContextMenu;
  }
  get height() {
    if (!this._previousState)
      return 0;
    const e = this._previousState.stickyNodes[this._previousState.count - 1];
    return e.position + e.height;
  }
  setState(e) {
    const t = !!this._previousState && this._previousState.count > 0, i = !!e && e.count > 0;
    if (!t && !i || t && i && this._previousState.equal(e))
      return;
    if (t !== i && this.setVisible(i), !i) {
      this._previousState = void 0, this._previousElements = [], this._previousStateDisposables.clear();
      return;
    }
    const n = e.stickyNodes[e.count - 1];
    if (this._previousState && e.animationStateChanged(this._previousState))
      this._previousElements[this._previousState.count - 1].style.top = `${n.position}px`;
    else {
      this._previousStateDisposables.clear();
      const o = Array(e.count);
      for (let r = e.count - 1; r >= 0; r--) {
        const a = e.stickyNodes[r], { element: l, disposable: c } = this.createElement(a, r, e.count);
        o[r] = l, this._rootDomNode.appendChild(l), this._previousStateDisposables.add(c);
      }
      this.stickyScrollFocus.updateElements(o, e), this._previousElements = o;
    }
    this._previousState = e, this._rootDomNode.style.height = `${n.position + n.height}px`;
  }
  createElement(e, t, i) {
    const n = e.startIndex, o = document.createElement("div");
    o.style.top = `${e.position}px`, this.tree.options.setRowHeight !== !1 && (o.style.height = `${e.height}px`), this.tree.options.setRowLineHeight !== !1 && (o.style.lineHeight = `${e.height}px`), o.classList.add("monaco-tree-sticky-row"), o.classList.add("monaco-list-row"), o.setAttribute("data-index", `${n}`), o.setAttribute("data-parity", n % 2 === 0 ? "even" : "odd"), o.setAttribute("id", this.view.getElementID(n));
    const r = this.setAccessibilityAttributes(o, e.node.element, t, i), a = this.treeDelegate.getTemplateId(e.node), l = this.treeRenderers.find((u) => u.templateId === a);
    if (!l)
      throw new Error(`No renderer found for template id ${a}`);
    let c = e.node;
    c === this.tree.getNode(this.tree.getNodeLocation(e.node)) && (c = new Proxy(e.node, {}));
    const d = l.renderTemplate(o);
    l.renderElement(c, e.startIndex, d, e.height);
    const h = we(() => {
      r.dispose(), l.disposeElement(c, e.startIndex, d, e.height), l.disposeTemplate(d), o.remove();
    });
    return { element: o, disposable: h };
  }
  setAccessibilityAttributes(e, t, i, n) {
    if (!this.accessibilityProvider)
      return V.None;
    this.accessibilityProvider.getSetSize && e.setAttribute("aria-setsize", String(this.accessibilityProvider.getSetSize(t, i, n))), this.accessibilityProvider.getPosInSet && e.setAttribute("aria-posinset", String(this.accessibilityProvider.getPosInSet(t, i))), this.accessibilityProvider.getRole && e.setAttribute("role", this.accessibilityProvider.getRole(t) ?? "treeitem");
    const o = this.accessibilityProvider.getAriaLabel(t), r = o && typeof o != "string" ? o : RC(o), a = et((c) => {
      const d = c.readObservable(r);
      d ? e.setAttribute("aria-label", d) : e.removeAttribute("aria-label");
    });
    typeof o == "string" || o && e.setAttribute("aria-label", o.get());
    const l = this.accessibilityProvider.getAriaLevel && this.accessibilityProvider.getAriaLevel(t);
    return typeof l == "number" && e.setAttribute("aria-level", `${l}`), e.setAttribute("aria-selected", String(!1)), a;
  }
  setVisible(e) {
    this._rootDomNode.classList.toggle("empty", !e), e || this.stickyScrollFocus.updateElements([], void 0);
  }
  domFocus() {
    this.stickyScrollFocus.domFocus();
  }
  focusedLast() {
    return this.stickyScrollFocus.focusedLast();
  }
  dispose() {
    this.stickyScrollFocus.dispose(), this._previousStateDisposables.dispose(), this._rootDomNode.remove();
  }
}
class vte extends V {
  get domHasFocus() {
    return this._domHasFocus;
  }
  set domHasFocus(e) {
    e !== this._domHasFocus && (this._onDidChangeHasFocus.fire(e), this._domHasFocus = e);
  }
  constructor(e, t) {
    super(), this.container = e, this.view = t, this.focusedIndex = -1, this.elements = [], this._onDidChangeHasFocus = new B(), this.onDidChangeHasFocus = this._onDidChangeHasFocus.event, this._onContextMenu = new B(), this.onContextMenu = this._onContextMenu.event, this._domHasFocus = !1, this._register(U(this.container, "focus", () => this.onFocus())), this._register(U(this.container, "blur", () => this.onBlur())), this._register(this.view.onDidFocus(() => this.toggleStickyScrollFocused(!1))), this._register(this.view.onKeyDown((i) => this.onKeyDown(i))), this._register(this.view.onMouseDown((i) => this.onMouseDown(i))), this._register(this.view.onContextMenu((i) => this.handleContextMenu(i)));
  }
  handleContextMenu(e) {
    const t = e.browserEvent.target;
    if (!KA(t) && !Op(t)) {
      this.focusedLast() && this.view.domFocus();
      return;
    }
    if (!cl(e.browserEvent)) {
      if (!this.state)
        throw new Error("Context menu should not be triggered when state is undefined");
      const r = this.state.stickyNodes.findIndex((a) => a.node.element === e.element?.element);
      if (r === -1)
        throw new Error("Context menu should not be triggered when element is not in sticky scroll widget");
      this.container.focus(), this.setFocus(r);
      return;
    }
    if (!this.state || this.focusedIndex < 0)
      throw new Error("Context menu key should not be triggered when focus is not in sticky scroll widget");
    const n = this.state.stickyNodes[this.focusedIndex].node.element, o = this.elements[this.focusedIndex];
    this._onContextMenu.fire({ element: n, anchor: o, browserEvent: e.browserEvent, isStickyScroll: !0 });
  }
  onKeyDown(e) {
    if (this.domHasFocus && this.state) {
      if (e.key === "ArrowUp")
        this.setFocusedElement(Math.max(0, this.focusedIndex - 1)), e.preventDefault(), e.stopPropagation();
      else if (e.key === "ArrowDown" || e.key === "ArrowRight") {
        if (this.focusedIndex >= this.state.count - 1) {
          const t = this.state.stickyNodes[this.state.count - 1].startIndex + 1;
          this.view.domFocus(), this.view.setFocus([t]), this.scrollNodeUnderWidget(t, this.state);
        } else
          this.setFocusedElement(this.focusedIndex + 1);
        e.preventDefault(), e.stopPropagation();
      }
    }
  }
  onMouseDown(e) {
    const t = e.browserEvent.target;
    !KA(t) && !Op(t) || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation());
  }
  updateElements(e, t) {
    if (t && t.count === 0)
      throw new Error("Sticky scroll state must be undefined when there are no sticky nodes");
    if (t && t.count !== e.length)
      throw new Error("Sticky scroll focus received illigel state");
    const i = this.focusedIndex;
    if (this.removeFocus(), this.elements = e, this.state = t, t) {
      const n = kn(i, 0, t.count - 1);
      this.setFocus(n);
    } else
      this.domHasFocus && this.view.domFocus();
    this.container.tabIndex = t ? 0 : -1;
  }
  setFocusedElement(e) {
    const t = this.state;
    if (!t)
      throw new Error("Cannot set focus when state is undefined");
    if (this.setFocus(e), !(e < t.count - 1) && t.lastNodePartiallyVisible()) {
      const i = t.stickyNodes[e];
      this.scrollNodeUnderWidget(i.endIndex + 1, t);
    }
  }
  scrollNodeUnderWidget(e, t) {
    const i = t.stickyNodes[t.count - 1], n = t.count > 1 ? t.stickyNodes[t.count - 2] : void 0, o = this.view.getElementTop(e), r = n ? n.position + n.height + i.height : i.height;
    this.view.scrollTop = o - r;
  }
  domFocus() {
    if (!this.state)
      throw new Error("Cannot focus when state is undefined");
    this.container.focus();
  }
  focusedLast() {
    return this.state ? this.view.getHTMLElement().classList.contains("sticky-scroll-focused") : !1;
  }
  removeFocus() {
    this.focusedIndex !== -1 && (this.toggleElementFocus(this.elements[this.focusedIndex], !1), this.focusedIndex = -1);
  }
  setFocus(e) {
    if (0 > e)
      throw new Error("addFocus() can not remove focus");
    if (!this.state && e >= 0)
      throw new Error("Cannot set focus index when state is undefined");
    if (this.state && e >= this.state.count)
      throw new Error("Cannot set focus index to an index that does not exist");
    const t = this.focusedIndex;
    t >= 0 && this.toggleElementFocus(this.elements[t], !1), e >= 0 && this.toggleElementFocus(this.elements[e], !0), this.focusedIndex = e;
  }
  toggleElementFocus(e, t) {
    this.toggleElementActiveFocus(e, t && this.domHasFocus), this.toggleElementPassiveFocus(e, t);
  }
  toggleCurrentElementActiveFocus(e) {
    this.focusedIndex !== -1 && this.toggleElementActiveFocus(this.elements[this.focusedIndex], e);
  }
  toggleElementActiveFocus(e, t) {
    e.classList.toggle("focused", t);
  }
  toggleElementPassiveFocus(e, t) {
    e.classList.toggle("passive-focused", t);
  }
  toggleStickyScrollFocused(e) {
    this.view.getHTMLElement().classList.toggle("sticky-scroll-focused", e);
  }
  onFocus() {
    if (!this.state || this.elements.length === 0)
      throw new Error("Cannot focus when state is undefined or elements are empty");
    this.domHasFocus = !0, this.toggleStickyScrollFocused(!0), this.toggleCurrentElementActiveFocus(!0), this.focusedIndex === -1 && this.setFocus(0);
  }
  onBlur() {
    this.domHasFocus = !1, this.toggleCurrentElementActiveFocus(!1);
  }
  dispose() {
    this.toggleStickyScrollFocused(!1), this._onDidChangeHasFocus.fire(!1), super.dispose();
  }
}
function Ob(s) {
  let e = Sh.Unknown;
  return ny(s.browserEvent.target, "monaco-tl-twistie", "monaco-tl-row") ? e = Sh.Twistie : ny(s.browserEvent.target, "monaco-tl-contents", "monaco-tl-row") ? e = Sh.Element : ny(s.browserEvent.target, "monaco-tree-type-filter", "monaco-list") && (e = Sh.Filter), {
    browserEvent: s.browserEvent,
    element: s.element ? s.element.element : null,
    target: e
  };
}
function Ste(s) {
  const e = KA(s.browserEvent.target);
  return {
    element: s.element ? s.element.element : null,
    browserEvent: s.browserEvent,
    anchor: s.anchor,
    isStickyScroll: e
  };
}
function Iw(s, e) {
  e(s), s.children.forEach((t) => Iw(t, e));
}
class jy {
  get nodeSet() {
    return this._nodeSet || (this._nodeSet = this.createNodeSet()), this._nodeSet;
  }
  constructor(e, t) {
    this.getFirstViewElementWithTrait = e, this.identityProvider = t, this.nodes = [], this._onDidChange = new B(), this.onDidChange = this._onDidChange.event;
  }
  set(e, t) {
    !t?.__forceEvent && pi(this.nodes, e) || this._set(e, !1, t);
  }
  _set(e, t, i) {
    if (this.nodes = [...e], this.elements = void 0, this._nodeSet = void 0, !t) {
      const n = this;
      this._onDidChange.fire({ get elements() {
        return n.get();
      }, browserEvent: i });
    }
  }
  get() {
    return this.elements || (this.elements = this.nodes.map((e) => e.element)), [...this.elements];
  }
  getNodes() {
    return this.nodes;
  }
  has(e) {
    return this.nodeSet.has(e);
  }
  onDidModelSplice({ insertedNodes: e, deletedNodes: t }) {
    if (!this.identityProvider) {
      const l = this.createNodeSet(), c = (d) => l.delete(d);
      t.forEach((d) => Iw(d, c)), this.set([...l.values()]);
      return;
    }
    const i = /* @__PURE__ */ new Set(), n = (l) => i.add(this.identityProvider.getId(l.element).toString());
    t.forEach((l) => Iw(l, n));
    const o = /* @__PURE__ */ new Map(), r = (l) => o.set(this.identityProvider.getId(l.element).toString(), l);
    e.forEach((l) => Iw(l, r));
    const a = [];
    for (const l of this.nodes) {
      const c = this.identityProvider.getId(l.element).toString();
      if (!i.has(c))
        a.push(l);
      else {
        const h = o.get(c);
        h && h.visible && a.push(h);
      }
    }
    if (this.nodes.length > 0 && a.length === 0) {
      const l = this.getFirstViewElementWithTrait();
      l && a.push(l);
    }
    this._set(a, !0);
  }
  createNodeSet() {
    const e = /* @__PURE__ */ new Set();
    for (const t of this.nodes)
      e.add(t);
    return e;
  }
}
class yte extends Q3 {
  constructor(e, t, i) {
    super(e), this.tree = t, this.stickyScrollProvider = i;
  }
  onViewPointer(e) {
    if (W3(e.browserEvent.target) || Vc(e.browserEvent.target) || pp(e.browserEvent.target) || e.browserEvent.isHandledByList)
      return;
    const t = e.element;
    if (!t)
      return super.onViewPointer(e);
    if (this.isSelectionRangeChangeEvent(e) || this.isSelectionSingleChangeEvent(e))
      return super.onViewPointer(e);
    const i = e.browserEvent.target, n = i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && e.browserEvent.offsetX < 16, o = Op(e.browserEvent.target);
    let r = !1;
    if (o ? r = !0 : typeof this.tree.expandOnlyOnTwistieClick == "function" ? r = this.tree.expandOnlyOnTwistieClick(t.element) : r = !!this.tree.expandOnlyOnTwistieClick, o)
      this.handleStickyScrollMouseEvent(e, t);
    else {
      if (r && !n && e.browserEvent.detail !== 2)
        return super.onViewPointer(e);
      if (!this.tree.expandOnDoubleClick && e.browserEvent.detail === 2)
        return super.onViewPointer(e);
    }
    if (t.collapsible && (!o || n)) {
      const a = this.tree.getNodeLocation(t), l = e.browserEvent.altKey;
      if (this.tree.setFocus([a]), this.tree.toggleCollapsed(a, l), n) {
        e.browserEvent.isHandledByList = !0;
        return;
      }
    }
    o || super.onViewPointer(e);
  }
  handleStickyScrollMouseEvent(e, t) {
    if (L$(e.browserEvent.target) || k$(e.browserEvent.target))
      return;
    const i = this.stickyScrollProvider();
    if (!i)
      throw new Error("Sticky scroll controller not found");
    const n = this.list.indexOf(t), o = this.list.getElementTop(n), r = i.nodePositionTopBelowWidget(t);
    this.tree.scrollTop = o - r, this.list.domFocus(), this.list.setFocus([n]), this.list.setSelection([n]);
  }
  onDoubleClick(e) {
    e.browserEvent.target.classList.contains("monaco-tl-twistie") || !this.tree.expandOnDoubleClick || e.browserEvent.isHandledByList || super.onDoubleClick(e);
  }
  // to make sure dom focus is not stolen (for example with context menu)
  onMouseDown(e) {
    const t = e.browserEvent.target;
    if (!KA(t) && !Op(t)) {
      super.onMouseDown(e);
      return;
    }
  }
  onContextMenu(e) {
    const t = e.browserEvent.target;
    if (!KA(t) && !Op(t)) {
      super.onContextMenu(e);
      return;
    }
  }
}
class xte extends ko {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, t, i, n, l), this.focusTrait = o, this.selectionTrait = r, this.anchorTrait = a;
  }
  createMouseController(e) {
    return new yte(this, e.tree, e.stickyScrollProvider);
  }
  splice(e, t, i = []) {
    if (super.splice(e, t, i), i.length === 0)
      return;
    const n = [], o = [];
    let r;
    i.forEach((a, l) => {
      this.focusTrait.has(a) && n.push(e + l), this.selectionTrait.has(a) && o.push(e + l), this.anchorTrait.has(a) && (r = e + l);
    }), n.length > 0 && super.setFocus(du([...super.getFocus(), ...n])), o.length > 0 && super.setSelection(du([...super.getSelection(), ...o])), typeof r == "number" && super.setAnchor(r);
  }
  setFocus(e, t, i = !1) {
    super.setFocus(e, t), i || this.focusTrait.set(e.map((n) => this.element(n)), t);
  }
  setSelection(e, t, i = !1) {
    super.setSelection(e, t), i || this.selectionTrait.set(e.map((n) => this.element(n)), t);
  }
  setAnchor(e, t = !1) {
    super.setAnchor(e), t || (typeof e > "u" ? this.anchorTrait.set([]) : this.anchorTrait.set([this.element(e)]));
  }
}
class HW {
  get onDidScroll() {
    return this.view.onDidScroll;
  }
  get onDidChangeFocus() {
    return this.eventBufferer.wrapEvent(this.focus.onDidChange);
  }
  get onDidChangeSelection() {
    return this.eventBufferer.wrapEvent(this.selection.onDidChange);
  }
  get onMouseDblClick() {
    return te.filter(te.map(this.view.onMouseDblClick, Ob), (e) => e.target !== Sh.Filter);
  }
  get onMouseOver() {
    return te.map(this.view.onMouseOver, Ob);
  }
  get onMouseOut() {
    return te.map(this.view.onMouseOut, Ob);
  }
  get onContextMenu() {
    return te.any(te.filter(te.map(this.view.onContextMenu, Ste), (e) => !e.isStickyScroll), this.stickyScrollController?.onContextMenu ?? te.None);
  }
  get onPointer() {
    return te.map(this.view.onPointer, Ob);
  }
  get onKeyDown() {
    return this.view.onKeyDown;
  }
  get onDidFocus() {
    return this.view.onDidFocus;
  }
  get onDidChangeModel() {
    return te.signal(this.model.onDidSplice);
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get findMode() {
    return this.findController?.mode ?? Sl.Highlight;
  }
  set findMode(e) {
    this.findController && (this.findController.mode = e);
  }
  get findMatchType() {
    return this.findController?.matchType ?? yu.Fuzzy;
  }
  set findMatchType(e) {
    this.findController && (this.findController.matchType = e);
  }
  get expandOnDoubleClick() {
    return typeof this._options.expandOnDoubleClick > "u" ? !0 : this._options.expandOnDoubleClick;
  }
  get expandOnlyOnTwistieClick() {
    return typeof this._options.expandOnlyOnTwistieClick > "u" ? !0 : this._options.expandOnlyOnTwistieClick;
  }
  get onDidDispose() {
    return this.view.onDidDispose;
  }
  constructor(e, t, i, n, o = {}) {
    this._user = e, this._options = o, this.eventBufferer = new k_(), this.onDidChangeFindOpenState = te.None, this.onDidChangeStickyScrollFocused = te.None, this.disposables = new X(), this._onWillRefilter = new B(), this.onWillRefilter = this._onWillRefilter.event, this._onDidUpdateOptions = new B(), this.treeDelegate = new lT(i);
    const r = new QB(), a = new QB(), l = this.disposables.add(new mte(a.event)), c = new _5();
    this.renderers = n.map((m) => new Mk(m, () => this.model, r.event, l, c, o));
    for (const m of this.renderers)
      this.disposables.add(m);
    let d;
    o.keyboardNavigationLabelProvider && (d = new pte(this, o.keyboardNavigationLabelProvider, o.filter), o = { ...o, filter: d }, this.disposables.add(d)), this.focus = new jy(() => this.view.getFocusedElements()[0], o.identityProvider), this.selection = new jy(() => this.view.getSelectedElements()[0], o.identityProvider), this.anchor = new jy(() => this.view.getAnchorElement(), o.identityProvider), this.view = new xte(e, t, this.treeDelegate, this.renderers, this.focus, this.selection, this.anchor, { ...fte(() => this.model, o), tree: this, stickyScrollProvider: () => this.stickyScrollController }), this.model = this.createModel(e, this.view, o), r.input = this.model.onDidChangeCollapseState;
    const h = te.forEach(this.model.onDidSplice, (m) => {
      this.eventBufferer.bufferEvents(() => {
        this.focus.onDidModelSplice(m), this.selection.onDidModelSplice(m);
      });
    }, this.disposables);
    h(() => null, null, this.disposables);
    const u = this.disposables.add(new B()), g = this.disposables.add(new Gl(0));
    if (this.disposables.add(te.any(h, this.focus.onDidChange, this.selection.onDidChange)(() => {
      g.trigger(() => {
        const m = /* @__PURE__ */ new Set();
        for (const p of this.focus.getNodes())
          m.add(p);
        for (const p of this.selection.getNodes())
          m.add(p);
        u.fire([...m.values()]);
      });
    })), a.input = u.event, o.keyboardSupport !== !1) {
      const m = te.chain(this.view.onKeyDown, (p) => p.filter((A) => !Vc(A.target)).map((A) => new Mt(A)));
      te.chain(m, (p) => p.filter(
        (A) => A.keyCode === 15
        /* KeyCode.LeftArrow */
      ))(this.onLeftArrow, this, this.disposables), te.chain(m, (p) => p.filter(
        (A) => A.keyCode === 17
        /* KeyCode.RightArrow */
      ))(this.onRightArrow, this, this.disposables), te.chain(m, (p) => p.filter(
        (A) => A.keyCode === 10
        /* KeyCode.Space */
      ))(this.onSpace, this, this.disposables);
    }
    if ((o.findWidgetEnabled ?? !0) && o.keyboardNavigationLabelProvider && o.contextViewProvider) {
      const m = this.options.findWidgetStyles ? { styles: this.options.findWidgetStyles } : void 0;
      this.findController = new Ate(this, this.model, this.view, d, o.contextViewProvider, m), this.focusNavigationFilter = (p) => this.findController.shouldAllowFocus(p), this.onDidChangeFindOpenState = this.findController.onDidChangeOpenState, this.disposables.add(this.findController), this.onDidChangeFindMode = this.findController.onDidChangeMode, this.onDidChangeFindMatchType = this.findController.onDidChangeMatchType;
    } else
      this.onDidChangeFindMode = te.None, this.onDidChangeFindMatchType = te.None;
    o.enableStickyScroll && (this.stickyScrollController = new KF(this, this.model, this.view, this.renderers, this.treeDelegate, o), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus), this.styleElement = xo(this.view.getHTMLElement()), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === om.Always);
  }
  updateOptions(e = {}) {
    this._options = { ...this._options, ...e };
    for (const t of this.renderers)
      t.updateOptions(e);
    this.view.updateOptions(this._options), this.findController?.updateOptions(e), this.updateStickyScroll(e), this._onDidUpdateOptions.fire(this._options), this.getHTMLElement().classList.toggle("always", this._options.renderIndentGuides === om.Always);
  }
  get options() {
    return this._options;
  }
  updateStickyScroll(e) {
    !this.stickyScrollController && this._options.enableStickyScroll ? (this.stickyScrollController = new KF(this, this.model, this.view, this.renderers, this.treeDelegate, this._options), this.onDidChangeStickyScrollFocused = this.stickyScrollController.onDidChangeHasFocus) : this.stickyScrollController && !this._options.enableStickyScroll && (this.onDidChangeStickyScrollFocused = te.None, this.stickyScrollController.dispose(), this.stickyScrollController = void 0), this.stickyScrollController?.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.view.getHTMLElement();
  }
  get scrollTop() {
    return this.view.scrollTop;
  }
  set scrollTop(e) {
    this.view.scrollTop = e;
  }
  get scrollHeight() {
    return this.view.scrollHeight;
  }
  get renderHeight() {
    return this.view.renderHeight;
  }
  get ariaLabel() {
    return this.view.ariaLabel;
  }
  set ariaLabel(e) {
    this.view.ariaLabel = e;
  }
  domFocus() {
    this.stickyScrollController?.focusedLast() ? this.stickyScrollController.domFocus() : this.view.domFocus();
  }
  layout(e, t) {
    this.view.layout(e, t), id(t) && this.findController?.layout(t);
  }
  style(e) {
    const t = `.${this.view.domId}`, i = [];
    e.treeIndentGuidesStroke && (i.push(`.monaco-list${t}:hover .monaco-tl-indent > .indent-guide, .monaco-list${t}.always .monaco-tl-indent > .indent-guide  { border-color: ${e.treeInactiveIndentGuidesStroke}; }`), i.push(`.monaco-list${t} .monaco-tl-indent > .indent-guide.active { border-color: ${e.treeIndentGuidesStroke}; }`));
    const n = e.treeStickyScrollBackground ?? e.listBackground;
    n && (i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { background-color: ${n}; }`), i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row { background-color: ${n}; }`)), e.treeStickyScrollBorder && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container { border-bottom: 1px solid ${e.treeStickyScrollBorder}; }`), e.treeStickyScrollShadow && i.push(`.monaco-list${t} .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow { box-shadow: ${e.treeStickyScrollShadow} 0 6px 6px -6px inset; height: 3px; }`), e.listFocusForeground && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { color: ${e.listFocusForeground}; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { color: inherit; }`));
    const o = Tl(e.listFocusAndSelectionOutline, Tl(e.listSelectionOutline, e.listFocusOutline ?? ""));
    o && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused.selected { outline: 1px solid ${o}; outline-offset: -1px;}`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused.selected { outline: inherit;}`)), e.listFocusOutline && (i.push(`.monaco-list${t}.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container:focus .monaco-list-row.focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-list${t}:not(.sticky-scroll-focused) .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-scrollable-element .monaco-tree-sticky-container .monaco-list-row.passive-focused { outline: 1px solid ${e.listFocusOutline}; outline-offset: -1px; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused.sticky-scroll-focused .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`), i.push(`.monaco-workbench.context-menu-visible .monaco-list${t}.last-focused:not(.sticky-scroll-focused) .monaco-tree-sticky-container .monaco-list-rows .monaco-list-row.focused { outline: inherit; }`)), this.styleElement.textContent = i.join(`
`), this.view.style(e);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.model.getParentNodeLocation(e);
    return this.model.getNode(t).element;
  }
  getFirstElementChild(e) {
    return this.model.getFirstElementChild(e);
  }
  // Tree
  getNode(e) {
    return this.model.getNode(e);
  }
  getNodeLocation(e) {
    return this.model.getNodeLocation(e);
  }
  collapse(e, t = !1) {
    return this.model.setCollapsed(e, !0, t);
  }
  expand(e, t = !1) {
    return this.model.setCollapsed(e, !1, t);
  }
  toggleCollapsed(e, t = !1) {
    return this.model.setCollapsed(e, void 0, t);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  refilter() {
    this._onWillRefilter.fire(void 0), this.model.refilter();
  }
  setSelection(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.selection.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setSelection(n, t, !0);
    });
  }
  getSelection() {
    return this.selection.get();
  }
  setFocus(e, t) {
    this.eventBufferer.bufferEvents(() => {
      const i = e.map((o) => this.model.getNode(o));
      this.focus.set(i, t);
      const n = e.map((o) => this.model.getListIndex(o)).filter((o) => o > -1);
      this.view.setFocus(n, t, !0);
    });
  }
  focusNext(e = 1, t = !1, i, n = cl(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusNext(e, t, i, n);
  }
  focusPrevious(e = 1, t = !1, i, n = cl(i) && i.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusPrevious(e, t, i, n);
  }
  focusNextPage(e, t = cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusNextPage(e, t);
  }
  focusPreviousPage(e, t = cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    return this.view.focusPreviousPage(e, t, () => this.stickyScrollController?.height ?? 0);
  }
  focusLast(e, t = cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusLast(e, t);
  }
  focusFirst(e, t = cl(e) && e.altKey ? void 0 : this.focusNavigationFilter) {
    this.view.focusFirst(e, t);
  }
  getFocus() {
    return this.focus.get();
  }
  reveal(e, t) {
    this.model.expandTo(e);
    const i = this.model.getListIndex(e);
    if (i !== -1)
      if (!this.stickyScrollController)
        this.view.reveal(i, t);
      else {
        const n = this.stickyScrollController.nodePositionTopBelowWidget(this.getNode(e));
        this.view.reveal(i, t, n);
      }
  }
  // List
  onLeftArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !0)) {
      const r = this.model.getParentNodeLocation(n);
      if (!r)
        return;
      const a = this.model.getListIndex(r);
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onRightArrow(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i);
    if (!this.model.setCollapsed(n, !1)) {
      if (!i.children.some((l) => l.visible))
        return;
      const [r] = this.view.getFocus(), a = r + 1;
      this.view.reveal(a), this.view.setFocus([a]);
    }
  }
  onSpace(e) {
    e.preventDefault(), e.stopPropagation();
    const t = this.view.getFocusedElements();
    if (t.length === 0)
      return;
    const i = t[0], n = this.model.getNodeLocation(i), o = e.browserEvent.altKey;
    this.model.setCollapsed(n, void 0, o);
  }
  dispose() {
    Ct(this.disposables), this.stickyScrollController?.dispose(), this.view.dispose();
  }
}
class cT {
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.nodesByIdentity = /* @__PURE__ */ new Map(), this.model = new hte(e, t, null, i), this.onDidSplice = this.model.onDidSplice, this.onDidChangeCollapseState = this.model.onDidChangeCollapseState, this.onDidChangeRenderNodeCount = this.model.onDidChangeRenderNodeCount, i.sorter && (this.sorter = {
      compare(n, o) {
        return i.sorter.compare(n.element, o.element);
      }
    }), this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = nt.empty(), i = {}) {
    const n = this.getElementLocation(e);
    this._setChildren(n, this.preserveCollapseState(t), i);
  }
  _setChildren(e, t = nt.empty(), i) {
    const n = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set(), r = (l) => {
      if (l.element === null)
        return;
      const c = l;
      if (n.add(c.element), this.nodes.set(c.element, c), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.add(d), this.nodesByIdentity.set(d, c);
      }
      i.onDidCreateNode?.(c);
    }, a = (l) => {
      if (l.element === null)
        return;
      const c = l;
      if (n.has(c.element) || this.nodes.delete(c.element), this.identityProvider) {
        const d = this.identityProvider.getId(c.element).toString();
        o.has(d) || this.nodesByIdentity.delete(d);
      }
      i.onDidDeleteNode?.(c);
    };
    this.model.splice([...e, 0], Number.MAX_VALUE, t, { ...i, onDidCreateNode: r, onDidDeleteNode: a });
  }
  preserveCollapseState(e = nt.empty()) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), nt.map(e, (t) => {
      let i = this.nodes.get(t.element);
      if (!i && this.identityProvider) {
        const r = this.identityProvider.getId(t.element).toString();
        i = this.nodesByIdentity.get(r);
      }
      if (!i) {
        let r;
        return typeof t.collapsed > "u" ? r = void 0 : t.collapsed === Fs.Collapsed || t.collapsed === Fs.PreserveOrCollapsed ? r = !0 : t.collapsed === Fs.Expanded || t.collapsed === Fs.PreserveOrExpanded ? r = !1 : r = !!t.collapsed, {
          ...t,
          children: this.preserveCollapseState(t.children),
          collapsed: r
        };
      }
      const n = typeof t.collapsible == "boolean" ? t.collapsible : i.collapsible;
      let o;
      return typeof t.collapsed > "u" || t.collapsed === Fs.PreserveOrCollapsed || t.collapsed === Fs.PreserveOrExpanded ? o = i.collapsed : t.collapsed === Fs.Collapsed ? o = !0 : t.collapsed === Fs.Expanded ? o = !1 : o = !!t.collapsed, {
        ...t,
        collapsible: n,
        collapsed: o,
        children: this.preserveCollapseState(t.children)
      };
    });
  }
  rerender(e) {
    const t = this.getElementLocation(e);
    this.model.rerender(t);
  }
  getFirstElementChild(e = null) {
    const t = this.getElementLocation(e);
    return this.model.getFirstElementChild(t);
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getElementLocation(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getElementLocation(e);
    return this.model.getListRenderCount(t);
  }
  isCollapsible(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getElementLocation(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getElementLocation(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getElementLocation(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getElementLocation(e);
    this.model.expandTo(t);
  }
  refilter() {
    this.model.refilter();
  }
  getNode(e = null) {
    if (e === null)
      return this.model.getNode(this.model.rootRef);
    const t = this.nodes.get(e);
    if (!t)
      throw new Vs(this.user, `Tree element not found: ${e}`);
    return t;
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    if (e === null)
      throw new Vs(this.user, "Invalid getParentNodeLocation call");
    const t = this.nodes.get(e);
    if (!t)
      throw new Vs(this.user, `Tree element not found: ${e}`);
    const i = this.model.getNodeLocation(t), n = this.model.getParentNodeLocation(i);
    return this.model.getNode(n).element;
  }
  getElementLocation(e) {
    if (e === null)
      return [];
    const t = this.nodes.get(e);
    if (!t)
      throw new Vs(this.user, `Tree element not found: ${e}`);
    return this.model.getNodeLocation(t);
  }
}
function Mw(s) {
  const e = [s.element], t = s.incompressible || !1;
  return {
    element: { elements: e, incompressible: t },
    children: nt.map(nt.from(s.children), Mw),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function Nw(s) {
  const e = [s.element], t = s.incompressible || !1;
  let i, n;
  for (; [n, i] = nt.consume(nt.from(s.children), 2), !(n.length !== 1 || n[0].incompressible); )
    s = n[0], e.push(s.element);
  return {
    element: { elements: e, incompressible: t },
    children: nt.map(nt.concat(n, i), Nw),
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function Nk(s, e = 0) {
  let t;
  return e < s.element.elements.length - 1 ? t = [Nk(s, e + 1)] : t = nt.map(nt.from(s.children), (i) => Nk(i, 0)), e === 0 && s.element.incompressible ? {
    element: s.element.elements[e],
    children: t,
    incompressible: !0,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  } : {
    element: s.element.elements[e],
    children: t,
    collapsible: s.collapsible,
    collapsed: s.collapsed
  };
}
function JF(s) {
  return Nk(s, 0);
}
function WW(s, e, t) {
  return s.element === e ? { ...s, children: t } : { ...s, children: nt.map(nt.from(s.children), (i) => WW(i, e, t)) };
}
const Ete = (s) => ({
  getId(e) {
    return e.elements.map((t) => s.getId(t).toString()).join("\0");
  }
});
class Lte {
  get onDidSplice() {
    return this.model.onDidSplice;
  }
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  get onDidChangeRenderNodeCount() {
    return this.model.onDidChangeRenderNodeCount;
  }
  constructor(e, t, i = {}) {
    this.user = e, this.rootRef = null, this.nodes = /* @__PURE__ */ new Map(), this.model = new cT(e, t, i), this.enabled = typeof i.compressionEnabled > "u" ? !0 : i.compressionEnabled, this.identityProvider = i.identityProvider;
  }
  setChildren(e, t = nt.empty(), i) {
    const n = i.diffIdentityProvider && Ete(i.diffIdentityProvider);
    if (e === null) {
      const m = nt.map(t, this.enabled ? Nw : Mw);
      this._setChildren(null, m, { diffIdentityProvider: n, diffDepth: 1 / 0 });
      return;
    }
    const o = this.nodes.get(e);
    if (!o)
      throw new Vs(this.user, "Unknown compressed tree node");
    const r = this.model.getNode(o), a = this.model.getParentNodeLocation(o), l = this.model.getNode(a), c = JF(r), d = WW(c, e, t), h = (this.enabled ? Nw : Mw)(d), u = i.diffIdentityProvider ? (m, p) => i.diffIdentityProvider.getId(m) === i.diffIdentityProvider.getId(p) : void 0;
    if (pi(h.element.elements, r.element.elements, u)) {
      this._setChildren(o, h.children || nt.empty(), { diffIdentityProvider: n, diffDepth: 1 });
      return;
    }
    const g = l.children.map((m) => m === r ? h : m);
    this._setChildren(l.element, g, {
      diffIdentityProvider: n,
      diffDepth: r.depth - l.depth
    });
  }
  isCompressionEnabled() {
    return this.enabled;
  }
  setCompressionEnabled(e) {
    if (e === this.enabled)
      return;
    this.enabled = e;
    const i = this.model.getNode().children, n = nt.map(i, JF), o = nt.map(n, e ? Nw : Mw);
    this._setChildren(null, o, {
      diffIdentityProvider: this.identityProvider,
      diffDepth: 1 / 0
    });
  }
  _setChildren(e, t, i) {
    const n = /* @__PURE__ */ new Set(), o = (a) => {
      for (const l of a.element.elements)
        n.add(l), this.nodes.set(l, a.element);
    }, r = (a) => {
      for (const l of a.element.elements)
        n.has(l) || this.nodes.delete(l);
    };
    this.model.setChildren(e, t, { ...i, onDidCreateNode: o, onDidDeleteNode: r });
  }
  has(e) {
    return this.nodes.has(e);
  }
  getListIndex(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListIndex(t);
  }
  getListRenderCount(e) {
    const t = this.getCompressedNode(e);
    return this.model.getListRenderCount(t);
  }
  getNode(e) {
    if (typeof e > "u")
      return this.model.getNode();
    const t = this.getCompressedNode(e);
    return this.model.getNode(t);
  }
  // TODO: review this
  getNodeLocation(e) {
    const t = this.model.getNodeLocation(e);
    return t === null ? null : t.elements[t.elements.length - 1];
  }
  // TODO: review this
  getParentNodeLocation(e) {
    const t = this.getCompressedNode(e), i = this.model.getParentNodeLocation(t);
    return i === null ? null : i.elements[i.elements.length - 1];
  }
  getFirstElementChild(e) {
    const t = this.getCompressedNode(e);
    return this.model.getFirstElementChild(t);
  }
  isCollapsible(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsible(t);
  }
  setCollapsible(e, t) {
    const i = this.getCompressedNode(e);
    return this.model.setCollapsible(i, t);
  }
  isCollapsed(e) {
    const t = this.getCompressedNode(e);
    return this.model.isCollapsed(t);
  }
  setCollapsed(e, t, i) {
    const n = this.getCompressedNode(e);
    return this.model.setCollapsed(n, t, i);
  }
  expandTo(e) {
    const t = this.getCompressedNode(e);
    this.model.expandTo(t);
  }
  rerender(e) {
    const t = this.getCompressedNode(e);
    this.model.rerender(t);
  }
  refilter() {
    this.model.refilter();
  }
  getCompressedNode(e) {
    if (e === null)
      return null;
    const t = this.nodes.get(e);
    if (!t)
      throw new Vs(this.user, `Tree element not found: ${e}`);
    return t;
  }
}
const kte = (s) => s[s.length - 1];
class dT {
  get element() {
    return this.node.element === null ? null : this.unwrapper(this.node.element);
  }
  get children() {
    return this.node.children.map((e) => new dT(this.unwrapper, e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e, t) {
    this.unwrapper = e, this.node = t;
  }
}
function Dte(s, e) {
  return {
    splice(t, i, n) {
      e.splice(t, i, n.map((o) => s.map(o)));
    },
    updateElementHeight(t, i) {
      e.updateElementHeight(t, i);
    }
  };
}
function Ite(s, e) {
  return {
    ...e,
    identityProvider: e.identityProvider && {
      getId(t) {
        return e.identityProvider.getId(s(t));
      }
    },
    sorter: e.sorter && {
      compare(t, i) {
        return e.sorter.compare(t.elements[0], i.elements[0]);
      }
    },
    filter: e.filter && {
      filter(t, i) {
        return e.filter.filter(s(t), i);
      }
    }
  };
}
class Mte {
  get onDidSplice() {
    return te.map(this.model.onDidSplice, ({ insertedNodes: e, deletedNodes: t }) => ({
      insertedNodes: e.map((i) => this.nodeMapper.map(i)),
      deletedNodes: t.map((i) => this.nodeMapper.map(i))
    }));
  }
  get onDidChangeCollapseState() {
    return te.map(this.model.onDidChangeCollapseState, ({ node: e, deep: t }) => ({
      node: this.nodeMapper.map(e),
      deep: t
    }));
  }
  get onDidChangeRenderNodeCount() {
    return te.map(this.model.onDidChangeRenderNodeCount, (e) => this.nodeMapper.map(e));
  }
  constructor(e, t, i = {}) {
    this.rootRef = null, this.elementMapper = i.elementMapper || kte;
    const n = (o) => this.elementMapper(o.elements);
    this.nodeMapper = new rT((o) => new dT(n, o)), this.model = new Lte(e, Dte(this.nodeMapper, t), Ite(n, i));
  }
  setChildren(e, t = nt.empty(), i = {}) {
    this.model.setChildren(e, t, i);
  }
  isCompressionEnabled() {
    return this.model.isCompressionEnabled();
  }
  setCompressionEnabled(e) {
    this.model.setCompressionEnabled(e);
  }
  has(e) {
    return this.model.has(e);
  }
  getListIndex(e) {
    return this.model.getListIndex(e);
  }
  getListRenderCount(e) {
    return this.model.getListRenderCount(e);
  }
  getNode(e) {
    return this.nodeMapper.map(this.model.getNode(e));
  }
  getNodeLocation(e) {
    return e.element;
  }
  getParentNodeLocation(e) {
    return this.model.getParentNodeLocation(e);
  }
  getFirstElementChild(e) {
    const t = this.model.getFirstElementChild(e);
    return t === null || typeof t > "u" ? t : this.elementMapper(t.elements);
  }
  isCollapsible(e) {
    return this.model.isCollapsible(e);
  }
  setCollapsible(e, t) {
    return this.model.setCollapsible(e, t);
  }
  isCollapsed(e) {
    return this.model.isCollapsed(e);
  }
  setCollapsed(e, t, i) {
    return this.model.setCollapsed(e, t, i);
  }
  expandTo(e) {
    return this.model.expandTo(e);
  }
  rerender(e) {
    return this.model.rerender(e);
  }
  refilter() {
    return this.model.refilter();
  }
  getCompressedTreeNode(e = null) {
    return this.model.getNode(e);
  }
}
var Nte = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
};
class hT extends HW {
  get onDidChangeCollapseState() {
    return this.model.onDidChangeCollapseState;
  }
  constructor(e, t, i, n, o = {}) {
    super(e, t, i, n, o), this.user = e;
  }
  setChildren(e, t = nt.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  rerender(e) {
    if (e === void 0) {
      this.view.rerender();
      return;
    }
    this.model.rerender(e);
  }
  hasElement(e) {
    return this.model.has(e);
  }
  createModel(e, t, i) {
    return new cT(e, t, i);
  }
}
class VW {
  get compressedTreeNodeProvider() {
    return this._compressedTreeNodeProvider();
  }
  constructor(e, t, i) {
    this._compressedTreeNodeProvider = e, this.stickyScrollDelegate = t, this.renderer = i, this.templateId = i.templateId, i.onDidChangeTwistieState && (this.onDidChangeTwistieState = i.onDidChangeTwistieState);
  }
  renderTemplate(e) {
    return { compressedTreeNode: void 0, data: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    let o = this.stickyScrollDelegate.getCompressedNode(e);
    o || (o = this.compressedTreeNodeProvider.getCompressedTreeNode(e.element)), o.element.elements.length === 1 ? (i.compressedTreeNode = void 0, this.renderer.renderElement(e, t, i.data, n)) : (i.compressedTreeNode = o, this.renderer.renderCompressedElements(o, t, i.data, n));
  }
  disposeElement(e, t, i, n) {
    i.compressedTreeNode ? this.renderer.disposeCompressedElements?.(i.compressedTreeNode, t, i.data, n) : this.renderer.disposeElement?.(e, t, i.data, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.data);
  }
  renderTwistie(e, t) {
    return this.renderer.renderTwistie ? this.renderer.renderTwistie(e, t) : !1;
  }
}
Nte([
  oi
], VW.prototype, "compressedTreeNodeProvider", null);
class Tte {
  constructor(e) {
    this.modelProvider = e, this.compressedStickyNodes = /* @__PURE__ */ new Map();
  }
  getCompressedNode(e) {
    return this.compressedStickyNodes.get(e);
  }
  constrainStickyScrollNodes(e, t, i) {
    if (this.compressedStickyNodes.clear(), e.length === 0)
      return [];
    for (let n = 0; n < e.length; n++) {
      const o = e[n], r = o.position + o.height;
      if (n + 1 < e.length && r + e[n + 1].height > i || n >= t - 1 && t < e.length) {
        const l = e.slice(0, n), c = e.slice(n), d = this.compressStickyNodes(c);
        return [...l, d];
      }
    }
    return e;
  }
  compressStickyNodes(e) {
    if (e.length === 0)
      throw new Error("Can't compress empty sticky nodes");
    const t = this.modelProvider();
    if (!t.isCompressionEnabled())
      return e[0];
    const i = [];
    for (let c = 0; c < e.length; c++) {
      const d = e[c], h = t.getCompressedTreeNode(d.node.element);
      if (h.element) {
        if (c !== 0 && h.element.incompressible)
          break;
        i.push(...h.element.elements);
      }
    }
    if (i.length < 2)
      return e[0];
    const n = e[e.length - 1], o = { elements: i, incompressible: !1 }, r = { ...n.node, children: [], element: o }, a = new Proxy(e[0].node, {}), l = {
      node: a,
      startIndex: e[0].startIndex,
      endIndex: n.endIndex,
      position: e[0].position,
      height: e[0].height
    };
    return this.compressedStickyNodes.set(a, r), l;
  }
}
function Bte(s, e) {
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      getKeyboardNavigationLabel(t) {
        let i;
        try {
          i = s().getCompressedTreeNode(t);
        } catch {
          return e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t);
        }
        return i.element.elements.length === 1 ? e.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(t) : e.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(i.element.elements);
      }
    }
  };
}
class zW extends hT {
  constructor(e, t, i, n, o = {}) {
    const r = () => this, a = new Tte(() => this.model), l = n.map((c) => new VW(r, a, c));
    super(e, t, i, l, { ...Bte(r, o), stickyScrollDelegate: a });
  }
  setChildren(e, t = nt.empty(), i) {
    this.model.setChildren(e, t, i);
  }
  createModel(e, t, i) {
    return new Mte(e, t, i);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), typeof e.compressionEnabled < "u" && this.model.setCompressionEnabled(e.compressionEnabled);
  }
  getCompressedTreeNode(e = null) {
    return this.model.getCompressedTreeNode(e);
  }
}
function Yy(s) {
  return {
    ...s,
    children: [],
    refreshPromise: void 0,
    stale: !0,
    slow: !1,
    forceExpanded: !1
  };
}
function Tk(s, e) {
  return e.parent ? e.parent === s ? !0 : Tk(s, e.parent) : !1;
}
function Rte(s, e) {
  return s === e || Tk(s, e) || Tk(e, s);
}
class uT {
  get element() {
    return this.node.element.element;
  }
  get children() {
    return this.node.children.map((e) => new uT(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class Fte {
  constructor(e, t, i) {
    this.renderer = e, this.nodeMapper = t, this.onDidChangeTwistieState = i, this.renderedNodes = /* @__PURE__ */ new Map(), this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...pe.asClassNameArray(Z.treeItemLoading)), !0) : (t.classList.remove(...pe.asClassNameArray(Z.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    this.renderer.disposeElement?.(this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear();
  }
}
function qF(s) {
  return {
    browserEvent: s.browserEvent,
    elements: s.elements.map((e) => e.element)
  };
}
function $F(s) {
  return {
    browserEvent: s.browserEvent,
    element: s.element && s.element.element,
    target: s.target
  };
}
class Ote extends W_ {
  constructor(e) {
    super(e.elements.map((t) => t.element)), this.data = e;
  }
}
function Ky(s) {
  return s instanceof W_ ? new Ote(s) : s;
}
class Pte {
  constructor(e) {
    this.dnd = e;
  }
  getDragURI(e) {
    return this.dnd.getDragURI(e.element);
  }
  getDragLabel(e, t) {
    if (this.dnd.getDragLabel)
      return this.dnd.getDragLabel(e.map((i) => i.element), t);
  }
  onDragStart(e, t) {
    this.dnd.onDragStart?.(Ky(e), t);
  }
  onDragOver(e, t, i, n, o, r = !0) {
    return this.dnd.onDragOver(Ky(e), t && t.element, i, n, o);
  }
  drop(e, t, i, n, o) {
    this.dnd.drop(Ky(e), t && t.element, i, n, o);
  }
  onDragEnd(e) {
    this.dnd.onDragEnd?.(e);
  }
  dispose() {
    this.dnd.dispose();
  }
}
function UW(s) {
  return s && {
    ...s,
    collapseByDefault: !0,
    identityProvider: s.identityProvider && {
      getId(e) {
        return s.identityProvider.getId(e.element);
      }
    },
    dnd: s.dnd && new Pte(s.dnd),
    multipleSelectionController: s.multipleSelectionController && {
      isSelectionSingleChangeEvent(e) {
        return s.multipleSelectionController.isSelectionSingleChangeEvent({ ...e, element: e.element });
      },
      isSelectionRangeChangeEvent(e) {
        return s.multipleSelectionController.isSelectionRangeChangeEvent({ ...e, element: e.element });
      }
    },
    accessibilityProvider: s.accessibilityProvider && {
      ...s.accessibilityProvider,
      getPosInSet: void 0,
      getSetSize: void 0,
      getRole: s.accessibilityProvider.getRole ? (e) => s.accessibilityProvider.getRole(e.element) : () => "treeitem",
      isChecked: s.accessibilityProvider.isChecked ? (e) => !!s.accessibilityProvider?.isChecked(e.element) : void 0,
      getAriaLabel(e) {
        return s.accessibilityProvider.getAriaLabel(e.element);
      },
      getWidgetAriaLabel() {
        return s.accessibilityProvider.getWidgetAriaLabel();
      },
      getWidgetRole: s.accessibilityProvider.getWidgetRole ? () => s.accessibilityProvider.getWidgetRole() : () => "tree",
      getAriaLevel: s.accessibilityProvider.getAriaLevel && ((e) => s.accessibilityProvider.getAriaLevel(e.element)),
      getActiveDescendantId: s.accessibilityProvider.getActiveDescendantId && ((e) => s.accessibilityProvider.getActiveDescendantId(e.element))
    },
    filter: s.filter && {
      filter(e, t) {
        return s.filter.filter(e.element, t);
      }
    },
    keyboardNavigationLabelProvider: s.keyboardNavigationLabelProvider && {
      ...s.keyboardNavigationLabelProvider,
      getKeyboardNavigationLabel(e) {
        return s.keyboardNavigationLabelProvider.getKeyboardNavigationLabel(e.element);
      }
    },
    sorter: void 0,
    expandOnlyOnTwistieClick: typeof s.expandOnlyOnTwistieClick > "u" ? void 0 : typeof s.expandOnlyOnTwistieClick != "function" ? s.expandOnlyOnTwistieClick : (e) => s.expandOnlyOnTwistieClick(e.element),
    defaultFindVisibility: (e) => e.hasChildren && e.stale ? 1 : typeof s.defaultFindVisibility == "number" ? s.defaultFindVisibility : typeof s.defaultFindVisibility > "u" ? 2 : s.defaultFindVisibility(e.element)
  };
}
function Bk(s, e) {
  e(s), s.children.forEach((t) => Bk(t, e));
}
class QW {
  get onDidScroll() {
    return this.tree.onDidScroll;
  }
  get onDidChangeFocus() {
    return te.map(this.tree.onDidChangeFocus, qF);
  }
  get onDidChangeSelection() {
    return te.map(this.tree.onDidChangeSelection, qF);
  }
  get onMouseDblClick() {
    return te.map(this.tree.onMouseDblClick, $F);
  }
  get onPointer() {
    return te.map(this.tree.onPointer, $F);
  }
  get onDidFocus() {
    return this.tree.onDidFocus;
  }
  /**
   * To be used internally only!
   * @deprecated
   */
  get onDidChangeModel() {
    return this.tree.onDidChangeModel;
  }
  get onDidChangeCollapseState() {
    return this.tree.onDidChangeCollapseState;
  }
  get onDidChangeFindOpenState() {
    return this.tree.onDidChangeFindOpenState;
  }
  get onDidChangeStickyScrollFocused() {
    return this.tree.onDidChangeStickyScrollFocused;
  }
  get onDidDispose() {
    return this.tree.onDidDispose;
  }
  constructor(e, t, i, n, o, r = {}) {
    this.user = e, this.dataSource = o, this.nodes = /* @__PURE__ */ new Map(), this.subTreeRefreshPromises = /* @__PURE__ */ new Map(), this.refreshPromises = /* @__PURE__ */ new Map(), this._onDidRender = new B(), this._onDidChangeNodeSlowState = new B(), this.nodeMapper = new rT((a) => new uT(a)), this.disposables = new X(), this.identityProvider = r.identityProvider, this.autoExpandSingleChildren = typeof r.autoExpandSingleChildren > "u" ? !1 : r.autoExpandSingleChildren, this.sorter = r.sorter, this.getDefaultCollapseState = (a) => r.collapseByDefault ? r.collapseByDefault(a) ? Fs.PreserveOrCollapsed : Fs.PreserveOrExpanded : void 0, this.tree = this.createTree(e, t, i, n, r), this.onDidChangeFindMode = this.tree.onDidChangeFindMode, this.onDidChangeFindMatchType = this.tree.onDidChangeFindMatchType, this.root = Yy({
      element: void 0,
      parent: null,
      hasChildren: !0,
      defaultCollapseState: void 0
    }), this.identityProvider && (this.root = {
      ...this.root,
      id: null
    }), this.nodes.set(null, this.root), this.tree.onDidChangeCollapseState(this._onDidChangeCollapseState, this, this.disposables);
  }
  createTree(e, t, i, n, o) {
    const r = new lT(i), a = n.map((c) => new Fte(c, this.nodeMapper, this._onDidChangeNodeSlowState.event)), l = UW(o) || {};
    return new hT(e, t, r, a, l);
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  // Widget
  getHTMLElement() {
    return this.tree.getHTMLElement();
  }
  get scrollTop() {
    return this.tree.scrollTop;
  }
  set scrollTop(e) {
    this.tree.scrollTop = e;
  }
  get scrollHeight() {
    return this.tree.scrollHeight;
  }
  get renderHeight() {
    return this.tree.renderHeight;
  }
  domFocus() {
    this.tree.domFocus();
  }
  layout(e, t) {
    this.tree.layout(e, t);
  }
  style(e) {
    this.tree.style(e);
  }
  // Model
  getInput() {
    return this.root.element;
  }
  async setInput(e, t) {
    this.refreshPromises.forEach((n) => n.cancel()), this.refreshPromises.clear(), this.root.element = e;
    const i = t && { viewState: t, focus: [], selection: [] };
    await this._updateChildren(e, !0, !1, i), i && (this.tree.setFocus(i.focus), this.tree.setSelection(i.selection)), t && typeof t.scrollTop == "number" && (this.scrollTop = t.scrollTop);
  }
  async _updateChildren(e = this.root.element, t = !0, i = !1, n, o) {
    if (typeof this.root.element > "u")
      throw new Vs(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await te.toPromise(this._onDidRender.event));
    const r = this.getDataNode(e);
    if (await this.refreshAndRenderNode(r, t, n, o), i)
      try {
        this.tree.rerender(r);
      } catch {
      }
  }
  // View
  rerender(e) {
    if (e === void 0 || e === this.root.element) {
      this.tree.rerender();
      return;
    }
    const t = this.getDataNode(e);
    this.tree.rerender(t);
  }
  // Tree
  getNode(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getNode(t === this.root ? null : t);
    return this.nodeMapper.map(i);
  }
  collapse(e, t = !1) {
    const i = this.getDataNode(e);
    return this.tree.collapse(i === this.root ? null : i, t);
  }
  async expand(e, t = !1) {
    if (typeof this.root.element > "u")
      throw new Vs(this.user, "Tree input not set");
    this.root.refreshPromise && (await this.root.refreshPromise, await te.toPromise(this._onDidRender.event));
    const i = this.getDataNode(e);
    if (this.tree.hasElement(i) && !this.tree.isCollapsible(i) || (i.refreshPromise && (await this.root.refreshPromise, await te.toPromise(this._onDidRender.event)), i !== this.root && !i.refreshPromise && !this.tree.isCollapsed(i)))
      return !1;
    const n = this.tree.expand(i === this.root ? null : i, t);
    return i.refreshPromise && (await this.root.refreshPromise, await te.toPromise(this._onDidRender.event)), n;
  }
  setSelection(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setSelection(i, t);
  }
  getSelection() {
    return this.tree.getSelection().map((t) => t.element);
  }
  setFocus(e, t) {
    const i = e.map((n) => this.getDataNode(n));
    this.tree.setFocus(i, t);
  }
  getFocus() {
    return this.tree.getFocus().map((t) => t.element);
  }
  reveal(e, t) {
    this.tree.reveal(this.getDataNode(e), t);
  }
  // Tree navigation
  getParentElement(e) {
    const t = this.tree.getParentElement(this.getDataNode(e));
    return t && t.element;
  }
  getFirstElementChild(e = this.root.element) {
    const t = this.getDataNode(e), i = this.tree.getFirstElementChild(t === this.root ? null : t);
    return i && i.element;
  }
  // Implementation
  getDataNode(e) {
    const t = this.nodes.get(e === this.root.element ? null : e);
    if (!t)
      throw new Vs(this.user, `Data tree node not found: ${e}`);
    return t;
  }
  async refreshAndRenderNode(e, t, i, n) {
    await this.refreshNode(e, t, i), !this.disposables.isDisposed && this.render(e, i, n);
  }
  async refreshNode(e, t, i) {
    let n;
    if (this.subTreeRefreshPromises.forEach((o, r) => {
      !n && Rte(r, e) && (n = o.then(() => this.refreshNode(e, t, i)));
    }), n)
      return n;
    if (e !== this.root && this.tree.getNode(e).collapsed) {
      e.hasChildren = !!this.dataSource.hasChildren(e.element), e.stale = !0, this.setChildren(e, [], t, i);
      return;
    }
    return this.doRefreshSubTree(e, t, i);
  }
  async doRefreshSubTree(e, t, i) {
    let n;
    e.refreshPromise = new Promise((o) => n = o), this.subTreeRefreshPromises.set(e, e.refreshPromise), e.refreshPromise.finally(() => {
      e.refreshPromise = void 0, this.subTreeRefreshPromises.delete(e);
    });
    try {
      const o = await this.doRefreshNode(e, t, i);
      e.stale = !1, await FE.settled(o.map((r) => this.doRefreshSubTree(r, t, i)));
    } finally {
      n();
    }
  }
  async doRefreshNode(e, t, i) {
    e.hasChildren = !!this.dataSource.hasChildren(e.element);
    let n;
    if (!e.hasChildren)
      n = Promise.resolve(nt.empty());
    else {
      const o = this.doGetChildren(e);
      if (PB(o))
        n = Promise.resolve(o);
      else {
        const r = MA(800);
        r.then(() => {
          e.slow = !0, this._onDidChangeNodeSlowState.fire(e);
        }, (a) => null), n = o.finally(() => r.cancel());
      }
    }
    try {
      const o = await n;
      return this.setChildren(e, o, t, i);
    } catch (o) {
      if (e !== this.root && this.tree.hasElement(e) && this.tree.collapse(e), Ad(o))
        return [];
      throw o;
    } finally {
      e.slow && (e.slow = !1, this._onDidChangeNodeSlowState.fire(e));
    }
  }
  doGetChildren(e) {
    let t = this.refreshPromises.get(e);
    if (t)
      return t;
    const i = this.dataSource.getChildren(e.element);
    return PB(i) ? this.processChildren(i) : (t = ir(async () => this.processChildren(await i)), this.refreshPromises.set(e, t), t.finally(() => {
      this.refreshPromises.delete(e);
    }));
  }
  _onDidChangeCollapseState({ node: e, deep: t }) {
    e.element !== null && !e.collapsed && e.element.stale && (t ? this.collapse(e.element.element) : this.refreshAndRenderNode(e.element, !1).catch(Pe));
  }
  setChildren(e, t, i, n) {
    const o = [...t];
    if (e.children.length === 0 && o.length === 0)
      return [];
    const r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map();
    for (const d of e.children)
      r.set(d.element, d), this.identityProvider && a.set(d.id, { node: d, collapsed: this.tree.hasElement(d) && this.tree.isCollapsed(d) });
    const l = [], c = o.map((d) => {
      const h = !!this.dataSource.hasChildren(d);
      if (!this.identityProvider) {
        const p = Yy({ element: d, parent: e, hasChildren: h, defaultCollapseState: this.getDefaultCollapseState(d) });
        return h && p.defaultCollapseState === Fs.PreserveOrExpanded && l.push(p), p;
      }
      const u = this.identityProvider.getId(d).toString(), g = a.get(u);
      if (g) {
        const p = g.node;
        return r.delete(p.element), this.nodes.delete(p.element), this.nodes.set(d, p), p.element = d, p.hasChildren = h, i ? g.collapsed ? (p.children.forEach((A) => Bk(A, (_) => this.nodes.delete(_.element))), p.children.splice(0, p.children.length), p.stale = !0) : l.push(p) : h && !g.collapsed && l.push(p), p;
      }
      const m = Yy({ element: d, parent: e, id: u, hasChildren: h, defaultCollapseState: this.getDefaultCollapseState(d) });
      return n && n.viewState.focus && n.viewState.focus.indexOf(u) > -1 && n.focus.push(m), n && n.viewState.selection && n.viewState.selection.indexOf(u) > -1 && n.selection.push(m), (n && n.viewState.expanded && n.viewState.expanded.indexOf(u) > -1 || h && m.defaultCollapseState === Fs.PreserveOrExpanded) && l.push(m), m;
    });
    for (const d of r.values())
      Bk(d, (h) => this.nodes.delete(h.element));
    for (const d of c)
      this.nodes.set(d.element, d);
    return e.children.splice(0, e.children.length, ...c), e !== this.root && this.autoExpandSingleChildren && c.length === 1 && l.length === 0 && (c[0].forceExpanded = !0, l.push(c[0])), l;
  }
  render(e, t, i) {
    const n = e.children.map((r) => this.asTreeElement(r, t)), o = i && {
      ...i,
      diffIdentityProvider: i.diffIdentityProvider && {
        getId(r) {
          return i.diffIdentityProvider.getId(r.element);
        }
      }
    };
    this.tree.setChildren(e === this.root ? null : e, n, o), e !== this.root && this.tree.setCollapsible(e, e.hasChildren), this._onDidRender.fire();
  }
  asTreeElement(e, t) {
    if (e.stale)
      return {
        element: e,
        collapsible: e.hasChildren,
        collapsed: !0
      };
    let i;
    return t && t.viewState.expanded && e.id && t.viewState.expanded.indexOf(e.id) > -1 ? i = !1 : e.forceExpanded ? (i = !1, e.forceExpanded = !1) : i = e.defaultCollapseState, {
      element: e,
      children: e.hasChildren ? nt.map(e.children, (n) => this.asTreeElement(n, t)) : [],
      collapsible: e.hasChildren,
      collapsed: i
    };
  }
  processChildren(e) {
    return this.sorter && (e = [...e].sort(this.sorter.compare.bind(this.sorter))), e;
  }
  dispose() {
    this.disposables.dispose(), this.tree.dispose();
  }
}
class gT {
  get element() {
    return {
      elements: this.node.element.elements.map((e) => e.element),
      incompressible: this.node.element.incompressible
    };
  }
  get children() {
    return this.node.children.map((e) => new gT(e));
  }
  get depth() {
    return this.node.depth;
  }
  get visibleChildrenCount() {
    return this.node.visibleChildrenCount;
  }
  get visibleChildIndex() {
    return this.node.visibleChildIndex;
  }
  get collapsible() {
    return this.node.collapsible;
  }
  get collapsed() {
    return this.node.collapsed;
  }
  get visible() {
    return this.node.visible;
  }
  get filterData() {
    return this.node.filterData;
  }
  constructor(e) {
    this.node = e;
  }
}
class Hte {
  constructor(e, t, i, n) {
    this.renderer = e, this.nodeMapper = t, this.compressibleNodeMapperProvider = i, this.onDidChangeTwistieState = n, this.renderedNodes = /* @__PURE__ */ new Map(), this.disposables = [], this.templateId = e.templateId;
  }
  renderTemplate(e) {
    return { templateData: this.renderer.renderTemplate(e) };
  }
  renderElement(e, t, i, n) {
    this.renderer.renderElement(this.nodeMapper.map(e), t, i.templateData, n);
  }
  renderCompressedElements(e, t, i, n) {
    this.renderer.renderCompressedElements(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  renderTwistie(e, t) {
    return e.slow ? (t.classList.add(...pe.asClassNameArray(Z.treeItemLoading)), !0) : (t.classList.remove(...pe.asClassNameArray(Z.treeItemLoading)), !1);
  }
  disposeElement(e, t, i, n) {
    this.renderer.disposeElement?.(this.nodeMapper.map(e), t, i.templateData, n);
  }
  disposeCompressedElements(e, t, i, n) {
    this.renderer.disposeCompressedElements?.(this.compressibleNodeMapperProvider().map(e), t, i.templateData, n);
  }
  disposeTemplate(e) {
    this.renderer.disposeTemplate(e.templateData);
  }
  dispose() {
    this.renderedNodes.clear(), this.disposables = Ct(this.disposables);
  }
}
function Wte(s) {
  const e = s && UW(s);
  return e && {
    ...e,
    keyboardNavigationLabelProvider: e.keyboardNavigationLabelProvider && {
      ...e.keyboardNavigationLabelProvider,
      getCompressedNodeKeyboardNavigationLabel(t) {
        return s.keyboardNavigationLabelProvider.getCompressedNodeKeyboardNavigationLabel(t.map((i) => i.element));
      }
    }
  };
}
class Vte extends QW {
  constructor(e, t, i, n, o, r, a = {}) {
    super(e, t, i, o, r, a), this.compressionDelegate = n, this.compressibleNodeMapper = new rT((l) => new gT(l)), this.filter = a.filter;
  }
  createTree(e, t, i, n, o) {
    const r = new lT(i), a = n.map((c) => new Hte(c, this.nodeMapper, () => this.compressibleNodeMapper, this._onDidChangeNodeSlowState.event)), l = Wte(o) || {};
    return new zW(e, t, r, a, l);
  }
  asTreeElement(e, t) {
    return {
      incompressible: this.compressionDelegate.isIncompressible(e.element),
      ...super.asTreeElement(e, t)
    };
  }
  updateOptions(e = {}) {
    this.tree.updateOptions(e);
  }
  render(e, t, i) {
    if (!this.identityProvider)
      return super.render(e, t);
    const n = (g) => this.identityProvider.getId(g).toString(), o = (g) => {
      const m = /* @__PURE__ */ new Set();
      for (const p of g) {
        const A = this.tree.getCompressedTreeNode(p === this.root ? null : p);
        if (A.element)
          for (const _ of A.element.elements)
            m.add(n(_.element));
      }
      return m;
    }, r = o(this.tree.getSelection()), a = o(this.tree.getFocus());
    super.render(e, t, i);
    const l = this.getSelection();
    let c = !1;
    const d = this.getFocus();
    let h = !1;
    const u = (g) => {
      const m = g.element;
      if (m)
        for (let p = 0; p < m.elements.length; p++) {
          const A = n(m.elements[p].element), _ = m.elements[m.elements.length - 1].element;
          r.has(A) && l.indexOf(_) === -1 && (l.push(_), c = !0), a.has(A) && d.indexOf(_) === -1 && (d.push(_), h = !0);
        }
      g.children.forEach(u);
    };
    u(this.tree.getCompressedTreeNode(e === this.root ? null : e)), c && this.setSelection(l), h && this.setFocus(d);
  }
  // For compressed async data trees, `TreeVisibility.Recurse` doesn't currently work
  // and we have to filter everything beforehand
  // Related to #85193 and #85835
  processChildren(e) {
    return this.filter && (e = nt.filter(e, (t) => {
      const i = this.filter.filter(
        t,
        1
        /* TreeVisibility.Visible */
      ), n = zte(i);
      if (n === 2)
        throw new Error("Recursive tree visibility not supported in async data compressed trees");
      return n === 1;
    })), super.processChildren(e);
  }
}
function zte(s) {
  return typeof s == "boolean" ? s ? 1 : 0 : aT(s) ? e_(s.visibility) : e_(s);
}
class Ute extends HW {
  constructor(e, t, i, n, o, r = {}) {
    super(e, t, i, n, r), this.user = e, this.dataSource = o, this.identityProvider = r.identityProvider;
  }
  createModel(e, t, i) {
    return new cT(e, t, i);
  }
}
new le("isMac", ze, f("isMac", "Whether the operating system is macOS"));
new le("isLinux", Fn, f("isLinux", "Whether the operating system is Linux"));
const hS = new le("isWindows", yn, f("isWindows", "Whether the operating system is Windows")), GW = new le("isWeb", pm, f("isWeb", "Whether the platform is a web browser"));
new le("isMacNative", ze && !pm, f("isMacNative", "Whether the operating system is macOS on a non-browser platform"));
new le("isIOS", Ea, f("isIOS", "Whether the operating system is iOS"));
new le("isMobile", K4, f("isMobile", "Whether the platform is a mobile web browser"));
new le("isDevelopment", !1, !0);
new le("productQualityType", "", f("productQualityType", "Quality type of VS Code"));
const jW = "inputFocus", YW = new le(jW, !1, f("inputFocus", "Whether keyboard focus is inside an input box"));
var ql = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, kt = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Do = We("listService");
class Qte {
  get lastFocusedList() {
    return this._lastFocusedWidget;
  }
  constructor() {
    this.disposables = new X(), this.lists = [], this._lastFocusedWidget = void 0, this._hasCreatedStyleController = !1;
  }
  setLastFocusedList(e) {
    e !== this._lastFocusedWidget && (this._lastFocusedWidget?.getHTMLElement().classList.remove("last-focused"), this._lastFocusedWidget = e, this._lastFocusedWidget?.getHTMLElement().classList.add("last-focused"));
  }
  register(e, t) {
    if (this._hasCreatedStyleController || (this._hasCreatedStyleController = !0, new G3(xo(), "").style(Qu)), this.lists.some((n) => n.widget === e))
      throw new Error("Cannot register the same widget multiple times");
    const i = { widget: e, extraContextKeys: t };
    return this.lists.push(i), x0(e.getHTMLElement()) && this.setLastFocusedList(e), jo(e.onDidFocus(() => this.setLastFocusedList(e)), we(() => this.lists.splice(this.lists.indexOf(i), 1)), e.onDidDispose(() => {
      this.lists = this.lists.filter((n) => n !== i), this._lastFocusedWidget === e && this.setLastFocusedList(void 0);
    }));
  }
  dispose() {
    this.disposables.dispose();
  }
}
const t_ = new le("listScrollAtBoundary", "none");
ne.or(t_.isEqualTo("top"), t_.isEqualTo("both"));
ne.or(t_.isEqualTo("bottom"), t_.isEqualTo("both"));
const KW = new le("listFocus", !0), JW = new le("treestickyScrollFocused", !1), uS = new le("listSupportsMultiselect", !0), qW = ne.and(KW, ne.not(jW), JW.negate()), fT = new le("listHasSelectionOrFocus", !1), mT = new le("listDoubleSelection", !1), pT = new le("listMultiSelection", !1), gS = new le("listSelectionNavigation", !1), Gte = new le("listSupportsFind", !0), AT = new le("treeElementCanCollapse", !1), jte = new le("treeElementHasParent", !1), _T = new le("treeElementCanExpand", !1), Yte = new le("treeElementHasChild", !1), Kte = new le("treeFindOpen", !1), $W = "listTypeNavigationMode", XW = "listAutomaticKeyboardNavigation";
function fS(s, e) {
  const t = s.createScoped(e.getHTMLElement());
  return KW.bindTo(t), t;
}
function mS(s, e) {
  const t = t_.bindTo(s), i = () => {
    const n = e.scrollTop === 0, o = e.scrollHeight - e.renderHeight - e.scrollTop < 1;
    n && o ? t.set("both") : n ? t.set("top") : o ? t.set("bottom") : t.set("none");
  };
  return i(), e.onDidScroll(i);
}
const Gu = "workbench.list.multiSelectModifier", Tw = "workbench.list.openMode", vo = "workbench.list.horizontalScrolling", bT = "workbench.list.defaultFindMode", wT = "workbench.list.typeNavigationMode", tv = "workbench.list.keyboardNavigation", Fr = "workbench.list.scrollByPage", CT = "workbench.list.defaultFindMatchType", i_ = "workbench.tree.indent", iv = "workbench.tree.renderIndentGuides", Or = "workbench.list.smoothScrolling", Na = "workbench.list.mouseWheelScrollSensitivity", Ta = "workbench.list.fastScrollSensitivity", nv = "workbench.tree.expandMode", sv = "workbench.tree.enableStickyScroll", ov = "workbench.tree.stickyScrollMaxItemCount";
function Ba(s) {
  return s.getValue(Gu) === "alt";
}
class Jte extends V {
  constructor(e) {
    super(), this.configurationService = e, this.useAltAsMultipleSelectionModifier = Ba(e), this.registerListeners();
  }
  registerListeners() {
    this._register(this.configurationService.onDidChangeConfiguration((e) => {
      e.affectsConfiguration(Gu) && (this.useAltAsMultipleSelectionModifier = Ba(this.configurationService));
    }));
  }
  isSelectionSingleChangeEvent(e) {
    return this.useAltAsMultipleSelectionModifier ? e.browserEvent.altKey : z3(e);
  }
  isSelectionRangeChangeEvent(e) {
    return U3(e);
  }
}
function pS(s, e) {
  const t = s.get(ht), i = s.get(bt), n = new X();
  return [{
    ...e,
    keyboardNavigationDelegate: { mightProducePrintableCharacter(r) {
      return i.mightProducePrintableCharacter(r);
    } },
    smoothScrolling: !!t.getValue(Or),
    mouseWheelScrollSensitivity: t.getValue(Na),
    fastScrollSensitivity: t.getValue(Ta),
    multipleSelectionController: e.multipleSelectionController ?? n.add(new Jte(t)),
    keyboardNavigationEventFilter: Xte(i),
    scrollByPage: !!t.getValue(Fr)
  }, n];
}
let XF = class extends ko {
  constructor(e, t, i, n, o, r, a, l, c) {
    const d = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(vo), [h, u] = c.invokeFunction(pS, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...h,
      horizontalScrolling: d
    }), this.disposables.add(u), this.contextKeyService = fS(r, this), this.disposables.add(mS(this.contextKeyService, this)), this.listSupportsMultiSelect = uS.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), gS.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this.listHasSelectionOrFocus = fT.bindTo(this.contextKeyService), this.listDoubleSelection = mT.bindTo(this.contextKeyService), this.listMultiSelection = pT.bindTo(this.contextKeyService), this.horizontalScrolling = o.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ba(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const m = this.getSelection(), p = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(m.length > 0 || p.length > 0), this.listMultiSelection.set(m.length > 1), this.listDoubleSelection.set(m.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const m = this.getSelection(), p = this.getFocus();
      this.listHasSelectionOrFocus.set(m.length > 0 || p.length > 0);
    })), this.disposables.add(l.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(Gu) && (this._useAltAsMultipleSelectionModifier = Ba(l));
      let p = {};
      if (m.affectsConfiguration(vo) && this.horizontalScrolling === void 0) {
        const A = !!l.getValue(vo);
        p = { ...p, horizontalScrolling: A };
      }
      if (m.affectsConfiguration(Fr)) {
        const A = !!l.getValue(Fr);
        p = { ...p, scrollByPage: A };
      }
      if (m.affectsConfiguration(Or)) {
        const A = !!l.getValue(Or);
        p = { ...p, smoothScrolling: A };
      }
      if (m.affectsConfiguration(Na)) {
        const A = l.getValue(Na);
        p = { ...p, mouseWheelScrollSensitivity: A };
      }
      if (m.affectsConfiguration(Ta)) {
        const A = l.getValue(Ta);
        p = { ...p, fastScrollSensitivity: A };
      }
      Object.keys(p).length > 0 && this.updateOptions(p);
    })), this.navigator = new ZW(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? ym(e) : Qu);
  }
};
XF = ql([
  kt(5, Se),
  kt(6, Do),
  kt(7, ht),
  kt(8, ke)
], XF);
let ZF = class extends ete {
  constructor(e, t, i, n, o, r, a, l, c) {
    const d = typeof o.horizontalScrolling < "u" ? o.horizontalScrolling : !!l.getValue(vo), [h, u] = c.invokeFunction(pS, o);
    super(e, t, i, n, {
      keyboardSupport: !1,
      ...h,
      horizontalScrolling: d
    }), this.disposables = new X(), this.disposables.add(u), this.contextKeyService = fS(r, this), this.disposables.add(mS(this.contextKeyService, this.widget)), this.horizontalScrolling = o.horizontalScrolling, this.listSupportsMultiSelect = uS.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(o.multipleSelectionSupport !== !1), gS.bindTo(this.contextKeyService).set(!!o.selectionNavigation), this._useAltAsMultipleSelectionModifier = Ba(l), this.disposables.add(this.contextKeyService), this.disposables.add(a.register(this)), this.updateStyles(o.overrideStyles), this.disposables.add(l.onDidChangeConfiguration((m) => {
      m.affectsConfiguration(Gu) && (this._useAltAsMultipleSelectionModifier = Ba(l));
      let p = {};
      if (m.affectsConfiguration(vo) && this.horizontalScrolling === void 0) {
        const A = !!l.getValue(vo);
        p = { ...p, horizontalScrolling: A };
      }
      if (m.affectsConfiguration(Fr)) {
        const A = !!l.getValue(Fr);
        p = { ...p, scrollByPage: A };
      }
      if (m.affectsConfiguration(Or)) {
        const A = !!l.getValue(Or);
        p = { ...p, smoothScrolling: A };
      }
      if (m.affectsConfiguration(Na)) {
        const A = l.getValue(Na);
        p = { ...p, mouseWheelScrollSensitivity: A };
      }
      if (m.affectsConfiguration(Ta)) {
        const A = l.getValue(Ta);
        p = { ...p, fastScrollSensitivity: A };
      }
      Object.keys(p).length > 0 && this.updateOptions(p);
    })), this.navigator = new ZW(this, { configurationService: l, ...o }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? ym(e) : Qu);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
ZF = ql([
  kt(5, Se),
  kt(6, Do),
  kt(7, ht),
  kt(8, ke)
], ZF);
let eO = class extends Ik {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    const h = typeof r.horizontalScrolling < "u" ? r.horizontalScrolling : !!c.getValue(vo), [u, g] = d.invokeFunction(pS, r);
    super(e, t, i, n, o, {
      keyboardSupport: !1,
      ...u,
      horizontalScrolling: h
    }), this.disposables.add(g), this.contextKeyService = fS(a, this), this.disposables.add(mS(this.contextKeyService, this)), this.listSupportsMultiSelect = uS.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(r.multipleSelectionSupport !== !1), gS.bindTo(this.contextKeyService).set(!!r.selectionNavigation), this.listHasSelectionOrFocus = fT.bindTo(this.contextKeyService), this.listDoubleSelection = mT.bindTo(this.contextKeyService), this.listMultiSelection = pT.bindTo(this.contextKeyService), this.horizontalScrolling = r.horizontalScrolling, this._useAltAsMultipleSelectionModifier = Ba(c), this.disposables.add(this.contextKeyService), this.disposables.add(l.register(this)), this.updateStyles(r.overrideStyles), this.disposables.add(this.onDidChangeSelection(() => {
      const p = this.getSelection(), A = this.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.listHasSelectionOrFocus.set(p.length > 0 || A.length > 0), this.listMultiSelection.set(p.length > 1), this.listDoubleSelection.set(p.length === 2);
      });
    })), this.disposables.add(this.onDidChangeFocus(() => {
      const p = this.getSelection(), A = this.getFocus();
      this.listHasSelectionOrFocus.set(p.length > 0 || A.length > 0);
    })), this.disposables.add(c.onDidChangeConfiguration((p) => {
      p.affectsConfiguration(Gu) && (this._useAltAsMultipleSelectionModifier = Ba(c));
      let A = {};
      if (p.affectsConfiguration(vo) && this.horizontalScrolling === void 0) {
        const _ = !!c.getValue(vo);
        A = { ...A, horizontalScrolling: _ };
      }
      if (p.affectsConfiguration(Fr)) {
        const _ = !!c.getValue(Fr);
        A = { ...A, scrollByPage: _ };
      }
      if (p.affectsConfiguration(Or)) {
        const _ = !!c.getValue(Or);
        A = { ...A, smoothScrolling: _ };
      }
      if (p.affectsConfiguration(Na)) {
        const _ = c.getValue(Na);
        A = { ...A, mouseWheelScrollSensitivity: _ };
      }
      if (p.affectsConfiguration(Ta)) {
        const _ = c.getValue(Ta);
        A = { ...A, fastScrollSensitivity: _ };
      }
      Object.keys(A).length > 0 && this.updateOptions(A);
    })), this.navigator = new qte(this, { configurationService: c, ...r }), this.disposables.add(this.navigator);
  }
  updateOptions(e) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.updateStyles(e.overrideStyles), e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyles(e) {
    this.style(e ? ym(e) : Qu);
  }
  dispose() {
    this.disposables.dispose(), super.dispose();
  }
};
eO = ql([
  kt(6, Se),
  kt(7, Do),
  kt(8, ht),
  kt(9, ke)
], eO);
class vT extends V {
  constructor(e, t) {
    super(), this.widget = e, this._onDidOpen = this._register(new B()), this.onDidOpen = this._onDidOpen.event, this._register(te.filter(this.widget.onDidChangeSelection, (i) => cl(i.browserEvent))((i) => this.onSelectionFromKeyboard(i))), this._register(this.widget.onPointer((i) => this.onPointer(i.element, i.browserEvent))), this._register(this.widget.onMouseDblClick((i) => this.onMouseDblClick(i.element, i.browserEvent))), typeof t?.openOnSingleClick != "boolean" && t?.configurationService ? (this.openOnSingleClick = t?.configurationService.getValue(Tw) !== "doubleClick", this._register(t?.configurationService.onDidChangeConfiguration((i) => {
      i.affectsConfiguration(Tw) && (this.openOnSingleClick = t?.configurationService.getValue(Tw) !== "doubleClick");
    }))) : this.openOnSingleClick = t?.openOnSingleClick ?? !0;
  }
  onSelectionFromKeyboard(e) {
    if (e.elements.length !== 1)
      return;
    const t = e.browserEvent, i = typeof t.preserveFocus == "boolean" ? t.preserveFocus : !0, n = typeof t.pinned == "boolean" ? t.pinned : !i;
    this._open(this.getSelectedElement(), i, n, !1, e.browserEvent);
  }
  onPointer(e, t) {
    if (!this.openOnSingleClick || t.detail === 2)
      return;
    const n = t.button === 1, o = !0, r = n, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  onMouseDblClick(e, t) {
    if (!t)
      return;
    const i = t.target;
    if (i.classList.contains("monaco-tl-twistie") || i.classList.contains("monaco-icon-label") && i.classList.contains("folder-icon") && t.offsetX < 16)
      return;
    const o = !1, r = !0, a = t.ctrlKey || t.metaKey || t.altKey;
    this._open(e, o, r, a, t);
  }
  _open(e, t, i, n, o) {
    e && this._onDidOpen.fire({
      editorOptions: {
        preserveFocus: t,
        pinned: i,
        revealIfVisible: !0
      },
      sideBySide: n,
      element: e,
      browserEvent: o
    });
  }
}
class ZW extends vT {
  constructor(e, t) {
    super(e, t), this.widget = e;
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class qte extends vT {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelectedElements()[0];
  }
}
class $te extends vT {
  constructor(e, t) {
    super(e, t);
  }
  getSelectedElement() {
    return this.widget.getSelection()[0] ?? void 0;
  }
}
function Xte(s) {
  let e = !1;
  return (t) => {
    if (t.toKeyCodeChord().isModifierKey())
      return !1;
    if (e)
      return e = !1, !1;
    const i = s.softDispatch(t, t.target);
    return i.kind === 1 ? (e = !0, !1) : (e = !1, i.kind === 0);
  };
}
let Rk = class extends hT {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: d, getTypeNavigationMode: h, disposable: u } = r.invokeFunction(G_, o);
    super(e, t, i, n, d), this.disposables.add(u), this.internals = new xu(this, o, h, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
Rk = ql([
  kt(5, ke),
  kt(6, Se),
  kt(7, Do),
  kt(8, ht)
], Rk);
let tO = class extends zW {
  constructor(e, t, i, n, o, r, a, l, c) {
    const { options: d, getTypeNavigationMode: h, disposable: u } = r.invokeFunction(G_, o);
    super(e, t, i, n, d), this.disposables.add(u), this.internals = new xu(this, o, h, o.overrideStyles, a, l, c), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
tO = ql([
  kt(5, ke),
  kt(6, Se),
  kt(7, Do),
  kt(8, ht)
], tO);
let iO = class extends Ute {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    const { options: h, getTypeNavigationMode: u, disposable: g } = a.invokeFunction(G_, r);
    super(e, t, i, n, o, h), this.disposables.add(g), this.internals = new xu(this, r, u, r.overrideStyles, l, c, d), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles !== void 0 && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
iO = ql([
  kt(6, ke),
  kt(7, Se),
  kt(8, Do),
  kt(9, ht)
], iO);
let Fk = class extends QW {
  get onDidOpen() {
    return this.internals.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a, l, c, d) {
    const { options: h, getTypeNavigationMode: u, disposable: g } = a.invokeFunction(G_, r);
    super(e, t, i, n, o, h), this.disposables.add(g), this.internals = new xu(this, r, u, r.overrideStyles, l, c, d), this.disposables.add(this.internals);
  }
  updateOptions(e = {}) {
    super.updateOptions(e), e.overrideStyles && this.internals.updateStyleOverrides(e.overrideStyles), this.internals.updateOptions(e);
  }
};
Fk = ql([
  kt(6, ke),
  kt(7, Se),
  kt(8, Do),
  kt(9, ht)
], Fk);
let nO = class extends Vte {
  constructor(e, t, i, n, o, r, a, l, c, d, h) {
    const { options: u, getTypeNavigationMode: g, disposable: m } = l.invokeFunction(G_, a);
    super(e, t, i, n, o, r, u), this.disposables.add(m), this.internals = new xu(this, a, g, a.overrideStyles, c, d, h), this.disposables.add(this.internals);
  }
  updateOptions(e) {
    super.updateOptions(e), this.internals.updateOptions(e);
  }
};
nO = ql([
  kt(7, ke),
  kt(8, Se),
  kt(9, Do),
  kt(10, ht)
], nO);
function e8(s) {
  const e = s.getValue(bT);
  if (e === "highlight")
    return Sl.Highlight;
  if (e === "filter")
    return Sl.Filter;
  const t = s.getValue(tv);
  if (t === "simple" || t === "highlight")
    return Sl.Highlight;
  if (t === "filter")
    return Sl.Filter;
}
function t8(s) {
  const e = s.getValue(CT);
  if (e === "fuzzy")
    return yu.Fuzzy;
  if (e === "contiguous")
    return yu.Contiguous;
}
function G_(s, e) {
  const t = s.get(ht), i = s.get(Yl), n = s.get(Se), o = s.get(ke), r = () => {
    const u = n.getContextKeyValue($W);
    if (u === "automatic")
      return fa.Automatic;
    if (u === "trigger" || n.getContextKeyValue(XW) === !1)
      return fa.Trigger;
    const m = t.getValue(wT);
    if (m === "automatic")
      return fa.Automatic;
    if (m === "trigger")
      return fa.Trigger;
  }, a = e.horizontalScrolling !== void 0 ? e.horizontalScrolling : !!t.getValue(vo), [l, c] = o.invokeFunction(pS, e), d = e.paddingBottom, h = e.renderIndentGuides !== void 0 ? e.renderIndentGuides : t.getValue(iv);
  return {
    getTypeNavigationMode: r,
    disposable: c,
    options: {
      // ...options, // TODO@Joao why is this not splatted here?
      keyboardSupport: !1,
      ...l,
      indent: typeof t.getValue(i_) == "number" ? t.getValue(i_) : void 0,
      renderIndentGuides: h,
      smoothScrolling: !!t.getValue(Or),
      defaultFindMode: e8(t),
      defaultFindMatchType: t8(t),
      horizontalScrolling: a,
      scrollByPage: !!t.getValue(Fr),
      paddingBottom: d,
      hideTwistiesOfChildlessElements: e.hideTwistiesOfChildlessElements,
      expandOnlyOnTwistieClick: e.expandOnlyOnTwistieClick ?? t.getValue(nv) === "doubleClick",
      contextViewProvider: i,
      findWidgetStyles: Z$,
      enableStickyScroll: !!t.getValue(sv),
      stickyScrollMaxItemCount: Number(t.getValue(ov))
    }
  };
}
let xu = class {
  get onDidOpen() {
    return this.navigator.onDidOpen;
  }
  constructor(e, t, i, n, o, r, a) {
    this.tree = e, this.disposables = [], this.contextKeyService = fS(o, e), this.disposables.push(mS(this.contextKeyService, e)), this.listSupportsMultiSelect = uS.bindTo(this.contextKeyService), this.listSupportsMultiSelect.set(t.multipleSelectionSupport !== !1), gS.bindTo(this.contextKeyService).set(!!t.selectionNavigation), this.listSupportFindWidget = Gte.bindTo(this.contextKeyService), this.listSupportFindWidget.set(t.findWidgetEnabled ?? !0), this.hasSelectionOrFocus = fT.bindTo(this.contextKeyService), this.hasDoubleSelection = mT.bindTo(this.contextKeyService), this.hasMultiSelection = pT.bindTo(this.contextKeyService), this.treeElementCanCollapse = AT.bindTo(this.contextKeyService), this.treeElementHasParent = jte.bindTo(this.contextKeyService), this.treeElementCanExpand = _T.bindTo(this.contextKeyService), this.treeElementHasChild = Yte.bindTo(this.contextKeyService), this.treeFindOpen = Kte.bindTo(this.contextKeyService), this.treeStickyScrollFocused = JW.bindTo(this.contextKeyService), this._useAltAsMultipleSelectionModifier = Ba(a), this.updateStyleOverrides(n);
    const c = () => {
      const h = e.getFocus()[0];
      if (!h)
        return;
      const u = e.getNode(h);
      this.treeElementCanCollapse.set(u.collapsible && !u.collapsed), this.treeElementHasParent.set(!!e.getParentElement(h)), this.treeElementCanExpand.set(u.collapsible && u.collapsed), this.treeElementHasChild.set(!!e.getFirstElementChild(h));
    }, d = /* @__PURE__ */ new Set();
    d.add($W), d.add(XW), this.disposables.push(this.contextKeyService, r.register(e), e.onDidChangeSelection(() => {
      const h = e.getSelection(), u = e.getFocus();
      this.contextKeyService.bufferChangeEvents(() => {
        this.hasSelectionOrFocus.set(h.length > 0 || u.length > 0), this.hasMultiSelection.set(h.length > 1), this.hasDoubleSelection.set(h.length === 2);
      });
    }), e.onDidChangeFocus(() => {
      const h = e.getSelection(), u = e.getFocus();
      this.hasSelectionOrFocus.set(h.length > 0 || u.length > 0), c();
    }), e.onDidChangeCollapseState(c), e.onDidChangeModel(c), e.onDidChangeFindOpenState((h) => this.treeFindOpen.set(h)), e.onDidChangeStickyScrollFocused((h) => this.treeStickyScrollFocused.set(h)), a.onDidChangeConfiguration((h) => {
      let u = {};
      if (h.affectsConfiguration(Gu) && (this._useAltAsMultipleSelectionModifier = Ba(a)), h.affectsConfiguration(i_)) {
        const g = a.getValue(i_);
        u = { ...u, indent: g };
      }
      if (h.affectsConfiguration(iv) && t.renderIndentGuides === void 0) {
        const g = a.getValue(iv);
        u = { ...u, renderIndentGuides: g };
      }
      if (h.affectsConfiguration(Or)) {
        const g = !!a.getValue(Or);
        u = { ...u, smoothScrolling: g };
      }
      if (h.affectsConfiguration(bT) || h.affectsConfiguration(tv)) {
        const g = e8(a);
        u = { ...u, defaultFindMode: g };
      }
      if (h.affectsConfiguration(wT) || h.affectsConfiguration(tv)) {
        const g = i();
        u = { ...u, typeNavigationMode: g };
      }
      if (h.affectsConfiguration(CT)) {
        const g = t8(a);
        u = { ...u, defaultFindMatchType: g };
      }
      if (h.affectsConfiguration(vo) && t.horizontalScrolling === void 0) {
        const g = !!a.getValue(vo);
        u = { ...u, horizontalScrolling: g };
      }
      if (h.affectsConfiguration(Fr)) {
        const g = !!a.getValue(Fr);
        u = { ...u, scrollByPage: g };
      }
      if (h.affectsConfiguration(nv) && t.expandOnlyOnTwistieClick === void 0 && (u = { ...u, expandOnlyOnTwistieClick: a.getValue(nv) === "doubleClick" }), h.affectsConfiguration(sv)) {
        const g = a.getValue(sv);
        u = { ...u, enableStickyScroll: g };
      }
      if (h.affectsConfiguration(ov)) {
        const g = Math.max(1, a.getValue(ov));
        u = { ...u, stickyScrollMaxItemCount: g };
      }
      if (h.affectsConfiguration(Na)) {
        const g = a.getValue(Na);
        u = { ...u, mouseWheelScrollSensitivity: g };
      }
      if (h.affectsConfiguration(Ta)) {
        const g = a.getValue(Ta);
        u = { ...u, fastScrollSensitivity: g };
      }
      Object.keys(u).length > 0 && e.updateOptions(u);
    }), this.contextKeyService.onDidChangeContext((h) => {
      h.affectsSome(d) && e.updateOptions({ typeNavigationMode: i() });
    })), this.navigator = new $te(e, { configurationService: a, ...t }), this.disposables.push(this.navigator);
  }
  updateOptions(e) {
    e.multipleSelectionSupport !== void 0 && this.listSupportsMultiSelect.set(!!e.multipleSelectionSupport);
  }
  updateStyleOverrides(e) {
    this.tree.style(e ? ym(e) : Qu);
  }
  dispose() {
    this.disposables = Ct(this.disposables);
  }
};
xu = ql([
  kt(4, Se),
  kt(5, Do),
  kt(6, ht)
], xu);
const Zte = ji.as(Wu.Configuration);
Zte.registerConfiguration({
  id: "workbench",
  order: 7,
  title: f("workbenchConfigurationTitle", "Workbench"),
  type: "object",
  properties: {
    [Gu]: {
      type: "string",
      enum: ["ctrlCmd", "alt"],
      markdownEnumDescriptions: [
        f("multiSelectModifier.ctrlCmd", "Maps to `Control` on Windows and Linux and to `Command` on macOS."),
        f("multiSelectModifier.alt", "Maps to `Alt` on Windows and Linux and to `Option` on macOS.")
      ],
      default: "ctrlCmd",
      description: f({
        key: "multiSelectModifier",
        comment: [
          "- `ctrlCmd` refers to a value the setting can take and should not be localized.",
          "- `Control` and `Command` refer to the modifier keys Ctrl or Cmd on the keyboard and can be localized."
        ]
      }, "The modifier to be used to add an item in trees and lists to a multi-selection with the mouse (for example in the explorer, open editors and scm view). The 'Open to Side' mouse gestures - if supported - will adapt such that they do not conflict with the multiselect modifier.")
    },
    [Tw]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: f({
        key: "openModeModifier",
        comment: ["`singleClick` and `doubleClick` refers to a value the setting can take and should not be localized."]
      }, "Controls how to open items in trees and lists using the mouse (if supported). Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [vo]: {
      type: "boolean",
      default: !1,
      description: f("horizontalScrolling setting", "Controls whether lists and trees support horizontal scrolling in the workbench. Warning: turning on this setting has a performance implication.")
    },
    [Fr]: {
      type: "boolean",
      default: !1,
      description: f("list.scrollByPage", "Controls whether clicks in the scrollbar scroll page by page.")
    },
    [i_]: {
      type: "number",
      default: 8,
      minimum: 4,
      maximum: 40,
      description: f("tree indent setting", "Controls tree indentation in pixels.")
    },
    [iv]: {
      type: "string",
      enum: ["none", "onHover", "always"],
      default: "onHover",
      description: f("render tree indent guides", "Controls whether the tree should render indent guides.")
    },
    [Or]: {
      type: "boolean",
      default: !1,
      description: f("list smoothScrolling setting", "Controls whether lists and trees have smooth scrolling.")
    },
    [Na]: {
      type: "number",
      default: 1,
      markdownDescription: f("Mouse Wheel Scroll Sensitivity", "A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.")
    },
    [Ta]: {
      type: "number",
      default: 5,
      markdownDescription: f("Fast Scroll Sensitivity", "Scrolling speed multiplier when pressing `Alt`.")
    },
    [bT]: {
      type: "string",
      enum: ["highlight", "filter"],
      enumDescriptions: [
        f("defaultFindModeSettingKey.highlight", "Highlight elements when searching. Further up and down navigation will traverse only the highlighted elements."),
        f("defaultFindModeSettingKey.filter", "Filter elements when searching.")
      ],
      default: "highlight",
      description: f("defaultFindModeSettingKey", "Controls the default find mode for lists and trees in the workbench.")
    },
    [tv]: {
      type: "string",
      enum: ["simple", "highlight", "filter"],
      enumDescriptions: [
        f("keyboardNavigationSettingKey.simple", "Simple keyboard navigation focuses elements which match the keyboard input. Matching is done only on prefixes."),
        f("keyboardNavigationSettingKey.highlight", "Highlight keyboard navigation highlights elements which match the keyboard input. Further up and down navigation will traverse only the highlighted elements."),
        f("keyboardNavigationSettingKey.filter", "Filter keyboard navigation will filter out and hide all the elements which do not match the keyboard input.")
      ],
      default: "highlight",
      description: f("keyboardNavigationSettingKey", "Controls the keyboard navigation style for lists and trees in the workbench. Can be simple, highlight and filter."),
      deprecated: !0,
      deprecationMessage: f("keyboardNavigationSettingKeyDeprecated", "Please use 'workbench.list.defaultFindMode' and	'workbench.list.typeNavigationMode' instead.")
    },
    [CT]: {
      type: "string",
      enum: ["fuzzy", "contiguous"],
      enumDescriptions: [
        f("defaultFindMatchTypeSettingKey.fuzzy", "Use fuzzy matching when searching."),
        f("defaultFindMatchTypeSettingKey.contiguous", "Use contiguous matching when searching.")
      ],
      default: "fuzzy",
      description: f("defaultFindMatchTypeSettingKey", "Controls the type of matching used when searching lists and trees in the workbench.")
    },
    [nv]: {
      type: "string",
      enum: ["singleClick", "doubleClick"],
      default: "singleClick",
      description: f("expand mode", "Controls how tree folders are expanded when clicking the folder names. Note that some trees and lists might choose to ignore this setting if it is not applicable.")
    },
    [sv]: {
      type: "boolean",
      default: !0,
      description: f("sticky scroll", "Controls whether sticky scrolling is enabled in trees.")
    },
    [ov]: {
      type: "number",
      minimum: 1,
      default: 7,
      markdownDescription: f("sticky scroll maximum items", "Controls the number of sticky elements displayed in the tree when {0} is enabled.", "`#workbench.tree.enableStickyScroll#`")
    },
    [wT]: {
      type: "string",
      enum: ["automatic", "trigger"],
      default: "automatic",
      markdownDescription: f("typeNavigationMode2", "Controls how type navigation works in lists and trees in the workbench. When set to `trigger`, type navigation begins once the `list.triggerTypeNavigation` command is run.")
    }
  }
});
class zc extends V {
  /**
   * Create a new {@link HighlightedLabel}.
   *
   * @param container The parent container to append to.
   */
  constructor(e, t) {
    super(), this.options = t, this.text = "", this.title = "", this.highlights = [], this.didEverRender = !1, this.supportIcons = t?.supportIcons ?? !1, this.domNode = K(e, de("span.monaco-highlighted-label"));
  }
  /**
   * The label's DOM node.
   */
  get element() {
    return this.domNode;
  }
  /**
   * Set the label and highlights.
   *
   * @param text The label to display.
   * @param highlights The ranges to highlight.
   * @param title An optional title for the hover tooltip.
   * @param escapeNewLines Whether to escape new lines.
   * @returns
   */
  set(e, t = [], i = "", n) {
    e || (e = ""), n && (e = zc.escapeNewLines(e, t)), !(this.didEverRender && this.text === e && this.title === i && bs(this.highlights, t)) && (this.text = e, this.title = i, this.highlights = t, this.render());
  }
  render() {
    const e = [];
    let t = 0;
    for (const i of this.highlights) {
      if (i.end === i.start)
        continue;
      if (t < i.start) {
        const r = this.text.substring(t, i.start);
        this.supportIcons ? e.push(...kh(r)) : e.push(r), t = i.start;
      }
      const n = this.text.substring(t, i.end), o = de("span.highlight", void 0, ...this.supportIcons ? kh(n) : [n]);
      i.extraClasses && o.classList.add(...i.extraClasses), e.push(o), t = i.end;
    }
    if (t < this.text.length) {
      const i = this.text.substring(t);
      this.supportIcons ? e.push(...kh(i)) : e.push(i);
    }
    if (Rn(this.domNode, ...e), this.options?.hoverDelegate?.showNativeHover)
      this.domNode.title = this.title;
    else if (!this.customHover && this.title !== "") {
      const i = this.options?.hoverDelegate ?? Ls("mouse");
      this.customHover = this._register(Oa().setupManagedHover(i, this.domNode, this.title));
    } else this.customHover && this.customHover.update(this.title);
    this.didEverRender = !0;
  }
  static escapeNewLines(e, t) {
    let i = 0, n = 0;
    return e.replace(/\r\n|\r|\n/g, (o, r) => {
      n = o === `\r
` ? -1 : 0, r += i;
      for (const a of t)
        a.end <= r || (a.start >= r && (a.start += n), a.end >= r && (a.end += n));
      return i += n, "⏎";
    });
  }
}
class ip {
  constructor(e) {
    this._element = e;
  }
  get element() {
    return this._element;
  }
  set textContent(e) {
    this.disposed || e === this._textContent || (this._textContent = e, this._element.textContent = e);
  }
  set classNames(e) {
    this.disposed || bs(e, this._classNames) || (this._classNames = e, this._element.classList.value = "", this._element.classList.add(...e));
  }
  set empty(e) {
    this.disposed || e === this._empty || (this._empty = e, this._element.style.marginLeft = e ? "0" : "");
  }
  dispose() {
    this.disposed = !0;
  }
}
class rv extends V {
  constructor(e, t) {
    super(), this.customHovers = /* @__PURE__ */ new Map(), this.creationOptions = t, this.domNode = this._register(new ip(K(e, de(".monaco-icon-label")))), this.labelContainer = K(this.domNode.element, de(".monaco-icon-label-container")), this.nameContainer = K(this.labelContainer, de("span.monaco-icon-name-container")), t?.supportHighlights || t?.supportIcons ? this.nameNode = this._register(new iie(this.nameContainer, !!t.supportIcons)) : this.nameNode = new eie(this.nameContainer), this.hoverDelegate = t?.hoverDelegate ?? Ls("mouse");
  }
  get element() {
    return this.domNode.element;
  }
  setLabel(e, t, i) {
    const n = ["monaco-icon-label"], o = ["monaco-icon-label-container"];
    let r = "";
    i && (i.extraClasses && n.push(...i.extraClasses), i.italic && n.push("italic"), i.strikethrough && n.push("strikethrough"), i.disabledCommand && o.push("disabled"), i.title && (typeof i.title == "string" ? r += i.title : r += e));
    const a = this.domNode.element.querySelector(".monaco-icon-label-iconpath");
    if (i?.iconPath) {
      let l;
      !a || !Bi(a) ? (l = de(".monaco-icon-label-iconpath"), this.domNode.element.prepend(l)) : l = a, l.style.backgroundImage = Vl(i?.iconPath);
    } else a && a.remove();
    if (this.domNode.classNames = n, this.domNode.element.setAttribute("aria-label", r), this.labelContainer.classList.value = "", this.labelContainer.classList.add(...o), this.setupHover(i?.descriptionTitle ? this.labelContainer : this.element, i?.title), this.nameNode.setLabel(e, i), t || this.descriptionNode) {
      const l = this.getOrCreateDescriptionNode();
      l instanceof zc ? (l.set(t || "", i ? i.descriptionMatches : void 0, void 0, i?.labelEscapeNewLines), this.setupHover(l.element, i?.descriptionTitle)) : (l.textContent = t && i?.labelEscapeNewLines ? zc.escapeNewLines(t, []) : t || "", this.setupHover(l.element, i?.descriptionTitle || ""), l.empty = !t);
    }
    if (i?.suffix || this.suffixNode) {
      const l = this.getOrCreateSuffixNode();
      l.textContent = i?.suffix ?? "";
    }
  }
  setupHover(e, t) {
    const i = this.customHovers.get(e);
    if (i && (i.dispose(), this.customHovers.delete(e)), !t) {
      e.removeAttribute("title");
      return;
    }
    if (this.hoverDelegate.showNativeHover)
      (function(o, r) {
        _s(r) ? o.title = v3(r) : r?.markdownNotSupportedFallback ? o.title = r.markdownNotSupportedFallback : o.removeAttribute("title");
      })(e, t);
    else {
      const n = Oa().setupManagedHover(this.hoverDelegate, e, t);
      n && this.customHovers.set(e, n);
    }
  }
  dispose() {
    super.dispose();
    for (const e of this.customHovers.values())
      e.dispose();
    this.customHovers.clear();
  }
  getOrCreateSuffixNode() {
    if (!this.suffixNode) {
      const e = this._register(new ip(J6(this.nameContainer, de("span.monaco-icon-suffix-container"))));
      this.suffixNode = this._register(new ip(K(e.element, de("span.label-suffix"))));
    }
    return this.suffixNode;
  }
  getOrCreateDescriptionNode() {
    if (!this.descriptionNode) {
      const e = this._register(new ip(K(this.labelContainer, de("span.monaco-icon-description-container"))));
      this.creationOptions?.supportDescriptionHighlights ? this.descriptionNode = this._register(new zc(K(e.element, de("span.label-description")), { supportIcons: !!this.creationOptions.supportIcons })) : this.descriptionNode = this._register(new ip(K(e.element, de("span.label-description"))));
    }
    return this.descriptionNode;
  }
}
class eie {
  constructor(e) {
    this.container = e, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && bs(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = K(this.container, de("a.label-name", { id: t?.domId }))), this.singleLabel.textContent = e;
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        for (let i = 0; i < e.length; i++) {
          const n = e[i], o = t?.domId && `${t?.domId}_${i}`;
          K(this.container, de("a.label-name", { id: o, "data-icon-label-count": e.length, "data-icon-label-index": i, role: "treeitem" }, n)), i < e.length - 1 && K(this.container, de("span.label-separator", void 0, t?.separator || "/"));
        }
      }
  }
}
function tie(s, e, t) {
  if (!t)
    return;
  let i = 0;
  return s.map((n) => {
    const o = { start: i, end: i + n.length }, r = t.map((a) => on.intersect(o, a)).filter((a) => !on.isEmpty(a)).map(({ start: a, end: l }) => ({ start: a - i, end: l - i }));
    return i = o.end + e.length, r;
  });
}
class iie extends V {
  constructor(e, t) {
    super(), this.container = e, this.supportIcons = t, this.label = void 0, this.singleLabel = void 0;
  }
  setLabel(e, t) {
    if (!(this.label === e && bs(this.options, t)))
      if (this.label = e, this.options = t, typeof e == "string")
        this.singleLabel || (this.container.innerText = "", this.container.classList.remove("multiple"), this.singleLabel = this._register(new zc(K(this.container, de("a.label-name", { id: t?.domId })), { supportIcons: this.supportIcons }))), this.singleLabel.set(e, t?.matches, void 0, t?.labelEscapeNewLines);
      else {
        this.container.innerText = "", this.container.classList.add("multiple"), this.singleLabel = void 0;
        const i = t?.separator || "/", n = tie(e, i, t?.matches);
        for (let o = 0; o < e.length; o++) {
          const r = e[o], a = n ? n[o] : void 0, l = t?.domId && `${t?.domId}_${o}`, c = de("a.label-name", { id: l, "data-icon-label-count": e.length, "data-icon-label-index": o, role: "treeitem" });
          this._register(new zc(K(this.container, c), { supportIcons: this.supportIcons })).set(r, a, void 0, t?.labelEscapeNewLines), o < e.length - 1 && K(c, de("span.label-separator", void 0, i));
        }
      }
  }
}
const Pb = de, nie = {
  keybindingLabelBackground: void 0,
  keybindingLabelForeground: void 0,
  keybindingLabelBorder: void 0,
  keybindingLabelBottomBorder: void 0,
  keybindingLabelShadow: void 0
};
class j_ extends V {
  constructor(e, t, i) {
    super(), this.os = t, this.keyElements = /* @__PURE__ */ new Set(), this.options = i || /* @__PURE__ */ Object.create(null);
    const n = this.options.keybindingLabelForeground;
    this.domNode = K(e, Pb(".monaco-keybinding")), n && (this.domNode.style.color = n), this.hover = this._register(Oa().setupManagedHover(Ls("mouse"), this.domNode, "")), this.didEverRender = !1, e.appendChild(this.domNode);
  }
  get element() {
    return this.domNode;
  }
  set(e, t) {
    this.didEverRender && this.keybinding === e && j_.areSame(this.matches, t) || (this.keybinding = e, this.matches = t, this.render());
  }
  render() {
    if (this.clear(), this.keybinding) {
      const e = this.keybinding.getChords();
      e[0] && this.renderChord(this.domNode, e[0], this.matches ? this.matches.firstPart : null);
      for (let i = 1; i < e.length; i++)
        K(this.domNode, Pb("span.monaco-keybinding-key-chord-separator", void 0, " ")), this.renderChord(this.domNode, e[i], this.matches ? this.matches.chordPart : null);
      const t = this.options.disableTitle ?? !1 ? void 0 : this.keybinding.getAriaLabel() || void 0;
      this.hover.update(t), this.domNode.setAttribute("aria-label", t || "");
    } else this.options && this.options.renderUnboundKeybindings && this.renderUnbound(this.domNode);
    this.didEverRender = !0;
  }
  clear() {
    Bn(this.domNode), this.keyElements.clear();
  }
  renderChord(e, t, i) {
    const n = FN.modifierLabels[this.os];
    t.ctrlKey && this.renderKey(e, n.ctrlKey, !!i?.ctrlKey, n.separator), t.shiftKey && this.renderKey(e, n.shiftKey, !!i?.shiftKey, n.separator), t.altKey && this.renderKey(e, n.altKey, !!i?.altKey, n.separator), t.metaKey && this.renderKey(e, n.metaKey, !!i?.metaKey, n.separator);
    const o = t.keyLabel;
    o && this.renderKey(e, o, !!i?.keyCode, "");
  }
  renderKey(e, t, i, n) {
    K(e, this.createKeyElement(t, i ? ".highlight" : "")), n && K(e, Pb("span.monaco-keybinding-key-separator", void 0, n));
  }
  renderUnbound(e) {
    K(e, this.createKeyElement(f("unbound", "Unbound")));
  }
  createKeyElement(e, t = "") {
    const i = Pb("span.monaco-keybinding-key" + t, void 0, e);
    return this.keyElements.add(i), this.options.keybindingLabelBackground && (i.style.backgroundColor = this.options.keybindingLabelBackground), this.options.keybindingLabelBorder && (i.style.borderColor = this.options.keybindingLabelBorder), this.options.keybindingLabelBottomBorder && (i.style.borderBottomColor = this.options.keybindingLabelBottomBorder), this.options.keybindingLabelShadow && (i.style.boxShadow = `inset 0 -1px 0 ${this.options.keybindingLabelShadow}`), i;
  }
  static areSame(e, t) {
    return e === t || !e && !t ? !0 : !!e && !!t && bs(e.firstPart, t.firstPart) && bs(e.chordPart, t.chordPart);
  }
}
const sO = new Br(() => {
  const s = new Intl.Collator(void 0, { numeric: !0, sensitivity: "base" });
  return {
    collator: s,
    collatorIsNumeric: s.resolvedOptions().numeric
  };
});
function sie(s, e, t = !1) {
  const i = s || "", n = e || "", o = sO.value.collator.compare(i, n);
  return sO.value.collatorIsNumeric && o === 0 && i !== n ? i < n ? -1 : 1 : o;
}
function oie(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = rie(s, e, t);
  if (o)
    return o;
  const r = i.endsWith(t), a = n.endsWith(t);
  if (r !== a)
    return r ? -1 : 1;
  const l = sie(i, n);
  return l !== 0 ? l : i.localeCompare(n);
}
function rie(s, e, t) {
  const i = s.toLowerCase(), n = e.toLowerCase(), o = i.startsWith(t), r = n.startsWith(t);
  if (o !== r)
    return o ? -1 : 1;
  if (o && r) {
    if (i.length < n.length)
      return -1;
    if (i.length > n.length)
      return 1;
  }
  return 0;
}
var AS = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ok = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Pk;
const fr = de;
class i8 {
  constructor(e, t, i) {
    this.index = e, this.hasCheckbox = t, this._hidden = !1, this._init = new Br(() => {
      const n = i.label ?? "", o = fp(n).text.trim(), r = i.ariaLabel || [n, this.saneDescription, this.saneDetail].map((a) => gJ(a)).filter((a) => !!a).join(", ");
      return {
        saneLabel: n,
        saneSortLabel: o,
        saneAriaLabel: r
      };
    }), this._saneDescription = i.description, this._saneTooltip = i.tooltip;
  }
  // #region Lazy Getters
  get saneLabel() {
    return this._init.value.saneLabel;
  }
  get saneSortLabel() {
    return this._init.value.saneSortLabel;
  }
  get saneAriaLabel() {
    return this._init.value.saneAriaLabel;
  }
  get element() {
    return this._element;
  }
  set element(e) {
    this._element = e;
  }
  get hidden() {
    return this._hidden;
  }
  set hidden(e) {
    this._hidden = e;
  }
  get saneDescription() {
    return this._saneDescription;
  }
  set saneDescription(e) {
    this._saneDescription = e;
  }
  get saneDetail() {
    return this._saneDetail;
  }
  set saneDetail(e) {
    this._saneDetail = e;
  }
  get saneTooltip() {
    return this._saneTooltip;
  }
  set saneTooltip(e) {
    this._saneTooltip = e;
  }
  get labelHighlights() {
    return this._labelHighlights;
  }
  set labelHighlights(e) {
    this._labelHighlights = e;
  }
  get descriptionHighlights() {
    return this._descriptionHighlights;
  }
  set descriptionHighlights(e) {
    this._descriptionHighlights = e;
  }
  get detailHighlights() {
    return this._detailHighlights;
  }
  set detailHighlights(e) {
    this._detailHighlights = e;
  }
}
class Ji extends i8 {
  constructor(e, t, i, n, o, r) {
    super(e, t, o), this.fireButtonTriggered = i, this._onChecked = n, this.item = o, this._separator = r, this._checked = !1, this.onChecked = t ? te.map(te.filter(this._onChecked.event, (a) => a.element === this), (a) => a.checked) : te.None, this._saneDetail = o.detail, this._labelHighlights = o.highlights?.label, this._descriptionHighlights = o.highlights?.description, this._detailHighlights = o.highlights?.detail;
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    this._separator = e;
  }
  get checked() {
    return this._checked;
  }
  set checked(e) {
    e !== this._checked && (this._checked = e, this._onChecked.fire({ element: this, checked: e }));
  }
  get checkboxDisabled() {
    return !!this.item.disabled;
  }
}
var da;
(function(s) {
  s[s.NONE = 0] = "NONE", s[s.MOUSE_HOVER = 1] = "MOUSE_HOVER", s[s.ACTIVE_ITEM = 2] = "ACTIVE_ITEM";
})(da || (da = {}));
class jd extends i8 {
  constructor(e, t, i) {
    super(e, !1, i), this.fireSeparatorButtonTriggered = t, this.separator = i, this.children = new Array(), this.focusInsideSeparator = da.NONE;
  }
}
class aie {
  getHeight(e) {
    return e instanceof jd ? 30 : e.saneDetail ? 44 : 22;
  }
  getTemplateId(e) {
    return e instanceof Ji ? av.ID : lv.ID;
  }
}
class lie {
  getWidgetAriaLabel() {
    return f("quickInput", "Quick Input");
  }
  getAriaLabel(e) {
    return e.separator?.label ? `${e.saneAriaLabel}, ${e.separator.label}` : e.saneAriaLabel;
  }
  getWidgetRole() {
    return "listbox";
  }
  getRole(e) {
    return e.hasCheckbox ? "checkbox" : "option";
  }
  isChecked(e) {
    if (!(!e.hasCheckbox || !(e instanceof Ji)))
      return {
        get value() {
          return e.checked;
        },
        onDidChange: (t) => e.onChecked(() => t())
      };
  }
}
class n8 {
  constructor(e) {
    this.hoverDelegate = e;
  }
  // TODO: only do the common stuff here and have a subclass handle their specific stuff
  renderTemplate(e) {
    const t = /* @__PURE__ */ Object.create(null);
    t.toDisposeElement = new X(), t.toDisposeTemplate = new X(), t.entry = K(e, fr(".quick-input-list-entry"));
    const i = K(t.entry, fr("label.quick-input-list-label"));
    t.toDisposeTemplate.add(Xt(i, ee.CLICK, (c) => {
      t.checkbox.offsetParent || c.preventDefault();
    })), t.checkbox = K(i, fr("input.quick-input-list-checkbox")), t.checkbox.type = "checkbox";
    const n = K(i, fr(".quick-input-list-rows")), o = K(n, fr(".quick-input-list-row")), r = K(n, fr(".quick-input-list-row"));
    t.label = new rv(o, { supportHighlights: !0, supportDescriptionHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.label), t.icon = $M(t.label.element, fr(".quick-input-list-icon"));
    const a = K(o, fr(".quick-input-list-entry-keybinding"));
    t.keybinding = new j_(a, Us), t.toDisposeTemplate.add(t.keybinding);
    const l = K(r, fr(".quick-input-list-label-meta"));
    return t.detail = new rv(l, { supportHighlights: !0, supportIcons: !0, hoverDelegate: this.hoverDelegate }), t.toDisposeTemplate.add(t.detail), t.separator = K(t.entry, fr(".quick-input-list-separator")), t.actionBar = new wo(t.entry, this.hoverDelegate ? { hoverDelegate: this.hoverDelegate } : void 0), t.actionBar.domNode.classList.add("quick-input-list-entry-action-bar"), t.toDisposeTemplate.add(t.actionBar), t;
  }
  disposeTemplate(e) {
    e.toDisposeElement.dispose(), e.toDisposeTemplate.dispose();
  }
  disposeElement(e, t, i) {
    i.toDisposeElement.clear(), i.actionBar.clear();
  }
}
var Oh;
let av = (Oh = class extends n8 {
  constructor(e, t) {
    super(e), this.themeService = t, this._itemsWithSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return Pk.ID;
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.toDisposeTemplate.add(Xt(t.checkbox, ee.CHANGE, (i) => {
      t.element.checked = t.checkbox.checked;
    })), t;
  }
  renderElement(e, t, i) {
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0;
    const o = n.item;
    i.checkbox.checked = n.checked, i.toDisposeElement.add(n.onChecked((u) => i.checkbox.checked = u)), i.checkbox.disabled = n.checkboxDisabled;
    const { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    if (o.iconPath) {
      const u = P0(this.themeService.getColorTheme().type) ? o.iconPath.dark : o.iconPath.light ?? o.iconPath.dark, g = _e.revive(u);
      i.icon.className = "quick-input-list-icon", i.icon.style.backgroundImage = Vl(g);
    } else
      i.icon.style.backgroundImage = "", i.icon.className = o.iconClass ? `quick-input-list-icon ${o.iconClass}` : "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const d = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (d.extraClasses = o.iconClasses, d.italic = o.italic, d.strikethrough = o.strikethrough, i.entry.classList.remove("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, d), i.keybinding.set(o.keybinding), n.saneDetail) {
      let u;
      n.saneTooltip || (u = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: u,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    n.separator?.label ? (i.separator.textContent = n.separator.label, i.separator.style.display = "", this.addItemWithSeparator(n)) : i.separator.style.display = "none", i.entry.classList.toggle("quick-input-list-separator-border", !!n.separator);
    const h = o.buttons;
    h && h.length ? (i.actionBar.push(h.map((u, g) => Qp(u, `id-${g}`, () => n.fireButtonTriggered({ button: u, item: n.item }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions");
  }
  disposeElement(e, t, i) {
    this.removeItemWithSeparator(e.element), super.disposeElement(e, t, i);
  }
  isItemWithSeparatorVisible(e) {
    return this._itemsWithSeparatorsFrequency.has(e);
  }
  addItemWithSeparator(e) {
    this._itemsWithSeparatorsFrequency.set(e, (this._itemsWithSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeItemWithSeparator(e) {
    const t = this._itemsWithSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._itemsWithSeparatorsFrequency.set(e, t - 1) : this._itemsWithSeparatorsFrequency.delete(e);
  }
}, Pk = Oh, Oh.ID = "quickpickitem", Oh);
av = Pk = AS([
  Ok(1, nn)
], av);
const F1 = class F1 extends n8 {
  constructor() {
    super(...arguments), this._visibleSeparatorsFrequency = /* @__PURE__ */ new Map();
  }
  get templateId() {
    return F1.ID;
  }
  get visibleSeparators() {
    return [...this._visibleSeparatorsFrequency.keys()];
  }
  isSeparatorVisible(e) {
    return this._visibleSeparatorsFrequency.has(e);
  }
  renderTemplate(e) {
    const t = super.renderTemplate(e);
    return t.checkbox.style.display = "none", t;
  }
  renderElement(e, t, i) {
    const n = e.element;
    i.element = n, n.element = i.entry ?? void 0, n.element.classList.toggle("focus-inside", !!n.focusInsideSeparator);
    const o = n.separator, { labelHighlights: r, descriptionHighlights: a, detailHighlights: l } = n;
    i.icon.style.backgroundImage = "", i.icon.className = "";
    let c;
    !n.saneTooltip && n.saneDescription && (c = {
      markdown: {
        value: n.saneDescription,
        supportThemeIcons: !0
      },
      markdownNotSupportedFallback: n.saneDescription
    });
    const d = {
      matches: r || [],
      // If we have a tooltip, we want that to be shown and not any other hover
      descriptionTitle: c,
      descriptionMatches: a || [],
      labelEscapeNewLines: !0
    };
    if (i.entry.classList.add("quick-input-list-separator-as-item"), i.label.setLabel(n.saneLabel, n.saneDescription, d), n.saneDetail) {
      let u;
      n.saneTooltip || (u = {
        markdown: {
          value: n.saneDetail,
          supportThemeIcons: !0
        },
        markdownNotSupportedFallback: n.saneDetail
      }), i.detail.element.style.display = "", i.detail.setLabel(n.saneDetail, void 0, {
        matches: l,
        title: u,
        labelEscapeNewLines: !0
      });
    } else
      i.detail.element.style.display = "none";
    i.separator.style.display = "none", i.entry.classList.add("quick-input-list-separator-border");
    const h = o.buttons;
    h && h.length ? (i.actionBar.push(h.map((u, g) => Qp(u, `id-${g}`, () => n.fireSeparatorButtonTriggered({ button: u, separator: n.separator }))), { icon: !0, label: !1 }), i.entry.classList.add("has-actions")) : i.entry.classList.remove("has-actions"), this.addSeparator(n);
  }
  disposeElement(e, t, i) {
    this.removeSeparator(e.element), this.isSeparatorVisible(e.element) || e.element.element?.classList.remove("focus-inside"), super.disposeElement(e, t, i);
  }
  addSeparator(e) {
    this._visibleSeparatorsFrequency.set(e, (this._visibleSeparatorsFrequency.get(e) || 0) + 1);
  }
  removeSeparator(e) {
    const t = this._visibleSeparatorsFrequency.get(e) || 0;
    t > 1 ? this._visibleSeparatorsFrequency.set(e, t - 1) : this._visibleSeparatorsFrequency.delete(e);
  }
};
F1.ID = "quickpickseparator";
let lv = F1, n_ = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this.parent = e, this.hoverDelegate = t, this.linkOpenerDelegate = i, this.accessibilityService = r, this._onKeyDown = new B(), this._onLeave = new B(), this.onLeave = this._onLeave.event, this._visibleCountObservable = ot("VisibleCount", 0), this.onChangedVisibleCount = te.fromObservable(this._visibleCountObservable, this._store), this._allVisibleCheckedObservable = ot("AllVisibleChecked", !1), this.onChangedAllVisibleChecked = te.fromObservable(this._allVisibleCheckedObservable, this._store), this._checkedCountObservable = ot("CheckedCount", 0), this.onChangedCheckedCount = te.fromObservable(this._checkedCountObservable, this._store), this._checkedElementsObservable = qL({ equalsFn: pi }, new Array()), this.onChangedCheckedElements = te.fromObservable(this._checkedElementsObservable, this._store), this._onButtonTriggered = new B(), this.onButtonTriggered = this._onButtonTriggered.event, this._onSeparatorButtonTriggered = new B(), this.onSeparatorButtonTriggered = this._onSeparatorButtonTriggered.event, this._elementChecked = new B(), this._elementCheckedEventBufferer = new k_(), this._hasCheckboxes = !1, this._inputElements = new Array(), this._elementTree = new Array(), this._itemElements = new Array(), this._elementDisposable = this._register(new X()), this._matchOnDescription = !1, this._matchOnDetail = !1, this._matchOnLabel = !0, this._matchOnLabelMode = "fuzzy", this._sortByLabel = !0, this._shouldLoop = !0, this._container = K(this.parent, fr(".quick-input-list")), this._separatorRenderer = new lv(t), this._itemRenderer = o.createInstance(av, t), this._tree = this._register(o.createInstance(Rk, "QuickInput", this._container, new aie(), [this._itemRenderer, this._separatorRenderer], {
      filter: {
        filter(a) {
          return a.hidden ? 0 : a instanceof jd ? 2 : 1;
        }
      },
      sorter: {
        compare: (a, l) => {
          if (!this.sortByLabel || !this._lastQueryString)
            return 0;
          const c = this._lastQueryString.toLowerCase();
          return die(a, l, c);
        }
      },
      accessibilityProvider: new lie(),
      setRowLineHeight: !1,
      multipleSelectionSupport: !1,
      hideTwistiesOfChildlessElements: !0,
      renderIndentGuides: om.None,
      findWidgetEnabled: !1,
      indent: 0,
      horizontalScrolling: !1,
      allowNonCollapsibleParents: !0,
      alwaysConsumeMouseWheel: !0
    })), this._tree.getHTMLElement().id = n, this._registerListeners();
  }
  //#region public getters/setters
  get onDidChangeFocus() {
    return te.map(this._tree.onDidChangeFocus, (e) => e.elements.filter((t) => t instanceof Ji).map((t) => t.item), this._store);
  }
  get onDidChangeSelection() {
    return te.map(this._tree.onDidChangeSelection, (e) => ({
      items: e.elements.filter((t) => t instanceof Ji).map((t) => t.item),
      event: e.browserEvent
    }), this._store);
  }
  get displayed() {
    return this._container.style.display !== "none";
  }
  set displayed(e) {
    this._container.style.display = e ? "" : "none";
  }
  get scrollTop() {
    return this._tree.scrollTop;
  }
  set scrollTop(e) {
    this._tree.scrollTop = e;
  }
  get ariaLabel() {
    return this._tree.ariaLabel;
  }
  set ariaLabel(e) {
    this._tree.ariaLabel = e ?? "";
  }
  set enabled(e) {
    this._tree.getHTMLElement().style.pointerEvents = e ? "" : "none";
  }
  get matchOnDescription() {
    return this._matchOnDescription;
  }
  set matchOnDescription(e) {
    this._matchOnDescription = e;
  }
  get matchOnDetail() {
    return this._matchOnDetail;
  }
  set matchOnDetail(e) {
    this._matchOnDetail = e;
  }
  get matchOnLabel() {
    return this._matchOnLabel;
  }
  set matchOnLabel(e) {
    this._matchOnLabel = e;
  }
  get matchOnLabelMode() {
    return this._matchOnLabelMode;
  }
  set matchOnLabelMode(e) {
    this._matchOnLabelMode = e;
  }
  get sortByLabel() {
    return this._sortByLabel;
  }
  set sortByLabel(e) {
    this._sortByLabel = e;
  }
  get shouldLoop() {
    return this._shouldLoop;
  }
  set shouldLoop(e) {
    this._shouldLoop = e;
  }
  //#endregion
  //#region register listeners
  _registerListeners() {
    this._registerOnKeyDown(), this._registerOnContainerClick(), this._registerOnMouseMiddleClick(), this._registerOnTreeModelChanged(), this._registerOnElementChecked(), this._registerOnContextMenu(), this._registerHoverListeners(), this._registerSelectionChangeListener(), this._registerSeparatorActionShowingListeners();
  }
  _registerOnKeyDown() {
    this._register(this._tree.onKeyDown((e) => {
      const t = new Mt(e);
      switch (t.keyCode) {
        case 10:
          this.toggleCheckbox();
          break;
      }
      this._onKeyDown.fire(t);
    }));
  }
  _registerOnContainerClick() {
    this._register(U(this._container, ee.CLICK, (e) => {
      (e.x || e.y) && this._onLeave.fire();
    }));
  }
  _registerOnMouseMiddleClick() {
    this._register(U(this._container, ee.AUXCLICK, (e) => {
      e.button === 1 && this._onLeave.fire();
    }));
  }
  _registerOnTreeModelChanged() {
    this._register(this._tree.onDidChangeModel(() => {
      const e = this._itemElements.filter((t) => !t.hidden).length;
      this._visibleCountObservable.set(e, void 0), this._hasCheckboxes && this._updateCheckedObservables();
    }));
  }
  _registerOnElementChecked() {
    this._register(this._elementCheckedEventBufferer.wrapEvent(this._elementChecked.event, (e, t) => t)((e) => this._updateCheckedObservables()));
  }
  _registerOnContextMenu() {
    this._register(this._tree.onContextMenu((e) => {
      e.element && (e.browserEvent.preventDefault(), this._tree.setSelection([e.element]));
    }));
  }
  _registerHoverListeners() {
    const e = this._register(new EH(this.hoverDelegate.delay));
    this._register(this._tree.onMouseOver(async (t) => {
      if (uR(t.browserEvent.target)) {
        e.cancel();
        return;
      }
      if (
        // anchors are an exception as called out above so we skip them here
        !(!uR(t.browserEvent.relatedTarget) && // check if the mouse is still over the same element
        yi(t.browserEvent.relatedTarget, t.element?.element))
      )
        try {
          await e.trigger(async () => {
            t.element instanceof Ji && this.showHover(t.element);
          });
        } catch (i) {
          if (!Ad(i))
            throw i;
        }
    })), this._register(this._tree.onMouseOut((t) => {
      yi(t.browserEvent.relatedTarget, t.element?.element) || e.cancel();
    }));
  }
  /**
   * Register's focus change and mouse events so that we can track when items inside of a
   * separator's section are focused or hovered so that we can display the separator's actions
   */
  _registerSeparatorActionShowingListeners() {
    this._register(this._tree.onDidChangeFocus((e) => {
      const t = e.elements[0] ? this._tree.getParentElement(e.elements[0]) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        const n = i === t;
        !!(i.focusInsideSeparator & da.ACTIVE_ITEM) !== n && (n ? i.focusInsideSeparator |= da.ACTIVE_ITEM : i.focusInsideSeparator &= ~da.ACTIVE_ITEM, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOver((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & da.MOUSE_HOVER) || (i.focusInsideSeparator |= da.MOUSE_HOVER, this._tree.rerender(i));
      }
    })), this._register(this._tree.onMouseOut((e) => {
      const t = e.element ? this._tree.getParentElement(e.element) : null;
      for (const i of this._separatorRenderer.visibleSeparators) {
        if (i !== t)
          continue;
        !!(i.focusInsideSeparator & da.MOUSE_HOVER) && (i.focusInsideSeparator &= ~da.MOUSE_HOVER, this._tree.rerender(i));
      }
    }));
  }
  _registerSelectionChangeListener() {
    this._register(this._tree.onDidChangeSelection((e) => {
      const t = e.elements.filter((i) => i instanceof Ji);
      t.length !== e.elements.length && (e.elements.length === 1 && e.elements[0] instanceof jd && (this._tree.setFocus([e.elements[0].children[0]]), this._tree.reveal(e.elements[0], 0)), this._tree.setSelection(t));
    }));
  }
  //#endregion
  //#region public methods
  setAllVisibleChecked(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      this._itemElements.forEach((t) => {
        !t.hidden && !t.checkboxDisabled && (t.checked = e);
      });
    });
  }
  setElements(e) {
    this._elementDisposable.clear(), this._lastQueryString = void 0, this._inputElements = e, this._hasCheckboxes = this.parent.classList.contains("show-checkboxes");
    let t;
    this._itemElements = new Array(), this._elementTree = e.reduce((i, n, o) => {
      let r;
      if (n.type === "separator") {
        if (!n.buttons)
          return i;
        t = new jd(o, (a) => this._onSeparatorButtonTriggered.fire(a), n), r = t;
      } else {
        const a = o > 0 ? e[o - 1] : void 0;
        let l;
        a && a.type === "separator" && !a.buttons && (t = void 0, l = a);
        const c = new Ji(o, this._hasCheckboxes, (d) => this._onButtonTriggered.fire(d), this._elementChecked, n, l);
        if (this._itemElements.push(c), t)
          return t.children.push(c), i;
        r = c;
      }
      return i.push(r), i;
    }, new Array()), this._setElementsToTree(this._elementTree), this.accessibilityService.isScreenReaderOptimized() && setTimeout(() => {
      const i = this._tree.getHTMLElement().querySelector(".monaco-list-row.focused"), n = i?.parentNode;
      if (i && n) {
        const o = i.nextSibling;
        i.remove(), n.insertBefore(i, o);
      }
    }, 0);
  }
  setFocusedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i).filter((i) => !i.hidden);
    if (this._tree.setFocus(t), e.length > 0) {
      const i = this._tree.getFocus()[0];
      i && this._tree.reveal(i);
    }
  }
  getActiveDescendant() {
    return this._tree.getHTMLElement().getAttribute("aria-activedescendant");
  }
  setSelectedElements(e) {
    const t = e.map((i) => this._itemElements.find((n) => n.item === i)).filter((i) => !!i);
    this._tree.setSelection(t);
  }
  getCheckedElements() {
    return this._itemElements.filter((e) => e.checked).map((e) => e.item);
  }
  setCheckedElements(e) {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const t = /* @__PURE__ */ new Set();
      for (const i of e)
        t.add(i);
      for (const i of this._itemElements)
        i.checked = t.has(i.item);
    });
  }
  focus(e) {
    if (this._itemElements.length)
      switch (e === yt.Second && this._itemElements.length < 2 && (e = yt.First), e) {
        case yt.First:
          this._tree.scrollTop = 0, this._tree.focusFirst(void 0, (t) => t.element instanceof Ji);
          break;
        case yt.Second: {
          this._tree.scrollTop = 0;
          let t = !1;
          this._tree.focusFirst(void 0, (i) => i.element instanceof Ji ? t ? !0 : (t = !t, !1) : !1);
          break;
        }
        case yt.Last:
          this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (t) => t.element instanceof Ji);
          break;
        case yt.Next: {
          const t = this._tree.getFocus();
          this._tree.focusNext(void 0, this._shouldLoop, void 0, (n) => n.element instanceof Ji ? (this._tree.reveal(n.element), !0) : !1);
          const i = this._tree.getFocus();
          t.length && t[0] === i[0] && t[0] === this._itemElements[this._itemElements.length - 1] && this._onLeave.fire();
          break;
        }
        case yt.Previous: {
          const t = this._tree.getFocus();
          this._tree.focusPrevious(void 0, this._shouldLoop, void 0, (n) => {
            if (!(n.element instanceof Ji))
              return !1;
            const o = this._tree.getParentElement(n.element);
            return o === null || o.children[0] !== n.element ? this._tree.reveal(n.element) : this._tree.reveal(o), !0;
          });
          const i = this._tree.getFocus();
          t.length && t[0] === i[0] && t[0] === this._itemElements[0] && this._onLeave.fire();
          break;
        }
        case yt.NextPage:
          this._tree.focusNextPage(void 0, (t) => t.element instanceof Ji ? (this._tree.reveal(t.element), !0) : !1);
          break;
        case yt.PreviousPage:
          this._tree.focusPreviousPage(void 0, (t) => {
            if (!(t.element instanceof Ji))
              return !1;
            const i = this._tree.getParentElement(t.element);
            return i === null || i.children[0] !== t.element ? this._tree.reveal(t.element) : this._tree.reveal(i), !0;
          });
          break;
        case yt.NextSeparator: {
          let t = !1;
          const i = this._tree.getFocus()[0];
          this._tree.focusNext(void 0, !0, void 0, (o) => {
            if (t)
              return !0;
            if (o.element instanceof jd)
              t = !0, this._separatorRenderer.isSeparatorVisible(o.element) ? this._tree.reveal(o.element.children[0]) : this._tree.reveal(o.element, 0);
            else if (o.element instanceof Ji) {
              if (o.element.separator)
                return this._itemRenderer.isItemWithSeparatorVisible(o.element) ? this._tree.reveal(o.element) : this._tree.reveal(o.element, 0), !0;
              if (o.element === this._elementTree[0])
                return this._tree.reveal(o.element, 0), !0;
            }
            return !1;
          });
          const n = this._tree.getFocus()[0];
          i === n && (this._tree.scrollTop = this._tree.scrollHeight, this._tree.focusLast(void 0, (o) => o.element instanceof Ji));
          break;
        }
        case yt.PreviousSeparator: {
          let t, i = !!this._tree.getFocus()[0]?.separator;
          this._tree.focusPrevious(void 0, !0, void 0, (n) => {
            if (n.element instanceof jd)
              i ? t || (this._separatorRenderer.isSeparatorVisible(n.element) ? this._tree.reveal(n.element) : this._tree.reveal(n.element, 0), t = n.element.children[0]) : i = !0;
            else if (n.element instanceof Ji && !t) {
              if (n.element.separator)
                this._itemRenderer.isItemWithSeparatorVisible(n.element) ? this._tree.reveal(n.element) : this._tree.reveal(n.element, 0), t = n.element;
              else if (n.element === this._elementTree[0])
                return this._tree.reveal(n.element, 0), !0;
            }
            return !1;
          }), t && this._tree.setFocus([t]);
          break;
        }
      }
  }
  clearFocus() {
    this._tree.setFocus([]);
  }
  domFocus() {
    this._tree.domFocus();
  }
  layout(e) {
    this._tree.getHTMLElement().style.maxHeight = e ? `${// Make sure height aligns with list item heights
    Math.floor(e / 44) * 44 + 6}px` : "", this._tree.layout();
  }
  filter(e) {
    if (this._lastQueryString = e, !(this._sortByLabel || this._matchOnLabel || this._matchOnDescription || this._matchOnDetail))
      return this._tree.layout(), !1;
    const t = e;
    if (e = e.trim(), !e || !(this.matchOnLabel || this.matchOnDescription || this.matchOnDetail))
      this._itemElements.forEach((i) => {
        i.labelHighlights = void 0, i.descriptionHighlights = void 0, i.detailHighlights = void 0, i.hidden = !1;
        const n = i.index && this._inputElements[i.index - 1];
        i.item && (i.separator = n && n.type === "separator" && !n.buttons ? n : void 0);
      });
    else {
      let i;
      this._itemElements.forEach((n) => {
        let o;
        this.matchOnLabelMode === "fuzzy" ? o = this.matchOnLabel ? Ey(e, fp(n.saneLabel)) ?? void 0 : void 0 : o = this.matchOnLabel ? cie(t, fp(n.saneLabel)) ?? void 0 : void 0;
        const r = this.matchOnDescription ? Ey(e, fp(n.saneDescription || "")) ?? void 0 : void 0, a = this.matchOnDetail ? Ey(e, fp(n.saneDetail || "")) ?? void 0 : void 0;
        if (o || r || a ? (n.labelHighlights = o, n.descriptionHighlights = r, n.detailHighlights = a, n.hidden = !1) : (n.labelHighlights = void 0, n.descriptionHighlights = void 0, n.detailHighlights = void 0, n.hidden = n.item ? !n.item.alwaysShow : !0), n.item ? n.separator = void 0 : n.separator && (n.hidden = !0), !this.sortByLabel) {
          const l = n.index && this._inputElements[n.index - 1] || void 0;
          l?.type === "separator" && !l.buttons && (i = l), i && !n.hidden && (n.separator = i, i = void 0);
        }
      });
    }
    return this._setElementsToTree(this._sortByLabel && e ? this._itemElements : this._elementTree), this._tree.layout(), !0;
  }
  toggleCheckbox() {
    this._elementCheckedEventBufferer.bufferEvents(() => {
      const e = this._tree.getFocus().filter((i) => i instanceof Ji), t = this._allVisibleChecked(e);
      for (const i of e)
        i.checkboxDisabled || (i.checked = !t);
    });
  }
  style(e) {
    this._tree.style(e);
  }
  toggleHover() {
    const e = this._tree.getFocus()[0];
    if (!e?.saneTooltip || !(e instanceof Ji))
      return;
    if (this._lastHover && !this._lastHover.isDisposed) {
      this._lastHover.dispose();
      return;
    }
    this.showHover(e);
    const t = new X();
    t.add(this._tree.onDidChangeFocus((i) => {
      i.elements[0] instanceof Ji && this.showHover(i.elements[0]);
    })), this._lastHover && t.add(this._lastHover), this._elementDisposable.add(t);
  }
  //#endregion
  //#region private methods
  _setElementsToTree(e) {
    const t = new Array();
    for (const i of e)
      i instanceof jd ? t.push({
        element: i,
        collapsible: !1,
        collapsed: !1,
        children: i.children.map((n) => ({
          element: n,
          collapsible: !1,
          collapsed: !1
        }))
      }) : t.push({
        element: i,
        collapsible: !1,
        collapsed: !1
      });
    this._tree.setChildren(null, t);
  }
  _allVisibleChecked(e, t = !0) {
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.hidden)
        if (o.checked)
          t = !0;
        else
          return !1;
    }
    return t;
  }
  _updateCheckedObservables() {
    xi((e) => {
      this._allVisibleCheckedObservable.set(this._allVisibleChecked(this._itemElements, !1), e);
      const t = this._itemElements.filter((i) => i.checked).length;
      this._checkedCountObservable.set(t, e), this._checkedElementsObservable.set(this.getCheckedElements(), e);
    });
  }
  /**
   * Disposes of the hover and shows a new one for the given index if it has a tooltip.
   * @param element The element to show the hover for
   */
  showHover(e) {
    this._lastHover && !this._lastHover.isDisposed && (this.hoverDelegate.onDidHideHover?.(), this._lastHover?.dispose()), !(!e.element || !e.saneTooltip) && (this._lastHover = this.hoverDelegate.showHover({
      content: e.saneTooltip,
      target: e.element,
      linkHandler: (t) => {
        this.linkOpenerDelegate(t);
      },
      appearance: {
        showPointer: !0
      },
      container: this._container,
      position: {
        hoverPosition: 1
        /* HoverPosition.RIGHT */
      }
    }, !1));
  }
};
AS([
  oi
], n_.prototype, "onDidChangeFocus", null);
AS([
  oi
], n_.prototype, "onDidChangeSelection", null);
n_ = AS([
  Ok(4, ke),
  Ok(5, Lo)
], n_);
function cie(s, e) {
  const { text: t, iconOffsets: i } = e;
  if (!i || i.length === 0)
    return oO(s, t);
  const n = _0(t, " "), o = t.length - n.length, r = oO(s, n);
  if (r)
    for (const a of r) {
      const l = i[a.start + o] + o;
      a.start += l, a.end += l;
    }
  return r;
}
function oO(s, e) {
  const t = e.toLowerCase().indexOf(s.toLowerCase());
  return t !== -1 ? [{ start: t, end: t + s.length }] : null;
}
function die(s, e, t) {
  const i = s.labelHighlights || [], n = e.labelHighlights || [];
  return i.length && !n.length ? -1 : !i.length && n.length ? 1 : i.length === 0 && n.length === 0 ? 0 : oie(s.saneSortLabel, e.saneSortLabel, t);
}
const s8 = {
  weight: 200,
  when: ne.and(ne.equals(
    DW,
    "quickPick"
    /* QuickInputType.QuickPick */
  ), Oee),
  metadata: { description: f("quickPick", "Used while in the context of the quick pick. If you change one keybinding for this command, you should change all of the other keybindings (modifier variants) of this command as well.") }
};
function gs(s, e = {}) {
  Hn.registerCommandAndKeybindingRule({
    ...s8,
    ...s,
    secondary: hie(s.primary, s.secondary ?? [], e)
  });
}
const cv = ze ? 256 : 2048;
function hie(s, e, t = {}) {
  return t.withAltMod && e.push(512 + s), t.withCtrlMod && (e.push(cv + s), t.withAltMod && e.push(512 + cv + s)), t.withCmdMod && ze && (e.push(2048 + s), t.withCtrlMod && e.push(2304 + s), t.withAltMod && (e.push(2560 + s), t.withCtrlMod && e.push(2816 + s))), e;
}
function Os(s, e) {
  return (t) => {
    const i = t.get(Q_).currentQuickInput;
    if (i)
      return e && i.quickNavigate ? i.focus(e) : i.focus(s);
  };
}
gs({ id: "quickInput.pageNext", primary: 12, handler: Os(yt.NextPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
gs({ id: "quickInput.pagePrevious", primary: 11, handler: Os(yt.PreviousPage) }, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
gs({ id: "quickInput.first", primary: cv + 14, handler: Os(yt.First) }, { withAltMod: !0, withCmdMod: !0 });
gs({ id: "quickInput.last", primary: cv + 13, handler: Os(yt.Last) }, { withAltMod: !0, withCmdMod: !0 });
gs({ id: "quickInput.next", primary: 18, handler: Os(yt.Next) }, { withCtrlMod: !0 });
gs({ id: "quickInput.previous", primary: 16, handler: Os(yt.Previous) }, { withCtrlMod: !0 });
const rO = f("quickInput.nextSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the next item. If we are not in quick access mode, this will navigate to the next separator."), aO = f("quickInput.previousSeparatorWithQuickAccessFallback", "If we're in quick access mode, this will navigate to the previous item. If we are not in quick access mode, this will navigate to the previous separator.");
ze ? (gs({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 2066,
  handler: Os(yt.NextSeparator, yt.Next),
  metadata: { description: rO }
}), gs({
  id: "quickInput.nextSeparator",
  primary: 2578,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2322
    /* KeyCode.DownArrow */
  ],
  handler: Os(yt.NextSeparator)
}, { withCtrlMod: !0 }), gs({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 2064,
  handler: Os(yt.PreviousSeparator, yt.Previous),
  metadata: { description: aO }
}), gs({
  id: "quickInput.previousSeparator",
  primary: 2576,
  // Since macOS has the cmd key as the primary modifier, we need to add this additional
  // keybinding to capture cmd+ctrl+upArrow
  secondary: [
    2320
    /* KeyCode.UpArrow */
  ],
  handler: Os(yt.PreviousSeparator)
}, { withCtrlMod: !0 })) : (gs({
  id: "quickInput.nextSeparatorWithQuickAccessFallback",
  primary: 530,
  handler: Os(yt.NextSeparator, yt.Next),
  metadata: { description: rO }
}), gs({
  id: "quickInput.nextSeparator",
  primary: 2578,
  handler: Os(yt.NextSeparator)
}), gs({
  id: "quickInput.previousSeparatorWithQuickAccessFallback",
  primary: 528,
  handler: Os(yt.PreviousSeparator, yt.Previous),
  metadata: { description: aO }
}), gs({
  id: "quickInput.previousSeparator",
  primary: 2576,
  handler: Os(yt.PreviousSeparator)
}));
gs({
  id: "quickInput.acceptInBackground",
  // If we are in the quick pick but the input box is not focused or our cursor is at the end of the input box
  when: ne.and(s8.when, ne.or(YW.negate(), Wee)),
  primary: 17,
  // Need a little extra weight to ensure this keybinding is preferred over the default cmd+alt+right arrow keybinding
  // https://github.com/microsoft/vscode/blob/1451e4fbbbf074a4355cc537c35b547b80ce1c52/src/vs/workbench/browser/parts/editor/editorActions.ts#L1178-L1195
  weight: 250,
  handler: (s) => {
    s.get(Q_).currentQuickInput?.accept(!0);
  }
}, { withAltMod: !0, withCtrlMod: !0, withCmdMod: !0 });
var uie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Jy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Hk;
const hs = de;
var Ph;
let Wk = (Ph = class extends V {
  // Max total width of quick input widget
  get currentQuickInput() {
    return this.controller ?? void 0;
  }
  get container() {
    return this._container;
  }
  constructor(e, t, i, n) {
    super(), this.options = e, this.layoutService = t, this.instantiationService = i, this.contextKeyService = n, this.enabled = !0, this.onDidAcceptEmitter = this._register(new B()), this.onDidCustomEmitter = this._register(new B()), this.onDidTriggerButtonEmitter = this._register(new B()), this.keyMods = { ctrlCmd: !1, alt: !1 }, this.controller = null, this.onShowEmitter = this._register(new B()), this.onShow = this.onShowEmitter.event, this.onHideEmitter = this._register(new B()), this.onHide = this.onHideEmitter.event, this.inQuickInputContext = Fee.bindTo(this.contextKeyService), this.quickInputTypeContext = Pee.bindTo(this.contextKeyService), this.endOfQuickInputBoxContext = Hee.bindTo(this.contextKeyService), this.idPrefix = e.idPrefix, this._container = e.container, this.styles = e.styles, this._register(te.runAndSubscribe(S0, ({ window: o, disposables: r }) => this.registerKeyModsListeners(o, r), { window: vt, disposables: this._store })), this._register(T6((o) => {
      this.ui && fe(this.ui.container) === o && (this.reparentUI(this.layoutService.mainContainer), this.layout(this.layoutService.mainContainerDimension, this.layoutService.mainContainerOffset.quickPickTop));
    }));
  }
  registerKeyModsListeners(e, t) {
    const i = (n) => {
      this.keyMods.ctrlCmd = n.ctrlKey || n.metaKey, this.keyMods.alt = n.altKey;
    };
    for (const n of [ee.KEY_DOWN, ee.KEY_UP, ee.MOUSE_DOWN])
      t.add(U(e, n, i, !0));
  }
  getUI(e) {
    if (this.ui)
      return e && fe(this._container) !== fe(this.layoutService.activeContainer) && (this.reparentUI(this.layoutService.activeContainer), this.layout(this.layoutService.activeContainerDimension, this.layoutService.activeContainerOffset.quickPickTop)), this.ui;
    const t = K(this._container, hs(".quick-input-widget.show-file-icons"));
    t.tabIndex = -1, t.style.display = "none";
    const i = xo(t), n = K(t, hs(".quick-input-titlebar")), o = this._register(new wo(n, { hoverDelegate: this.options.hoverDelegate }));
    o.domNode.classList.add("quick-input-left-action-bar");
    const r = K(n, hs(".quick-input-title")), a = this._register(new wo(n, { hoverDelegate: this.options.hoverDelegate }));
    a.domNode.classList.add("quick-input-right-action-bar");
    const l = K(t, hs(".quick-input-header")), c = K(l, hs("input.quick-input-check-all"));
    c.type = "checkbox", c.setAttribute("aria-label", f("quickInput.checkAll", "Toggle all checkboxes")), this._register(Xt(c, ee.CHANGE, (H) => {
      const J = c.checked;
      W.setAllVisibleChecked(J);
    })), this._register(U(c, ee.CLICK, (H) => {
      (H.x || H.y) && g.setFocus();
    }));
    const d = K(l, hs(".quick-input-description")), h = K(l, hs(".quick-input-and-message")), u = K(h, hs(".quick-input-filter")), g = this._register(new qee(u, this.styles.inputBox, this.styles.toggle));
    g.setAttribute("aria-describedby", `${this.idPrefix}message`);
    const m = K(u, hs(".quick-input-visible-count"));
    m.setAttribute("aria-live", "polite"), m.setAttribute("aria-atomic", "true");
    const p = new kk(m, { countFormat: f({ key: "quickInput.visibleCount", comment: ["This tells the user how many items are shown in a list of items to select from. The items can be anything. Currently not visible, but read by screen readers."] }, "{0} Results") }, this.styles.countBadge), A = K(u, hs(".quick-input-count"));
    A.setAttribute("aria-live", "polite");
    const _ = new kk(A, { countFormat: f({ key: "quickInput.countSelected", comment: ["This tells the user how many items are selected in a list of items to select from. The items can be anything."] }, "{0} Selected") }, this.styles.countBadge), b = this._register(new wo(l, { hoverDelegate: this.options.hoverDelegate }));
    b.domNode.classList.add("quick-input-inline-action-bar");
    const C = K(l, hs(".quick-input-action")), w = this._register(new Lk(C, this.styles.button));
    w.label = f("ok", "OK"), this._register(w.onDidClick((H) => {
      this.onDidAcceptEmitter.fire();
    }));
    const S = K(l, hs(".quick-input-action")), x = this._register(new Lk(S, { ...this.styles.button, supportIcons: !0 }));
    x.label = f("custom", "Custom"), this._register(x.onDidClick((H) => {
      this.onDidCustomEmitter.fire();
    }));
    const y = K(h, hs(`#${this.idPrefix}message.quick-input-message`)), D = this._register(new Dk(t, this.styles.progressBar));
    D.getContainer().classList.add("quick-input-progress");
    const I = K(t, hs(".quick-input-html-widget"));
    I.tabIndex = -1;
    const Q = K(t, hs(".quick-input-description")), P = this.idPrefix + "list", W = this._register(this.instantiationService.createInstance(n_, t, this.options.hoverDelegate, this.options.linkOpenerDelegate, P));
    g.setAttribute("aria-controls", P), this._register(W.onDidChangeFocus(() => {
      g.setAttribute("aria-activedescendant", W.getActiveDescendant() ?? "");
    })), this._register(W.onChangedAllVisibleChecked((H) => {
      c.checked = H;
    })), this._register(W.onChangedVisibleCount((H) => {
      p.setCount(H);
    })), this._register(W.onChangedCheckedCount((H) => {
      _.setCount(H);
    })), this._register(W.onLeave(() => {
      setTimeout(() => {
        this.controller && (g.setFocus(), this.controller instanceof qC && this.controller.canSelectMany && W.clearFocus());
      }, 0);
    }));
    const j = Wl(t);
    return this._register(j), this._register(U(t, ee.FOCUS, (H) => {
      const J = this.getUI();
      if (yi(H.relatedTarget, J.inputContainer)) {
        const se = J.inputBox.isSelectionAtEnd();
        this.endOfQuickInputBoxContext.get() !== se && this.endOfQuickInputBoxContext.set(se);
      }
      yi(H.relatedTarget, J.container) || (this.inQuickInputContext.set(!0), this.previousFocusElement = Bi(H.relatedTarget) ? H.relatedTarget : void 0);
    }, !0)), this._register(j.onDidBlur(() => {
      !this.getUI().ignoreFocusOut && !this.options.ignoreFocusOut() && this.hide(sm.Blur), this.inQuickInputContext.set(!1), this.endOfQuickInputBoxContext.set(!1), this.previousFocusElement = void 0;
    })), this._register(g.onKeyDown((H) => {
      const J = this.getUI().inputBox.isSelectionAtEnd();
      this.endOfQuickInputBoxContext.get() !== J && this.endOfQuickInputBoxContext.set(J);
    })), this._register(U(t, ee.FOCUS, (H) => {
      g.setFocus();
    })), this._register(Xt(t, ee.KEY_DOWN, (H) => {
      if (!yi(H.target, I))
        switch (H.keyCode) {
          case 3:
            Ve.stop(H, !0), this.enabled && this.onDidAcceptEmitter.fire();
            break;
          case 9:
            Ve.stop(H, !0), this.hide(sm.Gesture);
            break;
          case 2:
            if (!H.altKey && !H.ctrlKey && !H.metaKey) {
              const J = [
                ".quick-input-list .monaco-action-bar .always-visible",
                ".quick-input-list-entry:hover .monaco-action-bar",
                ".monaco-list-row.focused .monaco-action-bar"
              ];
              if (t.classList.contains("show-checkboxes") ? J.push("input") : J.push("input[type=text]"), this.getUI().list.displayed && J.push(".monaco-list"), this.getUI().message && J.push(".quick-input-message a"), this.getUI().widget) {
                if (yi(H.target, this.getUI().widget))
                  break;
                J.push(".quick-input-html-widget");
              }
              const se = t.querySelectorAll(J.join(", "));
              H.shiftKey && H.target === se[0] ? (Ve.stop(H, !0), W.clearFocus()) : !H.shiftKey && yi(H.target, se[se.length - 1]) && (Ve.stop(H, !0), se[0].focus());
            }
            break;
          case 10:
            H.ctrlKey && (Ve.stop(H, !0), this.getUI().list.toggleHover());
            break;
        }
    })), this.ui = {
      container: t,
      styleSheet: i,
      leftActionBar: o,
      titleBar: n,
      title: r,
      description1: Q,
      description2: d,
      widget: I,
      rightActionBar: a,
      inlineActionBar: b,
      checkAll: c,
      inputContainer: h,
      filterContainer: u,
      inputBox: g,
      visibleCountContainer: m,
      visibleCount: p,
      countContainer: A,
      count: _,
      okContainer: C,
      ok: w,
      message: y,
      customButtonContainer: S,
      customButton: x,
      list: W,
      progressBar: D,
      onDidAccept: this.onDidAcceptEmitter.event,
      onDidCustom: this.onDidCustomEmitter.event,
      onDidTriggerButton: this.onDidTriggerButtonEmitter.event,
      ignoreFocusOut: !1,
      keyMods: this.keyMods,
      show: (H) => this.show(H),
      hide: () => this.hide(),
      setVisibilities: (H) => this.setVisibilities(H),
      setEnabled: (H) => this.setEnabled(H),
      setContextKey: (H) => this.options.setContextKey(H),
      linkOpenerDelegate: (H) => this.options.linkOpenerDelegate(H)
    }, this.updateStyles(), this.ui;
  }
  reparentUI(e) {
    this.ui && (this._container = e, K(this._container, this.ui.container));
  }
  pick(e, t = {}, i = ct.None) {
    return new Promise((n, o) => {
      let r = (d) => {
        r = n, t.onKeyMods?.(a.keyMods), n(d);
      };
      if (i.isCancellationRequested) {
        r(void 0);
        return;
      }
      const a = this.createQuickPick({ useSeparators: !0 });
      let l;
      const c = [
        a,
        a.onDidAccept(() => {
          if (a.canSelectMany)
            r(a.selectedItems.slice()), a.hide();
          else {
            const d = a.activeItems[0];
            d && (r(d), a.hide());
          }
        }),
        a.onDidChangeActive((d) => {
          const h = d[0];
          h && t.onDidFocus && t.onDidFocus(h);
        }),
        a.onDidChangeSelection((d) => {
          if (!a.canSelectMany) {
            const h = d[0];
            h && (r(h), a.hide());
          }
        }),
        a.onDidTriggerItemButton((d) => t.onDidTriggerItemButton && t.onDidTriggerItemButton({
          ...d,
          removeItem: () => {
            const h = a.items.indexOf(d.item);
            if (h !== -1) {
              const u = a.items.slice(), g = u.splice(h, 1), m = a.activeItems.filter((A) => A !== g[0]), p = a.keepScrollPosition;
              a.keepScrollPosition = !0, a.items = u, m && (a.activeItems = m), a.keepScrollPosition = p;
            }
          }
        })),
        a.onDidTriggerSeparatorButton((d) => t.onDidTriggerSeparatorButton?.(d)),
        a.onDidChangeValue((d) => {
          l && !d && (a.activeItems.length !== 1 || a.activeItems[0] !== l) && (a.activeItems = [l]);
        }),
        i.onCancellationRequested(() => {
          a.hide();
        }),
        a.onDidHide(() => {
          Ct(c), r(void 0);
        })
      ];
      a.title = t.title, t.value && (a.value = t.value), a.canSelectMany = !!t.canPickMany, a.placeholder = t.placeHolder, a.ignoreFocusOut = !!t.ignoreFocusLost, a.matchOnDescription = !!t.matchOnDescription, a.matchOnDetail = !!t.matchOnDetail, a.matchOnLabel = t.matchOnLabel === void 0 || t.matchOnLabel, a.quickNavigate = t.quickNavigate, a.hideInput = !!t.hideInput, a.contextKey = t.contextKey, a.busy = !0, Promise.all([e, t.activeItem]).then(([d, h]) => {
        l = h, a.busy = !1, a.items = d, a.canSelectMany && (a.selectedItems = d.filter((u) => u.type !== "separator" && u.picked)), l && (a.activeItems = [l]);
      }), a.show(), Promise.resolve(e).then(void 0, (d) => {
        o(d), a.hide();
      });
    });
  }
  createQuickPick(e = { useSeparators: !1 }) {
    const t = this.getUI(!0);
    return new qC(t);
  }
  createInputBox() {
    const e = this.getUI(!0);
    return new Vee(e);
  }
  show(e) {
    const t = this.getUI(!0);
    this.onShowEmitter.fire();
    const i = this.controller;
    this.controller = e, i?.didHide(), this.setEnabled(!0), t.leftActionBar.clear(), t.title.textContent = "", t.description1.textContent = "", t.description2.textContent = "", Rn(t.widget), t.rightActionBar.clear(), t.inlineActionBar.clear(), t.checkAll.checked = !1, t.inputBox.placeholder = "", t.inputBox.password = !1, t.inputBox.showDecoration(ii.Ignore), t.visibleCount.setCount(0), t.count.setCount(0), Rn(t.message), t.progressBar.stop(), t.list.setElements([]), t.list.matchOnDescription = !1, t.list.matchOnDetail = !1, t.list.matchOnLabel = !0, t.list.sortByLabel = !0, t.ignoreFocusOut = !1, t.inputBox.toggles = void 0;
    const n = this.options.backKeybindingLabel();
    xk.tooltip = n ? f("quickInput.backWithKeybinding", "Back ({0})", n) : f("quickInput.back", "Back"), t.container.style.display = "", this.updateLayout(), t.inputBox.setFocus(), this.quickInputTypeContext.set(e.type);
  }
  isVisible() {
    return !!this.ui && this.ui.container.style.display !== "none";
  }
  setVisibilities(e) {
    const t = this.getUI();
    t.title.style.display = e.title ? "" : "none", t.description1.style.display = e.description && (e.inputBox || e.checkAll) ? "" : "none", t.description2.style.display = e.description && !(e.inputBox || e.checkAll) ? "" : "none", t.checkAll.style.display = e.checkAll ? "" : "none", t.inputContainer.style.display = e.inputBox ? "" : "none", t.filterContainer.style.display = e.inputBox ? "" : "none", t.visibleCountContainer.style.display = e.visibleCount ? "" : "none", t.countContainer.style.display = e.count ? "" : "none", t.okContainer.style.display = e.ok ? "" : "none", t.customButtonContainer.style.display = e.customButton ? "" : "none", t.message.style.display = e.message ? "" : "none", t.progressBar.getContainer().style.display = e.progressBar ? "" : "none", t.list.displayed = !!e.list, t.container.classList.toggle("show-checkboxes", !!e.checkBox), t.container.classList.toggle("hidden-input", !e.inputBox && !e.description), this.updateLayout();
  }
  setEnabled(e) {
    if (e !== this.enabled) {
      this.enabled = e;
      for (const t of this.getUI().leftActionBar.viewItems)
        t.action.enabled = e;
      for (const t of this.getUI().rightActionBar.viewItems)
        t.action.enabled = e;
      this.getUI().checkAll.disabled = !e, this.getUI().inputBox.enabled = e, this.getUI().ok.enabled = e, this.getUI().list.enabled = e;
    }
  }
  hide(e) {
    const t = this.controller;
    if (!t)
      return;
    t.willHide(e);
    const i = this.ui?.container, n = i && !QH(i);
    if (this.controller = null, this.onHideEmitter.fire(), i && (i.style.display = "none"), !n) {
      let o = this.previousFocusElement;
      for (; o && !o.offsetParent; )
        o = o.parentElement ?? void 0;
      o?.offsetParent ? (o.focus(), this.previousFocusElement = void 0) : this.options.returnFocus();
    }
    t.didHide(e);
  }
  layout(e, t) {
    this.dimension = e, this.titleBarOffset = t, this.updateLayout();
  }
  updateLayout() {
    if (this.ui && this.isVisible()) {
      this.ui.container.style.top = `${this.titleBarOffset}px`;
      const e = this.ui.container.style, t = Math.min(this.dimension.width * 0.62, Hk.MAX_WIDTH);
      e.width = t + "px", e.marginLeft = "-" + t / 2 + "px", this.ui.inputBox.layout(), this.ui.list.layout(this.dimension && this.dimension.height * 0.4);
    }
  }
  applyStyles(e) {
    this.styles = e, this.updateStyles();
  }
  updateStyles() {
    if (this.ui) {
      const { quickInputTitleBackground: e, quickInputBackground: t, quickInputForeground: i, widgetBorder: n, widgetShadow: o } = this.styles.widget;
      this.ui.titleBar.style.backgroundColor = e ?? "", this.ui.container.style.backgroundColor = t ?? "", this.ui.container.style.color = i ?? "", this.ui.container.style.border = n ? `1px solid ${n}` : "", this.ui.container.style.boxShadow = o ? `0 0 8px 2px ${o}` : "", this.ui.list.style(this.styles.list);
      const r = [];
      this.styles.pickerGroup.pickerGroupBorder && r.push(`.quick-input-list .quick-input-list-entry { border-top-color:  ${this.styles.pickerGroup.pickerGroupBorder}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(`.quick-input-list .quick-input-list-separator { color:  ${this.styles.pickerGroup.pickerGroupForeground}; }`), this.styles.pickerGroup.pickerGroupForeground && r.push(".quick-input-list .quick-input-list-separator-as-item { color: var(--vscode-descriptionForeground); }"), (this.styles.keybindingLabel.keybindingLabelBackground || this.styles.keybindingLabel.keybindingLabelBorder || this.styles.keybindingLabel.keybindingLabelBottomBorder || this.styles.keybindingLabel.keybindingLabelShadow || this.styles.keybindingLabel.keybindingLabelForeground) && (r.push(".quick-input-list .monaco-keybinding > .monaco-keybinding-key {"), this.styles.keybindingLabel.keybindingLabelBackground && r.push(`background-color: ${this.styles.keybindingLabel.keybindingLabelBackground};`), this.styles.keybindingLabel.keybindingLabelBorder && r.push(`border-color: ${this.styles.keybindingLabel.keybindingLabelBorder};`), this.styles.keybindingLabel.keybindingLabelBottomBorder && r.push(`border-bottom-color: ${this.styles.keybindingLabel.keybindingLabelBottomBorder};`), this.styles.keybindingLabel.keybindingLabelShadow && r.push(`box-shadow: inset 0 -1px 0 ${this.styles.keybindingLabel.keybindingLabelShadow};`), this.styles.keybindingLabel.keybindingLabelForeground && r.push(`color: ${this.styles.keybindingLabel.keybindingLabelForeground};`), r.push("}"));
      const a = r.join(`
`);
      a !== this.ui.styleSheet.textContent && (this.ui.styleSheet.textContent = a);
    }
  }
}, Hk = Ph, Ph.MAX_WIDTH = 600, Ph);
Wk = Hk = uie([
  Jy(1, wd),
  Jy(2, ke),
  Jy(3, Se)
], Wk);
var gie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, np = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Vk = class extends XG {
  get controller() {
    return this._controller || (this._controller = this._register(this.createController())), this._controller;
  }
  get hasController() {
    return !!this._controller;
  }
  get currentQuickInput() {
    return this.controller.currentQuickInput;
  }
  get quickAccess() {
    return this._quickAccess || (this._quickAccess = this._register(this.instantiationService.createInstance(yk))), this._quickAccess;
  }
  constructor(e, t, i, n, o) {
    super(i), this.instantiationService = e, this.contextKeyService = t, this.layoutService = n, this.configurationService = o, this._onShow = this._register(new B()), this._onHide = this._register(new B()), this.contexts = /* @__PURE__ */ new Map();
  }
  createController(e = this.layoutService, t) {
    const i = {
      idPrefix: "quickInput_",
      container: e.activeContainer,
      ignoreFocusOut: () => !1,
      backKeybindingLabel: () => {
      },
      setContextKey: (o) => this.setContextKey(o),
      linkOpenerDelegate: (o) => {
        this.instantiationService.invokeFunction((r) => {
          r.get(lr).open(o, { allowCommands: !0, fromUserGesture: !0 });
        });
      },
      returnFocus: () => e.focus(),
      styles: this.computeStyles(),
      hoverDelegate: this._register(this.instantiationService.createInstance(Ek))
    }, n = this._register(this.instantiationService.createInstance(Wk, {
      ...i,
      ...t
    }));
    return n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop), this._register(e.onDidLayoutActiveContainer((o) => {
      fe(e.activeContainer) === fe(n.container) && n.layout(o, e.activeContainerOffset.quickPickTop);
    })), this._register(e.onDidChangeActiveContainer(() => {
      n.isVisible() || n.layout(e.activeContainerDimension, e.activeContainerOffset.quickPickTop);
    })), this._register(n.onShow(() => {
      this.resetContextKeys(), this._onShow.fire();
    })), this._register(n.onHide(() => {
      this.resetContextKeys(), this._onHide.fire();
    })), n;
  }
  setContextKey(e) {
    let t;
    e && (t = this.contexts.get(e), t || (t = new le(e, !1).bindTo(this.contextKeyService), this.contexts.set(e, t))), !(t && t.get()) && (this.resetContextKeys(), t?.set(!0));
  }
  resetContextKeys() {
    this.contexts.forEach((e) => {
      e.get() && e.reset();
    });
  }
  pick(e, t, i = ct.None) {
    return this.controller.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.controller.createQuickPick(e);
  }
  createInputBox() {
    return this.controller.createInputBox();
  }
  updateStyles() {
    this.hasController && this.controller.applyStyles(this.computeStyles());
  }
  computeStyles() {
    return {
      widget: {
        quickInputBackground: oe(I2),
        quickInputForeground: oe(bK),
        quickInputTitleBackground: oe(wK),
        widgetBorder: oe(nY),
        widgetShadow: oe(B_)
      },
      inputBox: HC,
      toggle: PC,
      countBadge: Y3,
      button: $$,
      progressBar: X$,
      keybindingLabel: q$,
      list: ym({
        listBackground: I2,
        listFocusBackground: yC,
        listFocusForeground: SC,
        // Look like focused when inactive.
        listInactiveFocusForeground: SC,
        listInactiveSelectionIconForeground: vN,
        listInactiveFocusBackground: yC,
        listFocusOutline: Kt,
        listInactiveFocusOutline: Kt
      }),
      pickerGroup: {
        pickerGroupBorder: oe(CK),
        pickerGroupForeground: oe(a3)
      }
    };
  }
};
Vk = gie([
  np(0, ke),
  np(1, Se),
  np(2, nn),
  np(3, wd),
  np(4, ht)
], Vk);
var o8 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sh = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let zk = class extends Vk {
  constructor(e, t, i, n, o, r) {
    super(t, i, n, new gL(e.getContainerDomNode(), o), r), this.host = void 0;
    const a = s_.get(e);
    if (a) {
      const l = a.widget;
      this.host = {
        _serviceBrand: void 0,
        get mainContainer() {
          return l.getDomNode();
        },
        getContainer() {
          return l.getDomNode();
        },
        whenContainerStylesLoaded() {
        },
        get containers() {
          return [l.getDomNode()];
        },
        get activeContainer() {
          return l.getDomNode();
        },
        get mainContainerDimension() {
          return e.getLayoutInfo();
        },
        get activeContainerDimension() {
          return e.getLayoutInfo();
        },
        get onDidLayoutMainContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutActiveContainer() {
          return e.onDidLayoutChange;
        },
        get onDidLayoutContainer() {
          return te.map(e.onDidLayoutChange, (c) => ({ container: l.getDomNode(), dimension: c }));
        },
        get onDidChangeActiveContainer() {
          return te.None;
        },
        get onDidAddContainer() {
          return te.None;
        },
        get mainContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        get activeContainerOffset() {
          return { top: 0, quickPickTop: 0 };
        },
        focus: () => e.focus()
      };
    } else
      this.host = void 0;
  }
  createController() {
    return super.createController(this.host);
  }
};
zk = o8([
  sh(1, ke),
  sh(2, Se),
  sh(3, nn),
  sh(4, Nt),
  sh(5, ht)
], zk);
let Uk = class {
  get activeService() {
    const e = this.codeEditorService.getFocusedCodeEditor();
    if (!e)
      throw new Error("Quick input service needs a focused editor to work.");
    let t = this.mapEditorToService.get(e);
    if (!t) {
      const i = t = this.instantiationService.createInstance(zk, e);
      this.mapEditorToService.set(e, t), Wf(e.onDidDispose)(() => {
        i.dispose(), this.mapEditorToService.delete(e);
      });
    }
    return t;
  }
  get currentQuickInput() {
    return this.activeService.currentQuickInput;
  }
  get quickAccess() {
    return this.activeService.quickAccess;
  }
  constructor(e, t) {
    this.instantiationService = e, this.codeEditorService = t, this.mapEditorToService = /* @__PURE__ */ new Map();
  }
  pick(e, t, i = ct.None) {
    return this.activeService.pick(e, t, i);
  }
  createQuickPick(e = { useSeparators: !1 }) {
    return this.activeService.createQuickPick(e);
  }
  createInputBox() {
    return this.activeService.createInputBox();
  }
};
Uk = o8([
  sh(0, ke),
  sh(1, Nt)
], Uk);
const O1 = class O1 {
  static get(e) {
    return e.getContribution(O1.ID);
  }
  constructor(e) {
    this.editor = e, this.widget = new Qk(this.editor);
  }
  dispose() {
    this.widget.dispose();
  }
};
O1.ID = "editor.controller.quickInput";
let s_ = O1;
const P1 = class P1 {
  constructor(e) {
    this.codeEditor = e, this.domNode = document.createElement("div"), this.codeEditor.addOverlayWidget(this);
  }
  getId() {
    return P1.ID;
  }
  getDomNode() {
    return this.domNode;
  }
  getPosition() {
    return {
      preference: 2
      /* OverlayWidgetPositionPreference.TOP_CENTER */
    };
  }
  dispose() {
    this.codeEditor.removeOverlayWidget(this);
  }
};
P1.ID = "editor.contrib.quickInputWidget";
let Qk = P1;
rs(
  s_.ID,
  s_,
  4
  /* EditorContributionInstantiation.Lazy */
);
class fie {
  constructor(e, t, i, n, o) {
    this._parsedThemeRuleBrand = void 0, this.token = e, this.index = t, this.fontStyle = i, this.foreground = n, this.background = o;
  }
}
function mie(s) {
  if (!s || !Array.isArray(s))
    return [];
  const e = [];
  let t = 0;
  for (let i = 0, n = s.length; i < n; i++) {
    const o = s[i];
    let r = -1;
    if (typeof o.fontStyle == "string") {
      r = 0;
      const c = o.fontStyle.split(" ");
      for (let d = 0, h = c.length; d < h; d++)
        switch (c[d]) {
          case "italic":
            r = r | 1;
            break;
          case "bold":
            r = r | 2;
            break;
          case "underline":
            r = r | 4;
            break;
          case "strikethrough":
            r = r | 8;
            break;
        }
    }
    let a = null;
    typeof o.foreground == "string" && (a = o.foreground);
    let l = null;
    typeof o.background == "string" && (l = o.background), e[t++] = new fie(o.token || "", i, r, a, l);
  }
  return e;
}
function pie(s, e) {
  s.sort((d, h) => {
    const u = Cie(d.token, h.token);
    return u !== 0 ? u : d.index - h.index;
  });
  let t = 0, i = "000000", n = "ffffff";
  for (; s.length >= 1 && s[0].token === ""; ) {
    const d = s.shift();
    d.fontStyle !== -1 && (t = d.fontStyle), d.foreground !== null && (i = d.foreground), d.background !== null && (n = d.background);
  }
  const o = new _ie();
  for (const d of e)
    o.getId(d);
  const r = o.getId(i), a = o.getId(n), l = new ST(t, r, a), c = new yT(l);
  for (let d = 0, h = s.length; d < h; d++) {
    const u = s[d];
    c.insert(u.token, u.fontStyle, o.getId(u.foreground), o.getId(u.background));
  }
  return new r8(o, c);
}
const Aie = /^#?([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$/;
class _ie {
  constructor() {
    this._lastColorId = 0, this._id2color = [], this._color2id = /* @__PURE__ */ new Map();
  }
  getId(e) {
    if (e === null)
      return 0;
    const t = e.match(Aie);
    if (!t)
      throw new Error("Illegal value for token color: " + e);
    e = t[1].toUpperCase();
    let i = this._color2id.get(e);
    return i || (i = ++this._lastColorId, this._color2id.set(e, i), this._id2color[i] = Y.fromHex("#" + e), i);
  }
  getColorMap() {
    return this._id2color.slice(0);
  }
}
class r8 {
  static createFromRawTokenTheme(e, t) {
    return this.createFromParsedTokenTheme(mie(e), t);
  }
  static createFromParsedTokenTheme(e, t) {
    return pie(e, t);
  }
  constructor(e, t) {
    this._colorMap = e, this._root = t, this._cache = /* @__PURE__ */ new Map();
  }
  getColorMap() {
    return this._colorMap.getColorMap();
  }
  _match(e) {
    return this._root.match(e);
  }
  match(e, t) {
    let i = this._cache.get(t);
    if (typeof i > "u") {
      const n = this._match(t), o = wie(t);
      i = (n.metadata | o << 8) >>> 0, this._cache.set(t, i);
    }
    return (i | e << 0) >>> 0;
  }
}
const bie = /\b(comment|string|regex|regexp)\b/;
function wie(s) {
  const e = s.match(bie);
  if (!e)
    return 0;
  switch (e[1]) {
    case "comment":
      return 1;
    case "string":
      return 2;
    case "regex":
      return 3;
    case "regexp":
      return 3;
  }
  throw new Error("Unexpected match for standard token type!");
}
function Cie(s, e) {
  return s < e ? -1 : s > e ? 1 : 0;
}
class ST {
  constructor(e, t, i) {
    this._themeTrieElementRuleBrand = void 0, this._fontStyle = e, this._foreground = t, this._background = i, this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
  clone() {
    return new ST(this._fontStyle, this._foreground, this._background);
  }
  acceptOverwrite(e, t, i) {
    e !== -1 && (this._fontStyle = e), t !== 0 && (this._foreground = t), i !== 0 && (this._background = i), this.metadata = (this._fontStyle << 11 | this._foreground << 15 | this._background << 24) >>> 0;
  }
}
class yT {
  constructor(e) {
    this._themeTrieElementBrand = void 0, this._mainRule = e, this._children = /* @__PURE__ */ new Map();
  }
  match(e) {
    if (e === "")
      return this._mainRule;
    const t = e.indexOf(".");
    let i, n;
    t === -1 ? (i = e, n = "") : (i = e.substring(0, t), n = e.substring(t + 1));
    const o = this._children.get(i);
    return typeof o < "u" ? o.match(n) : this._mainRule;
  }
  insert(e, t, i, n) {
    if (e === "") {
      this._mainRule.acceptOverwrite(t, i, n);
      return;
    }
    const o = e.indexOf(".");
    let r, a;
    o === -1 ? (r = e, a = "") : (r = e.substring(0, o), a = e.substring(o + 1));
    let l = this._children.get(r);
    typeof l > "u" && (l = new yT(this._mainRule.clone()), this._children.set(r, l)), l.insert(a, t, i, n);
  }
}
function vie(s) {
  const e = [];
  for (let t = 1, i = s.length; t < i; t++) {
    const n = s[t];
    e[t] = `.mtk${t} { color: ${n}; }`;
  }
  return e.push(".mtki { font-style: italic; }"), e.push(".mtkb { font-weight: bold; }"), e.push(".mtku { text-decoration: underline; text-underline-position: under; }"), e.push(".mtks { text-decoration: line-through; }"), e.push(".mtks.mtku { text-decoration: underline line-through; text-underline-position: under; }"), e.join(`
`);
}
const Sie = {
  base: "vs",
  inherit: !1,
  rules: [
    { token: "", foreground: "000000", background: "fffffe" },
    { token: "invalid", foreground: "cd3131" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "001188" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "delimiter.xml", foreground: "0000FF" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "FF0000" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "FF0000" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "attribute.value.number", foreground: "098658" },
    { token: "attribute.value.unit", foreground: "098658" },
    { token: "attribute.value.html", foreground: "0000FF" },
    { token: "attribute.value.xml", foreground: "0000FF" },
    { token: "string", foreground: "A31515" },
    { token: "string.html", foreground: "0000FF" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "string.yaml", foreground: "0451A5" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.json", foreground: "0451A5" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "keyword.flow.scss", foreground: "0000FF" },
    { token: "operator.scss", foreground: "666666" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [$o]: "#FFFFFE",
    [Fa]: "#000000",
    [X5]: "#E5EBF1",
    [z_]: "#D3D3D3",
    [U_]: "#939393",
    [Z5]: "#ADD6FF4D"
  }
}, yie = {
  base: "vs-dark",
  inherit: !1,
  rules: [
    { token: "", foreground: "D4D4D4", background: "1E1E1E" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "74B0DF" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "B5CEA8" },
    { token: "number.hex", foreground: "5BB498" },
    { token: "regexp", foreground: "B46695" },
    { token: "annotation", foreground: "cc6666" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "DCDCDC" },
    { token: "delimiter.html", foreground: "808080" },
    { token: "delimiter.xml", foreground: "808080" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "A79873" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "DD6A6F" },
    { token: "metatag.content.html", foreground: "9CDCFE" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key.json", foreground: "9CDCFE" },
    { token: "string.value.json", foreground: "CE9178" },
    { token: "attribute.name", foreground: "9CDCFE" },
    { token: "attribute.value", foreground: "CE9178" },
    { token: "attribute.value.number.css", foreground: "B5CEA8" },
    { token: "attribute.value.unit.css", foreground: "B5CEA8" },
    { token: "attribute.value.hex.css", foreground: "D4D4D4" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "keyword.json", foreground: "CE9178" },
    { token: "keyword.flow.scss", foreground: "569CD6" },
    { token: "operator.scss", foreground: "909090" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [$o]: "#1E1E1E",
    [Fa]: "#D4D4D4",
    [X5]: "#3A3D41",
    [z_]: "#404040",
    [U_]: "#707070",
    [Z5]: "#ADD6FF26"
  }
}, xie = {
  base: "hc-black",
  inherit: !1,
  rules: [
    { token: "", foreground: "FFFFFF", background: "000000" },
    { token: "invalid", foreground: "f44747" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "1AEBFF" },
    { token: "variable.parameter", foreground: "9CDCFE" },
    { token: "constant", foreground: "569CD6" },
    { token: "comment", foreground: "608B4E" },
    { token: "number", foreground: "FFFFFF" },
    { token: "regexp", foreground: "C0C0C0" },
    { token: "annotation", foreground: "569CD6" },
    { token: "type", foreground: "3DC9B0" },
    { token: "delimiter", foreground: "FFFF00" },
    { token: "delimiter.html", foreground: "FFFF00" },
    { token: "tag", foreground: "569CD6" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta", foreground: "D4D4D4" },
    { token: "meta.tag", foreground: "CE9178" },
    { token: "metatag", foreground: "569CD6" },
    { token: "metatag.content.html", foreground: "1AEBFF" },
    { token: "metatag.html", foreground: "569CD6" },
    { token: "metatag.xml", foreground: "569CD6" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "9CDCFE" },
    { token: "string.key", foreground: "9CDCFE" },
    { token: "string.value", foreground: "CE9178" },
    { token: "attribute.name", foreground: "569CD6" },
    { token: "attribute.value", foreground: "3FF23F" },
    { token: "string", foreground: "CE9178" },
    { token: "string.sql", foreground: "FF0000" },
    { token: "keyword", foreground: "569CD6" },
    { token: "keyword.flow", foreground: "C586C0" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "909090" },
    { token: "predefined.sql", foreground: "FF00FF" }
  ],
  colors: {
    [$o]: "#000000",
    [Fa]: "#FFFFFF",
    [z_]: "#FFFFFF",
    [U_]: "#FFFFFF"
  }
}, Eie = {
  base: "hc-light",
  inherit: !1,
  rules: [
    { token: "", foreground: "292929", background: "FFFFFF" },
    { token: "invalid", foreground: "B5200D" },
    { token: "emphasis", fontStyle: "italic" },
    { token: "strong", fontStyle: "bold" },
    { token: "variable", foreground: "264F70" },
    { token: "variable.predefined", foreground: "4864AA" },
    { token: "constant", foreground: "dd0000" },
    { token: "comment", foreground: "008000" },
    { token: "number", foreground: "098658" },
    { token: "number.hex", foreground: "3030c0" },
    { token: "regexp", foreground: "800000" },
    { token: "annotation", foreground: "808080" },
    { token: "type", foreground: "008080" },
    { token: "delimiter", foreground: "000000" },
    { token: "delimiter.html", foreground: "383838" },
    { token: "tag", foreground: "800000" },
    { token: "tag.id.pug", foreground: "4F76AC" },
    { token: "tag.class.pug", foreground: "4F76AC" },
    { token: "meta.scss", foreground: "800000" },
    { token: "metatag", foreground: "e00000" },
    { token: "metatag.content.html", foreground: "B5200D" },
    { token: "metatag.html", foreground: "808080" },
    { token: "metatag.xml", foreground: "808080" },
    { token: "metatag.php", fontStyle: "bold" },
    { token: "key", foreground: "863B00" },
    { token: "string.key.json", foreground: "A31515" },
    { token: "string.value.json", foreground: "0451A5" },
    { token: "attribute.name", foreground: "264F78" },
    { token: "attribute.value", foreground: "0451A5" },
    { token: "string", foreground: "A31515" },
    { token: "string.sql", foreground: "B5200D" },
    { token: "keyword", foreground: "0000FF" },
    { token: "keyword.flow", foreground: "AF00DB" },
    { token: "operator.sql", foreground: "778899" },
    { token: "operator.swift", foreground: "666666" },
    { token: "predefined.sql", foreground: "C700C7" }
  ],
  colors: {
    [$o]: "#FFFFFF",
    [Fa]: "#292929",
    [z_]: "#292929",
    [U_]: "#292929"
  }
}, Lie = {
  IconContribution: "base.contributions.icons"
};
var lO;
(function(s) {
  function e(t, i) {
    let n = t.defaults;
    for (; pe.isThemeIcon(n); ) {
      const o = ju.getIcon(n.id);
      if (!o)
        return;
      n = o.defaults;
    }
    return n;
  }
  s.getDefinition = e;
})(lO || (lO = {}));
var cO;
(function(s) {
  function e(i) {
    return {
      weight: i.weight,
      style: i.style,
      src: i.src.map((n) => ({ format: n.format, location: n.location.toString() }))
    };
  }
  s.toJSONObject = e;
  function t(i) {
    const n = (o) => _s(o) ? o : void 0;
    if (i && Array.isArray(i.src) && i.src.every((o) => _s(o.format) && _s(o.location)))
      return {
        weight: n(i.weight),
        style: n(i.style),
        src: i.src.map((o) => ({ format: o.format, location: _e.parse(o.location) }))
      };
  }
  s.fromJSONObject = t;
})(cO || (cO = {}));
class kie {
  constructor() {
    this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this.iconSchema = {
      definitions: {
        icons: {
          type: "object",
          properties: {
            fontId: { type: "string", description: f("iconDefinition.fontId", "The id of the font to use. If not set, the font that is defined first is used.") },
            fontCharacter: { type: "string", description: f("iconDefinition.fontCharacter", "The font character associated with the icon definition.") }
          },
          additionalProperties: !1,
          defaultSnippets: [{ body: { fontCharacter: "\\\\e030" } }]
        }
      },
      type: "object",
      properties: {}
    }, this.iconReferenceSchema = { type: "string", pattern: `^${pe.iconNameExpression}$`, enum: [], enumDescriptions: [] }, this.iconsById = {}, this.iconFontsById = {};
  }
  registerIcon(e, t, i, n) {
    const o = this.iconsById[e];
    if (o) {
      if (i && !o.description) {
        o.description = i, this.iconSchema.properties[e].markdownDescription = `${i} $(${e})`;
        const l = this.iconReferenceSchema.enum.indexOf(e);
        l !== -1 && (this.iconReferenceSchema.enumDescriptions[l] = i), this._onDidChange.fire();
      }
      return o;
    }
    const r = { id: e, description: i, defaults: t, deprecationMessage: n };
    this.iconsById[e] = r;
    const a = { $ref: "#/definitions/icons" };
    return n && (a.deprecationMessage = n), i && (a.markdownDescription = `${i}: $(${e})`), this.iconSchema.properties[e] = a, this.iconReferenceSchema.enum.push(e), this.iconReferenceSchema.enumDescriptions.push(i || ""), this._onDidChange.fire(), { id: e };
  }
  getIcons() {
    return Object.keys(this.iconsById).map((e) => this.iconsById[e]);
  }
  getIcon(e) {
    return this.iconsById[e];
  }
  getIconSchema() {
    return this.iconSchema;
  }
  toString() {
    const e = (o, r) => o.id.localeCompare(r.id), t = (o) => {
      for (; pe.isThemeIcon(o.defaults); )
        o = this.iconsById[o.defaults.id];
      return `codicon codicon-${o ? o.id : ""}`;
    }, i = [];
    i.push("| preview     | identifier                        | default codicon ID                | description"), i.push("| ----------- | --------------------------------- | --------------------------------- | --------------------------------- |");
    const n = Object.keys(this.iconsById).map((o) => this.iconsById[o]);
    for (const o of n.filter((r) => !!r.description).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|${pe.isThemeIcon(o.defaults) ? o.defaults.id : o.id}|${o.description || ""}|`);
    i.push("| preview     | identifier                        "), i.push("| ----------- | --------------------------------- |");
    for (const o of n.filter((r) => !pe.isThemeIcon(r.defaults)).sort(e))
      i.push(`|<i class="${t(o)}"></i>|${o.id}|`);
    return i.join(`
`);
  }
}
const ju = new kie();
ji.add(Lie.IconContribution, ju);
function Rt(s, e, t, i) {
  return ju.registerIcon(s, e, t, i);
}
function a8() {
  return ju;
}
function Die() {
  const s = gH();
  for (const e in s) {
    const t = "\\" + s[e].toString(16);
    ju.registerIcon(e, { fontCharacter: t });
  }
}
Die();
const l8 = "vscode://schemas/icons", c8 = ji.as(O0.JSONContribution);
c8.registerSchema(l8, ju.getIconSchema());
const dO = new zt(() => c8.notifySchemaChanged(l8), 200);
ju.onDidChange(() => {
  dO.isScheduled() || dO.schedule();
});
const Iie = Rt("widget-close", Z.close, f("widgetClose", "Icon for the close action in widgets."));
Rt("goto-previous-location", Z.arrowUp, f("previousChangeIcon", "Icon for goto previous editor location."));
Rt("goto-next-location", Z.arrowDown, f("nextChangeIcon", "Icon for goto next editor location."));
pe.modify(Z.sync, "spin");
pe.modify(Z.loading, "spin");
function Mie(s) {
  const e = new X(), t = e.add(new B()), i = a8();
  return e.add(i.onDidChange(() => t.fire())), s && e.add(s.onDidProductIconThemeChange(() => t.fire())), {
    dispose: () => e.dispose(),
    onDidChange: t.event,
    getCSS() {
      const n = s ? s.getProductIconTheme() : new d8(), o = {}, r = [], a = [];
      for (const l of i.getIcons()) {
        const c = n.getIcon(l);
        if (!c)
          continue;
        const d = c.font, h = `--vscode-icon-${l.id}-font-family`, u = `--vscode-icon-${l.id}-content`;
        d ? (o[d.id] = d.definition, a.push(`${h}: ${oy(d.id)};`, `${u}: '${c.fontCharacter}';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; font-family: ${oy(d.id)}; }`)) : (a.push(`${u}: '${c.fontCharacter}'; ${h}: 'codicon';`), r.push(`.codicon-${l.id}:before { content: '${c.fontCharacter}'; }`));
      }
      for (const l in o) {
        const c = o[l], d = c.weight ? `font-weight: ${c.weight};` : "", h = c.style ? `font-style: ${c.style};` : "", u = c.src.map((g) => `${Vl(g.location)} format('${g.format}')`).join(", ");
        r.push(`@font-face { src: ${u}; font-family: ${oy(l)};${d}${h} font-display: block; }`);
      }
      return r.push(`:root { ${a.join(" ")} }`), r.join(`
`);
    }
  };
}
class d8 {
  getIcon(e) {
    const t = a8();
    let i = e.defaults;
    for (; pe.isThemeIcon(i); ) {
      const n = t.getIcon(i.id);
      if (!n)
        return;
      i = n.defaults;
    }
    return i;
  }
}
const wc = "vs", Gp = "vs-dark", Lf = "hc-black", kf = "hc-light", h8 = ji.as(j5.ColorContribution), Nie = ji.as(D5.ThemingContribution);
class u8 {
  constructor(e, t) {
    this.semanticHighlighting = !1, this.themeData = t;
    const i = t.base;
    e.length > 0 ? (Bw(e) ? this.id = e : this.id = i + " " + e, this.themeName = e) : (this.id = i, this.themeName = i), this.colors = null, this.defaultColors = /* @__PURE__ */ Object.create(null), this._tokenTheme = null;
  }
  get base() {
    return this.themeData.base;
  }
  notifyBaseUpdated() {
    this.themeData.inherit && (this.colors = null, this._tokenTheme = null);
  }
  getColors() {
    if (!this.colors) {
      const e = /* @__PURE__ */ new Map();
      for (const t in this.themeData.colors)
        e.set(t, Y.fromHex(this.themeData.colors[t]));
      if (this.themeData.inherit) {
        const t = Gk(this.themeData.base);
        for (const i in t.colors)
          e.has(i) || e.set(i, Y.fromHex(t.colors[i]));
      }
      this.colors = e;
    }
    return this.colors;
  }
  getColor(e, t) {
    const i = this.getColors().get(e);
    if (i)
      return i;
    if (t !== !1)
      return this.getDefault(e);
  }
  getDefault(e) {
    let t = this.defaultColors[e];
    return t || (t = h8.resolveDefaultColor(e, this), this.defaultColors[e] = t, t);
  }
  defines(e) {
    return this.getColors().has(e);
  }
  get type() {
    switch (this.base) {
      case wc:
        return po.LIGHT;
      case Lf:
        return po.HIGH_CONTRAST_DARK;
      case kf:
        return po.HIGH_CONTRAST_LIGHT;
      default:
        return po.DARK;
    }
  }
  get tokenTheme() {
    if (!this._tokenTheme) {
      let e = [], t = [];
      if (this.themeData.inherit) {
        const o = Gk(this.themeData.base);
        e = o.rules, o.encodedTokensColors && (t = o.encodedTokensColors);
      }
      const i = this.themeData.colors["editor.foreground"], n = this.themeData.colors["editor.background"];
      if (i || n) {
        const o = { token: "" };
        i && (o.foreground = i), n && (o.background = n), e.push(o);
      }
      e = e.concat(this.themeData.rules), this.themeData.encodedTokensColors && (t = this.themeData.encodedTokensColors), this._tokenTheme = r8.createFromRawTokenTheme(e, t);
    }
    return this._tokenTheme;
  }
  getTokenStyleMetadata(e, t, i) {
    const o = this.tokenTheme._match([e].concat(t).join(".")).metadata, r = xr.getForeground(o), a = xr.getFontStyle(o);
    return {
      foreground: r,
      italic: !!(a & 1),
      bold: !!(a & 2),
      underline: !!(a & 4),
      strikethrough: !!(a & 8)
    };
  }
}
function Bw(s) {
  return s === wc || s === Gp || s === Lf || s === kf;
}
function Gk(s) {
  switch (s) {
    case wc:
      return Sie;
    case Gp:
      return yie;
    case Lf:
      return xie;
    case kf:
      return Eie;
  }
}
function Hb(s) {
  const e = Gk(s);
  return new u8(s, e);
}
class Tie extends V {
  constructor() {
    super(), this._onColorThemeChange = this._register(new B()), this.onDidColorThemeChange = this._onColorThemeChange.event, this._onProductIconThemeChange = this._register(new B()), this.onDidProductIconThemeChange = this._onProductIconThemeChange.event, this._environment = /* @__PURE__ */ Object.create(null), this._builtInProductIconTheme = new d8(), this._autoDetectHighContrast = !0, this._knownThemes = /* @__PURE__ */ new Map(), this._knownThemes.set(wc, Hb(wc)), this._knownThemes.set(Gp, Hb(Gp)), this._knownThemes.set(Lf, Hb(Lf)), this._knownThemes.set(kf, Hb(kf));
    const e = this._register(Mie(this));
    this._codiconCSS = e.getCSS(), this._themeCSS = "", this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._globalStyleElement = null, this._styleElements = [], this._colorMapOverride = null, this.setTheme(wc), this._onOSSchemeChanged(), this._register(e.onDidChange(() => {
      this._codiconCSS = e.getCSS(), this._updateCSS();
    })), SH(vt, "(forced-colors: active)", () => {
      this._onOSSchemeChanged();
    });
  }
  registerEditorContainer(e) {
    return rC(e) ? this._registerShadowDomContainer(e) : this._registerRegularEditorContainer();
  }
  _registerRegularEditorContainer() {
    return this._globalStyleElement || (this._globalStyleElement = xo(void 0, (e) => {
      e.className = "monaco-colors", e.textContent = this._allCSS;
    }), this._styleElements.push(this._globalStyleElement)), V.None;
  }
  _registerShadowDomContainer(e) {
    const t = xo(e, (i) => {
      i.className = "monaco-colors", i.textContent = this._allCSS;
    });
    return this._styleElements.push(t), {
      dispose: () => {
        for (let i = 0; i < this._styleElements.length; i++)
          if (this._styleElements[i] === t) {
            this._styleElements.splice(i, 1);
            return;
          }
      }
    };
  }
  defineTheme(e, t) {
    if (!/^[a-z0-9\-]+$/i.test(e))
      throw new Error("Illegal theme name!");
    if (!Bw(t.base) && !Bw(e))
      throw new Error("Illegal theme base!");
    this._knownThemes.set(e, new u8(e, t)), Bw(e) && this._knownThemes.forEach((i) => {
      i.base === e && i.notifyBaseUpdated();
    }), this._theme.themeName === e && this.setTheme(e);
  }
  getColorTheme() {
    return this._theme;
  }
  setColorMapOverride(e) {
    this._colorMapOverride = e, this._updateThemeOrColorMap();
  }
  setTheme(e) {
    let t;
    this._knownThemes.has(e) ? t = this._knownThemes.get(e) : t = this._knownThemes.get(wc), this._updateActualTheme(t);
  }
  _updateActualTheme(e) {
    !e || this._theme === e || (this._theme = e, this._updateThemeOrColorMap());
  }
  _onOSSchemeChanged() {
    if (this._autoDetectHighContrast) {
      const e = vt.matchMedia("(forced-colors: active)").matches;
      if (e !== Ca(this._theme.type)) {
        let t;
        P0(this._theme.type) ? t = e ? Lf : Gp : t = e ? kf : wc, this._updateActualTheme(this._knownThemes.get(t));
      }
    }
  }
  setAutoDetectHighContrast(e) {
    this._autoDetectHighContrast = e, this._onOSSchemeChanged();
  }
  _updateThemeOrColorMap() {
    const e = [], t = {}, i = {
      addRule: (r) => {
        t[r] || (e.push(r), t[r] = !0);
      }
    };
    Nie.getThemingParticipants().forEach((r) => r(this._theme, i, this._environment));
    const n = [];
    for (const r of h8.getColors()) {
      const a = this._theme.getColor(r.id, !0);
      a && n.push(`${fN(r.id)}: ${a.toString()};`);
    }
    i.addRule(`.monaco-editor, .monaco-diff-editor, .monaco-component { ${n.join(`
`)} }`);
    const o = this._colorMapOverride || this._theme.tokenTheme.getColorMap();
    i.addRule(vie(o)), this._themeCSS = e.join(`
`), this._updateCSS(), ci.setColorMap(o), this._onColorThemeChange.fire(this._theme);
  }
  _updateCSS() {
    this._allCSS = `${this._codiconCSS}
${this._themeCSS}`, this._styleElements.forEach((e) => e.textContent = this._allCSS);
  }
  getFileIconTheme() {
    return {
      hasFileIcons: !1,
      hasFolderIcons: !1,
      hidesExplorerArrows: !1
    };
  }
  getProductIconTheme() {
    return this._builtInProductIconTheme;
  }
}
const cr = We("themeService");
var Bie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qy = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let jk = class extends V {
  constructor(e, t, i) {
    super(), this._contextKeyService = e, this._layoutService = t, this._configurationService = i, this._accessibilitySupport = 0, this._onDidChangeScreenReaderOptimized = new B(), this._onDidChangeReducedMotion = new B(), this._onDidChangeLinkUnderline = new B(), this._accessibilityModeEnabledContext = O_.bindTo(this._contextKeyService);
    const n = () => this._accessibilityModeEnabledContext.set(this.isScreenReaderOptimized());
    this._register(this._configurationService.onDidChangeConfiguration((r) => {
      r.affectsConfiguration("editor.accessibilitySupport") && (n(), this._onDidChangeScreenReaderOptimized.fire()), r.affectsConfiguration("workbench.reduceMotion") && (this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._onDidChangeReducedMotion.fire());
    })), n(), this._register(this.onDidChangeScreenReaderOptimized(() => n()));
    const o = vt.matchMedia("(prefers-reduced-motion: reduce)");
    this._systemMotionReduced = o.matches, this._configMotionReduced = this._configurationService.getValue("workbench.reduceMotion"), this._linkUnderlinesEnabled = this._configurationService.getValue("accessibility.underlineLinks"), this.initReducedMotionListeners(o), this.initLinkUnderlineListeners();
  }
  initReducedMotionListeners(e) {
    this._register(U(e, "change", () => {
      this._systemMotionReduced = e.matches, this._configMotionReduced === "auto" && this._onDidChangeReducedMotion.fire();
    }));
    const t = () => {
      const i = this.isMotionReduced();
      this._layoutService.mainContainer.classList.toggle("reduce-motion", i), this._layoutService.mainContainer.classList.toggle("enable-motion", !i);
    };
    t(), this._register(this.onDidChangeReducedMotion(() => t()));
  }
  initLinkUnderlineListeners() {
    this._register(this._configurationService.onDidChangeConfiguration((t) => {
      if (t.affectsConfiguration("accessibility.underlineLinks")) {
        const i = this._configurationService.getValue("accessibility.underlineLinks");
        this._linkUnderlinesEnabled = i, this._onDidChangeLinkUnderline.fire();
      }
    }));
    const e = () => {
      const t = this._linkUnderlinesEnabled;
      this._layoutService.mainContainer.classList.toggle("underline-links", t);
    };
    e(), this._register(this.onDidChangeLinkUnderlines(() => e()));
  }
  onDidChangeLinkUnderlines(e) {
    return this._onDidChangeLinkUnderline.event(e);
  }
  get onDidChangeScreenReaderOptimized() {
    return this._onDidChangeScreenReaderOptimized.event;
  }
  isScreenReaderOptimized() {
    const e = this._configurationService.getValue("editor.accessibilitySupport");
    return e === "on" || e === "auto" && this._accessibilitySupport === 2;
  }
  get onDidChangeReducedMotion() {
    return this._onDidChangeReducedMotion.event;
  }
  isMotionReduced() {
    const e = this._configMotionReduced;
    return e === "on" || e === "auto" && this._systemMotionReduced;
  }
  getAccessibilitySupport() {
    return this._accessibilitySupport;
  }
};
jk = Bie([
  qy(0, Se),
  qy(1, wd),
  qy(2, ht)
], jk);
var _S = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ya = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, vg, bp;
let Yk = class {
  constructor(e, t, i) {
    this._commandService = e, this._keybindingService = t, this._hiddenStates = new Kk(i);
  }
  createMenu(e, t, i) {
    return new dv(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t);
  }
  getMenuActions(e, t, i) {
    const n = new dv(e, this._hiddenStates, { emitEventsForSubmenuChanges: !1, eventDebounceDelay: 50, ...i }, this._commandService, this._keybindingService, t), o = n.getActions(i);
    return n.dispose(), o;
  }
  resetHiddenStates(e) {
    this._hiddenStates.reset(e);
  }
};
Yk = _S([
  ya(0, bi),
  ya(1, bt),
  ya(2, Jl)
], Yk);
var Hh;
let Kk = (Hh = class {
  constructor(e) {
    this._storageService = e, this._disposables = new X(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._ignoreChangeEvent = !1, this._hiddenByDefaultCache = /* @__PURE__ */ new Map();
    try {
      const t = e.get(vg._key, 0, "{}");
      this._data = JSON.parse(t);
    } catch {
      this._data = /* @__PURE__ */ Object.create(null);
    }
    this._disposables.add(e.onDidChangeValue(0, vg._key, this._disposables)(() => {
      if (!this._ignoreChangeEvent)
        try {
          const t = e.get(vg._key, 0, "{}");
          this._data = JSON.parse(t);
        } catch (t) {
          console.log("FAILED to read storage after UPDATE", t);
        }
      this._onDidChange.fire();
    }));
  }
  dispose() {
    this._onDidChange.dispose(), this._disposables.dispose();
  }
  _isHiddenByDefault(e, t) {
    return this._hiddenByDefaultCache.get(`${e.id}/${t}`) ?? !1;
  }
  setDefaultState(e, t, i) {
    this._hiddenByDefaultCache.set(`${e.id}/${t}`, i);
  }
  isHidden(e, t) {
    const i = this._isHiddenByDefault(e, t), n = this._data[e.id]?.includes(t) ?? !1;
    return i ? !n : n;
  }
  updateHidden(e, t, i) {
    this._isHiddenByDefault(e, t) && (i = !i);
    const o = this._data[e.id];
    if (i)
      o ? o.indexOf(t) < 0 && o.push(t) : this._data[e.id] = [t];
    else if (o) {
      const r = o.indexOf(t);
      r >= 0 && _9(o, r), o.length === 0 && delete this._data[e.id];
    }
    this._persist();
  }
  reset(e) {
    if (e === void 0)
      this._data = /* @__PURE__ */ Object.create(null), this._persist();
    else {
      for (const { id: t } of e)
        this._data[t] && delete this._data[t];
      this._persist();
    }
  }
  _persist() {
    try {
      this._ignoreChangeEvent = !0;
      const e = JSON.stringify(this._data);
      this._storageService.store(
        vg._key,
        e,
        0,
        0
        /* StorageTarget.USER */
      );
    } finally {
      this._ignoreChangeEvent = !1;
    }
  }
}, vg = Hh, Hh._key = "menu.hiddenCommands", Hh);
Kk = vg = _S([
  ya(0, Jl)
], Kk);
class jp {
  constructor(e, t) {
    this._id = e, this._collectContextKeysForSubmenus = t, this._menuGroups = [], this._allMenuIds = /* @__PURE__ */ new Set(), this._structureContextKeys = /* @__PURE__ */ new Set(), this._preconditionContextKeys = /* @__PURE__ */ new Set(), this._toggledContextKeys = /* @__PURE__ */ new Set(), this.refresh();
  }
  get allMenuIds() {
    return this._allMenuIds;
  }
  get structureContextKeys() {
    return this._structureContextKeys;
  }
  get preconditionContextKeys() {
    return this._preconditionContextKeys;
  }
  get toggledContextKeys() {
    return this._toggledContextKeys;
  }
  refresh() {
    this._menuGroups.length = 0, this._allMenuIds.clear(), this._structureContextKeys.clear(), this._preconditionContextKeys.clear(), this._toggledContextKeys.clear();
    const e = this._sort(mo.getMenuItems(this._id));
    let t;
    for (const i of e) {
      const n = i.group || "";
      (!t || t[0] !== n) && (t = [n, []], this._menuGroups.push(t)), t[1].push(i), this._collectContextKeysAndSubmenuIds(i);
    }
    this._allMenuIds.add(this._id);
  }
  _sort(e) {
    return e;
  }
  _collectContextKeysAndSubmenuIds(e) {
    if (jp._fillInKbExprKeys(e.when, this._structureContextKeys), ff(e)) {
      if (e.command.precondition && jp._fillInKbExprKeys(e.command.precondition, this._preconditionContextKeys), e.command.toggled) {
        const t = e.command.toggled.condition || e.command.toggled;
        jp._fillInKbExprKeys(t, this._toggledContextKeys);
      }
    } else this._collectContextKeysForSubmenus && (mo.getMenuItems(e.submenu).forEach(this._collectContextKeysAndSubmenuIds, this), this._allMenuIds.add(e.submenu));
  }
  static _fillInKbExprKeys(e, t) {
    if (e)
      for (const i of e.keys())
        t.add(i);
  }
}
let Jk = bp = class extends jp {
  constructor(e, t, i, n, o, r) {
    super(e, i), this._hiddenStates = t, this._commandService = n, this._keybindingService = o, this._contextKeyService = r, this.refresh();
  }
  createActionGroups(e) {
    const t = [];
    for (const i of this._menuGroups) {
      const [n, o] = i;
      let r;
      for (const a of o)
        if (this._contextKeyService.contextMatchesRules(a.when)) {
          const l = ff(a);
          l && this._hiddenStates.setDefaultState(this._id, a.command.id, !!a.isHiddenByDefault);
          const c = Rie(this._id, l ? a.command : a, this._hiddenStates);
          if (l) {
            const d = g8(this._commandService, this._keybindingService, a.command.id, a.when);
            (r ?? (r = [])).push(new bo(a.command, a.alt, e, c, d, this._contextKeyService, this._commandService));
          } else {
            const d = new bp(a.submenu, this._hiddenStates, this._collectContextKeysForSubmenus, this._commandService, this._keybindingService, this._contextKeyService).createActionGroups(e), h = Ri.join(...d.map((u) => u[1]));
            h.length > 0 && (r ?? (r = [])).push(new mf(a, c, h));
          }
        }
      r && r.length > 0 && t.push([n, r]);
    }
    return t;
  }
  _sort(e) {
    return e.sort(bp._compareMenuItems);
  }
  static _compareMenuItems(e, t) {
    const i = e.group, n = t.group;
    if (i !== n) {
      if (i) {
        if (!n)
          return -1;
      } else return 1;
      if (i === "navigation")
        return -1;
      if (n === "navigation")
        return 1;
      const a = i.localeCompare(n);
      if (a !== 0)
        return a;
    }
    const o = e.order || 0, r = t.order || 0;
    return o < r ? -1 : o > r ? 1 : bp._compareTitles(ff(e) ? e.command.title : e.title, ff(t) ? t.command.title : t.title);
  }
  static _compareTitles(e, t) {
    const i = typeof e == "string" ? e : e.original, n = typeof t == "string" ? t : t.original;
    return i.localeCompare(n);
  }
};
Jk = bp = _S([
  ya(3, bi),
  ya(4, bt),
  ya(5, Se)
], Jk);
let dv = class {
  constructor(e, t, i, n, o, r) {
    this._disposables = new X(), this._menuInfo = new Jk(e, t, i.emitEventsForSubmenuChanges, n, o, r);
    const a = new zt(() => {
      this._menuInfo.refresh(), this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !0, isToggleChange: !0 });
    }, i.eventDebounceDelay);
    this._disposables.add(a), this._disposables.add(mo.onDidChangeMenu((h) => {
      for (const u of this._menuInfo.allMenuIds)
        if (h.has(u)) {
          a.schedule();
          break;
        }
    }));
    const l = this._disposables.add(new X()), c = (h) => {
      let u = !1, g = !1, m = !1;
      for (const p of h)
        if (u = u || p.isStructuralChange, g = g || p.isEnablementChange, m = m || p.isToggleChange, u && g && m)
          break;
      return { menu: this, isStructuralChange: u, isEnablementChange: g, isToggleChange: m };
    }, d = () => {
      l.add(r.onDidChangeContext((h) => {
        const u = h.affectsSome(this._menuInfo.structureContextKeys), g = h.affectsSome(this._menuInfo.preconditionContextKeys), m = h.affectsSome(this._menuInfo.toggledContextKeys);
        (u || g || m) && this._onDidChange.fire({ menu: this, isStructuralChange: u, isEnablementChange: g, isToggleChange: m });
      })), l.add(t.onDidChange((h) => {
        this._onDidChange.fire({ menu: this, isStructuralChange: !0, isEnablementChange: !1, isToggleChange: !1 });
      }));
    };
    this._onDidChange = new nH({
      // start/stop context key listener
      onWillAddFirstListener: d,
      onDidRemoveLastListener: l.clear.bind(l),
      delay: i.eventDebounceDelay,
      merge: c
    }), this.onDidChange = this._onDidChange.event;
  }
  getActions(e) {
    return this._menuInfo.createActionGroups(e);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose();
  }
};
dv = _S([
  ya(3, bi),
  ya(4, bt),
  ya(5, Se)
], dv);
function Rie(s, e, t) {
  const i = IU(e) ? e.submenu.id : e.id, n = typeof e.title == "string" ? e.title : e.title.value, o = gf({
    id: `hide/${s.id}/${i}`,
    label: f("hide.label", "Hide '{0}'", n),
    run() {
      t.updateHidden(s, i, !0);
    }
  }), r = gf({
    id: `toggle/${s.id}/${i}`,
    label: n,
    get checked() {
      return !t.isHidden(s, i);
    },
    run() {
      t.updateHidden(s, i, !!this.checked);
    }
  });
  return {
    hide: o,
    toggle: r,
    get isHidden() {
      return !r.checked;
    }
  };
}
function g8(s, e, t, i = void 0, n = !0) {
  return gf({
    id: `configureKeybinding/${t}`,
    label: f("configure keybinding", "Configure Keybinding"),
    enabled: n,
    run() {
      const r = !!!e.lookupKeybinding(t) && i ? i.serialize() : void 0;
      s.executeCommand("workbench.action.openGlobalKeybindings", `@command:${t}` + (r ? ` +when:${r}` : ""));
    }
  });
}
var Fie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hO = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, qk;
const uO = "application/vnd.code.resources";
var Wh;
let $k = (Wh = class extends V {
  constructor(e, t) {
    super(), this.layoutService = e, this.logService = t, this.mapTextToType = /* @__PURE__ */ new Map(), this.findText = "", this.resources = [], this.resourcesStateHash = void 0, (od || yH) && this.installWebKitWriteTextWorkaround(), this._register(te.runAndSubscribe(S0, ({ window: i, disposables: n }) => {
      n.add(U(i.document, "copy", () => this.clearResourcesState()));
    }, { window: vt, disposables: this._store }));
  }
  // In Safari, it has the following note:
  //
  // "The request to write to the clipboard must be triggered during a user gesture.
  // A call to clipboard.write or clipboard.writeText outside the scope of a user
  // gesture(such as "click" or "touch" event handlers) will result in the immediate
  // rejection of the promise returned by the API call."
  // From: https://webkit.org/blog/10855/async-clipboard-api/
  //
  // Since extensions run in a web worker, and handle gestures in an asynchronous way,
  // they are not classified by Safari as "in response to a user gesture" and will reject.
  //
  // This function sets up some handlers to work around that behavior.
  installWebKitWriteTextWorkaround() {
    const e = () => {
      const t = new DH();
      this.webKitPendingClipboardWritePromise && !this.webKitPendingClipboardWritePromise.isSettled && this.webKitPendingClipboardWritePromise.cancel(), this.webKitPendingClipboardWritePromise = t, dp().navigator.clipboard.write([new ClipboardItem({
        "text/plain": t.p
      })]).catch(async (i) => {
        (!(i instanceof Error) || i.name !== "NotAllowedError" || !t.isRejected) && this.logService.error(i);
      });
    };
    this._register(te.runAndSubscribe(this.layoutService.onDidAddContainer, ({ container: t, disposables: i }) => {
      i.add(U(t, "click", e)), i.add(U(t, "keydown", e));
    }, { container: this.layoutService.mainContainer, disposables: this._store }));
  }
  async writeText(e, t) {
    if (this.clearResourcesState(), t) {
      this.mapTextToType.set(t, e);
      return;
    }
    if (this.webKitPendingClipboardWritePromise)
      return this.webKitPendingClipboardWritePromise.complete(e);
    try {
      return await dp().navigator.clipboard.writeText(e);
    } catch (i) {
      console.error(i);
    }
    this.fallbackWriteText(e);
  }
  fallbackWriteText(e) {
    const t = KM(), i = t.activeElement, n = t.body.appendChild(de("textarea", { "aria-hidden": !0 }));
    n.style.height = "1px", n.style.width = "1px", n.style.position = "absolute", n.value = e, n.focus(), n.select(), t.execCommand("copy"), Bi(i) && i.focus(), n.remove();
  }
  async readText(e) {
    if (e)
      return this.mapTextToType.get(e) || "";
    try {
      return await dp().navigator.clipboard.readText();
    } catch (t) {
      console.error(t);
    }
    return "";
  }
  async readFindText() {
    return this.findText;
  }
  async writeFindText(e) {
    this.findText = e;
  }
  async readResources() {
    try {
      const t = await dp().navigator.clipboard.read();
      for (const i of t)
        if (i.types.includes(`web ${uO}`)) {
          const n = await i.getType(`web ${uO}`);
          return JSON.parse(await n.text()).map((r) => _e.from(r));
        }
    } catch {
    }
    const e = await this.computeResourcesStateHash();
    return this.resourcesStateHash !== e && this.clearResourcesState(), this.resources;
  }
  async computeResourcesStateHash() {
    if (this.resources.length === 0)
      return;
    const e = await this.readText();
    return C0(e.substring(0, qk.MAX_RESOURCE_STATE_SOURCE_LENGTH));
  }
  clearInternalState() {
    this.clearResourcesState();
  }
  clearResourcesState() {
    this.resources = [], this.resourcesStateHash = void 0;
  }
}, qk = Wh, Wh.MAX_RESOURCE_STATE_SOURCE_LENGTH = 1e3, Wh);
$k = qk = Fie([
  hO(0, wd),
  hO(1, Es)
], $k);
const Yu = We("clipboardService");
var Oie = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Pie = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Yp = "data-keybinding-context";
let xT = class {
  constructor(e, t) {
    this._id = e, this._parent = t, this._value = /* @__PURE__ */ Object.create(null), this._value._contextId = e;
  }
  get value() {
    return { ...this._value };
  }
  setValue(e, t) {
    return this._value[e] !== t ? (this._value[e] = t, !0) : !1;
  }
  removeValue(e) {
    return e in this._value ? (delete this._value[e], !0) : !1;
  }
  getValue(e) {
    const t = this._value[e];
    return typeof t > "u" && this._parent ? this._parent.getValue(e) : t;
  }
};
const H1 = class H1 extends xT {
  constructor() {
    super(-1, null);
  }
  setValue(e, t) {
    return !1;
  }
  removeValue(e) {
    return !1;
  }
  getValue(e) {
  }
};
H1.INSTANCE = new H1();
let rm = H1;
const mA = class mA extends xT {
  constructor(e, t, i) {
    super(e, null), this._configurationService = t, this._values = wf.forConfigKeys(), this._listener = this._configurationService.onDidChangeConfiguration((n) => {
      if (n.source === 7) {
        const o = Array.from(this._values, ([r]) => r);
        this._values.clear(), i.fire(new fO(o));
      } else {
        const o = [];
        for (const r of n.affectedKeys) {
          const a = `config.${r}`, l = this._values.findSuperstr(a);
          l !== void 0 && (o.push(...nt.map(l, ([c]) => c)), this._values.deleteSuperstr(a)), this._values.has(a) && (o.push(a), this._values.delete(a));
        }
        i.fire(new fO(o));
      }
    });
  }
  dispose() {
    this._listener.dispose();
  }
  getValue(e) {
    if (e.indexOf(mA._keyPrefix) !== 0)
      return super.getValue(e);
    if (this._values.has(e))
      return this._values.get(e);
    const t = e.substr(mA._keyPrefix.length), i = this._configurationService.getValue(t);
    let n;
    switch (typeof i) {
      case "number":
      case "boolean":
      case "string":
        n = i;
        break;
      default:
        Array.isArray(i) ? n = JSON.stringify(i) : n = i;
    }
    return this._values.set(e, n), n;
  }
  setValue(e, t) {
    return super.setValue(e, t);
  }
  removeValue(e) {
    return super.removeValue(e);
  }
};
mA._keyPrefix = "config.";
let Xk = mA;
class Hie {
  constructor(e, t, i) {
    this._service = e, this._key = t, this._defaultValue = i, this.reset();
  }
  set(e) {
    this._service.setContext(this._key, e);
  }
  reset() {
    typeof this._defaultValue > "u" ? this._service.removeContext(this._key) : this._service.setContext(this._key, this._defaultValue);
  }
  get() {
    return this._service.getContextKeyValue(this._key);
  }
}
class gO {
  constructor(e) {
    this.key = e;
  }
  affectsSome(e) {
    return e.has(this.key);
  }
  allKeysContainedIn(e) {
    return this.affectsSome(e);
  }
}
class fO {
  constructor(e) {
    this.keys = e;
  }
  affectsSome(e) {
    for (const t of this.keys)
      if (e.has(t))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.keys.every((t) => e.has(t));
  }
}
class Wie {
  constructor(e) {
    this.events = e;
  }
  affectsSome(e) {
    for (const t of this.events)
      if (t.affectsSome(e))
        return !0;
    return !1;
  }
  allKeysContainedIn(e) {
    return this.events.every((t) => t.allKeysContainedIn(e));
  }
}
function Vie(s, e) {
  return s.allKeysContainedIn(new Set(Object.keys(e)));
}
class f8 extends V {
  constructor(e) {
    super(), this._onDidChangeContext = this._register(new uu({ merge: (t) => new Wie(t) })), this.onDidChangeContext = this._onDidChangeContext.event, this._isDisposed = !1, this._myContextId = e;
  }
  createKey(e, t) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new Hie(this, e, t);
  }
  bufferChangeEvents(e) {
    this._onDidChangeContext.pause();
    try {
      e();
    } finally {
      this._onDidChangeContext.resume();
    }
  }
  createScoped(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    return new zie(this, e);
  }
  contextMatchesRules(e) {
    if (this._isDisposed)
      throw new Error("AbstractContextKeyService has been disposed");
    const t = this.getContextValuesContainer(this._myContextId);
    return e ? e.evaluate(t) : !0;
  }
  getContextKeyValue(e) {
    if (!this._isDisposed)
      return this.getContextValuesContainer(this._myContextId).getValue(e);
  }
  setContext(e, t) {
    if (this._isDisposed)
      return;
    const i = this.getContextValuesContainer(this._myContextId);
    i && i.setValue(e, t) && this._onDidChangeContext.fire(new gO(e));
  }
  removeContext(e) {
    this._isDisposed || this.getContextValuesContainer(this._myContextId).removeValue(e) && this._onDidChangeContext.fire(new gO(e));
  }
  getContext(e) {
    return this._isDisposed ? rm.INSTANCE : this.getContextValuesContainer(Uie(e));
  }
  dispose() {
    super.dispose(), this._isDisposed = !0;
  }
}
let Zk = class extends f8 {
  constructor(e) {
    super(0), this._contexts = /* @__PURE__ */ new Map(), this._lastContextId = 0;
    const t = this._register(new Xk(this._myContextId, e, this._onDidChangeContext));
    this._contexts.set(this._myContextId, t);
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? rm.INSTANCE : this._contexts.get(e) || rm.INSTANCE;
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ContextKeyService has been disposed");
    const t = ++this._lastContextId;
    return this._contexts.set(t, new xT(t, this.getContextValuesContainer(e))), t;
  }
  disposeContext(e) {
    this._isDisposed || this._contexts.delete(e);
  }
};
Zk = Oie([
  Pie(0, ht)
], Zk);
class zie extends f8 {
  constructor(e, t) {
    if (super(e.createChildContext()), this._parentChangeListener = this._register(new On()), this._parent = e, this._updateParentChangeListener(), this._domNode = t, this._domNode.hasAttribute(Yp)) {
      let i = "";
      this._domNode.classList && (i = Array.from(this._domNode.classList.values()).join(", ")), console.error(`Element already has context attribute${i ? ": " + i : ""}`);
    }
    this._domNode.setAttribute(Yp, String(this._myContextId));
  }
  _updateParentChangeListener() {
    this._parentChangeListener.value = this._parent.onDidChangeContext((e) => {
      const i = this._parent.getContextValuesContainer(this._myContextId).value;
      Vie(e, i) || this._onDidChangeContext.fire(e);
    });
  }
  dispose() {
    this._isDisposed || (this._parent.disposeContext(this._myContextId), this._domNode.removeAttribute(Yp), super.dispose());
  }
  getContextValuesContainer(e) {
    return this._isDisposed ? rm.INSTANCE : this._parent.getContextValuesContainer(e);
  }
  createChildContext(e = this._myContextId) {
    if (this._isDisposed)
      throw new Error("ScopedContextKeyService has been disposed");
    return this._parent.createChildContext(e);
  }
  disposeContext(e) {
    this._isDisposed || this._parent.disposeContext(e);
  }
}
function Uie(s) {
  for (; s; ) {
    if (s.hasAttribute(Yp)) {
      const e = s.getAttribute(Yp);
      return e ? parseInt(e, 10) : NaN;
    }
    s = s.parentElement;
  }
  return 0;
}
function Qie(s, e, t) {
  s.get(Se).createKey(String(e), Gie(t));
}
function Gie(s) {
  return U4(s, (e) => {
    if (typeof e == "object" && e.$mid === 1)
      return _e.revive(e).toString();
    if (e instanceof _e)
      return e.toString();
  });
}
mt.registerCommand("_setContext", Qie);
mt.registerCommand({
  id: "getContextKeyInfo",
  handler() {
    return [...le.all()].sort((s, e) => s.key.localeCompare(e.key));
  },
  metadata: {
    description: f("getContextKeyInfo", "A command that returns information about context keys"),
    args: []
  }
});
mt.registerCommand("_generateContextKeyInfo", function() {
  const s = [], e = /* @__PURE__ */ new Set();
  for (const t of le.all())
    e.has(t.key) || (e.add(t.key), s.push(t));
  s.sort((t, i) => t.key.localeCompare(i.key)), console.log(JSON.stringify(s, void 0, 2));
});
let jie = class {
  constructor(e, t) {
    this.key = e, this.data = t, this.incoming = /* @__PURE__ */ new Map(), this.outgoing = /* @__PURE__ */ new Map();
  }
};
class mO {
  constructor(e) {
    this._hashFn = e, this._nodes = /* @__PURE__ */ new Map();
  }
  roots() {
    const e = [];
    for (const t of this._nodes.values())
      t.outgoing.size === 0 && e.push(t);
    return e;
  }
  insertEdge(e, t) {
    const i = this.lookupOrInsertNode(e), n = this.lookupOrInsertNode(t);
    i.outgoing.set(n.key, n), n.incoming.set(i.key, i);
  }
  removeNode(e) {
    const t = this._hashFn(e);
    this._nodes.delete(t);
    for (const i of this._nodes.values())
      i.outgoing.delete(t), i.incoming.delete(t);
  }
  lookupOrInsertNode(e) {
    const t = this._hashFn(e);
    let i = this._nodes.get(t);
    return i || (i = new jie(t, e), this._nodes.set(t, i)), i;
  }
  isEmpty() {
    return this._nodes.size === 0;
  }
  toString() {
    const e = [];
    for (const [t, i] of this._nodes)
      e.push(`${t}
	(-> incoming)[${[...i.incoming.keys()].join(", ")}]
	(outgoing ->)[${[...i.outgoing.keys()].join(",")}]
`);
    return e.join(`
`);
  }
  /**
   * This is brute force and slow and **only** be used
   * to trouble shoot.
   */
  findCycleSlow() {
    for (const [e, t] of this._nodes) {
      const i = /* @__PURE__ */ new Set([e]), n = this._findCycle(t, i);
      if (n)
        return n;
    }
  }
  _findCycle(e, t) {
    for (const [i, n] of e.outgoing) {
      if (t.has(i))
        return [...t, i].join(" -> ");
      t.add(i);
      const o = this._findCycle(n, t);
      if (o)
        return o;
      t.delete(i);
    }
  }
}
class Lm {
  constructor(...e) {
    this._entries = /* @__PURE__ */ new Map();
    for (const [t, i] of e)
      this.set(t, i);
  }
  set(e, t) {
    const i = this._entries.get(e);
    return this._entries.set(e, t), i;
  }
  get(e) {
    return this._entries.get(e);
  }
}
const Yie = !1;
class pO extends Error {
  constructor(e) {
    super("cyclic dependency between services"), this.message = e.findCycleSlow() ?? `UNABLE to detect cycle, dumping graph: 
${e.toString()}`;
  }
}
class hv {
  constructor(e = new Lm(), t = !1, i, n = Yie) {
    this._services = e, this._strict = t, this._parent = i, this._enableTracing = n, this._isDisposed = !1, this._servicesToMaybeDispose = /* @__PURE__ */ new Set(), this._children = /* @__PURE__ */ new Set(), this._activeInstantiations = /* @__PURE__ */ new Set(), this._services.set(ke, this), this._globalGraph = n ? i?._globalGraph ?? new mO((o) => o) : void 0;
  }
  dispose() {
    if (!this._isDisposed) {
      this._isDisposed = !0, Ct(this._children), this._children.clear();
      for (const e of this._servicesToMaybeDispose)
        DM(e) && e.dispose();
      this._servicesToMaybeDispose.clear();
    }
  }
  _throwIfDisposed() {
    if (this._isDisposed)
      throw new Error("InstantiationService has been disposed");
  }
  createChild(e, t) {
    this._throwIfDisposed();
    const i = this, n = new class extends hv {
      dispose() {
        i._children.delete(n), super.dispose();
      }
    }(e, this._strict, this, this._enableTracing);
    return this._children.add(n), t?.add(n), n;
  }
  invokeFunction(e, ...t) {
    this._throwIfDisposed();
    const i = Kp.traceInvocation(this._enableTracing, e);
    let n = !1;
    try {
      return e({
        get: (r) => {
          if (n)
            throw kM("service accessor is only valid during the invocation of its target method");
          const a = this._getOrCreateServiceInstance(r, i);
          if (!a)
            throw new Error(`[invokeFunction] unknown service '${r}'`);
          return a;
        }
      }, ...t);
    } finally {
      n = !0, i.stop();
    }
  }
  createInstance(e, ...t) {
    this._throwIfDisposed();
    let i, n;
    return e instanceof ha ? (i = Kp.traceCreation(this._enableTracing, e.ctor), n = this._createInstance(e.ctor, e.staticArguments.concat(t), i)) : (i = Kp.traceCreation(this._enableTracing, e), n = this._createInstance(e, t, i)), i.stop(), n;
  }
  _createInstance(e, t = [], i) {
    const n = Mr.getServiceDependencies(e).sort((a, l) => a.index - l.index), o = [];
    for (const a of n) {
      const l = this._getOrCreateServiceInstance(a.id, i);
      l || this._throwIfStrict(`[createInstance] ${e.name} depends on UNKNOWN service ${a.id}.`, !1), o.push(l);
    }
    const r = n.length > 0 ? n[0].index : t.length;
    if (t.length !== r) {
      console.trace(`[createInstance] First service dependency of ${e.name} at position ${r + 1} conflicts with ${t.length} static arguments`);
      const a = r - t.length;
      a > 0 ? t = t.concat(new Array(a)) : t = t.slice(0, r);
    }
    return Reflect.construct(e, t.concat(o));
  }
  _setCreatedServiceInstance(e, t) {
    if (this._services.get(e) instanceof ha)
      this._services.set(e, t);
    else if (this._parent)
      this._parent._setCreatedServiceInstance(e, t);
    else
      throw new Error("illegalState - setting UNKNOWN service instance");
  }
  _getServiceInstanceOrDescriptor(e) {
    const t = this._services.get(e);
    return !t && this._parent ? this._parent._getServiceInstanceOrDescriptor(e) : t;
  }
  _getOrCreateServiceInstance(e, t) {
    this._globalGraph && this._globalGraphImplicitDependency && this._globalGraph.insertEdge(this._globalGraphImplicitDependency, String(e));
    const i = this._getServiceInstanceOrDescriptor(e);
    return i instanceof ha ? this._safeCreateAndCacheServiceInstance(e, i, t.branch(e, !0)) : (t.branch(e, !1), i);
  }
  _safeCreateAndCacheServiceInstance(e, t, i) {
    if (this._activeInstantiations.has(e))
      throw new Error(`illegal state - RECURSIVELY instantiating service '${e}'`);
    this._activeInstantiations.add(e);
    try {
      return this._createAndCacheServiceInstance(e, t, i);
    } finally {
      this._activeInstantiations.delete(e);
    }
  }
  _createAndCacheServiceInstance(e, t, i) {
    const n = new mO((l) => l.id.toString());
    let o = 0;
    const r = [{ id: e, desc: t, _trace: i }], a = /* @__PURE__ */ new Set();
    for (; r.length; ) {
      const l = r.pop();
      if (!a.has(String(l.id))) {
        if (a.add(String(l.id)), n.lookupOrInsertNode(l), o++ > 1e3)
          throw new pO(n);
        for (const c of Mr.getServiceDependencies(l.desc.ctor)) {
          const d = this._getServiceInstanceOrDescriptor(c.id);
          if (d || this._throwIfStrict(`[createInstance] ${e} depends on ${c.id} which is NOT registered.`, !0), this._globalGraph?.insertEdge(String(l.id), String(c.id)), d instanceof ha) {
            const h = { id: c.id, desc: d, _trace: l._trace.branch(c.id, !0) };
            n.insertEdge(l, h), r.push(h);
          }
        }
      }
    }
    for (; ; ) {
      const l = n.roots();
      if (l.length === 0) {
        if (!n.isEmpty())
          throw new pO(n);
        break;
      }
      for (const { data: c } of l) {
        if (this._getServiceInstanceOrDescriptor(c.id) instanceof ha) {
          const h = this._createServiceInstanceWithOwner(c.id, c.desc.ctor, c.desc.staticArguments, c.desc.supportsDelayedInstantiation, c._trace);
          this._setCreatedServiceInstance(c.id, h);
        }
        n.removeNode(c);
      }
    }
    return this._getServiceInstanceOrDescriptor(e);
  }
  _createServiceInstanceWithOwner(e, t, i = [], n, o) {
    if (this._services.get(e) instanceof ha)
      return this._createServiceInstance(e, t, i, n, o, this._servicesToMaybeDispose);
    if (this._parent)
      return this._parent._createServiceInstanceWithOwner(e, t, i, n, o);
    throw new Error(`illegalState - creating UNKNOWN service instance ${t.name}`);
  }
  _createServiceInstance(e, t, i = [], n, o, r) {
    if (n) {
      const a = new hv(void 0, this._strict, this, this._enableTracing);
      a._globalGraphImplicitDependency = String(e);
      const l = /* @__PURE__ */ new Map(), c = new n6(() => {
        const d = a._createInstance(t, i, o);
        for (const [h, u] of l) {
          const g = d[h];
          if (typeof g == "function")
            for (const m of u)
              m.disposable = g.apply(d, m.listener);
        }
        return l.clear(), r.add(d), d;
      });
      return new Proxy(/* @__PURE__ */ Object.create(null), {
        get(d, h) {
          if (!c.isInitialized && typeof h == "string" && (h.startsWith("onDid") || h.startsWith("onWill"))) {
            let m = l.get(h);
            return m || (m = new Nn(), l.set(h, m)), (A, _, b) => {
              if (c.isInitialized)
                return c.value[h](A, _, b);
              {
                const C = { listener: [A, _, b], disposable: void 0 }, w = m.push(C);
                return we(() => {
                  w(), C.disposable?.dispose();
                });
              }
            };
          }
          if (h in d)
            return d[h];
          const u = c.value;
          let g = u[h];
          return typeof g != "function" || (g = g.bind(u), d[h] = g), g;
        },
        set(d, h, u) {
          return c.value[h] = u, !0;
        },
        getPrototypeOf(d) {
          return t.prototype;
        }
      });
    } else {
      const a = this._createInstance(t, i, o);
      return r.add(a), a;
    }
  }
  _throwIfStrict(e, t) {
    if (t && console.warn(e), this._strict)
      throw new Error(e);
  }
}
const Bs = class Bs {
  static traceInvocation(e, t) {
    return e ? new Bs(2, t.name || new Error().stack.split(`
`).slice(3, 4).join(`
`)) : Bs._None;
  }
  static traceCreation(e, t) {
    return e ? new Bs(1, t.name) : Bs._None;
  }
  constructor(e, t) {
    this.type = e, this.name = t, this._start = Date.now(), this._dep = [];
  }
  branch(e, t) {
    const i = new Bs(3, e.toString());
    return this._dep.push([e, t, i]), i;
  }
  stop() {
    const e = Date.now() - this._start;
    Bs._totals += e;
    let t = !1;
    function i(o, r) {
      const a = [], l = new Array(o + 1).join("	");
      for (const [c, d, h] of r._dep)
        if (d && h) {
          t = !0, a.push(`${l}CREATES -> ${c}`);
          const u = i(o + 1, h);
          u && a.push(u);
        } else
          a.push(`${l}uses -> ${c}`);
      return a.join(`
`);
    }
    const n = [
      `${this.type === 1 ? "CREATE" : "CALL"} ${this.name}`,
      `${i(1, this)}`,
      `DONE, took ${e.toFixed(2)}ms (grand total ${Bs._totals.toFixed(2)}ms)`
    ];
    (e > 2 || t) && Bs.all.add(n.join(`
`));
  }
};
Bs.all = /* @__PURE__ */ new Set(), Bs._None = new class extends Bs {
  constructor() {
    super(0, null);
  }
  stop() {
  }
  branch() {
    return this;
  }
}(), Bs._totals = 0;
let Kp = Bs;
const Kie = /* @__PURE__ */ new Set([
  Ie.inMemory,
  Ie.vscodeSourceControl,
  Ie.walkThrough,
  Ie.walkThroughSnippet,
  Ie.vscodeChatCodeBlock
]);
class Jie {
  constructor() {
    this._byResource = new ws(), this._byOwner = /* @__PURE__ */ new Map();
  }
  set(e, t, i) {
    let n = this._byResource.get(e);
    n || (n = /* @__PURE__ */ new Map(), this._byResource.set(e, n)), n.set(t, i);
    let o = this._byOwner.get(t);
    o || (o = new ws(), this._byOwner.set(t, o)), o.set(e, i);
  }
  get(e, t) {
    return this._byResource.get(e)?.get(t);
  }
  delete(e, t) {
    let i = !1, n = !1;
    const o = this._byResource.get(e);
    o && (i = o.delete(t));
    const r = this._byOwner.get(t);
    if (r && (n = r.delete(e)), i !== n)
      throw new Error("illegal state");
    return i && n;
  }
  values(e) {
    return typeof e == "string" ? this._byOwner.get(e)?.values() ?? nt.empty() : _e.isUri(e) ? this._byResource.get(e)?.values() ?? nt.empty() : nt.map(nt.concat(...this._byOwner.values()), (t) => t[1]);
  }
}
class qie {
  constructor(e) {
    this.errors = 0, this.infos = 0, this.warnings = 0, this.unknowns = 0, this._data = new ws(), this._service = e, this._subscription = e.onMarkerChanged(this._update, this);
  }
  dispose() {
    this._subscription.dispose();
  }
  _update(e) {
    for (const t of e) {
      const i = this._data.get(t);
      i && this._substract(i);
      const n = this._resourceStats(t);
      this._add(n), this._data.set(t, n);
    }
  }
  _resourceStats(e) {
    const t = { errors: 0, warnings: 0, infos: 0, unknowns: 0 };
    if (Kie.has(e.scheme))
      return t;
    for (const { severity: i } of this._service.read({ resource: e }))
      i === Yt.Error ? t.errors += 1 : i === Yt.Warning ? t.warnings += 1 : i === Yt.Info ? t.infos += 1 : t.unknowns += 1;
    return t;
  }
  _substract(e) {
    this.errors -= e.errors, this.warnings -= e.warnings, this.infos -= e.infos, this.unknowns -= e.unknowns;
  }
  _add(e) {
    this.errors += e.errors, this.warnings += e.warnings, this.infos += e.infos, this.unknowns += e.unknowns;
  }
}
class uc {
  constructor() {
    this._onMarkerChanged = new nH({
      delay: 0,
      merge: uc._merge
    }), this.onMarkerChanged = this._onMarkerChanged.event, this._data = new Jie(), this._stats = new qie(this);
  }
  dispose() {
    this._stats.dispose(), this._onMarkerChanged.dispose();
  }
  remove(e, t) {
    for (const i of t || [])
      this.changeOne(e, i, []);
  }
  changeOne(e, t, i) {
    if (P4(i))
      this._data.delete(t, e) && this._onMarkerChanged.fire([t]);
    else {
      const n = [];
      for (const o of i) {
        const r = uc._toMarker(e, t, o);
        r && n.push(r);
      }
      this._data.set(t, e, n), this._onMarkerChanged.fire([t]);
    }
  }
  static _toMarker(e, t, i) {
    let { code: n, severity: o, message: r, source: a, startLineNumber: l, startColumn: c, endLineNumber: d, endColumn: h, relatedInformation: u, tags: g } = i;
    if (r)
      return l = l > 0 ? l : 1, c = c > 0 ? c : 1, d = d >= l ? d : l, h = h > 0 ? h : c, {
        resource: t,
        owner: e,
        code: n,
        severity: o,
        message: r,
        source: a,
        startLineNumber: l,
        startColumn: c,
        endLineNumber: d,
        endColumn: h,
        relatedInformation: u,
        tags: g
      };
  }
  changeAll(e, t) {
    const i = [], n = this._data.values(e);
    if (n)
      for (const o of n) {
        const r = nt.first(o);
        r && (i.push(r.resource), this._data.delete(r.resource, e));
      }
    if (Ys(t)) {
      const o = new ws();
      for (const { resource: r, marker: a } of t) {
        const l = uc._toMarker(e, r, a);
        if (!l)
          continue;
        const c = o.get(r);
        c ? c.push(l) : (o.set(r, [l]), i.push(r));
      }
      for (const [r, a] of o)
        this._data.set(r, e, a);
    }
    i.length > 0 && this._onMarkerChanged.fire(i);
  }
  read(e = /* @__PURE__ */ Object.create(null)) {
    let { owner: t, resource: i, severities: n, take: o } = e;
    if ((!o || o < 0) && (o = -1), t && i) {
      const r = this._data.get(i, t);
      if (r) {
        const a = [];
        for (const l of r)
          if (uc._accept(l, n)) {
            const c = a.push(l);
            if (o > 0 && c === o)
              break;
          }
        return a;
      } else
        return [];
    } else if (!t && !i) {
      const r = [];
      for (const a of this._data.values())
        for (const l of a)
          if (uc._accept(l, n)) {
            const c = r.push(l);
            if (o > 0 && c === o)
              return r;
          }
      return r;
    } else {
      const r = this._data.values(i ?? t), a = [];
      for (const l of r)
        for (const c of l)
          if (uc._accept(c, n)) {
            const d = a.push(c);
            if (o > 0 && d === o)
              return a;
          }
      return a;
    }
  }
  static _accept(e, t) {
    return t === void 0 || (t & e.severity) === e.severity;
  }
  // --- event debounce logic
  static _merge(e) {
    const t = new ws();
    for (const i of e)
      for (const n of i)
        t.set(n, !0);
    return Array.from(t.keys());
  }
}
class $ie extends V {
  get configurationModel() {
    return this._configurationModel;
  }
  constructor(e) {
    super(), this.logService = e, this._configurationModel = Ui.createEmptyModel(this.logService);
  }
  reload() {
    return this.resetConfigurationModel(), this.configurationModel;
  }
  getConfigurationDefaultOverrides() {
    return {};
  }
  resetConfigurationModel() {
    this._configurationModel = Ui.createEmptyModel(this.logService);
    const e = ji.as(Wu.Configuration).getConfigurationProperties();
    this.updateConfigurationModel(Object.keys(e), e);
  }
  updateConfigurationModel(e, t) {
    const i = this.getConfigurationDefaultOverrides();
    for (const n of e) {
      const o = i[n], r = t[n];
      o !== void 0 ? this._configurationModel.setValue(n, o) : r ? this._configurationModel.setValue(n, r.default) : this._configurationModel.removeValue(n);
    }
  }
}
const bS = We("accessibilitySignalService"), tt = class tt {
  static register(e) {
    return new tt(e.fileName);
  }
  constructor(e) {
    this.fileName = e;
  }
};
tt.error = tt.register({ fileName: "error.mp3" }), tt.warning = tt.register({ fileName: "warning.mp3" }), tt.success = tt.register({ fileName: "success.mp3" }), tt.foldedArea = tt.register({ fileName: "foldedAreas.mp3" }), tt.break = tt.register({ fileName: "break.mp3" }), tt.quickFixes = tt.register({ fileName: "quickFixes.mp3" }), tt.taskCompleted = tt.register({ fileName: "taskCompleted.mp3" }), tt.taskFailed = tt.register({ fileName: "taskFailed.mp3" }), tt.terminalBell = tt.register({ fileName: "terminalBell.mp3" }), tt.diffLineInserted = tt.register({ fileName: "diffLineInserted.mp3" }), tt.diffLineDeleted = tt.register({ fileName: "diffLineDeleted.mp3" }), tt.diffLineModified = tt.register({ fileName: "diffLineModified.mp3" }), tt.chatRequestSent = tt.register({ fileName: "chatRequestSent.mp3" }), tt.chatResponseReceived1 = tt.register({ fileName: "chatResponseReceived1.mp3" }), tt.chatResponseReceived2 = tt.register({ fileName: "chatResponseReceived2.mp3" }), tt.chatResponseReceived3 = tt.register({ fileName: "chatResponseReceived3.mp3" }), tt.chatResponseReceived4 = tt.register({ fileName: "chatResponseReceived4.mp3" }), tt.clear = tt.register({ fileName: "clear.mp3" }), tt.save = tt.register({ fileName: "save.mp3" }), tt.format = tt.register({ fileName: "format.mp3" }), tt.voiceRecordingStarted = tt.register({ fileName: "voiceRecordingStarted.mp3" }), tt.voiceRecordingStopped = tt.register({ fileName: "voiceRecordingStopped.mp3" }), tt.progress = tt.register({ fileName: "progress.mp3" });
let Ot = tt;
class Xie {
  constructor(e) {
    this.randomOneOf = e;
  }
}
const Ne = class Ne {
  constructor(e, t, i, n, o, r) {
    this.sound = e, this.name = t, this.legacySoundSettingsKey = i, this.settingsKey = n, this.legacyAnnouncementSettingsKey = o, this.announcementMessage = r;
  }
  static register(e) {
    const t = new Xie("randomOneOf" in e.sound ? e.sound.randomOneOf : [e.sound]), i = new Ne(t, e.name, e.legacySoundSettingsKey, e.settingsKey, e.legacyAnnouncementSettingsKey, e.announcementMessage);
    return Ne._signals.add(i), i;
  }
};
Ne._signals = /* @__PURE__ */ new Set(), Ne.errorAtPosition = Ne.register({
  name: f("accessibilitySignals.positionHasError.name", "Error at Position"),
  sound: Ot.error,
  announcementMessage: f("accessibility.signals.positionHasError", "Error"),
  settingsKey: "accessibility.signals.positionHasError",
  delaySettingsKey: "accessibility.signalOptions.delays.errorAtPosition"
}), Ne.warningAtPosition = Ne.register({
  name: f("accessibilitySignals.positionHasWarning.name", "Warning at Position"),
  sound: Ot.warning,
  announcementMessage: f("accessibility.signals.positionHasWarning", "Warning"),
  settingsKey: "accessibility.signals.positionHasWarning",
  delaySettingsKey: "accessibility.signalOptions.delays.warningAtPosition"
}), Ne.errorOnLine = Ne.register({
  name: f("accessibilitySignals.lineHasError.name", "Error on Line"),
  sound: Ot.error,
  legacySoundSettingsKey: "audioCues.lineHasError",
  legacyAnnouncementSettingsKey: "accessibility.alert.error",
  announcementMessage: f("accessibility.signals.lineHasError", "Error on Line"),
  settingsKey: "accessibility.signals.lineHasError"
}), Ne.warningOnLine = Ne.register({
  name: f("accessibilitySignals.lineHasWarning.name", "Warning on Line"),
  sound: Ot.warning,
  legacySoundSettingsKey: "audioCues.lineHasWarning",
  legacyAnnouncementSettingsKey: "accessibility.alert.warning",
  announcementMessage: f("accessibility.signals.lineHasWarning", "Warning on Line"),
  settingsKey: "accessibility.signals.lineHasWarning"
}), Ne.foldedArea = Ne.register({
  name: f("accessibilitySignals.lineHasFoldedArea.name", "Folded Area on Line"),
  sound: Ot.foldedArea,
  legacySoundSettingsKey: "audioCues.lineHasFoldedArea",
  legacyAnnouncementSettingsKey: "accessibility.alert.foldedArea",
  announcementMessage: f("accessibility.signals.lineHasFoldedArea", "Folded"),
  settingsKey: "accessibility.signals.lineHasFoldedArea"
}), Ne.break = Ne.register({
  name: f("accessibilitySignals.lineHasBreakpoint.name", "Breakpoint on Line"),
  sound: Ot.break,
  legacySoundSettingsKey: "audioCues.lineHasBreakpoint",
  legacyAnnouncementSettingsKey: "accessibility.alert.breakpoint",
  announcementMessage: f("accessibility.signals.lineHasBreakpoint", "Breakpoint"),
  settingsKey: "accessibility.signals.lineHasBreakpoint"
}), Ne.inlineSuggestion = Ne.register({
  name: f("accessibilitySignals.lineHasInlineSuggestion.name", "Inline Suggestion on Line"),
  sound: Ot.quickFixes,
  legacySoundSettingsKey: "audioCues.lineHasInlineSuggestion",
  settingsKey: "accessibility.signals.lineHasInlineSuggestion"
}), Ne.terminalQuickFix = Ne.register({
  name: f("accessibilitySignals.terminalQuickFix.name", "Terminal Quick Fix"),
  sound: Ot.quickFixes,
  legacySoundSettingsKey: "audioCues.terminalQuickFix",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalQuickFix",
  announcementMessage: f("accessibility.signals.terminalQuickFix", "Quick Fix"),
  settingsKey: "accessibility.signals.terminalQuickFix"
}), Ne.onDebugBreak = Ne.register({
  name: f("accessibilitySignals.onDebugBreak.name", "Debugger Stopped on Breakpoint"),
  sound: Ot.break,
  legacySoundSettingsKey: "audioCues.onDebugBreak",
  legacyAnnouncementSettingsKey: "accessibility.alert.onDebugBreak",
  announcementMessage: f("accessibility.signals.onDebugBreak", "Breakpoint"),
  settingsKey: "accessibility.signals.onDebugBreak"
}), Ne.noInlayHints = Ne.register({
  name: f("accessibilitySignals.noInlayHints", "No Inlay Hints on Line"),
  sound: Ot.error,
  legacySoundSettingsKey: "audioCues.noInlayHints",
  legacyAnnouncementSettingsKey: "accessibility.alert.noInlayHints",
  announcementMessage: f("accessibility.signals.noInlayHints", "No Inlay Hints"),
  settingsKey: "accessibility.signals.noInlayHints"
}), Ne.taskCompleted = Ne.register({
  name: f("accessibilitySignals.taskCompleted", "Task Completed"),
  sound: Ot.taskCompleted,
  legacySoundSettingsKey: "audioCues.taskCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskCompleted",
  announcementMessage: f("accessibility.signals.taskCompleted", "Task Completed"),
  settingsKey: "accessibility.signals.taskCompleted"
}), Ne.taskFailed = Ne.register({
  name: f("accessibilitySignals.taskFailed", "Task Failed"),
  sound: Ot.taskFailed,
  legacySoundSettingsKey: "audioCues.taskFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.taskFailed",
  announcementMessage: f("accessibility.signals.taskFailed", "Task Failed"),
  settingsKey: "accessibility.signals.taskFailed"
}), Ne.terminalCommandFailed = Ne.register({
  name: f("accessibilitySignals.terminalCommandFailed", "Terminal Command Failed"),
  sound: Ot.error,
  legacySoundSettingsKey: "audioCues.terminalCommandFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalCommandFailed",
  announcementMessage: f("accessibility.signals.terminalCommandFailed", "Command Failed"),
  settingsKey: "accessibility.signals.terminalCommandFailed"
}), Ne.terminalCommandSucceeded = Ne.register({
  name: f("accessibilitySignals.terminalCommandSucceeded", "Terminal Command Succeeded"),
  sound: Ot.success,
  announcementMessage: f("accessibility.signals.terminalCommandSucceeded", "Command Succeeded"),
  settingsKey: "accessibility.signals.terminalCommandSucceeded"
}), Ne.terminalBell = Ne.register({
  name: f("accessibilitySignals.terminalBell", "Terminal Bell"),
  sound: Ot.terminalBell,
  legacySoundSettingsKey: "audioCues.terminalBell",
  legacyAnnouncementSettingsKey: "accessibility.alert.terminalBell",
  announcementMessage: f("accessibility.signals.terminalBell", "Terminal Bell"),
  settingsKey: "accessibility.signals.terminalBell"
}), Ne.notebookCellCompleted = Ne.register({
  name: f("accessibilitySignals.notebookCellCompleted", "Notebook Cell Completed"),
  sound: Ot.taskCompleted,
  legacySoundSettingsKey: "audioCues.notebookCellCompleted",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellCompleted",
  announcementMessage: f("accessibility.signals.notebookCellCompleted", "Notebook Cell Completed"),
  settingsKey: "accessibility.signals.notebookCellCompleted"
}), Ne.notebookCellFailed = Ne.register({
  name: f("accessibilitySignals.notebookCellFailed", "Notebook Cell Failed"),
  sound: Ot.taskFailed,
  legacySoundSettingsKey: "audioCues.notebookCellFailed",
  legacyAnnouncementSettingsKey: "accessibility.alert.notebookCellFailed",
  announcementMessage: f("accessibility.signals.notebookCellFailed", "Notebook Cell Failed"),
  settingsKey: "accessibility.signals.notebookCellFailed"
}), Ne.diffLineInserted = Ne.register({
  name: f("accessibilitySignals.diffLineInserted", "Diff Line Inserted"),
  sound: Ot.diffLineInserted,
  legacySoundSettingsKey: "audioCues.diffLineInserted",
  settingsKey: "accessibility.signals.diffLineInserted"
}), Ne.diffLineDeleted = Ne.register({
  name: f("accessibilitySignals.diffLineDeleted", "Diff Line Deleted"),
  sound: Ot.diffLineDeleted,
  legacySoundSettingsKey: "audioCues.diffLineDeleted",
  settingsKey: "accessibility.signals.diffLineDeleted"
}), Ne.diffLineModified = Ne.register({
  name: f("accessibilitySignals.diffLineModified", "Diff Line Modified"),
  sound: Ot.diffLineModified,
  legacySoundSettingsKey: "audioCues.diffLineModified",
  settingsKey: "accessibility.signals.diffLineModified"
}), Ne.chatRequestSent = Ne.register({
  name: f("accessibilitySignals.chatRequestSent", "Chat Request Sent"),
  sound: Ot.chatRequestSent,
  legacySoundSettingsKey: "audioCues.chatRequestSent",
  legacyAnnouncementSettingsKey: "accessibility.alert.chatRequestSent",
  announcementMessage: f("accessibility.signals.chatRequestSent", "Chat Request Sent"),
  settingsKey: "accessibility.signals.chatRequestSent"
}), Ne.chatResponseReceived = Ne.register({
  name: f("accessibilitySignals.chatResponseReceived", "Chat Response Received"),
  legacySoundSettingsKey: "audioCues.chatResponseReceived",
  sound: {
    randomOneOf: [
      Ot.chatResponseReceived1,
      Ot.chatResponseReceived2,
      Ot.chatResponseReceived3,
      Ot.chatResponseReceived4
    ]
  },
  settingsKey: "accessibility.signals.chatResponseReceived"
}), Ne.progress = Ne.register({
  name: f("accessibilitySignals.progress", "Progress"),
  sound: Ot.progress,
  legacySoundSettingsKey: "audioCues.chatResponsePending",
  legacyAnnouncementSettingsKey: "accessibility.alert.progress",
  announcementMessage: f("accessibility.signals.progress", "Progress"),
  settingsKey: "accessibility.signals.progress"
}), Ne.clear = Ne.register({
  name: f("accessibilitySignals.clear", "Clear"),
  sound: Ot.clear,
  legacySoundSettingsKey: "audioCues.clear",
  legacyAnnouncementSettingsKey: "accessibility.alert.clear",
  announcementMessage: f("accessibility.signals.clear", "Clear"),
  settingsKey: "accessibility.signals.clear"
}), Ne.save = Ne.register({
  name: f("accessibilitySignals.save", "Save"),
  sound: Ot.save,
  legacySoundSettingsKey: "audioCues.save",
  legacyAnnouncementSettingsKey: "accessibility.alert.save",
  announcementMessage: f("accessibility.signals.save", "Save"),
  settingsKey: "accessibility.signals.save"
}), Ne.format = Ne.register({
  name: f("accessibilitySignals.format", "Format"),
  sound: Ot.format,
  legacySoundSettingsKey: "audioCues.format",
  legacyAnnouncementSettingsKey: "accessibility.alert.format",
  announcementMessage: f("accessibility.signals.format", "Format"),
  settingsKey: "accessibility.signals.format"
}), Ne.voiceRecordingStarted = Ne.register({
  name: f("accessibilitySignals.voiceRecordingStarted", "Voice Recording Started"),
  sound: Ot.voiceRecordingStarted,
  legacySoundSettingsKey: "audioCues.voiceRecordingStarted",
  settingsKey: "accessibility.signals.voiceRecordingStarted"
}), Ne.voiceRecordingStopped = Ne.register({
  name: f("accessibilitySignals.voiceRecordingStopped", "Voice Recording Stopped"),
  sound: Ot.voiceRecordingStopped,
  legacySoundSettingsKey: "audioCues.voiceRecordingStopped",
  settingsKey: "accessibility.signals.voiceRecordingStopped"
});
let ua = Ne;
class Zie extends V {
  constructor(e, t = []) {
    super(), this.logger = new NU([e, ...t]), this._register(e.onDidChangeLogLevel((i) => this.setLevel(i)));
  }
  get onDidChangeLogLevel() {
    return this.logger.onDidChangeLogLevel;
  }
  setLevel(e) {
    this.logger.setLevel(e);
  }
  getLevel() {
    return this.logger.getLevel();
  }
  trace(e, ...t) {
    this.logger.trace(e, ...t);
  }
  debug(e, ...t) {
    this.logger.debug(e, ...t);
  }
  info(e, ...t) {
    this.logger.info(e, ...t);
  }
  warn(e, ...t) {
    this.logger.warn(e, ...t);
  }
  error(e, ...t) {
    this.logger.error(e, ...t);
  }
}
const m8 = [];
function p8(s) {
  m8.push(s);
}
function ene() {
  return m8.slice(0);
}
class tne {
  getParseResult(e) {
  }
}
var Ha = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hi = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class ine {
  constructor(e) {
    this.disposed = !1, this.model = e, this._onWillDispose = new B();
  }
  get textEditorModel() {
    return this.model;
  }
  dispose() {
    this.disposed = !0, this._onWillDispose.fire();
  }
}
let eD = class {
  constructor(e) {
    this.modelService = e;
  }
  createModelReference(e) {
    const t = this.modelService.getModel(e);
    return t ? Promise.resolve(new Wz(new ine(t))) : Promise.reject(new Error("Model not found"));
  }
};
eD = Ha([
  hi(0, Fi)
], eD);
const W1 = class W1 {
  show() {
    return W1.NULL_PROGRESS_RUNNER;
  }
  async showWhile(e, t) {
    await e;
  }
};
W1.NULL_PROGRESS_RUNNER = {
  done: () => {
  },
  total: () => {
  },
  worked: () => {
  }
};
let tD = W1;
class nne {
  withProgress(e, t, i) {
    return t({
      report: () => {
      }
    });
  }
}
class sne {
  constructor() {
    this.isExtensionDevelopment = !1, this.isBuilt = !1;
  }
}
class one {
  async confirm(e) {
    return {
      confirmed: this.doConfirm(e.message, e.detail),
      checkboxChecked: !1
      // unsupported
    };
  }
  doConfirm(e, t) {
    let i = e;
    return t && (i = i + `

` + t), vt.confirm(i);
  }
  async prompt(e) {
    let t;
    if (this.doConfirm(e.message, e.detail)) {
      const n = [...e.buttons ?? []];
      e.cancelButton && typeof e.cancelButton != "string" && typeof e.cancelButton != "boolean" && n.push(e.cancelButton), t = await n[0]?.run({ checkboxChecked: !1 });
    }
    return { result: t };
  }
  async error(e, t) {
    await this.prompt({ type: ii.Error, message: e, detail: t });
  }
}
const pA = class pA {
  info(e) {
    return this.notify({ severity: ii.Info, message: e });
  }
  warn(e) {
    return this.notify({ severity: ii.Warning, message: e });
  }
  error(e) {
    return this.notify({ severity: ii.Error, message: e });
  }
  notify(e) {
    switch (e.severity) {
      case ii.Error:
        console.error(e.message);
        break;
      case ii.Warning:
        console.warn(e.message);
        break;
      default:
        console.log(e.message);
        break;
    }
    return pA.NO_OP;
  }
  prompt(e, t, i, n) {
    return pA.NO_OP;
  }
  status(e, t) {
    return V.None;
  }
};
pA.NO_OP = new ij();
let iD = pA, nD = class {
  constructor(e) {
    this._onWillExecuteCommand = new B(), this._onDidExecuteCommand = new B(), this.onDidExecuteCommand = this._onDidExecuteCommand.event, this._instantiationService = e;
  }
  executeCommand(e, ...t) {
    const i = mt.getCommand(e);
    if (!i)
      return Promise.reject(new Error(`command '${e}' not found`));
    try {
      this._onWillExecuteCommand.fire({ commandId: e, args: t });
      const n = this._instantiationService.invokeFunction.apply(this._instantiationService, [i.handler, ...t]);
      return this._onDidExecuteCommand.fire({ commandId: e, args: t }), Promise.resolve(n);
    } catch (n) {
      return Promise.reject(n);
    }
  }
};
nD = Ha([
  hi(0, ke)
], nD);
let am = class extends vq {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o), this._cachedResolver = null, this._dynamicKeybindings = [], this._domNodeListeners = [];
    const a = (g) => {
      const m = new X();
      m.add(U(g, ee.KEY_DOWN, (p) => {
        const A = new Mt(p);
        this._dispatch(A, A.target) && (A.preventDefault(), A.stopPropagation());
      })), m.add(U(g, ee.KEY_UP, (p) => {
        const A = new Mt(p);
        this._singleModifierDispatch(A, A.target) && A.preventDefault();
      })), this._domNodeListeners.push(new rne(g, m));
    }, l = (g) => {
      for (let m = 0; m < this._domNodeListeners.length; m++) {
        const p = this._domNodeListeners[m];
        p.domNode === g && (this._domNodeListeners.splice(m, 1), p.dispose());
      }
    }, c = (g) => {
      g.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || a(g.getContainerDomNode());
    }, d = (g) => {
      g.getOption(
        61
        /* EditorOption.inDiffEditor */
      ) || l(g.getContainerDomNode());
    };
    this._register(r.onCodeEditorAdd(c)), this._register(r.onCodeEditorRemove(d)), r.listCodeEditors().forEach(c);
    const h = (g) => {
      a(g.getContainerDomNode());
    }, u = (g) => {
      l(g.getContainerDomNode());
    };
    this._register(r.onDiffEditorAdd(h)), this._register(r.onDiffEditorRemove(u)), r.listDiffEditors().forEach(h);
  }
  addDynamicKeybinding(e, t, i, n) {
    return jo(mt.registerCommand(e, i), this.addDynamicKeybindings([{
      keybinding: t,
      command: e,
      when: n
    }]));
  }
  addDynamicKeybindings(e) {
    const t = e.map((i) => ({
      keybinding: BE(i.keybinding, Us),
      command: i.command ?? null,
      commandArgs: i.commandArgs,
      when: i.when,
      weight1: 1e3,
      weight2: 0,
      extensionId: null,
      isBuiltinExtension: !1
    }));
    return this._dynamicKeybindings = this._dynamicKeybindings.concat(t), this.updateResolver(), we(() => {
      for (let i = 0; i < this._dynamicKeybindings.length; i++)
        if (this._dynamicKeybindings[i] === t[0]) {
          this._dynamicKeybindings.splice(i, t.length), this.updateResolver();
          return;
        }
    });
  }
  updateResolver() {
    this._cachedResolver = null, this._onDidUpdateKeybindings.fire();
  }
  _getResolver() {
    if (!this._cachedResolver) {
      const e = this._toNormalizedKeybindingItems(Hn.getDefaultKeybindings(), !0), t = this._toNormalizedKeybindingItems(this._dynamicKeybindings, !1);
      this._cachedResolver = new Fp(e, t, (i) => this._log(i));
    }
    return this._cachedResolver;
  }
  _documentHasFocus() {
    return vt.document.hasFocus();
  }
  _toNormalizedKeybindingItems(e, t) {
    const i = [];
    let n = 0;
    for (const o of e) {
      const r = o.when || void 0, a = o.keybinding;
      if (!a)
        i[n++] = new X2(void 0, o.command, o.commandArgs, r, t, null, !1);
      else {
        const l = YA.resolveKeybinding(a, Us);
        for (const c of l)
          i[n++] = new X2(c, o.command, o.commandArgs, r, t, null, !1);
      }
    }
    return i;
  }
  resolveKeyboardEvent(e) {
    const t = new Hl(e.ctrlKey, e.shiftKey, e.altKey, e.metaKey, e.keyCode);
    return new YA([t], Us);
  }
};
am = Ha([
  hi(0, Se),
  hi(1, bi),
  hi(2, eo),
  hi(3, Oi),
  hi(4, Es),
  hi(5, Nt)
], am);
class rne extends V {
  constructor(e, t) {
    super(), this.domNode = e, this._register(t);
  }
}
function AO(s) {
  return s && typeof s == "object" && (!s.overrideIdentifier || typeof s.overrideIdentifier == "string") && (!s.resource || s.resource instanceof _e);
}
let uv = class {
  constructor(e) {
    this.logService = e, this._onDidChangeConfiguration = new B(), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event;
    const t = new $ie(e);
    this._configuration = new eS(t.reload(), Ui.createEmptyModel(e), Ui.createEmptyModel(e), Ui.createEmptyModel(e), Ui.createEmptyModel(e), Ui.createEmptyModel(e), new ws(), Ui.createEmptyModel(e), new ws(), e), t.dispose();
  }
  getValue(e, t) {
    const i = typeof e == "string" ? e : void 0, n = AO(e) ? e : AO(t) ? t : {};
    return this._configuration.getValue(i, n, void 0);
  }
  updateValues(e) {
    const t = { data: this._configuration.toData() }, i = [];
    for (const n of e) {
      const [o, r] = n;
      this.getValue(o) !== r && (this._configuration.updateValue(o, r), i.push(o));
    }
    if (i.length > 0) {
      const n = new Aq({ keys: i, overrides: [] }, t, this._configuration, void 0, this.logService);
      n.source = 8, this._onDidChangeConfiguration.fire(n);
    }
    return Promise.resolve();
  }
  updateValue(e, t, i, n) {
    return this.updateValues([[e, t]]);
  }
  inspect(e, t = {}) {
    return this._configuration.inspect(e, t, void 0);
  }
};
uv = Ha([
  hi(0, Es)
], uv);
let sD = class {
  constructor(e, t, i) {
    this.configurationService = e, this.modelService = t, this.languageService = i, this._onDidChangeConfiguration = new B(), this.configurationService.onDidChangeConfiguration((n) => {
      this._onDidChangeConfiguration.fire({ affectedKeys: n.affectedKeys, affectsConfiguration: (o, r) => n.affectsConfiguration(r) });
    });
  }
  getValue(e, t, i) {
    const n = F.isIPosition(t) ? t : null, o = n ? typeof i == "string" ? i : void 0 : typeof t == "string" ? t : void 0, r = e ? this.getLanguage(e, n) : void 0;
    return typeof o > "u" ? this.configurationService.getValue({
      resource: e,
      overrideIdentifier: r
    }) : this.configurationService.getValue(o, {
      resource: e,
      overrideIdentifier: r
    });
  }
  getLanguage(e, t) {
    const i = this.modelService.getModel(e);
    return i ? t ? i.getLanguageIdAtPosition(t.lineNumber, t.column) : i.getLanguageId() : this.languageService.guessLanguageIdByFilepathOrFirstLine(e);
  }
};
sD = Ha([
  hi(0, ht),
  hi(1, Fi),
  hi(2, si)
], sD);
let oD = class {
  constructor(e) {
    this.configurationService = e;
  }
  getEOL(e, t) {
    const i = this.configurationService.getValue("files.eol", { overrideIdentifier: t, resource: e });
    return i && typeof i == "string" && i !== "auto" ? i : Fn || ze ? `
` : `\r
`;
  }
};
oD = Ha([
  hi(0, ht)
], oD);
class ane {
  publicLog2() {
  }
}
const AA = class AA {
  constructor() {
    const e = _e.from({ scheme: AA.SCHEME, authority: "model", path: "/" });
    this.workspace = { id: D3, folders: [new Oq({ uri: e, name: "", index: 0 })] };
  }
  getWorkspace() {
    return this.workspace;
  }
  getWorkspaceFolder(e) {
    return e && e.scheme === AA.SCHEME ? this.workspace.folders[0] : null;
  }
};
AA.SCHEME = "inmemory";
let rD = AA;
function gv(s, e, t) {
  if (!e || !(s instanceof uv))
    return;
  const i = [];
  Object.keys(e).forEach((n) => {
    uq(n) && i.push([`editor.${n}`, e[n]]), t && gq(n) && i.push([`diffEditor.${n}`, e[n]]);
  }), i.length > 0 && s.updateValues(i);
}
let aD = class {
  constructor(e) {
    this._modelService = e;
  }
  hasPreviewHandler() {
    return !1;
  }
  async apply(e, t) {
    const i = Array.isArray(e) ? e : RN.convert(e), n = /* @__PURE__ */ new Map();
    for (const a of i) {
      if (!(a instanceof Dh))
        throw new Error("bad edit - only text edits are supported");
      const l = this._modelService.getModel(a.resource);
      if (!l)
        throw new Error("bad edit - model not found");
      if (typeof a.versionId == "number" && l.getVersionId() !== a.versionId)
        throw new Error("bad state - model changed in the meantime");
      let c = n.get(l);
      c || (c = [], n.set(l, c)), c.push(ms.replaceMove(E.lift(a.textEdit.range), a.textEdit.text));
    }
    let o = 0, r = 0;
    for (const [a, l] of n)
      a.pushStackElement(), a.pushEditOperations([], l, () => []), a.pushStackElement(), r += 1, o += l.length;
    return {
      ariaSummary: Vf(jL.bulkEditServiceSummary, o, r),
      isApplied: o > 0
    };
  }
};
aD = Ha([
  hi(0, Fi)
], aD);
class lne {
  getUriLabel(e, t) {
    return e.scheme === "file" ? e.fsPath : e.path;
  }
  getUriBasenameLabel(e) {
    return Xo(e);
  }
}
let lD = class extends rq {
  constructor(e, t) {
    super(e), this._codeEditorService = t;
  }
  showContextView(e, t, i) {
    if (!t) {
      const n = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
      n && (t = n.getContainerDomNode());
    }
    return super.showContextView(e, t, i);
  }
};
lD = Ha([
  hi(0, wd),
  hi(1, Nt)
], lD);
class cne {
  constructor() {
    this._neverEmitter = new B(), this.onDidChangeTrust = this._neverEmitter.event;
  }
  isWorkspaceTrusted() {
    return !0;
  }
}
class dne extends $L {
  constructor() {
    super();
  }
}
class hne extends Zie {
  constructor() {
    super(new MU());
  }
}
let cD = class extends lk {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n, o, r), this.configure({ blockMouse: !1 });
  }
};
cD = Ha([
  hi(0, eo),
  hi(1, Oi),
  hi(2, Yl),
  hi(3, bt),
  hi(4, sr),
  hi(5, Se)
], cD);
const dD = {
  amdModuleId: "vs/editor/common/services/editorSimpleWorker",
  esmModuleLocation: void 0,
  label: "editorWorkerService"
};
let hD = class extends cL {
  constructor(e, t, i, n, o) {
    super(dD, e, t, i, n, o);
  }
};
hD = Ha([
  hi(0, Fi),
  hi(1, cN),
  hi(2, Es),
  hi(3, tn),
  hi(4, ye)
], hD);
class une {
  async playSignal(e, t) {
  }
}
$e(
  Es,
  hne,
  0
  /* InstantiationType.Eager */
);
$e(
  ht,
  uv,
  0
  /* InstantiationType.Eager */
);
$e(
  cN,
  sD,
  0
  /* InstantiationType.Eager */
);
$e(
  k5,
  oD,
  0
  /* InstantiationType.Eager */
);
$e(
  BC,
  rD,
  0
  /* InstantiationType.Eager */
);
$e(
  Zf,
  lne,
  0
  /* InstantiationType.Eager */
);
$e(
  eo,
  ane,
  0
  /* InstantiationType.Eager */
);
$e(
  T5,
  one,
  0
  /* InstantiationType.Eager */
);
$e(
  uN,
  sne,
  0
  /* InstantiationType.Eager */
);
$e(
  Oi,
  iD,
  0
  /* InstantiationType.Eager */
);
$e(
  Pa,
  uc,
  0
  /* InstantiationType.Eager */
);
$e(
  si,
  dne,
  0
  /* InstantiationType.Eager */
);
$e(
  cr,
  Tie,
  0
  /* InstantiationType.Eager */
);
$e(
  Fi,
  Ck,
  0
  /* InstantiationType.Eager */
);
$e(
  KN,
  gk,
  0
  /* InstantiationType.Eager */
);
$e(
  Se,
  Zk,
  0
  /* InstantiationType.Eager */
);
$e(
  kq,
  nne,
  0
  /* InstantiationType.Eager */
);
$e(
  P_,
  tD,
  0
  /* InstantiationType.Eager */
);
$e(
  Jl,
  K$,
  0
  /* InstantiationType.Eager */
);
$e(
  Sd,
  hD,
  0
  /* InstantiationType.Eager */
);
$e(
  L3,
  aD,
  0
  /* InstantiationType.Eager */
);
$e(
  Hq,
  cne,
  0
  /* InstantiationType.Eager */
);
$e(
  Zs,
  eD,
  0
  /* InstantiationType.Eager */
);
$e(
  Lo,
  jk,
  0
  /* InstantiationType.Eager */
);
$e(
  Do,
  Qte,
  0
  /* InstantiationType.Eager */
);
$e(
  bi,
  nD,
  0
  /* InstantiationType.Eager */
);
$e(
  bt,
  am,
  0
  /* InstantiationType.Eager */
);
$e(
  Q_,
  Uk,
  0
  /* InstantiationType.Eager */
);
$e(
  Yl,
  lD,
  0
  /* InstantiationType.Eager */
);
$e(
  lr,
  uk,
  0
  /* InstantiationType.Eager */
);
$e(
  Yu,
  $k,
  0
  /* InstantiationType.Eager */
);
$e(
  ar,
  cD,
  0
  /* InstantiationType.Eager */
);
$e(
  sr,
  Yk,
  0
  /* InstantiationType.Eager */
);
$e(
  bS,
  une,
  0
  /* InstantiationType.Eager */
);
$e(
  SW,
  tne,
  0
  /* InstantiationType.Eager */
);
var Ae;
(function(s) {
  const e = new Lm();
  for (const [l, c] of LR())
    e.set(l, c);
  const t = new hv(e, !0);
  e.set(ke, t);
  function i(l) {
    n || r({});
    const c = e.get(l);
    if (!c)
      throw new Error("Missing service " + l);
    return c instanceof ha ? t.invokeFunction((d) => d.get(l)) : c;
  }
  s.get = i;
  let n = !1;
  const o = new B();
  function r(l) {
    if (n)
      return t;
    n = !0;
    for (const [d, h] of LR())
      e.get(d) || e.set(d, h);
    for (const d in l)
      if (l.hasOwnProperty(d)) {
        const h = We(d);
        e.get(h) instanceof ha && e.set(h, l[d]);
      }
    const c = ene();
    for (const d of c)
      try {
        t.createInstance(d);
      } catch (h) {
        Pe(h);
      }
    return o.fire(), t;
  }
  s.initialize = r;
  function a(l) {
    if (n)
      return l();
    const c = new X(), d = c.add(o.event(() => {
      d.dispose(), c.add(l());
    }));
    return c;
  }
  s.withServices = a;
})(Ae || (Ae = {}));
function gne(s, e) {
  return new fne(s, e);
}
class fne extends AC {
  constructor(e, t) {
    const i = {
      amdModuleId: dD.amdModuleId,
      esmModuleLocation: dD.esmModuleLocation,
      label: t.label
    };
    super(i, t.keepIdleModels || !1, e), this._foreignModuleId = t.moduleId, this._foreignModuleCreateData = t.createData || null, this._foreignModuleHost = t.host || null, this._foreignProxy = null;
  }
  // foreign host request
  fhr(e, t) {
    if (!this._foreignModuleHost || typeof this._foreignModuleHost[e] != "function")
      return Promise.reject(new Error("Missing method " + e + " or missing main thread foreign host."));
    try {
      return Promise.resolve(this._foreignModuleHost[e].apply(this._foreignModuleHost, t));
    } catch (i) {
      return Promise.reject(i);
    }
  }
  _getForeignProxy() {
    return this._foreignProxy || (this._foreignProxy = this._getProxy().then((e) => {
      const t = this._foreignModuleHost ? xx(this._foreignModuleHost) : [];
      return e.$loadForeignModule(this._foreignModuleId, this._foreignModuleCreateData, t).then((i) => {
        this._foreignModuleCreateData = null;
        const n = (a, l) => e.$fmr(a, l), o = (a, l) => function() {
          const c = Array.prototype.slice.call(arguments, 0);
          return l(a, c);
        }, r = {};
        for (const a of i)
          r[a] = o(a, n);
        return r;
      });
    })), this._foreignProxy;
  }
  getProxy() {
    return this._getForeignProxy();
  }
  withSyncedResources(e) {
    return this.workerWithSyncedResources(e).then((t) => this.getProxy());
  }
}
const wS = {
  ICodeEditor: "vs.editor.ICodeEditor",
  IDiffEditor: "vs.editor.IDiffEditor"
};
class Qo {
  constructor(e, t, i, n) {
    this.startColumn = e, this.endColumn = t, this.className = i, this.type = n, this._lineDecorationBrand = void 0;
  }
  static _equals(e, t) {
    return e.startColumn === t.startColumn && e.endColumn === t.endColumn && e.className === t.className && e.type === t.type;
  }
  static equalsArr(e, t) {
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!Qo._equals(e[o], t[o]))
        return !1;
    return !0;
  }
  static extractWrapped(e, t, i) {
    if (e.length === 0)
      return e;
    const n = t + 1, o = i + 1, r = i - t, a = [];
    let l = 0;
    for (const c of e)
      c.endColumn <= n || c.startColumn >= o || (a[l++] = new Qo(Math.max(1, c.startColumn - n + 1), Math.min(r + 1, c.endColumn - n + 1), c.className, c.type));
    return a;
  }
  static filter(e, t, i, n) {
    if (e.length === 0)
      return [];
    const o = [];
    let r = 0;
    for (let a = 0, l = e.length; a < l; a++) {
      const c = e[a], d = c.range;
      if (d.endLineNumber < t || d.startLineNumber > t || d.isEmpty() && (c.type === 0 || c.type === 3))
        continue;
      const h = d.startLineNumber === t ? d.startColumn : i, u = d.endLineNumber === t ? d.endColumn : n;
      o[r++] = new Qo(h, u, c.inlineClassName, c.type);
    }
    return o;
  }
  static _typeCompare(e, t) {
    const i = [2, 0, 1, 3];
    return i[e] - i[t];
  }
  static compare(e, t) {
    if (e.startColumn !== t.startColumn)
      return e.startColumn - t.startColumn;
    if (e.endColumn !== t.endColumn)
      return e.endColumn - t.endColumn;
    const i = Qo._typeCompare(e.type, t.type);
    return i !== 0 ? i : e.className !== t.className ? e.className < t.className ? -1 : 1 : 0;
  }
}
class _O {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.className = i, this.metadata = n;
  }
}
class fv {
  constructor() {
    this.stopOffsets = [], this.classNames = [], this.metadata = [], this.count = 0;
  }
  static _metadata(e) {
    let t = 0;
    for (let i = 0, n = e.length; i < n; i++)
      t |= e[i];
    return t;
  }
  consumeLowerThan(e, t, i) {
    for (; this.count > 0 && this.stopOffsets[0] < e; ) {
      let n = 0;
      for (; n + 1 < this.count && this.stopOffsets[n] === this.stopOffsets[n + 1]; )
        n++;
      i.push(new _O(t, this.stopOffsets[n], this.classNames.join(" "), fv._metadata(this.metadata))), t = this.stopOffsets[n] + 1, this.stopOffsets.splice(0, n + 1), this.classNames.splice(0, n + 1), this.metadata.splice(0, n + 1), this.count -= n + 1;
    }
    return this.count > 0 && t < e && (i.push(new _O(t, e - 1, this.classNames.join(" "), fv._metadata(this.metadata))), t = e), t;
  }
  insert(e, t, i) {
    if (this.count === 0 || this.stopOffsets[this.count - 1] <= e)
      this.stopOffsets.push(e), this.classNames.push(t), this.metadata.push(i);
    else
      for (let n = 0; n < this.count; n++)
        if (this.stopOffsets[n] >= e) {
          this.stopOffsets.splice(n, 0, e), this.classNames.splice(n, 0, t), this.metadata.splice(n, 0, i);
          break;
        }
    this.count++;
  }
}
class mne {
  /**
   * Normalize line decorations. Overlapping decorations will generate multiple segments
   */
  static normalize(e, t) {
    if (t.length === 0)
      return [];
    const i = [], n = new fv();
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      let c = l.startColumn, d = l.endColumn;
      const h = l.className, u = l.type === 1 ? 2 : l.type === 2 ? 4 : 0;
      if (c > 1) {
        const p = e.charCodeAt(c - 2);
        Si(p) && c--;
      }
      if (d > 1) {
        const p = e.charCodeAt(d - 2);
        Si(p) && d--;
      }
      const g = c - 1, m = d - 2;
      o = n.consumeLowerThan(g, o, i), n.count === 0 && (o = g), n.insert(m, h, u);
    }
    return n.consumeLowerThan(1073741824, o, i), i;
  }
}
class Ni {
  constructor(e, t, i, n) {
    this.endIndex = e, this.type = t, this.metadata = i, this.containsRTL = n, this._linePartBrand = void 0;
  }
  isWhitespace() {
    return !!(this.metadata & 1);
  }
  isPseudoAfter() {
    return !!(this.metadata & 4);
  }
}
class A8 {
  constructor(e, t) {
    this.startOffset = e, this.endOffset = t;
  }
  equals(e) {
    return this.startOffset === e.startOffset && this.endOffset === e.endOffset;
  }
}
class km {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g, m, p, A, _, b, C) {
    this.useMonospaceOptimizations = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.continuesWithWrappedLine = n, this.isBasicASCII = o, this.containsRTL = r, this.fauxIndentLength = a, this.lineTokens = l, this.lineDecorations = c.sort(Qo.compare), this.tabSize = d, this.startVisibleColumn = h, this.spaceWidth = u, this.stopRenderingLineAfter = p, this.renderWhitespace = A === "all" ? 4 : A === "boundary" ? 1 : A === "selection" ? 2 : A === "trailing" ? 3 : 0, this.renderControlCharacters = _, this.fontLigatures = b, this.selectionsOnLine = C && C.sort((x, y) => x.startOffset < y.startOffset ? -1 : 1);
    const w = Math.abs(m - u), S = Math.abs(g - u);
    w < S ? (this.renderSpaceWidth = m, this.renderSpaceCharCode = 11825) : (this.renderSpaceWidth = g, this.renderSpaceCharCode = 183);
  }
  sameSelection(e) {
    if (this.selectionsOnLine === null)
      return e === null;
    if (e === null || e.length !== this.selectionsOnLine.length)
      return !1;
    for (let t = 0; t < this.selectionsOnLine.length; t++)
      if (!this.selectionsOnLine[t].equals(e[t]))
        return !1;
    return !0;
  }
  equals(e) {
    return this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineContent === e.lineContent && this.continuesWithWrappedLine === e.continuesWithWrappedLine && this.isBasicASCII === e.isBasicASCII && this.containsRTL === e.containsRTL && this.fauxIndentLength === e.fauxIndentLength && this.tabSize === e.tabSize && this.startVisibleColumn === e.startVisibleColumn && this.spaceWidth === e.spaceWidth && this.renderSpaceWidth === e.renderSpaceWidth && this.renderSpaceCharCode === e.renderSpaceCharCode && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.fontLigatures === e.fontLigatures && Qo.equalsArr(this.lineDecorations, e.lineDecorations) && this.lineTokens.equals(e.lineTokens) && this.sameSelection(e.selectionsOnLine);
  }
}
class _8 {
  constructor(e, t) {
    this.partIndex = e, this.charIndex = t;
  }
}
class ga {
  static getPartIndex(e) {
    return (e & 4294901760) >>> 16;
  }
  static getCharIndex(e) {
    return (e & 65535) >>> 0;
  }
  constructor(e, t) {
    this.length = e, this._data = new Uint32Array(this.length), this._horizontalOffset = new Uint32Array(this.length);
  }
  setColumnInfo(e, t, i, n) {
    const o = (t << 16 | i << 0) >>> 0;
    this._data[e - 1] = o, this._horizontalOffset[e - 1] = n;
  }
  getHorizontalOffset(e) {
    return this._horizontalOffset.length === 0 ? 0 : this._horizontalOffset[e - 1];
  }
  charOffsetToPartData(e) {
    return this.length === 0 ? 0 : e < 0 ? this._data[0] : e >= this.length ? this._data[this.length - 1] : this._data[e];
  }
  getDomPosition(e) {
    const t = this.charOffsetToPartData(e - 1), i = ga.getPartIndex(t), n = ga.getCharIndex(t);
    return new _8(i, n);
  }
  getColumn(e, t) {
    return this.partDataToCharOffset(e.partIndex, t, e.charIndex) + 1;
  }
  partDataToCharOffset(e, t, i) {
    if (this.length === 0)
      return 0;
    const n = (e << 16 | i << 0) >>> 0;
    let o = 0, r = this.length - 1;
    for (; o + 1 < r; ) {
      const p = o + r >>> 1, A = this._data[p];
      if (A === n)
        return p;
      A > n ? r = p : o = p;
    }
    if (o === r)
      return o;
    const a = this._data[o], l = this._data[r];
    if (a === n)
      return o;
    if (l === n)
      return r;
    const c = ga.getPartIndex(a), d = ga.getCharIndex(a), h = ga.getPartIndex(l);
    let u;
    c !== h ? u = t : u = ga.getCharIndex(l);
    const g = i - d, m = u - i;
    return g <= m ? o : r;
  }
}
class uD {
  constructor(e, t, i) {
    this._renderLineOutputBrand = void 0, this.characterMapping = e, this.containsRTL = t, this.containsForeignElements = i;
  }
}
function ET(s, e) {
  if (s.lineContent.length === 0) {
    if (s.lineDecorations.length > 0) {
      e.appendString("<span>");
      let t = 0, i = 0, n = 0;
      for (const r of s.lineDecorations)
        (r.type === 1 || r.type === 2) && (e.appendString('<span class="'), e.appendString(r.className), e.appendString('"></span>'), r.type === 1 && (n |= 1, t++), r.type === 2 && (n |= 2, i++));
      e.appendString("</span>");
      const o = new ga(1, t + i);
      return o.setColumnInfo(1, t, 0, 0), new uD(o, !1, n);
    }
    return e.appendString("<span><span></span></span>"), new uD(
      new ga(0, 0),
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  return yne(_ne(s), e);
}
class pne {
  constructor(e, t, i, n) {
    this.characterMapping = e, this.html = t, this.containsRTL = i, this.containsForeignElements = n;
  }
}
function CS(s) {
  const e = new R0(1e4), t = ET(s, e);
  return new pne(t.characterMapping, e.build(), t.containsRTL, t.containsForeignElements);
}
class Ane {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g, m, p, A) {
    this.fontIsMonospace = e, this.canUseHalfwidthRightwardsArrow = t, this.lineContent = i, this.len = n, this.isOverflowing = o, this.overflowingCharCount = r, this.parts = a, this.containsForeignElements = l, this.fauxIndentLength = c, this.tabSize = d, this.startVisibleColumn = h, this.containsRTL = u, this.spaceWidth = g, this.renderSpaceCharCode = m, this.renderWhitespace = p, this.renderControlCharacters = A;
  }
}
function _ne(s) {
  const e = s.lineContent;
  let t, i, n;
  s.stopRenderingLineAfter !== -1 && s.stopRenderingLineAfter < e.length ? (t = !0, i = e.length - s.stopRenderingLineAfter, n = s.stopRenderingLineAfter) : (t = !1, i = 0, n = e.length);
  let o = bne(e, s.containsRTL, s.lineTokens, s.fauxIndentLength, n);
  s.renderControlCharacters && !s.isBasicASCII && (o = Cne(e, o)), (s.renderWhitespace === 4 || s.renderWhitespace === 1 || s.renderWhitespace === 2 && s.selectionsOnLine || s.renderWhitespace === 3 && !s.continuesWithWrappedLine) && (o = vne(s, e, n, o));
  let r = 0;
  if (s.lineDecorations.length > 0) {
    for (let a = 0, l = s.lineDecorations.length; a < l; a++) {
      const c = s.lineDecorations[a];
      c.type === 3 || c.type === 1 ? r |= 1 : c.type === 2 && (r |= 2);
    }
    o = Sne(e, n, o, s.lineDecorations);
  }
  return s.containsRTL || (o = wne(e, o, !s.isBasicASCII || s.fontLigatures)), new Ane(s.useMonospaceOptimizations, s.canUseHalfwidthRightwardsArrow, e, n, t, i, o, r, s.fauxIndentLength, s.tabSize, s.startVisibleColumn, s.containsRTL, s.spaceWidth, s.renderSpaceCharCode, s.renderWhitespace, s.renderControlCharacters);
}
function bne(s, e, t, i, n) {
  const o = [];
  let r = 0;
  i > 0 && (o[r++] = new Ni(i, "", 0, !1));
  let a = i;
  for (let l = 0, c = t.getCount(); l < c; l++) {
    const d = t.getEndOffset(l);
    if (d <= i)
      continue;
    const h = t.getClassName(l);
    if (d >= n) {
      const g = e ? DA(s.substring(a, n)) : !1;
      o[r++] = new Ni(n, h, 0, g);
      break;
    }
    const u = e ? DA(s.substring(a, d)) : !1;
    o[r++] = new Ni(d, h, 0, u), a = d;
  }
  return o;
}
function wne(s, e, t) {
  let i = 0;
  const n = [];
  let o = 0;
  if (t)
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex;
      if (i + 50 < c) {
        const d = l.type, h = l.metadata, u = l.containsRTL;
        let g = -1, m = i;
        for (let p = i; p < c; p++)
          s.charCodeAt(p) === 32 && (g = p), g !== -1 && p - m >= 50 && (n[o++] = new Ni(g + 1, d, h, u), m = g + 1, g = -1);
        m !== c && (n[o++] = new Ni(c, d, h, u));
      } else
        n[o++] = l;
      i = c;
    }
  else
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r], c = l.endIndex, d = c - i;
      if (d > 50) {
        const h = l.type, u = l.metadata, g = l.containsRTL, m = Math.ceil(
          d / 50
          /* Constants.LongToken */
        );
        for (let p = 1; p < m; p++) {
          const A = i + p * 50;
          n[o++] = new Ni(A, h, u, g);
        }
        n[o++] = new Ni(c, h, u, g);
      } else
        n[o++] = l;
      i = c;
    }
  return n;
}
function b8(s) {
  return s < 32 ? s !== 9 : s === 127 || s >= 8234 && s <= 8238 || s >= 8294 && s <= 8297 || s >= 8206 && s <= 8207 || s === 1564;
}
function Cne(s, e) {
  const t = [];
  let i = new Ni(0, "", 0, !1), n = 0;
  for (const o of e) {
    const r = o.endIndex;
    for (; n < r; n++) {
      const a = s.charCodeAt(n);
      b8(a) && (n > i.endIndex && (i = new Ni(n, o.type, o.metadata, o.containsRTL), t.push(i)), i = new Ni(n + 1, "mtkcontrol", o.metadata, !1), t.push(i));
    }
    n > i.endIndex && (i = new Ni(r, o.type, o.metadata, o.containsRTL), t.push(i));
  }
  return t;
}
function vne(s, e, t, i) {
  const n = s.continuesWithWrappedLine, o = s.fauxIndentLength, r = s.tabSize, a = s.startVisibleColumn, l = s.useMonospaceOptimizations, c = s.selectionsOnLine, d = s.renderWhitespace === 1, h = s.renderWhitespace === 3, u = s.renderSpaceWidth !== s.spaceWidth, g = [];
  let m = 0, p = 0, A = i[p].type, _ = i[p].containsRTL, b = i[p].endIndex;
  const C = i.length;
  let w = !1, S = Sn(e), x;
  S === -1 ? (w = !0, S = t, x = t) : x = Ru(e);
  let y = !1, D = 0, I = c && c[D], Q = a % r;
  for (let W = o; W < t; W++) {
    const j = e.charCodeAt(W);
    I && W >= I.endOffset && (D++, I = c && c[D]);
    let H;
    if (W < S || W > x)
      H = !0;
    else if (j === 9)
      H = !0;
    else if (j === 32)
      if (d)
        if (y)
          H = !0;
        else {
          const J = W + 1 < t ? e.charCodeAt(W + 1) : 0;
          H = J === 32 || J === 9;
        }
      else
        H = !0;
    else
      H = !1;
    if (H && c && (H = !!I && I.startOffset <= W && I.endOffset > W), H && h && (H = w || W > x), H && _ && W >= S && W <= x && (H = !1), y) {
      if (!H || !l && Q >= r) {
        if (u) {
          const J = m > 0 ? g[m - 1].endIndex : o;
          for (let se = J + 1; se <= W; se++)
            g[m++] = new Ni(se, "mtkw", 1, !1);
        } else
          g[m++] = new Ni(W, "mtkw", 1, !1);
        Q = Q % r;
      }
    } else
      (W === b || H && W > o) && (g[m++] = new Ni(W, A, 0, _), Q = Q % r);
    for (j === 9 ? Q = r : sd(j) ? Q += 2 : Q++, y = H; W === b && (p++, p < C); )
      A = i[p].type, _ = i[p].containsRTL, b = i[p].endIndex;
  }
  let P = !1;
  if (y)
    if (n && d) {
      const W = t > 0 ? e.charCodeAt(t - 1) : 0, j = t > 1 ? e.charCodeAt(t - 2) : 0;
      W === 32 && j !== 32 && j !== 9 || (P = !0);
    } else
      P = !0;
  if (P)
    if (u) {
      const W = m > 0 ? g[m - 1].endIndex : o;
      for (let j = W + 1; j <= t; j++)
        g[m++] = new Ni(j, "mtkw", 1, !1);
    } else
      g[m++] = new Ni(t, "mtkw", 1, !1);
  else
    g[m++] = new Ni(t, A, 0, _);
  return g;
}
function Sne(s, e, t, i) {
  i.sort(Qo.compare);
  const n = mne.normalize(s, i), o = n.length;
  let r = 0;
  const a = [];
  let l = 0, c = 0;
  for (let h = 0, u = t.length; h < u; h++) {
    const g = t[h], m = g.endIndex, p = g.type, A = g.metadata, _ = g.containsRTL;
    for (; r < o && n[r].startOffset < m; ) {
      const b = n[r];
      if (b.startOffset > c && (c = b.startOffset, a[l++] = new Ni(c, p, A, _)), b.endOffset + 1 <= m)
        c = b.endOffset + 1, a[l++] = new Ni(c, p + " " + b.className, A | b.metadata, _), r++;
      else {
        c = m, a[l++] = new Ni(c, p + " " + b.className, A | b.metadata, _);
        break;
      }
    }
    m > c && (c = m, a[l++] = new Ni(c, p, A, _));
  }
  const d = t[t.length - 1].endIndex;
  if (r < o && n[r].startOffset === d)
    for (; r < o && n[r].startOffset === d; ) {
      const h = n[r];
      a[l++] = new Ni(c, h.className, h.metadata, !1), r++;
    }
  return a;
}
function yne(s, e) {
  const t = s.fontIsMonospace, i = s.canUseHalfwidthRightwardsArrow, n = s.containsForeignElements, o = s.lineContent, r = s.len, a = s.isOverflowing, l = s.overflowingCharCount, c = s.parts, d = s.fauxIndentLength, h = s.tabSize, u = s.startVisibleColumn, g = s.containsRTL, m = s.spaceWidth, p = s.renderSpaceCharCode, A = s.renderWhitespace, _ = s.renderControlCharacters, b = new ga(r + 1, c.length);
  let C = !1, w = 0, S = u, x = 0, y = 0, D = 0;
  g ? e.appendString('<span dir="ltr">') : e.appendString("<span>");
  for (let I = 0, Q = c.length; I < Q; I++) {
    const P = c[I], W = P.endIndex, j = P.type, H = P.containsRTL, J = A !== 0 && P.isWhitespace(), se = J && !t && (j === "mtkw" || !n), ce = w === W && P.isPseudoAfter();
    if (x = 0, e.appendString("<span "), H && e.appendString('style="unicode-bidi:isolate" '), e.appendString('class="'), e.appendString(se ? "mtkz" : j), e.appendASCIICharCode(
      34
      /* CharCode.DoubleQuote */
    ), J) {
      let he = 0;
      {
        let ae = w, be = S;
        for (; ae < W; ae++) {
          const Ft = (o.charCodeAt(ae) === 9 ? h - be % h : 1) | 0;
          he += Ft, ae >= d && (be += Ft);
        }
      }
      for (se && (e.appendString(' style="width:'), e.appendString(String(m * he)), e.appendString('px"')), e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < W; w++) {
        b.setColumnInfo(w + 1, I - D, x, y), D = 0;
        const ae = o.charCodeAt(w);
        let be, Ce;
        if (ae === 9) {
          be = h - S % h | 0, Ce = be, !i || Ce > 1 ? e.appendCharCode(8594) : e.appendCharCode(65515);
          for (let Ft = 2; Ft <= Ce; Ft++)
            e.appendCharCode(160);
        } else
          be = 2, Ce = 1, e.appendCharCode(p), e.appendCharCode(8204);
        x += be, y += Ce, w >= d && (S += Ce);
      }
    } else
      for (e.appendASCIICharCode(
        62
        /* CharCode.GreaterThan */
      ); w < W; w++) {
        b.setColumnInfo(w + 1, I - D, x, y), D = 0;
        const he = o.charCodeAt(w);
        let ae = 1, be = 1;
        switch (he) {
          case 9:
            ae = h - S % h, be = ae;
            for (let Ce = 1; Ce <= ae; Ce++)
              e.appendCharCode(160);
            break;
          case 32:
            e.appendCharCode(160);
            break;
          case 60:
            e.appendString("&lt;");
            break;
          case 62:
            e.appendString("&gt;");
            break;
          case 38:
            e.appendString("&amp;");
            break;
          case 0:
            _ ? e.appendCharCode(9216) : e.appendString("&#00;");
            break;
          case 65279:
          case 8232:
          case 8233:
          case 133:
            e.appendCharCode(65533);
            break;
          default:
            sd(he) && be++, _ && he < 32 ? e.appendCharCode(9216 + he) : _ && he === 127 ? e.appendCharCode(9249) : _ && b8(he) ? (e.appendString("[U+"), e.appendString(xne(he)), e.appendString("]"), ae = 8, be = ae) : e.appendCharCode(he);
        }
        x += ae, y += be, w >= d && (S += be);
      }
    ce ? D++ : D = 0, w >= r && !C && P.isPseudoAfter() && (C = !0, b.setColumnInfo(w + 1, I, x, y)), e.appendString("</span>");
  }
  return C || b.setColumnInfo(r + 1, c.length - 1, x, y), a && (e.appendString('<span class="mtkoverflow">'), e.appendString(f("showMore", "Show more ({0})", Ene(l))), e.appendString("</span>")), e.appendString("</span>"), new uD(b, g, n);
}
function xne(s) {
  return s.toString(16).toUpperCase().padStart(4, "0");
}
function Ene(s) {
  return s < 1024 ? f("overflow.chars", "{0} chars", s) : s < 1024 * 1024 ? `${(s / 1024).toFixed(1)} KB` : `${(s / 1024 / 1024).toFixed(1)} MB`;
}
class bO {
  constructor(e, t, i, n) {
    this._viewportBrand = void 0, this.top = e | 0, this.left = t | 0, this.width = i | 0, this.height = n | 0;
  }
}
class Lne {
  constructor(e, t) {
    this.tabSize = e, this.data = t;
  }
}
class LT {
  constructor(e, t, i, n, o, r, a) {
    this._viewLineDataBrand = void 0, this.content = e, this.continuesWithWrappedLine = t, this.minColumn = i, this.maxColumn = n, this.startVisibleColumn = o, this.tokens = r, this.inlineDecorations = a;
  }
}
class $s {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    this.minColumn = e, this.maxColumn = t, this.content = i, this.continuesWithWrappedLine = n, this.isBasicASCII = $s.isBasicASCII(i, r), this.containsRTL = $s.containsRTL(i, this.isBasicASCII, o), this.tokens = a, this.inlineDecorations = l, this.tabSize = c, this.startVisibleColumn = d;
  }
  static isBasicASCII(e, t) {
    return t ? WM(e) : !0;
  }
  static containsRTL(e, t, i) {
    return !t && i ? DA(e) : !1;
  }
}
class Jp {
  constructor(e, t, i) {
    this.range = e, this.inlineClassName = t, this.type = i;
  }
}
class kne {
  constructor(e, t, i, n) {
    this.startOffset = e, this.endOffset = t, this.inlineClassName = i, this.inlineClassNameAffectsLetterSpacing = n;
  }
  toInlineDecoration(e) {
    return new Jp(
      new E(e, this.startOffset + 1, e, this.endOffset + 1),
      this.inlineClassName,
      this.inlineClassNameAffectsLetterSpacing ? 3 : 0
      /* InlineDecorationType.Regular */
    );
  }
}
class w8 {
  constructor(e, t) {
    this._viewModelDecorationBrand = void 0, this.range = e, this.options = t;
  }
}
class o_ {
  constructor(e, t, i) {
    this.color = e, this.zIndex = t, this.data = i;
  }
  static compareByRenderingProps(e, t) {
    return e.zIndex === t.zIndex ? e.color < t.color ? -1 : e.color > t.color ? 1 : 0 : e.zIndex - t.zIndex;
  }
  static equals(e, t) {
    return e.color === t.color && e.zIndex === t.zIndex && pi(e.data, t.data);
  }
  static equalsArr(e, t) {
    return pi(e, t, o_.equals);
  }
}
function Dne(s) {
  return Array.isArray(s);
}
function Ine(s) {
  return !Dne(s);
}
function C8(s) {
  return typeof s == "string";
}
function wO(s) {
  return !C8(s);
}
function oh(s) {
  return !s;
}
function Fl(s, e) {
  return s.ignoreCase && e ? e.toLowerCase() : e;
}
function CO(s) {
  return s.replace(/[&<>'"_]/g, "-");
}
function Mne(s, e) {
  console.log(`${s.languageId}: ${e}`);
}
function It(s, e) {
  return new Error(`${s.languageId}: ${e}`);
}
function Cc(s, e, t, i, n) {
  const o = /\$((\$)|(#)|(\d\d?)|[sS](\d\d?)|@(\w+))/g;
  let r = null;
  return e.replace(o, function(a, l, c, d, h, u, g, m, p) {
    return oh(c) ? oh(d) ? !oh(h) && h < i.length ? Fl(s, i[h]) : !oh(g) && s && typeof s[g] == "string" ? s[g] : (r === null && (r = n.split("."), r.unshift(n)), !oh(u) && u < r.length ? Fl(s, r[u]) : "") : Fl(s, t) : "$";
  });
}
function Nne(s, e, t) {
  const i = /\$[sS](\d\d?)/g;
  let n = null;
  return e.replace(i, function(o, r) {
    return n === null && (n = t.split("."), n.unshift(t)), !oh(r) && r < n.length ? Fl(s, n[r]) : "";
  });
}
function Wb(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    const i = s.tokenizer[t];
    if (i)
      return i;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return null;
}
function Tne(s, e) {
  let t = e;
  for (; t && t.length > 0; ) {
    if (s.stateNames[t])
      return !0;
    const n = t.lastIndexOf(".");
    n < 0 ? t = null : t = t.substr(0, n);
  }
  return !1;
}
var Bne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Rne = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, gD;
const v8 = 5, V1 = class V1 {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new Df(e, t);
    let i = Df.getStackElementId(e);
    i.length > 0 && (i += "|"), i += t;
    let n = this._entries[i];
    return n || (n = new Df(e, t), this._entries[i] = n, n);
  }
};
V1._INSTANCE = new V1(v8);
let r_ = V1;
class Df {
  constructor(e, t) {
    this.parent = e, this.state = t, this.depth = (this.parent ? this.parent.depth : 0) + 1;
  }
  static getStackElementId(e) {
    let t = "";
    for (; e !== null; )
      t.length > 0 && (t += "|"), t += e.state, e = e.parent;
    return t;
  }
  static _equals(e, t) {
    for (; e !== null && t !== null; ) {
      if (e === t)
        return !0;
      if (e.state !== t.state)
        return !1;
      e = e.parent, t = t.parent;
    }
    return e === null && t === null;
  }
  equals(e) {
    return Df._equals(this, e);
  }
  push(e) {
    return r_.create(this, e);
  }
  pop() {
    return this.parent;
  }
  popall() {
    let e = this;
    for (; e.parent; )
      e = e.parent;
    return e;
  }
  switchTo(e) {
    return r_.create(this.parent, e);
  }
}
class zg {
  constructor(e, t) {
    this.languageId = e, this.state = t;
  }
  equals(e) {
    return this.languageId === e.languageId && this.state.equals(e.state);
  }
  clone() {
    return this.state.clone() === this.state ? this : new zg(this.languageId, this.state);
  }
}
const z1 = class z1 {
  static create(e, t) {
    return this._INSTANCE.create(e, t);
  }
  constructor(e) {
    this._maxCacheDepth = e, this._entries = /* @__PURE__ */ Object.create(null);
  }
  create(e, t) {
    if (t !== null)
      return new qp(e, t);
    if (e !== null && e.depth >= this._maxCacheDepth)
      return new qp(e, t);
    const i = Df.getStackElementId(e);
    let n = this._entries[i];
    return n || (n = new qp(e, null), this._entries[i] = n, n);
  }
};
z1._INSTANCE = new z1(v8);
let vc = z1;
class qp {
  constructor(e, t) {
    this.stack = e, this.embeddedLanguageData = t;
  }
  clone() {
    return (this.embeddedLanguageData ? this.embeddedLanguageData.clone() : null) === this.embeddedLanguageData ? this : vc.create(this.stack, this.embeddedLanguageData);
  }
  equals(e) {
    return !(e instanceof qp) || !this.stack.equals(e.stack) ? !1 : this.embeddedLanguageData === null && e.embeddedLanguageData === null ? !0 : this.embeddedLanguageData === null || e.embeddedLanguageData === null ? !1 : this.embeddedLanguageData.equals(e.embeddedLanguageData);
  }
}
class Fne {
  constructor() {
    this._tokens = [], this._languageId = null, this._lastTokenType = null, this._lastTokenLanguage = null;
  }
  enterLanguage(e) {
    this._languageId = e;
  }
  emit(e, t) {
    this._lastTokenType === t && this._lastTokenLanguage === this._languageId || (this._lastTokenType = t, this._lastTokenLanguage = this._languageId, this._tokens.push(new xA(e, t, this._languageId)));
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = ci.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenize(e, t, r);
    if (n !== 0)
      for (const c of l.tokens)
        this._tokens.push(new xA(c.offset + n, c.type, c.language));
    else
      this._tokens = this._tokens.concat(l.tokens);
    return this._lastTokenType = null, this._lastTokenLanguage = null, this._languageId = null, l.endState;
  }
  finalize(e) {
    return new BM(this._tokens, e);
  }
}
class mv {
  constructor(e, t) {
    this._languageService = e, this._theme = t, this._prependTokens = null, this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0;
  }
  enterLanguage(e) {
    this._currentLanguageId = this._languageService.languageIdCodec.encodeLanguageId(e);
  }
  emit(e, t) {
    const i = this._theme.match(this._currentLanguageId, t) | 1024;
    this._lastTokenMetadata !== i && (this._lastTokenMetadata = i, this._tokens.push(e), this._tokens.push(i));
  }
  static _merge(e, t, i) {
    const n = e !== null ? e.length : 0, o = t.length, r = i !== null ? i.length : 0;
    if (n === 0 && o === 0 && r === 0)
      return new Uint32Array(0);
    if (n === 0 && o === 0)
      return i;
    if (o === 0 && r === 0)
      return e;
    const a = new Uint32Array(n + o + r);
    e !== null && a.set(e);
    for (let l = 0; l < o; l++)
      a[n + l] = t[l];
    return i !== null && a.set(i, n + o), a;
  }
  nestedLanguageTokenize(e, t, i, n) {
    const o = i.languageId, r = i.state, a = ci.get(o);
    if (!a)
      return this.enterLanguage(o), this.emit(n, ""), r;
    const l = a.tokenizeEncoded(e, t, r);
    if (n !== 0)
      for (let c = 0, d = l.tokens.length; c < d; c += 2)
        l.tokens[c] += n;
    return this._prependTokens = mv._merge(this._prependTokens, this._tokens, l.tokens), this._tokens = [], this._currentLanguageId = 0, this._lastTokenMetadata = 0, l.endState;
  }
  finalize(e) {
    return new A0(mv._merge(this._prependTokens, this._tokens, null), e);
  }
}
let a_ = gD = class extends V {
  constructor(e, t, i, n, o) {
    super(), this._configurationService = o, this._languageService = e, this._standaloneThemeService = t, this._languageId = i, this._lexer = n, this._embeddedLanguages = /* @__PURE__ */ Object.create(null), this.embeddedLoaded = Promise.resolve(void 0);
    let r = !1;
    this._register(ci.onDidChange((a) => {
      if (r)
        return;
      let l = !1;
      for (let c = 0, d = a.changedLanguages.length; c < d; c++) {
        const h = a.changedLanguages[c];
        if (this._embeddedLanguages[h]) {
          l = !0;
          break;
        }
      }
      l && (r = !0, ci.handleChange([this._languageId]), r = !1);
    })), this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: this._languageId
    }), this._register(this._configurationService.onDidChangeConfiguration((a) => {
      a.affectsConfiguration("editor.maxTokenizationLineLength") && (this._maxTokenizationLineLength = this._configurationService.getValue("editor.maxTokenizationLineLength", {
        overrideIdentifier: this._languageId
      }));
    }));
  }
  getLoadStatus() {
    const e = [];
    for (const t in this._embeddedLanguages) {
      const i = ci.get(t);
      if (i) {
        if (i instanceof gD) {
          const n = i.getLoadStatus();
          n.loaded === !1 && e.push(n.promise);
        }
        continue;
      }
      ci.isResolved(t) || e.push(ci.getOrCreate(t));
    }
    return e.length === 0 ? {
      loaded: !0
    } : {
      loaded: !1,
      promise: Promise.all(e).then((t) => {
      })
    };
  }
  getInitialState() {
    const e = r_.create(null, this._lexer.start);
    return vc.create(e, null);
  }
  tokenize(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return E3(this._languageId, i);
    const n = new Fne(), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  tokenizeEncoded(e, t, i) {
    if (e.length >= this._maxTokenizationLineLength)
      return TN(this._languageService.languageIdCodec.encodeLanguageId(this._languageId), i);
    const n = new mv(this._languageService, this._standaloneThemeService.getColorTheme().tokenTheme), o = this._tokenize(e, t, i, n);
    return n.finalize(o);
  }
  _tokenize(e, t, i, n) {
    return i.embeddedLanguageData ? this._nestedTokenize(e, t, i, 0, n) : this._myTokenize(e, t, i, 0, n);
  }
  _findLeavingNestedLanguageOffset(e, t) {
    let i = this._lexer.tokenizer[t.stack.state];
    if (!i && (i = Wb(this._lexer, t.stack.state), !i))
      throw It(this._lexer, "tokenizer state is not defined: " + t.stack.state);
    let n = -1, o = !1;
    for (const r of i) {
      if (!wO(r.action) || r.action.nextEmbedded !== "@pop")
        continue;
      o = !0;
      let a = r.resolveRegex(t.stack.state);
      const l = a.source;
      if (l.substr(0, 4) === "^(?:" && l.substr(l.length - 1, 1) === ")") {
        const d = (a.ignoreCase ? "i" : "") + (a.unicode ? "u" : "");
        a = new RegExp(l.substr(4, l.length - 5), d);
      }
      const c = e.search(a);
      c === -1 || c !== 0 && r.matchOnlyAtLineStart || (n === -1 || c < n) && (n = c);
    }
    if (!o)
      throw It(this._lexer, 'no rule containing nextEmbedded: "@pop" in tokenizer embedded state: ' + t.stack.state);
    return n;
  }
  _nestedTokenize(e, t, i, n, o) {
    const r = this._findLeavingNestedLanguageOffset(e, i);
    if (r === -1) {
      const c = o.nestedLanguageTokenize(e, t, i.embeddedLanguageData, n);
      return vc.create(i.stack, new zg(i.embeddedLanguageData.languageId, c));
    }
    const a = e.substring(0, r);
    a.length > 0 && o.nestedLanguageTokenize(a, !1, i.embeddedLanguageData, n);
    const l = e.substring(r);
    return this._myTokenize(l, t, i, n + r, o);
  }
  _safeRuleName(e) {
    return e ? e.name : "(unknown)";
  }
  _myTokenize(e, t, i, n, o) {
    o.enterLanguage(this._languageId);
    const r = e.length, a = t && this._lexer.includeLF ? e + `
` : e, l = a.length;
    let c = i.embeddedLanguageData, d = i.stack, h = 0, u = null, g = !0;
    for (; g || h < l; ) {
      const m = h, p = d.depth, A = u ? u.groups.length : 0, _ = d.state;
      let b = null, C = null, w = null, S = null, x = null;
      if (u) {
        b = u.matches;
        const I = u.groups.shift();
        C = I.matched, w = I.action, S = u.rule, u.groups.length === 0 && (u = null);
      } else {
        if (!g && h >= l)
          break;
        g = !1;
        let I = this._lexer.tokenizer[_];
        if (!I && (I = Wb(this._lexer, _), !I))
          throw It(this._lexer, "tokenizer state is not defined: " + _);
        const Q = a.substr(h);
        for (const P of I)
          if ((h === 0 || !P.matchOnlyAtLineStart) && (b = Q.match(P.resolveRegex(_)), b)) {
            C = b[0], w = P.action;
            break;
          }
      }
      if (b || (b = [""], C = ""), w || (h < l && (b = [a.charAt(h)], C = b[0]), w = this._lexer.defaultToken), C === null)
        break;
      for (h += C.length; Ine(w) && wO(w) && w.test; )
        w = w.test(C, b, _, h === l);
      let y = null;
      if (typeof w == "string" || Array.isArray(w))
        y = w;
      else if (w.group)
        y = w.group;
      else if (w.token !== null && w.token !== void 0) {
        if (w.tokenSubst ? y = Cc(this._lexer, w.token, C, b, _) : y = w.token, w.nextEmbedded)
          if (w.nextEmbedded === "@pop") {
            if (!c)
              throw It(this._lexer, "cannot pop embedded language if not inside one");
            c = null;
          } else {
            if (c)
              throw It(this._lexer, "cannot enter embedded language from within an embedded language");
            x = Cc(this._lexer, w.nextEmbedded, C, b, _);
          }
        if (w.goBack && (h = Math.max(0, h - w.goBack)), w.switchTo && typeof w.switchTo == "string") {
          let I = Cc(this._lexer, w.switchTo, C, b, _);
          if (I[0] === "@" && (I = I.substr(1)), Wb(this._lexer, I))
            d = d.switchTo(I);
          else
            throw It(this._lexer, "trying to switch to a state '" + I + "' that is undefined in rule: " + this._safeRuleName(S));
        } else {
          if (w.transform && typeof w.transform == "function")
            throw It(this._lexer, "action.transform not supported");
          if (w.next)
            if (w.next === "@push") {
              if (d.depth >= this._lexer.maxStack)
                throw It(this._lexer, "maximum tokenizer stack size reached: [" + d.state + "," + d.parent.state + ",...]");
              d = d.push(_);
            } else if (w.next === "@pop") {
              if (d.depth <= 1)
                throw It(this._lexer, "trying to pop an empty stack in rule: " + this._safeRuleName(S));
              d = d.pop();
            } else if (w.next === "@popall")
              d = d.popall();
            else {
              let I = Cc(this._lexer, w.next, C, b, _);
              if (I[0] === "@" && (I = I.substr(1)), Wb(this._lexer, I))
                d = d.push(I);
              else
                throw It(this._lexer, "trying to set a next state '" + I + "' that is undefined in rule: " + this._safeRuleName(S));
            }
        }
        w.log && typeof w.log == "string" && Mne(this._lexer, this._lexer.languageId + ": " + Cc(this._lexer, w.log, C, b, _));
      }
      if (y === null)
        throw It(this._lexer, "lexer rule has no well-defined action in rule: " + this._safeRuleName(S));
      const D = (I) => {
        const Q = this._languageService.getLanguageIdByLanguageName(I) || this._languageService.getLanguageIdByMimeType(I) || I, P = this._getNestedEmbeddedLanguageData(Q);
        if (h < l) {
          const W = e.substr(h);
          return this._nestedTokenize(W, t, vc.create(d, P), n + h, o);
        } else
          return vc.create(d, P);
      };
      if (Array.isArray(y)) {
        if (u && u.groups.length > 0)
          throw It(this._lexer, "groups cannot be nested: " + this._safeRuleName(S));
        if (b.length !== y.length + 1)
          throw It(this._lexer, "matched number of groups does not match the number of actions in rule: " + this._safeRuleName(S));
        let I = 0;
        for (let Q = 1; Q < b.length; Q++)
          I += b[Q].length;
        if (I !== C.length)
          throw It(this._lexer, "with groups, all characters should be matched in consecutive groups in rule: " + this._safeRuleName(S));
        u = {
          rule: S,
          matches: b,
          groups: []
        };
        for (let Q = 0; Q < y.length; Q++)
          u.groups[Q] = {
            action: y[Q],
            matched: b[Q + 1]
          };
        h -= C.length;
        continue;
      } else {
        if (y === "@rematch" && (h -= C.length, C = "", b = null, y = "", x !== null))
          return D(x);
        if (C.length === 0) {
          if (l === 0 || p !== d.depth || _ !== d.state || (u ? u.groups.length : 0) !== A)
            continue;
          throw It(this._lexer, "no progress in tokenizer in rule: " + this._safeRuleName(S));
        }
        let I = null;
        if (C8(y) && y.indexOf("@brackets") === 0) {
          const Q = y.substr(9), P = One(this._lexer, C);
          if (!P)
            throw It(this._lexer, "@brackets token returned but no bracket defined as: " + C);
          I = CO(P.token + Q);
        } else {
          const Q = y === "" ? "" : y + this._lexer.tokenPostfix;
          I = CO(Q);
        }
        m < r && o.emit(m + n, I);
      }
      if (x !== null)
        return D(x);
    }
    return vc.create(d, c);
  }
  _getNestedEmbeddedLanguageData(e) {
    if (!this._languageService.isRegisteredLanguageId(e))
      return new zg(e, jA);
    e !== this._languageId && (this._languageService.requestBasicLanguageFeatures(e), ci.getOrCreate(e), this._embeddedLanguages[e] = !0);
    const t = ci.get(e);
    return t ? new zg(e, t.getInitialState()) : new zg(e, jA);
  }
};
a_ = gD = Bne([
  Rne(4, ht)
], a_);
function One(s, e) {
  if (!e)
    return null;
  e = Fl(s, e);
  const t = s.brackets;
  for (const i of t) {
    if (i.open === e)
      return {
        token: i.token,
        bracketType: 1
        /* monarchCommon.MonarchBracket.Open */
      };
    if (i.close === e)
      return {
        token: i.token,
        bracketType: -1
        /* monarchCommon.MonarchBracket.Close */
      };
  }
  return null;
}
const Pne = Hu("standaloneColorizer", { createHTML: (s) => s });
class kT {
  static colorizeElement(e, t, i, n) {
    n = n || {};
    const o = n.theme || "vs", r = n.mimeType || i.getAttribute("lang") || i.getAttribute("data-lang");
    if (!r)
      return console.error("Mode not detected"), Promise.resolve();
    const a = t.getLanguageIdByMimeType(r) || r;
    e.setTheme(o);
    const l = i.firstChild ? i.firstChild.nodeValue : "";
    i.className += " " + o;
    const c = (d) => {
      const h = Pne?.createHTML(d) ?? d;
      i.innerHTML = h;
    };
    return this.colorize(t, l || "", a, n).then(c, (d) => console.error(d));
  }
  static async colorize(e, t, i, n) {
    const o = e.languageIdCodec;
    let r = 4;
    n && typeof n.tabSize == "number" && (r = n.tabSize), zM(t) && (t = t.substr(1));
    const a = bd(t);
    if (!e.isRegisteredLanguageId(i))
      return vO(a, r, o);
    const l = await ci.getOrCreate(i);
    return l ? Hne(a, r, l, o) : vO(a, r, o);
  }
  static colorizeLine(e, t, i, n, o = 4) {
    const r = $s.isBasicASCII(e, t), a = $s.containsRTL(e, r, i);
    return CS(new km(!1, !0, e, !1, r, a, 0, n, [], o, 0, 0, 0, 0, -1, "none", !1, !1, null)).html;
  }
  static colorizeModelLine(e, t, i = 4) {
    const n = e.getLineContent(t);
    e.tokenization.forceTokenization(t);
    const r = e.tokenization.getLineTokens(t).inflate();
    return this.colorizeLine(n, e.mightContainNonBasicASCII(), e.mightContainRTL(), r, i);
  }
}
function Hne(s, e, t, i) {
  return new Promise((n, o) => {
    const r = () => {
      const a = Wne(s, e, t, i);
      if (t instanceof a_) {
        const l = t.getLoadStatus();
        if (l.loaded === !1) {
          l.promise.then(r, o);
          return;
        }
      }
      n(a);
    };
    r();
  });
}
function vO(s, e, t) {
  let i = [];
  const o = new Uint32Array(2);
  o[0] = 0, o[1] = 33587200;
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r];
    o[0] = l.length;
    const c = new Gi(o, l, t), d = $s.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), h = $s.containsRTL(
      l,
      d,
      /* check for RTL */
      !0
    ), u = CS(new km(!1, !0, l, !1, d, h, 0, c, [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    i = i.concat(u.html), i.push("<br/>");
  }
  return i.join("");
}
function Wne(s, e, t, i) {
  let n = [], o = t.getInitialState();
  for (let r = 0, a = s.length; r < a; r++) {
    const l = s[r], c = t.tokenizeEncoded(l, !0, o);
    Gi.convertToEndOffset(c.tokens, l.length);
    const d = new Gi(c.tokens, l, i), h = $s.isBasicASCII(
      l,
      /* check for basic ASCII */
      !0
    ), u = $s.containsRTL(
      l,
      h,
      /* check for RTL */
      !0
    ), g = CS(new km(!1, !0, l, !1, h, u, 0, d.inflate(), [], e, 0, 0, 0, 0, -1, "none", !1, !1, null));
    n = n.concat(g.html), n.push("<br/>"), o = c.endState;
  }
  return n.join("");
}
var Vne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zne = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Bf;
let pv = (Bf = class {
  constructor(e, t) {
  }
  dispose() {
  }
}, Bf.ID = "editor.contrib.markerDecorations", Bf);
pv = Vne([
  zne(1, KN)
], pv);
rs(
  pv.ID,
  pv,
  0
  /* EditorContributionInstantiation.Eager */
);
class S8 extends V {
  constructor(e, t) {
    super(), this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._referenceDomElement = e, this._width = -1, this._height = -1, this._resizeObserver = null, this.measureReferenceDomElement(!1, t);
  }
  dispose() {
    this.stopObserving(), super.dispose();
  }
  getWidth() {
    return this._width;
  }
  getHeight() {
    return this._height;
  }
  startObserving() {
    if (!this._resizeObserver && this._referenceDomElement) {
      let e = null;
      const t = () => {
        e ? this.observe({ width: e.width, height: e.height }) : this.observe();
      };
      let i = !1, n = !1;
      const o = () => {
        if (i && !n)
          try {
            i = !1, n = !0, t();
          } finally {
            ys(fe(this._referenceDomElement), () => {
              n = !1, o();
            });
          }
      };
      this._resizeObserver = new ResizeObserver((r) => {
        r && r[0] && r[0].contentRect ? e = { width: r[0].contentRect.width, height: r[0].contentRect.height } : e = null, i = !0, o();
      }), this._resizeObserver.observe(this._referenceDomElement);
    }
  }
  stopObserving() {
    this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = null);
  }
  observe(e) {
    this.measureReferenceDomElement(!0, e);
  }
  measureReferenceDomElement(e, t) {
    let i = 0, n = 0;
    t ? (i = t.width, n = t.height) : this._referenceDomElement && (i = this._referenceDomElement.clientWidth, n = this._referenceDomElement.clientHeight), i = Math.max(5, i), n = Math.max(5, n), (this._width !== i || this._height !== n) && (this._width = i, this._height = n, e && this._onDidChange.fire());
  }
}
const of = class of {
  constructor(e, t) {
    this.key = e, this.migrate = t;
  }
  apply(e) {
    const t = of._read(e, this.key), i = (o) => of._read(e, o), n = (o, r) => of._write(e, o, r);
    this.migrate(t, i, n);
  }
  static _read(e, t) {
    if (typeof e > "u")
      return;
    const i = t.indexOf(".");
    if (i >= 0) {
      const n = t.substring(0, i);
      return this._read(e[n], t.substring(i + 1));
    }
    return e[t];
  }
  static _write(e, t, i) {
    const n = t.indexOf(".");
    if (n >= 0) {
      const o = t.substring(0, n);
      e[o] = e[o] || {}, this._write(e[o], t.substring(n + 1), i);
      return;
    }
    e[t] = i;
  }
};
of.items = [];
let l_ = of;
function Wr(s, e) {
  l_.items.push(new l_(s, e));
}
function ks(s, e) {
  Wr(s, (t, i, n) => {
    if (typeof t < "u") {
      for (const [o, r] of e)
        if (t === o) {
          n(s, r);
          return;
        }
    }
  });
}
function Une(s) {
  l_.items.forEach((e) => e.apply(s));
}
ks("wordWrap", [[!0, "on"], [!1, "off"]]);
ks("lineNumbers", [[!0, "on"], [!1, "off"]]);
ks("cursorBlinking", [["visible", "solid"]]);
ks("renderWhitespace", [[!0, "boundary"], [!1, "none"]]);
ks("renderLineHighlight", [[!0, "line"], [!1, "none"]]);
ks("acceptSuggestionOnEnter", [[!0, "on"], [!1, "off"]]);
ks("tabCompletion", [[!1, "off"], [!0, "onlySnippets"]]);
ks("hover", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
ks("parameterHints", [[!0, { enabled: !0 }], [!1, { enabled: !1 }]]);
ks("autoIndent", [[!1, "advanced"], [!0, "full"]]);
ks("matchBrackets", [[!0, "always"], [!1, "never"]]);
ks("renderFinalNewline", [[!0, "on"], [!1, "off"]]);
ks("cursorSmoothCaretAnimation", [[!0, "on"], [!1, "off"]]);
ks("occurrencesHighlight", [[!0, "singleFile"], [!1, "off"]]);
ks("wordBasedSuggestions", [[!0, "matchingDocuments"], [!1, "off"]]);
Wr("autoClosingBrackets", (s, e, t) => {
  s === !1 && (t("autoClosingBrackets", "never"), typeof e("autoClosingQuotes") > "u" && t("autoClosingQuotes", "never"), typeof e("autoSurround") > "u" && t("autoSurround", "never"));
});
Wr("renderIndentGuides", (s, e, t) => {
  typeof s < "u" && (t("renderIndentGuides", void 0), typeof e("guides.indentation") > "u" && t("guides.indentation", !!s));
});
Wr("highlightActiveIndentGuide", (s, e, t) => {
  typeof s < "u" && (t("highlightActiveIndentGuide", void 0), typeof e("guides.highlightActiveIndentation") > "u" && t("guides.highlightActiveIndentation", !!s));
});
const Qne = {
  method: "showMethods",
  function: "showFunctions",
  constructor: "showConstructors",
  deprecated: "showDeprecated",
  field: "showFields",
  variable: "showVariables",
  class: "showClasses",
  struct: "showStructs",
  interface: "showInterfaces",
  module: "showModules",
  property: "showProperties",
  event: "showEvents",
  operator: "showOperators",
  unit: "showUnits",
  value: "showValues",
  constant: "showConstants",
  enum: "showEnums",
  enumMember: "showEnumMembers",
  keyword: "showKeywords",
  text: "showWords",
  color: "showColors",
  file: "showFiles",
  reference: "showReferences",
  folder: "showFolders",
  typeParameter: "showTypeParameters",
  snippet: "showSnippets"
};
Wr("suggest.filteredTypes", (s, e, t) => {
  if (s && typeof s == "object") {
    for (const i of Object.entries(Qne))
      s[i[0]] === !1 && typeof e(`suggest.${i[1]}`) > "u" && t(`suggest.${i[1]}`, !1);
    t("suggest.filteredTypes", void 0);
  }
});
Wr("quickSuggestions", (s, e, t) => {
  if (typeof s == "boolean") {
    const i = s ? "on" : "off";
    t("quickSuggestions", { comments: i, strings: i, other: i });
  }
});
Wr("experimental.stickyScroll.enabled", (s, e, t) => {
  typeof s == "boolean" && (t("experimental.stickyScroll.enabled", void 0), typeof e("stickyScroll.enabled") > "u" && t("stickyScroll.enabled", s));
});
Wr("experimental.stickyScroll.maxLineCount", (s, e, t) => {
  typeof s == "number" && (t("experimental.stickyScroll.maxLineCount", void 0), typeof e("stickyScroll.maxLineCount") > "u" && t("stickyScroll.maxLineCount", s));
});
Wr("codeActionsOnSave", (s, e, t) => {
  if (s && typeof s == "object") {
    let i = !1;
    const n = {};
    for (const o of Object.entries(s))
      typeof o[1] == "boolean" ? (i = !0, n[o[0]] = o[1] ? "explicit" : "never") : n[o[0]] = o[1];
    i && t("codeActionsOnSave", n);
  }
});
Wr("codeActionWidget.includeNearbyQuickfixes", (s, e, t) => {
  typeof s == "boolean" && (t("codeActionWidget.includeNearbyQuickfixes", void 0), typeof e("codeActionWidget.includeNearbyQuickFixes") > "u" && t("codeActionWidget.includeNearbyQuickFixes", s));
});
Wr("lightbulb.enabled", (s, e, t) => {
  typeof s == "boolean" && t("lightbulb.enabled", s ? void 0 : "off");
});
class Gne {
  constructor() {
    this._tabFocus = !1, this._onDidChangeTabFocus = new B(), this.onDidChangeTabFocus = this._onDidChangeTabFocus.event;
  }
  getTabFocusMode() {
    return this._tabFocus;
  }
  setTabFocusMode(e) {
    this._tabFocus = e, this._onDidChangeTabFocus.fire(this._tabFocus);
  }
}
const Av = new Gne();
var jne = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Yne = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let fD = class extends V {
  constructor(e, t, i, n, o) {
    super(), this._accessibilityService = o, this._onDidChange = this._register(new B()), this.onDidChange = this._onDidChange.event, this._onDidChangeFast = this._register(new B()), this.onDidChangeFast = this._onDidChangeFast.event, this._isDominatedByLongLines = !1, this._viewLineCount = 1, this._lineNumbersDigitCount = 1, this._reservedHeight = 0, this._glyphMarginDecorationLaneCount = 1, this._computeOptionsMemory = new eH(), this.isSimpleWidget = e, this.contextMenuId = t, this._containerObserver = this._register(new S8(n, i.dimension)), this._targetWindowId = fe(n).vscodeWindowId, this._rawOptions = SO(i), this._validatedOptions = Sc.validateOptions(this._rawOptions), this.options = this._computeOptions(), this.options.get(
      13
      /* EditorOption.automaticLayout */
    ) && this._containerObserver.startObserving(), this._register(_c.onDidChangeZoomLevel(() => this._recomputeOptions())), this._register(Av.onDidChangeTabFocus(() => this._recomputeOptions())), this._register(this._containerObserver.onDidChange(() => this._recomputeOptions())), this._register(GE.onDidChange(() => this._recomputeOptions())), this._register(TA.getInstance(fe(n)).onDidChange(() => this._recomputeOptions())), this._register(this._accessibilityService.onDidChangeScreenReaderOptimized(() => this._recomputeOptions()));
  }
  _recomputeOptions() {
    const e = this._computeOptions(), t = Sc.checkEquals(this.options, e);
    t !== null && (this.options = e, this._onDidChangeFast.fire(t), this._onDidChange.fire(t));
  }
  _computeOptions() {
    const e = this._readEnvConfiguration(), t = Lh.createFromValidatedSettings(this._validatedOptions, e.pixelRatio, this.isSimpleWidget), i = this._readFontInfo(t), n = {
      memory: this._computeOptionsMemory,
      outerWidth: e.outerWidth,
      outerHeight: e.outerHeight - this._reservedHeight,
      fontInfo: i,
      extraEditorClassName: e.extraEditorClassName,
      isDominatedByLongLines: this._isDominatedByLongLines,
      viewLineCount: this._viewLineCount,
      lineNumbersDigitCount: this._lineNumbersDigitCount,
      emptySelectionClipboard: e.emptySelectionClipboard,
      pixelRatio: e.pixelRatio,
      tabFocusMode: Av.getTabFocusMode(),
      accessibilitySupport: e.accessibilitySupport,
      glyphMarginDecorationLaneCount: this._glyphMarginDecorationLaneCount
    };
    return Sc.computeOptions(this._validatedOptions, n);
  }
  _readEnvConfiguration() {
    return {
      extraEditorClassName: Jne(),
      outerWidth: this._containerObserver.getWidth(),
      outerHeight: this._containerObserver.getHeight(),
      emptySelectionClipboard: b0 || Ko,
      pixelRatio: TA.getInstance(hR(this._targetWindowId, !0).window).value,
      accessibilitySupport: this._accessibilityService.isScreenReaderOptimized() ? 2 : this._accessibilityService.getAccessibilitySupport()
    };
  }
  _readFontInfo(e) {
    return GE.readFontInfo(hR(this._targetWindowId, !0).window, e);
  }
  getRawOptions() {
    return this._rawOptions;
  }
  updateOptions(e) {
    const t = SO(e);
    Sc.applyUpdate(this._rawOptions, t) && (this._validatedOptions = Sc.validateOptions(this._rawOptions), this._recomputeOptions());
  }
  observeContainer(e) {
    this._containerObserver.observe(e);
  }
  setIsDominatedByLongLines(e) {
    this._isDominatedByLongLines !== e && (this._isDominatedByLongLines = e, this._recomputeOptions());
  }
  setModelLineCount(e) {
    const t = Kne(e);
    this._lineNumbersDigitCount !== t && (this._lineNumbersDigitCount = t, this._recomputeOptions());
  }
  setViewLineCount(e) {
    this._viewLineCount !== e && (this._viewLineCount = e, this._recomputeOptions());
  }
  setReservedHeight(e) {
    this._reservedHeight !== e && (this._reservedHeight = e, this._recomputeOptions());
  }
  setGlyphMarginDecorationLaneCount(e) {
    this._glyphMarginDecorationLaneCount !== e && (this._glyphMarginDecorationLaneCount = e, this._recomputeOptions());
  }
};
fD = jne([
  Yne(4, Lo)
], fD);
function Kne(s) {
  let e = 0;
  for (; s; )
    s = Math.floor(s / 10), e++;
  return e || 1;
}
function Jne() {
  let s = "";
  return !od && !yH && (s += "no-user-select "), od && (s += "no-minimap-shadow ", s += "enable-user-select "), ze && (s += "mac "), s;
}
class qne {
  constructor() {
    this._values = [];
  }
  _read(e) {
    return this._values[e];
  }
  get(e) {
    return this._values[e];
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class $ne {
  constructor() {
    this._values = [];
  }
  _read(e) {
    if (e >= this._values.length)
      throw new Error("Cannot read uninitialized value");
    return this._values[e];
  }
  get(e) {
    return this._read(e);
  }
  _write(e, t) {
    this._values[e] = t;
  }
}
class Sc {
  static validateOptions(e) {
    const t = new qne();
    for (const i of Dg) {
      const n = i.name === "_never_" ? void 0 : e[i.name];
      t._write(i.id, i.validate(n));
    }
    return t;
  }
  static computeOptions(e, t) {
    const i = new $ne();
    for (const n of Dg)
      i._write(n.id, n.compute(t, i, e._read(n.id)));
    return i;
  }
  static _deepEquals(e, t) {
    if (typeof e != "object" || typeof t != "object" || !e || !t)
      return e === t;
    if (Array.isArray(e) || Array.isArray(t))
      return Array.isArray(e) && Array.isArray(t) ? pi(e, t) : !1;
    if (Object.keys(e).length !== Object.keys(t).length)
      return !1;
    for (const i in e)
      if (!Sc._deepEquals(e[i], t[i]))
        return !1;
    return !0;
  }
  static checkEquals(e, t) {
    const i = [];
    let n = !1;
    for (const o of Dg) {
      const r = !Sc._deepEquals(e._read(o.id), t._read(o.id));
      i[o.id] = r, r && (n = !0);
    }
    return n ? new Z4(i) : null;
  }
  /**
   * Returns true if something changed.
   * Modifies `options`.
  */
  static applyUpdate(e, t) {
    let i = !1;
    for (const n of Dg)
      if (t.hasOwnProperty(n.name)) {
        const o = n.applyUpdate(e[n.name], t[n.name]);
        e[n.name] = o.newValue, i = i || o.didChange;
      }
    return i;
  }
}
function SO(s) {
  const e = ll(s);
  return Une(e), e;
}
var Nc;
(function(s) {
  const e = { total: 0, min: Number.MAX_VALUE, max: 0 }, t = { ...e }, i = { ...e }, n = { ...e };
  let o = 0;
  const r = {
    keydown: 0,
    input: 0,
    render: 0
  };
  function a() {
    _(), performance.mark("inputlatency/start"), performance.mark("keydown/start"), r.keydown = 1, queueMicrotask(l);
  }
  s.onKeyDown = a;
  function l() {
    r.keydown === 1 && (performance.mark("keydown/end"), r.keydown = 2);
  }
  function c() {
    performance.mark("input/start"), r.input = 1, A();
  }
  s.onBeforeInput = c;
  function d() {
    r.input === 0 && c(), queueMicrotask(h);
  }
  s.onInput = d;
  function h() {
    r.input === 1 && (performance.mark("input/end"), r.input = 2);
  }
  function u() {
    _();
  }
  s.onKeyUp = u;
  function g() {
    _();
  }
  s.onSelectionChange = g;
  function m() {
    r.keydown === 2 && r.input === 2 && r.render === 0 && (performance.mark("render/start"), r.render = 1, queueMicrotask(p), A());
  }
  s.onRenderStart = m;
  function p() {
    r.render === 1 && (performance.mark("render/end"), r.render = 2);
  }
  function A() {
    setTimeout(_);
  }
  function _() {
    r.keydown === 2 && r.input === 2 && r.render === 2 && (performance.mark("inputlatency/end"), performance.measure("keydown", "keydown/start", "keydown/end"), performance.measure("input", "input/start", "input/end"), performance.measure("render", "render/start", "render/end"), performance.measure("inputlatency", "inputlatency/start", "inputlatency/end"), b("keydown", e), b("input", t), b("render", i), b("inputlatency", n), o++, C());
  }
  function b(y, D) {
    const I = performance.getEntriesByName(y)[0].duration;
    D.total += I, D.min = Math.min(D.min, I), D.max = Math.max(D.max, I);
  }
  function C() {
    performance.clearMarks("keydown/start"), performance.clearMarks("keydown/end"), performance.clearMarks("input/start"), performance.clearMarks("input/end"), performance.clearMarks("render/start"), performance.clearMarks("render/end"), performance.clearMarks("inputlatency/start"), performance.clearMarks("inputlatency/end"), performance.clearMeasures("keydown"), performance.clearMeasures("input"), performance.clearMeasures("render"), performance.clearMeasures("inputlatency"), r.keydown = 0, r.input = 0, r.render = 0;
  }
  function w() {
    if (o === 0)
      return;
    const y = {
      keydown: S(e),
      input: S(t),
      render: S(i),
      total: S(n),
      sampleCount: o
    };
    return x(e), x(t), x(i), x(n), o = 0, y;
  }
  s.getAndClearMeasurements = w;
  function S(y) {
    return {
      average: y.total / o,
      max: y.max,
      min: y.min
    };
  }
  function x(y) {
    y.total = 0, y.min = Number.MAX_VALUE, y.max = 0;
  }
})(Nc || (Nc = {}));
class vS {
  constructor(e, t) {
    this.x = e, this.y = t, this._pageCoordinatesBrand = void 0;
  }
  toClientCoordinates(e) {
    return new y8(this.x - e.scrollX, this.y - e.scrollY);
  }
}
class y8 {
  constructor(e, t) {
    this.clientX = e, this.clientY = t, this._clientCoordinatesBrand = void 0;
  }
  toPageCoordinates(e) {
    return new vS(this.clientX + e.scrollX, this.clientY + e.scrollY);
  }
}
class Xne {
  constructor(e, t, i, n) {
    this.x = e, this.y = t, this.width = i, this.height = n, this._editorPagePositionBrand = void 0;
  }
}
class Zne {
  constructor(e, t) {
    this.x = e, this.y = t, this._positionRelativeToEditorBrand = void 0;
  }
}
function DT(s) {
  const e = ui(s);
  return new Xne(e.left, e.top, e.width, e.height);
}
function IT(s, e, t) {
  const i = e.width / s.offsetWidth, n = e.height / s.offsetHeight, o = (t.x - e.x) / i, r = (t.y - e.y) / n;
  return new Zne(o, r);
}
class hd extends Ir {
  constructor(e, t, i) {
    super(fe(i), e), this._editorMouseEventBrand = void 0, this.isFromPointerCapture = t, this.pos = new vS(this.posx, this.posy), this.editorPos = DT(i), this.relativePos = IT(i, this.editorPos, this.pos);
  }
}
class ese {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new hd(e, !1, this._editorViewDomNode);
  }
  onContextMenu(e, t) {
    return U(e, "contextmenu", (i) => {
      t(this._create(i));
    });
  }
  onMouseUp(e, t) {
    return U(e, "mouseup", (i) => {
      t(this._create(i));
    });
  }
  onMouseDown(e, t) {
    return U(e, ee.MOUSE_DOWN, (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return U(e, ee.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onMouseLeave(e, t) {
    return U(e, ee.MOUSE_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onMouseMove(e, t) {
    return U(e, "mousemove", (i) => t(this._create(i)));
  }
}
class tse {
  constructor(e) {
    this._editorViewDomNode = e;
  }
  _create(e) {
    return new hd(e, !1, this._editorViewDomNode);
  }
  onPointerUp(e, t) {
    return U(e, "pointerup", (i) => {
      t(this._create(i));
    });
  }
  onPointerDown(e, t) {
    return U(e, ee.POINTER_DOWN, (i) => {
      t(this._create(i), i.pointerId);
    });
  }
  onPointerLeave(e, t) {
    return U(e, ee.POINTER_LEAVE, (i) => {
      t(this._create(i));
    });
  }
  onPointerMove(e, t) {
    return U(e, "pointermove", (i) => t(this._create(i)));
  }
}
class ise extends V {
  constructor(e) {
    super(), this._editorViewDomNode = e, this._globalPointerMoveMonitor = this._register(new Cm()), this._keydownListener = null;
  }
  startMonitoring(e, t, i, n, o) {
    this._keydownListener = Xt(e.ownerDocument, "keydown", (r) => {
      r.toKeyCodeChord().isModifierKey() || this._globalPointerMoveMonitor.stopMonitoring(!0, r.browserEvent);
    }, !0), this._globalPointerMoveMonitor.startMonitoring(e, t, i, (r) => {
      n(new hd(r, !0, this._editorViewDomNode));
    }, (r) => {
      this._keydownListener.dispose(), o(r);
    });
  }
  stopMonitoring() {
    this._globalPointerMoveMonitor.stopMonitoring(!0);
  }
}
const U1 = class U1 {
  constructor(e) {
    this._editor = e, this._instanceId = ++U1._idPool, this._counter = 0, this._rules = /* @__PURE__ */ new Map(), this._garbageCollectionScheduler = new zt(() => this.garbageCollect(), 1e3);
  }
  createClassNameRef(e) {
    const t = this.getOrCreateRule(e);
    return t.increaseRefCount(), {
      className: t.className,
      dispose: () => {
        t.decreaseRefCount(), this._garbageCollectionScheduler.schedule();
      }
    };
  }
  getOrCreateRule(e) {
    const t = this.computeUniqueKey(e);
    let i = this._rules.get(t);
    if (!i) {
      const n = this._counter++;
      i = new nse(t, `dyn-rule-${this._instanceId}-${n}`, rC(this._editor.getContainerDomNode()) ? this._editor.getContainerDomNode() : void 0, e), this._rules.set(t, i);
    }
    return i;
  }
  computeUniqueKey(e) {
    return JSON.stringify(e);
  }
  garbageCollect() {
    for (const e of this._rules.values())
      e.hasReferences() || (this._rules.delete(e.key), e.dispose());
  }
};
U1._idPool = 0;
let _v = U1;
class nse {
  constructor(e, t, i, n) {
    this.key = e, this.className = t, this.properties = n, this._referenceCount = 0, this._styleElementDisposables = new X(), this._styleElement = xo(i, void 0, this._styleElementDisposables), this._styleElement.textContent = this.getCssText(this.className, this.properties);
  }
  getCssText(e, t) {
    let i = `.${e} {`;
    for (const n in t) {
      const o = t[n];
      let r;
      typeof o == "object" ? r = oe(o.id) : r = o;
      const a = sse(n);
      i += `
	${a}: ${r};`;
    }
    return i += `
}`, i;
  }
  dispose() {
    this._styleElementDisposables.dispose(), this._styleElement = void 0;
  }
  increaseRefCount() {
    this._referenceCount++;
  }
  decreaseRefCount() {
    this._referenceCount--;
  }
  hasReferences() {
    return this._referenceCount > 0;
  }
}
function sse(s) {
  return s.replace(/(^[A-Z])/, ([e]) => e.toLowerCase()).replace(/([A-Z])/g, ([e]) => `-${e.toLowerCase()}`);
}
class Y_ extends V {
  constructor() {
    super(), this._shouldRender = !0;
  }
  shouldRender() {
    return this._shouldRender;
  }
  forceShouldRender() {
    this._shouldRender = !0;
  }
  setShouldRender() {
    this._shouldRender = !0;
  }
  onDidRender() {
    this._shouldRender = !1;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return !1;
  }
  onCompositionEnd(e) {
    return !1;
  }
  onConfigurationChanged(e) {
    return !1;
  }
  onCursorStateChanged(e) {
    return !1;
  }
  onDecorationsChanged(e) {
    return !1;
  }
  onFlushed(e) {
    return !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  onLanguageConfigurationChanged(e) {
    return !1;
  }
  onLineMappingChanged(e) {
    return !1;
  }
  onLinesChanged(e) {
    return !1;
  }
  onLinesDeleted(e) {
    return !1;
  }
  onLinesInserted(e) {
    return !1;
  }
  onRevealRangeRequest(e) {
    return !1;
  }
  onScrollChanged(e) {
    return !1;
  }
  onThemeChanged(e) {
    return !1;
  }
  onTokensChanged(e) {
    return !1;
  }
  onTokensColorsChanged(e) {
    return !1;
  }
  onZonesChanged(e) {
    return !1;
  }
  // --- end event handlers
  handleEvents(e) {
    let t = !1;
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      switch (o.type) {
        case 0:
          this.onCompositionStart(o) && (t = !0);
          break;
        case 1:
          this.onCompositionEnd(o) && (t = !0);
          break;
        case 2:
          this.onConfigurationChanged(o) && (t = !0);
          break;
        case 3:
          this.onCursorStateChanged(o) && (t = !0);
          break;
        case 4:
          this.onDecorationsChanged(o) && (t = !0);
          break;
        case 5:
          this.onFlushed(o) && (t = !0);
          break;
        case 6:
          this.onFocusChanged(o) && (t = !0);
          break;
        case 7:
          this.onLanguageConfigurationChanged(o) && (t = !0);
          break;
        case 8:
          this.onLineMappingChanged(o) && (t = !0);
          break;
        case 9:
          this.onLinesChanged(o) && (t = !0);
          break;
        case 10:
          this.onLinesDeleted(o) && (t = !0);
          break;
        case 11:
          this.onLinesInserted(o) && (t = !0);
          break;
        case 12:
          this.onRevealRangeRequest(o) && (t = !0);
          break;
        case 13:
          this.onScrollChanged(o) && (t = !0);
          break;
        case 15:
          this.onTokensChanged(o) && (t = !0);
          break;
        case 14:
          this.onThemeChanged(o) && (t = !0);
          break;
        case 16:
          this.onTokensColorsChanged(o) && (t = !0);
          break;
        case 17:
          this.onZonesChanged(o) && (t = !0);
          break;
        default:
          console.info("View received unknown event: "), console.info(o);
      }
    }
    t && (this._shouldRender = !0);
  }
}
class Ds extends Y_ {
  constructor(e) {
    super(), this._context = e, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
}
class Pr {
  static write(e, t) {
    e.setAttribute("data-mprt", String(t));
  }
  static read(e) {
    const t = e.getAttribute("data-mprt");
    return t === null ? 0 : parseInt(t, 10);
  }
  static collect(e, t) {
    const i = [];
    let n = 0;
    for (; e && e !== e.ownerDocument.body && e !== t; )
      e.nodeType === e.ELEMENT_NODE && (i[n++] = this.read(e)), e = e.parentElement;
    const o = new Uint8Array(n);
    for (let r = 0; r < n; r++)
      o[r] = i[n - r - 1];
    return o;
  }
}
class ose {
  constructor(e, t) {
    this._restrictedRenderingContextBrand = void 0, this._viewLayout = e, this.viewportData = t, this.scrollWidth = this._viewLayout.getScrollWidth(), this.scrollHeight = this._viewLayout.getScrollHeight(), this.visibleRange = this.viewportData.visibleRange, this.bigNumbersDelta = this.viewportData.bigNumbersDelta;
    const i = this._viewLayout.getCurrentViewport();
    this.scrollTop = i.top, this.scrollLeft = i.left, this.viewportWidth = i.width, this.viewportHeight = i.height;
  }
  getScrolledTopFromAbsoluteTop(e) {
    return e - this.scrollTop;
  }
  getVerticalOffsetForLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t) {
    return this._viewLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  getDecorationsInViewport() {
    return this.viewportData.getDecorationsInViewport();
  }
}
class rse extends ose {
  constructor(e, t, i) {
    super(e, t), this._renderingContextBrand = void 0, this._viewLines = i;
  }
  linesVisibleRangesForRange(e, t) {
    return this._viewLines.linesVisibleRangesForRange(e, t);
  }
  visibleRangeForPosition(e) {
    return this._viewLines.visibleRangeForPosition(e);
  }
}
class ase {
  constructor(e, t, i, n) {
    this.outsideRenderedLine = e, this.lineNumber = t, this.ranges = i, this.continuesOnNextLine = n;
  }
}
class SS {
  static from(e) {
    const t = new Array(e.length);
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = new SS(o.left, o.width);
    }
    return t;
  }
  constructor(e, t) {
    this._horizontalRangeBrand = void 0, this.left = Math.round(e), this.width = Math.round(t);
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
}
class Th {
  constructor(e, t) {
    this._floatHorizontalRangeBrand = void 0, this.left = e, this.width = t;
  }
  toString() {
    return `[${this.left},${this.width}]`;
  }
  static compare(e, t) {
    return e.left - t.left;
  }
}
class lse {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.originalLeft = t, this.left = Math.round(this.originalLeft);
  }
}
class yO {
  constructor(e, t) {
    this.outsideRenderedLine = e, this.ranges = t;
  }
}
class Rw {
  static _createRange() {
    return this._handyReadyRange || (this._handyReadyRange = document.createRange()), this._handyReadyRange;
  }
  static _detachRange(e, t) {
    e.selectNodeContents(t);
  }
  static _readClientRects(e, t, i, n, o) {
    const r = this._createRange();
    try {
      return r.setStart(e, t), r.setEnd(i, n), r.getClientRects();
    } catch {
      return null;
    } finally {
      this._detachRange(r, o);
    }
  }
  static _mergeAdjacentRanges(e) {
    if (e.length === 1)
      return e;
    e.sort(Th.compare);
    const t = [];
    let i = 0, n = e[0];
    for (let o = 1, r = e.length; o < r; o++) {
      const a = e[o];
      n.left + n.width + 0.9 >= a.left ? n.width = Math.max(n.width, a.left + a.width - n.left) : (t[i++] = n, n = a);
    }
    return t[i++] = n, t;
  }
  static _createHorizontalRangesFromClientRects(e, t, i) {
    if (!e || e.length === 0)
      return null;
    const n = [];
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      n[o] = new Th(Math.max(0, (a.left - t) / i), a.width / i);
    }
    return this._mergeAdjacentRanges(n);
  }
  static readHorizontalRanges(e, t, i, n, o, r) {
    const l = e.children.length - 1;
    if (0 > l)
      return null;
    if (t = Math.min(l, Math.max(0, t)), n = Math.min(l, Math.max(0, n)), t === n && i === o && i === 0 && !e.children[t].firstChild) {
      const u = e.children[t].getClientRects();
      return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(u, r.clientRectDeltaLeft, r.clientRectScale);
    }
    t !== n && n > 0 && o === 0 && (n--, o = 1073741824);
    let c = e.children[t].firstChild, d = e.children[n].firstChild;
    if ((!c || !d) && (!c && i === 0 && t > 0 && (c = e.children[t - 1].firstChild, i = 1073741824), !d && o === 0 && n > 0 && (d = e.children[n - 1].firstChild, o = 1073741824)), !c || !d)
      return null;
    i = Math.min(c.textContent.length, Math.max(0, i)), o = Math.min(d.textContent.length, Math.max(0, o));
    const h = this._readClientRects(c, i, d, o, r.endNode);
    return r.markDidDomLayout(), this._createHorizontalRangesFromClientRects(h, r.clientRectDeltaLeft, r.clientRectScale);
  }
}
const cse = /* @__PURE__ */ function() {
  return vA ? !0 : !(Fn || Ko || od);
}();
let If = !0;
class xO {
  constructor(e, t) {
    this.themeType = t;
    const i = e.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    i.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    ) === "off" ? this.renderWhitespace = i.get(
      100
      /* EditorOption.renderWhitespace */
    ) : this.renderWhitespace = "none", this.renderControlCharacters = i.get(
      95
      /* EditorOption.renderControlCharacters */
    ), this.spaceWidth = n.spaceWidth, this.middotWidth = n.middotWidth, this.wsmiddotWidth = n.wsmiddotWidth, this.useMonospaceOptimizations = n.isMonospace && !i.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), this.canUseHalfwidthRightwardsArrow = n.canUseHalfwidthRightwardsArrow, this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = i.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), this.fontLigatures = i.get(
      51
      /* EditorOption.fontLigatures */
    );
  }
  equals(e) {
    return this.themeType === e.themeType && this.renderWhitespace === e.renderWhitespace && this.renderControlCharacters === e.renderControlCharacters && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.useMonospaceOptimizations === e.useMonospaceOptimizations && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter && this.fontLigatures === e.fontLigatures;
  }
}
const Q1 = class Q1 {
  constructor(e) {
    this._options = e, this._isMaybeInvalid = !0, this._renderedViewLine = null;
  }
  // --- begin IVisibleLineData
  getDomNode() {
    return this._renderedViewLine && this._renderedViewLine.domNode ? this._renderedViewLine.domNode.domNode : null;
  }
  setDomNode(e) {
    if (this._renderedViewLine)
      this._renderedViewLine.domNode = rt(e);
    else
      throw new Error("I have no rendered view line to set the dom node to...");
  }
  onContentChanged() {
    this._isMaybeInvalid = !0;
  }
  onTokensChanged() {
    this._isMaybeInvalid = !0;
  }
  onDecorationsChanged() {
    this._isMaybeInvalid = !0;
  }
  onOptionsChanged(e) {
    this._isMaybeInvalid = !0, this._options = e;
  }
  onSelectionChanged() {
    return Ca(this._options.themeType) || this._options.renderWhitespace === "selection" ? (this._isMaybeInvalid = !0, !0) : !1;
  }
  renderLine(e, t, i, n, o) {
    if (this._isMaybeInvalid === !1)
      return !1;
    this._isMaybeInvalid = !1;
    const r = n.getViewLineRenderingData(e), a = this._options, l = Qo.filter(r.inlineDecorations, e, r.minColumn, r.maxColumn);
    let c = null;
    if (Ca(a.themeType) || this._options.renderWhitespace === "selection") {
      const g = n.selections;
      for (const m of g) {
        if (m.endLineNumber < e || m.startLineNumber > e)
          continue;
        const p = m.startLineNumber === e ? m.startColumn : r.minColumn, A = m.endLineNumber === e ? m.endColumn : r.maxColumn;
        p < A && (Ca(a.themeType) && l.push(new Qo(
          p,
          A,
          "inline-selected-text",
          0
          /* InlineDecorationType.Regular */
        )), this._options.renderWhitespace === "selection" && (c || (c = []), c.push(new A8(p - 1, A - 1))));
      }
    }
    const d = new km(a.useMonospaceOptimizations, a.canUseHalfwidthRightwardsArrow, r.content, r.continuesWithWrappedLine, r.isBasicASCII, r.containsRTL, r.minColumn - 1, r.tokens, l, r.tabSize, r.startVisibleColumn, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, a.stopRenderingLineAfter, a.renderWhitespace, a.renderControlCharacters, a.fontLigatures !== hu.OFF, c);
    if (this._renderedViewLine && this._renderedViewLine.input.equals(d))
      return !1;
    o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;" class="'), o.appendString(Q1.CLASS_NAME), o.appendString('">');
    const h = ET(d, o);
    o.appendString("</div>");
    let u = null;
    return If && cse && r.isBasicASCII && a.useMonospaceOptimizations && h.containsForeignElements === 0 && (u = new Vb(this._renderedViewLine ? this._renderedViewLine.domNode : null, d, h.characterMapping)), u || (u = E8(this._renderedViewLine ? this._renderedViewLine.domNode : null, d, h.characterMapping, h.containsRTL, h.containsForeignElements)), this._renderedViewLine = u, !0;
  }
  layoutLine(e, t, i) {
    this._renderedViewLine && this._renderedViewLine.domNode && (this._renderedViewLine.domNode.setTop(t), this._renderedViewLine.domNode.setHeight(i));
  }
  // --- end IVisibleLineData
  getWidth(e) {
    return this._renderedViewLine ? this._renderedViewLine.getWidth(e) : 0;
  }
  getWidthIsFast() {
    return this._renderedViewLine ? this._renderedViewLine.getWidthIsFast() : !0;
  }
  needsMonospaceFontCheck() {
    return this._renderedViewLine ? this._renderedViewLine instanceof Vb : !1;
  }
  monospaceAssumptionsAreValid() {
    return this._renderedViewLine && this._renderedViewLine instanceof Vb ? this._renderedViewLine.monospaceAssumptionsAreValid() : If;
  }
  onMonospaceAssumptionsInvalidated() {
    this._renderedViewLine && this._renderedViewLine instanceof Vb && (this._renderedViewLine = this._renderedViewLine.toSlowRenderedLine());
  }
  getVisibleRangesForRange(e, t, i, n) {
    if (!this._renderedViewLine)
      return null;
    t = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, t)), i = Math.min(this._renderedViewLine.input.lineContent.length + 1, Math.max(1, i));
    const o = this._renderedViewLine.input.stopRenderingLineAfter;
    if (o !== -1 && t > o + 1 && i > o + 1)
      return new yO(!0, [new Th(this.getWidth(n), 0)]);
    o !== -1 && t > o + 1 && (t = o + 1), o !== -1 && i > o + 1 && (i = o + 1);
    const r = this._renderedViewLine.getVisibleRangesForRange(e, t, i, n);
    return r && r.length > 0 ? new yO(!1, r) : null;
  }
  getColumnOfNodeOffset(e, t) {
    return this._renderedViewLine ? this._renderedViewLine.getColumnOfNodeOffset(e, t) : 1;
  }
};
Q1.CLASS_NAME = "view-line";
let Al = Q1;
class Vb {
  constructor(e, t, i) {
    this._cachedWidth = -1, this.domNode = e, this.input = t;
    const n = Math.floor(
      t.lineContent.length / 300
      /* Constants.MaxMonospaceDistance */
    );
    if (n > 0) {
      this._keyColumnPixelOffsetCache = new Float32Array(n);
      for (let o = 0; o < n; o++)
        this._keyColumnPixelOffsetCache[o] = -1;
    } else
      this._keyColumnPixelOffsetCache = null;
    this._characterMapping = i, this._charWidth = t.spaceWidth;
  }
  getWidth(e) {
    if (!this.domNode || this.input.lineContent.length < 300) {
      const t = this._characterMapping.getHorizontalOffset(this._characterMapping.length);
      return Math.round(this._charWidth * t);
    }
    return this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e?.markDidDomLayout()), this._cachedWidth;
  }
  getWidthIsFast() {
    return this.input.lineContent.length < 300 || this._cachedWidth !== -1;
  }
  monospaceAssumptionsAreValid() {
    if (!this.domNode)
      return If;
    if (this.input.lineContent.length < 300) {
      const e = this.getWidth(null), t = this.domNode.domNode.firstChild.offsetWidth;
      Math.abs(e - t) >= 2 && (console.warn("monospace assumptions have been violated, therefore disabling monospace optimizations!"), If = !1);
    }
    return If;
  }
  toSlowRenderedLine() {
    return E8(
      this.domNode,
      this.input,
      this._characterMapping,
      !1,
      0
      /* ForeignElementType.None */
    );
  }
  getVisibleRangesForRange(e, t, i, n) {
    const o = this._getColumnPixelOffset(e, t, n), r = this._getColumnPixelOffset(e, i, n);
    return [new Th(o, r - o)];
  }
  _getColumnPixelOffset(e, t, i) {
    if (t <= 300) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const n = Math.floor(
      (t - 1) / 300
      /* Constants.MaxMonospaceDistance */
    ) - 1, o = (n + 1) * 300 + 1;
    let r = -1;
    if (this._keyColumnPixelOffsetCache && (r = this._keyColumnPixelOffsetCache[n], r === -1 && (r = this._actualReadPixelOffset(e, o, i), this._keyColumnPixelOffsetCache[n] = r)), r === -1) {
      const c = this._characterMapping.getHorizontalOffset(t);
      return this._charWidth * c;
    }
    const a = this._characterMapping.getHorizontalOffset(o), l = this._characterMapping.getHorizontalOffset(t);
    return r + this._charWidth * (l - a);
  }
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  _actualReadPixelOffset(e, t, i) {
    if (!this.domNode)
      return -1;
    const n = this._characterMapping.getDomPosition(t), o = Rw.readHorizontalRanges(this._getReadingTarget(this.domNode), n.partIndex, n.charIndex, n.partIndex, n.charIndex, i);
    return !o || o.length === 0 ? -1 : o[0].left;
  }
  getColumnOfNodeOffset(e, t) {
    return L8(this._characterMapping, e, t);
  }
}
class x8 {
  constructor(e, t, i, n, o) {
    if (this.domNode = e, this.input = t, this._characterMapping = i, this._isWhitespaceOnly = /^\s*$/.test(t.lineContent), this._containsForeignElements = o, this._cachedWidth = -1, this._pixelOffsetCache = null, !n || this._characterMapping.length === 0) {
      this._pixelOffsetCache = new Float32Array(Math.max(2, this._characterMapping.length + 1));
      for (let r = 0, a = this._characterMapping.length; r <= a; r++)
        this._pixelOffsetCache[r] = -1;
    }
  }
  // --- Reading from the DOM methods
  _getReadingTarget(e) {
    return e.domNode.firstChild;
  }
  /**
   * Width of the line in pixels
   */
  getWidth(e) {
    return this.domNode ? (this._cachedWidth === -1 && (this._cachedWidth = this._getReadingTarget(this.domNode).offsetWidth, e?.markDidDomLayout()), this._cachedWidth) : 0;
  }
  getWidthIsFast() {
    return this._cachedWidth !== -1;
  }
  /**
   * Visible ranges for a model range
   */
  getVisibleRangesForRange(e, t, i, n) {
    if (!this.domNode)
      return null;
    if (this._pixelOffsetCache !== null) {
      const o = this._readPixelOffset(this.domNode, e, t, n);
      if (o === -1)
        return null;
      const r = this._readPixelOffset(this.domNode, e, i, n);
      return r === -1 ? null : [new Th(o, r - o)];
    }
    return this._readVisibleRangesForRange(this.domNode, e, t, i, n);
  }
  _readVisibleRangesForRange(e, t, i, n, o) {
    if (i === n) {
      const r = this._readPixelOffset(e, t, i, o);
      return r === -1 ? null : [new Th(r, 0)];
    } else
      return this._readRawVisibleRangesForRange(e, i, n, o);
  }
  _readPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      if (this._containsForeignElements === 0 || this._containsForeignElements === 2)
        return 0;
      if (this._containsForeignElements === 1)
        return this.getWidth(n);
      const o = this._getReadingTarget(e);
      return o.firstChild ? (n.markDidDomLayout(), o.firstChild.offsetWidth) : 0;
    }
    if (this._pixelOffsetCache !== null) {
      const o = this._pixelOffsetCache[i];
      if (o !== -1)
        return o;
      const r = this._actualReadPixelOffset(e, t, i, n);
      return this._pixelOffsetCache[i] = r, r;
    }
    return this._actualReadPixelOffset(e, t, i, n);
  }
  _actualReadPixelOffset(e, t, i, n) {
    if (this._characterMapping.length === 0) {
      const l = Rw.readHorizontalRanges(this._getReadingTarget(e), 0, 0, 0, 0, n);
      return !l || l.length === 0 ? -1 : l[0].left;
    }
    if (i === this._characterMapping.length && this._isWhitespaceOnly && this._containsForeignElements === 0)
      return this.getWidth(n);
    const o = this._characterMapping.getDomPosition(i), r = Rw.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, o.partIndex, o.charIndex, n);
    if (!r || r.length === 0)
      return -1;
    const a = r[0].left;
    if (this.input.isBasicASCII) {
      const l = this._characterMapping.getHorizontalOffset(i), c = Math.round(this.input.spaceWidth * l);
      if (Math.abs(c - a) <= 1)
        return c;
    }
    return a;
  }
  _readRawVisibleRangesForRange(e, t, i, n) {
    if (t === 1 && i === this._characterMapping.length)
      return [new Th(0, this.getWidth(n))];
    const o = this._characterMapping.getDomPosition(t), r = this._characterMapping.getDomPosition(i);
    return Rw.readHorizontalRanges(this._getReadingTarget(e), o.partIndex, o.charIndex, r.partIndex, r.charIndex, n);
  }
  /**
   * Returns the column for the text found at a specific offset inside a rendered dom node
   */
  getColumnOfNodeOffset(e, t) {
    return L8(this._characterMapping, e, t);
  }
}
class dse extends x8 {
  _readVisibleRangesForRange(e, t, i, n, o) {
    const r = super._readVisibleRangesForRange(e, t, i, n, o);
    if (!r || r.length === 0 || i === n || i === 1 && n === this._characterMapping.length)
      return r;
    if (!this.input.containsRTL) {
      const a = this._readPixelOffset(e, t, n, o);
      if (a !== -1) {
        const l = r[r.length - 1];
        l.left < a && (l.width = a - l.left);
      }
    }
    return r;
  }
}
const E8 = /* @__PURE__ */ function() {
  return b0 ? hse : use;
}();
function hse(s, e, t, i, n) {
  return new dse(s, e, t, i, n);
}
function use(s, e, t, i, n) {
  return new x8(s, e, t, i, n);
}
function L8(s, e, t) {
  const i = e.textContent.length;
  let n = -1;
  for (; e; )
    e = e.previousSibling, n++;
  return s.getColumn(new _8(n, t), i);
}
class c_ {
  /**
   * Get the visible column at the position. If we get to a non-whitespace character first
   * or past the end of string then return -1.
   *
   * **Note** `position` and the return value are 0-based.
   */
  static whitespaceVisibleColumn(e, t, i) {
    const n = e.length;
    let o = 0, r = -1, a = -1;
    for (let l = 0; l < n; l++) {
      if (l === t)
        return [r, a, o];
      switch (o % i === 0 && (r = l, a = o), e.charCodeAt(l)) {
        case 32:
          o += 1;
          break;
        case 9:
          o = wi.nextRenderTabStop(o, i);
          break;
        default:
          return [-1, -1, -1];
      }
    }
    return t === n ? [r, a, o] : [-1, -1, -1];
  }
  /**
   * Return the position that should result from a move left, right or to the
   * nearest tab, if atomic tabs are enabled. Left and right are used for the
   * arrow key movements, nearest is used for mouse selection. It returns
   * -1 if atomic tabs are not relevant and you should fall back to normal
   * behaviour.
   *
   * **Note**: `position` and the return value are 0-based.
   */
  static atomicPosition(e, t, i, n) {
    const o = e.length, [r, a, l] = c_.whitespaceVisibleColumn(e, t, i);
    if (l === -1)
      return -1;
    let c;
    switch (n) {
      case 0:
        c = !0;
        break;
      case 1:
        c = !1;
        break;
      case 2:
        if (l % i === 0)
          return t;
        c = l % i <= i / 2;
        break;
    }
    if (c) {
      if (r === -1)
        return -1;
      let u = a;
      for (let g = r; g < o; ++g) {
        if (u === a + i)
          return r;
        switch (e.charCodeAt(g)) {
          case 32:
            u += 1;
            break;
          case 9:
            u = wi.nextRenderTabStop(u, i);
            break;
          default:
            return -1;
        }
      }
      return u === a + i ? r : -1;
    }
    const d = wi.nextRenderTabStop(l, i);
    let h = l;
    for (let u = t; u < o; u++) {
      if (h === d)
        return u;
      switch (e.charCodeAt(u)) {
        case 32:
          h += 1;
          break;
        case 9:
          h = wi.nextRenderTabStop(h, i);
          break;
        default:
          return -1;
      }
    }
    return h === d ? o : -1;
  }
}
class dc {
  constructor(e = null) {
    this.hitTarget = e, this.type = 0;
  }
}
class k8 {
  get hitTarget() {
    return this.spanNode;
  }
  constructor(e, t, i) {
    this.position = e, this.spanNode = t, this.injectedText = i, this.type = 1;
  }
}
var rh;
(function(s) {
  function e(t, i, n) {
    const o = t.getPositionFromDOMInfo(i, n);
    return o ? new k8(o, i, null) : new dc(i);
  }
  s.createFromDOMInfo = e;
})(rh || (rh = {}));
class gse {
  constructor(e, t) {
    this.lastViewCursorsRenderData = e, this.lastTextareaPosition = t;
  }
}
class _n {
  static _deduceRage(e, t = null) {
    return !t && e ? new E(e.lineNumber, e.column, e.lineNumber, e.column) : t ?? null;
  }
  static createUnknown(e, t, i) {
    return { type: 0, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createTextarea(e, t) {
    return { type: 1, element: e, mouseColumn: t, position: null, range: null };
  }
  static createMargin(e, t, i, n, o, r) {
    return { type: e, element: t, mouseColumn: i, position: n, range: o, detail: r };
  }
  static createViewZone(e, t, i, n, o) {
    return { type: e, element: t, mouseColumn: i, position: n, range: this._deduceRage(n), detail: o };
  }
  static createContentText(e, t, i, n, o) {
    return { type: 6, element: e, mouseColumn: t, position: i, range: this._deduceRage(i, n), detail: o };
  }
  static createContentEmpty(e, t, i, n) {
    return { type: 7, element: e, mouseColumn: t, position: i, range: this._deduceRage(i), detail: n };
  }
  static createContentWidget(e, t, i) {
    return { type: 9, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createScrollbar(e, t, i) {
    return { type: 11, element: e, mouseColumn: t, position: i, range: this._deduceRage(i) };
  }
  static createOverlayWidget(e, t, i) {
    return { type: 12, element: e, mouseColumn: t, position: null, range: null, detail: i };
  }
  static createOutsideEditor(e, t, i, n) {
    return { type: 13, element: null, mouseColumn: e, position: t, range: this._deduceRage(t), outsidePosition: i, outsideDistance: n };
  }
  static _typeToString(e) {
    return e === 1 ? "TEXTAREA" : e === 2 ? "GUTTER_GLYPH_MARGIN" : e === 3 ? "GUTTER_LINE_NUMBERS" : e === 4 ? "GUTTER_LINE_DECORATIONS" : e === 5 ? "GUTTER_VIEW_ZONE" : e === 6 ? "CONTENT_TEXT" : e === 7 ? "CONTENT_EMPTY" : e === 8 ? "CONTENT_VIEW_ZONE" : e === 9 ? "CONTENT_WIDGET" : e === 10 ? "OVERVIEW_RULER" : e === 11 ? "SCROLLBAR" : e === 12 ? "OVERLAY_WIDGET" : "UNKNOWN";
  }
  static toString(e) {
    return this._typeToString(e.type) + ": " + e.position + " - " + e.range + " - " + JSON.stringify(e.detail);
  }
}
class Ln {
  static isTextArea(e) {
    return e.length === 2 && e[0] === 3 && e[1] === 7;
  }
  static isChildOfViewLines(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 8;
  }
  static isStrictChildOfViewLines(e) {
    return e.length > 4 && e[0] === 3 && e[3] === 8;
  }
  static isChildOfScrollableElement(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 6;
  }
  static isChildOfMinimap(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 9;
  }
  static isChildOfContentWidgets(e) {
    return e.length >= 4 && e[0] === 3 && e[3] === 1;
  }
  static isChildOfOverflowGuard(e) {
    return e.length >= 1 && e[0] === 3;
  }
  static isChildOfOverflowingContentWidgets(e) {
    return e.length >= 1 && e[0] === 2;
  }
  static isChildOfOverlayWidgets(e) {
    return e.length >= 2 && e[0] === 3 && e[1] === 4;
  }
  static isChildOfOverflowingOverlayWidgets(e) {
    return e.length >= 1 && e[0] === 5;
  }
}
class lm {
  constructor(e, t, i) {
    this.viewModel = e.viewModel;
    const n = e.configuration.options;
    this.layoutInfo = n.get(
      146
      /* EditorOption.layoutInfo */
    ), this.viewDomNode = t.viewDomNode, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.stickyTabStops = n.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.typicalHalfwidthCharacterWidth = n.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this.lastRenderData = i, this._context = e, this._viewHelper = t;
  }
  getZoneAtCoord(e) {
    return lm.getZoneAtCoord(this._context, e);
  }
  static getZoneAtCoord(e, t) {
    const i = e.viewLayout.getWhitespaceAtVerticalOffset(t);
    if (i) {
      const n = i.verticalOffset + i.height / 2, o = e.viewModel.getLineCount();
      let r = null, a, l = null;
      return i.afterLineNumber !== o && (l = new F(i.afterLineNumber + 1, 1)), i.afterLineNumber > 0 && (r = new F(i.afterLineNumber, e.viewModel.getLineMaxColumn(i.afterLineNumber))), l === null ? a = r : r === null ? a = l : t < n ? a = r : a = l, {
        viewZoneId: i.id,
        afterLineNumber: i.afterLineNumber,
        positionBefore: r,
        positionAfter: l,
        position: a
      };
    }
    return null;
  }
  getFullLineRangeAtCoord(e) {
    if (this._context.viewLayout.isAfterLines(e)) {
      const n = this._context.viewModel.getLineCount(), o = this._context.viewModel.getLineMaxColumn(n);
      return {
        range: new E(n, o, n, o),
        isAfterLines: !0
      };
    }
    const t = this._context.viewLayout.getLineNumberAtVerticalOffset(e), i = this._context.viewModel.getLineMaxColumn(t);
    return {
      range: new E(t, 1, t, i),
      isAfterLines: !1
    };
  }
  getLineNumberAtVerticalOffset(e) {
    return this._context.viewLayout.getLineNumberAtVerticalOffset(e);
  }
  isAfterLines(e) {
    return this._context.viewLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._context.viewLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._context.viewLayout.isInBottomPadding(e);
  }
  getVerticalOffsetForLineNumber(e) {
    return this._context.viewLayout.getVerticalOffsetForLineNumber(e);
  }
  findAttribute(e, t) {
    return lm._findAttribute(e, t, this._viewHelper.viewDomNode);
  }
  static _findAttribute(e, t, i) {
    for (; e && e !== e.ownerDocument.body; ) {
      if (e.hasAttribute && e.hasAttribute(t))
        return e.getAttribute(t);
      if (e === i)
        return null;
      e = e.parentNode;
    }
    return null;
  }
  getLineWidth(e) {
    return this._viewHelper.getLineWidth(e);
  }
  visibleRangeForPosition(e, t) {
    return this._viewHelper.visibleRangeForPosition(e, t);
  }
  getPositionFromDOMInfo(e, t) {
    return this._viewHelper.getPositionFromDOMInfo(e, t);
  }
  getCurrentScrollTop() {
    return this._context.viewLayout.getCurrentScrollTop();
  }
  getCurrentScrollLeft() {
    return this._context.viewLayout.getCurrentScrollLeft();
  }
}
class fse {
  constructor(e, t, i, n) {
    this.editorPos = t, this.pos = i, this.relativePos = n, this.mouseVerticalOffset = Math.max(0, e.getCurrentScrollTop() + this.relativePos.y), this.mouseContentHorizontalOffset = e.getCurrentScrollLeft() + this.relativePos.x - e.layoutInfo.contentLeft, this.isInMarginArea = this.relativePos.x < e.layoutInfo.contentLeft && this.relativePos.x >= e.layoutInfo.glyphMarginLeft, this.isInContentArea = !this.isInMarginArea, this.mouseColumn = Math.max(0, An._getMouseColumn(this.mouseContentHorizontalOffset, e.typicalHalfwidthCharacterWidth));
  }
}
class mse extends fse {
  get target() {
    return this._useHitTestTarget ? this.hitTestResult.value.hitTarget : this._eventTarget;
  }
  get targetPath() {
    return this._targetPathCacheElement !== this.target && (this._targetPathCacheElement = this.target, this._targetPathCacheValue = Pr.collect(this.target, this._ctx.viewDomNode)), this._targetPathCacheValue;
  }
  constructor(e, t, i, n, o) {
    super(e, t, i, n), this.hitTestResult = new Br(() => An.doHitTest(this._ctx, this)), this._targetPathCacheElement = null, this._targetPathCacheValue = new Uint8Array(0), this._ctx = e, this._eventTarget = o;
    const r = !!this._eventTarget;
    this._useHitTestTarget = !r;
  }
  toString() {
    return `pos(${this.pos.x},${this.pos.y}), editorPos(${this.editorPos.x},${this.editorPos.y}), relativePos(${this.relativePos.x},${this.relativePos.y}), mouseVerticalOffset: ${this.mouseVerticalOffset}, mouseContentHorizontalOffset: ${this.mouseContentHorizontalOffset}
	target: ${this.target ? this.target.outerHTML : null}`;
  }
  get wouldBenefitFromHitTestTargetSwitch() {
    return !this._useHitTestTarget && this.hitTestResult.value.hitTarget !== null && this.target !== this.hitTestResult.value.hitTarget;
  }
  switchToHitTestTarget() {
    this._useHitTestTarget = !0;
  }
  _getMouseColumn(e = null) {
    return e && e.column < this._ctx.viewModel.getLineMaxColumn(e.lineNumber) ? wi.visibleColumnFromColumn(this._ctx.viewModel.getLineContent(e.lineNumber), e.column, this._ctx.viewModel.model.getOptions().tabSize) + 1 : this.mouseColumn;
  }
  fulfillUnknown(e = null) {
    return _n.createUnknown(this.target, this._getMouseColumn(e), e);
  }
  fulfillTextarea() {
    return _n.createTextarea(this.target, this._getMouseColumn());
  }
  fulfillMargin(e, t, i, n) {
    return _n.createMargin(e, this.target, this._getMouseColumn(t), t, i, n);
  }
  fulfillViewZone(e, t, i) {
    return _n.createViewZone(e, this.target, this._getMouseColumn(t), t, i);
  }
  fulfillContentText(e, t, i) {
    return _n.createContentText(this.target, this._getMouseColumn(e), e, t, i);
  }
  fulfillContentEmpty(e, t) {
    return _n.createContentEmpty(this.target, this._getMouseColumn(e), e, t);
  }
  fulfillContentWidget(e) {
    return _n.createContentWidget(this.target, this._getMouseColumn(), e);
  }
  fulfillScrollbar(e) {
    return _n.createScrollbar(this.target, this._getMouseColumn(e), e);
  }
  fulfillOverlayWidget(e) {
    return _n.createOverlayWidget(this.target, this._getMouseColumn(), e);
  }
}
const EO = { isAfterLines: !0 };
function $y(s) {
  return {
    isAfterLines: !1,
    horizontalDistanceToText: s
  };
}
class An {
  constructor(e, t) {
    this._context = e, this._viewHelper = t;
  }
  mouseTargetIsWidget(e) {
    const t = e.target, i = Pr.collect(t, this._viewHelper.viewDomNode);
    return !!(Ln.isChildOfContentWidgets(i) || Ln.isChildOfOverflowingContentWidgets(i) || Ln.isChildOfOverlayWidgets(i) || Ln.isChildOfOverflowingOverlayWidgets(i));
  }
  createMouseTarget(e, t, i, n, o) {
    const r = new lm(this._context, this._viewHelper, e), a = new mse(r, t, i, n, o);
    try {
      const l = An._createMouseTarget(r, a);
      if (l.type === 6 && r.stickyTabStops && l.position !== null) {
        const c = An._snapToSoftTabBoundary(l.position, r.viewModel), d = E.fromPositions(c, c).plusRange(l.range);
        return a.fulfillContentText(c, d, l.detail);
      }
      return l;
    } catch {
      return a.fulfillUnknown();
    }
  }
  static _createMouseTarget(e, t) {
    if (t.target === null)
      return t.fulfillUnknown();
    const i = t;
    let n = null;
    return !Ln.isChildOfOverflowGuard(t.targetPath) && !Ln.isChildOfOverflowingContentWidgets(t.targetPath) && !Ln.isChildOfOverflowingOverlayWidgets(t.targetPath) && (n = n || t.fulfillUnknown()), n = n || An._hitTestContentWidget(e, i), n = n || An._hitTestOverlayWidget(e, i), n = n || An._hitTestMinimap(e, i), n = n || An._hitTestScrollbarSlider(e, i), n = n || An._hitTestViewZone(e, i), n = n || An._hitTestMargin(e, i), n = n || An._hitTestViewCursor(e, i), n = n || An._hitTestTextArea(e, i), n = n || An._hitTestViewLines(e, i), n = n || An._hitTestScrollbar(e, i), n || t.fulfillUnknown();
  }
  static _hitTestContentWidget(e, t) {
    if (Ln.isChildOfContentWidgets(t.targetPath) || Ln.isChildOfOverflowingContentWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillContentWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestOverlayWidget(e, t) {
    if (Ln.isChildOfOverlayWidgets(t.targetPath) || Ln.isChildOfOverflowingOverlayWidgets(t.targetPath)) {
      const i = e.findAttribute(t.target, "widgetId");
      return i ? t.fulfillOverlayWidget(i) : t.fulfillUnknown();
    }
    return null;
  }
  static _hitTestViewCursor(e, t) {
    if (t.target) {
      const i = e.lastRenderData.lastViewCursorsRenderData;
      for (const n of i)
        if (t.target === n.domNode)
          return t.fulfillContentText(n.position, null, { mightBeForeignElement: !1, injectedText: null });
    }
    if (t.isInContentArea) {
      const i = e.lastRenderData.lastViewCursorsRenderData, n = t.mouseContentHorizontalOffset, o = t.mouseVerticalOffset;
      for (const r of i) {
        if (n < r.contentLeft || n > r.contentLeft + r.width)
          continue;
        const a = e.getVerticalOffsetForLineNumber(r.position.lineNumber);
        if (a <= o && o <= a + r.height)
          return t.fulfillContentText(r.position, null, { mightBeForeignElement: !1, injectedText: null });
      }
    }
    return null;
  }
  static _hitTestViewZone(e, t) {
    const i = e.getZoneAtCoord(t.mouseVerticalOffset);
    if (i) {
      const n = t.isInContentArea ? 8 : 5;
      return t.fulfillViewZone(n, i.position, i);
    }
    return null;
  }
  static _hitTestTextArea(e, t) {
    return Ln.isTextArea(t.targetPath) ? e.lastRenderData.lastTextareaPosition ? t.fulfillContentText(e.lastRenderData.lastTextareaPosition, null, { mightBeForeignElement: !1, injectedText: null }) : t.fulfillTextarea() : null;
  }
  static _hitTestMargin(e, t) {
    if (t.isInMarginArea) {
      const i = e.getFullLineRangeAtCoord(t.mouseVerticalOffset), n = i.range.getStartPosition();
      let o = Math.abs(t.relativePos.x);
      const r = {
        isAfterLines: i.isAfterLines,
        glyphMarginLeft: e.layoutInfo.glyphMarginLeft,
        glyphMarginWidth: e.layoutInfo.glyphMarginWidth,
        lineNumbersWidth: e.layoutInfo.lineNumbersWidth,
        offsetX: o
      };
      if (o -= e.layoutInfo.glyphMarginLeft, o <= e.layoutInfo.glyphMarginWidth) {
        const a = e.viewModel.coordinatesConverter.convertViewPositionToModelPosition(i.range.getStartPosition()), l = e.viewModel.glyphLanes.getLanesAtLine(a.lineNumber);
        return r.glyphMarginLane = l[Math.floor(o / e.lineHeight)], t.fulfillMargin(2, n, i.range, r);
      }
      return o -= e.layoutInfo.glyphMarginWidth, o <= e.layoutInfo.lineNumbersWidth ? t.fulfillMargin(3, n, i.range, r) : (o -= e.layoutInfo.lineNumbersWidth, t.fulfillMargin(4, n, i.range, r));
    }
    return null;
  }
  static _hitTestViewLines(e, t) {
    if (!Ln.isChildOfViewLines(t.targetPath))
      return null;
    if (e.isInTopPadding(t.mouseVerticalOffset))
      return t.fulfillContentEmpty(new F(1, 1), EO);
    if (e.isAfterLines(t.mouseVerticalOffset) || e.isInBottomPadding(t.mouseVerticalOffset)) {
      const n = e.viewModel.getLineCount(), o = e.viewModel.getLineMaxColumn(n);
      return t.fulfillContentEmpty(new F(n, o), EO);
    }
    if (Ln.isStrictChildOfViewLines(t.targetPath)) {
      const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset);
      if (e.viewModel.getLineLength(n) === 0) {
        const r = e.getLineWidth(n), a = $y(t.mouseContentHorizontalOffset - r);
        return t.fulfillContentEmpty(new F(n, 1), a);
      }
      const o = e.getLineWidth(n);
      if (t.mouseContentHorizontalOffset >= o) {
        const r = $y(t.mouseContentHorizontalOffset - o), a = new F(n, e.viewModel.getLineMaxColumn(n));
        return t.fulfillContentEmpty(a, r);
      }
    }
    const i = t.hitTestResult.value;
    return i.type === 1 ? An.createMouseTargetFromHitTestPosition(e, t, i.spanNode, i.position, i.injectedText) : t.wouldBenefitFromHitTestTargetSwitch ? (t.switchToHitTestTarget(), this._createMouseTarget(e, t)) : t.fulfillUnknown();
  }
  static _hitTestMinimap(e, t) {
    if (Ln.isChildOfMinimap(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new F(i, n));
    }
    return null;
  }
  static _hitTestScrollbarSlider(e, t) {
    if (Ln.isChildOfScrollableElement(t.targetPath) && t.target && t.target.nodeType === 1) {
      const i = t.target.className;
      if (i && /\b(slider|scrollbar)\b/.test(i)) {
        const n = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), o = e.viewModel.getLineMaxColumn(n);
        return t.fulfillScrollbar(new F(n, o));
      }
    }
    return null;
  }
  static _hitTestScrollbar(e, t) {
    if (Ln.isChildOfScrollableElement(t.targetPath)) {
      const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.viewModel.getLineMaxColumn(i);
      return t.fulfillScrollbar(new F(i, n));
    }
    return null;
  }
  getMouseColumn(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    ), n = this._context.viewLayout.getCurrentScrollLeft() + e.x - i.contentLeft;
    return An._getMouseColumn(n, t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth);
  }
  static _getMouseColumn(e, t) {
    return e < 0 ? 1 : Math.round(e / t) + 1;
  }
  static createMouseTargetFromHitTestPosition(e, t, i, n, o) {
    const r = n.lineNumber, a = n.column, l = e.getLineWidth(r);
    if (t.mouseContentHorizontalOffset > l) {
      const _ = $y(t.mouseContentHorizontalOffset - l);
      return t.fulfillContentEmpty(n, _);
    }
    const c = e.visibleRangeForPosition(r, a);
    if (!c)
      return t.fulfillUnknown(n);
    const d = c.left;
    if (Math.abs(t.mouseContentHorizontalOffset - d) < 1)
      return t.fulfillContentText(n, null, { mightBeForeignElement: !!o, injectedText: o });
    const h = [];
    if (h.push({ offset: c.left, column: a }), a > 1) {
      const _ = e.visibleRangeForPosition(r, a - 1);
      _ && h.push({ offset: _.left, column: a - 1 });
    }
    const u = e.viewModel.getLineMaxColumn(r);
    if (a < u) {
      const _ = e.visibleRangeForPosition(r, a + 1);
      _ && h.push({ offset: _.left, column: a + 1 });
    }
    h.sort((_, b) => _.offset - b.offset);
    const g = t.pos.toClientCoordinates(fe(e.viewDomNode)), m = i.getBoundingClientRect(), p = m.left <= g.clientX && g.clientX <= m.right;
    let A = null;
    for (let _ = 1; _ < h.length; _++) {
      const b = h[_ - 1], C = h[_];
      if (b.offset <= t.mouseContentHorizontalOffset && t.mouseContentHorizontalOffset <= C.offset) {
        A = new E(r, b.column, r, C.column);
        const w = Math.abs(b.offset - t.mouseContentHorizontalOffset), S = Math.abs(C.offset - t.mouseContentHorizontalOffset);
        n = w < S ? new F(r, b.column) : new F(r, C.column);
        break;
      }
    }
    return t.fulfillContentText(n, A, { mightBeForeignElement: !p || !!o, injectedText: o });
  }
  /**
   * Most probably WebKit browsers and Edge
   */
  static _doHitTestWithCaretRangeFromPoint(e, t) {
    const i = e.getLineNumberAtVerticalOffset(t.mouseVerticalOffset), n = e.getVerticalOffsetForLineNumber(i), o = n + e.lineHeight;
    if (!(i === e.viewModel.getLineCount() && t.mouseVerticalOffset > o)) {
      const a = Math.floor((n + o) / 2);
      let l = t.pos.y + (a - t.mouseVerticalOffset);
      l <= t.editorPos.y && (l = t.editorPos.y + 1), l >= t.editorPos.y + t.editorPos.height && (l = t.editorPos.y + t.editorPos.height - 1);
      const c = new vS(t.pos.x, l), d = this._actualDoHitTestWithCaretRangeFromPoint(e, c.toClientCoordinates(fe(e.viewDomNode)));
      if (d.type === 1)
        return d;
    }
    return this._actualDoHitTestWithCaretRangeFromPoint(e, t.pos.toClientCoordinates(fe(e.viewDomNode)));
  }
  static _actualDoHitTestWithCaretRangeFromPoint(e, t) {
    const i = pu(e.viewDomNode);
    let n;
    if (i ? typeof i.caretRangeFromPoint > "u" ? n = pse(i, t.clientX, t.clientY) : n = i.caretRangeFromPoint(t.clientX, t.clientY) : n = e.viewDomNode.ownerDocument.caretRangeFromPoint(t.clientX, t.clientY), !n || !n.startContainer)
      return new dc();
    const o = n.startContainer;
    if (o.nodeType === o.TEXT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null, l = a ? a.parentNode : null;
      return (l && l.nodeType === l.ELEMENT_NODE ? l.className : null) === Al.CLASS_NAME ? rh.createFromDOMInfo(e, r, n.startOffset) : new dc(o.parentNode);
    } else if (o.nodeType === o.ELEMENT_NODE) {
      const r = o.parentNode, a = r ? r.parentNode : null;
      return (a && a.nodeType === a.ELEMENT_NODE ? a.className : null) === Al.CLASS_NAME ? rh.createFromDOMInfo(e, o, o.textContent.length) : new dc(o);
    }
    return new dc();
  }
  /**
   * Most probably Gecko
   */
  static _doHitTestWithCaretPositionFromPoint(e, t) {
    const i = e.viewDomNode.ownerDocument.caretPositionFromPoint(t.clientX, t.clientY);
    if (i.offsetNode.nodeType === i.offsetNode.TEXT_NODE) {
      const n = i.offsetNode.parentNode, o = n ? n.parentNode : null, r = o ? o.parentNode : null;
      return (r && r.nodeType === r.ELEMENT_NODE ? r.className : null) === Al.CLASS_NAME ? rh.createFromDOMInfo(e, i.offsetNode.parentNode, i.offset) : new dc(i.offsetNode.parentNode);
    }
    if (i.offsetNode.nodeType === i.offsetNode.ELEMENT_NODE) {
      const n = i.offsetNode.parentNode, o = n && n.nodeType === n.ELEMENT_NODE ? n.className : null, r = n ? n.parentNode : null, a = r && r.nodeType === r.ELEMENT_NODE ? r.className : null;
      if (o === Al.CLASS_NAME) {
        const l = i.offsetNode.childNodes[Math.min(i.offset, i.offsetNode.childNodes.length - 1)];
        if (l)
          return rh.createFromDOMInfo(e, l, 0);
      } else if (a === Al.CLASS_NAME)
        return rh.createFromDOMInfo(e, i.offsetNode, 0);
    }
    return new dc(i.offsetNode);
  }
  static _snapToSoftTabBoundary(e, t) {
    const i = t.getLineContent(e.lineNumber), { tabSize: n } = t.model.getOptions(), o = c_.atomicPosition(
      i,
      e.column - 1,
      n,
      2
      /* Direction.Nearest */
    );
    return o !== -1 ? new F(e.lineNumber, o + 1) : e;
  }
  static doHitTest(e, t) {
    let i = new dc();
    if (typeof e.viewDomNode.ownerDocument.caretRangeFromPoint == "function" ? i = this._doHitTestWithCaretRangeFromPoint(e, t) : e.viewDomNode.ownerDocument.caretPositionFromPoint && (i = this._doHitTestWithCaretPositionFromPoint(e, t.pos.toClientCoordinates(fe(e.viewDomNode)))), i.type === 1) {
      const n = e.viewModel.getInjectedTextAt(i.position), o = e.viewModel.normalizePosition(
        i.position,
        2
        /* PositionAffinity.None */
      );
      (n || !o.equals(i.position)) && (i = new k8(o, i.spanNode, n));
    }
    return i;
  }
}
function pse(s, e, t) {
  const i = document.createRange();
  let n = s.elementFromPoint(e, t);
  if (n !== null) {
    for (; n && n.firstChild && n.firstChild.nodeType !== n.firstChild.TEXT_NODE && n.lastChild && n.lastChild.firstChild; )
      n = n.lastChild;
    const o = n.getBoundingClientRect(), r = fe(n), a = r.getComputedStyle(n, null).getPropertyValue("font-style"), l = r.getComputedStyle(n, null).getPropertyValue("font-variant"), c = r.getComputedStyle(n, null).getPropertyValue("font-weight"), d = r.getComputedStyle(n, null).getPropertyValue("font-size"), h = r.getComputedStyle(n, null).getPropertyValue("line-height"), u = r.getComputedStyle(n, null).getPropertyValue("font-family"), g = `${a} ${l} ${c} ${d}/${h} ${u}`, m = n.innerText;
    let p = o.left, A = 0, _;
    if (e > o.left + o.width)
      A = m.length;
    else {
      const b = mD.getInstance();
      for (let C = 0; C < m.length + 1; C++) {
        if (_ = b.getCharWidth(m.charAt(C), g) / 2, p += _, e < p) {
          A = C;
          break;
        }
        p += _;
      }
    }
    i.setStart(n.firstChild, A), i.setEnd(n.firstChild, A);
  }
  return i;
}
const mh = class mh {
  static getInstance() {
    return mh._INSTANCE || (mh._INSTANCE = new mh()), mh._INSTANCE;
  }
  constructor() {
    this._cache = {}, this._canvas = document.createElement("canvas");
  }
  getCharWidth(e, t) {
    const i = e + t;
    if (this._cache[i])
      return this._cache[i];
    const n = this._canvas.getContext("2d");
    n.font = t;
    const r = n.measureText(e).width;
    return this._cache[i] = r, r;
  }
};
mh._INSTANCE = null;
let mD = mh;
class MT extends Y_ {
  constructor(e, t, i) {
    super(), this._mouseLeaveMonitor = null, this._context = e, this.viewController = t, this.viewHelper = i, this.mouseTargetFactory = new An(this._context, i), this._mouseDownOperation = this._register(new Ase(this._context, this.viewController, this.viewHelper, this.mouseTargetFactory, (r, a) => this._createMouseTarget(r, a), (r) => this._getMouseColumn(r))), this.lastMouseLeaveTime = -1, this._height = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height;
    const n = new ese(this.viewHelper.viewDomNode);
    this._register(n.onContextMenu(this.viewHelper.viewDomNode, (r) => this._onContextMenu(r, !0))), this._register(n.onMouseMove(this.viewHelper.viewDomNode, (r) => {
      this._onMouseMove(r), this._mouseLeaveMonitor || (this._mouseLeaveMonitor = U(this.viewHelper.viewDomNode.ownerDocument, "mousemove", (a) => {
        this.viewHelper.viewDomNode.contains(a.target) || this._onMouseLeave(new hd(a, !1, this.viewHelper.viewDomNode));
      }));
    })), this._register(n.onMouseUp(this.viewHelper.viewDomNode, (r) => this._onMouseUp(r))), this._register(n.onMouseLeave(this.viewHelper.viewDomNode, (r) => this._onMouseLeave(r)));
    let o = 0;
    this._register(n.onPointerDown(this.viewHelper.viewDomNode, (r, a) => {
      o = a;
    })), this._register(U(this.viewHelper.viewDomNode, ee.POINTER_UP, (r) => {
      this._mouseDownOperation.onPointerUp();
    })), this._register(n.onMouseDown(this.viewHelper.viewDomNode, (r) => this._onMouseDown(r, o))), this._setupMouseWheelZoomListener(), this._context.addEventHandler(this);
  }
  _setupMouseWheelZoomListener() {
    const e = EC.INSTANCE;
    let t = 0, i = _c.getZoomLevel(), n = !1, o = 0;
    const r = (l) => {
      if (this.viewController.emitMouseWheel(l), !this._context.configuration.options.get(
        76
        /* EditorOption.mouseWheelZoom */
      ))
        return;
      const c = new fu(l);
      if (e.acceptStandardWheelEvent(c), e.isPhysicalMouseWheel()) {
        if (a(l)) {
          const d = _c.getZoomLevel(), h = c.deltaY > 0 ? 1 : -1;
          _c.setZoomLevel(d + h), c.preventDefault(), c.stopPropagation();
        }
      } else
        Date.now() - t > 50 && (i = _c.getZoomLevel(), n = a(l), o = 0), t = Date.now(), o += c.deltaY, n && (_c.setZoomLevel(i + o / 5), c.preventDefault(), c.stopPropagation());
    };
    this._register(U(this.viewHelper.viewDomNode, ee.MOUSE_WHEEL, r, { capture: !0, passive: !1 }));
    function a(l) {
      return ze ? (l.metaKey || l.ctrlKey) && !l.shiftKey && !l.altKey : l.ctrlKey && !l.metaKey && !l.shiftKey && !l.altKey;
    }
  }
  dispose() {
    this._context.removeEventHandler(this), this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const t = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).height;
      this._height !== t && (this._height = t, this._mouseDownOperation.onHeightChanged());
    }
    return !1;
  }
  onCursorStateChanged(e) {
    return this._mouseDownOperation.onCursorStateChanged(e), !1;
  }
  onFocusChanged(e) {
    return !1;
  }
  // --- end event handlers
  getTargetAtClientPoint(e, t) {
    const n = new y8(e, t).toPageCoordinates(fe(this.viewHelper.viewDomNode)), o = DT(this.viewHelper.viewDomNode);
    if (n.y < o.y || n.y > o.y + o.height || n.x < o.x || n.x > o.x + o.width)
      return null;
    const r = IT(this.viewHelper.viewDomNode, o, n);
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), o, n, r, null);
  }
  _createMouseTarget(e, t) {
    let i = e.target;
    if (!this.viewHelper.viewDomNode.contains(i)) {
      const n = pu(this.viewHelper.viewDomNode);
      n && (i = n.elementsFromPoint(e.posx, e.posy).find((o) => this.viewHelper.viewDomNode.contains(o)));
    }
    return this.mouseTargetFactory.createMouseTarget(this.viewHelper.getLastRenderData(), e.editorPos, e.pos, e.relativePos, t ? i : null);
  }
  _getMouseColumn(e) {
    return this.mouseTargetFactory.getMouseColumn(e.relativePos);
  }
  _onContextMenu(e, t) {
    this.viewController.emitContextMenu({
      event: e,
      target: this._createMouseTarget(e, t)
    });
  }
  _onMouseMove(e) {
    this.mouseTargetFactory.mouseTargetIsWidget(e) || e.preventDefault(), !(this._mouseDownOperation.isActive() || e.timestamp < this.lastMouseLeaveTime) && this.viewController.emitMouseMove({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseLeave(e) {
    this._mouseLeaveMonitor && (this._mouseLeaveMonitor.dispose(), this._mouseLeaveMonitor = null), this.lastMouseLeaveTime = (/* @__PURE__ */ new Date()).getTime(), this.viewController.emitMouseLeave({
      event: e,
      target: null
    });
  }
  _onMouseUp(e) {
    this.viewController.emitMouseUp({
      event: e,
      target: this._createMouseTarget(e, !0)
    });
  }
  _onMouseDown(e, t) {
    const i = this._createMouseTarget(e, !0), n = i.type === 6 || i.type === 7, o = i.type === 2 || i.type === 3 || i.type === 4, r = i.type === 3, a = this._context.configuration.options.get(
      110
      /* EditorOption.selectOnLineNumbers */
    ), l = i.type === 8 || i.type === 5, c = i.type === 9;
    let d = e.leftButton || e.middleButton;
    ze && e.leftButton && e.ctrlKey && (d = !1);
    const h = () => {
      e.preventDefault(), this.viewHelper.focusTextArea();
    };
    if (d && (n || r && a))
      h(), this._mouseDownOperation.start(i.type, e, t);
    else if (o)
      e.preventDefault();
    else if (l) {
      const u = i.detail;
      d && this.viewHelper.shouldSuppressMouseDownOnViewZone(u.viewZoneId) && (h(), this._mouseDownOperation.start(i.type, e, t), e.preventDefault());
    } else c && this.viewHelper.shouldSuppressMouseDownOnWidget(i.detail) && (h(), e.preventDefault());
    this.viewController.emitMouseDown({
      event: e,
      target: i
    });
  }
}
class Ase extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewController = t, this._viewHelper = i, this._mouseTargetFactory = n, this._createMouseTarget = o, this._getMouseColumn = r, this._mouseMoveMonitor = this._register(new ise(this._viewHelper.viewDomNode)), this._topBottomDragScrolling = this._register(new _se(this._context, this._viewHelper, this._mouseTargetFactory, (a, l, c) => this._dispatchMouse(a, l, c))), this._mouseState = new pD(), this._currentSelection = new Ue(1, 1, 1, 1), this._isActive = !1, this._lastMouseEvent = null;
  }
  dispose() {
    super.dispose();
  }
  isActive() {
    return this._isActive;
  }
  _onMouseDownThenMove(e) {
    this._lastMouseEvent = e, this._mouseState.setModifiers(e);
    const t = this._findMousePosition(e, !1);
    t && (this._mouseState.isDragAndDrop ? this._viewController.emitMouseDrag({
      event: e,
      target: t
    }) : t.type === 13 && (t.outsidePosition === "above" || t.outsidePosition === "below") ? this._topBottomDragScrolling.start(t, e) : (this._topBottomDragScrolling.stop(), this._dispatchMouse(
      t,
      !0,
      1
      /* NavigationCommandRevealType.Minimal */
    )));
  }
  start(e, t, i) {
    this._lastMouseEvent = t, this._mouseState.setStartedOnLineNumbers(
      e === 3
      /* MouseTargetType.GUTTER_LINE_NUMBERS */
    ), this._mouseState.setStartButtons(t), this._mouseState.setModifiers(t);
    const n = this._findMousePosition(t, !0);
    if (!n || !n.position)
      return;
    this._mouseState.trySetCount(t.detail, n.position), t.detail = this._mouseState.count;
    const o = this._context.configuration.options;
    if (!o.get(
      92
      /* EditorOption.readOnly */
    ) && o.get(
      35
      /* EditorOption.dragAndDrop */
    ) && !o.get(
      22
      /* EditorOption.columnSelection */
    ) && !this._mouseState.altKey && t.detail < 2 && !this._isActive && !this._currentSelection.isEmpty() && n.type === 6 && n.position && this._currentSelection.containsPosition(n.position)) {
      this._mouseState.isDragAndDrop = !0, this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), (r) => {
        const a = this._findMousePosition(this._lastMouseEvent, !1);
        cl(r) ? this._viewController.emitMouseDropCanceled() : this._viewController.emitMouseDrop({
          event: this._lastMouseEvent,
          target: a ? this._createMouseTarget(this._lastMouseEvent, !0) : null
          // Ignoring because position is unknown, e.g., Content View Zone
        }), this._stop();
      });
      return;
    }
    this._mouseState.isDragAndDrop = !1, this._dispatchMouse(
      n,
      t.shiftKey,
      1
      /* NavigationCommandRevealType.Minimal */
    ), this._isActive || (this._isActive = !0, this._mouseMoveMonitor.startMonitoring(this._viewHelper.viewLinesDomNode, i, t.buttons, (r) => this._onMouseDownThenMove(r), () => this._stop()));
  }
  _stop() {
    this._isActive = !1, this._topBottomDragScrolling.stop();
  }
  onHeightChanged() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onPointerUp() {
    this._mouseMoveMonitor.stopMonitoring();
  }
  onCursorStateChanged(e) {
    this._currentSelection = e.selections[0];
  }
  _getPositionOutsideEditor(e) {
    const t = e.editorPos, i = this._context.viewModel, n = this._context.viewLayout, o = this._getMouseColumn(e);
    if (e.posy < t.y) {
      const a = t.y - e.posy, l = Math.max(n.getCurrentScrollTop() - a, 0), c = lm.getZoneAtCoord(this._context, l);
      if (c) {
        const h = this._helpPositionJumpOverViewZone(c);
        if (h)
          return _n.createOutsideEditor(o, h, "above", a);
      }
      const d = n.getLineNumberAtVerticalOffset(l);
      return _n.createOutsideEditor(o, new F(d, 1), "above", a);
    }
    if (e.posy > t.y + t.height) {
      const a = e.posy - t.y - t.height, l = n.getCurrentScrollTop() + e.relativePos.y, c = lm.getZoneAtCoord(this._context, l);
      if (c) {
        const h = this._helpPositionJumpOverViewZone(c);
        if (h)
          return _n.createOutsideEditor(o, h, "below", a);
      }
      const d = n.getLineNumberAtVerticalOffset(l);
      return _n.createOutsideEditor(o, new F(d, i.getLineMaxColumn(d)), "below", a);
    }
    const r = n.getLineNumberAtVerticalOffset(n.getCurrentScrollTop() + e.relativePos.y);
    if (e.posx < t.x) {
      const a = t.x - e.posx;
      return _n.createOutsideEditor(o, new F(r, 1), "left", a);
    }
    if (e.posx > t.x + t.width) {
      const a = e.posx - t.x - t.width;
      return _n.createOutsideEditor(o, new F(r, i.getLineMaxColumn(r)), "right", a);
    }
    return null;
  }
  _findMousePosition(e, t) {
    const i = this._getPositionOutsideEditor(e);
    if (i)
      return i;
    const n = this._createMouseTarget(e, t);
    if (!n.position)
      return null;
    if (n.type === 8 || n.type === 5) {
      const r = this._helpPositionJumpOverViewZone(n.detail);
      if (r)
        return _n.createViewZone(n.type, n.element, n.mouseColumn, r, n.detail);
    }
    return n;
  }
  _helpPositionJumpOverViewZone(e) {
    const t = new F(this._currentSelection.selectionStartLineNumber, this._currentSelection.selectionStartColumn), i = e.positionBefore, n = e.positionAfter;
    return i && n ? i.isBefore(t) ? i : n : null;
  }
  _dispatchMouse(e, t, i) {
    e.position && this._viewController.dispatchMouse({
      position: e.position,
      mouseColumn: e.mouseColumn,
      startedOnLineNumbers: this._mouseState.startedOnLineNumbers,
      revealType: i,
      inSelectionMode: t,
      mouseDownCount: this._mouseState.count,
      altKey: this._mouseState.altKey,
      ctrlKey: this._mouseState.ctrlKey,
      metaKey: this._mouseState.metaKey,
      shiftKey: this._mouseState.shiftKey,
      leftButton: this._mouseState.leftButton,
      middleButton: this._mouseState.middleButton,
      onInjectedText: e.type === 6 && e.detail.injectedText !== null
    });
  }
}
class _se extends V {
  constructor(e, t, i, n) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._operation = null;
  }
  dispose() {
    super.dispose(), this.stop();
  }
  start(e, t) {
    this._operation ? this._operation.setPosition(e, t) : this._operation = new bse(this._context, this._viewHelper, this._mouseTargetFactory, this._dispatchMouse, e, t);
  }
  stop() {
    this._operation && (this._operation.dispose(), this._operation = null);
  }
}
class bse extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._context = e, this._viewHelper = t, this._mouseTargetFactory = i, this._dispatchMouse = n, this._position = o, this._mouseEvent = r, this._lastTime = Date.now(), this._animationFrameDisposable = ys(fe(r.browserEvent), () => this._execute());
  }
  dispose() {
    this._animationFrameDisposable.dispose(), super.dispose();
  }
  setPosition(e, t) {
    this._position = e, this._mouseEvent = t;
  }
  /**
   * update internal state and return elapsed ms since last time
   */
  _tick() {
    const e = Date.now(), t = e - this._lastTime;
    return this._lastTime = e, t;
  }
  /**
   * get the number of lines per second to auto-scroll
   */
  _getScrollSpeed() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ).height / e, i = this._position.outsideDistance / e;
    return i <= 1.5 ? Math.max(30, t * (1 + i)) : i <= 3 ? Math.max(60, t * (2 + i)) : Math.max(200, t * (7 + i));
  }
  _execute() {
    const e = this._context.configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), t = this._getScrollSpeed(), i = this._tick(), n = t * (i / 1e3) * e, o = this._position.outsidePosition === "above" ? -n : n;
    this._context.viewModel.viewLayout.deltaScrollNow(0, o), this._viewHelper.renderNow();
    const r = this._context.viewLayout.getLinesViewportData(), a = this._position.outsidePosition === "above" ? r.startLineNumber : r.endLineNumber;
    let l;
    {
      const c = DT(this._viewHelper.viewDomNode), d = this._context.configuration.options.get(
        146
        /* EditorOption.layoutInfo */
      ).horizontalScrollbarHeight, h = new vS(this._mouseEvent.pos.x, c.y + c.height - d - 0.1), u = IT(this._viewHelper.viewDomNode, c, h);
      l = this._mouseTargetFactory.createMouseTarget(this._viewHelper.getLastRenderData(), c, h, u, null);
    }
    (!l.position || l.position.lineNumber !== a) && (this._position.outsidePosition === "above" ? l = _n.createOutsideEditor(this._position.mouseColumn, new F(a, 1), "above", this._position.outsideDistance) : l = _n.createOutsideEditor(this._position.mouseColumn, new F(a, this._context.viewModel.getLineMaxColumn(a)), "below", this._position.outsideDistance)), this._dispatchMouse(
      l,
      !0,
      2
      /* NavigationCommandRevealType.None */
    ), this._animationFrameDisposable = ys(fe(l.element), () => this._execute());
  }
}
const G1 = class G1 {
  // ms
  get altKey() {
    return this._altKey;
  }
  get ctrlKey() {
    return this._ctrlKey;
  }
  get metaKey() {
    return this._metaKey;
  }
  get shiftKey() {
    return this._shiftKey;
  }
  get leftButton() {
    return this._leftButton;
  }
  get middleButton() {
    return this._middleButton;
  }
  get startedOnLineNumbers() {
    return this._startedOnLineNumbers;
  }
  constructor() {
    this._altKey = !1, this._ctrlKey = !1, this._metaKey = !1, this._shiftKey = !1, this._leftButton = !1, this._middleButton = !1, this._startedOnLineNumbers = !1, this._lastMouseDownPosition = null, this._lastMouseDownPositionEqualCount = 0, this._lastMouseDownCount = 0, this._lastSetMouseDownCountTime = 0, this.isDragAndDrop = !1;
  }
  get count() {
    return this._lastMouseDownCount;
  }
  setModifiers(e) {
    this._altKey = e.altKey, this._ctrlKey = e.ctrlKey, this._metaKey = e.metaKey, this._shiftKey = e.shiftKey;
  }
  setStartButtons(e) {
    this._leftButton = e.leftButton, this._middleButton = e.middleButton;
  }
  setStartedOnLineNumbers(e) {
    this._startedOnLineNumbers = e;
  }
  trySetCount(e, t) {
    const i = (/* @__PURE__ */ new Date()).getTime();
    i - this._lastSetMouseDownCountTime > G1.CLEAR_MOUSE_DOWN_COUNT_TIME && (e = 1), this._lastSetMouseDownCountTime = i, e > this._lastMouseDownCount + 1 && (e = this._lastMouseDownCount + 1), this._lastMouseDownPosition && this._lastMouseDownPosition.equals(t) ? this._lastMouseDownPositionEqualCount++ : this._lastMouseDownPositionEqualCount = 1, this._lastMouseDownPosition = t, this._lastMouseDownCount = Math.min(e, this._lastMouseDownPositionEqualCount);
  }
};
G1.CLEAR_MOUSE_DOWN_COUNT_TIME = 400;
let pD = G1;
const rf = class rf {
  constructor(e, t, i, n, o) {
    this.value = e, this.selectionStart = t, this.selectionEnd = i, this.selection = n, this.newlineCountBeforeSelection = o;
  }
  toString() {
    return `[ <${this.value}>, selectionStart: ${this.selectionStart}, selectionEnd: ${this.selectionEnd}]`;
  }
  static readFromTextArea(e, t) {
    const i = e.getValue(), n = e.getSelectionStart(), o = e.getSelectionEnd();
    let r;
    if (t) {
      const a = i.substring(0, n), l = t.value.substring(0, t.selectionStart);
      a === l && (r = t.newlineCountBeforeSelection);
    }
    return new rf(i, n, o, null, r);
  }
  collapseSelection() {
    return this.selectionStart === this.value.length ? this : new rf(this.value, this.value.length, this.value.length, null, void 0);
  }
  writeToTextArea(e, t, i) {
    t.setValue(e, this.value), i && t.setSelectionRange(e, this.selectionStart, this.selectionEnd);
  }
  deduceEditorPosition(e) {
    if (e <= this.selectionStart) {
      const n = this.value.substring(e, this.selectionStart);
      return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, n, -1);
    }
    if (e >= this.selectionEnd) {
      const n = this.value.substring(this.selectionEnd, e);
      return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, n, 1);
    }
    const t = this.value.substring(this.selectionStart, e);
    if (t.indexOf("…") === -1)
      return this._finishDeduceEditorPosition(this.selection?.getStartPosition() ?? null, t, 1);
    const i = this.value.substring(e, this.selectionEnd);
    return this._finishDeduceEditorPosition(this.selection?.getEndPosition() ?? null, i, -1);
  }
  _finishDeduceEditorPosition(e, t, i) {
    let n = 0, o = -1;
    for (; (o = t.indexOf(`
`, o + 1)) !== -1; )
      n++;
    return [e, i * t.length, n];
  }
  static deduceInput(e, t, i) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    const n = Math.min(kA(e.value, t.value), e.selectionStart, t.selectionStart), o = Math.min(NE(e.value, t.value), e.value.length - e.selectionEnd, t.value.length - t.selectionEnd);
    e.value.substring(n, e.value.length - o);
    const r = t.value.substring(n, t.value.length - o), a = e.selectionStart - n, l = e.selectionEnd - n, c = t.selectionStart - n, d = t.selectionEnd - n;
    if (c === d) {
      const u = e.selectionStart - n;
      return {
        text: r,
        replacePrevCharCnt: u,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    }
    const h = l - a;
    return {
      text: r,
      replacePrevCharCnt: h,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
  }
  static deduceAndroidCompositionInput(e, t) {
    if (!e)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: 0
      };
    if (e.value === t.value)
      return {
        text: "",
        replacePrevCharCnt: 0,
        replaceNextCharCnt: 0,
        positionDelta: t.selectionEnd - e.selectionEnd
      };
    const i = Math.min(kA(e.value, t.value), e.selectionEnd), n = Math.min(NE(e.value, t.value), e.value.length - e.selectionEnd), o = e.value.substring(i, e.value.length - n), r = t.value.substring(i, t.value.length - n);
    e.selectionStart - i;
    const a = e.selectionEnd - i;
    t.selectionStart - i;
    const l = t.selectionEnd - i;
    return {
      text: r,
      replacePrevCharCnt: a,
      replaceNextCharCnt: o.length - a,
      positionDelta: l - r.length
    };
  }
};
rf.EMPTY = new rf("", 0, 0, null, void 0);
let bn = rf;
class Ug {
  static _getPageOfLine(e, t) {
    return Math.floor((e - 1) / t);
  }
  static _getRangeForPage(e, t) {
    const i = e * t, n = i + 1, o = i + t;
    return new E(n, 1, o + 1, 1);
  }
  static fromEditorSelection(e, t, i, n) {
    const r = Ug._getPageOfLine(t.startLineNumber, i), a = Ug._getRangeForPage(r, i), l = Ug._getPageOfLine(t.endLineNumber, i), c = Ug._getRangeForPage(l, i);
    let d = a.intersectRanges(new E(1, 1, t.startLineNumber, t.startColumn));
    if (n && e.getValueLengthInRange(
      d,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const _ = e.modifyPosition(d.getEndPosition(), -500);
      d = E.fromPositions(_, d.getEndPosition());
    }
    const h = e.getValueInRange(
      d,
      1
      /* EndOfLinePreference.LF */
    ), u = e.getLineCount(), g = e.getLineMaxColumn(u);
    let m = c.intersectRanges(new E(t.endLineNumber, t.endColumn, u, g));
    if (n && e.getValueLengthInRange(
      m,
      1
      /* EndOfLinePreference.LF */
    ) > 500) {
      const _ = e.modifyPosition(m.getStartPosition(), 500);
      m = E.fromPositions(m.getStartPosition(), _);
    }
    const p = e.getValueInRange(
      m,
      1
      /* EndOfLinePreference.LF */
    );
    let A;
    if (r === l || r + 1 === l)
      A = e.getValueInRange(
        t,
        1
        /* EndOfLinePreference.LF */
      );
    else {
      const _ = a.intersectRanges(t), b = c.intersectRanges(t);
      A = e.getValueInRange(
        _,
        1
        /* EndOfLinePreference.LF */
      ) + "…" + e.getValueInRange(
        b,
        1
        /* EndOfLinePreference.LF */
      );
    }
    return n && A.length > 2 * 500 && (A = A.substring(0, 500) + "…" + A.substring(A.length - 500, A.length)), new bn(h + A + p, h.length, h.length + A.length, t, d.endLineNumber - d.startLineNumber);
  }
}
var wse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, LO = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, bv;
(function(s) {
  s.Tap = "-monaco-textarea-synthetic-tap";
})(bv || (bv = {}));
const j1 = class j1 {
  constructor() {
    this._lastState = null;
  }
  set(e, t) {
    this._lastState = { lastCopiedValue: e, data: t };
  }
  get(e) {
    return this._lastState && this._lastState.lastCopiedValue === e ? this._lastState.data : (this._lastState = null, null);
  }
};
j1.INSTANCE = new j1();
let wv = j1;
class Cse {
  constructor() {
    this._lastTypeTextLength = 0;
  }
  handleCompositionUpdate(e) {
    e = e || "";
    const t = {
      text: e,
      replacePrevCharCnt: this._lastTypeTextLength,
      replaceNextCharCnt: 0,
      positionDelta: 0
    };
    return this._lastTypeTextLength = e.length, t;
  }
}
let AD = class extends V {
  get textAreaState() {
    return this._textAreaState;
  }
  constructor(e, t, i, n, o, r) {
    super(), this._host = e, this._textArea = t, this._OS = i, this._browser = n, this._accessibilityService = o, this._logService = r, this._onFocus = this._register(new B()), this.onFocus = this._onFocus.event, this._onBlur = this._register(new B()), this.onBlur = this._onBlur.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onKeyUp = this._register(new B()), this.onKeyUp = this._onKeyUp.event, this._onCut = this._register(new B()), this.onCut = this._onCut.event, this._onPaste = this._register(new B()), this.onPaste = this._onPaste.event, this._onType = this._register(new B()), this.onType = this._onType.event, this._onCompositionStart = this._register(new B()), this.onCompositionStart = this._onCompositionStart.event, this._onCompositionUpdate = this._register(new B()), this.onCompositionUpdate = this._onCompositionUpdate.event, this._onCompositionEnd = this._register(new B()), this.onCompositionEnd = this._onCompositionEnd.event, this._onSelectionChangeRequest = this._register(new B()), this.onSelectionChangeRequest = this._onSelectionChangeRequest.event, this._asyncFocusGainWriteScreenReaderContent = this._register(new On()), this._asyncTriggerCut = this._register(new zt(() => this._onCut.fire(), 0)), this._textAreaState = bn.EMPTY, this._selectionChangeListener = null, this._accessibilityService.isScreenReaderOptimized() && this.writeNativeTextAreaContent("ctor"), this._register(te.runAndSubscribe(this._accessibilityService.onDidChangeScreenReaderOptimized, () => {
      this._accessibilityService.isScreenReaderOptimized() && !this._asyncFocusGainWriteScreenReaderContent.value ? this._asyncFocusGainWriteScreenReaderContent.value = this._register(new zt(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)) : this._asyncFocusGainWriteScreenReaderContent.clear();
    })), this._hasFocus = !1, this._currentComposition = null;
    let a = null;
    this._register(this._textArea.onKeyDown((l) => {
      const c = new Mt(l);
      (c.keyCode === 114 || this._currentComposition && c.keyCode === 1) && c.stopPropagation(), c.equals(
        9
        /* KeyCode.Escape */
      ) && c.preventDefault(), a = c, this._onKeyDown.fire(c);
    })), this._register(this._textArea.onKeyUp((l) => {
      const c = new Mt(l);
      this._onKeyUp.fire(c);
    })), this._register(this._textArea.onCompositionStart((l) => {
      const c = new Cse();
      if (this._currentComposition) {
        this._currentComposition = c;
        return;
      }
      if (this._currentComposition = c, this._OS === 2 && a && a.equals(
        114
        /* KeyCode.KEY_IN_COMPOSITION */
      ) && this._textAreaState.selectionStart === this._textAreaState.selectionEnd && this._textAreaState.selectionStart > 0 && this._textAreaState.value.substr(this._textAreaState.selectionStart - 1, 1) === l.data && (a.code === "ArrowRight" || a.code === "ArrowLeft")) {
        c.handleCompositionUpdate("x"), this._onCompositionStart.fire({ data: l.data });
        return;
      }
      if (this._browser.isAndroid) {
        this._onCompositionStart.fire({ data: l.data });
        return;
      }
      this._onCompositionStart.fire({ data: l.data });
    })), this._register(this._textArea.onCompositionUpdate((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._browser.isAndroid) {
        const h = bn.readFromTextArea(this._textArea, this._textAreaState), u = bn.deduceAndroidCompositionInput(this._textAreaState, h);
        this._textAreaState = h, this._onType.fire(u), this._onCompositionUpdate.fire(l);
        return;
      }
      const d = c.handleCompositionUpdate(l.data);
      this._textAreaState = bn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(d), this._onCompositionUpdate.fire(l);
    })), this._register(this._textArea.onCompositionEnd((l) => {
      const c = this._currentComposition;
      if (!c)
        return;
      if (this._currentComposition = null, this._browser.isAndroid) {
        const h = bn.readFromTextArea(this._textArea, this._textAreaState), u = bn.deduceAndroidCompositionInput(this._textAreaState, h);
        this._textAreaState = h, this._onType.fire(u), this._onCompositionEnd.fire();
        return;
      }
      const d = c.handleCompositionUpdate(l.data);
      this._textAreaState = bn.readFromTextArea(this._textArea, this._textAreaState), this._onType.fire(d), this._onCompositionEnd.fire();
    })), this._register(this._textArea.onInput((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received input event"), this._currentComposition)
        return;
      const c = bn.readFromTextArea(this._textArea, this._textAreaState), d = bn.deduceInput(
        this._textAreaState,
        c,
        /*couldBeEmojiInput*/
        this._OS === 2
        /* OperatingSystem.Macintosh */
      );
      d.replacePrevCharCnt === 0 && d.text.length === 1 && (Si(d.text.charCodeAt(0)) || d.text.charCodeAt(0) === 127) || (this._textAreaState = c, (d.text !== "" || d.replacePrevCharCnt !== 0 || d.replaceNextCharCnt !== 0 || d.positionDelta !== 0) && this._onType.fire(d));
    })), this._register(this._textArea.onCut((l) => {
      this._textArea.setIgnoreSelectionChangeTime("received cut event"), this._ensureClipboardGetsEditorSelection(l), this._asyncTriggerCut.schedule();
    })), this._register(this._textArea.onCopy((l) => {
      this._ensureClipboardGetsEditorSelection(l);
    })), this._register(this._textArea.onPaste((l) => {
      if (this._textArea.setIgnoreSelectionChangeTime("received paste event"), l.preventDefault(), !l.clipboardData)
        return;
      let [c, d] = kO.getTextData(l.clipboardData);
      c && (d = d || wv.INSTANCE.get(c), this._onPaste.fire({
        text: c,
        metadata: d
      }));
    })), this._register(this._textArea.onFocus(() => {
      const l = this._hasFocus;
      this._setHasFocus(!0), this._accessibilityService.isScreenReaderOptimized() && this._browser.isSafari && !l && this._hasFocus && (this._asyncFocusGainWriteScreenReaderContent.value || (this._asyncFocusGainWriteScreenReaderContent.value = new zt(() => this.writeNativeTextAreaContent("asyncFocusGain"), 0)), this._asyncFocusGainWriteScreenReaderContent.value.schedule());
    })), this._register(this._textArea.onBlur(() => {
      this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("blurWithoutCompositionEnd"), this._onCompositionEnd.fire()), this._setHasFocus(!1);
    })), this._register(this._textArea.onSyntheticTap(() => {
      this._browser.isAndroid && this._currentComposition && (this._currentComposition = null, this.writeNativeTextAreaContent("tapWithoutCompositionEnd"), this._onCompositionEnd.fire());
    }));
  }
  _installSelectionChangeListener() {
    let e = 0;
    return U(this._textArea.ownerDocument, "selectionchange", (t) => {
      if (Nc.onSelectionChange(), !this._hasFocus || this._currentComposition || !this._browser.isChrome)
        return;
      const i = Date.now(), n = i - e;
      if (e = i, n < 5)
        return;
      const o = i - this._textArea.getIgnoreSelectionChangeTime();
      if (this._textArea.resetSelectionChangeTime(), o < 100 || !this._textAreaState.selection)
        return;
      const r = this._textArea.getValue();
      if (this._textAreaState.value !== r)
        return;
      const a = this._textArea.getSelectionStart(), l = this._textArea.getSelectionEnd();
      if (this._textAreaState.selectionStart === a && this._textAreaState.selectionEnd === l)
        return;
      const c = this._textAreaState.deduceEditorPosition(a), d = this._host.deduceModelPosition(c[0], c[1], c[2]), h = this._textAreaState.deduceEditorPosition(l), u = this._host.deduceModelPosition(h[0], h[1], h[2]), g = new Ue(d.lineNumber, d.column, u.lineNumber, u.column);
      this._onSelectionChangeRequest.fire(g);
    });
  }
  dispose() {
    super.dispose(), this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null);
  }
  focusTextArea() {
    this._setHasFocus(!0), this.refreshFocusState();
  }
  isFocused() {
    return this._hasFocus;
  }
  refreshFocusState() {
    this._setHasFocus(this._textArea.hasFocus());
  }
  _setHasFocus(e) {
    this._hasFocus !== e && (this._hasFocus = e, this._selectionChangeListener && (this._selectionChangeListener.dispose(), this._selectionChangeListener = null), this._hasFocus && (this._selectionChangeListener = this._installSelectionChangeListener()), this._hasFocus && this.writeNativeTextAreaContent("focusgain"), this._hasFocus ? this._onFocus.fire() : this._onBlur.fire());
  }
  _setAndWriteTextAreaState(e, t) {
    this._hasFocus || (t = t.collapseSelection()), t.writeToTextArea(e, this._textArea, this._hasFocus), this._textAreaState = t;
  }
  writeNativeTextAreaContent(e) {
    !this._accessibilityService.isScreenReaderOptimized() && e === "render" || this._currentComposition || (this._logService.trace(`writeTextAreaState(reason: ${e})`), this._setAndWriteTextAreaState(e, this._host.getScreenReaderContent()));
  }
  _ensureClipboardGetsEditorSelection(e) {
    const t = this._host.getDataToCopy(), i = {
      version: 1,
      isFromEmptySelection: t.isFromEmptySelection,
      multicursorText: t.multicursorText,
      mode: t.mode
    };
    wv.INSTANCE.set(
      // When writing "LINE\r\n" to the clipboard and then pasting,
      // Firefox pastes "LINE\n", so let's work around this quirk
      this._browser.isFirefox ? t.text.replace(/\r\n/g, `
`) : t.text,
      i
    ), e.preventDefault(), e.clipboardData && kO.setTextData(e.clipboardData, t.text, t.html, i);
  }
};
AD = wse([
  LO(4, Lo),
  LO(5, Es)
], AD);
const kO = {
  getTextData(s) {
    const e = s.getData(fl.text);
    let t = null;
    const i = s.getData("vscode-editor-data");
    if (typeof i == "string")
      try {
        t = JSON.parse(i), t.version !== 1 && (t = null);
      } catch {
      }
    return e.length === 0 && t === null && s.files.length > 0 ? [Array.prototype.slice.call(s.files, 0).map((o) => o.name).join(`
`), null] : [e, t];
  },
  setTextData(s, e, t, i) {
    s.setData(fl.text, e), typeof t == "string" && s.setData("text/html", t), s.setData("vscode-editor-data", JSON.stringify(i));
  }
};
class vse extends V {
  get ownerDocument() {
    return this._actual.ownerDocument;
  }
  constructor(e) {
    super(), this._actual = e, this.onKeyDown = this._register(new Ke(this._actual, "keydown")).event, this.onKeyUp = this._register(new Ke(this._actual, "keyup")).event, this.onCompositionStart = this._register(new Ke(this._actual, "compositionstart")).event, this.onCompositionUpdate = this._register(new Ke(this._actual, "compositionupdate")).event, this.onCompositionEnd = this._register(new Ke(this._actual, "compositionend")).event, this.onBeforeInput = this._register(new Ke(this._actual, "beforeinput")).event, this.onInput = this._register(new Ke(this._actual, "input")).event, this.onCut = this._register(new Ke(this._actual, "cut")).event, this.onCopy = this._register(new Ke(this._actual, "copy")).event, this.onPaste = this._register(new Ke(this._actual, "paste")).event, this.onFocus = this._register(new Ke(this._actual, "focus")).event, this.onBlur = this._register(new Ke(this._actual, "blur")).event, this._onSyntheticTap = this._register(new B()), this.onSyntheticTap = this._onSyntheticTap.event, this._ignoreSelectionChangeTime = 0, this._register(this.onKeyDown(() => Nc.onKeyDown())), this._register(this.onBeforeInput(() => Nc.onBeforeInput())), this._register(this.onInput(() => Nc.onInput())), this._register(this.onKeyUp(() => Nc.onKeyUp())), this._register(U(this._actual, bv.Tap, () => this._onSyntheticTap.fire()));
  }
  hasFocus() {
    const e = pu(this._actual);
    return e ? e.activeElement === this._actual : this._actual.isConnected ? ln() === this._actual : !1;
  }
  setIgnoreSelectionChangeTime(e) {
    this._ignoreSelectionChangeTime = Date.now();
  }
  getIgnoreSelectionChangeTime() {
    return this._ignoreSelectionChangeTime;
  }
  resetSelectionChangeTime() {
    this._ignoreSelectionChangeTime = 0;
  }
  getValue() {
    return this._actual.value;
  }
  setValue(e, t) {
    const i = this._actual;
    i.value !== t && (this.setIgnoreSelectionChangeTime("setValue"), i.value = t);
  }
  getSelectionStart() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionEnd : this._actual.selectionStart;
  }
  getSelectionEnd() {
    return this._actual.selectionDirection === "backward" ? this._actual.selectionStart : this._actual.selectionEnd;
  }
  setSelectionRange(e, t, i) {
    const n = this._actual;
    let o = null;
    const r = pu(n);
    r ? o = r.activeElement : o = ln();
    const a = fe(o), l = o === n, c = n.selectionStart, d = n.selectionEnd;
    if (l && c === t && d === i) {
      Ko && a.parent !== a && n.focus();
      return;
    }
    if (l) {
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.setSelectionRange(t, i), Ko && a.parent !== a && n.focus();
      return;
    }
    try {
      const h = Y6(n);
      this.setIgnoreSelectionChangeTime("setSelectionRange"), n.focus(), n.setSelectionRange(t, i), K6(n, h);
    } catch {
    }
  }
}
class Sse extends MT {
  constructor(e, t, i) {
    super(e, t, i), this._register(xn.addTarget(this.viewHelper.linesContentDomNode)), this._register(U(this.viewHelper.linesContentDomNode, Et.Tap, (o) => this.onTap(o))), this._register(U(this.viewHelper.linesContentDomNode, Et.Change, (o) => this.onChange(o))), this._register(U(this.viewHelper.linesContentDomNode, Et.Contextmenu, (o) => this._onContextMenu(new hd(o, !1, this.viewHelper.viewDomNode), !1))), this._lastPointerType = "mouse", this._register(U(this.viewHelper.linesContentDomNode, "pointerdown", (o) => {
      const r = o.pointerType;
      if (r === "mouse") {
        this._lastPointerType = "mouse";
        return;
      } else r === "touch" ? this._lastPointerType = "touch" : this._lastPointerType = "pen";
    }));
    const n = new tse(this.viewHelper.viewDomNode);
    this._register(n.onPointerMove(this.viewHelper.viewDomNode, (o) => this._onMouseMove(o))), this._register(n.onPointerUp(this.viewHelper.viewDomNode, (o) => this._onMouseUp(o))), this._register(n.onPointerLeave(this.viewHelper.viewDomNode, (o) => this._onMouseLeave(o))), this._register(n.onPointerDown(this.viewHelper.viewDomNode, (o, r) => this._onMouseDown(o, r)));
  }
  onTap(e) {
    !e.initialTarget || !this.viewHelper.linesContentDomNode.contains(e.initialTarget) || (e.preventDefault(), this.viewHelper.focusTextArea(), this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !1
    ));
  }
  onChange(e) {
    this._lastPointerType === "touch" && this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY), this._lastPointerType === "pen" && this._dispatchGesture(
      e,
      /*inSelectionMode*/
      !0
    );
  }
  _dispatchGesture(e, t) {
    const i = this._createMouseTarget(new hd(e, !1, this.viewHelper.viewDomNode), !1);
    i.position && this.viewController.dispatchMouse({
      position: i.position,
      mouseColumn: i.position.column,
      startedOnLineNumbers: !1,
      revealType: 1,
      mouseDownCount: e.tapCount,
      inSelectionMode: t,
      altKey: !1,
      ctrlKey: !1,
      metaKey: !1,
      shiftKey: !1,
      leftButton: !1,
      middleButton: !1,
      onInjectedText: i.type === 6 && i.detail.injectedText !== null
    });
  }
  _onMouseDown(e, t) {
    e.browserEvent.pointerType !== "touch" && super._onMouseDown(e, t);
  }
}
class yse extends MT {
  constructor(e, t, i) {
    super(e, t, i), this._register(xn.addTarget(this.viewHelper.linesContentDomNode)), this._register(U(this.viewHelper.linesContentDomNode, Et.Tap, (n) => this.onTap(n))), this._register(U(this.viewHelper.linesContentDomNode, Et.Change, (n) => this.onChange(n))), this._register(U(this.viewHelper.linesContentDomNode, Et.Contextmenu, (n) => this._onContextMenu(new hd(n, !1, this.viewHelper.viewDomNode), !1)));
  }
  onTap(e) {
    e.preventDefault(), this.viewHelper.focusTextArea();
    const t = this._createMouseTarget(new hd(e, !1, this.viewHelper.viewDomNode), !1);
    if (t.position) {
      const i = document.createEvent("CustomEvent");
      i.initEvent(bv.Tap, !1, !0), this.viewHelper.dispatchTextAreaEvent(i), this.viewController.moveTo(
        t.position,
        1
        /* NavigationCommandRevealType.Minimal */
      );
    }
  }
  onChange(e) {
    this._context.viewModel.viewLayout.deltaScrollNow(-e.translationX, -e.translationY);
  }
}
class xse extends V {
  constructor(e, t, i) {
    super(), (Ea || z9 && K4) && UM.pointerEvents ? this.handler = this._register(new Sse(e, t, i)) : vt.TouchEvent ? this.handler = this._register(new yse(e, t, i)) : this.handler = this._register(new MT(e, t, i));
  }
  getTargetAtClientPoint(e, t) {
    return this.handler.getTargetAtClientPoint(e, t);
  }
}
class Ku extends Y_ {
}
const Y1 = class Y1 extends Ku {
  constructor(e) {
    super(), this._context = e, this._readConfig(), this._lastCursorModelPosition = new F(1, 1), this._renderResult = null, this._activeLineNumber = 1, this._context.addEventHandler(this);
  }
  _readConfig() {
    const e = this._context.configuration.options;
    this._lineHeight = e.get(
      67
      /* EditorOption.lineHeight */
    );
    const t = e.get(
      68
      /* EditorOption.lineNumbers */
    );
    this._renderLineNumbers = t.renderType, this._renderCustomLineNumbers = t.renderFn, this._renderFinalNewline = e.get(
      96
      /* EditorOption.renderFinalNewline */
    );
    const i = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineNumbersLeft = i.lineNumbersLeft, this._lineNumbersWidth = i.lineNumbersWidth;
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this._readConfig(), !0;
  }
  onCursorStateChanged(e) {
    const t = e.selections[0].getPosition();
    this._lastCursorModelPosition = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(t);
    let i = !1;
    return this._activeLineNumber !== t.lineNumber && (this._activeLineNumber = t.lineNumber, i = !0), (this._renderLineNumbers === 2 || this._renderLineNumbers === 3) && (i = !0), i;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return e.affectsLineNumber;
  }
  // --- end event handlers
  _getLineRenderLineNumber(e) {
    const t = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(e, 1));
    if (t.column !== 1)
      return "";
    const i = t.lineNumber;
    if (this._renderCustomLineNumbers)
      return this._renderCustomLineNumbers(i);
    if (this._renderLineNumbers === 2) {
      const n = Math.abs(this._lastCursorModelPosition.lineNumber - i);
      return n === 0 ? '<span class="relative-current-line-number">' + i + "</span>" : String(n);
    }
    if (this._renderLineNumbers === 3) {
      if (this._lastCursorModelPosition.lineNumber === i || i % 10 === 0)
        return String(i);
      const n = this._context.viewModel.getLineCount();
      return i === n ? String(i) : "";
    }
    return String(i);
  }
  prepareRender(e) {
    if (this._renderLineNumbers === 0) {
      this._renderResult = null;
      return;
    }
    const t = Fn ? this._lineHeight % 2 === 0 ? " lh-even" : " lh-odd" : "", i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = this._context.viewModel.getDecorationsInViewport(e.visibleRange).filter((c) => !!c.options.lineNumberClassName);
    o.sort((c, d) => E.compareRangesUsingEnds(c.range, d.range));
    let r = 0;
    const a = this._context.viewModel.getLineCount(), l = [];
    for (let c = i; c <= n; c++) {
      const d = c - i;
      let h = this._getLineRenderLineNumber(c), u = "";
      for (; r < o.length && o[r].range.endLineNumber < c; )
        r++;
      for (let g = r; g < o.length; g++) {
        const { range: m, options: p } = o[g];
        m.startLineNumber <= c && (u += " " + p.lineNumberClassName);
      }
      if (!h && !u) {
        l[d] = "";
        continue;
      }
      c === a && this._context.viewModel.getLineLength(c) === 0 && (this._renderFinalNewline === "off" && (h = ""), this._renderFinalNewline === "dimmed" && (u += " dimmed-line-number")), c === this._activeLineNumber && (u += " active-line-number"), l[d] = `<div class="${Y1.CLASS_NAME}${t}${u}" style="left:${this._lineNumbersLeft}px;width:${this._lineNumbersWidth}px;">${h}</div>`;
    }
    this._renderResult = l;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
Y1.CLASS_NAME = "line-numbers";
let Cv = Y1;
rr((s, e) => {
  const t = s.getColor(cX), i = s.getColor(SX);
  i ? e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${i}; }`) : t && e.addRule(`.monaco-editor .line-numbers.dimmed-line-number { color: ${t.transparent(0.4)}; }`);
});
const af = class af extends Ds {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._domNode = rt(document.createElement("div")), this._domNode.setClassName(af.OUTER_CLASS_NAME), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._glyphMarginBackgroundDomNode = rt(document.createElement("div")), this._glyphMarginBackgroundDomNode.setClassName(af.CLASS_NAME), this._domNode.appendChild(this._glyphMarginBackgroundDomNode);
  }
  dispose() {
    super.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._contentLeft = i.contentLeft, this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollTopChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setLayerHinting(this._canUseLayerHinting), this._domNode.setContain("strict");
    const t = e.scrollTop - e.bigNumbersDelta;
    this._domNode.setTop(-t);
    const i = Math.min(e.scrollHeight, 1e6);
    this._domNode.setHeight(i), this._domNode.setWidth(this._contentLeft), this._glyphMarginBackgroundDomNode.setLeft(this._glyphMarginLeft), this._glyphMarginBackgroundDomNode.setWidth(this._glyphMarginWidth), this._glyphMarginBackgroundDomNode.setHeight(i);
  }
};
af.CLASS_NAME = "glyph-margin", af.OUTER_CLASS_NAME = "margin";
let vv = af;
const Mf = "monaco-mouse-cursor-text";
var Ese = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, DO = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class Lse {
  constructor(e, t, i, n, o) {
    this._context = e, this.modelLineNumber = t, this.distanceToModelLineStart = i, this.widthOfHiddenLineTextBefore = n, this.distanceToModelLineEnd = o, this._visibleTextAreaBrand = void 0, this.startPosition = null, this.endPosition = null, this.visibleTextareaStart = null, this.visibleTextareaEnd = null, this._previousPresentation = null;
  }
  prepareRender(e) {
    const t = new F(this.modelLineNumber, this.distanceToModelLineStart + 1), i = new F(this.modelLineNumber, this._context.viewModel.model.getLineMaxColumn(this.modelLineNumber) - this.distanceToModelLineEnd);
    this.startPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t), this.endPosition = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i), this.startPosition.lineNumber === this.endPosition.lineNumber ? (this.visibleTextareaStart = e.visibleRangeForPosition(this.startPosition), this.visibleTextareaEnd = e.visibleRangeForPosition(this.endPosition)) : (this.visibleTextareaStart = null, this.visibleTextareaEnd = null);
  }
  definePresentation(e) {
    return this._previousPresentation || (e ? this._previousPresentation = e : this._previousPresentation = {
      foreground: 1,
      italic: !1,
      bold: !1,
      underline: !1,
      strikethrough: !1
    }), this._previousPresentation;
  }
}
const Xy = Ko;
let _D = class extends Ds {
  constructor(e, t, i, n, o) {
    super(e), this._keybindingService = n, this._instantiationService = o, this._primaryCursorPosition = new F(1, 1), this._primaryCursorVisibleRange = null, this._viewController = t, this._visibleRangeProvider = i, this._scrollLeft = 0, this._scrollTop = 0;
    const r = this._context.configuration.options, a = r.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(r), this._contentLeft = a.contentLeft, this._contentWidth = a.contentWidth, this._contentHeight = a.height, this._fontInfo = r.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = r.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = r.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = r.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this._visibleTextArea = null, this._selections = [new Ue(1, 1, 1, 1)], this._modelSelections = [new Ue(1, 1, 1, 1)], this._lastRenderPosition = null, this.textArea = rt(document.createElement("textarea")), Pr.write(
      this.textArea,
      7
      /* PartFingerprint.TextArea */
    ), this.textArea.setClassName(`inputarea ${Mf}`), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: l } = this._context.viewModel.model.getOptions();
    this.textArea.domNode.style.tabSize = `${l * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("autocorrect", "off"), this.textArea.setAttribute("autocapitalize", "off"), this.textArea.setAttribute("autocomplete", "off"), this.textArea.setAttribute("spellcheck", "false"), this.textArea.setAttribute("aria-label", this._getAriaLabel(r)), this.textArea.setAttribute("aria-required", r.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(r.get(
      125
      /* EditorOption.tabIndex */
    ))), this.textArea.setAttribute("role", "textbox"), this.textArea.setAttribute("aria-roledescription", f("editor", "editor")), this.textArea.setAttribute("aria-multiline", "true"), this.textArea.setAttribute("aria-autocomplete", r.get(
      92
      /* EditorOption.readOnly */
    ) ? "none" : "both"), this._ensureReadOnlyAttribute(), this.textAreaCover = rt(document.createElement("div")), this.textAreaCover.setPosition("absolute");
    const c = {
      getLineCount: () => this._context.viewModel.getLineCount(),
      getLineMaxColumn: (u) => this._context.viewModel.getLineMaxColumn(u),
      getValueInRange: (u, g) => this._context.viewModel.getValueInRange(u, g),
      getValueLengthInRange: (u, g) => this._context.viewModel.getValueLengthInRange(u, g),
      modifyPosition: (u, g) => this._context.viewModel.modifyPosition(u, g)
    }, d = {
      getDataToCopy: () => {
        const u = this._context.viewModel.getPlainTextToCopy(this._modelSelections, this._emptySelectionClipboard, yn), g = this._context.viewModel.model.getEOL(), m = this._emptySelectionClipboard && this._modelSelections.length === 1 && this._modelSelections[0].isEmpty(), p = Array.isArray(u) ? u : null, A = Array.isArray(u) ? u.join(g) : u;
        let _, b = null;
        if (this._copyWithSyntaxHighlighting && A.length < 65536) {
          const C = this._context.viewModel.getRichTextToCopy(this._modelSelections, this._emptySelectionClipboard);
          C && (_ = C.html, b = C.mode);
        }
        return {
          isFromEmptySelection: m,
          multicursorText: p,
          text: A,
          html: _,
          mode: b
        };
      },
      getScreenReaderContent: () => {
        if (this._accessibilitySupport === 1) {
          const u = this._selections[0];
          if (ze && u.isEmpty()) {
            const m = u.getStartPosition();
            let p = this._getWordBeforePosition(m);
            if (p.length === 0 && (p = this._getCharacterBeforePosition(m)), p.length > 0)
              return new bn(p, p.length, p.length, E.fromPositions(m), 0);
          }
          if (ze && !u.isEmpty() && c.getValueLengthInRange(
            u,
            0
            /* EndOfLinePreference.TextDefined */
          ) < 500) {
            const m = c.getValueInRange(
              u,
              0
              /* EndOfLinePreference.TextDefined */
            );
            return new bn(m, 0, m.length, u, 0);
          }
          if (od && !u.isEmpty()) {
            const m = "vscode-placeholder";
            return new bn(m, 0, m.length, null, void 0);
          }
          return bn.EMPTY;
        }
        if (eR) {
          const u = this._selections[0];
          if (u.isEmpty()) {
            const g = u.getStartPosition(), [m, p] = this._getAndroidWordAtPosition(g);
            if (m.length > 0)
              return new bn(m, p, p, E.fromPositions(g), 0);
          }
          return bn.EMPTY;
        }
        return Ug.fromEditorSelection(
          c,
          this._selections[0],
          this._accessibilityPageSize,
          this._accessibilitySupport === 0
          /* AccessibilitySupport.Unknown */
        );
      },
      deduceModelPosition: (u, g, m) => this._context.viewModel.deduceModelPositionRelativeToViewPosition(u, g, m)
    }, h = this._register(new vse(this.textArea.domNode));
    this._textAreaInput = this._register(this._instantiationService.createInstance(AD, d, h, Us, {
      isAndroid: eR,
      isChrome: I_,
      isFirefox: Ko,
      isSafari: od
    })), this._register(this._textAreaInput.onKeyDown((u) => {
      this._viewController.emitKeyDown(u);
    })), this._register(this._textAreaInput.onKeyUp((u) => {
      this._viewController.emitKeyUp(u);
    })), this._register(this._textAreaInput.onPaste((u) => {
      let g = !1, m = null, p = null;
      u.metadata && (g = this._emptySelectionClipboard && !!u.metadata.isFromEmptySelection, m = typeof u.metadata.multicursorText < "u" ? u.metadata.multicursorText : null, p = u.metadata.mode), this._viewController.paste(u.text, g, m, p);
    })), this._register(this._textAreaInput.onCut(() => {
      this._viewController.cut();
    })), this._register(this._textAreaInput.onType((u) => {
      u.replacePrevCharCnt || u.replaceNextCharCnt || u.positionDelta ? this._viewController.compositionType(u.text, u.replacePrevCharCnt, u.replaceNextCharCnt, u.positionDelta) : this._viewController.type(u.text);
    })), this._register(this._textAreaInput.onSelectionChangeRequest((u) => {
      this._viewController.setSelection(u);
    })), this._register(this._textAreaInput.onCompositionStart((u) => {
      const g = this.textArea.domNode, m = this._modelSelections[0], { distanceToModelLineStart: p, widthOfHiddenTextBefore: A } = (() => {
        const b = g.value.substring(0, Math.min(g.selectionStart, g.selectionEnd)), C = b.lastIndexOf(`
`), w = b.substring(C + 1), S = w.lastIndexOf("	"), x = w.length - S - 1, y = m.getStartPosition(), D = Math.min(y.column - 1, x), I = y.column - 1 - D, Q = w.substring(0, w.length - D), { tabSize: P } = this._context.viewModel.model.getOptions(), W = kse(this.textArea.domNode.ownerDocument, Q, this._fontInfo, P);
        return { distanceToModelLineStart: I, widthOfHiddenTextBefore: W };
      })(), { distanceToModelLineEnd: _ } = (() => {
        const b = g.value.substring(Math.max(g.selectionStart, g.selectionEnd)), C = b.indexOf(`
`), w = C === -1 ? b : b.substring(0, C), S = w.indexOf("	"), x = S === -1 ? w.length : w.length - S - 1, y = m.getEndPosition(), D = Math.min(this._context.viewModel.model.getLineMaxColumn(y.lineNumber) - y.column, x);
        return { distanceToModelLineEnd: this._context.viewModel.model.getLineMaxColumn(y.lineNumber) - y.column - D };
      })();
      this._context.viewModel.revealRange(
        "keyboard",
        !0,
        E.fromPositions(this._selections[0].getStartPosition()),
        0,
        1
        /* ScrollType.Immediate */
      ), this._visibleTextArea = new Lse(this._context, m.startLineNumber, p, A, _), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render(), this.textArea.setClassName(`inputarea ${Mf} ime-input`), this._viewController.compositionStart(), this._context.viewModel.onCompositionStart();
    })), this._register(this._textAreaInput.onCompositionUpdate((u) => {
      this._visibleTextArea && (this._visibleTextArea.prepareRender(this._visibleRangeProvider), this._render());
    })), this._register(this._textAreaInput.onCompositionEnd(() => {
      this._visibleTextArea = null, this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off"), this._render(), this.textArea.setClassName(`inputarea ${Mf}`), this._viewController.compositionEnd(), this._context.viewModel.onCompositionEnd();
    })), this._register(this._textAreaInput.onFocus(() => {
      this._context.viewModel.setHasFocus(!0);
    })), this._register(this._textAreaInput.onBlur(() => {
      this._context.viewModel.setHasFocus(!1);
    })), this._register(Rp.onDidChange(() => {
      this._ensureReadOnlyAttribute();
    }));
  }
  writeScreenReaderContent(e) {
    this._textAreaInput.writeNativeTextAreaContent(e);
  }
  dispose() {
    super.dispose();
  }
  _getAndroidWordAtPosition(e) {
    const t = '`~!@#$%^&*()-=+[{]}\\|;:",.<>/?', i = this._context.viewModel.getLineContent(e.lineNumber), n = Eo(t, []);
    let o = !0, r = e.column, a = !0, l = e.column, c = 0;
    for (; c < 50 && (o || a); ) {
      if (o && r <= 1 && (o = !1), o) {
        const d = i.charCodeAt(r - 2);
        n.get(d) !== 0 ? o = !1 : r--;
      }
      if (a && l > i.length && (a = !1), a) {
        const d = i.charCodeAt(l - 1);
        n.get(d) !== 0 ? a = !1 : l++;
      }
      c++;
    }
    return [i.substring(r - 1, l - 1), e.column - r];
  }
  _getWordBeforePosition(e) {
    const t = this._context.viewModel.getLineContent(e.lineNumber), i = Eo(this._context.configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), []);
    let n = e.column, o = 0;
    for (; n > 1; ) {
      const r = t.charCodeAt(n - 2);
      if (i.get(r) !== 0 || o > 50)
        return t.substring(n - 1, e.column - 1);
      o++, n--;
    }
    return t.substring(0, e.column - 1);
  }
  _getCharacterBeforePosition(e) {
    if (e.column > 1) {
      const i = this._context.viewModel.getLineContent(e.lineNumber).charAt(e.column - 2);
      if (!Si(i.charCodeAt(0)))
        return i;
    }
    return "";
  }
  _getAriaLabel(e) {
    if (e.get(
      2
      /* EditorOption.accessibilitySupport */
    ) === 1) {
      const i = this._keybindingService.lookupKeybinding("editor.action.toggleScreenReaderAccessibilityMode")?.getAriaLabel(), n = this._keybindingService.lookupKeybinding("workbench.action.showCommands")?.getAriaLabel(), o = this._keybindingService.lookupKeybinding("workbench.action.openGlobalKeybindings")?.getAriaLabel(), r = f("accessibilityModeOff", "The editor is not accessible at this time.");
      return i ? f("accessibilityOffAriaLabel", "{0} To enable screen reader optimized mode, use {1}", r, i) : n ? f("accessibilityOffAriaLabelNoKb", "{0} To enable screen reader optimized mode, open the quick pick with {1} and run the command Toggle Screen Reader Accessibility Mode, which is currently not triggerable via keyboard.", r, n) : o ? f("accessibilityOffAriaLabelNoKbs", "{0} Please assign a keybinding for the command Toggle Screen Reader Accessibility Mode by accessing the keybindings editor with {1} and run it.", r, o) : r;
    }
    return e.get(
      4
      /* EditorOption.ariaLabel */
    );
  }
  _setAccessibilityOptions(e) {
    this._accessibilitySupport = e.get(
      2
      /* EditorOption.accessibilitySupport */
    );
    const t = e.get(
      3
      /* EditorOption.accessibilityPageSize */
    );
    this._accessibilitySupport === 2 && t === Hr.accessibilityPageSize.defaultValue ? this._accessibilityPageSize = 500 : this._accessibilityPageSize = t;
    const n = e.get(
      146
      /* EditorOption.layoutInfo */
    ).wrappingColumn;
    if (n !== -1 && this._accessibilitySupport !== 1) {
      const o = e.get(
        50
        /* EditorOption.fontInfo */
      );
      this._textAreaWrapping = !0, this._textAreaWidth = Math.round(n * o.typicalHalfwidthCharacterWidth);
    } else
      this._textAreaWrapping = !1, this._textAreaWidth = Xy ? 0 : 1;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._setAccessibilityOptions(t), this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._contentHeight = i.height, this._fontInfo = t.get(
      50
      /* EditorOption.fontInfo */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._emptySelectionClipboard = t.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this._copyWithSyntaxHighlighting = t.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.textArea.setAttribute("wrap", this._textAreaWrapping && !this._visibleTextArea ? "on" : "off");
    const { tabSize: n } = this._context.viewModel.model.getOptions();
    return this.textArea.domNode.style.tabSize = `${n * this._fontInfo.spaceWidth}px`, this.textArea.setAttribute("aria-label", this._getAriaLabel(t)), this.textArea.setAttribute("aria-required", t.get(
      5
      /* EditorOption.ariaRequired */
    ) ? "true" : "false"), this.textArea.setAttribute("tabindex", String(t.get(
      125
      /* EditorOption.tabIndex */
    ))), (e.hasChanged(
      34
      /* EditorOption.domReadOnly */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    )) && this._ensureReadOnlyAttribute(), e.hasChanged(
      2
      /* EditorOption.accessibilitySupport */
    ) && this._textAreaInput.writeNativeTextAreaContent("strategy changed"), !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), this._modelSelections = e.modelSelections.slice(0), this._textAreaInput.writeNativeTextAreaContent("selection changed"), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return this._scrollLeft = e.scrollLeft, this._scrollTop = e.scrollTop, !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin view API
  isFocused() {
    return this._textAreaInput.isFocused();
  }
  focusTextArea() {
    this._textAreaInput.focusTextArea();
  }
  getLastRenderData() {
    return this._lastRenderPosition;
  }
  setAriaOptions(e) {
    e.activeDescendant ? (this.textArea.setAttribute("aria-haspopup", "true"), this.textArea.setAttribute("aria-autocomplete", "list"), this.textArea.setAttribute("aria-activedescendant", e.activeDescendant)) : (this.textArea.setAttribute("aria-haspopup", "false"), this.textArea.setAttribute("aria-autocomplete", "both"), this.textArea.removeAttribute("aria-activedescendant")), e.role && this.textArea.setAttribute("role", e.role);
  }
  // --- end view API
  _ensureReadOnlyAttribute() {
    const e = this._context.configuration.options;
    !Rp.enabled || e.get(
      34
      /* EditorOption.domReadOnly */
    ) && e.get(
      92
      /* EditorOption.readOnly */
    ) ? this.textArea.setAttribute("readonly", "true") : this.textArea.removeAttribute("readonly");
  }
  prepareRender(e) {
    this._primaryCursorPosition = new F(this._selections[0].positionLineNumber, this._selections[0].positionColumn), this._primaryCursorVisibleRange = e.visibleRangeForPosition(this._primaryCursorPosition), this._visibleTextArea?.prepareRender(e);
  }
  render(e) {
    this._textAreaInput.writeNativeTextAreaContent("render"), this._render();
  }
  _render() {
    if (this._visibleTextArea) {
      const i = this._visibleTextArea.visibleTextareaStart, n = this._visibleTextArea.visibleTextareaEnd, o = this._visibleTextArea.startPosition, r = this._visibleTextArea.endPosition;
      if (o && r && i && n && n.left >= this._scrollLeft && i.left <= this._scrollLeft + this._contentWidth) {
        const a = this._context.viewLayout.getVerticalOffsetForLineNumber(this._primaryCursorPosition.lineNumber) - this._scrollTop, l = this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
        let c = this._visibleTextArea.widthOfHiddenLineTextBefore, d = this._contentLeft + i.left - this._scrollLeft, h = n.left - i.left + 1;
        if (d < this._contentLeft) {
          const _ = this._contentLeft - d;
          d += _, c += _, h -= _;
        }
        h > this._contentWidth && (h = this._contentWidth);
        const u = this._context.viewModel.getViewLineData(o.lineNumber), g = u.tokens.findTokenIndexAtOffset(o.column - 1), m = u.tokens.findTokenIndexAtOffset(r.column - 1), p = g === m, A = this._visibleTextArea.definePresentation(p ? u.tokens.getPresentation(g) : null);
        this.textArea.domNode.scrollTop = l * this._lineHeight, this.textArea.domNode.scrollLeft = c, this._doRender({
          lastRenderPosition: null,
          top: a,
          left: d,
          width: h,
          height: this._lineHeight,
          useCover: !1,
          color: (ci.getColorMap() || [])[A.foreground],
          italic: A.italic,
          bold: A.bold,
          underline: A.underline,
          strikethrough: A.strikethrough
        });
      }
      return;
    }
    if (!this._primaryCursorVisibleRange) {
      this._renderAtTopLeft();
      return;
    }
    const e = this._contentLeft + this._primaryCursorVisibleRange.left - this._scrollLeft;
    if (e < this._contentLeft || e > this._contentLeft + this._contentWidth) {
      this._renderAtTopLeft();
      return;
    }
    const t = this._context.viewLayout.getVerticalOffsetForLineNumber(this._selections[0].positionLineNumber) - this._scrollTop;
    if (t < 0 || t > this._contentHeight) {
      this._renderAtTopLeft();
      return;
    }
    if (ze || this._accessibilitySupport === 2) {
      this._doRender({
        lastRenderPosition: this._primaryCursorPosition,
        top: t,
        left: this._textAreaWrapping ? this._contentLeft : e,
        width: this._textAreaWidth,
        height: this._lineHeight,
        useCover: !1
      }), this.textArea.domNode.scrollLeft = this._primaryCursorVisibleRange.left;
      const i = this._textAreaInput.textAreaState.newlineCountBeforeSelection ?? this._newlinecount(this.textArea.domNode.value.substr(0, this.textArea.domNode.selectionStart));
      this.textArea.domNode.scrollTop = i * this._lineHeight;
      return;
    }
    this._doRender({
      lastRenderPosition: this._primaryCursorPosition,
      top: t,
      left: this._textAreaWrapping ? this._contentLeft : e,
      width: this._textAreaWidth,
      height: Xy ? 0 : 1,
      useCover: !1
    });
  }
  _newlinecount(e) {
    let t = 0, i = -1;
    do {
      if (i = e.indexOf(`
`, i + 1), i === -1)
        break;
      t++;
    } while (!0);
    return t;
  }
  _renderAtTopLeft() {
    this._doRender({
      lastRenderPosition: null,
      top: 0,
      left: 0,
      width: this._textAreaWidth,
      height: Xy ? 0 : 1,
      useCover: !0
    });
  }
  _doRender(e) {
    this._lastRenderPosition = e.lastRenderPosition;
    const t = this.textArea, i = this.textAreaCover;
    cn(t, this._fontInfo), t.setTop(e.top), t.setLeft(e.left), t.setWidth(e.width), t.setHeight(e.height), t.setColor(e.color ? Y.Format.CSS.formatHex(e.color) : ""), t.setFontStyle(e.italic ? "italic" : ""), e.bold && t.setFontWeight("bold"), t.setTextDecoration(`${e.underline ? " underline" : ""}${e.strikethrough ? " line-through" : ""}`), i.setTop(e.useCover ? e.top : 0), i.setLeft(e.useCover ? e.left : 0), i.setWidth(e.useCover ? e.width : 0), i.setHeight(e.useCover ? e.height : 0);
    const n = this._context.configuration.options;
    n.get(
      57
      /* EditorOption.glyphMargin */
    ) ? i.setClassName("monaco-editor-background textAreaCover " + vv.OUTER_CLASS_NAME) : n.get(
      68
      /* EditorOption.lineNumbers */
    ).renderType !== 0 ? i.setClassName("monaco-editor-background textAreaCover " + Cv.CLASS_NAME) : i.setClassName("monaco-editor-background textAreaCover");
  }
};
_D = Ese([
  DO(3, bt),
  DO(4, ke)
], _D);
function kse(s, e, t, i) {
  if (e.length === 0)
    return 0;
  const n = s.createElement("div");
  n.style.position = "absolute", n.style.top = "-50000px", n.style.width = "50000px";
  const o = s.createElement("span");
  cn(o, t), o.style.whiteSpace = "pre", o.style.tabSize = `${i * t.spaceWidth}px`, o.append(e), n.appendChild(o), s.body.appendChild(n);
  const r = o.offsetWidth;
  return n.remove(), r;
}
const Dse = () => !0, Ise = () => !1, Mse = (s) => s === " " || s === "	";
class ug {
  static shouldRecreate(e) {
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) || e.hasChanged(
      132
      /* EditorOption.wordSeparators */
    ) || e.hasChanged(
      37
      /* EditorOption.emptySelectionClipboard */
    ) || e.hasChanged(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ) || e.hasChanged(
      79
      /* EditorOption.multiCursorPaste */
    ) || e.hasChanged(
      80
      /* EditorOption.multiCursorLimit */
    ) || e.hasChanged(
      6
      /* EditorOption.autoClosingBrackets */
    ) || e.hasChanged(
      7
      /* EditorOption.autoClosingComments */
    ) || e.hasChanged(
      11
      /* EditorOption.autoClosingQuotes */
    ) || e.hasChanged(
      9
      /* EditorOption.autoClosingDelete */
    ) || e.hasChanged(
      10
      /* EditorOption.autoClosingOvertype */
    ) || e.hasChanged(
      14
      /* EditorOption.autoSurround */
    ) || e.hasChanged(
      129
      /* EditorOption.useTabStops */
    ) || e.hasChanged(
      50
      /* EditorOption.fontInfo */
    ) || e.hasChanged(
      92
      /* EditorOption.readOnly */
    ) || e.hasChanged(
      131
      /* EditorOption.wordSegmenterLocales */
    );
  }
  constructor(e, t, i, n) {
    this.languageConfigurationService = n, this._cursorMoveConfigurationBrand = void 0, this._languageId = e;
    const o = i.options, r = o.get(
      146
      /* EditorOption.layoutInfo */
    ), a = o.get(
      50
      /* EditorOption.fontInfo */
    );
    this.readOnly = o.get(
      92
      /* EditorOption.readOnly */
    ), this.tabSize = t.tabSize, this.indentSize = t.indentSize, this.insertSpaces = t.insertSpaces, this.stickyTabStops = o.get(
      117
      /* EditorOption.stickyTabStops */
    ), this.lineHeight = a.lineHeight, this.typicalHalfwidthCharacterWidth = a.typicalHalfwidthCharacterWidth, this.pageSize = Math.max(1, Math.floor(r.height / this.lineHeight) - 2), this.useTabStops = o.get(
      129
      /* EditorOption.useTabStops */
    ), this.wordSeparators = o.get(
      132
      /* EditorOption.wordSeparators */
    ), this.emptySelectionClipboard = o.get(
      37
      /* EditorOption.emptySelectionClipboard */
    ), this.copyWithSyntaxHighlighting = o.get(
      25
      /* EditorOption.copyWithSyntaxHighlighting */
    ), this.multiCursorMergeOverlapping = o.get(
      77
      /* EditorOption.multiCursorMergeOverlapping */
    ), this.multiCursorPaste = o.get(
      79
      /* EditorOption.multiCursorPaste */
    ), this.multiCursorLimit = o.get(
      80
      /* EditorOption.multiCursorLimit */
    ), this.autoClosingBrackets = o.get(
      6
      /* EditorOption.autoClosingBrackets */
    ), this.autoClosingComments = o.get(
      7
      /* EditorOption.autoClosingComments */
    ), this.autoClosingQuotes = o.get(
      11
      /* EditorOption.autoClosingQuotes */
    ), this.autoClosingDelete = o.get(
      9
      /* EditorOption.autoClosingDelete */
    ), this.autoClosingOvertype = o.get(
      10
      /* EditorOption.autoClosingOvertype */
    ), this.autoSurround = o.get(
      14
      /* EditorOption.autoSurround */
    ), this.autoIndent = o.get(
      12
      /* EditorOption.autoIndent */
    ), this.wordSegmenterLocales = o.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), this.surroundingPairs = {}, this._electricChars = null, this.shouldAutoCloseBefore = {
      quote: this._getShouldAutoClose(e, this.autoClosingQuotes, !0),
      comment: this._getShouldAutoClose(e, this.autoClosingComments, !1),
      bracket: this._getShouldAutoClose(e, this.autoClosingBrackets, !1)
    }, this.autoClosingPairs = this.languageConfigurationService.getLanguageConfiguration(e).getAutoClosingPairs();
    const l = this.languageConfigurationService.getLanguageConfiguration(e).getSurroundingPairs();
    if (l)
      for (const d of l)
        this.surroundingPairs[d.open] = d.close;
    const c = this.languageConfigurationService.getLanguageConfiguration(e).comments;
    this.blockCommentStartToken = c?.blockCommentStartToken ?? null;
  }
  get electricChars() {
    if (!this._electricChars) {
      this._electricChars = {};
      const e = this.languageConfigurationService.getLanguageConfiguration(this._languageId).electricCharacter?.getElectricCharacters();
      if (e)
        for (const t of e)
          this._electricChars[t] = !0;
    }
    return this._electricChars;
  }
  /**
   * Should return opening bracket type to match indentation with
   */
  onElectricCharacter(e, t, i) {
    const n = wh(t, i - 1), o = this.languageConfigurationService.getLanguageConfiguration(n.languageId).electricCharacter;
    return o ? o.onElectricCharacter(e, n, i - n.firstCharOffset) : null;
  }
  normalizeIndentation(e) {
    return rW(e, this.indentSize, this.insertSpaces);
  }
  _getShouldAutoClose(e, t, i) {
    switch (t) {
      case "beforeWhitespace":
        return Mse;
      case "languageDefined":
        return this._getLanguageDefinedShouldAutoClose(e, i);
      case "always":
        return Dse;
      case "never":
        return Ise;
    }
  }
  _getLanguageDefinedShouldAutoClose(e, t) {
    const i = this.languageConfigurationService.getLanguageConfiguration(e).getAutoCloseBeforeSet(t);
    return (n) => i.indexOf(n) !== -1;
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  visibleColumnFromColumn(e, t) {
    return wi.visibleColumnFromColumn(e.getLineContent(t.lineNumber), t.column, this.tabSize);
  }
  /**
   * Returns a visible column from a column.
   * @see {@link CursorColumns}
   */
  columnFromVisibleColumn(e, t, i) {
    const n = wi.columnFromVisibleColumn(e.getLineContent(t), i, this.tabSize), o = e.getLineMinColumn(t);
    if (n < o)
      return o;
    const r = e.getLineMaxColumn(t);
    return n > r ? r : n;
  }
}
class Ye {
  static fromModelState(e) {
    return new Nse(e);
  }
  static fromViewState(e) {
    return new Tse(e);
  }
  static fromModelSelection(e) {
    const t = Ue.liftSelection(e), i = new Vi(E.fromPositions(t.getSelectionStart()), 0, 0, t.getPosition(), 0);
    return Ye.fromModelState(i);
  }
  static fromModelSelections(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t[i] = this.fromModelSelection(e[i]);
    return t;
  }
  constructor(e, t) {
    this._cursorStateBrand = void 0, this.modelState = e, this.viewState = t;
  }
  equals(e) {
    return this.viewState.equals(e.viewState) && this.modelState.equals(e.modelState);
  }
}
class Nse {
  constructor(e) {
    this.modelState = e, this.viewState = null;
  }
}
class Tse {
  constructor(e) {
    this.modelState = null, this.viewState = e;
  }
}
class Vi {
  constructor(e, t, i, n, o) {
    this.selectionStart = e, this.selectionStartKind = t, this.selectionStartLeftoverVisibleColumns = i, this.position = n, this.leftoverVisibleColumns = o, this._singleCursorStateBrand = void 0, this.selection = Vi._computeSelection(this.selectionStart, this.position);
  }
  equals(e) {
    return this.selectionStartLeftoverVisibleColumns === e.selectionStartLeftoverVisibleColumns && this.leftoverVisibleColumns === e.leftoverVisibleColumns && this.selectionStartKind === e.selectionStartKind && this.position.equals(e.position) && this.selectionStart.equalsRange(e.selectionStart);
  }
  hasSelection() {
    return !this.selection.isEmpty() || !this.selectionStart.isEmpty();
  }
  move(e, t, i, n) {
    return e ? new Vi(this.selectionStart, this.selectionStartKind, this.selectionStartLeftoverVisibleColumns, new F(t, i), n) : new Vi(new E(t, i, t, i), 0, n, new F(t, i), n);
  }
  static _computeSelection(e, t) {
    return e.isEmpty() || !t.isBeforeOrEqual(e.getStartPosition()) ? Ue.fromPositions(e.getStartPosition(), t) : Ue.fromPositions(e.getEndPosition(), t);
  }
}
class is {
  constructor(e, t, i) {
    this._editOperationResultBrand = void 0, this.type = e, this.commands = t, this.shouldPushStackElementBefore = i.shouldPushStackElementBefore, this.shouldPushStackElementAfter = i.shouldPushStackElementAfter;
  }
}
function ud(s) {
  return s === "'" || s === '"' || s === "`";
}
class ah {
  static columnSelect(e, t, i, n, o, r) {
    const a = Math.abs(o - i) + 1, l = i > o, c = n > r, d = n < r, h = [];
    for (let u = 0; u < a; u++) {
      const g = i + (l ? -u : u), m = e.columnFromVisibleColumn(t, g, n), p = e.columnFromVisibleColumn(t, g, r), A = e.visibleColumnFromColumn(t, new F(g, m)), _ = e.visibleColumnFromColumn(t, new F(g, p));
      d && (A > r || _ < n) || c && (_ > n || A < r) || h.push(new Vi(new E(g, m, g, m), 0, 0, new F(g, p), 0));
    }
    if (h.length === 0)
      for (let u = 0; u < a; u++) {
        const g = i + (l ? -u : u), m = t.getLineMaxColumn(g);
        h.push(new Vi(new E(g, m, g, m), 0, 0, new F(g, m), 0));
      }
    return {
      viewStates: h,
      reversed: l,
      fromLineNumber: i,
      fromVisualColumn: n,
      toLineNumber: o,
      toVisualColumn: r
    };
  }
  static columnSelectLeft(e, t, i) {
    let n = i.toViewVisualColumn;
    return n > 0 && n--, ah.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, n);
  }
  static columnSelectRight(e, t, i) {
    let n = 0;
    const o = Math.min(i.fromViewLineNumber, i.toViewLineNumber), r = Math.max(i.fromViewLineNumber, i.toViewLineNumber);
    for (let l = o; l <= r; l++) {
      const c = t.getLineMaxColumn(l), d = e.visibleColumnFromColumn(t, new F(l, c));
      n = Math.max(n, d);
    }
    let a = i.toViewVisualColumn;
    return a < n && a++, this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, i.toViewLineNumber, a);
  }
  static columnSelectUp(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.max(1, i.toViewLineNumber - o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
  static columnSelectDown(e, t, i, n) {
    const o = n ? e.pageSize : 1, r = Math.min(t.getLineCount(), i.toViewLineNumber + o);
    return this.columnSelect(e, t, i.fromViewLineNumber, i.fromViewVisualColumn, r, i.toViewVisualColumn);
  }
}
class vn {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getEndPosition());
  }
}
class Fw {
  constructor(e, t, i = !1) {
    this._range = e, this._text = t, this.insertsAutoWhitespace = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getStartPosition());
  }
}
class Sv {
  constructor(e, t, i, n, o = !1) {
    this._range = e, this._text = t, this._columnDeltaOffset = n, this._lineNumberDeltaOffset = i, this.insertsAutoWhitespace = o;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return Ue.fromPositions(n.getEndPosition().delta(this._lineNumberDeltaOffset, this._columnDeltaOffset));
  }
}
class D8 {
  constructor(e, t, i, n = !1) {
    this._range = e, this._text = t, this._initialSelection = i, this._forceMoveMarkers = n, this._selectionId = null;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._range, this._text, this._forceMoveMarkers), this._selectionId = t.trackSelection(this._initialSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._selectionId);
  }
}
class Zy {
  constructor(e, t, i) {
    this._cursorPositionBrand = void 0, this.lineNumber = e, this.column = t, this.leftoverVisibleColumns = i;
  }
}
class gt {
  static leftPosition(e, t) {
    if (t.column > e.getLineMinColumn(t.lineNumber))
      return t.delta(void 0, -bH(e.getLineContent(t.lineNumber), t.column - 1));
    if (t.lineNumber > 1) {
      const i = t.lineNumber - 1;
      return new F(i, e.getLineMaxColumn(i));
    } else
      return t;
  }
  static leftPositionAtomicSoftTabs(e, t, i) {
    if (t.column <= e.getLineIndentColumn(t.lineNumber)) {
      const n = e.getLineMinColumn(t.lineNumber), o = e.getLineContent(t.lineNumber), r = c_.atomicPosition(
        o,
        t.column - 1,
        i,
        0
        /* Direction.Left */
      );
      if (r !== -1 && r + 1 >= n)
        return new F(t.lineNumber, r + 1);
    }
    return this.leftPosition(e, t);
  }
  static left(e, t, i) {
    const n = e.stickyTabStops ? gt.leftPositionAtomicSoftTabs(t, i, e.tabSize) : gt.leftPosition(t, i);
    return new Zy(n.lineNumber, n.column, 0);
  }
  /**
   * @param noOfColumns Must be either `1`
   * or `Math.round(viewModel.getLineContent(viewLineNumber).length / 2)` (for half lines).
  */
  static moveLeft(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.startLineNumber, a = i.selection.startColumn;
    else {
      const l = i.position.delta(void 0, -(o - 1)), c = t.normalizePosition(
        gt.clipPositionColumn(l, t),
        0
        /* PositionAffinity.Left */
      ), d = gt.left(e, t, c);
      r = d.lineNumber, a = d.column;
    }
    return i.move(n, r, a, 0);
  }
  /**
   * Adjusts the column so that it is within min/max of the line.
  */
  static clipPositionColumn(e, t) {
    return new F(e.lineNumber, gt.clipRange(e.column, t.getLineMinColumn(e.lineNumber), t.getLineMaxColumn(e.lineNumber)));
  }
  static clipRange(e, t, i) {
    return e < t ? t : e > i ? i : e;
  }
  static rightPosition(e, t, i) {
    return i < e.getLineMaxColumn(t) ? i = i + HM(e.getLineContent(t), i - 1) : t < e.getLineCount() && (t = t + 1, i = e.getLineMinColumn(t)), new F(t, i);
  }
  static rightPositionAtomicSoftTabs(e, t, i, n, o) {
    if (i < e.getLineIndentColumn(t)) {
      const r = e.getLineContent(t), a = c_.atomicPosition(
        r,
        i - 1,
        n,
        1
        /* Direction.Right */
      );
      if (a !== -1)
        return new F(t, a + 1);
    }
    return this.rightPosition(e, t, i);
  }
  static right(e, t, i) {
    const n = e.stickyTabStops ? gt.rightPositionAtomicSoftTabs(t, i.lineNumber, i.column, e.tabSize, e.indentSize) : gt.rightPosition(t, i.lineNumber, i.column);
    return new Zy(n.lineNumber, n.column, 0);
  }
  static moveRight(e, t, i, n, o) {
    let r, a;
    if (i.hasSelection() && !n)
      r = i.selection.endLineNumber, a = i.selection.endColumn;
    else {
      const l = i.position.delta(void 0, o - 1), c = t.normalizePosition(
        gt.clipPositionColumn(l, t),
        1
        /* PositionAffinity.Right */
      ), d = gt.right(e, t, c);
      r = d.lineNumber, a = d.column;
    }
    return i.move(n, r, a, 0);
  }
  static vertical(e, t, i, n, o, r, a, l) {
    const c = wi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize) + o, d = t.getLineCount(), h = i === 1 && n === 1, u = i === d && n === t.getLineMaxColumn(i), g = r < i ? h : u;
    if (i = r, i < 1 ? (i = 1, a ? n = t.getLineMinColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : i > d ? (i = d, a ? n = t.getLineMaxColumn(i) : n = Math.min(t.getLineMaxColumn(i), n)) : n = e.columnFromVisibleColumn(t, i, c), g ? o = 0 : o = c - wi.visibleColumnFromColumn(t.getLineContent(i), n, e.tabSize), l !== void 0) {
      const m = new F(i, n), p = t.normalizePosition(m, l);
      o = o + (n - p.column), i = p.lineNumber, n = p.column;
    }
    return new Zy(i, n, o);
  }
  static down(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i + r,
      a,
      4
      /* PositionAffinity.RightOfInjectedText */
    );
  }
  static moveDown(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.endLineNumber, a = i.selection.endColumn) : (r = i.position.lineNumber, a = i.position.column);
    let l = 0, c;
    do
      if (c = gt.down(e, t, r + l, a, i.leftoverVisibleColumns, o, !0), t.normalizePosition(
        new F(c.lineNumber, c.column),
        2
        /* PositionAffinity.None */
      ).lineNumber > r)
        break;
    while (l++ < 10 && r + l < t.getLineCount());
    return i.move(n, c.lineNumber, c.column, c.leftoverVisibleColumns);
  }
  static translateDown(e, t, i) {
    const n = i.selection, o = gt.down(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = gt.down(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Vi(new E(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new F(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static up(e, t, i, n, o, r, a) {
    return this.vertical(
      e,
      t,
      i,
      n,
      o,
      i - r,
      a,
      3
      /* PositionAffinity.LeftOfInjectedText */
    );
  }
  static moveUp(e, t, i, n, o) {
    let r, a;
    i.hasSelection() && !n ? (r = i.selection.startLineNumber, a = i.selection.startColumn) : (r = i.position.lineNumber, a = i.position.column);
    const l = gt.up(e, t, r, a, i.leftoverVisibleColumns, o, !0);
    return i.move(n, l.lineNumber, l.column, l.leftoverVisibleColumns);
  }
  static translateUp(e, t, i) {
    const n = i.selection, o = gt.up(e, t, n.selectionStartLineNumber, n.selectionStartColumn, i.selectionStartLeftoverVisibleColumns, 1, !1), r = gt.up(e, t, n.positionLineNumber, n.positionColumn, i.leftoverVisibleColumns, 1, !1);
    return new Vi(new E(o.lineNumber, o.column, o.lineNumber, o.column), 0, o.leftoverVisibleColumns, new F(r.lineNumber, r.column), r.leftoverVisibleColumns);
  }
  static _isBlankLine(e, t) {
    return e.getLineFirstNonWhitespaceColumn(t) === 0;
  }
  static moveToPrevBlankLine(e, t, i, n) {
    let o = i.position.lineNumber;
    for (; o > 1 && this._isBlankLine(t, o); )
      o--;
    for (; o > 1 && !this._isBlankLine(t, o); )
      o--;
    return i.move(n, o, t.getLineMinColumn(o), 0);
  }
  static moveToNextBlankLine(e, t, i, n) {
    const o = t.getLineCount();
    let r = i.position.lineNumber;
    for (; r < o && this._isBlankLine(t, r); )
      r++;
    for (; r < o && !this._isBlankLine(t, r); )
      r++;
    return i.move(n, r, t.getLineMinColumn(r), 0);
  }
  static moveToBeginningOfLine(e, t, i, n) {
    const o = i.position.lineNumber, r = t.getLineMinColumn(o), a = t.getLineFirstNonWhitespaceColumn(o) || r;
    let l;
    return i.position.column === a ? l = r : l = a, i.move(n, o, l, 0);
  }
  static moveToEndOfLine(e, t, i, n, o) {
    const r = i.position.lineNumber, a = t.getLineMaxColumn(r);
    return i.move(n, r, a, o ? 1073741824 - a : 0);
  }
  static moveToBeginningOfBuffer(e, t, i, n) {
    return i.move(n, 1, 1, 0);
  }
  static moveToEndOfBuffer(e, t, i, n) {
    const o = t.getLineCount(), r = t.getLineMaxColumn(o);
    return i.move(n, o, r, 0);
  }
}
class Eu {
  static deleteRight(e, t, i, n) {
    const o = [];
    let r = e !== 3;
    for (let a = 0, l = n.length; a < l; a++) {
      const c = n[a];
      let d = c;
      if (d.isEmpty()) {
        const h = c.getPosition(), u = gt.right(t, i, h);
        d = new E(u.lineNumber, u.column, h.lineNumber, h.column);
      }
      if (d.isEmpty()) {
        o[a] = null;
        continue;
      }
      d.startLineNumber !== d.endLineNumber && (r = !0), o[a] = new vn(d, "");
    }
    return [r, o];
  }
  static isAutoClosingPairDelete(e, t, i, n, o, r, a) {
    if (t === "never" && i === "never" || e === "never")
      return !1;
    for (let l = 0, c = r.length; l < c; l++) {
      const d = r[l], h = d.getPosition();
      if (!d.isEmpty())
        return !1;
      const u = o.getLineContent(h.lineNumber);
      if (h.column < 2 || h.column >= u.length + 1)
        return !1;
      const g = u.charAt(h.column - 2), m = n.get(g);
      if (!m)
        return !1;
      if (ud(g)) {
        if (i === "never")
          return !1;
      } else if (t === "never")
        return !1;
      const p = u.charAt(h.column - 1);
      let A = !1;
      for (const _ of m)
        _.open === g && _.close === p && (A = !0);
      if (!A)
        return !1;
      if (e === "auto") {
        let _ = !1;
        for (let b = 0, C = a.length; b < C; b++) {
          const w = a[b];
          if (h.lineNumber === w.startLineNumber && h.column === w.startColumn) {
            _ = !0;
            break;
          }
        }
        if (!_)
          return !1;
      }
    }
    return !0;
  }
  static _runAutoClosingPairDelete(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].getPosition(), l = new E(a.lineNumber, a.column - 1, a.lineNumber, a.column + 1);
      n[o] = new vn(l, "");
    }
    return [!0, n];
  }
  static deleteLeft(e, t, i, n, o) {
    if (this.isAutoClosingPairDelete(t.autoClosingDelete, t.autoClosingBrackets, t.autoClosingQuotes, t.autoClosingPairs.autoClosingPairsOpenByEnd, i, n, o))
      return this._runAutoClosingPairDelete(t, i, n);
    const r = [];
    let a = e !== 2;
    for (let l = 0, c = n.length; l < c; l++) {
      const d = Eu.getDeleteRange(n[l], i, t);
      if (d.isEmpty()) {
        r[l] = null;
        continue;
      }
      d.startLineNumber !== d.endLineNumber && (a = !0), r[l] = new vn(d, "");
    }
    return [a, r];
  }
  static getDeleteRange(e, t, i) {
    if (!e.isEmpty())
      return e;
    const n = e.getPosition();
    if (i.useTabStops && n.column > 1) {
      const o = t.getLineContent(n.lineNumber), r = Sn(o), a = r === -1 ? (
        /* entire string is whitespace */
        o.length + 1
      ) : r + 1;
      if (n.column <= a) {
        const l = i.visibleColumnFromColumn(t, n), c = wi.prevIndentTabStop(l, i.indentSize), d = i.columnFromVisibleColumn(t, n.lineNumber, c);
        return new E(n.lineNumber, d, n.lineNumber, n.column);
      }
    }
    return E.fromPositions(Eu.getPositionAfterDeleteLeft(n, t), n);
  }
  static getPositionAfterDeleteLeft(e, t) {
    if (e.column > 1) {
      const i = H7(e.column - 1, t.getLineContent(e.lineNumber));
      return e.with(void 0, i + 1);
    } else if (e.lineNumber > 1) {
      const i = e.lineNumber - 1;
      return new F(i, t.getLineMaxColumn(i));
    } else
      return e;
  }
  static cut(e, t, i) {
    const n = [];
    let o = null;
    i.sort((r, a) => F.compare(r.getStartPosition(), a.getEndPosition()));
    for (let r = 0, a = i.length; r < a; r++) {
      const l = i[r];
      if (l.isEmpty())
        if (e.emptySelectionClipboard) {
          const c = l.getPosition();
          let d, h, u, g;
          c.lineNumber < t.getLineCount() ? (d = c.lineNumber, h = 1, u = c.lineNumber + 1, g = 1) : c.lineNumber > 1 && o?.endLineNumber !== c.lineNumber ? (d = c.lineNumber - 1, h = t.getLineMaxColumn(c.lineNumber - 1), u = c.lineNumber, g = t.getLineMaxColumn(c.lineNumber)) : (d = c.lineNumber, h = 1, u = c.lineNumber, g = t.getLineMaxColumn(c.lineNumber));
          const m = new E(d, h, u, g);
          o = m, m.isEmpty() ? n[r] = null : n[r] = new vn(m, "");
        } else
          n[r] = null;
      else
        n[r] = new vn(l, "");
    }
    return new is(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class Wt {
  static _createWord(e, t, i, n, o) {
    return { start: n, end: o, wordType: t, nextCharClass: i };
  }
  static _createIntlWord(e, t) {
    return { start: e.index, end: e.index + e.segment.length, wordType: 1, nextCharClass: t };
  }
  static _findPreviousWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindPreviousWordOnLine(n, e, i);
  }
  static _doFindPreviousWordOnLine(e, t, i) {
    let n = 0;
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, i.column - 2);
    for (let r = i.column - 2; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return this._createIntlWord(o, l);
      if (l === 0) {
        if (n === 2)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 1;
      } else if (l === 2) {
        if (n === 1)
          return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
        n = 2;
      } else if (l === 1 && n !== 0)
        return this._createWord(e, n, l, r + 1, this._findEndOfWord(e, t, n, r + 1));
    }
    return n !== 0 ? this._createWord(e, n, 1, 0, this._findEndOfWord(e, t, n, 0)) : null;
  }
  static _findEndOfWord(e, t, i, n) {
    const o = t.findNextIntlWordAtOrAfterOffset(e, n), r = e.length;
    for (let a = n; a < r; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (o && a === o.index + o.segment.length || c === 1 || i === 1 && c === 2 || i === 2 && c === 0)
        return a;
    }
    return r;
  }
  static _findNextWordOnLine(e, t, i) {
    const n = t.getLineContent(i.lineNumber);
    return this._doFindNextWordOnLine(n, e, i);
  }
  static _doFindNextWordOnLine(e, t, i) {
    let n = 0;
    const o = e.length, r = t.findNextIntlWordAtOrAfterOffset(e, i.column - 1);
    for (let a = i.column - 1; a < o; a++) {
      const l = e.charCodeAt(a), c = t.get(l);
      if (r && a === r.index)
        return this._createIntlWord(r, c);
      if (c === 0) {
        if (n === 2)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 1;
      } else if (c === 2) {
        if (n === 1)
          return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
        n = 2;
      } else if (c === 1 && n !== 0)
        return this._createWord(e, n, c, this._findStartOfWord(e, t, n, a - 1), a);
    }
    return n !== 0 ? this._createWord(e, n, 1, this._findStartOfWord(e, t, n, o - 1), o) : null;
  }
  static _findStartOfWord(e, t, i, n) {
    const o = t.findPrevIntlWordBeforeOrAtOffset(e, n);
    for (let r = n; r >= 0; r--) {
      const a = e.charCodeAt(r), l = t.get(a);
      if (o && r === o.index)
        return r;
      if (l === 1 || i === 1 && l === 2 || i === 2 && l === 0)
        return r + 1;
    }
    return 0;
  }
  static moveWordLeft(e, t, i, n, o) {
    let r = i.lineNumber, a = i.column;
    a === 1 && r > 1 && (r = r - 1, a = t.getLineMaxColumn(r));
    let l = Wt._findPreviousWordOnLine(e, t, new F(r, a));
    if (n === 0)
      return new F(r, l ? l.start + 1 : 1);
    if (n === 1)
      return !o && l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Wt._findPreviousWordOnLine(e, t, new F(r, l.start + 1))), new F(r, l ? l.start + 1 : 1);
    if (n === 3) {
      for (; l && l.wordType === 2; )
        l = Wt._findPreviousWordOnLine(e, t, new F(r, l.start + 1));
      return new F(r, l ? l.start + 1 : 1);
    }
    return l && a <= l.end + 1 && (l = Wt._findPreviousWordOnLine(e, t, new F(r, l.start + 1))), new F(r, l ? l.end + 1 : 1);
  }
  static _moveWordPartLeft(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === 1)
      return i > 1 ? new F(i - 1, e.getLineMaxColumn(i - 1)) : t;
    const o = e.getLineContent(i);
    for (let r = t.column - 1; r > 1; r--) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a === 95 && l !== 95)
        return new F(i, r);
      if (a === 45 && l !== 45)
        return new F(i, r);
      if ((Ig(a) || lb(a)) && hc(l))
        return new F(i, r);
      if (hc(a) && hc(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (Ig(c) || lb(c))
          return new F(i, r);
      }
    }
    return new F(i, 1);
  }
  static moveWordRight(e, t, i, n) {
    let o = i.lineNumber, r = i.column, a = !1;
    r === t.getLineMaxColumn(o) && o < t.getLineCount() && (a = !0, o = o + 1, r = 1);
    let l = Wt._findNextWordOnLine(e, t, new F(o, r));
    if (n === 2)
      l && l.wordType === 2 && l.end - l.start === 1 && l.nextCharClass === 0 && (l = Wt._findNextWordOnLine(e, t, new F(o, l.end + 1))), l ? r = l.end + 1 : r = t.getLineMaxColumn(o);
    else if (n === 3) {
      for (a && (r = 0); l && (l.wordType === 2 || l.start + 1 <= r); )
        l = Wt._findNextWordOnLine(e, t, new F(o, l.end + 1));
      l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    } else
      l && !a && r >= l.start + 1 && (l = Wt._findNextWordOnLine(e, t, new F(o, l.end + 1))), l ? r = l.start + 1 : r = t.getLineMaxColumn(o);
    return new F(o, r);
  }
  static _moveWordPartRight(e, t) {
    const i = t.lineNumber, n = e.getLineMaxColumn(i);
    if (t.column === n)
      return i < e.getLineCount() ? new F(i + 1, 1) : t;
    const o = e.getLineContent(i);
    for (let r = t.column + 1; r < n; r++) {
      const a = o.charCodeAt(r - 2), l = o.charCodeAt(r - 1);
      if (a !== 95 && l === 95)
        return new F(i, r);
      if (a !== 45 && l === 45)
        return new F(i, r);
      if ((Ig(a) || lb(a)) && hc(l))
        return new F(i, r);
      if (hc(a) && hc(l) && r + 1 < n) {
        const c = o.charCodeAt(r);
        if (Ig(c) || lb(c))
          return new F(i, r);
      }
    }
    return new F(i, n);
  }
  static _deleteWordLeftWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 2, o = Ru(i, n);
    return o + 1 < n ? new E(t.lineNumber, o + 2, t.lineNumber, t.column) : null;
  }
  static deleteWordLeft(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    if (Eu.isAutoClosingPairDelete(e.autoClosingDelete, e.autoClosingBrackets, e.autoClosingQuotes, e.autoClosingPairs.autoClosingPairsOpenByEnd, e.model, [e.selection], e.autoClosedCharacters)) {
      const h = e.selection.getPosition();
      return new E(h.lineNumber, h.column - 1, h.lineNumber, h.column + 1);
    }
    const a = new F(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    if (l === 1 && c === 1)
      return null;
    if (r) {
      const h = this._deleteWordLeftWhitespace(n, a);
      if (h)
        return h;
    }
    let d = Wt._findPreviousWordOnLine(i, n, a);
    return t === 0 ? d ? c = d.start + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l)) : (d && c <= d.end + 1 && (d = Wt._findPreviousWordOnLine(i, n, new F(l, d.start + 1))), d ? c = d.end + 1 : c > 1 ? c = 1 : (l--, c = n.getLineMaxColumn(l))), new E(l, c, a.lineNumber, a.column);
  }
  static deleteInsideWord(e, t, i) {
    if (!i.isEmpty())
      return i;
    const n = new F(i.positionLineNumber, i.positionColumn), o = this._deleteInsideWordWhitespace(t, n);
    return o || this._deleteInsideWordDetermineDeleteRange(e, t, n);
  }
  static _charAtIsWhitespace(e, t) {
    const i = e.charCodeAt(t);
    return i === 32 || i === 9;
  }
  static _deleteInsideWordWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = i.length;
    if (n === 0)
      return null;
    let o = Math.max(t.column - 2, 0);
    if (!this._charAtIsWhitespace(i, o))
      return null;
    let r = Math.min(t.column - 1, n - 1);
    if (!this._charAtIsWhitespace(i, r))
      return null;
    for (; o > 0 && this._charAtIsWhitespace(i, o - 1); )
      o--;
    for (; r + 1 < n && this._charAtIsWhitespace(i, r + 1); )
      r++;
    return new E(t.lineNumber, o + 1, t.lineNumber, r + 2);
  }
  static _deleteInsideWordDetermineDeleteRange(e, t, i) {
    const n = t.getLineContent(i.lineNumber), o = n.length;
    if (o === 0)
      return i.lineNumber > 1 ? new E(i.lineNumber - 1, t.getLineMaxColumn(i.lineNumber - 1), i.lineNumber, 1) : i.lineNumber < t.getLineCount() ? new E(i.lineNumber, 1, i.lineNumber + 1, 1) : new E(i.lineNumber, 1, i.lineNumber, 1);
    const r = (h) => h.start + 1 <= i.column && i.column <= h.end + 1, a = (h, u) => (h = Math.min(h, i.column), u = Math.max(u, i.column), new E(i.lineNumber, h, i.lineNumber, u)), l = (h) => {
      let u = h.start + 1, g = h.end + 1, m = !1;
      for (; g - 1 < o && this._charAtIsWhitespace(n, g - 1); )
        m = !0, g++;
      if (!m)
        for (; u > 1 && this._charAtIsWhitespace(n, u - 2); )
          u--;
      return a(u, g);
    }, c = Wt._findPreviousWordOnLine(e, t, i);
    if (c && r(c))
      return l(c);
    const d = Wt._findNextWordOnLine(e, t, i);
    return d && r(d) ? l(d) : c && d ? a(c.end + 1, d.start + 1) : c ? a(c.start + 1, c.end + 1) : d ? a(d.start + 1, d.end + 1) : a(1, o + 1);
  }
  static _deleteWordPartLeft(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Wt._moveWordPartLeft(e, i);
    return new E(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _findFirstNonWhitespaceChar(e, t) {
    const i = e.length;
    for (let n = t; n < i; n++) {
      const o = e.charAt(n);
      if (o !== " " && o !== "	")
        return n;
    }
    return i;
  }
  static _deleteWordRightWhitespace(e, t) {
    const i = e.getLineContent(t.lineNumber), n = t.column - 1, o = this._findFirstNonWhitespaceChar(i, n);
    return n + 1 < o ? new E(t.lineNumber, t.column, t.lineNumber, o + 1) : null;
  }
  static deleteWordRight(e, t) {
    const i = e.wordSeparators, n = e.model, o = e.selection, r = e.whitespaceHeuristics;
    if (!o.isEmpty())
      return o;
    const a = new F(o.positionLineNumber, o.positionColumn);
    let l = a.lineNumber, c = a.column;
    const d = n.getLineCount(), h = n.getLineMaxColumn(l);
    if (l === d && c === h)
      return null;
    if (r) {
      const g = this._deleteWordRightWhitespace(n, a);
      if (g)
        return g;
    }
    let u = Wt._findNextWordOnLine(i, n, a);
    return t === 2 ? u ? c = u.end + 1 : c < h || l === d ? c = h : (l++, u = Wt._findNextWordOnLine(i, n, new F(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l)) : (u && c >= u.start + 1 && (u = Wt._findNextWordOnLine(i, n, new F(l, u.end + 1))), u ? c = u.start + 1 : c < h || l === d ? c = h : (l++, u = Wt._findNextWordOnLine(i, n, new F(l, 1)), u ? c = u.start + 1 : c = n.getLineMaxColumn(l))), new E(l, c, a.lineNumber, a.column);
  }
  static _deleteWordPartRight(e, t) {
    if (!t.isEmpty())
      return t;
    const i = t.getPosition(), n = Wt._moveWordPartRight(e, i);
    return new E(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  static _createWordAtPosition(e, t, i) {
    const n = new E(t, i.start + 1, t, i.end + 1);
    return {
      word: e.getValueInRange(n),
      startColumn: n.startColumn,
      endColumn: n.endColumn
    };
  }
  static getWordAtPosition(e, t, i, n) {
    const o = Eo(t, i), r = Wt._findPreviousWordOnLine(o, e, n);
    if (r && r.wordType === 1 && r.start <= n.column - 1 && n.column - 1 <= r.end)
      return Wt._createWordAtPosition(e, n.lineNumber, r);
    const a = Wt._findNextWordOnLine(o, e, n);
    return a && a.wordType === 1 && a.start <= n.column - 1 && n.column - 1 <= a.end ? Wt._createWordAtPosition(e, n.lineNumber, a) : null;
  }
  static word(e, t, i, n, o) {
    const r = Eo(e.wordSeparators, e.wordSegmenterLocales), a = Wt._findPreviousWordOnLine(r, t, o), l = Wt._findNextWordOnLine(r, t, o);
    if (!n) {
      let g, m;
      return a && a.wordType === 1 && a.start <= o.column - 1 && o.column - 1 <= a.end ? (g = a.start + 1, m = a.end + 1) : l && l.wordType === 1 && l.start <= o.column - 1 && o.column - 1 <= l.end ? (g = l.start + 1, m = l.end + 1) : (a ? g = a.end + 1 : g = 1, l ? m = l.start + 1 : m = t.getLineMaxColumn(o.lineNumber)), new Vi(new E(o.lineNumber, g, o.lineNumber, m), 1, 0, new F(o.lineNumber, m), 0);
    }
    let c, d;
    a && a.wordType === 1 && a.start < o.column - 1 && o.column - 1 < a.end ? (c = a.start + 1, d = a.end + 1) : l && l.wordType === 1 && l.start < o.column - 1 && o.column - 1 < l.end ? (c = l.start + 1, d = l.end + 1) : (c = o.column, d = o.column);
    const h = o.lineNumber;
    let u;
    if (i.selectionStart.containsPosition(o))
      u = i.selectionStart.endColumn;
    else if (o.isBeforeOrEqual(i.selectionStart.getStartPosition())) {
      u = c;
      const g = new F(h, u);
      i.selectionStart.containsPosition(g) && (u = i.selectionStart.endColumn);
    } else {
      u = d;
      const g = new F(h, u);
      i.selectionStart.containsPosition(g) && (u = i.selectionStart.startColumn);
    }
    return i.move(!0, h, u, 0);
  }
}
class gn {
  static addCursorDown(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Ye(l.modelState, l.viewState), i ? n[o++] = Ye.fromModelState(gt.translateDown(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ye.fromViewState(gt.translateDown(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static addCursorUp(e, t, i) {
    const n = [];
    let o = 0;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      n[o++] = new Ye(l.modelState, l.viewState), i ? n[o++] = Ye.fromModelState(gt.translateUp(e.cursorConfig, e.model, l.modelState)) : n[o++] = Ye.fromViewState(gt.translateUp(e.cursorConfig, e, l.viewState));
    }
    return n;
  }
  static moveToBeginningOfLine(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = this._moveToLineStart(e, a, i);
    }
    return n;
  }
  static _moveToLineStart(e, t, i) {
    const n = t.viewState.position.column, o = t.modelState.position.column, r = n === o, a = t.viewState.position.lineNumber, l = e.getLineFirstNonWhitespaceColumn(a);
    return !r && !(n === l) ? this._moveToLineStartByView(e, t, i) : this._moveToLineStartByModel(e, t, i);
  }
  static _moveToLineStartByView(e, t, i) {
    return Ye.fromViewState(gt.moveToBeginningOfLine(e.cursorConfig, e, t.viewState, i));
  }
  static _moveToLineStartByModel(e, t, i) {
    return Ye.fromModelState(gt.moveToBeginningOfLine(e.cursorConfig, e.model, t.modelState, i));
  }
  static moveToEndOfLine(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = this._moveToLineEnd(e, l, i, n);
    }
    return o;
  }
  static _moveToLineEnd(e, t, i, n) {
    const o = t.viewState.position, r = e.getLineMaxColumn(o.lineNumber), a = o.column === r, l = t.modelState.position, c = e.model.getLineMaxColumn(l.lineNumber), d = r - o.column === c - l.column;
    return a || d ? this._moveToLineEndByModel(e, t, i, n) : this._moveToLineEndByView(e, t, i, n);
  }
  static _moveToLineEndByView(e, t, i, n) {
    return Ye.fromViewState(gt.moveToEndOfLine(e.cursorConfig, e, t.viewState, i, n));
  }
  static _moveToLineEndByModel(e, t, i, n) {
    return Ye.fromModelState(gt.moveToEndOfLine(e.cursorConfig, e.model, t.modelState, i, n));
  }
  static expandLineSelection(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n], a = r.modelState.selection.startLineNumber, l = e.model.getLineCount();
      let c = r.modelState.selection.endLineNumber, d;
      c === l ? d = e.model.getLineMaxColumn(l) : (c++, d = 1), i[n] = Ye.fromModelState(new Vi(new E(a, 1, a, 1), 0, 0, new F(c, d), 0));
    }
    return i;
  }
  static moveToBeginningOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Ye.fromModelState(gt.moveToBeginningOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static moveToEndOfBuffer(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      n[o] = Ye.fromModelState(gt.moveToEndOfBuffer(e.cursorConfig, e.model, a.modelState, i));
    }
    return n;
  }
  static selectAll(e, t) {
    const i = e.model.getLineCount(), n = e.model.getLineMaxColumn(i);
    return Ye.fromModelState(new Vi(new E(1, 1, 1, 1), 0, 0, new F(i, n), 0));
  }
  static line(e, t, i, n, o) {
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new F(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    if (!i) {
      const c = e.model.getLineCount();
      let d = r.lineNumber + 1, h = 1;
      return d > c && (d = c, h = e.model.getLineMaxColumn(d)), Ye.fromModelState(new Vi(new E(r.lineNumber, 1, d, h), 2, 0, new F(d, h), 0));
    }
    const l = t.modelState.selectionStart.getStartPosition().lineNumber;
    if (r.lineNumber < l)
      return Ye.fromViewState(t.viewState.move(!0, a.lineNumber, 1, 0));
    if (r.lineNumber > l) {
      const c = e.getLineCount();
      let d = a.lineNumber + 1, h = 1;
      return d > c && (d = c, h = e.getLineMaxColumn(d)), Ye.fromViewState(t.viewState.move(!0, d, h, 0));
    } else {
      const c = t.modelState.selectionStart.getEndPosition();
      return Ye.fromModelState(t.modelState.move(!0, c.lineNumber, c.column, 0));
    }
  }
  static word(e, t, i, n) {
    const o = e.model.validatePosition(n);
    return Ye.fromModelState(Wt.word(e.cursorConfig, e.model, t.modelState, i, o));
  }
  static cancelSelection(e, t) {
    if (!t.modelState.hasSelection())
      return new Ye(t.modelState, t.viewState);
    const i = t.viewState.position.lineNumber, n = t.viewState.position.column;
    return Ye.fromViewState(new Vi(new E(i, n, i, n), 0, 0, new F(i, n), 0));
  }
  static moveTo(e, t, i, n, o) {
    if (i) {
      if (t.modelState.selectionStartKind === 1)
        return this.word(e, t, i, n);
      if (t.modelState.selectionStartKind === 2)
        return this.line(e, t, i, n, o);
    }
    const r = e.model.validatePosition(n), a = o ? e.coordinatesConverter.validateViewPosition(new F(o.lineNumber, o.column), r) : e.coordinatesConverter.convertModelPositionToViewPosition(r);
    return Ye.fromViewState(t.viewState.move(i, a.lineNumber, a.column, 0));
  }
  static simpleMove(e, t, i, n, o, r) {
    switch (i) {
      case 0:
        return r === 4 ? this._moveHalfLineLeft(e, t, n) : this._moveLeft(e, t, n, o);
      case 1:
        return r === 4 ? this._moveHalfLineRight(e, t, n) : this._moveRight(e, t, n, o);
      case 2:
        return r === 2 ? this._moveUpByViewLines(e, t, n, o) : this._moveUpByModelLines(e, t, n, o);
      case 3:
        return r === 2 ? this._moveDownByViewLines(e, t, n, o) : this._moveDownByModelLines(e, t, n, o);
      case 4:
        return r === 2 ? t.map((a) => Ye.fromViewState(gt.moveToPrevBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ye.fromModelState(gt.moveToPrevBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 5:
        return r === 2 ? t.map((a) => Ye.fromViewState(gt.moveToNextBlankLine(e.cursorConfig, e, a.viewState, n))) : t.map((a) => Ye.fromModelState(gt.moveToNextBlankLine(e.cursorConfig, e.model, a.modelState, n)));
      case 6:
        return this._moveToViewMinColumn(e, t, n);
      case 7:
        return this._moveToViewFirstNonWhitespaceColumn(e, t, n);
      case 8:
        return this._moveToViewCenterColumn(e, t, n);
      case 9:
        return this._moveToViewMaxColumn(e, t, n);
      case 10:
        return this._moveToViewLastNonWhitespaceColumn(e, t, n);
      default:
        return null;
    }
  }
  static viewportMove(e, t, i, n, o) {
    const r = e.getCompletelyVisibleViewRange(), a = e.coordinatesConverter.convertViewRangeToModelRange(r);
    switch (i) {
      case 11: {
        const l = this._firstLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 13: {
        const l = this._lastLineNumberInRange(e.model, a, o), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 12: {
        const l = Math.round((a.startLineNumber + a.endLineNumber) / 2), c = e.model.getLineFirstNonWhitespaceColumn(l);
        return [this._moveToModelPosition(e, t[0], n, l, c)];
      }
      case 14: {
        const l = [];
        for (let c = 0, d = t.length; c < d; c++) {
          const h = t[c];
          l[c] = this.findPositionInViewportIfOutside(e, h, r, n);
        }
        return l;
      }
      default:
        return null;
    }
  }
  static findPositionInViewportIfOutside(e, t, i, n) {
    const o = t.viewState.position.lineNumber;
    if (i.startLineNumber <= o && o <= i.endLineNumber - 1)
      return new Ye(t.modelState, t.viewState);
    {
      let r;
      o > i.endLineNumber - 1 ? r = i.endLineNumber - 1 : o < i.startLineNumber ? r = i.startLineNumber : r = o;
      const a = gt.vertical(e.cursorConfig, e, o, t.viewState.position.column, t.viewState.leftoverVisibleColumns, r, !1);
      return Ye.fromViewState(t.viewState.move(n, a.lineNumber, a.column, a.leftoverVisibleColumns));
    }
  }
  /**
   * Find the nth line start included in the range (from the start).
   */
  static _firstLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.min(t.endLineNumber, n + i - 1);
  }
  /**
   * Find the nth line start included in the range (from the end).
   */
  static _lastLineNumberInRange(e, t, i) {
    let n = t.startLineNumber;
    return t.startColumn !== e.getLineMinColumn(n) && n++, Math.max(n, t.endLineNumber - i + 1);
  }
  static _moveLeft(e, t, i, n) {
    return t.map((o) => Ye.fromViewState(gt.moveLeft(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineLeft(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Ye.fromViewState(gt.moveLeft(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveRight(e, t, i, n) {
    return t.map((o) => Ye.fromViewState(gt.moveRight(e.cursorConfig, e, o.viewState, i, n)));
  }
  static _moveHalfLineRight(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round(e.getLineLength(l) / 2);
      n[o] = Ye.fromViewState(gt.moveRight(e.cursorConfig, e, a.viewState, i, c));
    }
    return n;
  }
  static _moveDownByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ye.fromViewState(gt.moveDown(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveDownByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ye.fromModelState(gt.moveDown(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveUpByViewLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ye.fromViewState(gt.moveUp(e.cursorConfig, e, l.viewState, i, n));
    }
    return o;
  }
  static _moveUpByModelLines(e, t, i, n) {
    const o = [];
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      o[r] = Ye.fromModelState(gt.moveUp(e.cursorConfig, e.model, l.modelState, i, n));
    }
    return o;
  }
  static _moveToViewPosition(e, t, i, n, o) {
    return Ye.fromViewState(t.viewState.move(i, n, o, 0));
  }
  static _moveToModelPosition(e, t, i, n, o) {
    return Ye.fromModelState(t.modelState.move(i, n, o, 0));
  }
  static _moveToViewMinColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMinColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewFirstNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineFirstNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewCenterColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = Math.round((e.getLineMaxColumn(l) + e.getLineMinColumn(l)) / 2);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewMaxColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineMaxColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
  static _moveToViewLastNonWhitespaceColumn(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.viewState.position.lineNumber, c = e.getLineLastNonWhitespaceColumn(l);
      n[o] = this._moveToViewPosition(e, a, i, l, c);
    }
    return n;
  }
}
var yv;
(function(s) {
  const e = function(i) {
    if (!Ti(i))
      return !1;
    const n = i;
    return !(!_s(n.to) || !Mn(n.select) && !V4(n.select) || !Mn(n.by) && !_s(n.by) || !Mn(n.value) && !id(n.value));
  };
  s.metadata = {
    description: "Move cursor to a logical position in the view",
    args: [
      {
        name: "Cursor move argument object",
        description: `Property-value pairs that can be passed through this argument:
					* 'to': A mandatory logical position value providing where to move the cursor.
						\`\`\`
						'left', 'right', 'up', 'down', 'prevBlankLine', 'nextBlankLine',
						'wrappedLineStart', 'wrappedLineEnd', 'wrappedLineColumnCenter'
						'wrappedLineFirstNonWhitespaceCharacter', 'wrappedLineLastNonWhitespaceCharacter'
						'viewPortTop', 'viewPortCenter', 'viewPortBottom', 'viewPortIfOutside'
						\`\`\`
					* 'by': Unit to move. Default is computed based on 'to' value.
						\`\`\`
						'line', 'wrappedLine', 'character', 'halfLine'
						\`\`\`
					* 'value': Number of units to move. Default is '1'.
					* 'select': If 'true' makes the selection. Default is 'false'.
				`,
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["left", "right", "up", "down", "prevBlankLine", "nextBlankLine", "wrappedLineStart", "wrappedLineEnd", "wrappedLineColumnCenter", "wrappedLineFirstNonWhitespaceCharacter", "wrappedLineLastNonWhitespaceCharacter", "viewPortTop", "viewPortCenter", "viewPortBottom", "viewPortIfOutside"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "character", "halfLine"]
            },
            value: {
              type: "number",
              default: 1
            },
            select: {
              type: "boolean",
              default: !1
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Left: "left",
    Right: "right",
    Up: "up",
    Down: "down",
    PrevBlankLine: "prevBlankLine",
    NextBlankLine: "nextBlankLine",
    WrappedLineStart: "wrappedLineStart",
    WrappedLineFirstNonWhitespaceCharacter: "wrappedLineFirstNonWhitespaceCharacter",
    WrappedLineColumnCenter: "wrappedLineColumnCenter",
    WrappedLineEnd: "wrappedLineEnd",
    WrappedLineLastNonWhitespaceCharacter: "wrappedLineLastNonWhitespaceCharacter",
    ViewPortTop: "viewPortTop",
    ViewPortCenter: "viewPortCenter",
    ViewPortBottom: "viewPortBottom",
    ViewPortIfOutside: "viewPortIfOutside"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Character: "character",
    HalfLine: "halfLine"
  };
  function t(i) {
    if (!i.to)
      return null;
    let n;
    switch (i.to) {
      case s.RawDirection.Left:
        n = 0;
        break;
      case s.RawDirection.Right:
        n = 1;
        break;
      case s.RawDirection.Up:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.PrevBlankLine:
        n = 4;
        break;
      case s.RawDirection.NextBlankLine:
        n = 5;
        break;
      case s.RawDirection.WrappedLineStart:
        n = 6;
        break;
      case s.RawDirection.WrappedLineFirstNonWhitespaceCharacter:
        n = 7;
        break;
      case s.RawDirection.WrappedLineColumnCenter:
        n = 8;
        break;
      case s.RawDirection.WrappedLineEnd:
        n = 9;
        break;
      case s.RawDirection.WrappedLineLastNonWhitespaceCharacter:
        n = 10;
        break;
      case s.RawDirection.ViewPortTop:
        n = 11;
        break;
      case s.RawDirection.ViewPortBottom:
        n = 13;
        break;
      case s.RawDirection.ViewPortCenter:
        n = 12;
        break;
      case s.RawDirection.ViewPortIfOutside:
        n = 14;
        break;
      default:
        return null;
    }
    let o = 0;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Character:
        o = 3;
        break;
      case s.RawUnit.HalfLine:
        o = 4;
        break;
    }
    return {
      direction: n,
      unit: o,
      select: !!i.select,
      value: i.value || 1
    };
  }
  s.parse = t;
})(yv || (yv = {}));
class Bse {
  constructor(e, t, i) {
    this._indentRulesSupport = t, this._indentationLineProcessor = new I8(e, i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be increased after the given line number
   */
  shouldIncrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIncrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should be decreased after the given line number
   */
  shouldDecrease(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldDecrease(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should remain unchanged at the given line number
   */
  shouldIgnore(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIgnore(i);
  }
  /**
   * Apply the new indentation and return whether the indentation level should increase on the line after the given line number
   */
  shouldIndentNextLine(e, t) {
    const i = this._indentationLineProcessor.getProcessedLine(e, t);
    return this._indentRulesSupport.shouldIndentNextLine(i);
  }
}
class NT {
  constructor(e, t) {
    this.model = e, this.indentationLineProcessor = new I8(e, t);
  }
  /**
   * Returns the processed text, stripped from the language configuration brackets within the string, comment and regex tokens, around the given range
   */
  getProcessedTokenContextAroundRange(e) {
    const t = this._getProcessedTokensBeforeRange(e), i = this._getProcessedTokensAfterRange(e), n = this._getProcessedPreviousLineTokens(e);
    return { beforeRangeProcessedTokens: t, afterRangeProcessedTokens: i, previousLineProcessedTokens: n };
  }
  _getProcessedTokensBeforeRange(e) {
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const t = this.model.tokenization.getLineTokens(e.startLineNumber), i = wh(t, e.startColumn - 1);
    let n;
    if (TT(this.model, e.getStartPosition())) {
      const r = e.startColumn - 1 - i.firstCharOffset, a = i.firstCharOffset, l = a + r;
      n = t.sliceAndInflate(a, l, 0);
    } else {
      const r = e.startColumn - 1;
      n = t.sliceAndInflate(0, r, 0);
    }
    return this.indentationLineProcessor.getProcessedTokens(n);
  }
  _getProcessedTokensAfterRange(e) {
    const t = e.isEmpty() ? e.getStartPosition() : e.getEndPosition();
    this.model.tokenization.forceTokenization(t.lineNumber);
    const i = this.model.tokenization.getLineTokens(t.lineNumber), n = wh(i, t.column - 1), o = t.column - 1 - n.firstCharOffset, r = n.firstCharOffset + o, a = n.firstCharOffset + n.getLineLength(), l = i.sliceAndInflate(r, a, 0);
    return this.indentationLineProcessor.getProcessedTokens(l);
  }
  _getProcessedPreviousLineTokens(e) {
    const t = (g) => {
      this.model.tokenization.forceTokenization(g);
      const m = this.model.tokenization.getLineTokens(g), p = this.model.getLineMaxColumn(g) - 1;
      return wh(m, p);
    };
    this.model.tokenization.forceTokenization(e.startLineNumber);
    const i = this.model.tokenization.getLineTokens(e.startLineNumber), n = wh(i, e.startColumn - 1), o = Gi.createEmpty("", n.languageIdCodec), r = e.startLineNumber - 1;
    if (r === 0 || !(n.firstCharOffset === 0))
      return o;
    const c = t(r);
    if (!(n.languageId === c.languageId))
      return o;
    const h = c.toIViewLineTokens();
    return this.indentationLineProcessor.getProcessedTokens(h);
  }
}
class I8 {
  constructor(e, t) {
    this.model = e, this.languageConfigurationService = t;
  }
  /**
   * Get the processed line for the given line number and potentially adjust the indentation level.
   * Remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedLine(e, t) {
    const i = (r, a) => {
      const l = Ii(r);
      return a + r.substring(l.length);
    };
    this.model.tokenization.forceTokenization?.(e);
    const n = this.model.tokenization.getLineTokens(e);
    let o = this.getProcessedTokens(n).getLineContent();
    return t !== void 0 && (o = i(o, t)), o;
  }
  /**
   * Process the line with the given tokens, remove the language configuration brackets from the regex, string and comment tokens.
   */
  getProcessedTokens(e) {
    const t = (l) => l === 2 || l === 3 || l === 1, i = e.getLanguageId(0), o = this.languageConfigurationService.getLanguageConfiguration(i).bracketsNew.getBracketRegExp({ global: !0 }), r = [];
    return e.forEach((l) => {
      const c = e.getStandardTokenType(l);
      let d = e.getTokenText(l);
      t(c) && (d = d.replace(o, ""));
      const h = e.getMetadata(l);
      r.push({ text: d, metadata: h });
    }), Gi.createFromTextAndMetadata(r, e.languageIdCodec);
  }
}
function TT(s, e) {
  s.tokenization.forceTokenization(e.lineNumber);
  const t = s.tokenization.getLineTokens(e.lineNumber), i = wh(t, e.column - 1), n = i.firstCharOffset === 0, o = t.getLanguageId(0) === i.languageId;
  return !n && !o;
}
function BT(s, e, t, i) {
  e.tokenization.forceTokenization(t.startLineNumber);
  const n = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), o = i.getLanguageConfiguration(n);
  if (!o)
    return null;
  const a = new NT(e, i).getProcessedTokenContextAroundRange(t), l = a.previousLineProcessedTokens.getLineContent(), c = a.beforeRangeProcessedTokens.getLineContent(), d = a.afterRangeProcessedTokens.getLineContent(), h = o.onEnter(s, l, c, d);
  if (!h)
    return null;
  const u = h.indentAction;
  let g = h.appendText;
  const m = h.removeText || 0;
  g ? u === Tn.Indent && (g = "	" + g) : u === Tn.Indent || u === Tn.IndentOutdent ? g = "	" : g = "";
  let p = p5(e, t.startLineNumber, t.startColumn);
  return m && (p = p.substring(0, p.length - m)), {
    indentAction: u,
    appendText: g,
    removeText: m,
    indentation: p
  };
}
var Rse = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Fse = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ow;
const ex = /* @__PURE__ */ Object.create(null);
function Rd(s, e) {
  if (e <= 0)
    return "";
  ex[s] || (ex[s] = ["", s]);
  const t = ex[s];
  for (let i = t.length; i <= e; i++)
    t[i] = t[i - 1] + s;
  return t[e];
}
let Lu = Ow = class {
  static unshiftIndent(e, t, i, n, o) {
    const r = wi.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Rd(" ", n), c = wi.prevIndentTabStop(r, n) / n;
      return Rd(a, c);
    } else {
      const a = "	", c = wi.prevRenderTabStop(r, i) / i;
      return Rd(a, c);
    }
  }
  static shiftIndent(e, t, i, n, o) {
    const r = wi.visibleColumnFromColumn(e, t, i);
    if (o) {
      const a = Rd(" ", n), c = wi.nextIndentTabStop(r, n) / n;
      return Rd(a, c);
    } else {
      const a = "	", c = wi.nextRenderTabStop(r, i) / i;
      return Rd(a, c);
    }
  }
  constructor(e, t, i) {
    this._languageConfigurationService = i, this._opts = t, this._selection = e, this._selectionId = null, this._useLastEditRangeForCursorEndPosition = !1, this._selectionStartColumnStaysPut = !1;
  }
  _addEditOperation(e, t, i) {
    this._useLastEditRangeForCursorEndPosition ? e.addTrackedEditOperation(t, i) : e.addEditOperation(t, i);
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber;
    let n = this._selection.endLineNumber;
    this._selection.endColumn === 1 && i !== n && (n = n - 1);
    const { tabSize: o, indentSize: r, insertSpaces: a } = this._opts, l = i === n;
    if (this._opts.useTabStops) {
      this._selection.isEmpty() && /^\s*$/.test(e.getLineContent(i)) && (this._useLastEditRangeForCursorEndPosition = !0);
      let c = 0, d = 0;
      for (let h = i; h <= n; h++, c = d) {
        d = 0;
        const u = e.getLineContent(h);
        let g = Sn(u);
        if (this._opts.isUnshift && (u.length === 0 || g === 0) || !l && !this._opts.isUnshift && u.length === 0)
          continue;
        if (g === -1 && (g = u.length), h > 1 && wi.visibleColumnFromColumn(u, g + 1, o) % r !== 0 && e.tokenization.isCheapToTokenize(h - 1)) {
          const A = BT(this._opts.autoIndent, e, new E(h - 1, e.getLineMaxColumn(h - 1), h - 1, e.getLineMaxColumn(h - 1)), this._languageConfigurationService);
          if (A) {
            if (d = c, A.appendText)
              for (let _ = 0, b = A.appendText.length; _ < b && d < r && A.appendText.charCodeAt(_) === 32; _++)
                d++;
            A.removeText && (d = Math.max(0, d - A.removeText));
            for (let _ = 0; _ < d && !(g === 0 || u.charCodeAt(g - 1) !== 32); _++)
              g--;
          }
        }
        if (this._opts.isUnshift && g === 0)
          continue;
        let m;
        this._opts.isUnshift ? m = Ow.unshiftIndent(u, g + 1, o, r, a) : m = Ow.shiftIndent(u, g + 1, o, r, a), this._addEditOperation(t, new E(h, 1, h, g + 1), m), h === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn <= g + 1);
      }
    } else {
      !this._opts.isUnshift && this._selection.isEmpty() && e.getLineLength(i) === 0 && (this._useLastEditRangeForCursorEndPosition = !0);
      const c = a ? Rd(" ", r) : "	";
      for (let d = i; d <= n; d++) {
        const h = e.getLineContent(d);
        let u = Sn(h);
        if (!(this._opts.isUnshift && (h.length === 0 || u === 0)) && !(!l && !this._opts.isUnshift && h.length === 0) && (u === -1 && (u = h.length), !(this._opts.isUnshift && u === 0)))
          if (this._opts.isUnshift) {
            u = Math.min(u, r);
            for (let g = 0; g < u; g++)
              if (h.charCodeAt(g) === 9) {
                u = g + 1;
                break;
              }
            this._addEditOperation(t, new E(d, 1, d, u + 1), "");
          } else
            this._addEditOperation(t, new E(d, 1, d, 1), c), d === i && !this._selection.isEmpty() && (this._selectionStartColumnStaysPut = this._selection.startColumn === 1);
      }
    }
    this._selectionId = t.trackSelection(this._selection);
  }
  computeCursorState(e, t) {
    if (this._useLastEditRangeForCursorEndPosition) {
      const n = t.getInverseEditOperations()[0];
      return new Ue(n.range.endLineNumber, n.range.endColumn, n.range.endLineNumber, n.range.endColumn);
    }
    const i = t.getTrackedSelection(this._selectionId);
    if (this._selectionStartColumnStaysPut) {
      const n = this._selection.startColumn;
      return i.startColumn <= n ? i : i.getDirection() === 0 ? new Ue(i.startLineNumber, n, i.endLineNumber, i.endColumn) : new Ue(i.endLineNumber, i.endColumn, i.startLineNumber, n);
    }
    return i;
  }
};
Lu = Ow = Rse([
  Fse(2, tn)
], Lu);
class Ose {
  constructor(e, t, i) {
    this._range = e, this._charBeforeSelection = t, this._charAfterSelection = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new E(this._range.startLineNumber, this._range.startColumn, this._range.startLineNumber, this._range.startColumn), this._charBeforeSelection), t.addTrackedEditOperation(new E(this._range.endLineNumber, this._range.endColumn, this._range.endLineNumber, this._range.endColumn), this._charAfterSelection);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations(), n = i[0].range, o = i[1].range;
    return new Ue(n.endLineNumber, n.endColumn, o.endLineNumber, o.endColumn - this._charAfterSelection.length);
  }
}
class Pse {
  constructor(e, t, i) {
    this._position = e, this._text = t, this._charAfter = i;
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(new E(this._position.lineNumber, this._position.column, this._position.lineNumber, this._position.column), this._text + this._charAfter);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return new Ue(n.endLineNumber, n.startColumn, n.endLineNumber, n.endColumn - this._charAfter.length);
  }
}
function Hse(s, e, t) {
  const i = s.tokenization.getLanguageIdAtPosition(e, 0);
  if (e > 1) {
    let n, o = -1;
    for (n = e - 1; n >= 1; n--) {
      if (s.tokenization.getLanguageIdAtPosition(n, 0) !== i)
        return o;
      const r = s.getLineContent(n);
      if (t.shouldIgnore(n) || /^\s+$/.test(r) || r === "") {
        o = n;
        continue;
      }
      return n;
    }
  }
  return -1;
}
function xv(s, e, t, i = !0, n) {
  if (s < 4)
    return null;
  const o = n.getLanguageConfiguration(e.tokenization.getLanguageId()).indentRulesSupport;
  if (!o)
    return null;
  const r = new Bse(e, o, n);
  if (t <= 1)
    return {
      indentation: "",
      action: null
    };
  for (let l = t - 1; l > 0 && e.getLineContent(l) === ""; l--)
    if (l === 1)
      return {
        indentation: "",
        action: null
      };
  const a = Hse(e, t, r);
  if (a < 0)
    return null;
  if (a < 1)
    return {
      indentation: "",
      action: null
    };
  if (r.shouldIncrease(a) || r.shouldIndentNextLine(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: Ii(l),
      action: Tn.Indent,
      line: a
    };
  } else if (r.shouldDecrease(a)) {
    const l = e.getLineContent(a);
    return {
      indentation: Ii(l),
      action: null,
      line: a
    };
  } else {
    if (a === 1)
      return {
        indentation: Ii(e.getLineContent(a)),
        action: null,
        line: a
      };
    const l = a - 1, c = o.getIndentMetadata(e.getLineContent(l));
    if (!(c & 3) && c & 4) {
      let d = 0;
      for (let h = l - 1; h > 0; h--)
        if (!r.shouldIndentNextLine(h)) {
          d = h;
          break;
        }
      return {
        indentation: Ii(e.getLineContent(d + 1)),
        action: null,
        line: d + 1
      };
    }
    if (i)
      return {
        indentation: Ii(e.getLineContent(a)),
        action: null,
        line: a
      };
    for (let d = a; d > 0; d--) {
      if (r.shouldIncrease(d))
        return {
          indentation: Ii(e.getLineContent(d)),
          action: Tn.Indent,
          line: d
        };
      if (r.shouldIndentNextLine(d)) {
        let h = 0;
        for (let u = d - 1; u > 0; u--)
          if (!r.shouldIndentNextLine(d)) {
            h = u;
            break;
          }
        return {
          indentation: Ii(e.getLineContent(h + 1)),
          action: null,
          line: h + 1
        };
      } else if (r.shouldDecrease(d))
        return {
          indentation: Ii(e.getLineContent(d)),
          action: null,
          line: d
        };
    }
    return {
      indentation: Ii(e.getLineContent(1)),
      action: null,
      line: 1
    };
  }
}
function Wse(s, e, t, i, n) {
  if (s < 4)
    return null;
  const o = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), r = n.getLanguageConfiguration(o).indentRulesSupport;
  if (!r)
    return null;
  e.tokenization.forceTokenization(t.startLineNumber);
  const l = new NT(e, n).getProcessedTokenContextAroundRange(t), c = l.afterRangeProcessedTokens, d = l.beforeRangeProcessedTokens, h = Ii(d.getLineContent()), u = zse(e, t.startLineNumber, d), g = TT(e, t.getStartPosition()), m = e.getLineContent(t.startLineNumber), p = Ii(m), A = xv(s, u, t.startLineNumber + 1, void 0, n);
  if (!A) {
    const b = g ? p : h;
    return {
      beforeEnter: b,
      afterEnter: b
    };
  }
  let _ = g ? p : A.indentation;
  return A.action === Tn.Indent && (_ = i.shiftIndent(_)), r.shouldDecrease(c.getLineContent()) && (_ = i.unshiftIndent(_)), {
    beforeEnter: g ? p : h,
    afterEnter: _
  };
}
function Vse(s, e, t, i, n, o) {
  const r = s.autoIndent;
  if (r < 4 || TT(e, t.getStartPosition()))
    return null;
  const l = e.getLanguageIdAtPosition(t.startLineNumber, t.startColumn), c = o.getLanguageConfiguration(l).indentRulesSupport;
  if (!c)
    return null;
  const h = new NT(e, o).getProcessedTokenContextAroundRange(t), u = h.beforeRangeProcessedTokens.getLineContent(), g = h.afterRangeProcessedTokens.getLineContent(), m = u + g, p = u + i + g;
  if (!c.shouldDecrease(m) && c.shouldDecrease(p)) {
    const _ = xv(r, e, t.startLineNumber, !1, o);
    if (!_)
      return null;
    let b = _.indentation;
    return _.action !== Tn.Indent && (b = n.unshiftIndent(b)), b;
  }
  const A = t.startLineNumber - 1;
  if (A > 0) {
    const _ = e.getLineContent(A);
    if (c.shouldIndentNextLine(_) && c.shouldIncrease(p)) {
      const C = xv(r, e, t.startLineNumber, !1, o)?.indentation;
      if (C !== void 0) {
        const w = e.getLineContent(t.startLineNumber), S = Ii(w), y = n.shiftIndent(C) === S, D = /^\s*$/.test(m), I = s.autoClosingPairs.autoClosingPairsOpenByEnd.get(i), P = I && I.length > 0 && D;
        if (y && P)
          return C;
      }
    }
  }
  return null;
}
function zse(s, e, t) {
  return {
    tokenization: {
      getLineTokens: (n) => n === e ? t : s.tokenization.getLineTokens(n),
      getLanguageId: () => s.getLanguageId(),
      getLanguageIdAtPosition: (n, o) => s.getLanguageIdAtPosition(n, o)
    },
    getLineContent: (n) => n === e ? t.getLineContent() : s.getLineContent(n)
  };
}
class Use {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isAutoIndentType(e, t, i)) {
      const r = [];
      for (const l of i) {
        const c = this._findActualIndentationForSelection(e, t, l, n);
        if (c === null)
          return;
        r.push({ selection: l, indentation: c });
      }
      const a = bD.getAutoClosingPairClose(e, t, i, n, !1);
      return this._getIndentationAndAutoClosingPairEdits(e, t, r, n, a);
    }
  }
  static _isAutoIndentType(e, t, i) {
    if (e.autoIndent < 4)
      return !1;
    for (let n = 0, o = i.length; n < o; n++)
      if (!t.tokenization.isCheapToTokenize(i[n].getEndPosition().lineNumber))
        return !1;
    return !0;
  }
  static _findActualIndentationForSelection(e, t, i, n) {
    const o = Vse(e, t, i, n, {
      shiftIndent: (a) => OT(e, a),
      unshiftIndent: (a) => Ev(e, a)
    }, e.languageConfigurationService);
    if (o === null)
      return null;
    const r = p5(t, i.startLineNumber, i.startColumn);
    return o === e.normalizeIndentation(r) ? null : o;
  }
  static _getIndentationAndAutoClosingPairEdits(e, t, i, n, o) {
    const r = i.map(({ selection: l, indentation: c }) => {
      if (o !== null) {
        const d = this._getEditFromIndentationAndSelection(e, t, c, l, n, !1);
        return new eoe(d, l, n, o);
      } else {
        const d = this._getEditFromIndentationAndSelection(e, t, c, l, n, !0);
        return Yd(d.range, d.text, !1);
      }
    }), a = { shouldPushStackElementBefore: !0, shouldPushStackElementAfter: !1 };
    return new is(4, r, a);
  }
  static _getEditFromIndentationAndSelection(e, t, i, n, o, r = !0) {
    const a = n.startLineNumber, l = t.getLineFirstNonWhitespaceColumn(a);
    let c = e.normalizeIndentation(i);
    if (l !== 0) {
      const h = t.getLineContent(a);
      c += h.substring(l - 1, n.startColumn - 1);
    }
    return c += r ? o : "", { range: new E(a, 1, n.endLineNumber, n.endColumn), text: c };
  }
}
class Qse {
  static getEdits(e, t, i, n, o, r) {
    if (N8(t, i, n, o, r))
      return this._runAutoClosingOvertype(e, n, r);
  }
  static _runAutoClosingOvertype(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const l = t[o].getPosition(), c = new E(l.lineNumber, l.column, l.lineNumber, l.column + 1);
      n[o] = new vn(c, i);
    }
    return new is(4, n, {
      shouldPushStackElementBefore: yS(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
}
class Gse {
  static getEdits(e, t, i, n, o) {
    if (N8(e, t, i, n, o)) {
      const r = i.map((a) => new vn(new E(a.positionLineNumber, a.positionColumn, a.positionLineNumber, a.positionColumn + 1), "", !1));
      return new is(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
}
class bD {
  static getEdits(e, t, i, n, o, r) {
    if (!r) {
      const a = this.getAutoClosingPairClose(e, t, i, n, o);
      if (a !== null)
        return this._runAutoClosingOpenCharType(i, n, o, a);
    }
  }
  static _runAutoClosingOpenCharType(e, t, i, n) {
    const o = [];
    for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r];
      o[r] = new Zse(l, t, !i, n);
    }
    return new is(4, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !1
    });
  }
  static getAutoClosingPairClose(e, t, i, n, o) {
    for (const m of i)
      if (!m.isEmpty())
        return null;
    const r = i.map((m) => {
      const p = m.getPosition();
      return o ? { lineNumber: p.lineNumber, beforeColumn: p.column - n.length, afterColumn: p.column } : { lineNumber: p.lineNumber, beforeColumn: p.column, afterColumn: p.column };
    }), a = this._findAutoClosingPairOpen(e, t, r.map((m) => new F(m.lineNumber, m.beforeColumn)), n);
    if (!a)
      return null;
    let l, c;
    if (ud(n) ? (l = e.autoClosingQuotes, c = e.shouldAutoCloseBefore.quote) : (e.blockCommentStartToken ? a.open.includes(e.blockCommentStartToken) : !1) ? (l = e.autoClosingComments, c = e.shouldAutoCloseBefore.comment) : (l = e.autoClosingBrackets, c = e.shouldAutoCloseBefore.bracket), l === "never")
      return null;
    const h = this._findContainedAutoClosingPair(e, a), u = h ? h.close : "";
    let g = !0;
    for (const m of r) {
      const { lineNumber: p, beforeColumn: A, afterColumn: _ } = m, b = t.getLineContent(p), C = b.substring(0, A - 1), w = b.substring(_ - 1);
      if (w.startsWith(u) || (g = !1), w.length > 0) {
        const D = w.charAt(0);
        if (!this._isBeforeClosingBrace(e, w) && !c(D))
          return null;
      }
      if (a.open.length === 1 && (n === "'" || n === '"') && l !== "always") {
        const D = Eo(e.wordSeparators, []);
        if (C.length > 0) {
          const I = C.charCodeAt(C.length - 1);
          if (D.get(I) === 0)
            return null;
        }
      }
      if (!t.tokenization.isCheapToTokenize(p))
        return null;
      t.tokenization.forceTokenization(p);
      const S = t.tokenization.getLineTokens(p), x = wh(S, A - 1);
      if (!a.shouldAutoClose(x, A - x.firstCharOffset))
        return null;
      const y = a.findNeutralCharacter();
      if (y) {
        const D = t.tokenization.getTokenTypeIfInsertingCharacter(p, A, y);
        if (!a.isOK(D))
          return null;
      }
    }
    return g ? a.close.substring(0, a.close.length - u.length) : a.close;
  }
  /**
   * Find another auto-closing pair that is contained by the one passed in.
   *
   * e.g. when having [(,)] and [(*,*)] as auto-closing pairs
   * this method will find [(,)] as a containment pair for [(*,*)]
   */
  static _findContainedAutoClosingPair(e, t) {
    if (t.open.length <= 1)
      return null;
    const i = t.close.charAt(t.close.length - 1), n = e.autoClosingPairs.autoClosingPairsCloseByEnd.get(i) || [];
    let o = null;
    for (const r of n)
      r.open !== t.open && t.open.includes(r.open) && t.close.endsWith(r.close) && (!o || r.open.length > o.open.length) && (o = r);
    return o;
  }
  /**
   * Determine if typing `ch` at all `positions` in the `model` results in an
   * auto closing open sequence being typed.
   *
   * Auto closing open sequences can consist of multiple characters, which
   * can lead to ambiguities. In such a case, the longest auto-closing open
   * sequence is returned.
   */
  static _findAutoClosingPairOpen(e, t, i, n) {
    const o = e.autoClosingPairs.autoClosingPairsOpenByEnd.get(n);
    if (!o)
      return null;
    let r = null;
    for (const a of o)
      if (r === null || a.open.length > r.open.length) {
        let l = !0;
        for (const c of i)
          if (t.getValueInRange(new E(c.lineNumber, c.column - a.open.length + 1, c.lineNumber, c.column)) + n !== a.open) {
            l = !1;
            break;
          }
        l && (r = a);
      }
    return r;
  }
  static _isBeforeClosingBrace(e, t) {
    const i = t.charAt(0), n = e.autoClosingPairs.autoClosingPairsOpenByStart.get(i) || [], o = e.autoClosingPairs.autoClosingPairsCloseByStart.get(i) || [], r = n.some((l) => t.startsWith(l.open)), a = o.some((l) => t.startsWith(l.close));
    return !r && a;
  }
}
class jse {
  static getEdits(e, t, i, n, o) {
    if (!o && this._isSurroundSelectionType(e, t, i, n))
      return this._runSurroundSelectionType(e, i, n);
  }
  static _runSurroundSelectionType(e, t, i) {
    const n = [];
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = e.surroundingPairs[i];
      n[o] = new Ose(a, i, l);
    }
    return new is(0, n, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _isSurroundSelectionType(e, t, i, n) {
    if (!T8(e, n) || !e.surroundingPairs.hasOwnProperty(n))
      return !1;
    const o = ud(n);
    for (const r of i) {
      if (r.isEmpty())
        return !1;
      let a = !0;
      for (let l = r.startLineNumber; l <= r.endLineNumber; l++) {
        const c = t.getLineContent(l), d = l === r.startLineNumber ? r.startColumn - 1 : 0, h = l === r.endLineNumber ? r.endColumn - 1 : c.length, u = c.substring(d, h);
        if (/[^ \t]/.test(u)) {
          a = !1;
          break;
        }
      }
      if (a)
        return !1;
      if (o && r.startLineNumber === r.endLineNumber && r.startColumn + 1 === r.endColumn) {
        const l = t.getValueInRange(r);
        if (ud(l))
          return !1;
      }
    }
    return !0;
  }
}
class Yse {
  static getEdits(e, t, i, n, o, r) {
    if (!r && this._isTypeInterceptorElectricChar(t, i, n)) {
      const a = this._typeInterceptorElectricChar(e, t, i, n[0], o);
      if (a)
        return a;
    }
  }
  static _isTypeInterceptorElectricChar(e, t, i) {
    return !!(i.length === 1 && t.tokenization.isCheapToTokenize(i[0].getEndPosition().lineNumber));
  }
  static _typeInterceptorElectricChar(e, t, i, n, o) {
    if (!t.electricChars.hasOwnProperty(o) || !n.isEmpty())
      return null;
    const r = n.getPosition();
    i.tokenization.forceTokenization(r.lineNumber);
    const a = i.tokenization.getLineTokens(r.lineNumber);
    let l;
    try {
      l = t.onElectricCharacter(o, a, r.column);
    } catch (c) {
      return Pe(c), null;
    }
    if (!l)
      return null;
    if (l.matchOpenBracket) {
      const c = (a.getLineContent() + o).lastIndexOf(l.matchOpenBracket) + 1, d = i.bracketPairs.findMatchingBracketUp(
        l.matchOpenBracket,
        {
          lineNumber: r.lineNumber,
          column: c
        },
        500
        /* give at most 500ms to compute */
      );
      if (d) {
        if (d.startLineNumber === r.lineNumber)
          return null;
        const h = i.getLineContent(d.startLineNumber), u = Ii(h), g = t.normalizeIndentation(u), m = i.getLineContent(r.lineNumber), p = i.getLineFirstNonWhitespaceColumn(r.lineNumber) || r.column, A = m.substring(p - 1, r.column - 1), _ = g + A + o, b = new E(r.lineNumber, 1, r.lineNumber, r.column), C = new vn(b, _);
        return new is(FT(_, e), [C], {
          shouldPushStackElementBefore: !1,
          shouldPushStackElementAfter: !0
        });
      }
    }
    return null;
  }
}
class Kse {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new vn(t[r], i);
    const o = FT(i, e);
    return new is(o, n, {
      shouldPushStackElementBefore: yS(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class M8 {
  static getEdits(e, t, i, n, o) {
    if (!o && n === `
`) {
      const r = [];
      for (let a = 0, l = i.length; a < l; a++)
        r[a] = this._enter(e, t, !1, i[a]);
      return new is(4, r, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
  }
  static _enter(e, t, i, n) {
    if (e.autoIndent === 0)
      return Yd(n, `
`, i);
    if (!t.tokenization.isCheapToTokenize(n.getStartPosition().lineNumber) || e.autoIndent === 1) {
      const l = t.getLineContent(n.startLineNumber), c = Ii(l).substring(0, n.startColumn - 1);
      return Yd(n, `
` + e.normalizeIndentation(c), i);
    }
    const o = BT(e.autoIndent, t, n, e.languageConfigurationService);
    if (o) {
      if (o.indentAction === Tn.None)
        return Yd(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Tn.Indent)
        return Yd(n, `
` + e.normalizeIndentation(o.indentation + o.appendText), i);
      if (o.indentAction === Tn.IndentOutdent) {
        const l = e.normalizeIndentation(o.indentation), c = e.normalizeIndentation(o.indentation + o.appendText), d = `
` + c + `
` + l;
        return i ? new Fw(n, d, !0) : new Sv(n, d, -1, c.length - l.length, !0);
      } else if (o.indentAction === Tn.Outdent) {
        const l = Ev(e, o.indentation);
        return Yd(n, `
` + e.normalizeIndentation(l + o.appendText), i);
      }
    }
    const r = t.getLineContent(n.startLineNumber), a = Ii(r).substring(0, n.startColumn - 1);
    if (e.autoIndent >= 4) {
      const l = Wse(e.autoIndent, t, n, {
        unshiftIndent: (c) => Ev(e, c),
        shiftIndent: (c) => OT(e, c),
        normalizeIndentation: (c) => e.normalizeIndentation(c)
      }, e.languageConfigurationService);
      if (l) {
        let c = e.visibleColumnFromColumn(t, n.getEndPosition());
        const d = n.endColumn, h = t.getLineContent(n.endLineNumber), u = Sn(h);
        if (u >= 0 ? n = n.setEndPosition(n.endLineNumber, Math.max(n.endColumn, u + 1)) : n = n.setEndPosition(n.endLineNumber, t.getLineMaxColumn(n.endLineNumber)), i)
          return new Fw(n, `
` + e.normalizeIndentation(l.afterEnter), !0);
        {
          let g = 0;
          return d <= u + 1 && (e.insertSpaces || (c = Math.ceil(c / e.indentSize)), g = Math.min(c + 1 - e.normalizeIndentation(l.afterEnter).length - 1, 0)), new Sv(n, `
` + e.normalizeIndentation(l.afterEnter), 0, g, !0);
        }
      }
    }
    return Yd(n, `
` + e.normalizeIndentation(a), i);
  }
  static lineInsertBefore(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      let a = i[o].positionLineNumber;
      if (a === 1)
        n[o] = new Fw(new E(1, 1, 1, 1), `
`);
      else {
        a--;
        const l = t.getLineMaxColumn(a);
        n[o] = this._enter(e, t, !1, new E(a, l, a, l));
      }
    }
    return n;
  }
  static lineInsertAfter(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o].positionLineNumber, l = t.getLineMaxColumn(a);
      n[o] = this._enter(e, t, !1, new E(a, l, a, l));
    }
    return n;
  }
  static lineBreakInsert(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = this._enter(e, t, !0, i[o]);
    return n;
  }
}
class Jse {
  static getEdits(e, t, i, n, o, r) {
    const a = this._distributePasteToCursors(e, i, n, o, r);
    return a ? (i = i.sort(E.compareRangesUsingStarts), this._distributedPaste(e, t, i, a)) : this._simplePaste(e, t, i, n, o);
  }
  static _distributePasteToCursors(e, t, i, n, o) {
    if (n || t.length === 1)
      return null;
    if (o && o.length === t.length)
      return o;
    if (e.multiCursorPaste === "spread") {
      i.charCodeAt(i.length - 1) === 10 && (i = i.substring(0, i.length - 1)), i.charCodeAt(i.length - 1) === 13 && (i = i.substring(0, i.length - 1));
      const r = bd(i);
      if (r.length === t.length)
        return r;
    }
    return null;
  }
  static _distributedPaste(e, t, i, n) {
    const o = [];
    for (let r = 0, a = i.length; r < a; r++)
      o[r] = new vn(i[r], n[r]);
    return new is(0, o, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
  static _simplePaste(e, t, i, n, o) {
    const r = [];
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], d = c.getPosition();
      if (o && !c.isEmpty() && (o = !1), o && n.indexOf(`
`) !== n.length - 1 && (o = !1), o) {
        const h = new E(d.lineNumber, 1, d.lineNumber, 1);
        r[a] = new D8(h, n, c, !0);
      } else
        r[a] = new vn(c, n);
    }
    return new is(0, r, {
      shouldPushStackElementBefore: !0,
      shouldPushStackElementAfter: !0
    });
  }
}
class qse {
  static getEdits(e, t, i, n, o, r, a, l) {
    const c = n.map((d) => this._compositionType(i, d, o, r, a, l));
    return new is(4, c, {
      shouldPushStackElementBefore: yS(
        e,
        4
        /* EditOperationType.TypingOther */
      ),
      shouldPushStackElementAfter: !1
    });
  }
  static _compositionType(e, t, i, n, o, r) {
    if (!t.isEmpty())
      return null;
    const a = t.getPosition(), l = Math.max(1, a.column - n), c = Math.min(e.getLineMaxColumn(a.lineNumber), a.column + o), d = new E(a.lineNumber, l, a.lineNumber, c);
    return e.getValueInRange(d) === i && r === 0 ? null : new Sv(d, i, 0, r);
  }
}
class $se {
  static getEdits(e, t, i) {
    const n = [];
    for (let r = 0, a = t.length; r < a; r++)
      n[r] = new vn(t[r], i);
    const o = FT(i, e);
    return new is(o, n, {
      shouldPushStackElementBefore: yS(e, o),
      shouldPushStackElementAfter: !1
    });
  }
}
class Xse {
  static getCommands(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++) {
      const a = i[o];
      if (a.isEmpty()) {
        const l = t.getLineContent(a.startLineNumber);
        if (/^\s*$/.test(l) && t.tokenization.isCheapToTokenize(a.startLineNumber)) {
          let c = this._goodIndentForLine(e, t, a.startLineNumber);
          c = c || "	";
          const d = e.normalizeIndentation(c);
          if (!l.startsWith(d)) {
            n[o] = new vn(new E(a.startLineNumber, 1, a.startLineNumber, l.length + 1), d, !0);
            continue;
          }
        }
        n[o] = this._replaceJumpToNextIndent(e, t, a, !0);
      } else {
        if (a.startLineNumber === a.endLineNumber) {
          const l = t.getLineMaxColumn(a.startLineNumber);
          if (a.startColumn !== 1 || a.endColumn !== l) {
            n[o] = this._replaceJumpToNextIndent(e, t, a, !1);
            continue;
          }
        }
        n[o] = new Lu(a, {
          isUnshift: !1,
          tabSize: e.tabSize,
          indentSize: e.indentSize,
          insertSpaces: e.insertSpaces,
          useTabStops: e.useTabStops,
          autoIndent: e.autoIndent
        }, e.languageConfigurationService);
      }
    }
    return n;
  }
  static _goodIndentForLine(e, t, i) {
    let n = null, o = "";
    const r = xv(e.autoIndent, t, i, !1, e.languageConfigurationService);
    if (r)
      n = r.action, o = r.indentation;
    else if (i > 1) {
      let a;
      for (a = i - 1; a >= 1; a--) {
        const d = t.getLineContent(a);
        if (Ru(d) >= 0)
          break;
      }
      if (a < 1)
        return null;
      const l = t.getLineMaxColumn(a), c = BT(e.autoIndent, t, new E(a, l, a, l), e.languageConfigurationService);
      c && (o = c.indentation + c.appendText);
    }
    return n && (n === Tn.Indent && (o = OT(e, o)), n === Tn.Outdent && (o = Ev(e, o)), o = e.normalizeIndentation(o)), o || null;
  }
  static _replaceJumpToNextIndent(e, t, i, n) {
    let o = "";
    const r = i.getStartPosition();
    if (e.insertSpaces) {
      const a = e.visibleColumnFromColumn(t, r), l = e.indentSize, c = l - a % l;
      for (let d = 0; d < c; d++)
        o += " ";
    } else
      o = "	";
    return new vn(i, o, n);
  }
}
class RT extends Sv {
  constructor(e, t, i, n, o, r) {
    super(e, t, i, n), this._openCharacter = o, this._closeCharacter = r, this.closeCharacterRange = null, this.enclosingRange = null;
  }
  _computeCursorStateWithRange(e, t, i) {
    return this.closeCharacterRange = new E(t.startLineNumber, t.endColumn - this._closeCharacter.length, t.endLineNumber, t.endColumn), this.enclosingRange = new E(t.startLineNumber, t.endColumn - this._openCharacter.length - this._closeCharacter.length, t.endLineNumber, t.endColumn), super.computeCursorState(e, i);
  }
}
class Zse extends RT {
  constructor(e, t, i, n) {
    const o = (i ? t : "") + n, r = 0, a = -n.length;
    super(e, o, r, a, t, n);
  }
  computeCursorState(e, t) {
    const n = t.getInverseEditOperations()[0].range;
    return this._computeCursorStateWithRange(e, n, t);
  }
}
class eoe extends RT {
  constructor(e, t, i, n) {
    const o = i + n, r = 0, a = i.length;
    super(t, o, r, a, i, n), this._autoIndentationEdit = e, this._autoClosingEdit = { range: t, text: o };
  }
  getEditOperations(e, t) {
    t.addTrackedEditOperation(this._autoIndentationEdit.range, this._autoIndentationEdit.text), t.addTrackedEditOperation(this._autoClosingEdit.range, this._autoClosingEdit.text);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length !== 2)
      throw new Error("There should be two inverse edit operations!");
    const n = i[0].range, o = i[1].range, r = n.plusRange(o);
    return this._computeCursorStateWithRange(e, r, t);
  }
}
function FT(s, e) {
  return s === " " ? e === 5 || e === 6 ? 6 : 5 : 4;
}
function yS(s, e) {
  return MO(s) && !MO(e) ? !0 : s === 5 ? !1 : IO(s) !== IO(e);
}
function IO(s) {
  return s === 6 || s === 5 ? "space" : s;
}
function MO(s) {
  return s === 4 || s === 5 || s === 6;
}
function N8(s, e, t, i, n) {
  if (s.autoClosingOvertype === "never" || !s.autoClosingPairs.autoClosingPairsCloseSingleChar.has(n))
    return !1;
  for (let o = 0, r = t.length; o < r; o++) {
    const a = t[o];
    if (!a.isEmpty())
      return !1;
    const l = a.getPosition(), c = e.getLineContent(l.lineNumber);
    if (c.charAt(l.column - 1) !== n)
      return !1;
    const h = ud(n);
    if ((l.column > 2 ? c.charCodeAt(l.column - 2) : 0) === 92 && h)
      return !1;
    if (s.autoClosingOvertype === "auto") {
      let g = !1;
      for (let m = 0, p = i.length; m < p; m++) {
        const A = i[m];
        if (l.lineNumber === A.startLineNumber && l.column === A.startColumn) {
          g = !0;
          break;
        }
      }
      if (!g)
        return !1;
    }
  }
  return !0;
}
function Yd(s, e, t) {
  return t ? new Fw(s, e, !0) : new vn(s, e, !0);
}
function OT(s, e, t) {
  return t = t || 1, Lu.shiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function Ev(s, e, t) {
  return t = t || 1, Lu.unshiftIndent(e, e.length + t, s.tabSize, s.indentSize, s.insertSpaces);
}
function T8(s, e) {
  return ud(e) ? s.autoSurround === "quotes" || s.autoSurround === "languageDefined" : s.autoSurround === "brackets" || s.autoSurround === "languageDefined";
}
class lh {
  static indent(e, t, i) {
    if (t === null || i === null)
      return [];
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new Lu(i[o], {
        isUnshift: !1,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static outdent(e, t, i) {
    const n = [];
    for (let o = 0, r = i.length; o < r; o++)
      n[o] = new Lu(i[o], {
        isUnshift: !0,
        tabSize: e.tabSize,
        indentSize: e.indentSize,
        insertSpaces: e.insertSpaces,
        useTabStops: e.useTabStops,
        autoIndent: e.autoIndent
      }, e.languageConfigurationService);
    return n;
  }
  static paste(e, t, i, n, o, r) {
    return Jse.getEdits(e, t, i, n, o, r);
  }
  static tab(e, t, i) {
    return Xse.getCommands(e, t, i);
  }
  static compositionType(e, t, i, n, o, r, a, l) {
    return qse.getEdits(e, t, i, n, o, r, a, l);
  }
  /**
   * This is very similar with typing, but the character is already in the text buffer!
   */
  static compositionEndWithInterceptors(e, t, i, n, o, r) {
    if (!n)
      return null;
    let a = null;
    for (const u of n)
      if (a === null)
        a = u.insertedText;
      else if (a !== u.insertedText)
        return null;
    if (!a || a.length !== 1)
      return null;
    const l = a;
    let c = !1;
    for (const u of n)
      if (u.deletedText.length !== 0) {
        c = !0;
        break;
      }
    if (c) {
      if (!T8(t, l) || !t.surroundingPairs.hasOwnProperty(l))
        return null;
      const u = ud(l);
      for (const p of n)
        if (p.deletedSelectionStart !== 0 || p.deletedSelectionEnd !== p.deletedText.length || /^[ \t]+$/.test(p.deletedText) || u && ud(p.deletedText))
          return null;
      const g = [];
      for (const p of o) {
        if (!p.isEmpty())
          return null;
        g.push(p.getPosition());
      }
      if (g.length !== n.length)
        return null;
      const m = [];
      for (let p = 0, A = g.length; p < A; p++)
        m.push(new Pse(g[p], n[p].deletedText, t.surroundingPairs[l]));
      return new is(4, m, {
        shouldPushStackElementBefore: !0,
        shouldPushStackElementAfter: !1
      });
    }
    const d = Gse.getEdits(t, i, o, r, l);
    if (d !== void 0)
      return d;
    const h = bD.getEdits(t, i, o, l, !0, !1);
    return h !== void 0 ? h : null;
  }
  static typeWithInterceptors(e, t, i, n, o, r, a) {
    const l = M8.getEdits(i, n, o, a, e);
    if (l !== void 0)
      return l;
    const c = Use.getEdits(i, n, o, a, e);
    if (c !== void 0)
      return c;
    const d = Qse.getEdits(t, i, n, o, r, a);
    if (d !== void 0)
      return d;
    const h = bD.getEdits(i, n, o, a, !1, e);
    if (h !== void 0)
      return h;
    const u = jse.getEdits(i, n, o, a, e);
    if (u !== void 0)
      return u;
    const g = Yse.getEdits(t, i, n, o, a, e);
    return g !== void 0 ? g : Kse.getEdits(t, o, a);
  }
  static typeWithoutInterceptors(e, t, i, n, o) {
    return $se.getEdits(e, n, o);
  }
}
class toe {
  constructor(e, t, i, n, o, r) {
    this.deletedText = e, this.deletedSelectionStart = t, this.deletedSelectionEnd = i, this.insertedText = n, this.insertedSelectionStart = o, this.insertedSelectionEnd = r;
  }
}
var R;
(function(s) {
  s.editorSimpleInput = new le("editorSimpleInput", !1, !0), s.editorTextFocus = new le("editorTextFocus", !1, f("editorTextFocus", "Whether the editor text has focus (cursor is blinking)")), s.focus = new le("editorFocus", !1, f("editorFocus", "Whether the editor or an editor widget has focus (e.g. focus is in the find widget)")), s.textInputFocus = new le("textInputFocus", !1, f("textInputFocus", "Whether an editor or a rich text input has focus (cursor is blinking)")), s.readOnly = new le("editorReadonly", !1, f("editorReadonly", "Whether the editor is read-only")), s.inDiffEditor = new le("inDiffEditor", !1, f("inDiffEditor", "Whether the context is a diff editor")), s.isEmbeddedDiffEditor = new le("isEmbeddedDiffEditor", !1, f("isEmbeddedDiffEditor", "Whether the context is an embedded diff editor")), s.inMultiDiffEditor = new le("inMultiDiffEditor", !1, f("inMultiDiffEditor", "Whether the context is a multi diff editor")), s.multiDiffEditorAllCollapsed = new le("multiDiffEditorAllCollapsed", void 0, f("multiDiffEditorAllCollapsed", "Whether all files in multi diff editor are collapsed")), s.hasChanges = new le("diffEditorHasChanges", !1, f("diffEditorHasChanges", "Whether the diff editor has changes")), s.comparingMovedCode = new le("comparingMovedCode", !1, f("comparingMovedCode", "Whether a moved code block is selected for comparison")), s.accessibleDiffViewerVisible = new le("accessibleDiffViewerVisible", !1, f("accessibleDiffViewerVisible", "Whether the accessible diff viewer is visible")), s.diffEditorRenderSideBySideInlineBreakpointReached = new le("diffEditorRenderSideBySideInlineBreakpointReached", !1, f("diffEditorRenderSideBySideInlineBreakpointReached", "Whether the diff editor render side by side inline breakpoint is reached")), s.diffEditorInlineMode = new le("diffEditorInlineMode", !1, f("diffEditorInlineMode", "Whether inline mode is active")), s.diffEditorOriginalWritable = new le("diffEditorOriginalWritable", !1, f("diffEditorOriginalWritable", "Whether modified is writable in the diff editor")), s.diffEditorModifiedWritable = new le("diffEditorModifiedWritable", !1, f("diffEditorModifiedWritable", "Whether modified is writable in the diff editor")), s.diffEditorOriginalUri = new le("diffEditorOriginalUri", "", f("diffEditorOriginalUri", "The uri of the original document")), s.diffEditorModifiedUri = new le("diffEditorModifiedUri", "", f("diffEditorModifiedUri", "The uri of the modified document")), s.columnSelection = new le("editorColumnSelection", !1, f("editorColumnSelection", "Whether `editor.columnSelection` is enabled")), s.writable = s.readOnly.toNegated(), s.hasNonEmptySelection = new le("editorHasSelection", !1, f("editorHasSelection", "Whether the editor has text selected")), s.hasOnlyEmptySelection = s.hasNonEmptySelection.toNegated(), s.hasMultipleSelections = new le("editorHasMultipleSelections", !1, f("editorHasMultipleSelections", "Whether the editor has multiple selections")), s.hasSingleSelection = s.hasMultipleSelections.toNegated(), s.tabMovesFocus = new le("editorTabMovesFocus", !1, f("editorTabMovesFocus", "Whether `Tab` will move focus out of the editor")), s.tabDoesNotMoveFocus = s.tabMovesFocus.toNegated(), s.isInEmbeddedEditor = new le("isInEmbeddedEditor", !1, !0), s.canUndo = new le("canUndo", !1, !0), s.canRedo = new le("canRedo", !1, !0), s.hoverVisible = new le("editorHoverVisible", !1, f("editorHoverVisible", "Whether the editor hover is visible")), s.hoverFocused = new le("editorHoverFocused", !1, f("editorHoverFocused", "Whether the editor hover is focused")), s.stickyScrollFocused = new le("stickyScrollFocused", !1, f("stickyScrollFocused", "Whether the sticky scroll is focused")), s.stickyScrollVisible = new le("stickyScrollVisible", !1, f("stickyScrollVisible", "Whether the sticky scroll is visible")), s.standaloneColorPickerVisible = new le("standaloneColorPickerVisible", !1, f("standaloneColorPickerVisible", "Whether the standalone color picker is visible")), s.standaloneColorPickerFocused = new le("standaloneColorPickerFocused", !1, f("standaloneColorPickerFocused", "Whether the standalone color picker is focused")), s.inCompositeEditor = new le("inCompositeEditor", void 0, f("inCompositeEditor", "Whether the editor is part of a larger editor (e.g. notebooks)")), s.notInCompositeEditor = s.inCompositeEditor.toNegated(), s.languageId = new le("editorLangId", "", f("editorLangId", "The language identifier of the editor")), s.hasCompletionItemProvider = new le("editorHasCompletionItemProvider", !1, f("editorHasCompletionItemProvider", "Whether the editor has a completion item provider")), s.hasCodeActionsProvider = new le("editorHasCodeActionsProvider", !1, f("editorHasCodeActionsProvider", "Whether the editor has a code actions provider")), s.hasCodeLensProvider = new le("editorHasCodeLensProvider", !1, f("editorHasCodeLensProvider", "Whether the editor has a code lens provider")), s.hasDefinitionProvider = new le("editorHasDefinitionProvider", !1, f("editorHasDefinitionProvider", "Whether the editor has a definition provider")), s.hasDeclarationProvider = new le("editorHasDeclarationProvider", !1, f("editorHasDeclarationProvider", "Whether the editor has a declaration provider")), s.hasImplementationProvider = new le("editorHasImplementationProvider", !1, f("editorHasImplementationProvider", "Whether the editor has an implementation provider")), s.hasTypeDefinitionProvider = new le("editorHasTypeDefinitionProvider", !1, f("editorHasTypeDefinitionProvider", "Whether the editor has a type definition provider")), s.hasHoverProvider = new le("editorHasHoverProvider", !1, f("editorHasHoverProvider", "Whether the editor has a hover provider")), s.hasDocumentHighlightProvider = new le("editorHasDocumentHighlightProvider", !1, f("editorHasDocumentHighlightProvider", "Whether the editor has a document highlight provider")), s.hasDocumentSymbolProvider = new le("editorHasDocumentSymbolProvider", !1, f("editorHasDocumentSymbolProvider", "Whether the editor has a document symbol provider")), s.hasReferenceProvider = new le("editorHasReferenceProvider", !1, f("editorHasReferenceProvider", "Whether the editor has a reference provider")), s.hasRenameProvider = new le("editorHasRenameProvider", !1, f("editorHasRenameProvider", "Whether the editor has a rename provider")), s.hasSignatureHelpProvider = new le("editorHasSignatureHelpProvider", !1, f("editorHasSignatureHelpProvider", "Whether the editor has a signature help provider")), s.hasInlayHintsProvider = new le("editorHasInlayHintsProvider", !1, f("editorHasInlayHintsProvider", "Whether the editor has an inline hints provider")), s.hasDocumentFormattingProvider = new le("editorHasDocumentFormattingProvider", !1, f("editorHasDocumentFormattingProvider", "Whether the editor has a document formatting provider")), s.hasDocumentSelectionFormattingProvider = new le("editorHasDocumentSelectionFormattingProvider", !1, f("editorHasDocumentSelectionFormattingProvider", "Whether the editor has a document selection formatting provider")), s.hasMultipleDocumentFormattingProvider = new le("editorHasMultipleDocumentFormattingProvider", !1, f("editorHasMultipleDocumentFormattingProvider", "Whether the editor has multiple document formatting providers")), s.hasMultipleDocumentSelectionFormattingProvider = new le("editorHasMultipleDocumentSelectionFormattingProvider", !1, f("editorHasMultipleDocumentSelectionFormattingProvider", "Whether the editor has multiple document selection formatting providers"));
})(R || (R = {}));
const st = 0;
class Jt extends Wn {
  runEditorCommand(e, t, i) {
    const n = t._getViewModel();
    n && this.runCoreEditorCommand(n, i || {});
  }
}
var qi;
(function(s) {
  const e = function(i) {
    if (!Ti(i))
      return !1;
    const n = i;
    return !(!_s(n.to) || !Mn(n.by) && !_s(n.by) || !Mn(n.value) && !id(n.value) || !Mn(n.revealCursor) && !V4(n.revealCursor));
  };
  s.metadata = {
    description: "Scroll editor in the given direction",
    args: [
      {
        name: "Editor scroll argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'to': A mandatory direction value.\n						```\n						'up', 'down'\n						```\n					* 'by': Unit to move. Default is computed based on 'to' value.\n						```\n						'line', 'wrappedLine', 'page', 'halfPage', 'editor'\n						```\n					* 'value': Number of units to move. Default is '1'.\n					* 'revealCursor': If 'true' reveals the cursor if it is outside view port.\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["to"],
          properties: {
            to: {
              type: "string",
              enum: ["up", "down"]
            },
            by: {
              type: "string",
              enum: ["line", "wrappedLine", "page", "halfPage", "editor"]
            },
            value: {
              type: "number",
              default: 1
            },
            revealCursor: {
              type: "boolean"
            }
          }
        }
      }
    ]
  }, s.RawDirection = {
    Up: "up",
    Right: "right",
    Down: "down",
    Left: "left"
  }, s.RawUnit = {
    Line: "line",
    WrappedLine: "wrappedLine",
    Page: "page",
    HalfPage: "halfPage",
    Editor: "editor",
    Column: "column"
  };
  function t(i) {
    let n;
    switch (i.to) {
      case s.RawDirection.Up:
        n = 1;
        break;
      case s.RawDirection.Right:
        n = 2;
        break;
      case s.RawDirection.Down:
        n = 3;
        break;
      case s.RawDirection.Left:
        n = 4;
        break;
      default:
        return null;
    }
    let o;
    switch (i.by) {
      case s.RawUnit.Line:
        o = 1;
        break;
      case s.RawUnit.WrappedLine:
        o = 2;
        break;
      case s.RawUnit.Page:
        o = 3;
        break;
      case s.RawUnit.HalfPage:
        o = 4;
        break;
      case s.RawUnit.Editor:
        o = 5;
        break;
      case s.RawUnit.Column:
        o = 6;
        break;
      default:
        o = 2;
    }
    const r = Math.floor(i.value || 1), a = !!i.revealCursor;
    return {
      direction: n,
      unit: o,
      value: r,
      revealCursor: a,
      select: !!i.select
    };
  }
  s.parse = t;
})(qi || (qi = {}));
var Qg;
(function(s) {
  const e = function(t) {
    if (!Ti(t))
      return !1;
    const i = t;
    return !(!id(i.lineNumber) && !_s(i.lineNumber) || !Mn(i.at) && !_s(i.at));
  };
  s.metadata = {
    description: "Reveal the given line at the given logical position",
    args: [
      {
        name: "Reveal line argument object",
        description: "Property-value pairs that can be passed through this argument:\n					* 'lineNumber': A mandatory line number value.\n					* 'at': Logical position at which line has to be revealed.\n						```\n						'top', 'center', 'bottom'\n						```\n				",
        constraint: e,
        schema: {
          type: "object",
          required: ["lineNumber"],
          properties: {
            lineNumber: {
              type: ["number", "string"]
            },
            at: {
              type: "string",
              enum: ["top", "center", "bottom"]
            }
          }
        }
      }
    ]
  }, s.RawAtArgument = {
    Top: "top",
    Center: "center",
    Bottom: "bottom"
  };
})(Qg || (Qg = {}));
class wD {
  constructor(e) {
    e.addImplementation(1e4, "code-editor", (t, i) => {
      const n = t.get(Nt).getFocusedCodeEditor();
      return n && n.hasTextFocus() ? this._runEditorCommand(t, n, i) : !1;
    }), e.addImplementation(1e3, "generic-dom-input-textarea", (t, i) => {
      const n = ln();
      return n && ["input", "textarea"].indexOf(n.tagName.toLowerCase()) >= 0 ? (this.runDOMCommand(n), !0) : !1;
    }), e.addImplementation(0, "generic-dom", (t, i) => {
      const n = t.get(Nt).getActiveCodeEditor();
      return n ? (n.focus(), this._runEditorCommand(t, n, i)) : !1;
    });
  }
  _runEditorCommand(e, t, i) {
    const n = this.runEditorCommand(e, t, i);
    return n || !0;
  }
}
var Li;
(function(s) {
  class e extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        gn.moveTo(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]) && C.revealType !== 2 && b.revealAllCursors(C.source, !0, !0);
    }
  }
  s.MoveTo = re(new e({
    id: "_moveTo",
    inSelectionMode: !1,
    precondition: void 0
  })), s.MoveToSelect = re(new e({
    id: "_moveToSelect",
    inSelectionMode: !0,
    precondition: void 0
  }));
  class t extends Jt {
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement();
      const w = this._getColumnSelectResult(b, b.getPrimaryCursorState(), b.getCursorColumnSelectData(), C);
      w !== null && (b.setCursorStates(C.source, 3, w.viewStates.map((S) => Ye.fromViewState(S))), b.setCursorColumnSelectData({
        isReal: !0,
        fromViewLineNumber: w.fromLineNumber,
        fromViewVisualColumn: w.fromVisualColumn,
        toViewLineNumber: w.toLineNumber,
        toViewVisualColumn: w.toVisualColumn
      }), w.reversed ? b.revealTopMostCursor(C.source) : b.revealBottomMostCursor(C.source));
    }
  }
  s.ColumnSelect = re(new class extends t {
    constructor() {
      super({
        id: "columnSelect",
        precondition: void 0
      });
    }
    _getColumnSelectResult(_, b, C, w) {
      if (typeof w.position > "u" || typeof w.viewPosition > "u" || typeof w.mouseColumn > "u")
        return null;
      const S = _.model.validatePosition(w.position), x = _.coordinatesConverter.validateViewPosition(new F(w.viewPosition.lineNumber, w.viewPosition.column), S), y = w.doColumnSelect ? C.fromViewLineNumber : x.lineNumber, D = w.doColumnSelect ? C.fromViewVisualColumn : w.mouseColumn - 1;
      return ah.columnSelect(_.cursorConfig, _, y, D, x.lineNumber, w.mouseColumn - 1);
    }
  }()), s.CursorColumnSelectLeft = re(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectLeft",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 3599,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(_, b, C, w) {
      return ah.columnSelectLeft(_.cursorConfig, _, C);
    }
  }()), s.CursorColumnSelectRight = re(new class extends t {
    constructor() {
      super({
        id: "cursorColumnSelectRight",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 3601,
          linux: { primary: 0 }
        }
      });
    }
    _getColumnSelectResult(_, b, C, w) {
      return ah.columnSelectRight(_.cursorConfig, _, C);
    }
  }());
  class i extends t {
    constructor(b) {
      super(b), this._isPaged = b.isPaged;
    }
    _getColumnSelectResult(b, C, w, S) {
      return ah.columnSelectUp(b.cursorConfig, b, w, this._isPaged);
    }
  }
  s.CursorColumnSelectUp = re(new i({
    isPaged: !1,
    id: "cursorColumnSelectUp",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3600,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageUp = re(new i({
    isPaged: !0,
    id: "cursorColumnSelectPageUp",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3595,
      linux: { primary: 0 }
    }
  }));
  class n extends t {
    constructor(b) {
      super(b), this._isPaged = b.isPaged;
    }
    _getColumnSelectResult(b, C, w, S) {
      return ah.columnSelectDown(b.cursorConfig, b, w, this._isPaged);
    }
  }
  s.CursorColumnSelectDown = re(new n({
    isPaged: !1,
    id: "cursorColumnSelectDown",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3602,
      linux: { primary: 0 }
    }
  })), s.CursorColumnSelectPageDown = re(new n({
    isPaged: !0,
    id: "cursorColumnSelectPageDown",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3596,
      linux: { primary: 0 }
    }
  }));
  class o extends Jt {
    constructor() {
      super({
        id: "cursorMove",
        precondition: void 0,
        metadata: yv.metadata
      });
    }
    runCoreEditorCommand(b, C) {
      const w = yv.parse(C);
      w && this._runCursorMove(b, C.source, w);
    }
    _runCursorMove(b, C, w) {
      b.model.pushStackElement(), b.setCursorStates(C, 3, o._move(b, b.getCursorStates(), w)), b.revealAllCursors(C, !0);
    }
    static _move(b, C, w) {
      const S = w.select, x = w.value;
      switch (w.direction) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
          return gn.simpleMove(b, C, w.direction, S, x, w.unit);
        case 11:
        case 13:
        case 12:
        case 14:
          return gn.viewportMove(b, C, w.direction, S, x);
        default:
          return null;
      }
    }
  }
  s.CursorMoveImpl = o, s.CursorMove = re(new o());
  class r extends Jt {
    constructor(b) {
      super(b), this._staticArgs = b.args;
    }
    runCoreEditorCommand(b, C) {
      let w = this._staticArgs;
      this._staticArgs.value === -1 && (w = {
        direction: this._staticArgs.direction,
        unit: this._staticArgs.unit,
        select: this._staticArgs.select,
        value: C.pageSize || b.cursorConfig.pageSize
      }), b.model.pushStackElement(), b.setCursorStates(C.source, 3, gn.simpleMove(b, b.getCursorStates(), w.direction, w.select, w.value, w.unit)), b.revealAllCursors(C.source, !0);
    }
  }
  s.CursorLeft = re(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorLeft",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 15,
      mac: { primary: 15, secondary: [
        288
        /* KeyCode.KeyB */
      ] }
    }
  })), s.CursorLeftSelect = re(new r({
    args: {
      direction: 0,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorLeftSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1039
      /* KeyCode.LeftArrow */
    }
  })), s.CursorRight = re(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !1,
      value: 1
    },
    id: "cursorRight",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 17,
      mac: { primary: 17, secondary: [
        292
        /* KeyCode.KeyF */
      ] }
    }
  })), s.CursorRightSelect = re(new r({
    args: {
      direction: 1,
      unit: 0,
      select: !0,
      value: 1
    },
    id: "cursorRightSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1041
      /* KeyCode.RightArrow */
    }
  })), s.CursorUp = re(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorUp",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 16,
      mac: { primary: 16, secondary: [
        302
        /* KeyCode.KeyP */
      ] }
    }
  })), s.CursorUpSelect = re(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1040,
      secondary: [
        3088
        /* KeyCode.UpArrow */
      ],
      mac: {
        primary: 1040
        /* KeyCode.UpArrow */
      },
      linux: {
        primary: 1040
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorPageUp = re(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUp",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 11
      /* KeyCode.PageUp */
    }
  })), s.CursorPageUpSelect = re(new r({
    args: {
      direction: 2,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageUpSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1035
      /* KeyCode.PageUp */
    }
  })), s.CursorDown = re(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: 1
    },
    id: "cursorDown",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 18,
      mac: { primary: 18, secondary: [
        300
        /* KeyCode.KeyN */
      ] }
    }
  })), s.CursorDownSelect = re(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: 1
    },
    id: "cursorDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1042,
      secondary: [
        3090
        /* KeyCode.DownArrow */
      ],
      mac: {
        primary: 1042
        /* KeyCode.DownArrow */
      },
      linux: {
        primary: 1042
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorPageDown = re(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !1,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDown",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 12
      /* KeyCode.PageDown */
    }
  })), s.CursorPageDownSelect = re(new r({
    args: {
      direction: 3,
      unit: 2,
      select: !0,
      value: -1
      /* Constants.PAGE_SIZE_MARKER */
    },
    id: "cursorPageDownSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1036
      /* KeyCode.PageDown */
    }
  })), s.CreateCursor = re(new class extends Jt {
    constructor() {
      super({
        id: "createCursor",
        precondition: void 0
      });
    }
    runCoreEditorCommand(_, b) {
      if (!b.position)
        return;
      let C;
      b.wholeLine ? C = gn.line(_, _.getPrimaryCursorState(), !1, b.position, b.viewPosition) : C = gn.moveTo(_, _.getPrimaryCursorState(), !1, b.position, b.viewPosition);
      const w = _.getCursorStates();
      if (w.length > 1) {
        const S = C.modelState ? C.modelState.position : null, x = C.viewState ? C.viewState.position : null;
        for (let y = 0, D = w.length; y < D; y++) {
          const I = w[y];
          if (!(S && !I.modelState.selection.containsPosition(S)) && !(x && !I.viewState.selection.containsPosition(x))) {
            w.splice(y, 1), _.model.pushStackElement(), _.setCursorStates(b.source, 3, w);
            return;
          }
        }
      }
      w.push(C), _.model.pushStackElement(), _.setCursorStates(b.source, 3, w);
    }
  }()), s.LastCursorMoveToSelect = re(new class extends Jt {
    constructor() {
      super({
        id: "_lastCursorMoveToSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(_, b) {
      if (!b.position)
        return;
      const C = _.getLastAddedCursorIndex(), w = _.getCursorStates(), S = w.slice(0);
      S[C] = gn.moveTo(_, w[C], !0, b.position, b.viewPosition), _.model.pushStackElement(), _.setCursorStates(b.source, 3, S);
    }
  }());
  class a extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, gn.moveToBeginningOfLine(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  s.CursorHome = re(new a({
    inSelectionMode: !1,
    id: "cursorHome",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 14,
      mac: { primary: 14, secondary: [
        2063
        /* KeyCode.LeftArrow */
      ] }
    }
  })), s.CursorHomeSelect = re(new a({
    inSelectionMode: !0,
    id: "cursorHomeSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1038,
      mac: { primary: 1038, secondary: [
        3087
        /* KeyCode.LeftArrow */
      ] }
    }
  }));
  class l extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, this._exec(b.getCursorStates())), b.revealAllCursors(C.source, !0);
    }
    _exec(b) {
      const C = [];
      for (let w = 0, S = b.length; w < S; w++) {
        const x = b[w], y = x.modelState.position.lineNumber;
        C[w] = Ye.fromModelState(x.modelState.move(this._inSelectionMode, y, 1, 0));
      }
      return C;
    }
  }
  s.CursorLineStart = re(new l({
    inSelectionMode: !1,
    id: "cursorLineStart",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 0,
      mac: {
        primary: 287
        /* KeyCode.KeyA */
      }
    }
  })), s.CursorLineStartSelect = re(new l({
    inSelectionMode: !0,
    id: "cursorLineStartSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 0,
      mac: {
        primary: 1311
        /* KeyCode.KeyA */
      }
    }
  }));
  class c extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, gn.moveToEndOfLine(b, b.getCursorStates(), this._inSelectionMode, C.sticky || !1)), b.revealAllCursors(C.source, !0);
    }
  }
  s.CursorEnd = re(new c({
    inSelectionMode: !1,
    id: "cursorEnd",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 13,
      mac: { primary: 13, secondary: [
        2065
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Go to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: f("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  })), s.CursorEndSelect = re(new c({
    inSelectionMode: !0,
    id: "cursorEndSelect",
    precondition: void 0,
    kbOpts: {
      args: { sticky: !1 },
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 1037,
      mac: { primary: 1037, secondary: [
        3089
        /* KeyCode.RightArrow */
      ] }
    },
    metadata: {
      description: "Select to End",
      args: [{
        name: "args",
        schema: {
          type: "object",
          properties: {
            sticky: {
              description: f("stickydesc", "Stick to the end even when going to longer lines"),
              type: "boolean",
              default: !1
            }
          }
        }
      }]
    }
  }));
  class d extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, this._exec(b, b.getCursorStates())), b.revealAllCursors(C.source, !0);
    }
    _exec(b, C) {
      const w = [];
      for (let S = 0, x = C.length; S < x; S++) {
        const y = C[S], D = y.modelState.position.lineNumber, I = b.model.getLineMaxColumn(D);
        w[S] = Ye.fromModelState(y.modelState.move(this._inSelectionMode, D, I, 0));
      }
      return w;
    }
  }
  s.CursorLineEnd = re(new d({
    inSelectionMode: !1,
    id: "cursorLineEnd",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 0,
      mac: {
        primary: 291
        /* KeyCode.KeyE */
      }
    }
  })), s.CursorLineEndSelect = re(new d({
    inSelectionMode: !0,
    id: "cursorLineEndSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 0,
      mac: {
        primary: 1315
        /* KeyCode.KeyE */
      }
    }
  }));
  class h extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, gn.moveToBeginningOfBuffer(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  s.CursorTop = re(new h({
    inSelectionMode: !1,
    id: "cursorTop",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 2062,
      mac: {
        primary: 2064
        /* KeyCode.UpArrow */
      }
    }
  })), s.CursorTopSelect = re(new h({
    inSelectionMode: !0,
    id: "cursorTopSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3086,
      mac: {
        primary: 3088
        /* KeyCode.UpArrow */
      }
    }
  }));
  class u extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      b.model.pushStackElement(), b.setCursorStates(C.source, 3, gn.moveToEndOfBuffer(b, b.getCursorStates(), this._inSelectionMode)), b.revealAllCursors(C.source, !0);
    }
  }
  s.CursorBottom = re(new u({
    inSelectionMode: !1,
    id: "cursorBottom",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 2061,
      mac: {
        primary: 2066
        /* KeyCode.DownArrow */
      }
    }
  })), s.CursorBottomSelect = re(new u({
    inSelectionMode: !0,
    id: "cursorBottomSelect",
    precondition: void 0,
    kbOpts: {
      weight: st,
      kbExpr: R.textInputFocus,
      primary: 3085,
      mac: {
        primary: 3090
        /* KeyCode.DownArrow */
      }
    }
  }));
  class g extends Jt {
    constructor() {
      super({
        id: "editorScroll",
        precondition: void 0,
        metadata: qi.metadata
      });
    }
    determineScrollMethod(b) {
      const C = [
        6
        /* EditorScroll_.Unit.Column */
      ], w = [
        1,
        2,
        3,
        4,
        5,
        6
        /* EditorScroll_.Unit.Column */
      ], S = [
        4,
        2
        /* EditorScroll_.Direction.Right */
      ], x = [
        1,
        3
        /* EditorScroll_.Direction.Down */
      ];
      return C.includes(b.unit) && S.includes(b.direction) ? this._runHorizontalEditorScroll.bind(this) : w.includes(b.unit) && x.includes(b.direction) ? this._runVerticalEditorScroll.bind(this) : null;
    }
    runCoreEditorCommand(b, C) {
      const w = qi.parse(C);
      if (!w)
        return;
      const S = this.determineScrollMethod(w);
      S && S(b, C.source, w);
    }
    _runVerticalEditorScroll(b, C, w) {
      const S = this._computeDesiredScrollTop(b, w);
      if (w.revealCursor) {
        const x = b.getCompletelyVisibleViewRangeAtScrollTop(S);
        b.setCursorStates(C, 3, [
          gn.findPositionInViewportIfOutside(b, b.getPrimaryCursorState(), x, w.select)
        ]);
      }
      b.viewLayout.setScrollPosition(
        { scrollTop: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollTop(b, C) {
      if (C.unit === 1) {
        const x = b.viewLayout.getFutureViewport(), y = b.getCompletelyVisibleViewRangeAtScrollTop(x.top), D = b.coordinatesConverter.convertViewRangeToModelRange(y);
        let I;
        C.direction === 1 ? I = Math.max(1, D.startLineNumber - C.value) : I = Math.min(b.model.getLineCount(), D.startLineNumber + C.value);
        const Q = b.coordinatesConverter.convertModelPositionToViewPosition(new F(I, 1));
        return b.viewLayout.getVerticalOffsetForLineNumber(Q.lineNumber);
      }
      if (C.unit === 5) {
        let x = 0;
        return C.direction === 3 && (x = b.model.getLineCount() - b.cursorConfig.pageSize), b.viewLayout.getVerticalOffsetForLineNumber(x);
      }
      let w;
      C.unit === 3 ? w = b.cursorConfig.pageSize * C.value : C.unit === 4 ? w = Math.round(b.cursorConfig.pageSize / 2) * C.value : w = C.value;
      const S = (C.direction === 1 ? -1 : 1) * w;
      return b.viewLayout.getCurrentScrollTop() + S * b.cursorConfig.lineHeight;
    }
    _runHorizontalEditorScroll(b, C, w) {
      const S = this._computeDesiredScrollLeft(b, w);
      b.viewLayout.setScrollPosition(
        { scrollLeft: S },
        0
        /* ScrollType.Smooth */
      );
    }
    _computeDesiredScrollLeft(b, C) {
      const w = (C.direction === 4 ? -1 : 1) * C.value;
      return b.viewLayout.getCurrentScrollLeft() + w * b.cursorConfig.typicalHalfwidthCharacterWidth;
    }
  }
  s.EditorScrollImpl = g, s.EditorScroll = re(new g()), s.ScrollLineUp = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollLineUp",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 2064,
          mac: {
            primary: 267
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Up,
        by: qi.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollPageUp = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollPageUp",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 2059,
          win: {
            primary: 523
            /* KeyCode.PageUp */
          },
          linux: {
            primary: 523
            /* KeyCode.PageUp */
          }
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Up,
        by: qi.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollEditorTop = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollEditorTop",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Up,
        by: qi.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollLineDown = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollLineDown",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 2066,
          mac: {
            primary: 268
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Down,
        by: qi.RawUnit.WrappedLine,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollPageDown = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollPageDown",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 2060,
          win: {
            primary: 524
            /* KeyCode.PageDown */
          },
          linux: {
            primary: 524
            /* KeyCode.PageDown */
          }
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Down,
        by: qi.RawUnit.Page,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollEditorBottom = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollEditorBottom",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Down,
        by: qi.RawUnit.Editor,
        value: 1,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollLeft = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollLeft",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Left,
        by: qi.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }()), s.ScrollRight = re(new class extends Jt {
    constructor() {
      super({
        id: "scrollRight",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus
        }
      });
    }
    runCoreEditorCommand(_, b) {
      s.EditorScroll.runCoreEditorCommand(_, {
        to: qi.RawDirection.Right,
        by: qi.RawUnit.Column,
        value: 2,
        revealCursor: !1,
        select: !1,
        source: b.source
      });
    }
  }());
  class m extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      C.position && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        gn.word(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position)
      ]), C.revealType !== 2 && b.revealAllCursors(C.source, !0, !0));
    }
  }
  s.WordSelect = re(new m({
    inSelectionMode: !1,
    id: "_wordSelect",
    precondition: void 0
  })), s.WordSelectDrag = re(new m({
    inSelectionMode: !0,
    id: "_wordSelectDrag",
    precondition: void 0
  })), s.LastCursorWordSelect = re(new class extends Jt {
    constructor() {
      super({
        id: "lastCursorWordSelect",
        precondition: void 0
      });
    }
    runCoreEditorCommand(_, b) {
      if (!b.position)
        return;
      const C = _.getLastAddedCursorIndex(), w = _.getCursorStates(), S = w.slice(0), x = w[C];
      S[C] = gn.word(_, x, x.modelState.hasSelection(), b.position), _.model.pushStackElement(), _.setCursorStates(b.source, 3, S);
    }
  }());
  class p extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      C.position && (b.model.pushStackElement(), b.setCursorStates(C.source, 3, [
        gn.line(b, b.getPrimaryCursorState(), this._inSelectionMode, C.position, C.viewPosition)
      ]), C.revealType !== 2 && b.revealAllCursors(C.source, !1, !0));
    }
  }
  s.LineSelect = re(new p({
    inSelectionMode: !1,
    id: "_lineSelect",
    precondition: void 0
  })), s.LineSelectDrag = re(new p({
    inSelectionMode: !0,
    id: "_lineSelectDrag",
    precondition: void 0
  }));
  class A extends Jt {
    constructor(b) {
      super(b), this._inSelectionMode = b.inSelectionMode;
    }
    runCoreEditorCommand(b, C) {
      if (!C.position)
        return;
      const w = b.getLastAddedCursorIndex(), S = b.getCursorStates(), x = S.slice(0);
      x[w] = gn.line(b, S[w], this._inSelectionMode, C.position, C.viewPosition), b.model.pushStackElement(), b.setCursorStates(C.source, 3, x);
    }
  }
  s.LastCursorLineSelect = re(new A({
    inSelectionMode: !1,
    id: "lastCursorLineSelect",
    precondition: void 0
  })), s.LastCursorLineSelectDrag = re(new A({
    inSelectionMode: !0,
    id: "lastCursorLineSelectDrag",
    precondition: void 0
  })), s.CancelSelection = re(new class extends Jt {
    constructor() {
      super({
        id: "cancelSelection",
        precondition: R.hasNonEmptySelection,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(_, b) {
      _.model.pushStackElement(), _.setCursorStates(b.source, 3, [
        gn.cancelSelection(_, _.getPrimaryCursorState())
      ]), _.revealAllCursors(b.source, !0);
    }
  }()), s.RemoveSecondaryCursors = re(new class extends Jt {
    constructor() {
      super({
        id: "removeSecondaryCursors",
        precondition: R.hasMultipleSelections,
        kbOpts: {
          weight: st + 1,
          kbExpr: R.textInputFocus,
          primary: 9,
          secondary: [
            1033
            /* KeyCode.Escape */
          ]
        }
      });
    }
    runCoreEditorCommand(_, b) {
      _.model.pushStackElement(), _.setCursorStates(b.source, 3, [
        _.getPrimaryCursorState()
      ]), _.revealAllCursors(b.source, !0), vu(f("removedCursor", "Removed secondary cursors"));
    }
  }()), s.RevealLine = re(new class extends Jt {
    constructor() {
      super({
        id: "revealLine",
        precondition: void 0,
        metadata: Qg.metadata
      });
    }
    runCoreEditorCommand(_, b) {
      const C = b, w = C.lineNumber || 0;
      let S = typeof w == "number" ? w + 1 : parseInt(w) + 1;
      S < 1 && (S = 1);
      const x = _.model.getLineCount();
      S > x && (S = x);
      const y = new E(S, 1, S, _.model.getLineMaxColumn(S));
      let D = 0;
      if (C.at)
        switch (C.at) {
          case Qg.RawAtArgument.Top:
            D = 3;
            break;
          case Qg.RawAtArgument.Center:
            D = 1;
            break;
          case Qg.RawAtArgument.Bottom:
            D = 4;
            break;
        }
      const I = _.coordinatesConverter.convertModelRangeToViewRange(y);
      _.revealRange(
        b.source,
        !1,
        I,
        D,
        0
        /* ScrollType.Smooth */
      );
    }
  }()), s.SelectAll = new class extends wD {
    constructor() {
      super(OU);
    }
    runDOMCommand(_) {
      Ko && (_.focus(), _.select()), _.ownerDocument.execCommand("selectAll");
    }
    runEditorCommand(_, b, C) {
      const w = b._getViewModel();
      w && this.runCoreEditorCommand(w, C);
    }
    runCoreEditorCommand(_, b) {
      _.model.pushStackElement(), _.setCursorStates("keyboard", 3, [
        gn.selectAll(_, _.getPrimaryCursorState())
      ]);
    }
  }(), s.SetSelection = re(new class extends Jt {
    constructor() {
      super({
        id: "setSelection",
        precondition: void 0
      });
    }
    runCoreEditorCommand(_, b) {
      b.selection && (_.model.pushStackElement(), _.setCursorStates(b.source, 3, [
        Ye.fromModelSelection(b.selection)
      ]));
    }
  }());
})(Li || (Li = {}));
const ioe = ne.and(R.textInputFocus, R.columnSelection);
function Dm(s, e) {
  Hn.registerKeybindingRule({
    id: s,
    primary: e,
    when: ioe,
    weight: st + 1
  });
}
Dm(
  Li.CursorColumnSelectLeft.id,
  1039
  /* KeyCode.LeftArrow */
);
Dm(
  Li.CursorColumnSelectRight.id,
  1041
  /* KeyCode.RightArrow */
);
Dm(
  Li.CursorColumnSelectUp.id,
  1040
  /* KeyCode.UpArrow */
);
Dm(
  Li.CursorColumnSelectPageUp.id,
  1035
  /* KeyCode.PageUp */
);
Dm(
  Li.CursorColumnSelectDown.id,
  1042
  /* KeyCode.DownArrow */
);
Dm(
  Li.CursorColumnSelectPageDown.id,
  1036
  /* KeyCode.PageDown */
);
function NO(s) {
  return s.register(), s;
}
var TO;
(function(s) {
  class e extends Wn {
    runEditorCommand(i, n, o) {
      const r = n._getViewModel();
      r && this.runCoreEditingCommand(n, r, o || {});
    }
  }
  s.CoreEditingCommand = e, s.LineBreakInsert = re(new class extends e {
    constructor() {
      super({
        id: "lineBreakInsert",
        precondition: R.writable,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 0,
          mac: {
            primary: 301
            /* KeyCode.KeyO */
          }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, M8.lineBreakInsert(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection)));
    }
  }()), s.Outdent = re(new class extends e {
    constructor() {
      super({
        id: "outdent",
        precondition: R.writable,
        kbOpts: {
          weight: st,
          kbExpr: ne.and(R.editorTextFocus, R.tabDoesNotMoveFocus),
          primary: 1026
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, lh.outdent(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.Tab = re(new class extends e {
    constructor() {
      super({
        id: "tab",
        precondition: R.writable,
        kbOpts: {
          weight: st,
          kbExpr: ne.and(R.editorTextFocus, R.tabDoesNotMoveFocus),
          primary: 2
          /* KeyCode.Tab */
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      t.pushUndoStop(), t.executeCommands(this.id, lh.tab(i.cursorConfig, i.model, i.getCursorStates().map((o) => o.modelState.selection))), t.pushUndoStop();
    }
  }()), s.DeleteLeft = re(new class extends e {
    constructor() {
      super({
        id: "deleteLeft",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 1,
          secondary: [
            1025
            /* KeyCode.Backspace */
          ],
          mac: { primary: 1, secondary: [
            1025,
            294,
            257
            /* KeyCode.Backspace */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = Eu.deleteLeft(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection), i.getCursorAutoClosedCharacters());
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        2
        /* EditOperationType.DeletingLeft */
      );
    }
  }()), s.DeleteRight = re(new class extends e {
    constructor() {
      super({
        id: "deleteRight",
        precondition: void 0,
        kbOpts: {
          weight: st,
          kbExpr: R.textInputFocus,
          primary: 20,
          mac: { primary: 20, secondary: [
            290,
            276
            /* KeyCode.Delete */
          ] }
        }
      });
    }
    runCoreEditingCommand(t, i, n) {
      const [o, r] = Eu.deleteRight(i.getPrevEditOperationType(), i.cursorConfig, i.model, i.getCursorStates().map((a) => a.modelState.selection));
      o && t.pushUndoStop(), t.executeCommands(this.id, r), i.setPrevEditOperationType(
        3
        /* EditOperationType.DeletingRight */
      );
    }
  }()), s.Undo = new class extends wD {
    constructor() {
      super(n5);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("undo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().undo();
    }
  }(), s.Redo = new class extends wD {
    constructor() {
      super(s5);
    }
    runDOMCommand(t) {
      t.ownerDocument.execCommand("redo");
    }
    runEditorCommand(t, i, n) {
      if (!(!i.hasModel() || i.getOption(
        92
        /* EditorOption.readOnly */
      ) === !0))
        return i.getModel().redo();
    }
  }();
})(TO || (TO = {}));
class BO extends B0 {
  constructor(e, t, i) {
    super({
      id: e,
      precondition: void 0,
      metadata: i
    }), this._handlerId = t;
  }
  runCommand(e, t) {
    const i = e.get(Nt).getFocusedCodeEditor();
    i && i.trigger("keyboard", this._handlerId, t);
  }
}
function Ju(s, e) {
  NO(new BO("default:" + s, s)), NO(new BO(s, s, e));
}
Ju("type", {
  description: "Type",
  args: [{
    name: "args",
    schema: {
      type: "object",
      required: ["text"],
      properties: {
        text: {
          type: "string"
        }
      }
    }
  }]
});
Ju(
  "replacePreviousChar"
  /* Handler.ReplacePreviousChar */
);
Ju(
  "compositionType"
  /* Handler.CompositionType */
);
Ju(
  "compositionStart"
  /* Handler.CompositionStart */
);
Ju(
  "compositionEnd"
  /* Handler.CompositionEnd */
);
Ju(
  "paste"
  /* Handler.Paste */
);
Ju(
  "cut"
  /* Handler.Cut */
);
class noe {
  constructor(e, t, i, n) {
    this.configuration = e, this.viewModel = t, this.userInputEvents = i, this.commandDelegate = n;
  }
  paste(e, t, i, n) {
    this.commandDelegate.paste(e, t, i, n);
  }
  type(e) {
    this.commandDelegate.type(e);
  }
  compositionType(e, t, i, n) {
    this.commandDelegate.compositionType(e, t, i, n);
  }
  compositionStart() {
    this.commandDelegate.startComposition();
  }
  compositionEnd() {
    this.commandDelegate.endComposition();
  }
  cut() {
    this.commandDelegate.cut();
  }
  setSelection(e) {
    Li.SetSelection.runCoreEditorCommand(this.viewModel, {
      source: "keyboard",
      selection: e
    });
  }
  _validateViewColumn(e) {
    const t = this.viewModel.getLineMinColumn(e.lineNumber);
    return e.column < t ? new F(e.lineNumber, t) : e;
  }
  _hasMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.altKey;
      case "ctrlKey":
        return e.ctrlKey;
      case "metaKey":
        return e.metaKey;
      default:
        return !1;
    }
  }
  _hasNonMulticursorModifier(e) {
    switch (this.configuration.options.get(
      78
      /* EditorOption.multiCursorModifier */
    )) {
      case "altKey":
        return e.ctrlKey || e.metaKey;
      case "ctrlKey":
        return e.altKey || e.metaKey;
      case "metaKey":
        return e.ctrlKey || e.altKey;
      default:
        return !1;
    }
  }
  dispatchMouse(e) {
    const t = this.configuration.options, i = Fn && t.get(
      108
      /* EditorOption.selectionClipboard */
    ), n = t.get(
      22
      /* EditorOption.columnSelection */
    );
    e.middleButton && !i ? this._columnSelect(e.position, e.mouseColumn, e.inSelectionMode) : e.startedOnLineNumbers ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelect(e.position, e.revealType) : this._createCursor(e.position, !0) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount >= 4 ? this._selectAll() : e.mouseDownCount === 3 ? this._hasMulticursorModifier(e) ? e.inSelectionMode ? this._lastCursorLineSelectDrag(e.position, e.revealType) : this._lastCursorLineSelect(e.position, e.revealType) : e.inSelectionMode ? this._lineSelectDrag(e.position, e.revealType) : this._lineSelect(e.position, e.revealType) : e.mouseDownCount === 2 ? e.onInjectedText || (this._hasMulticursorModifier(e) ? this._lastCursorWordSelect(e.position, e.revealType) : e.inSelectionMode ? this._wordSelectDrag(e.position, e.revealType) : this._wordSelect(e.position, e.revealType)) : this._hasMulticursorModifier(e) ? this._hasNonMulticursorModifier(e) || (e.shiftKey ? this._columnSelect(e.position, e.mouseColumn, !0) : e.inSelectionMode ? this._lastCursorMoveToSelect(e.position, e.revealType) : this._createCursor(e.position, !1)) : e.inSelectionMode ? e.altKey ? this._columnSelect(e.position, e.mouseColumn, !0) : n ? this._columnSelect(e.position, e.mouseColumn, !0) : this._moveToSelect(e.position, e.revealType) : this.moveTo(e.position, e.revealType);
  }
  _usualArgs(e, t) {
    return e = this._validateViewColumn(e), {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      revealType: t
    };
  }
  moveTo(e, t) {
    Li.MoveTo.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _moveToSelect(e, t) {
    Li.MoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _columnSelect(e, t, i) {
    e = this._validateViewColumn(e), Li.ColumnSelect.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      mouseColumn: t,
      doColumnSelect: i
    });
  }
  _createCursor(e, t) {
    e = this._validateViewColumn(e), Li.CreateCursor.runCoreEditorCommand(this.viewModel, {
      source: "mouse",
      position: this._convertViewToModelPosition(e),
      viewPosition: e,
      wholeLine: t
    });
  }
  _lastCursorMoveToSelect(e, t) {
    Li.LastCursorMoveToSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelect(e, t) {
    Li.WordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _wordSelectDrag(e, t) {
    Li.WordSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorWordSelect(e, t) {
    Li.LastCursorWordSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelect(e, t) {
    Li.LineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lineSelectDrag(e, t) {
    Li.LineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelect(e, t) {
    Li.LastCursorLineSelect.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _lastCursorLineSelectDrag(e, t) {
    Li.LastCursorLineSelectDrag.runCoreEditorCommand(this.viewModel, this._usualArgs(e, t));
  }
  _selectAll() {
    Li.SelectAll.runCoreEditorCommand(this.viewModel, { source: "mouse" });
  }
  // ----------------------
  _convertViewToModelPosition(e) {
    return this.viewModel.coordinatesConverter.convertViewPositionToModelPosition(e);
  }
  emitKeyDown(e) {
    this.userInputEvents.emitKeyDown(e);
  }
  emitKeyUp(e) {
    this.userInputEvents.emitKeyUp(e);
  }
  emitContextMenu(e) {
    this.userInputEvents.emitContextMenu(e);
  }
  emitMouseMove(e) {
    this.userInputEvents.emitMouseMove(e);
  }
  emitMouseLeave(e) {
    this.userInputEvents.emitMouseLeave(e);
  }
  emitMouseUp(e) {
    this.userInputEvents.emitMouseUp(e);
  }
  emitMouseDown(e) {
    this.userInputEvents.emitMouseDown(e);
  }
  emitMouseDrag(e) {
    this.userInputEvents.emitMouseDrag(e);
  }
  emitMouseDrop(e) {
    this.userInputEvents.emitMouseDrop(e);
  }
  emitMouseDropCanceled() {
    this.userInputEvents.emitMouseDropCanceled();
  }
  emitMouseWheel(e) {
    this.userInputEvents.emitMouseWheel(e);
  }
}
class B8 {
  constructor(e) {
    this._lineFactory = e, this._set(1, []);
  }
  flush() {
    this._set(1, []);
  }
  _set(e, t) {
    this._lines = t, this._rendLineNumberStart = e;
  }
  _get() {
    return {
      rendLineNumberStart: this._rendLineNumberStart,
      lines: this._lines
    };
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getStartLineNumber() {
    return this._rendLineNumberStart;
  }
  /**
   * @returns Inclusive line number that is inside this collection
   */
  getEndLineNumber() {
    return this._rendLineNumberStart + this._lines.length - 1;
  }
  getCount() {
    return this._lines.length;
  }
  getLine(e) {
    const t = e - this._rendLineNumberStart;
    if (t < 0 || t >= this._lines.length)
      throw new lt("Illegal value for lineNumber");
    return this._lines[t];
  }
  /**
   * @returns Lines that were removed from this collection
   */
  onLinesDeleted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = this.getStartLineNumber(), n = this.getEndLineNumber();
    if (t < i) {
      const l = t - e + 1;
      return this._rendLineNumberStart -= l, null;
    }
    if (e > n)
      return null;
    let o = 0, r = 0;
    for (let l = i; l <= n; l++) {
      const c = l - this._rendLineNumberStart;
      e <= l && l <= t && (r === 0 ? (o = c, r = 1) : r++);
    }
    if (e < i) {
      let l = 0;
      t < i ? l = t - e + 1 : l = i - e, this._rendLineNumberStart -= l;
    }
    return this._lines.splice(o, r);
  }
  onLinesChanged(e, t) {
    const i = e + t - 1;
    if (this.getCount() === 0)
      return !1;
    const n = this.getStartLineNumber(), o = this.getEndLineNumber();
    let r = !1;
    for (let a = e; a <= i; a++)
      a >= n && a <= o && (this._lines[a - this._rendLineNumberStart].onContentChanged(), r = !0);
    return r;
  }
  onLinesInserted(e, t) {
    if (this.getCount() === 0)
      return null;
    const i = t - e + 1, n = this.getStartLineNumber(), o = this.getEndLineNumber();
    if (e <= n)
      return this._rendLineNumberStart += i, null;
    if (e > o)
      return null;
    if (i + e > o)
      return this._lines.splice(e - this._rendLineNumberStart, o - e + 1);
    const r = [];
    for (let h = 0; h < i; h++)
      r[h] = this._lineFactory.createLine();
    const a = e - this._rendLineNumberStart, l = this._lines.slice(0, a), c = this._lines.slice(a, this._lines.length - i), d = this._lines.slice(this._lines.length - i, this._lines.length);
    return this._lines = l.concat(r).concat(c), d;
  }
  onTokensChanged(e) {
    if (this.getCount() === 0)
      return !1;
    const t = this.getStartLineNumber(), i = this.getEndLineNumber();
    let n = !1;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      if (a.toLineNumber < t || a.fromLineNumber > i)
        continue;
      const l = Math.max(t, a.fromLineNumber), c = Math.min(i, a.toLineNumber);
      for (let d = l; d <= c; d++) {
        const h = d - this._rendLineNumberStart;
        this._lines[h].onTokensChanged(), n = !0;
      }
    }
    return n;
  }
}
class R8 {
  constructor(e) {
    this._lineFactory = e, this.domNode = this._createDomNode(), this._linesCollection = new B8(this._lineFactory);
  }
  _createDomNode() {
    const e = rt(document.createElement("div"));
    return e.setClassName("view-layer"), e.setPosition("absolute"), e.domNode.setAttribute("role", "presentation"), e.domNode.setAttribute("aria-hidden", "true"), e;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return !!e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    );
  }
  onFlushed(e) {
    return this._linesCollection.flush(), !0;
  }
  onLinesChanged(e) {
    return this._linesCollection.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    const t = this._linesCollection.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++)
        t[i].getDomNode()?.remove();
    return !0;
  }
  onLinesInserted(e) {
    const t = this._linesCollection.onLinesInserted(e.fromLineNumber, e.toLineNumber);
    if (t)
      for (let i = 0, n = t.length; i < n; i++)
        t[i].getDomNode()?.remove();
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onTokensChanged(e) {
    return this._linesCollection.onTokensChanged(e.ranges);
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  getStartLineNumber() {
    return this._linesCollection.getStartLineNumber();
  }
  getEndLineNumber() {
    return this._linesCollection.getEndLineNumber();
  }
  getVisibleLine(e) {
    return this._linesCollection.getLine(e);
  }
  renderLines(e) {
    const t = this._linesCollection._get(), i = new CD(this.domNode.domNode, this._lineFactory, e), n = {
      rendLineNumberStart: t.rendLineNumberStart,
      lines: t.lines,
      linesLength: t.lines.length
    }, o = i.render(n, e.startLineNumber, e.endLineNumber, e.relativeVerticalOffset);
    this._linesCollection._set(o.rendLineNumberStart, o.lines);
  }
}
const al = class al {
  constructor(e, t, i) {
    this._domNode = e, this._lineFactory = t, this._viewportData = i;
  }
  render(e, t, i, n) {
    const o = {
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines.slice(0),
      linesLength: e.linesLength
    };
    if (o.rendLineNumberStart + o.linesLength - 1 < t || i < o.rendLineNumberStart) {
      o.rendLineNumberStart = t, o.linesLength = i - t + 1, o.lines = [];
      for (let r = t; r <= i; r++)
        o.lines[r - t] = this._lineFactory.createLine();
      return this._finishRendering(o, !0, n), o;
    }
    if (this._renderUntouchedLines(o, Math.max(t - o.rendLineNumberStart, 0), Math.min(i - o.rendLineNumberStart, o.linesLength - 1), n, t), o.rendLineNumberStart > t) {
      const r = t, a = Math.min(i, o.rendLineNumberStart - 1);
      r <= a && (this._insertLinesBefore(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart < t) {
      const r = Math.min(o.linesLength, t - o.rendLineNumberStart);
      r > 0 && (this._removeLinesBefore(o, r), o.linesLength -= r);
    }
    if (o.rendLineNumberStart = t, o.rendLineNumberStart + o.linesLength - 1 < i) {
      const r = o.rendLineNumberStart + o.linesLength, a = i;
      r <= a && (this._insertLinesAfter(o, r, a, n, t), o.linesLength += a - r + 1);
    } else if (o.rendLineNumberStart + o.linesLength - 1 > i) {
      const r = Math.max(0, i - o.rendLineNumberStart + 1), l = o.linesLength - 1 - r + 1;
      l > 0 && (this._removeLinesAfter(o, l), o.linesLength -= l);
    }
    return this._finishRendering(o, !1, n), o;
  }
  _renderUntouchedLines(e, t, i, n, o) {
    const r = e.rendLineNumberStart, a = e.lines;
    for (let l = t; l <= i; l++) {
      const c = r + l;
      a[l].layoutLine(c, n[c - o], this._viewportData.lineHeight);
    }
  }
  _insertLinesBefore(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = r.concat(e.lines);
  }
  _removeLinesBefore(e, t) {
    for (let i = 0; i < t; i++)
      e.lines[i].getDomNode()?.remove();
    e.lines.splice(0, t);
  }
  _insertLinesAfter(e, t, i, n, o) {
    const r = [];
    let a = 0;
    for (let l = t; l <= i; l++)
      r[a++] = this._lineFactory.createLine();
    e.lines = e.lines.concat(r);
  }
  _removeLinesAfter(e, t) {
    const i = e.linesLength - t;
    for (let n = 0; n < t; n++)
      e.lines[i + n].getDomNode()?.remove();
    e.lines.splice(i, t);
  }
  _finishRenderingNewLines(e, t, i, n) {
    al._ttPolicy && (i = al._ttPolicy.createHTML(i));
    const o = this._domNode.lastChild;
    t || !o ? this._domNode.innerHTML = i : o.insertAdjacentHTML("afterend", i);
    let r = this._domNode.lastChild;
    for (let a = e.linesLength - 1; a >= 0; a--) {
      const l = e.lines[a];
      n[a] && (l.setDomNode(r), r = r.previousSibling);
    }
  }
  _finishRenderingInvalidLines(e, t, i) {
    const n = document.createElement("div");
    al._ttPolicy && (t = al._ttPolicy.createHTML(t)), n.innerHTML = t;
    for (let o = 0; o < e.linesLength; o++) {
      const r = e.lines[o];
      if (i[o]) {
        const a = n.firstChild, l = r.getDomNode();
        l.parentNode.replaceChild(a, l), r.setDomNode(a);
      }
    }
  }
  _finishRendering(e, t, i) {
    const n = al._sb, o = e.linesLength, r = e.lines, a = e.rendLineNumberStart, l = [];
    {
      n.reset();
      let c = !1;
      for (let d = 0; d < o; d++) {
        const h = r[d];
        l[d] = !1, !(h.getDomNode() || !h.renderLine(d + a, i[d], this._viewportData.lineHeight, this._viewportData, n)) && (l[d] = !0, c = !0);
      }
      c && this._finishRenderingNewLines(e, t, n.build(), l);
    }
    {
      n.reset();
      let c = !1;
      const d = [];
      for (let h = 0; h < o; h++) {
        const u = r[h];
        d[h] = !1, !(l[h] || !u.renderLine(h + a, i[h], this._viewportData.lineHeight, this._viewportData, n)) && (d[h] = !0, c = !0);
      }
      c && this._finishRenderingInvalidLines(e, n.build(), d);
    }
  }
};
al._ttPolicy = Hu("editorViewLayer", { createHTML: (e) => e }), al._sb = new R0(1e5);
let CD = al;
class F8 extends Ds {
  constructor(e) {
    super(e), this._dynamicOverlays = [], this._isFocused = !1, this._visibleLines = new R8({
      createLine: () => new soe(this._dynamicOverlays)
    }), this.domNode = this._visibleLines.domNode;
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    cn(this.domNode, i), this.domNode.setClassName("view-overlays");
  }
  shouldRender() {
    if (super.shouldRender())
      return !0;
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      if (this._dynamicOverlays[e].shouldRender())
        return !0;
    return !1;
  }
  dispose() {
    super.dispose();
    for (let e = 0, t = this._dynamicOverlays.length; e < t; e++)
      this._dynamicOverlays[e].dispose();
    this._dynamicOverlays = [];
  }
  getDomNode() {
    return this.domNode;
  }
  addDynamicOverlay(e) {
    this._dynamicOverlays.push(e);
  }
  // ----- event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e);
    const i = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    return cn(this.domNode, i), !0;
  }
  onFlushed(e) {
    return this._visibleLines.onFlushed(e);
  }
  onFocusChanged(e) {
    return this._isFocused = e.isFocused, !0;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onScrollChanged(e) {
    return this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._visibleLines.onZonesChanged(e);
  }
  // ----- end event handlers
  prepareRender(e) {
    const t = this._dynamicOverlays.filter((i) => i.shouldRender());
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      o.prepareRender(e), o.onDidRender();
    }
  }
  render(e) {
    this._viewOverlaysRender(e), this.domNode.toggleClassName("focused", this._isFocused);
  }
  _viewOverlaysRender(e) {
    this._visibleLines.renderLines(e.viewportData);
  }
}
class soe {
  constructor(e) {
    this._dynamicOverlays = e, this._domNode = null, this._renderedContent = null;
  }
  getDomNode() {
    return this._domNode ? this._domNode.domNode : null;
  }
  setDomNode(e) {
    this._domNode = rt(e);
  }
  onContentChanged() {
  }
  onTokensChanged() {
  }
  renderLine(e, t, i, n, o) {
    let r = "";
    for (let a = 0, l = this._dynamicOverlays.length; a < l; a++) {
      const c = this._dynamicOverlays[a];
      r += c.render(n.startLineNumber, e);
    }
    return this._renderedContent === r ? !1 : (this._renderedContent = r, o.appendString('<div style="top:'), o.appendString(String(t)), o.appendString("px;height:"), o.appendString(String(i)), o.appendString('px;">'), o.appendString(r), o.appendString("</div>"), !0);
  }
  layoutLine(e, t, i) {
    this._domNode && (this._domNode.setTop(t), this._domNode.setHeight(i));
  }
}
class ooe extends F8 {
  constructor(e) {
    super(e);
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentWidth = i.contentWidth, this.domNode.setHeight(0);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentWidth = i.contentWidth, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollWidthChanged;
  }
  // --- end event handlers
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e), this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth));
  }
}
class roe extends F8 {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._contentLeft = i.contentLeft, this.domNode.setClassName("margin-view-overlays"), this.domNode.setWidth(1), cn(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    cn(this.domNode, t.get(
      50
      /* EditorOption.fontInfo */
    ));
    const i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._contentLeft = i.contentLeft, super.onConfigurationChanged(e) || !0;
  }
  onScrollChanged(e) {
    return super.onScrollChanged(e) || e.scrollHeightChanged;
  }
  _viewOverlaysRender(e) {
    super._viewOverlaysRender(e);
    const t = Math.min(e.scrollHeight, 1e6);
    this.domNode.setHeight(t), this.domNode.setWidth(this._contentLeft);
  }
}
class xS {
  constructor(e) {
    this.onKeyDown = null, this.onKeyUp = null, this.onContextMenu = null, this.onMouseMove = null, this.onMouseLeave = null, this.onMouseDown = null, this.onMouseUp = null, this.onMouseDrag = null, this.onMouseDrop = null, this.onMouseDropCanceled = null, this.onMouseWheel = null, this._coordinatesConverter = e;
  }
  emitKeyDown(e) {
    this.onKeyDown?.(e);
  }
  emitKeyUp(e) {
    this.onKeyUp?.(e);
  }
  emitContextMenu(e) {
    this.onContextMenu?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseMove(e) {
    this.onMouseMove?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseLeave(e) {
    this.onMouseLeave?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDown(e) {
    this.onMouseDown?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseUp(e) {
    this.onMouseUp?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrag(e) {
    this.onMouseDrag?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDrop(e) {
    this.onMouseDrop?.(this._convertViewToModelMouseEvent(e));
  }
  emitMouseDropCanceled() {
    this.onMouseDropCanceled?.();
  }
  emitMouseWheel(e) {
    this.onMouseWheel?.(e);
  }
  _convertViewToModelMouseEvent(e) {
    return e.target ? {
      event: e.event,
      target: this._convertViewToModelMouseTarget(e.target)
    } : e;
  }
  _convertViewToModelMouseTarget(e) {
    return xS.convertViewToModelMouseTarget(e, this._coordinatesConverter);
  }
  static convertViewToModelMouseTarget(e, t) {
    const i = { ...e };
    return i.position && (i.position = t.convertViewPositionToModelPosition(i.position)), i.range && (i.range = t.convertViewRangeToModelRange(i.range)), (i.type === 5 || i.type === 8) && (i.detail = this.convertViewToModelViewZoneData(i.detail, t)), i;
  }
  static convertViewToModelViewZoneData(e, t) {
    return {
      viewZoneId: e.viewZoneId,
      positionBefore: e.positionBefore ? t.convertViewPositionToModelPosition(e.positionBefore) : e.positionBefore,
      positionAfter: e.positionAfter ? t.convertViewPositionToModelPosition(e.positionAfter) : e.positionAfter,
      position: t.convertViewPositionToModelPosition(e.position),
      afterLineNumber: t.convertViewPositionToModelPosition(new F(e.afterLineNumber, 1)).lineNumber
    };
  }
}
class aoe extends Ds {
  constructor(e) {
    super(e), this.blocks = [], this.contentWidth = -1, this.contentLeft = 0, this.domNode = rt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("blockDecorations-container"), this.update();
  }
  update() {
    let e = !1;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = i.contentWidth - i.verticalScrollbarWidth;
    this.contentWidth !== n && (this.contentWidth = n, e = !0);
    const o = i.contentLeft;
    return this.contentLeft !== o && (this.contentLeft = o, e = !0), e;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return this.update();
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollLeftChanged;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    let t = 0;
    const i = e.getDecorationsInViewport();
    for (const n of i) {
      if (!n.options.blockClassName)
        continue;
      let o = this.blocks[t];
      o || (o = this.blocks[t] = rt(document.createElement("div")), this.domNode.appendChild(o));
      let r, a;
      n.options.blockIsAfterEnd ? (r = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !1), a = e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0)) : (r = e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !0), a = n.range.isEmpty() && !n.options.blockDoesNotCollapse ? e.getVerticalOffsetForLineNumber(n.range.startLineNumber, !1) : e.getVerticalOffsetAfterLineNumber(n.range.endLineNumber, !0));
      const [l, c, d, h] = n.options.blockPadding ?? [0, 0, 0, 0];
      o.setClassName("blockDecorations-block " + n.options.blockClassName), o.setLeft(this.contentLeft - h), o.setWidth(this.contentWidth + h + c), o.setTop(r - e.scrollTop - l), o.setHeight(a - r + l + d), t++;
    }
    for (let n = t; n < this.blocks.length; n++)
      this.blocks[n].domNode.remove();
    this.blocks.length = t;
  }
}
class loe extends Ds {
  constructor(e, t) {
    super(e), this._viewDomNode = t, this._widgets = {}, this.domNode = rt(document.createElement("div")), Pr.write(
      this.domNode,
      1
      /* PartFingerprint.ContentWidgets */
    ), this.domNode.setClassName("contentWidgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this.overflowingContentWidgetsDomNode = rt(document.createElement("div")), Pr.write(
      this.overflowingContentWidgetsDomNode,
      2
      /* PartFingerprint.OverflowingContentWidgets */
    ), this.overflowingContentWidgetsDomNode.setClassName("overflowingContentWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onConfigurationChanged(e);
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLineMappingChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesChanged(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesDeleted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onLinesInserted(e) {
    return this._updateAnchorsViewPositions(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onZonesChanged(e) {
    return !0;
  }
  // ---- end view event handlers
  _updateAnchorsViewPositions() {
    const e = Object.keys(this._widgets);
    for (const t of e)
      this._widgets[t].updateAnchorViewPosition();
  }
  addWidget(e) {
    const t = new coe(this._context, this._viewDomNode, e);
    this._widgets[t.id] = t, t.allowEditorOverflow ? this.overflowingContentWidgetsDomNode.appendChild(t.domNode) : this.domNode.appendChild(t.domNode), this.setShouldRender();
  }
  setWidgetPosition(e, t, i, n, o) {
    this._widgets[e.getId()].setPosition(t, i, n, o), this.setShouldRender();
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const i = this._widgets[t];
      delete this._widgets[t];
      const n = i.domNode.domNode;
      n.remove(), n.removeAttribute("monaco-visible-content-widget"), this.setShouldRender();
    }
  }
  shouldSuppressMouseDownOnWidget(e) {
    return this._widgets.hasOwnProperty(e) ? this._widgets[e].suppressMouseDown : !1;
  }
  onBeforeRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].onBeforeRender(e);
  }
  prepareRender(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].prepareRender(e);
  }
  render(e) {
    const t = Object.keys(this._widgets);
    for (const i of t)
      this._widgets[i].render(e);
  }
}
class coe {
  constructor(e, t, i) {
    this._primaryAnchor = new sp(null, null), this._secondaryAnchor = new sp(null, null), this._context = e, this._viewDomNode = t, this._actual = i, this.domNode = rt(this._actual.getDomNode()), this.id = this._actual.getId(), this.allowEditorOverflow = this._actual.allowEditorOverflow || !1, this.suppressMouseDown = this._actual.suppressMouseDown || !1;
    const n = this._context.configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._fixedOverflowWidgets = n.get(
      42
      /* EditorOption.fixedOverflowWidgets */
    ), this._contentWidth = o.contentWidth, this._contentLeft = o.contentLeft, this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._affinity = null, this._preference = [], this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1, this._maxWidth = this._getMaxWidth(), this._isVisible = !1, this._renderData = null, this.domNode.setPosition(this._fixedOverflowWidgets && this.allowEditorOverflow ? "fixed" : "absolute"), this.domNode.setDisplay("none"), this.domNode.setVisibility("hidden"), this.domNode.setAttribute("widgetId", this.id), this.domNode.setMaxWidth(this._maxWidth);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    if (this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      );
      this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._maxWidth = this._getMaxWidth();
    }
  }
  updateAnchorViewPosition() {
    this._setPosition(this._affinity, this._primaryAnchor.modelPosition, this._secondaryAnchor.modelPosition);
  }
  _setPosition(e, t, i) {
    this._affinity = e, this._primaryAnchor = n(t, this._context.viewModel, this._affinity), this._secondaryAnchor = n(i, this._context.viewModel, this._affinity);
    function n(o, r, a) {
      if (!o)
        return new sp(null, null);
      const l = r.model.validatePosition(o);
      if (r.coordinatesConverter.modelPositionIsVisible(l)) {
        const c = r.coordinatesConverter.convertModelPositionToViewPosition(l, a ?? void 0);
        return new sp(o, c);
      }
      return new sp(o, null);
    }
  }
  _getMaxWidth() {
    const e = this.domNode.domNode.ownerDocument, t = e.defaultView;
    return this.allowEditorOverflow ? t?.innerWidth || e.documentElement.offsetWidth || e.body.offsetWidth : this._contentWidth;
  }
  setPosition(e, t, i, n) {
    this._setPosition(n, e, t), this._preference = i, this._primaryAnchor.viewPosition && this._preference && this._preference.length > 0 ? this.domNode.setDisplay("block") : this.domNode.setDisplay("none"), this._cachedDomNodeOffsetWidth = -1, this._cachedDomNodeOffsetHeight = -1;
  }
  _layoutBoxInViewport(e, t, i, n) {
    const o = e.top, r = o, a = e.top + e.height, l = n.viewportHeight - a, c = o - i, d = r >= i, h = a, u = l >= i;
    let g = e.left;
    return g + t > n.scrollLeft + n.viewportWidth && (g = n.scrollLeft + n.viewportWidth - t), g < n.scrollLeft && (g = n.scrollLeft), { fitsAbove: d, aboveTop: c, fitsBelow: u, belowTop: h, left: g };
  }
  _layoutHorizontalSegmentInPage(e, t, i, n) {
    const a = Math.max(15, t.left - n), l = Math.min(t.left + t.width + n, e.width - 15), d = this._viewDomNode.domNode.ownerDocument.defaultView;
    let h = t.left + i - (d?.scrollX ?? 0);
    if (h + n > l) {
      const u = h - (l - n);
      h -= u, i -= u;
    }
    if (h < a) {
      const u = h - a;
      h -= u, i -= u;
    }
    return [i, h];
  }
  _layoutBoxInPage(e, t, i, n) {
    const o = e.top - i, r = e.top + e.height, a = ui(this._viewDomNode.domNode), l = this._viewDomNode.domNode.ownerDocument, c = l.defaultView, d = a.top + o - (c?.scrollY ?? 0), h = a.top + r - (c?.scrollY ?? 0), u = mu(l.body), [g, m] = this._layoutHorizontalSegmentInPage(u, a, e.left - n.scrollLeft + this._contentLeft, t), p = 22, A = 22, _ = d >= p, b = h + i <= u.height - A;
    return this._fixedOverflowWidgets ? {
      fitsAbove: _,
      aboveTop: Math.max(d, p),
      fitsBelow: b,
      belowTop: h,
      left: m
    } : { fitsAbove: _, aboveTop: o, fitsBelow: b, belowTop: r, left: g };
  }
  _prepareRenderWidgetAtExactPositionOverflowing(e) {
    return new op(e.top, e.left + this._contentLeft);
  }
  /**
   * Compute the coordinates above and below the primary and secondary anchors.
   * The content widget *must* touch the primary anchor.
   * The content widget should touch if possible the secondary anchor.
   */
  _getAnchorsCoordinates(e) {
    const t = o(this._primaryAnchor.viewPosition, this._affinity, this._lineHeight), i = this._secondaryAnchor.viewPosition?.lineNumber === this._primaryAnchor.viewPosition?.lineNumber ? this._secondaryAnchor.viewPosition : null, n = o(i, this._affinity, this._lineHeight);
    return { primary: t, secondary: n };
    function o(r, a, l) {
      if (!r)
        return null;
      const c = e.visibleRangeForPosition(r);
      if (!c)
        return null;
      const d = r.column === 1 && a === 3 ? 0 : c.left, h = e.getVerticalOffsetForLineNumber(r.lineNumber) - e.scrollTop;
      return new RO(h, d, l);
    }
  }
  _reduceAnchorCoordinates(e, t, i) {
    if (!t)
      return e;
    const n = this._context.configuration.options.get(
      50
      /* EditorOption.fontInfo */
    );
    let o = t.left;
    return o < e.left ? o = Math.max(o, e.left - i + n.typicalFullwidthCharacterWidth) : o = Math.min(o, e.left + i - n.typicalFullwidthCharacterWidth), new RO(e.top, o, e.height);
  }
  _prepareRenderWidget(e) {
    if (!this._preference || this._preference.length === 0)
      return null;
    const { primary: t, secondary: i } = this._getAnchorsCoordinates(e);
    if (!t)
      return {
        kind: "offViewport",
        preserveFocus: this.domNode.domNode.contains(this.domNode.domNode.ownerDocument.activeElement)
      };
    if (this._cachedDomNodeOffsetWidth === -1 || this._cachedDomNodeOffsetHeight === -1) {
      let r = null;
      if (typeof this._actual.beforeRender == "function" && (r = tx(this._actual.beforeRender, this._actual)), r)
        this._cachedDomNodeOffsetWidth = r.width, this._cachedDomNodeOffsetHeight = r.height;
      else {
        const l = this.domNode.domNode.getBoundingClientRect();
        this._cachedDomNodeOffsetWidth = Math.round(l.width), this._cachedDomNodeOffsetHeight = Math.round(l.height);
      }
    }
    const n = this._reduceAnchorCoordinates(t, i, this._cachedDomNodeOffsetWidth);
    let o;
    this.allowEditorOverflow ? o = this._layoutBoxInPage(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e) : o = this._layoutBoxInViewport(n, this._cachedDomNodeOffsetWidth, this._cachedDomNodeOffsetHeight, e);
    for (let r = 1; r <= 2; r++)
      for (const a of this._preference)
        if (a === 1) {
          if (!o)
            return null;
          if (r === 2 || o.fitsAbove)
            return {
              kind: "inViewport",
              coordinate: new op(o.aboveTop, o.left),
              position: 1
              /* ContentWidgetPositionPreference.ABOVE */
            };
        } else if (a === 2) {
          if (!o)
            return null;
          if (r === 2 || o.fitsBelow)
            return {
              kind: "inViewport",
              coordinate: new op(o.belowTop, o.left),
              position: 2
              /* ContentWidgetPositionPreference.BELOW */
            };
        } else
          return this.allowEditorOverflow ? {
            kind: "inViewport",
            coordinate: this._prepareRenderWidgetAtExactPositionOverflowing(new op(n.top, n.left)),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          } : {
            kind: "inViewport",
            coordinate: new op(n.top, n.left),
            position: 0
            /* ContentWidgetPositionPreference.EXACT */
          };
    return null;
  }
  /**
   * On this first pass, we ensure that the content widget (if it is in the viewport) has the max width set correctly.
   */
  onBeforeRender(e) {
    !this._primaryAnchor.viewPosition || !this._preference || this._primaryAnchor.viewPosition.lineNumber < e.startLineNumber || this._primaryAnchor.viewPosition.lineNumber > e.endLineNumber || this.domNode.setMaxWidth(this._maxWidth);
  }
  prepareRender(e) {
    this._renderData = this._prepareRenderWidget(e);
  }
  render(e) {
    if (!this._renderData || this._renderData.kind === "offViewport") {
      this._isVisible && (this.domNode.removeAttribute("monaco-visible-content-widget"), this._isVisible = !1, this._renderData?.kind === "offViewport" && this._renderData.preserveFocus ? this.domNode.setTop(-1e3) : this.domNode.setVisibility("hidden")), typeof this._actual.afterRender == "function" && tx(this._actual.afterRender, this._actual, null);
      return;
    }
    this.allowEditorOverflow ? (this.domNode.setTop(this._renderData.coordinate.top), this.domNode.setLeft(this._renderData.coordinate.left)) : (this.domNode.setTop(this._renderData.coordinate.top + e.scrollTop - e.bigNumbersDelta), this.domNode.setLeft(this._renderData.coordinate.left)), this._isVisible || (this.domNode.setVisibility("inherit"), this.domNode.setAttribute("monaco-visible-content-widget", "true"), this._isVisible = !0), typeof this._actual.afterRender == "function" && tx(this._actual.afterRender, this._actual, this._renderData.position);
  }
}
class sp {
  constructor(e, t) {
    this.modelPosition = e, this.viewPosition = t;
  }
}
class op {
  constructor(e, t) {
    this.top = e, this.left = t, this._coordinateBrand = void 0;
  }
}
class RO {
  constructor(e, t, i) {
    this.top = e, this.left = t, this.height = i, this._anchorCoordinateBrand = void 0;
  }
}
function tx(s, e, ...t) {
  try {
    return s.call(e, ...t);
  } catch {
    return null;
  }
}
class O8 extends Ku {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, this._selectionIsEmpty = !0, this._focused = !1, this._cursorLineNumbers = [1], this._selections = [new Ue(1, 1, 1, 1)], this._renderData = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  _readFromSelections() {
    let e = !1;
    const t = /* @__PURE__ */ new Set();
    for (const o of this._selections)
      t.add(o.positionLineNumber);
    const i = Array.from(t);
    i.sort((o, r) => o - r), pi(this._cursorLineNumbers, i) || (this._cursorLineNumbers = i, e = !0);
    const n = this._selections.every((o) => o.isEmpty());
    return this._selectionIsEmpty !== n && (this._selectionIsEmpty = n, e = !0), e;
  }
  // --- begin event handlers
  onThemeChanged(e) {
    return this._readFromSelections();
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._renderLineHighlight = t.get(
      97
      /* EditorOption.renderLineHighlight */
    ), this._renderLineHighlightOnlyWhenFocus = t.get(
      98
      /* EditorOption.renderLineHighlightOnlyWhenFocus */
    ), this._wordWrap = i.isViewportWrapping, this._contentLeft = i.contentLeft, this._contentWidth = i.contentWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._readFromSelections();
  }
  onFlushed(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollWidthChanged || e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._renderLineHighlightOnlyWhenFocus ? (this._focused = e.isFocused, !0) : !1;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._shouldRenderThis()) {
      this._renderData = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = [];
    for (let r = t; r <= i; r++) {
      const a = r - t;
      n[a] = "";
    }
    if (this._wordWrap) {
      const r = this._renderOne(e, !1);
      for (const a of this._cursorLineNumbers) {
        const l = this._context.viewModel.coordinatesConverter, c = l.convertViewPositionToModelPosition(new F(a, 1)).lineNumber, d = l.convertModelPositionToViewPosition(new F(c, 1)).lineNumber, h = l.convertModelPositionToViewPosition(new F(c, this._context.viewModel.model.getLineMaxColumn(c))).lineNumber, u = Math.max(d, t), g = Math.min(h, i);
        for (let m = u; m <= g; m++) {
          const p = m - t;
          n[p] = r;
        }
      }
    }
    const o = this._renderOne(e, !0);
    for (const r of this._cursorLineNumbers) {
      if (r < t || r > i)
        continue;
      const a = r - t;
      n[a] = o;
    }
    this._renderData = n;
  }
  render(e, t) {
    if (!this._renderData)
      return "";
    const i = t - e;
    return i >= this._renderData.length ? "" : this._renderData[i];
  }
  _shouldRenderInMargin() {
    return (this._renderLineHighlight === "gutter" || this._renderLineHighlight === "all") && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
  _shouldRenderInContent() {
    return (this._renderLineHighlight === "line" || this._renderLineHighlight === "all") && this._selectionIsEmpty && (!this._renderLineHighlightOnlyWhenFocus || this._focused);
  }
}
class doe extends O8 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-both" : "") + (t ? " current-line-exact" : "")}" style="width:${Math.max(e.scrollWidth, this._contentWidth)}px;"></div>`;
  }
  _shouldRenderThis() {
    return this._shouldRenderInContent();
  }
  _shouldRenderOther() {
    return this._shouldRenderInMargin();
  }
}
class hoe extends O8 {
  _renderOne(e, t) {
    return `<div class="${"current-line" + (this._shouldRenderInMargin() ? " current-line-margin" : "") + (this._shouldRenderOther() ? " current-line-margin-both" : "") + (this._shouldRenderInMargin() && t ? " current-line-exact-margin" : "")}" style="width:${this._contentLeft}px"></div>`;
  }
  _shouldRenderThis() {
    return !0;
  }
  _shouldRenderOther() {
    return this._shouldRenderInContent();
  }
}
rr((s, e) => {
  const t = s.getColor($3);
  if (t && (e.addRule(`.monaco-editor .view-overlays .current-line { background-color: ${t}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-margin { background-color: ${t}; border: none; }`)), !t || t.isTransparent() || s.defines(bF)) {
    const i = s.getColor(bF);
    i && (e.addRule(`.monaco-editor .view-overlays .current-line-exact { border: 2px solid ${i}; }`), e.addRule(`.monaco-editor .margin-view-overlays .current-line-exact-margin { border: 2px solid ${i}; }`), Ca(s.type) && (e.addRule(".monaco-editor .view-overlays .current-line-exact { border-width: 1px; }"), e.addRule(".monaco-editor .margin-view-overlays .current-line-exact-margin { border-width: 1px; }")));
  }
});
class uoe extends Ku {
  constructor(e) {
    super(), this._context = e;
    const t = this._context.configuration.options;
    this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    const t = e.getDecorationsInViewport();
    let i = [], n = 0;
    for (let l = 0, c = t.length; l < c; l++) {
      const d = t[l];
      d.options.className && (i[n++] = d);
    }
    i = i.sort((l, c) => {
      if (l.options.zIndex < c.options.zIndex)
        return -1;
      if (l.options.zIndex > c.options.zIndex)
        return 1;
      const d = l.options.className, h = c.options.className;
      return d < h ? -1 : d > h ? 1 : E.compareRangesUsingStarts(l.range, c.range);
    });
    const o = e.visibleRange.startLineNumber, r = e.visibleRange.endLineNumber, a = [];
    for (let l = o; l <= r; l++) {
      const c = l - o;
      a[c] = "";
    }
    this._renderWholeLineDecorations(e, i, a), this._renderNormalDecorations(e, i, a), this._renderResult = a;
  }
  _renderWholeLineDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber, o = e.visibleRange.endLineNumber;
    for (let r = 0, a = t.length; r < a; r++) {
      const l = t[r];
      if (!l.options.isWholeLine)
        continue;
      const c = '<div class="cdr ' + l.options.className + '" style="left:0;width:100%;"></div>', d = Math.max(l.range.startLineNumber, n), h = Math.min(l.range.endLineNumber, o);
      for (let u = d; u <= h; u++) {
        const g = u - n;
        i[g] += c;
      }
    }
  }
  _renderNormalDecorations(e, t, i) {
    const n = e.visibleRange.startLineNumber;
    let o = null, r = !1, a = null, l = !1;
    for (let c = 0, d = t.length; c < d; c++) {
      const h = t[c];
      if (h.options.isWholeLine)
        continue;
      const u = h.options.className, g = !!h.options.showIfCollapsed;
      let m = h.range;
      if (g && m.endColumn === 1 && m.endLineNumber !== m.startLineNumber && (m = new E(m.startLineNumber, m.startColumn, m.endLineNumber - 1, this._context.viewModel.getLineMaxColumn(m.endLineNumber - 1))), o === u && r === g && E.areIntersectingOrTouching(a, m)) {
        a = E.plusRange(a, m);
        continue;
      }
      o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i), o = u, r = g, a = m, l = h.options.shouldFillLineOnLineBreak ?? !1;
    }
    o !== null && this._renderNormalDecoration(e, a, o, l, r, n, i);
  }
  _renderNormalDecoration(e, t, i, n, o, r, a) {
    const l = e.linesVisibleRangesForRange(
      t,
      /*TODO@Alex*/
      i === "findMatch"
    );
    if (l)
      for (let c = 0, d = l.length; c < d; c++) {
        const h = l[c];
        if (h.outsideRenderedLine)
          continue;
        const u = h.lineNumber - r;
        if (o && h.ranges.length === 1) {
          const g = h.ranges[0];
          if (g.width < this._typicalHalfwidthCharacterWidth) {
            const m = Math.round(g.left + g.width / 2), p = Math.max(0, Math.round(m - this._typicalHalfwidthCharacterWidth / 2));
            h.ranges[0] = new SS(p, this._typicalHalfwidthCharacterWidth);
          }
        }
        for (let g = 0, m = h.ranges.length; g < m; g++) {
          const p = n && h.continuesOnNextLine && m === 1, A = h.ranges[g], _ = '<div class="cdr ' + i + '" style="left:' + String(A.left) + "px;width:" + (p ? "100%;" : String(A.width) + "px;") + '"></div>';
          a[u] += _;
        }
      }
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class goe extends Ds {
  constructor(e, t, i, n) {
    super(e);
    const o = this._context.configuration.options, r = o.get(
      104
      /* EditorOption.scrollbar */
    ), a = o.get(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ), l = o.get(
      40
      /* EditorOption.fastScrollSensitivity */
    ), c = o.get(
      107
      /* EditorOption.scrollPredominantAxis */
    ), d = {
      listenOnDomNode: i.domNode,
      className: "editor-scrollable " + hL(e.theme.type),
      useShadows: !1,
      lazyRender: !0,
      vertical: r.vertical,
      horizontal: r.horizontal,
      verticalHasArrows: r.verticalHasArrows,
      horizontalHasArrows: r.horizontalHasArrows,
      verticalScrollbarSize: r.verticalScrollbarSize,
      verticalSliderSize: r.verticalSliderSize,
      horizontalScrollbarSize: r.horizontalScrollbarSize,
      horizontalSliderSize: r.horizontalSliderSize,
      handleMouseWheel: r.handleMouseWheel,
      alwaysConsumeMouseWheel: r.alwaysConsumeMouseWheel,
      arrowSize: r.arrowSize,
      mouseWheelScrollSensitivity: a,
      fastScrollSensitivity: l,
      scrollPredominantAxis: c,
      scrollByPage: r.scrollByPage
    };
    this.scrollbar = this._register(new Y0(t.domNode, d, this._context.viewLayout.getScrollable())), Pr.write(
      this.scrollbar.getDomNode(),
      6
      /* PartFingerprint.ScrollableElement */
    ), this.scrollbarDomNode = rt(this.scrollbar.getDomNode()), this.scrollbarDomNode.setPosition("absolute"), this._setLayout();
    const h = (u, g, m) => {
      const p = {};
      {
        const A = u.scrollTop;
        A && (p.scrollTop = this._context.viewLayout.getCurrentScrollTop() + A, u.scrollTop = 0);
      }
      if (m) {
        const A = u.scrollLeft;
        A && (p.scrollLeft = this._context.viewLayout.getCurrentScrollLeft() + A, u.scrollLeft = 0);
      }
      this._context.viewModel.viewLayout.setScrollPosition(
        p,
        1
        /* ScrollType.Immediate */
      );
    };
    this._register(U(i.domNode, "scroll", (u) => h(i.domNode, !0, !0))), this._register(U(t.domNode, "scroll", (u) => h(t.domNode, !0, !1))), this._register(U(n.domNode, "scroll", (u) => h(n.domNode, !0, !1))), this._register(U(this.scrollbarDomNode.domNode, "scroll", (u) => h(this.scrollbarDomNode.domNode, !0, !1)));
  }
  dispose() {
    super.dispose();
  }
  _setLayout() {
    const e = this._context.configuration.options, t = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.scrollbarDomNode.setLeft(t.contentLeft), e.get(
      73
      /* EditorOption.minimap */
    ).side === "right" ? this.scrollbarDomNode.setWidth(t.contentWidth + t.minimap.minimapWidth) : this.scrollbarDomNode.setWidth(t.contentWidth), this.scrollbarDomNode.setHeight(t.height);
  }
  getOverviewRulerLayoutInfo() {
    return this.scrollbar.getOverviewRulerLayoutInfo();
  }
  getDomNode() {
    return this.scrollbarDomNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    this.scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this.scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    if (e.hasChanged(
      104
      /* EditorOption.scrollbar */
    ) || e.hasChanged(
      75
      /* EditorOption.mouseWheelScrollSensitivity */
    ) || e.hasChanged(
      40
      /* EditorOption.fastScrollSensitivity */
    )) {
      const t = this._context.configuration.options, i = t.get(
        104
        /* EditorOption.scrollbar */
      ), n = t.get(
        75
        /* EditorOption.mouseWheelScrollSensitivity */
      ), o = t.get(
        40
        /* EditorOption.fastScrollSensitivity */
      ), r = t.get(
        107
        /* EditorOption.scrollPredominantAxis */
      ), a = {
        vertical: i.vertical,
        horizontal: i.horizontal,
        verticalScrollbarSize: i.verticalScrollbarSize,
        horizontalScrollbarSize: i.horizontalScrollbarSize,
        scrollByPage: i.scrollByPage,
        handleMouseWheel: i.handleMouseWheel,
        mouseWheelScrollSensitivity: n,
        fastScrollSensitivity: o,
        scrollPredominantAxis: r
      };
      this.scrollbar.updateOptions(a);
    }
    return e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && this._setLayout(), !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onThemeChanged(e) {
    return this.scrollbar.updateClassName("editor-scrollable " + hL(this._context.theme.type)), !0;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this.scrollbar.renderNow();
  }
}
class vD {
  constructor(e, t, i, n, o) {
    this.startLineNumber = e, this.endLineNumber = t, this.className = i, this.tooltip = n, this._decorationToRenderBrand = void 0, this.zIndex = o ?? 0;
  }
}
class foe {
  constructor(e, t, i) {
    this.className = e, this.zIndex = t, this.tooltip = i;
  }
}
class moe {
  constructor() {
    this.decorations = [];
  }
  add(e) {
    this.decorations.push(e);
  }
  getDecorations() {
    return this.decorations;
  }
}
class P8 extends Ku {
  /**
   * Returns an array with an element for each visible line number.
   */
  _render(e, t, i) {
    const n = [];
    for (let a = e; a <= t; a++) {
      const l = a - e;
      n[l] = new moe();
    }
    if (i.length === 0)
      return n;
    i.sort((a, l) => a.className === l.className ? a.startLineNumber === l.startLineNumber ? a.endLineNumber - l.endLineNumber : a.startLineNumber - l.startLineNumber : a.className < l.className ? -1 : 1);
    let o = null, r = 0;
    for (let a = 0, l = i.length; a < l; a++) {
      const c = i[a], d = c.className, h = c.zIndex;
      let u = Math.max(c.startLineNumber, e) - e;
      const g = Math.min(c.endLineNumber, t) - e;
      o === d ? (u = Math.max(r + 1, u), r = Math.max(r, g)) : (o = d, r = g);
      for (let m = u; m <= r; m++)
        n[m].add(new foe(d, h, c.tooltip));
    }
    return n;
  }
}
class poe extends Ds {
  constructor(e) {
    super(e), this._widgets = {}, this._context = e;
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode = rt(document.createElement("div")), this.domNode.setClassName("glyph-margin-widgets"), this.domNode.setPosition("absolute"), this.domNode.setTop(0), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, this._managedDomNodes = [], this._decorationGlyphsToRender = [];
  }
  dispose() {
    this._managedDomNodes = [], this._decorationGlyphsToRender = [], this._widgets = {}, super.dispose();
  }
  getWidgets() {
    return Object.values(this._widgets);
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._glyphMargin = t.get(
      57
      /* EditorOption.glyphMargin */
    ), this._glyphMarginLeft = i.glyphMarginLeft, this._glyphMarginWidth = i.glyphMarginWidth, this._glyphMarginDecorationLaneCount = i.glyphMarginDecorationLaneCount, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // --- begin widget management
  addWidget(e) {
    const t = rt(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: e.getPosition(),
      domNode: t,
      renderInfo: null
    }, t.setPosition("absolute"), t.setDisplay("none"), t.setAttribute("widgetId", e.getId()), this.domNode.appendChild(t), this.setShouldRender();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()];
    return i.preference.lane === t.lane && i.preference.zIndex === t.zIndex && E.equalsRange(i.preference.range, t.range) ? !1 : (i.preference = t, this.setShouldRender(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets[t]) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender();
    }
  }
  // --- end widget management
  _collectDecorationBasedGlyphRenderRequest(e, t) {
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber, o = e.getDecorationsInViewport();
    for (const r of o) {
      const a = r.options.glyphMarginClassName;
      if (!a)
        continue;
      const l = Math.max(r.range.startLineNumber, i), c = Math.min(r.range.endLineNumber, n), d = r.options.glyphMargin?.position ?? qo.Center, h = r.options.zIndex ?? 0;
      for (let u = l; u <= c; u++) {
        const g = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(u, 0)), m = this._context.viewModel.glyphLanes.getLanesAtLine(g.lineNumber).indexOf(d);
        t.push(new Aoe(u, m, h, a));
      }
    }
  }
  _collectWidgetBasedGlyphRenderRequest(e, t) {
    const i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (const o of Object.values(this._widgets)) {
      const r = o.preference.range, { startLineNumber: a, endLineNumber: l } = this._context.viewModel.coordinatesConverter.convertModelRangeToViewRange(E.lift(r));
      if (!a || !l || l < i || a > n)
        continue;
      const c = Math.max(a, i), d = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(c, 0)), h = this._context.viewModel.glyphLanes.getLanesAtLine(d.lineNumber).indexOf(o.preference.lane);
      t.push(new _oe(c, h, o.preference.zIndex, o));
    }
  }
  _collectSortedGlyphRenderRequests(e) {
    const t = [];
    return this._collectDecorationBasedGlyphRenderRequest(e, t), this._collectWidgetBasedGlyphRenderRequest(e, t), t.sort((i, n) => i.lineNumber === n.lineNumber ? i.laneIndex === n.laneIndex ? i.zIndex === n.zIndex ? n.type === i.type ? i.type === 0 && n.type === 0 ? i.className < n.className ? -1 : 1 : 0 : n.type - i.type : n.zIndex - i.zIndex : i.laneIndex - n.laneIndex : i.lineNumber - n.lineNumber), t;
  }
  /**
   * Will store render information in each widget's renderInfo and in `_decorationGlyphsToRender`.
   */
  prepareRender(e) {
    if (!this._glyphMargin) {
      this._decorationGlyphsToRender = [];
      return;
    }
    for (const n of Object.values(this._widgets))
      n.renderInfo = null;
    const t = new Pl(this._collectSortedGlyphRenderRequests(e)), i = [];
    for (; t.length > 0; ) {
      const n = t.peek();
      if (!n)
        break;
      const o = t.takeWhile((a) => a.lineNumber === n.lineNumber && a.laneIndex === n.laneIndex);
      if (!o || o.length === 0)
        break;
      const r = o[0];
      if (r.type === 0) {
        const a = [];
        for (const l of o) {
          if (l.zIndex !== r.zIndex || l.type !== r.type)
            break;
          (a.length === 0 || a[a.length - 1] !== l.className) && a.push(l.className);
        }
        i.push(r.accept(a.join(" ")));
      } else
        r.widget.renderInfo = {
          lineNumber: r.lineNumber,
          laneIndex: r.laneIndex
        };
    }
    this._decorationGlyphsToRender = i;
  }
  render(e) {
    if (!this._glyphMargin) {
      for (const i of Object.values(this._widgets))
        i.domNode.setDisplay("none");
      for (; this._managedDomNodes.length > 0; )
        this._managedDomNodes.pop()?.domNode.remove();
      return;
    }
    const t = Math.round(this._glyphMarginWidth / this._glyphMarginDecorationLaneCount);
    for (const i of Object.values(this._widgets))
      if (!i.renderInfo)
        i.domNode.setDisplay("none");
      else {
        const n = e.viewportData.relativeVerticalOffset[i.renderInfo.lineNumber - e.viewportData.startLineNumber], o = this._glyphMarginLeft + i.renderInfo.laneIndex * this._lineHeight;
        i.domNode.setDisplay("block"), i.domNode.setTop(n), i.domNode.setLeft(o), i.domNode.setWidth(t), i.domNode.setHeight(this._lineHeight);
      }
    for (let i = 0; i < this._decorationGlyphsToRender.length; i++) {
      const n = this._decorationGlyphsToRender[i], o = e.viewportData.relativeVerticalOffset[n.lineNumber - e.viewportData.startLineNumber], r = this._glyphMarginLeft + n.laneIndex * this._lineHeight;
      let a;
      i < this._managedDomNodes.length ? a = this._managedDomNodes[i] : (a = rt(document.createElement("div")), this._managedDomNodes.push(a), this.domNode.appendChild(a)), a.setClassName("cgmr codicon " + n.combinedClassName), a.setPosition("absolute"), a.setTop(o), a.setLeft(r), a.setWidth(t), a.setHeight(this._lineHeight);
    }
    for (; this._managedDomNodes.length > this._decorationGlyphsToRender.length; )
      this._managedDomNodes.pop()?.domNode.remove();
  }
}
class Aoe {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.className = n, this.type = 0;
  }
  accept(e) {
    return new boe(this.lineNumber, this.laneIndex, e);
  }
}
class _oe {
  constructor(e, t, i, n) {
    this.lineNumber = e, this.laneIndex = t, this.zIndex = i, this.widget = n, this.type = 1;
  }
}
class boe {
  constructor(e, t, i) {
    this.lineNumber = e, this.laneIndex = t, this.combinedClassName = i;
  }
}
class woe extends Ku {
  constructor(e) {
    super(), this._context = e, this._primaryPosition = null;
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._spaceWidth = n.spaceWidth, this._maxIndentLeft = i.wrappingColumn === -1 ? -1 : i.wrappingColumn * n.typicalHalfwidthCharacterWidth, this._bracketPairGuideOptions = t.get(
      16
      /* EditorOption.guides */
    ), !0;
  }
  onCursorStateChanged(e) {
    const i = e.selections[0].getPosition();
    return this._primaryPosition?.equals(i) ? !1 : (this._primaryPosition = i, !0);
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLanguageConfigurationChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (!this._bracketPairGuideOptions.indentation && this._bracketPairGuideOptions.bracketPairs === !1) {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = e.scrollWidth, o = this._primaryPosition, r = this.getGuidesByLine(t, Math.min(i + 1, this._context.viewModel.getLineCount()), o), a = [];
    for (let l = t; l <= i; l++) {
      const c = l - t, d = r[c];
      let h = "";
      const u = e.visibleRangeForPosition(new F(l, 1))?.left ?? 0;
      for (const g of d) {
        const m = g.column === -1 ? u + (g.visibleColumn - 1) * this._spaceWidth : e.visibleRangeForPosition(new F(l, g.column)).left;
        if (m > n || this._maxIndentLeft > 0 && m > this._maxIndentLeft)
          break;
        const p = g.horizontalLine ? g.horizontalLine.top ? "horizontal-top" : "horizontal-bottom" : "vertical", A = g.horizontalLine ? (e.visibleRangeForPosition(new F(l, g.horizontalLine.endColumn))?.left ?? m + this._spaceWidth) - m : this._spaceWidth;
        h += `<div class="core-guide ${g.className} ${p}" style="left:${m}px;width:${A}px"></div>`;
      }
      a[c] = h;
    }
    this._renderResult = a;
  }
  getGuidesByLine(e, t, i) {
    const n = this._bracketPairGuideOptions.bracketPairs !== !1 ? this._context.viewModel.getBracketGuidesInRangeByLine(e, t, i, {
      highlightActive: this._bracketPairGuideOptions.highlightActiveBracketPair,
      horizontalGuides: this._bracketPairGuideOptions.bracketPairsHorizontal === !0 ? Mh.Enabled : this._bracketPairGuideOptions.bracketPairsHorizontal === "active" ? Mh.EnabledForActive : Mh.Disabled,
      includeInactive: this._bracketPairGuideOptions.bracketPairs === !0
    }) : null, o = this._bracketPairGuideOptions.indentation ? this._context.viewModel.getLinesIndentGuides(e, t) : null;
    let r = 0, a = 0, l = 0;
    if (this._bracketPairGuideOptions.highlightActiveIndentation !== !1 && i) {
      const h = this._context.viewModel.getActiveIndentGuide(i.lineNumber, e, t);
      r = h.startLineNumber, a = h.endLineNumber, l = h.indent;
    }
    const { indentSize: c } = this._context.viewModel.model.getOptions(), d = [];
    for (let h = e; h <= t; h++) {
      const u = new Array();
      d.push(u);
      const g = n ? n[h - e] : [], m = new Pl(g), p = o ? o[h - e] : 0;
      for (let A = 1; A <= p; A++) {
        const _ = (A - 1) * c + 1, b = (
          // Disable active indent guide if there are bracket guides.
          (this._bracketPairGuideOptions.highlightActiveIndentation === "always" || g.length === 0) && r <= h && h <= a && A === l
        );
        u.push(...m.takeWhile((w) => w.visibleColumn < _) || []);
        const C = m.peek();
        (!C || C.visibleColumn !== _ || C.horizontalLine) && u.push(new vh(_, -1, `core-guide-indent lvl-${(A - 1) % 30}` + (b ? " indent-active" : ""), null, -1, -1));
      }
      u.push(...m.takeWhile((A) => !0) || []);
    }
    return d;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
function gg(s) {
  if (!(s && s.isTransparent()))
    return s;
}
rr((s, e) => {
  const t = [
    { bracketColor: eW, guideColor: TX, guideColorActive: HX },
    { bracketColor: tW, guideColor: BX, guideColorActive: WX },
    { bracketColor: iW, guideColor: RX, guideColorActive: VX },
    { bracketColor: nW, guideColor: FX, guideColorActive: zX },
    { bracketColor: sW, guideColor: OX, guideColorActive: UX },
    { bracketColor: oW, guideColor: PX, guideColorActive: QX }
  ], i = new fW(), n = [
    { indentColor: z_, indentColorActive: U_ },
    { indentColor: uX, indentColorActive: AX },
    { indentColor: gX, indentColorActive: _X },
    { indentColor: fX, indentColorActive: bX },
    { indentColor: mX, indentColorActive: wX },
    { indentColor: pX, indentColorActive: CX }
  ], o = t.map((a) => {
    const l = s.getColor(a.bracketColor), c = s.getColor(a.guideColor), d = s.getColor(a.guideColorActive), h = gg(gg(c) ?? l?.transparent(0.3)), u = gg(gg(d) ?? l);
    if (!(!h || !u))
      return {
        guideColor: h,
        guideColorActive: u
      };
  }).filter(Pf), r = n.map((a) => {
    const l = s.getColor(a.indentColor), c = s.getColor(a.indentColorActive), d = gg(l), h = gg(c);
    if (!(!d || !h))
      return {
        indentColor: d,
        indentColorActive: h
      };
  }).filter(Pf);
  if (o.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = o[a % o.length];
      e.addRule(`.monaco-editor .${i.getInlineClassNameOfLevel(a).replace(/ /g, ".")} { --guide-color: ${l.guideColor}; --guide-color-active: ${l.guideColorActive}; }`);
    }
    e.addRule(".monaco-editor .vertical { box-shadow: 1px 0 0 0 var(--guide-color) inset; }"), e.addRule(".monaco-editor .horizontal-top { border-top: 1px solid var(--guide-color); }"), e.addRule(".monaco-editor .horizontal-bottom { border-bottom: 1px solid var(--guide-color); }"), e.addRule(`.monaco-editor .vertical.${i.activeClassName} { box-shadow: 1px 0 0 0 var(--guide-color-active) inset; }`), e.addRule(`.monaco-editor .horizontal-top.${i.activeClassName} { border-top: 1px solid var(--guide-color-active); }`), e.addRule(`.monaco-editor .horizontal-bottom.${i.activeClassName} { border-bottom: 1px solid var(--guide-color-active); }`);
  }
  if (r.length > 0) {
    for (let a = 0; a < 30; a++) {
      const l = r[a % r.length];
      e.addRule(`.monaco-editor .lines-content .core-guide-indent.lvl-${a} { --indent-color: ${l.indentColor}; --indent-color-active: ${l.indentColorActive}; }`);
    }
    e.addRule(".monaco-editor .lines-content .core-guide-indent { box-shadow: 1px 0 0 0 var(--indent-color) inset; }"), e.addRule(".monaco-editor .lines-content .core-guide-indent.indent-active { box-shadow: 1px 0 0 0 var(--indent-color-active) inset; }");
  }
});
class ix {
  get didDomLayout() {
    return this._didDomLayout;
  }
  readClientRect() {
    if (!this._clientRectRead) {
      this._clientRectRead = !0;
      const e = this._domNode.getBoundingClientRect();
      this.markDidDomLayout(), this._clientRectDeltaLeft = e.left, this._clientRectScale = e.width / this._domNode.offsetWidth;
    }
  }
  get clientRectDeltaLeft() {
    return this._clientRectRead || this.readClientRect(), this._clientRectDeltaLeft;
  }
  get clientRectScale() {
    return this._clientRectRead || this.readClientRect(), this._clientRectScale;
  }
  constructor(e, t) {
    this._domNode = e, this.endNode = t, this._didDomLayout = !1, this._clientRectDeltaLeft = 0, this._clientRectScale = 1, this._clientRectRead = !1;
  }
  markDidDomLayout() {
    this._didDomLayout = !0;
  }
}
class Coe {
  constructor() {
    this._currentVisibleRange = new E(1, 1, 1, 1);
  }
  getCurrentVisibleRange() {
    return this._currentVisibleRange;
  }
  setCurrentVisibleRange(e) {
    this._currentVisibleRange = e;
  }
}
class voe {
  constructor(e, t, i, n, o, r, a) {
    this.minimalReveal = e, this.lineNumber = t, this.startColumn = i, this.endColumn = n, this.startScrollTop = o, this.stopScrollTop = r, this.scrollType = a, this.type = "range", this.minLineNumber = t, this.maxLineNumber = t;
  }
}
class Soe {
  constructor(e, t, i, n, o) {
    this.minimalReveal = e, this.selections = t, this.startScrollTop = i, this.stopScrollTop = n, this.scrollType = o, this.type = "selections";
    let r = t[0].startLineNumber, a = t[0].endLineNumber;
    for (let l = 1, c = t.length; l < c; l++) {
      const d = t[l];
      r = Math.min(r, d.startLineNumber), a = Math.max(a, d.endLineNumber);
    }
    this.minLineNumber = r, this.maxLineNumber = a;
  }
}
const K1 = class K1 extends Ds {
  constructor(e, t) {
    super(e);
    const i = this._context.configuration, n = this._context.configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      147
      /* EditorOption.wrappingInfo */
    );
    this._lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = o.typicalHalfwidthCharacterWidth, this._isViewportWrapping = r.isViewportWrapping, this._revealHorizontalRightPadding = n.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = n.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = n.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !n.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._viewLineOptions = new xO(i, this._context.theme.type), this._linesContent = t, this._textRangeRestingSpot = document.createElement("div"), this._visibleLines = new R8({
      createLine: () => new Al(this._viewLineOptions)
    }), this.domNode = this._visibleLines.domNode, Pr.write(
      this.domNode,
      8
      /* PartFingerprint.ViewLines */
    ), this.domNode.setClassName(`view-lines ${Mf}`), cn(this.domNode, o), this._maxLineWidth = 0, this._asyncUpdateLineWidths = new zt(() => {
      this._updateLineWidthsSlow();
    }, 200), this._asyncCheckMonospaceFontAssumptions = new zt(() => {
      this._checkMonospaceFontAssumptions();
    }, 2e3), this._lastRenderedData = new Coe(), this._horizontalRevealRequest = null, this._stickyScrollEnabled = n.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = n.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount;
  }
  dispose() {
    this._asyncUpdateLineWidths.dispose(), this._asyncCheckMonospaceFontAssumptions.dispose(), super.dispose();
  }
  getDomNode() {
    return this.domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    this._visibleLines.onConfigurationChanged(e), e.hasChanged(
      147
      /* EditorOption.wrappingInfo */
    ) && (this._maxLineWidth = 0);
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      147
      /* EditorOption.wrappingInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._isViewportWrapping = n.isViewportWrapping, this._revealHorizontalRightPadding = t.get(
      101
      /* EditorOption.revealHorizontalRightPadding */
    ), this._cursorSurroundingLines = t.get(
      29
      /* EditorOption.cursorSurroundingLines */
    ), this._cursorSurroundingLinesStyle = t.get(
      30
      /* EditorOption.cursorSurroundingLinesStyle */
    ), this._canUseLayerHinting = !t.get(
      32
      /* EditorOption.disableLayerHinting */
    ), this._stickyScrollEnabled = t.get(
      116
      /* EditorOption.stickyScroll */
    ).enabled, this._maxNumberStickyLines = t.get(
      116
      /* EditorOption.stickyScroll */
    ).maxLineCount, cn(this.domNode, i), this._onOptionsMaybeChanged(), e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) && (this._maxLineWidth = 0), !0;
  }
  _onOptionsMaybeChanged() {
    const e = this._context.configuration, t = new xO(e, this._context.theme.type);
    if (!this._viewLineOptions.equals(t)) {
      this._viewLineOptions = t;
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onOptionsChanged(this._viewLineOptions);
      return !0;
    }
    return !1;
  }
  onCursorStateChanged(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = !1;
    for (let o = t; o <= i; o++)
      n = this._visibleLines.getVisibleLine(o).onSelectionChanged() || n;
    return n;
  }
  onDecorationsChanged(e) {
    {
      const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
      for (let n = t; n <= i; n++)
        this._visibleLines.getVisibleLine(n).onDecorationsChanged();
    }
    return !0;
  }
  onFlushed(e) {
    const t = this._visibleLines.onFlushed(e);
    return this._maxLineWidth = 0, t;
  }
  onLinesChanged(e) {
    return this._visibleLines.onLinesChanged(e);
  }
  onLinesDeleted(e) {
    return this._visibleLines.onLinesDeleted(e);
  }
  onLinesInserted(e) {
    return this._visibleLines.onLinesInserted(e);
  }
  onRevealRangeRequest(e) {
    const t = this._computeScrollTopToRevealRange(this._context.viewLayout.getFutureViewport(), e.source, e.minimalReveal, e.range, e.selections, e.verticalType);
    if (t === -1)
      return !1;
    let i = this._context.viewLayout.validateScrollPosition({ scrollTop: t });
    e.revealHorizontal ? e.range && e.range.startLineNumber !== e.range.endLineNumber ? i = {
      scrollTop: i.scrollTop,
      scrollLeft: 0
    } : e.range ? this._horizontalRevealRequest = new voe(e.minimalReveal, e.range.startLineNumber, e.range.startColumn, e.range.endColumn, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType) : e.selections && e.selections.length > 0 && (this._horizontalRevealRequest = new Soe(e.minimalReveal, e.selections, this._context.viewLayout.getCurrentScrollTop(), i.scrollTop, e.scrollType)) : this._horizontalRevealRequest = null;
    const o = Math.abs(this._context.viewLayout.getCurrentScrollTop() - i.scrollTop) <= this._lineHeight ? 1 : e.scrollType;
    return this._context.viewModel.viewLayout.setScrollPosition(i, o), !0;
  }
  onScrollChanged(e) {
    if (this._horizontalRevealRequest && e.scrollLeftChanged && (this._horizontalRevealRequest = null), this._horizontalRevealRequest && e.scrollTopChanged) {
      const t = Math.min(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop), i = Math.max(this._horizontalRevealRequest.startScrollTop, this._horizontalRevealRequest.stopScrollTop);
      (e.scrollTop < t || e.scrollTop > i) && (this._horizontalRevealRequest = null);
    }
    return this.domNode.setWidth(e.scrollWidth), this._visibleLines.onScrollChanged(e) || !0;
  }
  onTokensChanged(e) {
    return this._visibleLines.onTokensChanged(e);
  }
  onZonesChanged(e) {
    return this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth), this._visibleLines.onZonesChanged(e);
  }
  onThemeChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  // ---- end view event handlers
  // ----------- HELPERS FOR OTHERS
  getPositionFromDOMInfo(e, t) {
    const i = this._getViewLineDomNode(e);
    if (i === null)
      return null;
    const n = this._getLineNumberFor(i);
    if (n === -1 || n < 1 || n > this._context.viewModel.getLineCount())
      return null;
    if (this._context.viewModel.getLineMaxColumn(n) === 1)
      return new F(n, 1);
    const o = this._visibleLines.getStartLineNumber(), r = this._visibleLines.getEndLineNumber();
    if (n < o || n > r)
      return null;
    let a = this._visibleLines.getVisibleLine(n).getColumnOfNodeOffset(e, t);
    const l = this._context.viewModel.getLineMinColumn(n);
    return a < l && (a = l), new F(n, a);
  }
  _getViewLineDomNode(e) {
    for (; e && e.nodeType === 1; ) {
      if (e.className === Al.CLASS_NAME)
        return e;
      e = e.parentElement;
    }
    return null;
  }
  /**
   * @returns the line number of this view line dom node.
   */
  _getLineNumberFor(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    for (let n = t; n <= i; n++) {
      const o = this._visibleLines.getVisibleLine(n);
      if (e === o.getDomNode())
        return n;
    }
    return -1;
  }
  getLineWidth(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    if (e < t || e > i)
      return -1;
    const n = new ix(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getWidth(n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  linesVisibleRangesForRange(e, t) {
    if (this.shouldRender())
      return null;
    const i = e.endLineNumber, n = E.intersectRanges(e, this._lastRenderedData.getCurrentVisibleRange());
    if (!n)
      return null;
    const o = [];
    let r = 0;
    const a = new ix(this.domNode.domNode, this._textRangeRestingSpot);
    let l = 0;
    t && (l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(n.startLineNumber, 1)).lineNumber);
    const c = this._visibleLines.getStartLineNumber(), d = this._visibleLines.getEndLineNumber();
    for (let h = n.startLineNumber; h <= n.endLineNumber; h++) {
      if (h < c || h > d)
        continue;
      const u = h === n.startLineNumber ? n.startColumn : 1, g = h !== n.endLineNumber, m = g ? this._context.viewModel.getLineMaxColumn(h) : n.endColumn, p = this._visibleLines.getVisibleLine(h).getVisibleRangesForRange(h, u, m, a);
      if (p) {
        if (t && h < i) {
          const A = l;
          l = this._context.viewModel.coordinatesConverter.convertViewPositionToModelPosition(new F(h + 1, 1)).lineNumber, A !== l && (p.ranges[p.ranges.length - 1].width += this._typicalHalfwidthCharacterWidth);
        }
        o[r++] = new ase(p.outsideRenderedLine, h, SS.from(p.ranges), g);
      }
    }
    return this._updateLineWidthsSlowIfDomDidLayout(a), r === 0 ? null : o;
  }
  _visibleRangesForLineRange(e, t, i) {
    if (this.shouldRender() || e < this._visibleLines.getStartLineNumber() || e > this._visibleLines.getEndLineNumber())
      return null;
    const n = new ix(this.domNode.domNode, this._textRangeRestingSpot), o = this._visibleLines.getVisibleLine(e).getVisibleRangesForRange(e, t, i, n);
    return this._updateLineWidthsSlowIfDomDidLayout(n), o;
  }
  visibleRangeForPosition(e) {
    const t = this._visibleRangesForLineRange(e.lineNumber, e.column, e.column);
    return t ? new lse(t.outsideRenderedLine, t.ranges[0].left) : null;
  }
  /**
   * Updates the max line width if it is fast to compute.
   * Returns true if all lines were taken into account.
   * Returns false if some lines need to be reevaluated (in a slow fashion).
   */
  _updateLineWidthsFast() {
    return this._updateLineWidths(!0);
  }
  _updateLineWidthsSlow() {
    this._updateLineWidths(!1);
  }
  /**
   * Update the line widths using DOM layout information after someone else
   * has caused a synchronous layout.
   */
  _updateLineWidthsSlowIfDomDidLayout(e) {
    e.didDomLayout && (this._asyncUpdateLineWidths.isScheduled() || (this._asyncUpdateLineWidths.cancel(), this._updateLineWidthsSlow()));
  }
  _updateLineWidths(e) {
    const t = this._visibleLines.getStartLineNumber(), i = this._visibleLines.getEndLineNumber();
    let n = 1, o = !0;
    for (let r = t; r <= i; r++) {
      const a = this._visibleLines.getVisibleLine(r);
      if (e && !a.getWidthIsFast()) {
        o = !1;
        continue;
      }
      n = Math.max(n, a.getWidth(null));
    }
    return o && t === 1 && i === this._context.viewModel.getLineCount() && (this._maxLineWidth = 0), this._ensureMaxLineWidth(n), o;
  }
  _checkMonospaceFontAssumptions() {
    let e = -1, t = -1;
    const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
    for (let o = i; o <= n; o++) {
      const r = this._visibleLines.getVisibleLine(o);
      if (r.needsMonospaceFontCheck()) {
        const a = r.getWidth(null);
        a > t && (t = a, e = o);
      }
    }
    if (e !== -1 && !this._visibleLines.getVisibleLine(e).monospaceAssumptionsAreValid())
      for (let o = i; o <= n; o++)
        this._visibleLines.getVisibleLine(o).onMonospaceAssumptionsInvalidated();
  }
  prepareRender() {
    throw new Error("Not supported");
  }
  render() {
    throw new Error("Not supported");
  }
  renderText(e) {
    if (this._visibleLines.renderLines(e), this._lastRenderedData.setCurrentVisibleRange(e.visibleRange), this.domNode.setWidth(this._context.viewLayout.getScrollWidth()), this.domNode.setHeight(Math.min(this._context.viewLayout.getScrollHeight(), 1e6)), this._horizontalRevealRequest) {
      const i = this._horizontalRevealRequest;
      if (e.startLineNumber <= i.minLineNumber && i.maxLineNumber <= e.endLineNumber) {
        this._horizontalRevealRequest = null, this.onDidRender();
        const n = this._computeScrollLeftToReveal(i);
        n && (this._isViewportWrapping || this._ensureMaxLineWidth(n.maxHorizontalOffset), this._context.viewModel.viewLayout.setScrollPosition({
          scrollLeft: n.scrollLeft
        }, i.scrollType));
      }
    }
    if (this._updateLineWidthsFast() ? this._asyncUpdateLineWidths.cancel() : this._asyncUpdateLineWidths.schedule(), Fn && !this._asyncCheckMonospaceFontAssumptions.isScheduled()) {
      const i = this._visibleLines.getStartLineNumber(), n = this._visibleLines.getEndLineNumber();
      for (let o = i; o <= n; o++)
        if (this._visibleLines.getVisibleLine(o).needsMonospaceFontCheck()) {
          this._asyncCheckMonospaceFontAssumptions.schedule();
          break;
        }
    }
    this._linesContent.setLayerHinting(this._canUseLayerHinting), this._linesContent.setContain("strict");
    const t = this._context.viewLayout.getCurrentScrollTop() - e.bigNumbersDelta;
    this._linesContent.setTop(-t), this._linesContent.setLeft(-this._context.viewLayout.getCurrentScrollLeft());
  }
  // --- width
  _ensureMaxLineWidth(e) {
    const t = Math.ceil(e);
    this._maxLineWidth < t && (this._maxLineWidth = t, this._context.viewModel.viewLayout.setMaxLineWidth(this._maxLineWidth));
  }
  _computeScrollTopToRevealRange(e, t, i, n, o, r) {
    const a = e.top, l = e.height, c = a + l;
    let d, h, u;
    if (o && o.length > 0) {
      let _ = o[0].startLineNumber, b = o[0].endLineNumber;
      for (let C = 1, w = o.length; C < w; C++) {
        const S = o[C];
        _ = Math.min(_, S.startLineNumber), b = Math.max(b, S.endLineNumber);
      }
      d = !1, h = this._context.viewLayout.getVerticalOffsetForLineNumber(_), u = this._context.viewLayout.getVerticalOffsetForLineNumber(b) + this._lineHeight;
    } else if (n)
      d = !0, h = this._context.viewLayout.getVerticalOffsetForLineNumber(n.startLineNumber), u = this._context.viewLayout.getVerticalOffsetForLineNumber(n.endLineNumber) + this._lineHeight;
    else
      return -1;
    const g = (t === "mouse" || i) && this._cursorSurroundingLinesStyle === "default";
    let m = 0, p = 0;
    if (g)
      i || (m = this._lineHeight);
    else {
      const _ = l / this._lineHeight, b = Math.max(this._cursorSurroundingLines, this._stickyScrollEnabled ? this._maxNumberStickyLines : 0), C = Math.min(_ / 2, b);
      m = C * this._lineHeight, p = Math.max(0, C - 1) * this._lineHeight;
    }
    i || (r === 0 || r === 4) && (p += this._lineHeight), h -= m, u += p;
    let A;
    if (u - h > l) {
      if (!d)
        return -1;
      A = h;
    } else if (r === 5 || r === 6)
      if (r === 6 && a <= h && u <= c)
        A = a;
      else {
        const _ = Math.max(5 * this._lineHeight, l * 0.2), b = h - _, C = u - l;
        A = Math.max(C, b);
      }
    else if (r === 1 || r === 2)
      if (r === 2 && a <= h && u <= c)
        A = a;
      else {
        const _ = (h + u) / 2;
        A = Math.max(0, _ - l / 2);
      }
    else
      A = this._computeMinimumScrolling(
        a,
        c,
        h,
        u,
        r === 3,
        r === 4
        /* viewEvents.VerticalRevealType.Bottom */
      );
    return A;
  }
  _computeScrollLeftToReveal(e) {
    const t = this._context.viewLayout.getCurrentViewport(), i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), n = t.left, o = n + t.width - i.verticalScrollbarWidth;
    let r = 1073741824, a = 0;
    if (e.type === "range") {
      const c = this._visibleRangesForLineRange(e.lineNumber, e.startColumn, e.endColumn);
      if (!c)
        return null;
      for (const d of c.ranges)
        r = Math.min(r, Math.round(d.left)), a = Math.max(a, Math.round(d.left + d.width));
    } else
      for (const c of e.selections) {
        if (c.startLineNumber !== c.endLineNumber)
          return null;
        const d = this._visibleRangesForLineRange(c.startLineNumber, c.startColumn, c.endColumn);
        if (!d)
          return null;
        for (const h of d.ranges)
          r = Math.min(r, Math.round(h.left)), a = Math.max(a, Math.round(h.left + h.width));
      }
    return e.minimalReveal || (r = Math.max(0, r - K1.HORIZONTAL_EXTRA_PX), a += this._revealHorizontalRightPadding), e.type === "selections" && a - r > t.width ? null : {
      scrollLeft: this._computeMinimumScrolling(n, o, r, a),
      maxHorizontalOffset: a
    };
  }
  _computeMinimumScrolling(e, t, i, n, o, r) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, o = !!o, r = !!r;
    const a = t - e;
    if (n - i < a) {
      if (o)
        return i;
      if (r)
        return Math.max(0, n - a);
      if (i < e)
        return i;
      if (n > t)
        return Math.max(0, n - a);
    } else
      return i;
    return e;
  }
};
K1.HORIZONTAL_EXTRA_PX = 30;
let SD = K1;
class yoe extends P8 {
  constructor(e) {
    super(), this._context = e;
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._decorationsLeft = i.decorationsLeft, this._decorationsWidth = i.decorationsWidth, !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.linesDecorationsClassName, c = a.options.zIndex;
      l && (i[n++] = new vD(a.range.startLineNumber, a.range.endLineNumber, l, a.options.linesDecorationsTooltip ?? null, c));
      const d = a.options.firstLineDecorationClassName;
      d && (i[n++] = new vD(a.range.startLineNumber, a.range.startLineNumber, d, a.options.linesDecorationsTooltip ?? null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = this._decorationsLeft.toString(), r = this._decorationsWidth.toString(), a = '" style="left:' + o + "px;width:" + r + 'px;"></div>', l = [];
    for (let c = t; c <= i; c++) {
      const d = c - t, h = n[d].getDecorations();
      let u = "";
      for (const g of h) {
        let m = '<div class="cldr ' + g.className;
        g.tooltip !== null && (m += '" title="' + g.tooltip), m += a, u += m;
      }
      l[d] = u;
    }
    this._renderResult = l;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
class xoe extends P8 {
  constructor(e) {
    super(), this._context = e, this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    return !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _getDecorations(e) {
    const t = e.getDecorationsInViewport(), i = [];
    let n = 0;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o], l = a.options.marginClassName, c = a.options.zIndex;
      l && (i[n++] = new vD(a.range.startLineNumber, a.range.endLineNumber, l, null, c));
    }
    return i;
  }
  prepareRender(e) {
    const t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber, n = this._render(t, i, this._getDecorations(e)), o = [];
    for (let r = t; r <= i; r++) {
      const a = r - t, l = n[a].getDecorations();
      let c = "";
      for (const d of l)
        c += '<div class="cmdr ' + d.className + '" style=""></div>';
      o[a] = c;
    }
    this._renderResult = o;
  }
  render(e, t) {
    return this._renderResult ? this._renderResult[t - e] : "";
  }
}
const mc = class mc {
  constructor(e, t, i, n) {
    this._rgba8Brand = void 0, this.r = mc._clamp(e), this.g = mc._clamp(t), this.b = mc._clamp(i), this.a = mc._clamp(n);
  }
  equals(e) {
    return this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  static _clamp(e) {
    return e < 0 ? 0 : e > 255 ? 255 : e | 0;
  }
};
mc.Empty = new mc(0, 0, 0, 0);
let Ol = mc;
const J1 = class J1 extends V {
  static getInstance() {
    return this._INSTANCE || (this._INSTANCE = new J1()), this._INSTANCE;
  }
  constructor() {
    super(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._updateColorMap(), this._register(ci.onDidChange((e) => {
      e.changedColorMap && this._updateColorMap();
    }));
  }
  _updateColorMap() {
    const e = ci.getColorMap();
    if (!e) {
      this._colors = [Ol.Empty], this._backgroundIsLight = !0;
      return;
    }
    this._colors = [Ol.Empty];
    for (let i = 1; i < e.length; i++) {
      const n = e[i].rgba;
      this._colors[i] = new Ol(n.r, n.g, n.b, Math.round(n.a * 255));
    }
    const t = e[
      2
      /* ColorId.DefaultBackground */
    ].getRelativeLuminance();
    this._backgroundIsLight = t >= 0.5, this._onDidChange.fire(void 0);
  }
  getColor(e) {
    return (e < 1 || e >= this._colors.length) && (e = 2), this._colors[e];
  }
  backgroundIsLight() {
    return this._backgroundIsLight;
  }
};
J1._INSTANCE = null;
let Lv = J1;
const Eoe = (() => {
  const s = [];
  for (let e = 32; e <= 126; e++)
    s.push(e);
  return s.push(
    65533
    /* Constants.UNKNOWN_CODE */
  ), s;
})(), Loe = (s, e) => (s -= 32, s < 0 || s > 96 ? e <= 2 ? (s + 96) % 96 : 95 : s);
class d_ {
  constructor(e, t) {
    this.scale = t, this._minimapCharRendererBrand = void 0, this.charDataNormal = d_.soften(e, 12 / 15), this.charDataLight = d_.soften(e, 50 / 60);
  }
  static soften(e, t) {
    const i = new Uint8ClampedArray(e.length);
    for (let n = 0, o = e.length; n < o; n++)
      i[n] = hC(e[n] * t);
    return i;
  }
  renderChar(e, t, i, n, o, r, a, l, c, d, h) {
    const u = 1 * this.scale, g = 2 * this.scale, m = h ? 1 : g;
    if (t + u > e.width || i + m > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const p = d ? this.charDataLight : this.charDataNormal, A = Loe(n, c), _ = e.width * 4, b = a.r, C = a.g, w = a.b, S = o.r - b, x = o.g - C, y = o.b - w, D = Math.max(r, l), I = e.data;
    let Q = A * u * g, P = i * _ + t * 4;
    for (let W = 0; W < m; W++) {
      let j = P;
      for (let H = 0; H < u; H++) {
        const J = p[Q++] / 255 * (r / 255);
        I[j++] = b + S * J, I[j++] = C + x * J, I[j++] = w + y * J, I[j++] = D;
      }
      P += _;
    }
  }
  blockRenderChar(e, t, i, n, o, r, a, l) {
    const c = 1 * this.scale, d = 2 * this.scale, h = l ? 1 : d;
    if (t + c > e.width || i + h > e.height) {
      console.warn("bad render request outside image data");
      return;
    }
    const u = e.width * 4, g = 0.5 * (o / 255), m = r.r, p = r.g, A = r.b, _ = n.r - m, b = n.g - p, C = n.b - A, w = m + _ * g, S = p + b * g, x = A + C * g, y = Math.max(o, a), D = e.data;
    let I = i * u + t * 4;
    for (let Q = 0; Q < h; Q++) {
      let P = I;
      for (let W = 0; W < c; W++)
        D[P++] = w, D[P++] = S, D[P++] = x, D[P++] = y;
      I += u;
    }
  }
}
const FO = {
  0: 0,
  1: 1,
  2: 2,
  3: 3,
  4: 4,
  5: 5,
  6: 6,
  7: 7,
  8: 8,
  9: 9,
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
}, OO = (s) => {
  const e = new Uint8ClampedArray(s.length / 2);
  for (let t = 0; t < s.length; t += 2)
    e[t >> 1] = FO[s[t]] << 4 | FO[s[t + 1]] & 15;
  return e;
}, PO = {
  1: Wf(() => OO("0000511D6300CF609C709645A78432005642574171487021003C451900274D35D762755E8B629C5BA856AF57BA649530C167D1512A272A3F6038604460398526BCA2A968DB6F8957C768BE5FBE2FB467CF5D8D5B795DC7625B5DFF50DE64C466DB2FC47CD860A65E9A2EB96CB54CE06DA763AB2EA26860524D3763536601005116008177A8705E53AB738E6A982F88BAA35B5F5B626D9C636B449B737E5B7B678598869A662F6B5B8542706C704C80736A607578685B70594A49715A4522E792")),
  2: Wf(() => OO("000000000000000055394F383D2800008B8B1F210002000081B1CBCBCC820000847AAF6B9AAF2119BE08B8881AD60000A44FD07DCCF107015338130C00000000385972265F390B406E2437634B4B48031B12B8A0847000001E15B29A402F0000000000004B33460B00007A752C2A0000000000004D3900000084394B82013400ABA5CFC7AD9C0302A45A3E5A98AB000089A43382D97900008BA54AA087A70A0248A6A7AE6DBE0000BF6F94987EA40A01A06DCFA7A7A9030496C32F77891D0000A99FB1A0AFA80603B29AB9CA75930D010C0948354D3900000C0948354F37460D0028BE673D8400000000AF9D7B6E00002B007AA8933400007AA642675C2700007984CFB9C3985B768772A8A6B7B20000CAAECAAFC4B700009F94A6009F840009D09F9BA4CA9C0000CC8FC76DC87F0000C991C472A2000000A894A48CA7B501079BA2C9C69BA20000B19A5D3FA89000005CA6009DA2960901B0A7F0669FB200009D009E00B7890000DAD0F5D092820000D294D4C48BD10000B5A7A4A3B1A50402CAB6CBA6A2000000B5A7A4A3B1A8044FCDADD19D9CB00000B7778F7B8AAE0803C9AB5D3F5D3F00009EA09EA0BAB006039EA0989A8C7900009B9EF4D6B7C00000A9A7816CACA80000ABAC84705D3F000096DA635CDC8C00006F486F266F263D4784006124097B00374F6D2D6D2D6D4A3A95872322000000030000000000008D8939130000000000002E22A5C9CBC70600AB25C0B5C9B400061A2DB04CA67001082AA6BEBEBFC606002321DACBC19E03087AA08B6768380000282FBAC0B8CA7A88AD25BBA5A29900004C396C5894A6000040485A6E356E9442A32CD17EADA70000B4237923628600003E2DE9C1D7B500002F25BBA5A2990000231DB6AFB4A804023025C0B5CAB588062B2CBDBEC0C706882435A75CA20000002326BD6A82A908048B4B9A5A668000002423A09CB4BB060025259C9D8A7900001C1FCAB2C7C700002A2A9387ABA200002626A4A47D6E9D14333163A0C87500004B6F9C2D643A257049364936493647358A34438355497F1A0000A24C1D590000D38DFFBDD4CD3126"))
};
class $p {
  /**
   * Creates a new character renderer factory with the given scale.
   */
  static create(e, t) {
    if (this.lastCreated && e === this.lastCreated.scale && t === this.lastFontFamily)
      return this.lastCreated;
    let i;
    return PO[e] ? i = new d_(PO[e](), e) : i = $p.createFromSampleData($p.createSampleData(t).data, e), this.lastFontFamily = t, this.lastCreated = i, i;
  }
  /**
   * Creates the font sample data, writing to a canvas.
   */
  static createSampleData(e) {
    const t = document.createElement("canvas"), i = t.getContext("2d");
    t.style.height = "16px", t.height = 16, t.width = 96 * 10, t.style.width = 96 * 10 + "px", i.fillStyle = "#ffffff", i.font = `bold 16px ${e}`, i.textBaseline = "middle";
    let n = 0;
    for (const o of Eoe)
      i.fillText(String.fromCharCode(o), n, 16 / 2), n += 10;
    return i.getImageData(
      0,
      0,
      96 * 10,
      16
      /* Constants.SAMPLED_CHAR_HEIGHT */
    );
  }
  /**
   * Creates a character renderer from the canvas sample data.
   */
  static createFromSampleData(e, t) {
    if (e.length !== 61440)
      throw new Error("Unexpected source in MinimapCharRenderer");
    const n = $p._downsample(e, t);
    return new d_(n, t);
  }
  static _downsampleChar(e, t, i, n, o) {
    const r = 1 * o, a = 2 * o;
    let l = n, c = 0;
    for (let d = 0; d < a; d++) {
      const h = d / a * 16, u = (d + 1) / a * 16;
      for (let g = 0; g < r; g++) {
        const m = g / r * 10, p = (g + 1) / r * 10;
        let A = 0, _ = 0;
        for (let C = h; C < u; C++) {
          const w = t + Math.floor(C) * 3840, S = 1 - (C - Math.floor(C));
          for (let x = m; x < p; x++) {
            const y = 1 - (x - Math.floor(x)), D = w + Math.floor(x) * 4, I = y * S;
            _ += I, A += e[D] * e[D + 3] / 255 * I;
          }
        }
        const b = A / _;
        c = Math.max(c, b), i[l++] = hC(b);
      }
    }
    return c;
  }
  static _downsample(e, t) {
    const i = 2 * t * 1 * t, n = i * 96, o = new Uint8ClampedArray(n);
    let r = 0, a = 0, l = 0;
    for (let c = 0; c < 96; c++)
      l = Math.max(l, this._downsampleChar(e, a, o, r, t)), r += i, a += 10 * 4;
    if (l > 0) {
      const c = 255 / l;
      for (let d = 0; d < n; d++)
        o[d] *= c;
    }
    return o;
  }
}
const koe = yn ? '"Segoe WPC", "Segoe UI", sans-serif' : ze ? "-apple-system, BlinkMacSystemFont, sans-serif" : 'system-ui, "Ubuntu", "Droid Sans", sans-serif', Doe = 140, Ioe = 2;
class Nf {
  constructor(e, t, i) {
    const n = e.options, o = n.get(
      144
      /* EditorOption.pixelRatio */
    ), r = n.get(
      146
      /* EditorOption.layoutInfo */
    ), a = r.minimap, l = n.get(
      50
      /* EditorOption.fontInfo */
    ), c = n.get(
      73
      /* EditorOption.minimap */
    );
    this.renderMinimap = a.renderMinimap, this.size = c.size, this.minimapHeightIsEditorHeight = a.minimapHeightIsEditorHeight, this.scrollBeyondLastLine = n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ), this.paddingTop = n.get(
      84
      /* EditorOption.padding */
    ).top, this.paddingBottom = n.get(
      84
      /* EditorOption.padding */
    ).bottom, this.showSlider = c.showSlider, this.autohide = c.autohide, this.pixelRatio = o, this.typicalHalfwidthCharacterWidth = l.typicalHalfwidthCharacterWidth, this.lineHeight = n.get(
      67
      /* EditorOption.lineHeight */
    ), this.minimapLeft = a.minimapLeft, this.minimapWidth = a.minimapWidth, this.minimapHeight = r.height, this.canvasInnerWidth = a.minimapCanvasInnerWidth, this.canvasInnerHeight = a.minimapCanvasInnerHeight, this.canvasOuterWidth = a.minimapCanvasOuterWidth, this.canvasOuterHeight = a.minimapCanvasOuterHeight, this.isSampling = a.minimapIsSampling, this.editorHeight = r.height, this.fontScale = a.minimapScale, this.minimapLineHeight = a.minimapLineHeight, this.minimapCharWidth = 1 * this.fontScale, this.sectionHeaderFontFamily = koe, this.sectionHeaderFontSize = c.sectionHeaderFontSize * o, this.sectionHeaderLetterSpacing = c.sectionHeaderLetterSpacing, this.sectionHeaderFontColor = Nf._getSectionHeaderColor(t, i.getColor(
      1
      /* ColorId.DefaultForeground */
    )), this.charRenderer = Wf(() => $p.create(this.fontScale, l.fontFamily)), this.defaultBackgroundColor = i.getColor(
      2
      /* ColorId.DefaultBackground */
    ), this.backgroundColor = Nf._getMinimapBackground(t, this.defaultBackgroundColor), this.foregroundAlpha = Nf._getMinimapForegroundOpacity(t);
  }
  static _getMinimapBackground(e, t) {
    const i = e.getColor(gY);
    return i ? new Ol(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  static _getMinimapForegroundOpacity(e) {
    const t = e.getColor(fY);
    return t ? Ol._clamp(Math.round(255 * t.rgba.a)) : 255;
  }
  static _getSectionHeaderColor(e, t) {
    const i = e.getColor(Fa);
    return i ? new Ol(i.rgba.r, i.rgba.g, i.rgba.b, Math.round(255 * i.rgba.a)) : t;
  }
  equals(e) {
    return this.renderMinimap === e.renderMinimap && this.size === e.size && this.minimapHeightIsEditorHeight === e.minimapHeightIsEditorHeight && this.scrollBeyondLastLine === e.scrollBeyondLastLine && this.paddingTop === e.paddingTop && this.paddingBottom === e.paddingBottom && this.showSlider === e.showSlider && this.autohide === e.autohide && this.pixelRatio === e.pixelRatio && this.typicalHalfwidthCharacterWidth === e.typicalHalfwidthCharacterWidth && this.lineHeight === e.lineHeight && this.minimapLeft === e.minimapLeft && this.minimapWidth === e.minimapWidth && this.minimapHeight === e.minimapHeight && this.canvasInnerWidth === e.canvasInnerWidth && this.canvasInnerHeight === e.canvasInnerHeight && this.canvasOuterWidth === e.canvasOuterWidth && this.canvasOuterHeight === e.canvasOuterHeight && this.isSampling === e.isSampling && this.editorHeight === e.editorHeight && this.fontScale === e.fontScale && this.minimapLineHeight === e.minimapLineHeight && this.minimapCharWidth === e.minimapCharWidth && this.sectionHeaderFontSize === e.sectionHeaderFontSize && this.sectionHeaderLetterSpacing === e.sectionHeaderLetterSpacing && this.defaultBackgroundColor && this.defaultBackgroundColor.equals(e.defaultBackgroundColor) && this.backgroundColor && this.backgroundColor.equals(e.backgroundColor) && this.foregroundAlpha === e.foregroundAlpha;
  }
}
class Xp {
  constructor(e, t, i, n, o, r, a, l, c) {
    this.scrollTop = e, this.scrollHeight = t, this.sliderNeeded = i, this._computedSliderRatio = n, this.sliderTop = o, this.sliderHeight = r, this.topPaddingLineCount = a, this.startLineNumber = l, this.endLineNumber = c;
  }
  /**
   * Compute a desired `scrollPosition` such that the slider moves by `delta`.
   */
  getDesiredScrollTopFromDelta(e) {
    return Math.round(this.scrollTop + e / this._computedSliderRatio);
  }
  getDesiredScrollTopFromTouchLocation(e) {
    return Math.round((e - this.sliderHeight / 2) / this._computedSliderRatio);
  }
  /**
   * Intersect a line range with `this.startLineNumber` and `this.endLineNumber`.
   */
  intersectWithViewport(e) {
    const t = Math.max(this.startLineNumber, e.startLineNumber), i = Math.min(this.endLineNumber, e.endLineNumber);
    return t > i ? null : [t, i];
  }
  /**
   * Get the inner minimap y coordinate for a line number.
   */
  getYForLineNumber(e, t) {
    return +(e - this.startLineNumber + this.topPaddingLineCount) * t;
  }
  static create(e, t, i, n, o, r, a, l, c, d, h) {
    const u = e.pixelRatio, g = e.minimapLineHeight, m = Math.floor(e.canvasInnerHeight / g), p = e.lineHeight;
    if (e.minimapHeightIsEditorHeight) {
      let x = l * e.lineHeight + e.paddingTop + e.paddingBottom;
      e.scrollBeyondLastLine && (x += Math.max(0, o - e.lineHeight - e.paddingBottom));
      const y = Math.max(1, Math.floor(o * o / x)), D = Math.max(0, e.minimapHeight - y), I = D / (d - o), Q = c * I, P = D > 0, W = Math.floor(e.canvasInnerHeight / e.minimapLineHeight), j = Math.floor(e.paddingTop / e.lineHeight);
      return new Xp(c, d, P, I, Q, y, j, 1, Math.min(a, W));
    }
    let A;
    if (r && i !== a) {
      const x = i - t + 1;
      A = Math.floor(x * g / u);
    } else {
      const x = o / p;
      A = Math.floor(x * g / u);
    }
    const _ = Math.floor(e.paddingTop / p);
    let b = Math.floor(e.paddingBottom / p);
    if (e.scrollBeyondLastLine) {
      const x = o / p;
      b = Math.max(b, x - 1);
    }
    let C;
    if (b > 0) {
      const x = o / p;
      C = (_ + a + b - x - 1) * g / u;
    } else
      C = Math.max(0, (_ + a) * g / u - A);
    C = Math.min(e.minimapHeight - A, C);
    const w = C / (d - o), S = c * w;
    if (m >= _ + a + b) {
      const x = C > 0;
      return new Xp(c, d, x, w, S, A, _, 1, a);
    } else {
      let x;
      t > 1 ? x = t + _ : x = Math.max(1, c / p);
      let y, D = Math.max(1, Math.floor(x - S * u / g));
      D < _ ? (y = _ - D + 1, D = 1) : (y = 0, D = Math.max(1, D - _)), h && h.scrollHeight === d && (h.scrollTop > c && (D = Math.min(D, h.startLineNumber), y = Math.max(y, h.topPaddingLineCount)), h.scrollTop < c && (D = Math.max(D, h.startLineNumber), y = Math.min(y, h.topPaddingLineCount)));
      const I = Math.min(a, D - y + m - 1), Q = (c - n) / p;
      let P;
      return c >= e.paddingTop ? P = (t - D + y + Q) * g / u : P = c / e.paddingTop * (y + Q) * g / u, new Xp(c, d, !0, w, P, A, y, D, I);
    }
  }
}
const q1 = class q1 {
  constructor(e) {
    this.dy = e;
  }
  onContentChanged() {
    this.dy = -1;
  }
  onTokensChanged() {
    this.dy = -1;
  }
};
q1.INVALID = new q1(-1);
let kv = q1;
class HO {
  constructor(e, t, i) {
    this.renderedLayout = e, this._imageData = t, this._renderedLines = new B8({
      createLine: () => kv.INVALID
    }), this._renderedLines._set(e.startLineNumber, i);
  }
  /**
   * Check if the current RenderData matches accurately the new desired layout and no painting is needed.
   */
  linesEquals(e) {
    if (!this.scrollEquals(e))
      return !1;
    const i = this._renderedLines._get().lines;
    for (let n = 0, o = i.length; n < o; n++)
      if (i[n].dy === -1)
        return !1;
    return !0;
  }
  /**
   * Check if the current RenderData matches the new layout's scroll position
   */
  scrollEquals(e) {
    return this.renderedLayout.startLineNumber === e.startLineNumber && this.renderedLayout.endLineNumber === e.endLineNumber;
  }
  _get() {
    const e = this._renderedLines._get();
    return {
      imageData: this._imageData,
      rendLineNumberStart: e.rendLineNumberStart,
      lines: e.lines
    };
  }
  onLinesChanged(e, t) {
    return this._renderedLines.onLinesChanged(e, t);
  }
  onLinesDeleted(e, t) {
    this._renderedLines.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._renderedLines.onLinesInserted(e, t);
  }
  onTokensChanged(e) {
    return this._renderedLines.onTokensChanged(e);
  }
}
class PT {
  constructor(e, t, i, n) {
    this._backgroundFillData = PT._createBackgroundFillData(t, i, n), this._buffers = [
      e.createImageData(t, i),
      e.createImageData(t, i)
    ], this._lastUsedBuffer = 0;
  }
  getBuffer() {
    this._lastUsedBuffer = 1 - this._lastUsedBuffer;
    const e = this._buffers[this._lastUsedBuffer];
    return e.data.set(this._backgroundFillData), e;
  }
  static _createBackgroundFillData(e, t, i) {
    const n = i.r, o = i.g, r = i.b, a = i.a, l = new Uint8ClampedArray(e * t * 4);
    let c = 0;
    for (let d = 0; d < t; d++)
      for (let h = 0; h < e; h++)
        l[c] = n, l[c + 1] = o, l[c + 2] = r, l[c + 3] = a, c += 4;
    return l;
  }
}
class h_ {
  static compute(e, t, i) {
    if (e.renderMinimap === 0 || !e.isSampling)
      return [null, []];
    const { minimapLineCount: n } = df.computeContainedMinimapLineCount({
      viewLineCount: t,
      scrollBeyondLastLine: e.scrollBeyondLastLine,
      paddingTop: e.paddingTop,
      paddingBottom: e.paddingBottom,
      height: e.editorHeight,
      lineHeight: e.lineHeight,
      pixelRatio: e.pixelRatio
    }), o = t / n, r = o / 2;
    if (!i || i.minimapLines.length === 0) {
      const A = [];
      if (A[0] = 1, n > 1) {
        for (let _ = 0, b = n - 1; _ < b; _++)
          A[_] = Math.round(_ * o + r);
        A[n - 1] = t;
      }
      return [new h_(o, A), []];
    }
    const a = i.minimapLines, l = a.length, c = [];
    let d = 0, h = 0, u = 1;
    const g = 10;
    let m = [], p = null;
    for (let A = 0; A < n; A++) {
      const _ = Math.max(u, Math.round(A * o)), b = Math.max(_, Math.round((A + 1) * o));
      for (; d < l && a[d] < _; ) {
        if (m.length < g) {
          const w = d + 1 + h;
          p && p.type === "deleted" && p._oldIndex === d - 1 ? p.deleteToLineNumber++ : (p = { type: "deleted", _oldIndex: d, deleteFromLineNumber: w, deleteToLineNumber: w }, m.push(p)), h--;
        }
        d++;
      }
      let C;
      if (d < l && a[d] <= b)
        C = a[d], d++;
      else if (A === 0 ? C = 1 : A + 1 === n ? C = t : C = Math.round(A * o + r), m.length < g) {
        const w = d + 1 + h;
        p && p.type === "inserted" && p._i === A - 1 ? p.insertToLineNumber++ : (p = { type: "inserted", _i: A, insertFromLineNumber: w, insertToLineNumber: w }, m.push(p)), h++;
      }
      c[A] = C, u = C;
    }
    if (m.length < g)
      for (; d < l; ) {
        const A = d + 1 + h;
        p && p.type === "deleted" && p._oldIndex === d - 1 ? p.deleteToLineNumber++ : (p = { type: "deleted", _oldIndex: d, deleteFromLineNumber: A, deleteToLineNumber: A }, m.push(p)), h--, d++;
      }
    else
      m = [{ type: "flush" }];
    return [new h_(o, c), m];
  }
  constructor(e, t) {
    this.samplingRatio = e, this.minimapLines = t;
  }
  modelLineToMinimapLine(e) {
    return Math.min(this.minimapLines.length, Math.max(1, Math.round(e / this.samplingRatio)));
  }
  /**
   * Will return null if the model line ranges are not intersecting with a sampled model line.
   */
  modelLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e) - 1;
    for (; i > 0 && this.minimapLines[i - 1] >= e; )
      i--;
    let n = this.modelLineToMinimapLine(t) - 1;
    for (; n + 1 < this.minimapLines.length && this.minimapLines[n + 1] <= t; )
      n++;
    if (i === n) {
      const o = this.minimapLines[i];
      if (o < e || o > t)
        return null;
    }
    return [i + 1, n + 1];
  }
  /**
   * Will always return a range, even if it is not intersecting with a sampled model line.
   */
  decorationLineRangeToMinimapLineRange(e, t) {
    let i = this.modelLineToMinimapLine(e), n = this.modelLineToMinimapLine(t);
    return e !== t && n === i && (n === this.minimapLines.length ? i > 1 && i-- : n++), [i, n];
  }
  onLinesDeleted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    let i = this.minimapLines.length, n = 0;
    for (let o = this.minimapLines.length - 1; o >= 0 && !(this.minimapLines[o] < e.fromLineNumber); o--)
      this.minimapLines[o] <= e.toLineNumber ? (this.minimapLines[o] = Math.max(1, e.fromLineNumber - 1), i = Math.min(i, o), n = Math.max(n, o)) : this.minimapLines[o] -= t;
    return [i, n];
  }
  onLinesInserted(e) {
    const t = e.toLineNumber - e.fromLineNumber + 1;
    for (let i = this.minimapLines.length - 1; i >= 0 && !(this.minimapLines[i] < e.fromLineNumber); i--)
      this.minimapLines[i] += t;
  }
}
class Moe extends Ds {
  constructor(e) {
    super(e), this._sectionHeaderCache = new Vu(10, 1.5), this.tokensColorTracker = Lv.getInstance(), this._selections = [], this._minimapSelections = null, this.options = new Nf(this._context.configuration, this._context.theme, this.tokensColorTracker);
    const [t] = h_.compute(this.options, this._context.viewModel.getLineCount(), null);
    this._samplingState = t, this._shouldCheckSampling = !1, this._actual = new Gg(e.theme, this);
  }
  dispose() {
    this._actual.dispose(), super.dispose();
  }
  getDomNode() {
    return this._actual.getDomNode();
  }
  _onOptionsMaybeChanged() {
    const e = new Nf(this._context.configuration, this._context.theme, this.tokensColorTracker);
    return this.options.equals(e) ? !1 : (this.options = e, this._recreateLineSampling(), this._actual.onDidChangeOptions(), !0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    return this._onOptionsMaybeChanged();
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, this._minimapSelections = null, this._actual.onSelectionChanged();
  }
  onDecorationsChanged(e) {
    return e.affectsMinimap ? this._actual.onDecorationsChanged() : !1;
  }
  onFlushed(e) {
    return this._samplingState && (this._shouldCheckSampling = !0), this._actual.onFlushed();
  }
  onLinesChanged(e) {
    if (this._samplingState) {
      const t = this._samplingState.modelLineRangeToMinimapLineRange(e.fromLineNumber, e.fromLineNumber + e.count - 1);
      return t ? this._actual.onLinesChanged(t[0], t[1] - t[0] + 1) : !1;
    } else
      return this._actual.onLinesChanged(e.fromLineNumber, e.count);
  }
  onLinesDeleted(e) {
    if (this._samplingState) {
      const [t, i] = this._samplingState.onLinesDeleted(e);
      return t <= i && this._actual.onLinesChanged(t + 1, i - t + 1), this._shouldCheckSampling = !0, !0;
    } else
      return this._actual.onLinesDeleted(e.fromLineNumber, e.toLineNumber);
  }
  onLinesInserted(e) {
    return this._samplingState ? (this._samplingState.onLinesInserted(e), this._shouldCheckSampling = !0, !0) : this._actual.onLinesInserted(e.fromLineNumber, e.toLineNumber);
  }
  onScrollChanged(e) {
    return this._actual.onScrollChanged();
  }
  onThemeChanged(e) {
    return this._actual.onThemeChanged(), this._onOptionsMaybeChanged(), !0;
  }
  onTokensChanged(e) {
    if (this._samplingState) {
      const t = [];
      for (const i of e.ranges) {
        const n = this._samplingState.modelLineRangeToMinimapLineRange(i.fromLineNumber, i.toLineNumber);
        n && t.push({ fromLineNumber: n[0], toLineNumber: n[1] });
      }
      return t.length ? this._actual.onTokensChanged(t) : !1;
    } else
      return this._actual.onTokensChanged(e.ranges);
  }
  onTokensColorsChanged(e) {
    return this._onOptionsMaybeChanged(), this._actual.onTokensColorsChanged();
  }
  onZonesChanged(e) {
    return this._actual.onZonesChanged();
  }
  // --- end event handlers
  prepareRender(e) {
    this._shouldCheckSampling && (this._shouldCheckSampling = !1, this._recreateLineSampling());
  }
  render(e) {
    let t = e.visibleRange.startLineNumber, i = e.visibleRange.endLineNumber;
    this._samplingState && (t = this._samplingState.modelLineToMinimapLine(t), i = this._samplingState.modelLineToMinimapLine(i));
    const n = {
      viewportContainsWhitespaceGaps: e.viewportData.whitespaceViewportData.length > 0,
      scrollWidth: e.scrollWidth,
      scrollHeight: e.scrollHeight,
      viewportStartLineNumber: t,
      viewportEndLineNumber: i,
      viewportStartLineNumberVerticalOffset: e.getVerticalOffsetForLineNumber(t),
      scrollTop: e.scrollTop,
      scrollLeft: e.scrollLeft,
      viewportWidth: e.viewportWidth,
      viewportHeight: e.viewportHeight
    };
    this._actual.render(n);
  }
  //#region IMinimapModel
  _recreateLineSampling() {
    this._minimapSelections = null;
    const e = !!this._samplingState, [t, i] = h_.compute(this.options, this._context.viewModel.getLineCount(), this._samplingState);
    if (this._samplingState = t, e && this._samplingState)
      for (const n of i)
        switch (n.type) {
          case "deleted":
            this._actual.onLinesDeleted(n.deleteFromLineNumber, n.deleteToLineNumber);
            break;
          case "inserted":
            this._actual.onLinesInserted(n.insertFromLineNumber, n.insertToLineNumber);
            break;
          case "flush":
            this._actual.onFlushed();
            break;
        }
  }
  getLineCount() {
    return this._samplingState ? this._samplingState.minimapLines.length : this._context.viewModel.getLineCount();
  }
  getRealLineCount() {
    return this._context.viewModel.getLineCount();
  }
  getLineContent(e) {
    return this._samplingState ? this._context.viewModel.getLineContent(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineContent(e);
  }
  getLineMaxColumn(e) {
    return this._samplingState ? this._context.viewModel.getLineMaxColumn(this._samplingState.minimapLines[e - 1]) : this._context.viewModel.getLineMaxColumn(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    if (this._samplingState) {
      const n = [];
      for (let o = 0, r = t - e + 1; o < r; o++)
        i[o] ? n[o] = this._context.viewModel.getViewLineData(this._samplingState.minimapLines[e + o - 1]) : n[o] = null;
      return n;
    }
    return this._context.viewModel.getMinimapLinesRenderingData(e, t, i).data;
  }
  getSelections() {
    if (this._minimapSelections === null)
      if (this._samplingState) {
        this._minimapSelections = [];
        for (const e of this._selections) {
          const [t, i] = this._samplingState.decorationLineRangeToMinimapLineRange(e.startLineNumber, e.endLineNumber);
          this._minimapSelections.push(new Ue(t, e.startColumn, i, e.endColumn));
        }
      } else
        this._minimapSelections = this._selections;
    return this._minimapSelections;
  }
  getMinimapDecorationsInViewport(e, t) {
    const i = this._getMinimapDecorationsInViewport(e, t).filter((n) => !n.options.minimap?.sectionHeaderStyle);
    if (this._samplingState) {
      const n = [];
      for (const o of i) {
        if (!o.options.minimap)
          continue;
        const r = o.range, a = this._samplingState.modelLineToMinimapLine(r.startLineNumber), l = this._samplingState.modelLineToMinimapLine(r.endLineNumber);
        n.push(new w8(new E(a, r.startColumn, l, r.endColumn), o.options));
      }
      return n;
    }
    return i;
  }
  getSectionHeaderDecorationsInViewport(e, t) {
    const i = this.options.minimapLineHeight, o = this.options.sectionHeaderFontSize / i;
    return e = Math.floor(Math.max(1, e - o)), this._getMinimapDecorationsInViewport(e, t).filter((r) => !!r.options.minimap?.sectionHeaderStyle);
  }
  _getMinimapDecorationsInViewport(e, t) {
    let i;
    if (this._samplingState) {
      const n = this._samplingState.minimapLines[e - 1], o = this._samplingState.minimapLines[t - 1];
      i = new E(n, 1, o, this._context.viewModel.getLineMaxColumn(o));
    } else
      i = new E(e, 1, t, this._context.viewModel.getLineMaxColumn(t));
    return this._context.viewModel.getMinimapDecorationsInRange(i);
  }
  getSectionHeaderText(e, t) {
    const i = e.options.minimap?.sectionHeaderText;
    if (!i)
      return null;
    const n = this._sectionHeaderCache.get(i);
    if (n)
      return n;
    const o = t(i);
    return this._sectionHeaderCache.set(i, o), o;
  }
  getOptions() {
    return this._context.viewModel.model.getOptions();
  }
  revealLineNumber(e) {
    this._samplingState && (e = this._samplingState.minimapLines[e - 1]), this._context.viewModel.revealRange(
      "mouse",
      !1,
      new E(e, 1, e, 1),
      1,
      0
      /* ScrollType.Smooth */
    );
  }
  setScrollTop(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e
      },
      1
      /* ScrollType.Immediate */
    );
  }
}
class Gg extends V {
  constructor(e, t) {
    super(), this._renderDecorations = !1, this._gestureInProgress = !1, this._theme = e, this._model = t, this._lastRenderData = null, this._buffers = null, this._selectionColor = this._theme.getColor(D2), this._domNode = rt(document.createElement("div")), Pr.write(
      this._domNode,
      9
      /* PartFingerprint.Minimap */
    ), this._domNode.setClassName(this._getMinimapDomNodeClassName()), this._domNode.setPosition("absolute"), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._shadow = rt(document.createElement("div")), this._shadow.setClassName("minimap-shadow-hidden"), this._domNode.appendChild(this._shadow), this._canvas = rt(document.createElement("canvas")), this._canvas.setPosition("absolute"), this._canvas.setLeft(0), this._domNode.appendChild(this._canvas), this._decorationsCanvas = rt(document.createElement("canvas")), this._decorationsCanvas.setPosition("absolute"), this._decorationsCanvas.setClassName("minimap-decorations-layer"), this._decorationsCanvas.setLeft(0), this._domNode.appendChild(this._decorationsCanvas), this._slider = rt(document.createElement("div")), this._slider.setPosition("absolute"), this._slider.setClassName("minimap-slider"), this._slider.setLayerHinting(!0), this._slider.setContain("strict"), this._domNode.appendChild(this._slider), this._sliderHorizontal = rt(document.createElement("div")), this._sliderHorizontal.setPosition("absolute"), this._sliderHorizontal.setClassName("minimap-slider-horizontal"), this._slider.appendChild(this._sliderHorizontal), this._applyLayout(), this._pointerDownListener = Xt(this._domNode.domNode, ee.POINTER_DOWN, (i) => {
      if (i.preventDefault(), this._model.options.renderMinimap === 0 || !this._lastRenderData)
        return;
      if (this._model.options.size !== "proportional") {
        if (i.button === 0 && this._lastRenderData) {
          const c = ui(this._slider.domNode), d = c.top + c.height / 2;
          this._startSliderDragging(i, d, this._lastRenderData.renderedLayout);
        }
        return;
      }
      const o = this._model.options.minimapLineHeight, r = this._model.options.canvasInnerHeight / this._model.options.canvasOuterHeight * i.offsetY;
      let l = Math.floor(r / o) + this._lastRenderData.renderedLayout.startLineNumber - this._lastRenderData.renderedLayout.topPaddingLineCount;
      l = Math.min(l, this._model.getLineCount()), this._model.revealLineNumber(l);
    }), this._sliderPointerMoveMonitor = new Cm(), this._sliderPointerDownListener = Xt(this._slider.domNode, ee.POINTER_DOWN, (i) => {
      i.preventDefault(), i.stopPropagation(), i.button === 0 && this._lastRenderData && this._startSliderDragging(i, i.pageY, this._lastRenderData.renderedLayout);
    }), this._gestureDisposable = xn.addTarget(this._domNode.domNode), this._sliderTouchStartListener = U(this._domNode.domNode, Et.Start, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && (this._slider.toggleClassName("active", !0), this._gestureInProgress = !0, this.scrollDueToTouchEvent(i));
    }, { passive: !1 }), this._sliderTouchMoveListener = U(this._domNode.domNode, Et.Change, (i) => {
      i.preventDefault(), i.stopPropagation(), this._lastRenderData && this._gestureInProgress && this.scrollDueToTouchEvent(i);
    }, { passive: !1 }), this._sliderTouchEndListener = Xt(this._domNode.domNode, Et.End, (i) => {
      i.preventDefault(), i.stopPropagation(), this._gestureInProgress = !1, this._slider.toggleClassName("active", !1);
    });
  }
  _startSliderDragging(e, t, i) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const n = e.pageX;
    this._slider.toggleClassName("active", !0);
    const o = (r, a) => {
      const l = ui(this._domNode.domNode), c = Math.min(Math.abs(a - n), Math.abs(a - l.left), Math.abs(a - l.left - l.width));
      if (yn && c > Doe) {
        this._model.setScrollTop(i.scrollTop);
        return;
      }
      const d = r - t;
      this._model.setScrollTop(i.getDesiredScrollTopFromDelta(d));
    };
    e.pageY !== t && o(e.pageY, n), this._sliderPointerMoveMonitor.startMonitoring(e.target, e.pointerId, e.buttons, (r) => o(r.pageY, r.pageX), () => {
      this._slider.toggleClassName("active", !1);
    });
  }
  scrollDueToTouchEvent(e) {
    const t = this._domNode.domNode.getBoundingClientRect().top, i = this._lastRenderData.renderedLayout.getDesiredScrollTopFromTouchLocation(e.pageY - t);
    this._model.setScrollTop(i);
  }
  dispose() {
    this._pointerDownListener.dispose(), this._sliderPointerMoveMonitor.dispose(), this._sliderPointerDownListener.dispose(), this._gestureDisposable.dispose(), this._sliderTouchStartListener.dispose(), this._sliderTouchMoveListener.dispose(), this._sliderTouchEndListener.dispose(), super.dispose();
  }
  _getMinimapDomNodeClassName() {
    const e = ["minimap"];
    return this._model.options.showSlider === "always" ? e.push("slider-always") : e.push("slider-mouseover"), this._model.options.autohide && e.push("autohide"), e.join(" ");
  }
  getDomNode() {
    return this._domNode;
  }
  _applyLayout() {
    this._domNode.setLeft(this._model.options.minimapLeft), this._domNode.setWidth(this._model.options.minimapWidth), this._domNode.setHeight(this._model.options.minimapHeight), this._shadow.setHeight(this._model.options.minimapHeight), this._canvas.setWidth(this._model.options.canvasOuterWidth), this._canvas.setHeight(this._model.options.canvasOuterHeight), this._canvas.domNode.width = this._model.options.canvasInnerWidth, this._canvas.domNode.height = this._model.options.canvasInnerHeight, this._decorationsCanvas.setWidth(this._model.options.canvasOuterWidth), this._decorationsCanvas.setHeight(this._model.options.canvasOuterHeight), this._decorationsCanvas.domNode.width = this._model.options.canvasInnerWidth, this._decorationsCanvas.domNode.height = this._model.options.canvasInnerHeight, this._slider.setWidth(this._model.options.minimapWidth);
  }
  _getBuffer() {
    return this._buffers || this._model.options.canvasInnerWidth > 0 && this._model.options.canvasInnerHeight > 0 && (this._buffers = new PT(this._canvas.domNode.getContext("2d"), this._model.options.canvasInnerWidth, this._model.options.canvasInnerHeight, this._model.options.backgroundColor)), this._buffers ? this._buffers.getBuffer() : null;
  }
  // ---- begin view event handlers
  onDidChangeOptions() {
    this._lastRenderData = null, this._buffers = null, this._applyLayout(), this._domNode.setClassName(this._getMinimapDomNodeClassName());
  }
  onSelectionChanged() {
    return this._renderDecorations = !0, !0;
  }
  onDecorationsChanged() {
    return this._renderDecorations = !0, !0;
  }
  onFlushed() {
    return this._lastRenderData = null, !0;
  }
  onLinesChanged(e, t) {
    return this._lastRenderData ? this._lastRenderData.onLinesChanged(e, t) : !1;
  }
  onLinesDeleted(e, t) {
    return this._lastRenderData?.onLinesDeleted(e, t), !0;
  }
  onLinesInserted(e, t) {
    return this._lastRenderData?.onLinesInserted(e, t), !0;
  }
  onScrollChanged() {
    return this._renderDecorations = !0, !0;
  }
  onThemeChanged() {
    return this._selectionColor = this._theme.getColor(D2), this._renderDecorations = !0, !0;
  }
  onTokensChanged(e) {
    return this._lastRenderData ? this._lastRenderData.onTokensChanged(e) : !1;
  }
  onTokensColorsChanged() {
    return this._lastRenderData = null, this._buffers = null, !0;
  }
  onZonesChanged() {
    return this._lastRenderData = null, !0;
  }
  // --- end event handlers
  render(e) {
    if (this._model.options.renderMinimap === 0) {
      this._shadow.setClassName("minimap-shadow-hidden"), this._sliderHorizontal.setWidth(0), this._sliderHorizontal.setHeight(0);
      return;
    }
    e.scrollLeft + e.viewportWidth >= e.scrollWidth ? this._shadow.setClassName("minimap-shadow-hidden") : this._shadow.setClassName("minimap-shadow-visible");
    const i = Xp.create(this._model.options, e.viewportStartLineNumber, e.viewportEndLineNumber, e.viewportStartLineNumberVerticalOffset, e.viewportHeight, e.viewportContainsWhitespaceGaps, this._model.getLineCount(), this._model.getRealLineCount(), e.scrollTop, e.scrollHeight, this._lastRenderData ? this._lastRenderData.renderedLayout : null);
    this._slider.setDisplay(i.sliderNeeded ? "block" : "none"), this._slider.setTop(i.sliderTop), this._slider.setHeight(i.sliderHeight), this._sliderHorizontal.setLeft(0), this._sliderHorizontal.setWidth(this._model.options.minimapWidth), this._sliderHorizontal.setTop(0), this._sliderHorizontal.setHeight(i.sliderHeight), this.renderDecorations(i), this._lastRenderData = this.renderLines(i);
  }
  renderDecorations(e) {
    if (this._renderDecorations) {
      this._renderDecorations = !1;
      const t = this._model.getSelections();
      t.sort(E.compareRangesUsingStarts);
      const i = this._model.getMinimapDecorationsInViewport(e.startLineNumber, e.endLineNumber);
      i.sort((u, g) => (u.options.zIndex || 0) - (g.options.zIndex || 0));
      const { canvasInnerWidth: n, canvasInnerHeight: o } = this._model.options, r = this._model.options.minimapLineHeight, a = this._model.options.minimapCharWidth, l = this._model.getOptions().tabSize, c = this._decorationsCanvas.domNode.getContext("2d");
      c.clearRect(0, 0, n, o);
      const d = new WO(e.startLineNumber, e.endLineNumber, !1);
      this._renderSelectionLineHighlights(c, t, d, e, r), this._renderDecorationsLineHighlights(c, i, d, e, r);
      const h = new WO(e.startLineNumber, e.endLineNumber, null);
      this._renderSelectionsHighlights(c, t, h, e, r, l, a, n), this._renderDecorationsHighlights(c, i, h, e, r, l, a, n), this._renderSectionHeaders(e);
    }
  }
  _renderSelectionLineHighlights(e, t, i, n, o) {
    if (!this._selectionColor || this._selectionColor.isTransparent())
      return;
    e.fillStyle = this._selectionColor.transparent(0.5).toString();
    let r = 0, a = 0;
    for (const l of t) {
      const c = n.intersectWithViewport(l);
      if (!c)
        continue;
      const [d, h] = c;
      for (let m = d; m <= h; m++)
        i.set(m, !0);
      const u = n.getYForLineNumber(d, o), g = n.getYForLineNumber(h, o);
      a >= u || (a > r && e.fillRect(qr, r, e.canvas.width, a - r), r = u), a = g;
    }
    a > r && e.fillRect(qr, r, e.canvas.width, a - r);
  }
  _renderDecorationsLineHighlights(e, t, i, n, o) {
    const r = /* @__PURE__ */ new Map();
    for (let a = t.length - 1; a >= 0; a--) {
      const l = t[a], c = l.options.minimap;
      if (!c || c.position !== 1)
        continue;
      const d = n.intersectWithViewport(l.range);
      if (!d)
        continue;
      const [h, u] = d, g = c.getColor(this._theme.value);
      if (!g || g.isTransparent())
        continue;
      let m = r.get(g.toString());
      m || (m = g.transparent(0.5).toString(), r.set(g.toString(), m)), e.fillStyle = m;
      for (let p = h; p <= u; p++) {
        if (i.has(p))
          continue;
        i.set(p, !0);
        const A = n.getYForLineNumber(h, o);
        e.fillRect(qr, A, e.canvas.width, o);
      }
    }
  }
  _renderSelectionsHighlights(e, t, i, n, o, r, a, l) {
    if (!(!this._selectionColor || this._selectionColor.isTransparent()))
      for (const c of t) {
        const d = n.intersectWithViewport(c);
        if (!d)
          continue;
        const [h, u] = d;
        for (let g = h; g <= u; g++)
          this.renderDecorationOnLine(e, i, c, this._selectionColor, n, g, o, o, r, a, l);
      }
  }
  _renderDecorationsHighlights(e, t, i, n, o, r, a, l) {
    for (const c of t) {
      const d = c.options.minimap;
      if (!d)
        continue;
      const h = n.intersectWithViewport(c.range);
      if (!h)
        continue;
      const [u, g] = h, m = d.getColor(this._theme.value);
      if (!(!m || m.isTransparent()))
        for (let p = u; p <= g; p++)
          switch (d.position) {
            case 1:
              this.renderDecorationOnLine(e, i, c.range, m, n, p, o, o, r, a, l);
              continue;
            case 2: {
              const A = n.getYForLineNumber(p, o);
              this.renderDecoration(e, m, 2, A, Ioe, o);
              continue;
            }
          }
    }
  }
  renderDecorationOnLine(e, t, i, n, o, r, a, l, c, d, h) {
    const u = o.getYForLineNumber(r, l);
    if (u + a < 0 || u > this._model.options.canvasInnerHeight)
      return;
    const { startLineNumber: g, endLineNumber: m } = i, p = g === r ? i.startColumn : 1, A = m === r ? i.endColumn : this._model.getLineMaxColumn(r), _ = this.getXOffsetForPosition(t, r, p, c, d, h), b = this.getXOffsetForPosition(t, r, A, c, d, h);
    this.renderDecoration(e, n, _, u, b - _, a);
  }
  getXOffsetForPosition(e, t, i, n, o, r) {
    if (i === 1)
      return qr;
    if ((i - 1) * o >= r)
      return r;
    let l = e.get(t);
    if (!l) {
      const c = this._model.getLineContent(t);
      l = [qr];
      let d = qr;
      for (let h = 1; h < c.length + 1; h++) {
        const u = c.charCodeAt(h - 1), g = u === 9 ? n * o : sd(u) ? 2 * o : o, m = d + g;
        if (m >= r) {
          l[h] = r;
          break;
        }
        l[h] = m, d = m;
      }
      e.set(t, l);
    }
    return i - 1 < l.length ? l[i - 1] : r;
  }
  renderDecoration(e, t, i, n, o, r) {
    e.fillStyle = t && t.toString() || "", e.fillRect(i, n, o, r);
  }
  _renderSectionHeaders(e) {
    const t = this._model.options.minimapLineHeight, i = this._model.options.sectionHeaderFontSize, n = this._model.options.sectionHeaderLetterSpacing, o = i * 1.5, { canvasInnerWidth: r } = this._model.options, a = this._model.options.backgroundColor, l = `rgb(${a.r} ${a.g} ${a.b} / .7)`, c = this._model.options.sectionHeaderFontColor, d = `rgb(${c.r} ${c.g} ${c.b})`, h = d, u = this._decorationsCanvas.domNode.getContext("2d");
    u.letterSpacing = n + "px", u.font = "500 " + i + "px " + this._model.options.sectionHeaderFontFamily, u.strokeStyle = h, u.lineWidth = 0.2;
    const g = this._model.getSectionHeaderDecorationsInViewport(e.startLineNumber, e.endLineNumber);
    g.sort((p, A) => p.range.startLineNumber - A.range.startLineNumber);
    const m = Gg._fitSectionHeader.bind(null, u, r - qr);
    for (const p of g) {
      const A = e.getYForLineNumber(p.range.startLineNumber, t) + i, _ = A - i, b = _ + 2, C = this._model.getSectionHeaderText(p, m);
      Gg._renderSectionLabel(u, C, p.options.minimap?.sectionHeaderStyle === 2, l, d, r, _, o, A, b);
    }
  }
  static _fitSectionHeader(e, t, i) {
    if (!i)
      return i;
    const n = "…", o = e.measureText(i).width, r = e.measureText(n).width;
    if (o <= t || o <= r)
      return i;
    const a = i.length, l = o / i.length, c = Math.floor((t - r) / l) - 1;
    let d = Math.ceil(c / 2);
    for (; d > 0 && /\s/.test(i[d - 1]); )
      --d;
    return i.substring(0, d) + n + i.substring(a - (c - d));
  }
  static _renderSectionLabel(e, t, i, n, o, r, a, l, c, d) {
    t && (e.fillStyle = n, e.fillRect(0, a, r, l), e.fillStyle = o, e.fillText(t, qr, c)), i && (e.beginPath(), e.moveTo(0, d), e.lineTo(r, d), e.closePath(), e.stroke());
  }
  renderLines(e) {
    const t = e.startLineNumber, i = e.endLineNumber, n = this._model.options.minimapLineHeight;
    if (this._lastRenderData && this._lastRenderData.linesEquals(e)) {
      const J = this._lastRenderData._get();
      return new HO(e, J.imageData, J.lines);
    }
    const o = this._getBuffer();
    if (!o)
      return null;
    const [r, a, l] = Gg._renderUntouchedLines(o, e.topPaddingLineCount, t, i, n, this._lastRenderData), c = this._model.getMinimapLinesRenderingData(t, i, l), d = this._model.getOptions().tabSize, h = this._model.options.defaultBackgroundColor, u = this._model.options.backgroundColor, g = this._model.options.foregroundAlpha, m = this._model.tokensColorTracker, p = m.backgroundIsLight(), A = this._model.options.renderMinimap, _ = this._model.options.charRenderer(), b = this._model.options.fontScale, C = this._model.options.minimapCharWidth, S = (A === 1 ? 2 : 3) * b, x = n > S ? Math.floor((n - S) / 2) : 0, y = u.a / 255, D = new Ol(Math.round((u.r - h.r) * y + h.r), Math.round((u.g - h.g) * y + h.g), Math.round((u.b - h.b) * y + h.b), 255);
    let I = e.topPaddingLineCount * n;
    const Q = [];
    for (let J = 0, se = i - t + 1; J < se; J++)
      l[J] && Gg._renderLine(o, D, u.a, p, A, C, m, g, _, I, x, d, c[J], b, n), Q[J] = new kv(I), I += n;
    const P = r === -1 ? 0 : r, j = (a === -1 ? o.height : a) - P;
    return this._canvas.domNode.getContext("2d").putImageData(o, 0, 0, 0, P, o.width, j), new HO(e, o, Q);
  }
  static _renderUntouchedLines(e, t, i, n, o, r) {
    const a = [];
    if (!r) {
      for (let I = 0, Q = n - i + 1; I < Q; I++)
        a[I] = !0;
      return [-1, -1, a];
    }
    const l = r._get(), c = l.imageData.data, d = l.rendLineNumberStart, h = l.lines, u = h.length, g = e.width, m = e.data, p = (n - i + 1) * o * g * 4;
    let A = -1, _ = -1, b = -1, C = -1, w = -1, S = -1, x = t * o;
    for (let I = i; I <= n; I++) {
      const Q = I - i, P = I - d, W = P >= 0 && P < u ? h[P].dy : -1;
      if (W === -1) {
        a[Q] = !0, x += o;
        continue;
      }
      const j = W * g * 4, H = (W + o) * g * 4, J = x * g * 4, se = (x + o) * g * 4;
      C === j && S === J ? (C = H, S = se) : (b !== -1 && (m.set(c.subarray(b, C), w), A === -1 && b === 0 && b === w && (A = C), _ === -1 && C === p && b === w && (_ = b)), b = j, C = H, w = J, S = se), a[Q] = !1, x += o;
    }
    b !== -1 && (m.set(c.subarray(b, C), w), A === -1 && b === 0 && b === w && (A = C), _ === -1 && C === p && b === w && (_ = b));
    const y = A === -1 ? -1 : A / (g * 4), D = _ === -1 ? -1 : _ / (g * 4);
    return [y, D, a];
  }
  static _renderLine(e, t, i, n, o, r, a, l, c, d, h, u, g, m, p) {
    const A = g.content, _ = g.tokens, b = e.width - r, C = p === 1;
    let w = qr, S = 0, x = 0;
    for (let y = 0, D = _.getCount(); y < D; y++) {
      const I = _.getEndOffset(y), Q = _.getForeground(y), P = a.getColor(Q);
      for (; S < I; S++) {
        if (w > b)
          return;
        const W = A.charCodeAt(S);
        if (W === 9) {
          const j = u - (S + x) % u;
          x += j - 1, w += j * r;
        } else if (W === 32)
          w += r;
        else {
          const j = sd(W) ? 2 : 1;
          for (let H = 0; H < j; H++)
            if (o === 2 ? c.blockRenderChar(e, w, d + h, P, l, t, i, C) : c.renderChar(e, w, d + h, W, P, l, t, i, m, n, C), w += r, w > b)
              return;
        }
      }
    }
  }
}
class WO {
  constructor(e, t, i) {
    this._startLineNumber = e, this._endLineNumber = t, this._defaultValue = i, this._values = [];
    for (let n = 0, o = this._endLineNumber - this._startLineNumber + 1; n < o; n++)
      this._values[n] = i;
  }
  has(e) {
    return this.get(e) !== this._defaultValue;
  }
  set(e, t) {
    e < this._startLineNumber || e > this._endLineNumber || (this._values[e - this._startLineNumber] = t);
  }
  get(e) {
    return e < this._startLineNumber || e > this._endLineNumber ? this._defaultValue : this._values[e - this._startLineNumber];
  }
}
class Noe extends Ds {
  constructor(e, t) {
    super(e), this._viewDomNode = t;
    const n = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._widgets = {}, this._verticalScrollbarWidth = n.verticalScrollbarWidth, this._minimapWidth = n.minimap.minimapWidth, this._horizontalScrollbarHeight = n.horizontalScrollbarHeight, this._editorHeight = n.height, this._editorWidth = n.width, this._viewDomNodeRect = { top: 0, left: 0, width: 0, height: 0 }, this._domNode = rt(document.createElement("div")), Pr.write(
      this._domNode,
      4
      /* PartFingerprint.OverlayWidgets */
    ), this._domNode.setClassName("overlayWidgets"), this.overflowingOverlayWidgetsDomNode = rt(document.createElement("div")), Pr.write(
      this.overflowingOverlayWidgetsDomNode,
      5
      /* PartFingerprint.OverflowingOverlayWidgets */
    ), this.overflowingOverlayWidgetsDomNode.setClassName("overflowingOverlayWidgets");
  }
  dispose() {
    super.dispose(), this._widgets = {};
  }
  getDomNode() {
    return this._domNode;
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._verticalScrollbarWidth = i.verticalScrollbarWidth, this._minimapWidth = i.minimap.minimapWidth, this._horizontalScrollbarHeight = i.horizontalScrollbarHeight, this._editorHeight = i.height, this._editorWidth = i.width, !0;
  }
  // ---- end view event handlers
  addWidget(e) {
    const t = rt(e.getDomNode());
    this._widgets[e.getId()] = {
      widget: e,
      preference: null,
      domNode: t
    }, t.setPosition("absolute"), t.setAttribute("widgetId", e.getId()), e.allowEditorOverflow ? this.overflowingOverlayWidgetsDomNode.appendChild(t) : this._domNode.appendChild(t), this.setShouldRender(), this._updateMaxMinWidth();
  }
  setWidgetPosition(e, t) {
    const i = this._widgets[e.getId()], n = t ? t.preference : null, o = t?.stackOridinal;
    return i.preference === n && i.stack === o ? (this._updateMaxMinWidth(), !1) : (i.preference = n, i.stack = o, this.setShouldRender(), this._updateMaxMinWidth(), !0);
  }
  removeWidget(e) {
    const t = e.getId();
    if (this._widgets.hasOwnProperty(t)) {
      const n = this._widgets[t].domNode.domNode;
      delete this._widgets[t], n.remove(), this.setShouldRender(), this._updateMaxMinWidth();
    }
  }
  _updateMaxMinWidth() {
    let e = 0;
    const t = Object.keys(this._widgets);
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i], a = this._widgets[o].widget.getMinContentWidthInPx?.();
      typeof a < "u" && (e = Math.max(e, a));
    }
    this._context.viewLayout.setOverlayWidgetsMinWidth(e);
  }
  _renderWidget(e, t) {
    const i = e.domNode;
    if (e.preference === null) {
      i.setTop("");
      return;
    }
    const n = 2 * this._verticalScrollbarWidth + this._minimapWidth;
    if (e.preference === 0 || e.preference === 1) {
      if (e.preference === 1) {
        const o = i.domNode.clientHeight;
        i.setTop(this._editorHeight - o - 2 * this._horizontalScrollbarHeight);
      } else
        i.setTop(0);
      e.stack !== void 0 ? (i.setTop(t[e.preference]), t[e.preference] += i.domNode.clientWidth) : i.setRight(n);
    } else if (e.preference === 2)
      i.domNode.style.right = "50%", e.stack !== void 0 ? (i.setTop(t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ]), t[
        2
        /* OverlayWidgetPositionPreference.TOP_CENTER */
      ] += i.domNode.clientHeight) : i.setTop(0);
    else {
      const { top: o, left: r } = e.preference;
      if (this._context.configuration.options.get(
        42
        /* EditorOption.fixedOverflowWidgets */
      ) && e.widget.allowEditorOverflow) {
        const l = this._viewDomNodeRect;
        i.setTop(o + l.top), i.setLeft(r + l.left), i.setPosition("fixed");
      } else
        i.setTop(o), i.setLeft(r), i.setPosition("absolute");
    }
  }
  prepareRender(e) {
    this._viewDomNodeRect = ui(this._viewDomNode.domNode);
  }
  render(e) {
    this._domNode.setWidth(this._editorWidth);
    const t = Object.keys(this._widgets), i = Array.from({ length: 3 }, () => 0);
    t.sort((n, o) => (this._widgets[n].stack || 0) - (this._widgets[o].stack || 0));
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      this._renderWidget(this._widgets[r], i);
    }
  }
}
class Toe {
  constructor(e, t) {
    const i = e.options;
    this.lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this.pixelRatio = i.get(
      144
      /* EditorOption.pixelRatio */
    ), this.overviewRulerLanes = i.get(
      83
      /* EditorOption.overviewRulerLanes */
    ), this.renderBorder = i.get(
      82
      /* EditorOption.overviewRulerBorder */
    );
    const n = t.getColor(yX);
    this.borderColor = n ? n.toString() : null, this.hideCursor = i.get(
      59
      /* EditorOption.hideCursorInOverviewRuler */
    );
    const o = t.getColor(cS);
    this.cursorColorSingle = o ? o.transparent(0.7).toString() : null;
    const r = t.getColor(X3);
    this.cursorColorPrimary = r ? r.transparent(0.7).toString() : null;
    const a = t.getColor(Z3);
    this.cursorColorSecondary = a ? a.transparent(0.7).toString() : null, this.themeType = t.type;
    const l = i.get(
      73
      /* EditorOption.minimap */
    ), c = l.enabled, d = l.side, h = t.getColor(xX), u = ci.getDefaultBackground();
    h ? this.backgroundColor = h : c && d === "right" ? this.backgroundColor = u : this.backgroundColor = null;
    const m = i.get(
      146
      /* EditorOption.layoutInfo */
    ).overviewRuler;
    this.top = m.top, this.right = m.right, this.domWidth = m.width, this.domHeight = m.height, this.overviewRulerLanes === 0 ? (this.canvasWidth = 0, this.canvasHeight = 0) : (this.canvasWidth = this.domWidth * this.pixelRatio | 0, this.canvasHeight = this.domHeight * this.pixelRatio | 0);
    const [p, A] = this._initLanes(1, this.canvasWidth, this.overviewRulerLanes);
    this.x = p, this.w = A;
  }
  _initLanes(e, t, i) {
    const n = t - e;
    if (i >= 3) {
      const o = Math.floor(n / 3), r = Math.floor(n / 3), a = n - o - r, l = e, c = l + o, d = l + o + a;
      return [
        [
          0,
          l,
          // Left
          c,
          // Center
          l,
          // Left | Center
          d,
          // Right
          l,
          // Left | Right
          c,
          // Center | Right
          l
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          a,
          // Center
          o + a,
          // Left | Center
          r,
          // Right
          o + a + r,
          // Left | Right
          a + r,
          // Center | Right
          o + a + r
          // Left | Center | Right
        ]
      ];
    } else if (i === 2) {
      const o = Math.floor(n / 2), r = n - o, a = e, l = a + o;
      return [
        [
          0,
          a,
          // Left
          a,
          // Center
          a,
          // Left | Center
          l,
          // Right
          a,
          // Left | Right
          a,
          // Center | Right
          a
          // Left | Center | Right
        ],
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          r,
          // Right
          o + r,
          // Left | Right
          o + r,
          // Center | Right
          o + r
          // Left | Center | Right
        ]
      ];
    } else {
      const o = e, r = n;
      return [
        [
          0,
          o,
          // Left
          o,
          // Center
          o,
          // Left | Center
          o,
          // Right
          o,
          // Left | Right
          o,
          // Center | Right
          o
          // Left | Center | Right
        ],
        [
          0,
          r,
          // Left
          r,
          // Center
          r,
          // Left | Center
          r,
          // Right
          r,
          // Left | Right
          r,
          // Center | Right
          r
          // Left | Center | Right
        ]
      ];
    }
  }
  equals(e) {
    return this.lineHeight === e.lineHeight && this.pixelRatio === e.pixelRatio && this.overviewRulerLanes === e.overviewRulerLanes && this.renderBorder === e.renderBorder && this.borderColor === e.borderColor && this.hideCursor === e.hideCursor && this.cursorColorSingle === e.cursorColorSingle && this.cursorColorPrimary === e.cursorColorPrimary && this.cursorColorSecondary === e.cursorColorSecondary && this.themeType === e.themeType && Y.equals(this.backgroundColor, e.backgroundColor) && this.top === e.top && this.right === e.right && this.domWidth === e.domWidth && this.domHeight === e.domHeight && this.canvasWidth === e.canvasWidth && this.canvasHeight === e.canvasHeight;
  }
}
class Boe extends Ds {
  constructor(e) {
    super(e), this._actualShouldRender = 0, this._renderedDecorations = [], this._renderedCursorPositions = [], this._domNode = rt(document.createElement("canvas")), this._domNode.setClassName("decorationsOverviewRuler"), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._domNode.setAttribute("aria-hidden", "true"), this._updateSettings(!1), this._tokensColorTrackerListener = ci.onDidChange((t) => {
      t.changedColorMap && this._updateSettings(!0);
    }), this._cursorPositions = [{ position: new F(1, 1), color: this._settings.cursorColorSingle }];
  }
  dispose() {
    super.dispose(), this._tokensColorTrackerListener.dispose();
  }
  _updateSettings(e) {
    const t = new Toe(this._context.configuration, this._context.theme);
    return this._settings && this._settings.equals(t) ? !1 : (this._settings = t, this._domNode.setTop(this._settings.top), this._domNode.setRight(this._settings.right), this._domNode.setWidth(this._settings.domWidth), this._domNode.setHeight(this._settings.domHeight), this._domNode.domNode.width = this._settings.canvasWidth, this._domNode.domNode.height = this._settings.canvasHeight, e && this._render(), !0);
  }
  // ---- begin view event handlers
  _markRenderingIsNeeded() {
    return this._actualShouldRender = 2, !0;
  }
  _markRenderingIsMaybeNeeded() {
    return this._actualShouldRender = 1, !0;
  }
  onConfigurationChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  onCursorStateChanged(e) {
    this._cursorPositions = [];
    for (let t = 0, i = e.selections.length; t < i; t++) {
      let n = this._settings.cursorColorSingle;
      i > 1 && (n = t === 0 ? this._settings.cursorColorPrimary : this._settings.cursorColorSecondary), this._cursorPositions.push({ position: e.selections[t].getPosition(), color: n });
    }
    return this._cursorPositions.sort((t, i) => F.compare(t.position, i.position)), this._markRenderingIsMaybeNeeded();
  }
  onDecorationsChanged(e) {
    return e.affectsOverviewRuler ? this._markRenderingIsMaybeNeeded() : !1;
  }
  onFlushed(e) {
    return this._markRenderingIsNeeded();
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged ? this._markRenderingIsNeeded() : !1;
  }
  onZonesChanged(e) {
    return this._markRenderingIsNeeded();
  }
  onThemeChanged(e) {
    return this._updateSettings(!1) ? this._markRenderingIsNeeded() : !1;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  prepareRender(e) {
  }
  render(e) {
    this._render(), this._actualShouldRender = 0;
  }
  _render() {
    const e = this._settings.backgroundColor;
    if (this._settings.overviewRulerLanes === 0) {
      this._domNode.setBackgroundColor(e ? Y.Format.CSS.formatHexA(e) : ""), this._domNode.setDisplay("none");
      return;
    }
    const t = this._context.viewModel.getAllOverviewRulerDecorations(this._context.theme);
    if (t.sort(o_.compareByRenderingProps), this._actualShouldRender === 1 && !o_.equalsArr(this._renderedDecorations, t) && (this._actualShouldRender = 2), this._actualShouldRender === 1 && !pi(this._renderedCursorPositions, this._cursorPositions, (m, p) => m.position.lineNumber === p.position.lineNumber && m.color === p.color) && (this._actualShouldRender = 2), this._actualShouldRender === 1)
      return;
    this._renderedDecorations = t, this._renderedCursorPositions = this._cursorPositions, this._domNode.setDisplay("block");
    const i = this._settings.canvasWidth, n = this._settings.canvasHeight, o = this._settings.lineHeight, r = this._context.viewLayout, a = this._context.viewLayout.getScrollHeight(), l = n / a, c = 6 * this._settings.pixelRatio | 0, d = c / 2 | 0, h = this._domNode.domNode.getContext("2d");
    e ? e.isOpaque() ? (h.fillStyle = Y.Format.CSS.formatHexA(e), h.fillRect(0, 0, i, n)) : (h.clearRect(0, 0, i, n), h.fillStyle = Y.Format.CSS.formatHexA(e), h.fillRect(0, 0, i, n)) : h.clearRect(0, 0, i, n);
    const u = this._settings.x, g = this._settings.w;
    for (const m of t) {
      const p = m.color, A = m.data;
      h.fillStyle = p;
      let _ = 0, b = 0, C = 0;
      for (let w = 0, S = A.length / 3; w < S; w++) {
        const x = A[3 * w], y = A[3 * w + 1], D = A[3 * w + 2];
        let I = r.getVerticalOffsetForLineNumber(y) * l | 0, Q = (r.getVerticalOffsetForLineNumber(D) + o) * l | 0;
        if (Q - I < c) {
          let W = (I + Q) / 2 | 0;
          W < d ? W = d : W + d > n && (W = n - d), I = W - d, Q = W + d;
        }
        I > C + 1 || x !== _ ? (w !== 0 && h.fillRect(u[_], b, g[_], C - b), _ = x, b = I, C = Q) : Q > C && (C = Q);
      }
      h.fillRect(u[_], b, g[_], C - b);
    }
    if (!this._settings.hideCursor) {
      const m = 2 * this._settings.pixelRatio | 0, p = m / 2 | 0, A = this._settings.x[
        7
        /* OverviewRulerLane.Full */
      ], _ = this._settings.w[
        7
        /* OverviewRulerLane.Full */
      ];
      let b = -100, C = -100, w = null;
      for (let S = 0, x = this._cursorPositions.length; S < x; S++) {
        const y = this._cursorPositions[S].color;
        if (!y)
          continue;
        const D = this._cursorPositions[S].position;
        let I = r.getVerticalOffsetForLineNumber(D.lineNumber) * l | 0;
        I < p ? I = p : I + p > n && (I = n - p);
        const Q = I - p, P = Q + m;
        Q > C + 1 || y !== w ? (S !== 0 && w && h.fillRect(A, b, _, C - b), b = Q, C = P) : P > C && (C = P), w = y, h.fillStyle = y;
      }
      w && h.fillRect(A, b, _, C - b);
    }
    this._settings.renderBorder && this._settings.borderColor && this._settings.overviewRulerLanes > 0 && (h.beginPath(), h.lineWidth = 1, h.strokeStyle = this._settings.borderColor, h.moveTo(0, 0), h.lineTo(0, n), h.moveTo(1, 0), h.lineTo(i, 0), h.stroke());
  }
}
class VO {
  constructor(e, t, i) {
    this._colorZoneBrand = void 0, this.from = e | 0, this.to = t | 0, this.colorId = i | 0;
  }
  static compare(e, t) {
    return e.colorId === t.colorId ? e.from === t.from ? e.to - t.to : e.from - t.from : e.colorId - t.colorId;
  }
}
class H8 {
  constructor(e, t, i, n) {
    this._overviewRulerZoneBrand = void 0, this.startLineNumber = e, this.endLineNumber = t, this.heightInLines = i, this.color = n, this._colorZone = null;
  }
  static compare(e, t) {
    return e.color === t.color ? e.startLineNumber === t.startLineNumber ? e.heightInLines === t.heightInLines ? e.endLineNumber - t.endLineNumber : e.heightInLines - t.heightInLines : e.startLineNumber - t.startLineNumber : e.color < t.color ? -1 : 1;
  }
  setColorZone(e) {
    this._colorZone = e;
  }
  getColorZones() {
    return this._colorZone;
  }
}
class Roe {
  constructor(e) {
    this._getVerticalOffsetForLine = e, this._zones = [], this._colorZonesInvalid = !1, this._lineHeight = 0, this._domWidth = 0, this._domHeight = 0, this._outerHeight = 0, this._pixelRatio = 1, this._lastAssignedId = 0, this._color2Id = /* @__PURE__ */ Object.create(null), this._id2Color = [];
  }
  getId2Color() {
    return this._id2Color;
  }
  setZones(e) {
    this._zones = e, this._zones.sort(H8.compare);
  }
  setLineHeight(e) {
    return this._lineHeight === e ? !1 : (this._lineHeight = e, this._colorZonesInvalid = !0, !0);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this._colorZonesInvalid = !0;
  }
  getDOMWidth() {
    return this._domWidth;
  }
  getCanvasWidth() {
    return this._domWidth * this._pixelRatio;
  }
  setDOMWidth(e) {
    return this._domWidth === e ? !1 : (this._domWidth = e, this._colorZonesInvalid = !0, !0);
  }
  getDOMHeight() {
    return this._domHeight;
  }
  getCanvasHeight() {
    return this._domHeight * this._pixelRatio;
  }
  setDOMHeight(e) {
    return this._domHeight === e ? !1 : (this._domHeight = e, this._colorZonesInvalid = !0, !0);
  }
  getOuterHeight() {
    return this._outerHeight;
  }
  setOuterHeight(e) {
    return this._outerHeight === e ? !1 : (this._outerHeight = e, this._colorZonesInvalid = !0, !0);
  }
  resolveColorZones() {
    const e = this._colorZonesInvalid, t = Math.floor(this._lineHeight), i = Math.floor(this.getCanvasHeight()), n = Math.floor(this._outerHeight), o = i / n, r = Math.floor(4 * this._pixelRatio / 2), a = [];
    for (let l = 0, c = this._zones.length; l < c; l++) {
      const d = this._zones[l];
      if (!e) {
        const w = d.getColorZones();
        if (w) {
          a.push(w);
          continue;
        }
      }
      const h = this._getVerticalOffsetForLine(d.startLineNumber), u = d.heightInLines === 0 ? this._getVerticalOffsetForLine(d.endLineNumber) + t : h + d.heightInLines * t, g = Math.floor(o * h), m = Math.floor(o * u);
      let p = Math.floor((g + m) / 2), A = m - p;
      A < r && (A = r), p - A < 0 && (p = A), p + A > i && (p = i - A);
      const _ = d.color;
      let b = this._color2Id[_];
      b || (b = ++this._lastAssignedId, this._color2Id[_] = b, this._id2Color[b] = _);
      const C = new VO(p - A, p + A, b);
      d.setColorZone(C), a.push(C);
    }
    return this._colorZonesInvalid = !1, a.sort(VO.compare), a;
  }
}
class Foe extends Y_ {
  constructor(e, t) {
    super(), this._context = e;
    const i = this._context.configuration.options;
    this._domNode = rt(document.createElement("canvas")), this._domNode.setClassName(t), this._domNode.setPosition("absolute"), this._domNode.setLayerHinting(!0), this._domNode.setContain("strict"), this._zoneManager = new Roe((n) => this._context.viewLayout.getVerticalOffsetForLineNumber(n)), this._zoneManager.setDOMWidth(0), this._zoneManager.setDOMHeight(0), this._zoneManager.setOuterHeight(this._context.viewLayout.getScrollHeight()), this._zoneManager.setLineHeight(i.get(
      67
      /* EditorOption.lineHeight */
    )), this._zoneManager.setPixelRatio(i.get(
      144
      /* EditorOption.pixelRatio */
    )), this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), super.dispose();
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && (this._zoneManager.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), this._render()), e.hasChanged(
      144
      /* EditorOption.pixelRatio */
    ) && (this._zoneManager.setPixelRatio(t.get(
      144
      /* EditorOption.pixelRatio */
    )), this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render()), !0;
  }
  onFlushed(e) {
    return this._render(), !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged && (this._zoneManager.setOuterHeight(e.scrollHeight), this._render()), !0;
  }
  onZonesChanged(e) {
    return this._render(), !0;
  }
  // ---- end view event handlers
  getDomNode() {
    return this._domNode.domNode;
  }
  setLayout(e) {
    this._domNode.setTop(e.top), this._domNode.setRight(e.right);
    let t = !1;
    t = this._zoneManager.setDOMWidth(e.width) || t, t = this._zoneManager.setDOMHeight(e.height) || t, t && (this._domNode.setWidth(this._zoneManager.getDOMWidth()), this._domNode.setHeight(this._zoneManager.getDOMHeight()), this._domNode.domNode.width = this._zoneManager.getCanvasWidth(), this._domNode.domNode.height = this._zoneManager.getCanvasHeight(), this._render());
  }
  setZones(e) {
    this._zoneManager.setZones(e), this._render();
  }
  _render() {
    if (this._zoneManager.getOuterHeight() === 0)
      return !1;
    const e = this._zoneManager.getCanvasWidth(), t = this._zoneManager.getCanvasHeight(), i = this._zoneManager.resolveColorZones(), n = this._zoneManager.getId2Color(), o = this._domNode.domNode.getContext("2d");
    return o.clearRect(0, 0, e, t), i.length > 0 && this._renderOneLane(o, i, n, e), !0;
  }
  _renderOneLane(e, t, i, n) {
    let o = 0, r = 0, a = 0;
    for (const l of t) {
      const c = l.colorId, d = l.from, h = l.to;
      c !== o ? (e.fillRect(0, r, n, a - r), o = c, e.fillStyle = i[o], r = d, a = h) : a >= d ? a = Math.max(a, h) : (e.fillRect(0, r, n, a - r), r = d, a = h);
    }
    e.fillRect(0, r, n, a - r);
  }
}
class Ooe extends Ds {
  constructor(e) {
    super(e), this.domNode = rt(document.createElement("div")), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setClassName("view-rulers"), this._renderedRulers = [];
    const t = this._context.configuration.options;
    this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth;
  }
  dispose() {
    super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._rulers = t.get(
      103
      /* EditorOption.rulers */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onScrollChanged(e) {
    return e.scrollHeightChanged;
  }
  // --- end event handlers
  prepareRender(e) {
  }
  _ensureRulersCount() {
    const e = this._renderedRulers.length, t = this._rulers.length;
    if (e === t)
      return;
    if (e < t) {
      const { tabSize: n } = this._context.viewModel.model.getOptions(), o = n;
      let r = t - e;
      for (; r > 0; ) {
        const a = rt(document.createElement("div"));
        a.setClassName("view-ruler"), a.setWidth(o), this.domNode.appendChild(a), this._renderedRulers.push(a), r--;
      }
      return;
    }
    let i = e - t;
    for (; i > 0; ) {
      const n = this._renderedRulers.pop();
      this.domNode.removeChild(n), i--;
    }
  }
  render(e) {
    this._ensureRulersCount();
    for (let t = 0, i = this._rulers.length; t < i; t++) {
      const n = this._renderedRulers[t], o = this._rulers[t];
      n.setBoxShadow(o.color ? `1px 0 0 0 ${o.color} inset` : ""), n.setHeight(Math.min(e.scrollHeight, 1e6)), n.setLeft(o.column * this._typicalHalfwidthCharacterWidth);
    }
  }
}
class Poe extends Ds {
  constructor(e) {
    super(e), this._scrollTop = 0, this._width = 0, this._updateWidth(), this._shouldShow = !1;
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    this._useShadows = i.useShadows, this._domNode = rt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
  }
  dispose() {
    super.dispose();
  }
  _updateShouldShow() {
    const e = this._useShadows && this._scrollTop > 0;
    return this._shouldShow !== e ? (this._shouldShow = e, !0) : !1;
  }
  getDomNode() {
    return this._domNode;
  }
  _updateWidth() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    t.minimap.renderMinimap === 0 || t.minimap.minimapWidth > 0 && t.minimap.minimapLeft === 0 ? this._width = t.width : this._width = t.width - t.verticalScrollbarWidth;
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const i = this._context.configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return this._useShadows = i.useShadows, this._updateWidth(), this._updateShouldShow(), !0;
  }
  onScrollChanged(e) {
    return this._scrollTop = e.scrollTop, this._updateShouldShow();
  }
  // --- end event handlers
  prepareRender(e) {
  }
  render(e) {
    this._domNode.setWidth(this._width), this._domNode.setClassName(this._shouldShow ? "scroll-decoration" : "");
  }
}
class Hoe {
  constructor(e) {
    this.left = e.left, this.width = e.width, this.startStyle = null, this.endStyle = null;
  }
}
class Woe {
  constructor(e, t) {
    this.lineNumber = e, this.ranges = t;
  }
}
function Voe(s) {
  return new Hoe(s);
}
function zoe(s) {
  return new Woe(s.lineNumber, s.ranges.map(Voe));
}
const ei = class ei extends Ku {
  constructor(e) {
    super(), this._previousFrameVisibleRangesWithStyle = [], this._context = e;
    const t = this._context.configuration.options;
    this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, this._selections = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    return this._roundedSelection = t.get(
      102
      /* EditorOption.roundedSelection */
    ), this._typicalHalfwidthCharacterWidth = t.get(
      50
      /* EditorOption.fontInfo */
    ).typicalHalfwidthCharacterWidth, !0;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections.slice(0), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  _visibleRangesHaveGaps(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t].ranges.length > 1)
        return !0;
    return !1;
  }
  _enrichVisibleRangesWithStyle(e, t, i) {
    const n = this._typicalHalfwidthCharacterWidth / 4;
    let o = null, r = null;
    if (i && i.length > 0 && t.length > 0) {
      const a = t[0].lineNumber;
      if (a === e.startLineNumber)
        for (let c = 0; !o && c < i.length; c++)
          i[c].lineNumber === a && (o = i[c].ranges[0]);
      const l = t[t.length - 1].lineNumber;
      if (l === e.endLineNumber)
        for (let c = i.length - 1; !r && c >= 0; c--)
          i[c].lineNumber === l && (r = i[c].ranges[0]);
      o && !o.startStyle && (o = null), r && !r.startStyle && (r = null);
    }
    for (let a = 0, l = t.length; a < l; a++) {
      const c = t[a].ranges[0], d = c.left, h = c.left + c.width, u = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      }, g = {
        top: 0,
        bottom: 0
        /* CornerStyle.EXTERN */
      };
      if (a > 0) {
        const m = t[a - 1].ranges[0].left, p = t[a - 1].ranges[0].left + t[a - 1].ranges[0].width;
        zb(d - m) < n ? u.top = 2 : d > m && (u.top = 1), zb(h - p) < n ? g.top = 2 : m < h && h < p && (g.top = 1);
      } else o && (u.top = o.startStyle.top, g.top = o.endStyle.top);
      if (a + 1 < l) {
        const m = t[a + 1].ranges[0].left, p = t[a + 1].ranges[0].left + t[a + 1].ranges[0].width;
        zb(d - m) < n ? u.bottom = 2 : m < d && d < p && (u.bottom = 1), zb(h - p) < n ? g.bottom = 2 : h < p && (g.bottom = 1);
      } else r && (u.bottom = r.startStyle.bottom, g.bottom = r.endStyle.bottom);
      c.startStyle = u, c.endStyle = g;
    }
  }
  _getVisibleRangesWithStyle(e, t, i) {
    const o = (t.linesVisibleRangesForRange(e, !0) || []).map(zoe);
    return !this._visibleRangesHaveGaps(o) && this._roundedSelection && this._enrichVisibleRangesWithStyle(t.visibleRange, o, i), o;
  }
  _createSelectionPiece(e, t, i, n, o) {
    return '<div class="cslr ' + i + '" style="top:' + e.toString() + "px;bottom:" + t.toString() + "px;left:" + n.toString() + "px;width:" + o.toString() + 'px;"></div>';
  }
  _actualRenderOneSelection(e, t, i, n) {
    if (n.length === 0)
      return;
    const o = !!n[0].ranges[0].startStyle, r = n[0].lineNumber, a = n[n.length - 1].lineNumber;
    for (let l = 0, c = n.length; l < c; l++) {
      const d = n[l], h = d.lineNumber, u = h - t, g = i && h === r ? 1 : 0, m = i && h !== r && h === a ? 1 : 0;
      let p = "", A = "";
      for (let _ = 0, b = d.ranges.length; _ < b; _++) {
        const C = d.ranges[_];
        if (o) {
          const S = C.startStyle, x = C.endStyle;
          if (S.top === 1 || S.bottom === 1) {
            p += this._createSelectionPiece(g, m, ei.SELECTION_CLASS_NAME, C.left - ei.ROUNDED_PIECE_WIDTH, ei.ROUNDED_PIECE_WIDTH);
            let y = ei.EDITOR_BACKGROUND_CLASS_NAME;
            S.top === 1 && (y += " " + ei.SELECTION_TOP_RIGHT), S.bottom === 1 && (y += " " + ei.SELECTION_BOTTOM_RIGHT), p += this._createSelectionPiece(g, m, y, C.left - ei.ROUNDED_PIECE_WIDTH, ei.ROUNDED_PIECE_WIDTH);
          }
          if (x.top === 1 || x.bottom === 1) {
            p += this._createSelectionPiece(g, m, ei.SELECTION_CLASS_NAME, C.left + C.width, ei.ROUNDED_PIECE_WIDTH);
            let y = ei.EDITOR_BACKGROUND_CLASS_NAME;
            x.top === 1 && (y += " " + ei.SELECTION_TOP_LEFT), x.bottom === 1 && (y += " " + ei.SELECTION_BOTTOM_LEFT), p += this._createSelectionPiece(g, m, y, C.left + C.width, ei.ROUNDED_PIECE_WIDTH);
          }
        }
        let w = ei.SELECTION_CLASS_NAME;
        if (o) {
          const S = C.startStyle, x = C.endStyle;
          S.top === 0 && (w += " " + ei.SELECTION_TOP_LEFT), S.bottom === 0 && (w += " " + ei.SELECTION_BOTTOM_LEFT), x.top === 0 && (w += " " + ei.SELECTION_TOP_RIGHT), x.bottom === 0 && (w += " " + ei.SELECTION_BOTTOM_RIGHT);
        }
        A += this._createSelectionPiece(g, m, w, C.left, C.width);
      }
      e[u][0] += p, e[u][1] += A;
    }
  }
  prepareRender(e) {
    const t = [], i = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber;
    for (let r = i; r <= n; r++) {
      const a = r - i;
      t[a] = ["", ""];
    }
    const o = [];
    for (let r = 0, a = this._selections.length; r < a; r++) {
      const l = this._selections[r];
      if (l.isEmpty()) {
        o[r] = null;
        continue;
      }
      const c = this._getVisibleRangesWithStyle(l, e, this._previousFrameVisibleRangesWithStyle[r]);
      o[r] = c, this._actualRenderOneSelection(t, i, this._selections.length > 1, c);
    }
    this._previousFrameVisibleRangesWithStyle = o, this._renderResult = t.map(([r, a]) => r + a);
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
};
ei.SELECTION_CLASS_NAME = "selected-text", ei.SELECTION_TOP_LEFT = "top-left-radius", ei.SELECTION_BOTTOM_LEFT = "bottom-left-radius", ei.SELECTION_TOP_RIGHT = "top-right-radius", ei.SELECTION_BOTTOM_RIGHT = "bottom-right-radius", ei.EDITOR_BACKGROUND_CLASS_NAME = "monaco-editor-background", ei.ROUNDED_PIECE_WIDTH = 10;
let yD = ei;
rr((s, e) => {
  const t = s.getColor(Qj);
  t && !t.isTransparent() && e.addRule(`.monaco-editor .view-line span.inline-selected-text { color: ${t}; }`);
});
function zb(s) {
  return s < 0 ? -s : s;
}
class zO {
  constructor(e, t, i, n, o, r, a) {
    this.top = e, this.left = t, this.paddingLeft = i, this.width = n, this.height = o, this.textContent = r, this.textContentClassName = a;
  }
}
var yl;
(function(s) {
  s[s.Single = 0] = "Single", s[s.MultiPrimary = 1] = "MultiPrimary", s[s.MultiSecondary = 2] = "MultiSecondary";
})(yl || (yl = {}));
class UO {
  constructor(e, t) {
    this._context = e;
    const i = this._context.configuration.options, n = i.get(
      50
      /* EditorOption.fontInfo */
    );
    this._cursorStyle = i.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = i.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = n.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(i.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), this._isVisible = !0, this._domNode = rt(document.createElement("div")), this._domNode.setClassName(`cursor ${Mf}`), this._domNode.setHeight(this._lineHeight), this._domNode.setTop(0), this._domNode.setLeft(0), cn(this._domNode, n), this._domNode.setDisplay("none"), this._position = new F(1, 1), this._pluralityClass = "", this.setPlurality(t), this._lastRenderedContent = "", this._renderData = null;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._position;
  }
  setPlurality(e) {
    switch (e) {
      default:
      case yl.Single:
        this._pluralityClass = "";
        break;
      case yl.MultiPrimary:
        this._pluralityClass = "cursor-primary";
        break;
      case yl.MultiSecondary:
        this._pluralityClass = "cursor-secondary";
        break;
    }
  }
  show() {
    this._isVisible || (this._domNode.setVisibility("inherit"), this._isVisible = !0);
  }
  hide() {
    this._isVisible && (this._domNode.setVisibility("hidden"), this._isVisible = !1);
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    );
    return this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._typicalHalfwidthCharacterWidth = i.typicalHalfwidthCharacterWidth, this._lineCursorWidth = Math.min(t.get(
      31
      /* EditorOption.cursorWidth */
    ), this._typicalHalfwidthCharacterWidth), cn(this._domNode, i), !0;
  }
  onCursorPositionChanged(e, t) {
    return t ? this._domNode.domNode.style.transitionProperty = "none" : this._domNode.domNode.style.transitionProperty = "", this._position = e, !0;
  }
  /**
   * If `this._position` is inside a grapheme, returns the position where the grapheme starts.
   * Also returns the next grapheme.
   */
  _getGraphemeAwarePosition() {
    const { lineNumber: e, column: t } = this._position, i = this._context.viewModel.getLineContent(e), [n, o] = T7(i, t - 1);
    return [new F(e, n + 1), i.substring(n, o)];
  }
  _prepareRender(e) {
    let t = "", i = "";
    const [n, o] = this._getGraphemeAwarePosition();
    if (this._cursorStyle === zi.Line || this._cursorStyle === zi.LineThin) {
      const u = e.visibleRangeForPosition(n);
      if (!u || u.outsideRenderedLine)
        return null;
      const g = fe(this._domNode.domNode);
      let m;
      this._cursorStyle === zi.Line ? (m = gR(g, this._lineCursorWidth > 0 ? this._lineCursorWidth : 2), m > 2 && (t = o, i = this._getTokenClassName(n))) : m = gR(g, 1);
      let p = u.left, A = 0;
      m >= 2 && p >= 1 && (A = 1, p -= A);
      const _ = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta;
      return new zO(_, p, A, m, this._lineHeight, t, i);
    }
    const r = e.linesVisibleRangesForRange(new E(n.lineNumber, n.column, n.lineNumber, n.column + o.length), !1);
    if (!r || r.length === 0)
      return null;
    const a = r[0];
    if (a.outsideRenderedLine || a.ranges.length === 0)
      return null;
    const l = a.ranges[0], c = o === "	" ? this._typicalHalfwidthCharacterWidth : l.width < 1 ? this._typicalHalfwidthCharacterWidth : l.width;
    this._cursorStyle === zi.Block && (t = o, i = this._getTokenClassName(n));
    let d = e.getVerticalOffsetForLineNumber(n.lineNumber) - e.bigNumbersDelta, h = this._lineHeight;
    return (this._cursorStyle === zi.Underline || this._cursorStyle === zi.UnderlineThin) && (d += this._lineHeight - 2, h = 2), new zO(d, l.left, 0, c, h, t, i);
  }
  _getTokenClassName(e) {
    const t = this._context.viewModel.getViewLineData(e.lineNumber), i = t.tokens.findTokenIndexAtOffset(e.column - 1);
    return t.tokens.getClassName(i);
  }
  prepareRender(e) {
    this._renderData = this._prepareRender(e);
  }
  render(e) {
    return this._renderData ? (this._lastRenderedContent !== this._renderData.textContent && (this._lastRenderedContent = this._renderData.textContent, this._domNode.domNode.textContent = this._lastRenderedContent), this._domNode.setClassName(`cursor ${this._pluralityClass} ${Mf} ${this._renderData.textContentClassName}`), this._domNode.setDisplay("block"), this._domNode.setTop(this._renderData.top), this._domNode.setLeft(this._renderData.left), this._domNode.setPaddingLeft(this._renderData.paddingLeft), this._domNode.setWidth(this._renderData.width), this._domNode.setLineHeight(this._renderData.height), this._domNode.setHeight(this._renderData.height), {
      domNode: this._domNode.domNode,
      position: this._position,
      contentLeft: this._renderData.left,
      height: this._renderData.height,
      width: 2
    }) : (this._domNode.setDisplay("none"), null);
  }
}
const _A = class _A extends Ds {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._selectionIsEmpty = !0, this._isComposingInput = !1, this._isVisible = !1, this._primaryCursor = new UO(this._context, yl.Single), this._secondaryCursors = [], this._renderData = [], this._domNode = rt(document.createElement("div")), this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true"), this._updateDomClassName(), this._domNode.appendChild(this._primaryCursor.getDomNode()), this._startCursorBlinkAnimation = new nr(), this._cursorFlatBlinkInterval = new YM(), this._blinkingEnabled = !1, this._editorHasFocus = !1, this._updateBlinking();
  }
  dispose() {
    super.dispose(), this._startCursorBlinkAnimation.dispose(), this._cursorFlatBlinkInterval.dispose();
  }
  getDomNode() {
    return this._domNode;
  }
  // --- begin event handlers
  onCompositionStart(e) {
    return this._isComposingInput = !0, this._updateBlinking(), !0;
  }
  onCompositionEnd(e) {
    return this._isComposingInput = !1, this._updateBlinking(), !0;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options;
    this._readOnly = t.get(
      92
      /* EditorOption.readOnly */
    ), this._cursorBlinking = t.get(
      26
      /* EditorOption.cursorBlinking */
    ), this._cursorStyle = t.get(
      28
      /* EditorOption.cursorStyle */
    ), this._cursorSmoothCaretAnimation = t.get(
      27
      /* EditorOption.cursorSmoothCaretAnimation */
    ), this._updateBlinking(), this._updateDomClassName(), this._primaryCursor.onConfigurationChanged(e);
    for (let i = 0, n = this._secondaryCursors.length; i < n; i++)
      this._secondaryCursors[i].onConfigurationChanged(e);
    return !0;
  }
  _onCursorPositionChanged(e, t, i) {
    const n = this._secondaryCursors.length !== t.length || this._cursorSmoothCaretAnimation === "explicit" && i !== 3;
    if (this._primaryCursor.setPlurality(t.length ? yl.MultiPrimary : yl.Single), this._primaryCursor.onCursorPositionChanged(e, n), this._updateBlinking(), this._secondaryCursors.length < t.length) {
      const o = t.length - this._secondaryCursors.length;
      for (let r = 0; r < o; r++) {
        const a = new UO(this._context, yl.MultiSecondary);
        this._domNode.domNode.insertBefore(a.getDomNode().domNode, this._primaryCursor.getDomNode().domNode.nextSibling), this._secondaryCursors.push(a);
      }
    } else if (this._secondaryCursors.length > t.length) {
      const o = this._secondaryCursors.length - t.length;
      for (let r = 0; r < o; r++)
        this._domNode.removeChild(this._secondaryCursors[0].getDomNode()), this._secondaryCursors.splice(0, 1);
    }
    for (let o = 0; o < t.length; o++)
      this._secondaryCursors[o].onCursorPositionChanged(t[o], n);
  }
  onCursorStateChanged(e) {
    const t = [];
    for (let n = 0, o = e.selections.length; n < o; n++)
      t[n] = e.selections[n].getPosition();
    this._onCursorPositionChanged(t[0], t.slice(1), e.reason);
    const i = e.selections[0].isEmpty();
    return this._selectionIsEmpty !== i && (this._selectionIsEmpty = i, this._updateDomClassName()), !0;
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onFocusChanged(e) {
    return this._editorHasFocus = e.isFocused, this._updateBlinking(), !1;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return !0;
  }
  onTokensChanged(e) {
    const t = (i) => {
      for (let n = 0, o = e.ranges.length; n < o; n++)
        if (e.ranges[n].fromLineNumber <= i.lineNumber && i.lineNumber <= e.ranges[n].toLineNumber)
          return !0;
      return !1;
    };
    if (t(this._primaryCursor.getPosition()))
      return !0;
    for (const i of this._secondaryCursors)
      if (t(i.getPosition()))
        return !0;
    return !1;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  // ---- blinking logic
  _getCursorBlinking() {
    return this._isComposingInput || !this._editorHasFocus ? 0 : this._readOnly ? 5 : this._cursorBlinking;
  }
  _updateBlinking() {
    this._startCursorBlinkAnimation.cancel(), this._cursorFlatBlinkInterval.cancel();
    const e = this._getCursorBlinking(), t = e === 0, i = e === 5;
    t ? this._hide() : this._show(), this._blinkingEnabled = !1, this._updateDomClassName(), !t && !i && (e === 1 ? this._cursorFlatBlinkInterval.cancelAndSet(() => {
      this._isVisible ? this._hide() : this._show();
    }, _A.BLINK_INTERVAL, fe(this._domNode.domNode)) : this._startCursorBlinkAnimation.setIfNotSet(() => {
      this._blinkingEnabled = !0, this._updateDomClassName();
    }, _A.BLINK_INTERVAL));
  }
  // --- end blinking logic
  _updateDomClassName() {
    this._domNode.setClassName(this._getClassName());
  }
  _getClassName() {
    let e = "cursors-layer";
    switch (this._selectionIsEmpty || (e += " has-selection"), this._cursorStyle) {
      case zi.Line:
        e += " cursor-line-style";
        break;
      case zi.Block:
        e += " cursor-block-style";
        break;
      case zi.Underline:
        e += " cursor-underline-style";
        break;
      case zi.LineThin:
        e += " cursor-line-thin-style";
        break;
      case zi.BlockOutline:
        e += " cursor-block-outline-style";
        break;
      case zi.UnderlineThin:
        e += " cursor-underline-thin-style";
        break;
      default:
        e += " cursor-line-style";
    }
    if (this._blinkingEnabled)
      switch (this._getCursorBlinking()) {
        case 1:
          e += " cursor-blink";
          break;
        case 2:
          e += " cursor-smooth";
          break;
        case 3:
          e += " cursor-phase";
          break;
        case 4:
          e += " cursor-expand";
          break;
        case 5:
          e += " cursor-solid";
          break;
        default:
          e += " cursor-solid";
      }
    else
      e += " cursor-solid";
    return (this._cursorSmoothCaretAnimation === "on" || this._cursorSmoothCaretAnimation === "explicit") && (e += " cursor-smooth-caret-animation"), e;
  }
  _show() {
    this._primaryCursor.show();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].show();
    this._isVisible = !0;
  }
  _hide() {
    this._primaryCursor.hide();
    for (let e = 0, t = this._secondaryCursors.length; e < t; e++)
      this._secondaryCursors[e].hide();
    this._isVisible = !1;
  }
  // ---- IViewPart implementation
  prepareRender(e) {
    this._primaryCursor.prepareRender(e);
    for (let t = 0, i = this._secondaryCursors.length; t < i; t++)
      this._secondaryCursors[t].prepareRender(e);
  }
  render(e) {
    const t = [];
    let i = 0;
    const n = this._primaryCursor.render(e);
    n && (t[i++] = n);
    for (let o = 0, r = this._secondaryCursors.length; o < r; o++) {
      const a = this._secondaryCursors[o].render(e);
      a && (t[i++] = a);
    }
    this._renderData = t;
  }
  getLastRenderData() {
    return this._renderData;
  }
};
_A.BLINK_INTERVAL = 500;
let xD = _A;
rr((s, e) => {
  const t = [
    { class: ".cursor", foreground: cS, background: jN },
    { class: ".cursor-primary", foreground: X3, background: aX },
    { class: ".cursor-secondary", foreground: Z3, background: lX }
  ];
  for (const i of t) {
    const n = s.getColor(i.foreground);
    if (n) {
      let o = s.getColor(i.background);
      o || (o = n.opposite()), e.addRule(`.monaco-editor .cursors-layer ${i.class} { background-color: ${n}; border-color: ${n}; color: ${o}; }`), Ca(s.type) && e.addRule(`.monaco-editor .cursors-layer.has-selection ${i.class} { border-left: 1px solid ${o}; border-right: 1px solid ${o}; }`);
    }
  }
});
const nx = () => {
  throw new Error("Invalid change accessor");
};
class Uoe extends Ds {
  constructor(e) {
    super(e);
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, this.domNode = rt(document.createElement("div")), this.domNode.setClassName("view-zones"), this.domNode.setPosition("absolute"), this.domNode.setAttribute("role", "presentation"), this.domNode.setAttribute("aria-hidden", "true"), this.marginDomNode = rt(document.createElement("div")), this.marginDomNode.setClassName("margin-view-zones"), this.marginDomNode.setPosition("absolute"), this.marginDomNode.setAttribute("role", "presentation"), this.marginDomNode.setAttribute("aria-hidden", "true"), this._zones = {};
  }
  dispose() {
    super.dispose(), this._zones = {};
  }
  // ---- begin view event handlers
  _recomputeWhitespacesProps() {
    const e = this._context.viewLayout.getWhitespaces(), t = /* @__PURE__ */ new Map();
    for (const n of e)
      t.set(n.id, n);
    let i = !1;
    return this._context.viewModel.changeWhitespace((n) => {
      const o = Object.keys(this._zones);
      for (let r = 0, a = o.length; r < a; r++) {
        const l = o[r], c = this._zones[l], d = this._computeWhitespaceProps(c.delegate);
        c.isInHiddenArea = d.isInHiddenArea;
        const h = t.get(l);
        h && (h.afterLineNumber !== d.afterViewLineNumber || h.height !== d.heightInPx) && (n.changeOneWhitespace(l, d.afterViewLineNumber, d.heightInPx), this._safeCallOnComputedHeight(c.delegate, d.heightInPx), i = !0);
      }
    }), i;
  }
  onConfigurationChanged(e) {
    const t = this._context.configuration.options, i = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return this._lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this._contentWidth = i.contentWidth, this._contentLeft = i.contentLeft, e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._recomputeWhitespacesProps(), !0;
  }
  onLineMappingChanged(e) {
    return this._recomputeWhitespacesProps();
  }
  onLinesDeleted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged || e.scrollWidthChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  // ---- end view event handlers
  _getZoneOrdinal(e) {
    return e.ordinal ?? e.afterColumn ?? 1e4;
  }
  _computeWhitespaceProps(e) {
    if (e.afterLineNumber === 0)
      return {
        isInHiddenArea: !1,
        afterViewLineNumber: 0,
        heightInPx: this._heightInPixels(e),
        minWidthInPx: this._minWidthInPixels(e)
      };
    let t;
    if (typeof e.afterColumn < "u")
      t = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: e.afterColumn
      });
    else {
      const r = this._context.viewModel.model.validatePosition({
        lineNumber: e.afterLineNumber,
        column: 1
      }).lineNumber;
      t = new F(r, this._context.viewModel.model.getLineMaxColumn(r));
    }
    let i;
    t.column === this._context.viewModel.model.getLineMaxColumn(t.lineNumber) ? i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber + 1,
      column: 1
    }) : i = this._context.viewModel.model.validatePosition({
      lineNumber: t.lineNumber,
      column: t.column + 1
    });
    const n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(t, e.afterColumnAffinity, !0), o = e.showInHiddenAreas || this._context.viewModel.coordinatesConverter.modelPositionIsVisible(i);
    return {
      isInHiddenArea: !o,
      afterViewLineNumber: n.lineNumber,
      heightInPx: o ? this._heightInPixels(e) : 0,
      minWidthInPx: this._minWidthInPixels(e)
    };
  }
  changeViewZones(e) {
    let t = !1;
    return this._context.viewModel.changeWhitespace((i) => {
      const n = {
        addZone: (o) => (t = !0, this._addZone(i, o)),
        removeZone: (o) => {
          o && (t = this._removeZone(i, o) || t);
        },
        layoutZone: (o) => {
          o && (t = this._layoutZone(i, o) || t);
        }
      };
      Qoe(e, n), n.addZone = nx, n.removeZone = nx, n.layoutZone = nx;
    }), t;
  }
  _addZone(e, t) {
    const i = this._computeWhitespaceProps(t), o = {
      whitespaceId: e.insertWhitespace(i.afterViewLineNumber, this._getZoneOrdinal(t), i.heightInPx, i.minWidthInPx),
      delegate: t,
      isInHiddenArea: i.isInHiddenArea,
      isVisible: !1,
      domNode: rt(t.domNode),
      marginDomNode: t.marginDomNode ? rt(t.marginDomNode) : null
    };
    return this._safeCallOnComputedHeight(o.delegate, i.heightInPx), o.domNode.setPosition("absolute"), o.domNode.domNode.style.width = "100%", o.domNode.setDisplay("none"), o.domNode.setAttribute("monaco-view-zone", o.whitespaceId), this.domNode.appendChild(o.domNode), o.marginDomNode && (o.marginDomNode.setPosition("absolute"), o.marginDomNode.domNode.style.width = "100%", o.marginDomNode.setDisplay("none"), o.marginDomNode.setAttribute("monaco-view-zone", o.whitespaceId), this.marginDomNode.appendChild(o.marginDomNode)), this._zones[o.whitespaceId] = o, this.setShouldRender(), o.whitespaceId;
  }
  _removeZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t];
      return delete this._zones[t], e.removeWhitespace(i.whitespaceId), i.domNode.removeAttribute("monaco-visible-view-zone"), i.domNode.removeAttribute("monaco-view-zone"), i.domNode.domNode.remove(), i.marginDomNode && (i.marginDomNode.removeAttribute("monaco-visible-view-zone"), i.marginDomNode.removeAttribute("monaco-view-zone"), i.marginDomNode.domNode.remove()), this.setShouldRender(), !0;
    }
    return !1;
  }
  _layoutZone(e, t) {
    if (this._zones.hasOwnProperty(t)) {
      const i = this._zones[t], n = this._computeWhitespaceProps(i.delegate);
      return i.isInHiddenArea = n.isInHiddenArea, e.changeOneWhitespace(i.whitespaceId, n.afterViewLineNumber, n.heightInPx), this._safeCallOnComputedHeight(i.delegate, n.heightInPx), this.setShouldRender(), !0;
    }
    return !1;
  }
  shouldSuppressMouseDownOnViewZone(e) {
    return this._zones.hasOwnProperty(e) ? !!this._zones[e].delegate.suppressMouseDown : !1;
  }
  _heightInPixels(e) {
    return typeof e.heightInPx == "number" ? e.heightInPx : typeof e.heightInLines == "number" ? this._lineHeight * e.heightInLines : this._lineHeight;
  }
  _minWidthInPixels(e) {
    return typeof e.minWidthInPx == "number" ? e.minWidthInPx : 0;
  }
  _safeCallOnComputedHeight(e, t) {
    if (typeof e.onComputedHeight == "function")
      try {
        e.onComputedHeight(t);
      } catch (i) {
        Pe(i);
      }
  }
  _safeCallOnDomNodeTop(e, t) {
    if (typeof e.onDomNodeTop == "function")
      try {
        e.onDomNodeTop(t);
      } catch (i) {
        Pe(i);
      }
  }
  prepareRender(e) {
  }
  render(e) {
    const t = e.viewportData.whitespaceViewportData, i = {};
    let n = !1;
    for (const r of t)
      this._zones[r.id].isInHiddenArea || (i[r.id] = r, n = !0);
    const o = Object.keys(this._zones);
    for (let r = 0, a = o.length; r < a; r++) {
      const l = o[r], c = this._zones[l];
      let d = 0, h = 0, u = "none";
      i.hasOwnProperty(l) ? (d = i[l].verticalOffset - e.bigNumbersDelta, h = i[l].height, u = "block", c.isVisible || (c.domNode.setAttribute("monaco-visible-view-zone", "true"), c.isVisible = !0), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(i[l].verticalOffset))) : (c.isVisible && (c.domNode.removeAttribute("monaco-visible-view-zone"), c.isVisible = !1), this._safeCallOnDomNodeTop(c.delegate, e.getScrolledTopFromAbsoluteTop(-1e6))), c.domNode.setTop(d), c.domNode.setHeight(h), c.domNode.setDisplay(u), c.marginDomNode && (c.marginDomNode.setTop(d), c.marginDomNode.setHeight(h), c.marginDomNode.setDisplay(u));
    }
    n && (this.domNode.setWidth(Math.max(e.scrollWidth, this._contentWidth)), this.marginDomNode.setWidth(this._contentLeft));
  }
}
function Qoe(s, e) {
  try {
    return s(e);
  } catch (t) {
    Pe(t);
  }
}
class Goe extends Ku {
  constructor(e) {
    super(), this._context = e, this._options = new QO(this._context.configuration), this._selection = [], this._renderResult = null, this._context.addEventHandler(this);
  }
  dispose() {
    this._context.removeEventHandler(this), this._renderResult = null, super.dispose();
  }
  // --- begin event handlers
  onConfigurationChanged(e) {
    const t = new QO(this._context.configuration);
    return this._options.equals(t) ? e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    ) : (this._options = t, !0);
  }
  onCursorStateChanged(e) {
    return this._selection = e.selections, this._options.renderWhitespace === "selection";
  }
  onDecorationsChanged(e) {
    return !0;
  }
  onFlushed(e) {
    return !0;
  }
  onLinesChanged(e) {
    return !0;
  }
  onLinesDeleted(e) {
    return !0;
  }
  onLinesInserted(e) {
    return !0;
  }
  onScrollChanged(e) {
    return e.scrollTopChanged;
  }
  onZonesChanged(e) {
    return !0;
  }
  // --- end event handlers
  prepareRender(e) {
    if (this._options.renderWhitespace === "none") {
      this._renderResult = null;
      return;
    }
    const t = e.visibleRange.startLineNumber, n = e.visibleRange.endLineNumber - t + 1, o = new Array(n);
    for (let a = 0; a < n; a++)
      o[a] = !0;
    const r = this._context.viewModel.getMinimapLinesRenderingData(e.viewportData.startLineNumber, e.viewportData.endLineNumber, o);
    this._renderResult = [];
    for (let a = e.viewportData.startLineNumber; a <= e.viewportData.endLineNumber; a++) {
      const l = a - e.viewportData.startLineNumber, c = r.data[l];
      let d = null;
      if (this._options.renderWhitespace === "selection") {
        const h = this._selection;
        for (const u of h) {
          if (u.endLineNumber < a || u.startLineNumber > a)
            continue;
          const g = u.startLineNumber === a ? u.startColumn : c.minColumn, m = u.endLineNumber === a ? u.endColumn : c.maxColumn;
          g < m && (d || (d = []), d.push(new A8(g - 1, m - 1)));
        }
      }
      this._renderResult[l] = this._applyRenderWhitespace(e, a, d, c);
    }
  }
  _applyRenderWhitespace(e, t, i, n) {
    if (this._options.renderWhitespace === "selection" && !i || this._options.renderWhitespace === "trailing" && n.continuesWithWrappedLine)
      return "";
    const o = this._context.theme.getColor(YN), r = this._options.renderWithSVG, a = n.content, l = this._options.stopRenderingLineAfter === -1 ? a.length : Math.min(this._options.stopRenderingLineAfter, a.length), c = n.continuesWithWrappedLine, d = n.minColumn - 1, h = this._options.renderWhitespace === "boundary", u = this._options.renderWhitespace === "trailing", g = this._options.lineHeight, m = this._options.middotWidth, p = this._options.wsmiddotWidth, A = this._options.spaceWidth, _ = Math.abs(p - A), b = Math.abs(m - A), C = _ < b ? 11825 : 183, w = this._options.canUseHalfwidthRightwardsArrow;
    let S = "", x = !1, y = Sn(a), D;
    y === -1 ? (x = !0, y = l, D = l) : D = Ru(a);
    let I = 0, Q = i && i[I], P = 0;
    for (let W = d; W < l; W++) {
      const j = a.charCodeAt(W);
      if (Q && W >= Q.endOffset && (I++, Q = i && i[I]), j !== 9 && j !== 32 || u && !x && W <= D)
        continue;
      if (h && W >= y && W <= D && j === 32) {
        const J = W - 1 >= 0 ? a.charCodeAt(W - 1) : 0, se = W + 1 < l ? a.charCodeAt(W + 1) : 0;
        if (J !== 32 && se !== 32)
          continue;
      }
      if (h && c && W === l - 1) {
        const J = W - 1 >= 0 ? a.charCodeAt(W - 1) : 0;
        if (j === 32 && J !== 32 && J !== 9)
          continue;
      }
      if (i && (!Q || Q.startOffset > W || Q.endOffset <= W))
        continue;
      const H = e.visibleRangeForPosition(new F(t, W + 1));
      H && (r ? (P = Math.max(P, H.left), j === 9 ? S += this._renderArrow(g, A, H.left) : S += `<circle cx="${(H.left + A / 2).toFixed(2)}" cy="${(g / 2).toFixed(2)}" r="${(A / 7).toFixed(2)}" />`) : j === 9 ? S += `<div class="mwh" style="left:${H.left}px;height:${g}px;">${w ? "￫" : "→"}</div>` : S += `<div class="mwh" style="left:${H.left}px;height:${g}px;">${String.fromCharCode(C)}</div>`);
    }
    return r ? (P = Math.round(P + A), `<svg style="bottom:0;position:absolute;width:${P}px;height:${g}px" viewBox="0 0 ${P} ${g}" xmlns="http://www.w3.org/2000/svg" fill="${o}">` + S + "</svg>") : S;
  }
  _renderArrow(e, t, i) {
    const n = t / 7, o = t, r = e / 2, a = i, l = { x: 0, y: n / 2 }, c = { x: 100 / 125 * o, y: l.y }, d = { x: c.x - 0.2 * c.x, y: c.y + 0.2 * c.x }, h = { x: d.x + 0.1 * c.x, y: d.y + 0.1 * c.x }, u = { x: h.x + 0.35 * c.x, y: h.y - 0.35 * c.x }, g = { x: u.x, y: -u.y }, m = { x: h.x, y: -h.y }, p = { x: d.x, y: -d.y }, A = { x: c.x, y: -c.y }, _ = { x: l.x, y: -l.y };
    return `<path d="M ${[l, c, d, h, u, g, m, p, A, _].map((w) => `${(a + w.x).toFixed(2)} ${(r + w.y).toFixed(2)}`).join(" L ")}" />`;
  }
  render(e, t) {
    if (!this._renderResult)
      return "";
    const i = t - e;
    return i < 0 || i >= this._renderResult.length ? "" : this._renderResult[i];
  }
}
class QO {
  constructor(e) {
    const t = e.options, i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      38
      /* EditorOption.experimentalWhitespaceRendering */
    );
    n === "off" ? (this.renderWhitespace = "none", this.renderWithSVG = !1) : n === "svg" ? (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !0) : (this.renderWhitespace = t.get(
      100
      /* EditorOption.renderWhitespace */
    ), this.renderWithSVG = !1), this.spaceWidth = i.spaceWidth, this.middotWidth = i.middotWidth, this.wsmiddotWidth = i.wsmiddotWidth, this.canUseHalfwidthRightwardsArrow = i.canUseHalfwidthRightwardsArrow, this.lineHeight = t.get(
      67
      /* EditorOption.lineHeight */
    ), this.stopRenderingLineAfter = t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    );
  }
  equals(e) {
    return this.renderWhitespace === e.renderWhitespace && this.renderWithSVG === e.renderWithSVG && this.spaceWidth === e.spaceWidth && this.middotWidth === e.middotWidth && this.wsmiddotWidth === e.wsmiddotWidth && this.canUseHalfwidthRightwardsArrow === e.canUseHalfwidthRightwardsArrow && this.lineHeight === e.lineHeight && this.stopRenderingLineAfter === e.stopRenderingLineAfter;
  }
}
class joe {
  constructor(e, t, i, n) {
    this.selections = e, this.startLineNumber = t.startLineNumber | 0, this.endLineNumber = t.endLineNumber | 0, this.relativeVerticalOffset = t.relativeVerticalOffset, this.bigNumbersDelta = t.bigNumbersDelta | 0, this.lineHeight = t.lineHeight | 0, this.whitespaceViewportData = i, this._model = n, this.visibleRange = new E(t.startLineNumber, this._model.getLineMinColumn(t.startLineNumber), t.endLineNumber, this._model.getLineMaxColumn(t.endLineNumber));
  }
  getViewLineRenderingData(e) {
    return this._model.getViewportViewLineRenderingData(this.visibleRange, e);
  }
  getDecorationsInViewport() {
    return this._model.getDecorationsInViewport(this.visibleRange);
  }
}
class Yoe {
  get type() {
    return this._theme.type;
  }
  get value() {
    return this._theme;
  }
  constructor(e) {
    this._theme = e;
  }
  update(e) {
    this._theme = e;
  }
  getColor(e) {
    return this._theme.getColor(e);
  }
}
class Koe {
  constructor(e, t, i) {
    this.configuration = e, this.theme = new Yoe(t), this.viewModel = i, this.viewLayout = i.viewLayout;
  }
  addEventHandler(e) {
    this.viewModel.addViewEventHandler(e);
  }
  removeEventHandler(e) {
    this.viewModel.removeViewEventHandler(e);
  }
}
var Joe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qoe = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ED = class extends Y_ {
  constructor(e, t, i, n, o, r, a) {
    super(), this._instantiationService = a, this._shouldRecomputeGlyphMarginLanes = !1, this._selections = [new Ue(1, 1, 1, 1)], this._renderAnimationFrame = null;
    const l = new noe(t, n, o, e);
    this._context = new Koe(t, i, n), this._context.addEventHandler(this), this._viewParts = [], this._textAreaHandler = this._instantiationService.createInstance(_D, this._context, l, this._createTextAreaHandlerHelper()), this._viewParts.push(this._textAreaHandler), this._linesContent = rt(document.createElement("div")), this._linesContent.setClassName("lines-content monaco-editor-background"), this._linesContent.setPosition("absolute"), this.domNode = rt(document.createElement("div")), this.domNode.setClassName(this._getEditorClassName()), this.domNode.setAttribute("role", "code"), this._overflowGuardContainer = rt(document.createElement("div")), Pr.write(
      this._overflowGuardContainer,
      3
      /* PartFingerprint.OverflowGuard */
    ), this._overflowGuardContainer.setClassName("overflow-guard"), this._scrollbar = new goe(this._context, this._linesContent, this.domNode, this._overflowGuardContainer), this._viewParts.push(this._scrollbar), this._viewLines = new SD(this._context, this._linesContent), this._viewZones = new Uoe(this._context), this._viewParts.push(this._viewZones);
    const c = new Boe(this._context);
    this._viewParts.push(c);
    const d = new Poe(this._context);
    this._viewParts.push(d);
    const h = new ooe(this._context);
    this._viewParts.push(h), h.addDynamicOverlay(new doe(this._context)), h.addDynamicOverlay(new yD(this._context)), h.addDynamicOverlay(new woe(this._context)), h.addDynamicOverlay(new uoe(this._context)), h.addDynamicOverlay(new Goe(this._context));
    const u = new roe(this._context);
    this._viewParts.push(u), u.addDynamicOverlay(new hoe(this._context)), u.addDynamicOverlay(new xoe(this._context)), u.addDynamicOverlay(new yoe(this._context)), u.addDynamicOverlay(new Cv(this._context)), this._glyphMarginWidgets = new poe(this._context), this._viewParts.push(this._glyphMarginWidgets);
    const g = new vv(this._context);
    g.getDomNode().appendChild(this._viewZones.marginDomNode), g.getDomNode().appendChild(u.getDomNode()), g.getDomNode().appendChild(this._glyphMarginWidgets.domNode), this._viewParts.push(g), this._contentWidgets = new loe(this._context, this.domNode), this._viewParts.push(this._contentWidgets), this._viewCursors = new xD(this._context), this._viewParts.push(this._viewCursors), this._overlayWidgets = new Noe(this._context, this.domNode), this._viewParts.push(this._overlayWidgets);
    const m = new Ooe(this._context);
    this._viewParts.push(m);
    const p = new aoe(this._context);
    this._viewParts.push(p);
    const A = new Moe(this._context);
    if (this._viewParts.push(A), c) {
      const _ = this._scrollbar.getOverviewRulerLayoutInfo();
      _.parent.insertBefore(c.getDomNode(), _.insertBefore);
    }
    this._linesContent.appendChild(h.getDomNode()), this._linesContent.appendChild(m.domNode), this._linesContent.appendChild(this._viewZones.domNode), this._linesContent.appendChild(this._viewLines.getDomNode()), this._linesContent.appendChild(this._contentWidgets.domNode), this._linesContent.appendChild(this._viewCursors.getDomNode()), this._overflowGuardContainer.appendChild(g.getDomNode()), this._overflowGuardContainer.appendChild(this._scrollbar.getDomNode()), this._overflowGuardContainer.appendChild(d.getDomNode()), this._overflowGuardContainer.appendChild(this._textAreaHandler.textArea), this._overflowGuardContainer.appendChild(this._textAreaHandler.textAreaCover), this._overflowGuardContainer.appendChild(this._overlayWidgets.getDomNode()), this._overflowGuardContainer.appendChild(A.getDomNode()), this._overflowGuardContainer.appendChild(p.domNode), this.domNode.appendChild(this._overflowGuardContainer), r ? (r.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode.domNode), r.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode.domNode)) : (this.domNode.appendChild(this._contentWidgets.overflowingContentWidgetsDomNode), this.domNode.appendChild(this._overlayWidgets.overflowingOverlayWidgetsDomNode)), this._applyLayout(), this._pointerHandler = this._register(new xse(this._context, l, this._createPointerHandlerHelper()));
  }
  _computeGlyphMarginLanes() {
    const e = this._context.viewModel.model, t = this._context.viewModel.glyphLanes;
    let i = [], n = 0;
    i = i.concat(e.getAllMarginDecorations().map((o) => {
      const r = o.options.glyphMargin?.position ?? qo.Center;
      return n = Math.max(n, o.range.endLineNumber), { range: o.range, lane: r, persist: o.options.glyphMargin?.persistLane };
    })), i = i.concat(this._glyphMarginWidgets.getWidgets().map((o) => {
      const r = e.validateRange(o.preference.range);
      return n = Math.max(n, r.endLineNumber), { range: r, lane: o.preference.lane };
    })), i.sort((o, r) => E.compareRangesUsingStarts(o.range, r.range)), t.reset(n);
    for (const o of i)
      t.push(o.lane, o.range, o.persist);
    return t;
  }
  _createPointerHandlerHelper() {
    return {
      viewDomNode: this.domNode.domNode,
      linesContentDomNode: this._linesContent.domNode,
      viewLinesDomNode: this._viewLines.getDomNode().domNode,
      focusTextArea: () => {
        this.focus();
      },
      dispatchTextAreaEvent: (e) => {
        this._textAreaHandler.textArea.domNode.dispatchEvent(e);
      },
      getLastRenderData: () => {
        const e = this._viewCursors.getLastRenderData() || [], t = this._textAreaHandler.getLastRenderData();
        return new gse(e, t);
      },
      renderNow: () => {
        this.render(!0, !1);
      },
      shouldSuppressMouseDownOnViewZone: (e) => this._viewZones.shouldSuppressMouseDownOnViewZone(e),
      shouldSuppressMouseDownOnWidget: (e) => this._contentWidgets.shouldSuppressMouseDownOnWidget(e),
      getPositionFromDOMInfo: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getPositionFromDOMInfo(e, t)),
      visibleRangeForPosition: (e, t) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(new F(e, t))),
      getLineWidth: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.getLineWidth(e))
    };
  }
  _createTextAreaHandlerHelper() {
    return {
      visibleRangeForPosition: (e) => (this._flushAccumulatedAndRenderNow(), this._viewLines.visibleRangeForPosition(e))
    };
  }
  _applyLayout() {
    const t = this._context.configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
    this.domNode.setWidth(t.width), this.domNode.setHeight(t.height), this._overflowGuardContainer.setWidth(t.width), this._overflowGuardContainer.setHeight(t.height), this._linesContent.setWidth(16777216), this._linesContent.setHeight(16777216);
  }
  _getEditorClassName() {
    const e = this._textAreaHandler.isFocused() ? " focused" : "";
    return this._context.configuration.options.get(
      143
      /* EditorOption.editorClassName */
    ) + " " + hL(this._context.theme.type) + e;
  }
  // --- begin event handlers
  handleEvents(e) {
    super.handleEvents(e), this._scheduleRender();
  }
  onConfigurationChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), this._applyLayout(), !1;
  }
  onCursorStateChanged(e) {
    return this._selections = e.selections, !1;
  }
  onDecorationsChanged(e) {
    return e.affectsGlyphMargin && (this._shouldRecomputeGlyphMarginLanes = !0), !1;
  }
  onFocusChanged(e) {
    return this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  onThemeChanged(e) {
    return this._context.theme.update(e.theme), this.domNode.setClassName(this._getEditorClassName()), !1;
  }
  // --- end event handlers
  dispose() {
    this._renderAnimationFrame !== null && (this._renderAnimationFrame.dispose(), this._renderAnimationFrame = null), this._contentWidgets.overflowingContentWidgetsDomNode.domNode.remove(), this._context.removeEventHandler(this), this._viewLines.dispose();
    for (const e of this._viewParts)
      e.dispose();
    super.dispose();
  }
  _scheduleRender() {
    if (this._store.isDisposed)
      throw new lt();
    if (this._renderAnimationFrame === null) {
      const e = this._createCoordinatedRendering();
      this._renderAnimationFrame = LD.INSTANCE.scheduleCoordinatedRendering({
        window: fe(this.domNode?.domNode),
        prepareRenderText: () => {
          if (this._store.isDisposed)
            throw new lt();
          try {
            return e.prepareRenderText();
          } finally {
            this._renderAnimationFrame = null;
          }
        },
        renderText: () => {
          if (this._store.isDisposed)
            throw new lt();
          return e.renderText();
        },
        prepareRender: (t, i) => {
          if (this._store.isDisposed)
            throw new lt();
          return e.prepareRender(t, i);
        },
        render: (t, i) => {
          if (this._store.isDisposed)
            throw new lt();
          return e.render(t, i);
        }
      });
    }
  }
  _flushAccumulatedAndRenderNow() {
    const e = this._createCoordinatedRendering();
    Tc(() => e.prepareRenderText());
    const t = Tc(() => e.renderText());
    if (t) {
      const [i, n] = t;
      Tc(() => e.prepareRender(i, n)), Tc(() => e.render(i, n));
    }
  }
  _getViewPartsToRender() {
    const e = [];
    let t = 0;
    for (const i of this._viewParts)
      i.shouldRender() && (e[t++] = i);
    return e;
  }
  _createCoordinatedRendering() {
    return {
      prepareRenderText: () => {
        if (this._shouldRecomputeGlyphMarginLanes) {
          this._shouldRecomputeGlyphMarginLanes = !1;
          const e = this._computeGlyphMarginLanes();
          this._context.configuration.setGlyphMarginDecorationLaneCount(e.requiredLanes);
        }
        Nc.onRenderStart();
      },
      renderText: () => {
        if (!this.domNode.domNode.isConnected)
          return null;
        let e = this._getViewPartsToRender();
        if (!this._viewLines.shouldRender() && e.length === 0)
          return null;
        const t = this._context.viewLayout.getLinesViewportData();
        this._context.viewModel.setViewport(t.startLineNumber, t.endLineNumber, t.centeredLineNumber);
        const i = new joe(this._selections, t, this._context.viewLayout.getWhitespaceViewportData(), this._context.viewModel);
        return this._contentWidgets.shouldRender() && this._contentWidgets.onBeforeRender(i), this._viewLines.shouldRender() && (this._viewLines.renderText(i), this._viewLines.onDidRender(), e = this._getViewPartsToRender()), [e, new rse(this._context.viewLayout, i, this._viewLines)];
      },
      prepareRender: (e, t) => {
        for (const i of e)
          i.prepareRender(t);
      },
      render: (e, t) => {
        for (const i of e)
          i.render(t), i.onDidRender();
      }
    };
  }
  // --- BEGIN CodeEditor helpers
  delegateVerticalScrollbarPointerDown(e) {
    this._scrollbar.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    this._scrollbar.delegateScrollFromMouseWheelEvent(e);
  }
  restoreState(e) {
    this._context.viewModel.viewLayout.setScrollPosition(
      {
        scrollTop: e.scrollTop,
        scrollLeft: e.scrollLeft
      },
      1
      /* ScrollType.Immediate */
    ), this._context.viewModel.visibleLinesStabilized();
  }
  getOffsetForColumn(e, t) {
    const i = this._context.viewModel.model.validatePosition({
      lineNumber: e,
      column: t
    }), n = this._context.viewModel.coordinatesConverter.convertModelPositionToViewPosition(i);
    this._flushAccumulatedAndRenderNow();
    const o = this._viewLines.visibleRangeForPosition(new F(n.lineNumber, n.column));
    return o ? o.left : -1;
  }
  getTargetAtClientPoint(e, t) {
    const i = this._pointerHandler.getTargetAtClientPoint(e, t);
    return i ? xS.convertViewToModelMouseTarget(i, this._context.viewModel.coordinatesConverter) : null;
  }
  createOverviewRuler(e) {
    return new Foe(this._context, e);
  }
  change(e) {
    this._viewZones.changeViewZones(e), this._scheduleRender();
  }
  render(e, t) {
    if (t) {
      this._viewLines.forceShouldRender();
      for (const i of this._viewParts)
        i.forceShouldRender();
    }
    e ? this._flushAccumulatedAndRenderNow() : this._scheduleRender();
  }
  writeScreenReaderContent(e) {
    this._textAreaHandler.writeScreenReaderContent(e);
  }
  focus() {
    this._textAreaHandler.focusTextArea();
  }
  isFocused() {
    return this._textAreaHandler.isFocused();
  }
  setAriaOptions(e) {
    this._textAreaHandler.setAriaOptions(e);
  }
  addContentWidget(e) {
    this._contentWidgets.addWidget(e.widget), this.layoutContentWidget(e), this._scheduleRender();
  }
  layoutContentWidget(e) {
    this._contentWidgets.setWidgetPosition(e.widget, e.position?.position ?? null, e.position?.secondaryPosition ?? null, e.position?.preference ?? null, e.position?.positionAffinity ?? null), this._scheduleRender();
  }
  removeContentWidget(e) {
    this._contentWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addOverlayWidget(e) {
    this._overlayWidgets.addWidget(e.widget), this.layoutOverlayWidget(e), this._scheduleRender();
  }
  layoutOverlayWidget(e) {
    this._overlayWidgets.setWidgetPosition(e.widget, e.position) && this._scheduleRender();
  }
  removeOverlayWidget(e) {
    this._overlayWidgets.removeWidget(e.widget), this._scheduleRender();
  }
  addGlyphMarginWidget(e) {
    this._glyphMarginWidgets.addWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
  layoutGlyphMarginWidget(e) {
    const t = e.position;
    this._glyphMarginWidgets.setWidgetPosition(e.widget, t) && (this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender());
  }
  removeGlyphMarginWidget(e) {
    this._glyphMarginWidgets.removeWidget(e.widget), this._shouldRecomputeGlyphMarginLanes = !0, this._scheduleRender();
  }
};
ED = Joe([
  qoe(6, ke)
], ED);
function Tc(s) {
  try {
    return s();
  } catch (e) {
    return Pe(e), null;
  }
}
const $1 = class $1 {
  constructor() {
    this._coordinatedRenderings = [], this._animationFrameRunners = /* @__PURE__ */ new Map();
  }
  scheduleCoordinatedRendering(e) {
    return this._coordinatedRenderings.push(e), this._scheduleRender(e.window), {
      dispose: () => {
        const t = this._coordinatedRenderings.indexOf(e);
        if (t !== -1 && (this._coordinatedRenderings.splice(t, 1), this._coordinatedRenderings.length === 0)) {
          for (const [i, n] of this._animationFrameRunners)
            n.dispose();
          this._animationFrameRunners.clear();
        }
      }
    };
  }
  _scheduleRender(e) {
    if (!this._animationFrameRunners.has(e)) {
      const t = () => {
        this._animationFrameRunners.delete(e), this._onRenderScheduled();
      };
      this._animationFrameRunners.set(e, oC(e, t, 100));
    }
  }
  _onRenderScheduled() {
    const e = this._coordinatedRenderings.slice(0);
    this._coordinatedRenderings = [];
    for (const i of e)
      Tc(() => i.prepareRenderText());
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      t[i] = Tc(() => o.renderText());
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      Tc(() => o.prepareRender(a, l));
    }
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i], r = t[i];
      if (!r)
        continue;
      const [a, l] = r;
      Tc(() => o.render(a, l));
    }
  }
};
$1.INSTANCE = new $1();
let LD = $1;
class Zp {
  constructor(e, t, i, n, o) {
    this.injectionOffsets = e, this.injectionOptions = t, this.breakOffsets = i, this.breakOffsetsVisibleColumn = n, this.wrappedTextIndentLength = o;
  }
  getOutputLineCount() {
    return this.breakOffsets.length;
  }
  getMinOutputOffset(e) {
    return e > 0 ? this.wrappedTextIndentLength : 0;
  }
  getLineLength(e) {
    const t = e > 0 ? this.breakOffsets[e - 1] : 0;
    let n = this.breakOffsets[e] - t;
    return e > 0 && (n += this.wrappedTextIndentLength), n;
  }
  getMaxOutputOffset(e) {
    return this.getLineLength(e);
  }
  translateToInputOffset(e, t) {
    e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength));
    let n = e === 0 ? t : this.breakOffsets[e - 1] + t;
    if (this.injectionOffsets !== null)
      for (let o = 0; o < this.injectionOffsets.length && n > this.injectionOffsets[o]; o++)
        n < this.injectionOffsets[o] + this.injectionOptions[o].content.length ? n = this.injectionOffsets[o] : n -= this.injectionOptions[o].content.length;
    return n;
  }
  translateToOutputPosition(e, t = 2) {
    let i = e;
    if (this.injectionOffsets !== null)
      for (let n = 0; n < this.injectionOffsets.length && !(e < this.injectionOffsets[n] || t !== 1 && e === this.injectionOffsets[n]); n++)
        i += this.injectionOptions[n].content.length;
    return this.offsetInInputWithInjectionsToOutputPosition(i, t);
  }
  offsetInInputWithInjectionsToOutputPosition(e, t = 2) {
    let i = 0, n = this.breakOffsets.length - 1, o = 0, r = 0;
    for (; i <= n; ) {
      o = i + (n - i) / 2 | 0;
      const l = this.breakOffsets[o];
      if (r = o > 0 ? this.breakOffsets[o - 1] : 0, t === 0)
        if (e <= r)
          n = o - 1;
        else if (e > l)
          i = o + 1;
        else
          break;
      else if (e < r)
        n = o - 1;
      else if (e >= l)
        i = o + 1;
      else
        break;
    }
    let a = e - r;
    return o > 0 && (a += this.wrappedTextIndentLength), new Ub(o, a);
  }
  normalizeOutputPosition(e, t, i) {
    if (this.injectionOffsets !== null) {
      const n = this.outputPositionToOffsetInInputWithInjections(e, t), o = this.normalizeOffsetInInputWithInjectionsAroundInjections(n, i);
      if (o !== n)
        return this.offsetInInputWithInjectionsToOutputPosition(o, i);
    }
    if (i === 0) {
      if (e > 0 && t === this.getMinOutputOffset(e))
        return new Ub(e - 1, this.getMaxOutputOffset(e - 1));
    } else if (i === 1) {
      const n = this.getOutputLineCount() - 1;
      if (e < n && t === this.getMaxOutputOffset(e))
        return new Ub(e + 1, this.getMinOutputOffset(e + 1));
    }
    return new Ub(e, t);
  }
  outputPositionToOffsetInInputWithInjections(e, t) {
    return e > 0 && (t = Math.max(0, t - this.wrappedTextIndentLength)), (e > 0 ? this.breakOffsets[e - 1] : 0) + t;
  }
  normalizeOffsetInInputWithInjectionsAroundInjections(e, t) {
    const i = this.getInjectedTextAtOffset(e);
    if (!i)
      return e;
    if (t === 2) {
      if (e === i.offsetInInputWithInjections + i.length && GO(this.injectionOptions[i.injectedTextIndex].cursorStops))
        return i.offsetInInputWithInjections + i.length;
      {
        let n = i.offsetInInputWithInjections;
        if (jO(this.injectionOptions[i.injectedTextIndex].cursorStops))
          return n;
        let o = i.injectedTextIndex - 1;
        for (; o >= 0 && this.injectionOffsets[o] === this.injectionOffsets[i.injectedTextIndex] && !(GO(this.injectionOptions[o].cursorStops) || (n -= this.injectionOptions[o].content.length, jO(this.injectionOptions[o].cursorStops))); )
          o--;
        return n;
      }
    } else if (t === 1 || t === 4) {
      let n = i.offsetInInputWithInjections + i.length, o = i.injectedTextIndex;
      for (; o + 1 < this.injectionOffsets.length && this.injectionOffsets[o + 1] === this.injectionOffsets[o]; )
        n += this.injectionOptions[o + 1].content.length, o++;
      return n;
    } else if (t === 0 || t === 3) {
      let n = i.offsetInInputWithInjections, o = i.injectedTextIndex;
      for (; o - 1 >= 0 && this.injectionOffsets[o - 1] === this.injectionOffsets[o]; )
        n -= this.injectionOptions[o - 1].content.length, o--;
      return n;
    }
    eN();
  }
  getInjectedText(e, t) {
    const i = this.outputPositionToOffsetInInputWithInjections(e, t), n = this.getInjectedTextAtOffset(i);
    return n ? {
      options: this.injectionOptions[n.injectedTextIndex]
    } : null;
  }
  getInjectedTextAtOffset(e) {
    const t = this.injectionOffsets, i = this.injectionOptions;
    if (t !== null) {
      let n = 0;
      for (let o = 0; o < t.length; o++) {
        const r = i[o].content.length, a = t[o] + n, l = t[o] + n + r;
        if (a > e)
          break;
        if (e <= l)
          return {
            injectedTextIndex: o,
            offsetInInputWithInjections: a,
            length: r
          };
        n += r;
      }
    }
  }
}
function GO(s) {
  return s == null ? !0 : s === Aa.Right || s === Aa.Both;
}
function jO(s) {
  return s == null ? !0 : s === Aa.Left || s === Aa.Both;
}
class Ub {
  constructor(e, t) {
    this.outputLineIndex = e, this.outputOffset = t;
  }
  toString() {
    return `${this.outputLineIndex}:${this.outputOffset}`;
  }
  toPosition(e) {
    return new F(e + this.outputLineIndex, this.outputOffset + 1);
  }
}
const $oe = Hu("domLineBreaksComputer", { createHTML: (s) => s });
class HT {
  static create(e) {
    return new HT(new WeakRef(e));
  }
  constructor(e) {
    this.targetWindow = e;
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [];
    return {
      addRequest: (l, c, d) => {
        r.push(l), a.push(c);
      },
      finalize: () => Xoe(xc(this.targetWindow.deref()), r, e, t, i, n, o, a)
    };
  }
}
function Xoe(s, e, t, i, n, o, r, a) {
  function l(I) {
    const Q = a[I];
    if (Q) {
      const P = Rr.applyInjectedText(e[I], Q), W = Q.map((H) => H.options), j = Q.map((H) => H.column - 1);
      return new Zp(j, W, [P.length], [], 0);
    } else
      return null;
  }
  if (n === -1) {
    const I = [];
    for (let Q = 0, P = e.length; Q < P; Q++)
      I[Q] = l(Q);
    return I;
  }
  const c = Math.round(n * t.typicalHalfwidthCharacterWidth), h = Math.round(i * (o === 3 ? 2 : o === 2 ? 1 : 0)), u = Math.ceil(t.spaceWidth * h), g = document.createElement("div");
  cn(g, t);
  const m = new R0(1e4), p = [], A = [], _ = [], b = [], C = [];
  for (let I = 0; I < e.length; I++) {
    const Q = Rr.applyInjectedText(e[I], a[I]);
    let P = 0, W = 0, j = c;
    if (o !== 0)
      if (P = Sn(Q), P === -1)
        P = 0;
      else {
        for (let ce = 0; ce < P; ce++) {
          const he = Q.charCodeAt(ce) === 9 ? i - W % i : 1;
          W += he;
        }
        const se = Math.ceil(t.spaceWidth * W);
        se + t.typicalFullwidthCharacterWidth > c ? (P = 0, W = 0) : j = c - se;
      }
    const H = Q.substr(P), J = Zoe(H, W, i, j, m, u);
    p[I] = P, A[I] = W, _[I] = H, b[I] = J[0], C[I] = J[1];
  }
  const w = m.build(), S = $oe?.createHTML(w) ?? w;
  g.innerHTML = S, g.style.position = "absolute", g.style.top = "10000", r === "keepAll" ? (g.style.wordBreak = "keep-all", g.style.overflowWrap = "anywhere") : (g.style.wordBreak = "inherit", g.style.overflowWrap = "break-word"), s.document.body.appendChild(g);
  const x = document.createRange(), y = Array.prototype.slice.call(g.children, 0), D = [];
  for (let I = 0; I < e.length; I++) {
    const Q = y[I], P = ere(x, Q, _[I], b[I]);
    if (P === null) {
      D[I] = l(I);
      continue;
    }
    const W = p[I], j = A[I] + h, H = C[I], J = [];
    for (let ae = 0, be = P.length; ae < be; ae++)
      J[ae] = H[P[ae]];
    if (W !== 0)
      for (let ae = 0, be = P.length; ae < be; ae++)
        P[ae] += W;
    let se, ce;
    const he = a[I];
    he ? (se = he.map((ae) => ae.options), ce = he.map((ae) => ae.column - 1)) : (se = null, ce = null), D[I] = new Zp(ce, se, P, J, j);
  }
  return g.remove(), D;
}
function Zoe(s, e, t, i, n, o) {
  if (o !== 0) {
    const u = String(o);
    n.appendString('<div style="text-indent: -'), n.appendString(u), n.appendString("px; padding-left: "), n.appendString(u), n.appendString("px; box-sizing: border-box; width:");
  } else
    n.appendString('<div style="width:');
  n.appendString(String(i)), n.appendString('px;">');
  const r = s.length;
  let a = e, l = 0;
  const c = [], d = [];
  let h = 0 < r ? s.charCodeAt(0) : 0;
  n.appendString("<span>");
  for (let u = 0; u < r; u++) {
    u !== 0 && u % 16384 === 0 && n.appendString("</span><span>"), c[u] = l, d[u] = a;
    const g = h;
    h = u + 1 < r ? s.charCodeAt(u + 1) : 0;
    let m = 1, p = 1;
    switch (g) {
      case 9:
        m = t - a % t, p = m;
        for (let A = 1; A <= m; A++)
          A < m ? n.appendCharCode(160) : n.appendASCIICharCode(
            32
            /* CharCode.Space */
          );
        break;
      case 32:
        h === 32 ? n.appendCharCode(160) : n.appendASCIICharCode(
          32
          /* CharCode.Space */
        );
        break;
      case 60:
        n.appendString("&lt;");
        break;
      case 62:
        n.appendString("&gt;");
        break;
      case 38:
        n.appendString("&amp;");
        break;
      case 0:
        n.appendString("&#00;");
        break;
      case 65279:
      case 8232:
      case 8233:
      case 133:
        n.appendCharCode(65533);
        break;
      default:
        sd(g) && p++, g < 32 ? n.appendCharCode(9216 + g) : n.appendCharCode(g);
    }
    l += m, a += p;
  }
  return n.appendString("</span>"), c[s.length] = l, d[s.length] = a, n.appendString("</div>"), [c, d];
}
function ere(s, e, t, i) {
  if (t.length <= 1)
    return null;
  const n = Array.prototype.slice.call(e.children, 0), o = [];
  try {
    kD(s, n, i, 0, null, t.length - 1, null, o);
  } catch (r) {
    return console.log(r), null;
  }
  return o.length === 0 ? null : (o.push(t.length), o);
}
function kD(s, e, t, i, n, o, r, a) {
  if (i === o || (n = n || sx(s, e, t[i], t[i + 1]), r = r || sx(s, e, t[o], t[o + 1]), Math.abs(n[0].top - r[0].top) <= 0.1))
    return;
  if (i + 1 === o) {
    a.push(o);
    return;
  }
  const l = i + (o - i) / 2 | 0, c = sx(s, e, t[l], t[l + 1]);
  kD(s, e, t, i, n, l, c, a), kD(s, e, t, l, c, o, r, a);
}
function sx(s, e, t, i) {
  return s.setStart(
    e[t / 16384 | 0].firstChild,
    t % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.setEnd(
    e[i / 16384 | 0].firstChild,
    i % 16384
    /* Constants.SPAN_MODULO_LIMIT */
  ), s.getClientRects();
}
class tre extends V {
  constructor() {
    super(), this._editor = null, this._instantiationService = null, this._instances = this._register(new IM()), this._pending = /* @__PURE__ */ new Map(), this._finishedInstantiation = [], this._finishedInstantiation[
      0
      /* EditorContributionInstantiation.Eager */
    ] = !1, this._finishedInstantiation[
      1
      /* EditorContributionInstantiation.AfterFirstRender */
    ] = !1, this._finishedInstantiation[
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    ] = !1, this._finishedInstantiation[
      3
      /* EditorContributionInstantiation.Eventually */
    ] = !1;
  }
  initialize(e, t, i) {
    this._editor = e, this._instantiationService = i;
    for (const n of t) {
      if (this._pending.has(n.id)) {
        Pe(new Error(`Cannot have two contributions with the same id ${n.id}`));
        continue;
      }
      this._pending.set(n.id, n);
    }
    this._instantiateSome(
      0
      /* EditorContributionInstantiation.Eager */
    ), this._register(ub(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    })), this._register(ub(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        2
        /* EditorContributionInstantiation.BeforeFirstInteraction */
      );
    })), this._register(ub(fe(this._editor.getDomNode()), () => {
      this._instantiateSome(
        3
        /* EditorContributionInstantiation.Eventually */
      );
    }, 5e3));
  }
  saveViewState() {
    const e = {};
    for (const [t, i] of this._instances)
      typeof i.saveViewState == "function" && (e[t] = i.saveViewState());
    return e;
  }
  restoreViewState(e) {
    for (const [t, i] of this._instances)
      typeof i.restoreViewState == "function" && i.restoreViewState(e[t]);
  }
  get(e) {
    return this._instantiateById(e), this._instances.get(e) || null;
  }
  onBeforeInteractionEvent() {
    this._instantiateSome(
      2
      /* EditorContributionInstantiation.BeforeFirstInteraction */
    );
  }
  onAfterModelAttached() {
    return ub(fe(this._editor?.getDomNode()), () => {
      this._instantiateSome(
        1
        /* EditorContributionInstantiation.AfterFirstRender */
      );
    }, 50);
  }
  _instantiateSome(e) {
    if (this._finishedInstantiation[e])
      return;
    this._finishedInstantiation[e] = !0;
    const t = this._findPendingContributionsByInstantiation(e);
    for (const i of t)
      this._instantiateById(i.id);
  }
  _findPendingContributionsByInstantiation(e) {
    const t = [];
    for (const [, i] of this._pending)
      i.instantiation === e && t.push(i);
    return t;
  }
  _instantiateById(e) {
    const t = this._pending.get(e);
    if (t) {
      if (this._pending.delete(e), !this._instantiationService || !this._editor)
        throw new Error("Cannot instantiate contributions before being initialized!");
      try {
        const i = this._instantiationService.createInstance(t.ctor, this._editor);
        this._instances.set(t.id, i), typeof i.restoreViewState == "function" && t.instantiation !== 0 && console.warn(`Editor contribution '${t.id}' should be eager instantiated because it uses saveViewState / restoreViewState.`);
      } catch (i) {
        Pe(i);
      }
    }
  }
}
class W8 {
  constructor(e, t, i, n, o, r, a) {
    this.id = e, this.label = t, this.alias = i, this.metadata = n, this._precondition = o, this._run = r, this._contextKeyService = a;
  }
  isSupported() {
    return this._contextKeyService.contextMatchesRules(this._precondition);
  }
  run(e) {
    return this.isSupported() ? this._run(e) : Promise.resolve(void 0);
  }
}
class WT {
  static create(e) {
    return new WT(e.get(
      135
      /* EditorOption.wordWrapBreakBeforeCharacters */
    ), e.get(
      134
      /* EditorOption.wordWrapBreakAfterCharacters */
    ));
  }
  constructor(e, t) {
    this.classifier = new ire(e, t);
  }
  createLineBreaksComputer(e, t, i, n, o) {
    const r = [], a = [], l = [];
    return {
      addRequest: (c, d, h) => {
        r.push(c), a.push(d), l.push(h);
      },
      finalize: () => {
        const c = e.typicalFullwidthCharacterWidth / e.typicalHalfwidthCharacterWidth, d = [];
        for (let h = 0, u = r.length; h < u; h++) {
          const g = a[h], m = l[h];
          m && !m.injectionOptions && !g ? d[h] = nre(this.classifier, m, r[h], t, i, c, n, o) : d[h] = sre(this.classifier, r[h], g, t, i, c, n, o);
        }
        return DD.length = 0, ID.length = 0, d;
      }
    };
  }
}
class ire extends wm {
  constructor(e, t) {
    super(
      0
      /* CharacterClass.NONE */
    );
    for (let i = 0; i < e.length; i++)
      this.set(
        e.charCodeAt(i),
        1
        /* CharacterClass.BREAK_BEFORE */
      );
    for (let i = 0; i < t.length; i++)
      this.set(
        t.charCodeAt(i),
        2
        /* CharacterClass.BREAK_AFTER */
      );
  }
  get(e) {
    return e >= 0 && e < 256 ? this._asciiMap[e] : e >= 12352 && e <= 12543 || e >= 13312 && e <= 19903 || e >= 19968 && e <= 40959 ? 3 : this._map.get(e) || this._defaultValue;
  }
}
let DD = [], ID = [];
function nre(s, e, t, i, n, o, r, a) {
  if (n === -1)
    return null;
  const l = t.length;
  if (l <= 1)
    return null;
  const c = a === "keepAll", d = e.breakOffsets, h = e.breakOffsetsVisibleColumn, u = V8(t, i, n, o, r), g = n - u, m = DD, p = ID;
  let A = 0, _ = 0, b = 0, C = n;
  const w = d.length;
  let S = 0;
  if (S >= 0) {
    let x = Math.abs(h[S] - C);
    for (; S + 1 < w; ) {
      const y = Math.abs(h[S + 1] - C);
      if (y >= x)
        break;
      x = y, S++;
    }
  }
  for (; S < w; ) {
    let x = S < 0 ? 0 : d[S], y = S < 0 ? 0 : h[S];
    _ > x && (x = _, y = b);
    let D = 0, I = 0, Q = 0, P = 0;
    if (y <= C) {
      let j = y, H = x === 0 ? 0 : t.charCodeAt(x - 1), J = x === 0 ? 0 : s.get(H), se = !0;
      for (let ce = x; ce < l; ce++) {
        const he = ce, ae = t.charCodeAt(ce);
        let be, Ce;
        if (Si(ae) ? (ce++, be = 0, Ce = 2) : (be = s.get(ae), Ce = eA(ae, j, i, o)), he > _ && MD(H, J, ae, be, c) && (D = he, I = j), j += Ce, j > C) {
          he > _ ? (Q = he, P = j - Ce) : (Q = ce + 1, P = j), j - I > g && (D = 0), se = !1;
          break;
        }
        H = ae, J = be;
      }
      if (se) {
        A > 0 && (m[A] = d[d.length - 1], p[A] = h[d.length - 1], A++);
        break;
      }
    }
    if (D === 0) {
      let j = y, H = t.charCodeAt(x), J = s.get(H), se = !1;
      for (let ce = x - 1; ce >= _; ce--) {
        const he = ce + 1, ae = t.charCodeAt(ce);
        if (ae === 9) {
          se = !0;
          break;
        }
        let be, Ce;
        if (gu(ae) ? (ce--, be = 0, Ce = 2) : (be = s.get(ae), Ce = sd(ae) ? o : 1), j <= C) {
          if (Q === 0 && (Q = he, P = j), j <= C - g)
            break;
          if (MD(ae, be, H, J, c)) {
            D = he, I = j;
            break;
          }
        }
        j -= Ce, H = ae, J = be;
      }
      if (D !== 0) {
        const ce = g - (P - I);
        if (ce <= i) {
          const he = t.charCodeAt(Q);
          let ae;
          Si(he) ? ae = 2 : ae = eA(he, P, i, o), ce - ae < 0 && (D = 0);
        }
      }
      if (se) {
        S--;
        continue;
      }
    }
    if (D === 0 && (D = Q, I = P), D <= _) {
      const j = t.charCodeAt(_);
      Si(j) ? (D = _ + 2, I = b + 2) : (D = _ + 1, I = b + eA(j, b, i, o));
    }
    for (_ = D, m[A] = D, b = I, p[A] = I, A++, C = I + g; S < 0 || S < w && h[S] < I; )
      S++;
    let W = Math.abs(h[S] - C);
    for (; S + 1 < w; ) {
      const j = Math.abs(h[S + 1] - C);
      if (j >= W)
        break;
      W = j, S++;
    }
  }
  return A === 0 ? null : (m.length = A, p.length = A, DD = e.breakOffsets, ID = e.breakOffsetsVisibleColumn, e.breakOffsets = m, e.breakOffsetsVisibleColumn = p, e.wrappedTextIndentLength = u, e);
}
function sre(s, e, t, i, n, o, r, a) {
  const l = Rr.applyInjectedText(e, t);
  let c, d;
  if (t && t.length > 0 ? (c = t.map((I) => I.options), d = t.map((I) => I.column - 1)) : (c = null, d = null), n === -1)
    return c ? new Zp(d, c, [l.length], [], 0) : null;
  const h = l.length;
  if (h <= 1)
    return c ? new Zp(d, c, [l.length], [], 0) : null;
  const u = a === "keepAll", g = V8(l, i, n, o, r), m = n - g, p = [], A = [];
  let _ = 0, b = 0, C = 0, w = n, S = l.charCodeAt(0), x = s.get(S), y = eA(S, 0, i, o), D = 1;
  Si(S) && (y += 1, S = l.charCodeAt(1), x = s.get(S), D++);
  for (let I = D; I < h; I++) {
    const Q = I, P = l.charCodeAt(I);
    let W, j;
    Si(P) ? (I++, W = 0, j = 2) : (W = s.get(P), j = eA(P, y, i, o)), MD(S, x, P, W, u) && (b = Q, C = y), y += j, y > w && ((b === 0 || y - C > m) && (b = Q, C = y - j), p[_] = b, A[_] = C, _++, w = C + m, b = 0), S = P, x = W;
  }
  return _ === 0 && (!t || t.length === 0) ? null : (p[_] = h, A[_] = y, new Zp(d, c, p, A, g));
}
function eA(s, e, t, i) {
  return s === 9 ? t - e % t : sd(s) || s < 32 ? i : 1;
}
function YO(s, e) {
  return e - s % e;
}
function MD(s, e, t, i, n) {
  return t !== 32 && (e === 2 && i !== 2 || e !== 1 && i === 1 || !n && e === 3 && i !== 2 || !n && i === 3 && e !== 1);
}
function V8(s, e, t, i, n) {
  let o = 0;
  if (n !== 0) {
    const r = Sn(s);
    if (r !== -1) {
      for (let l = 0; l < r; l++) {
        const c = s.charCodeAt(l) === 9 ? YO(o, e) : 1;
        o += c;
      }
      const a = n === 3 ? 2 : n === 2 ? 1 : 0;
      for (let l = 0; l < a; l++) {
        const c = YO(o, e);
        o += c;
      }
      o + i > t && (o = 0);
    }
  }
  return o;
}
class Dv {
  constructor(e) {
    this._selTrackedRange = null, this._trackSelection = !0, this._setState(e, new Vi(new E(1, 1, 1, 1), 0, 0, new F(1, 1), 0), new Vi(new E(1, 1, 1, 1), 0, 0, new F(1, 1), 0));
  }
  dispose(e) {
    this._removeTrackedRange(e);
  }
  startTrackingSelection(e) {
    this._trackSelection = !0, this._updateTrackedRange(e);
  }
  stopTrackingSelection(e) {
    this._trackSelection = !1, this._removeTrackedRange(e);
  }
  _updateTrackedRange(e) {
    this._trackSelection && (this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      this.modelState.selection,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    ));
  }
  _removeTrackedRange(e) {
    this._selTrackedRange = e.model._setTrackedRange(
      this._selTrackedRange,
      null,
      0
      /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
    );
  }
  asCursorState() {
    return new Ye(this.modelState, this.viewState);
  }
  readSelectionFromMarkers(e) {
    const t = e.model._getTrackedRange(this._selTrackedRange);
    return this.modelState.selection.isEmpty() && !t.isEmpty() ? Ue.fromRange(t.collapseToEnd(), this.modelState.selection.getDirection()) : Ue.fromRange(t, this.modelState.selection.getDirection());
  }
  ensureValidState(e) {
    this._setState(e, this.modelState, this.viewState);
  }
  setState(e, t, i) {
    this._setState(e, t, i);
  }
  static _validatePositionWithCache(e, t, i, n) {
    return t.equals(i) ? n : e.normalizePosition(
      t,
      2
      /* PositionAffinity.None */
    );
  }
  static _validateViewState(e, t) {
    const i = t.position, n = t.selectionStart.getStartPosition(), o = t.selectionStart.getEndPosition(), r = e.normalizePosition(
      i,
      2
      /* PositionAffinity.None */
    ), a = this._validatePositionWithCache(e, n, i, r), l = this._validatePositionWithCache(e, o, n, a);
    return i.equals(r) && n.equals(a) && o.equals(l) ? t : new Vi(E.fromPositions(a, l), t.selectionStartKind, t.selectionStartLeftoverVisibleColumns + n.column - a.column, r, t.leftoverVisibleColumns + i.column - r.column);
  }
  _setState(e, t, i) {
    if (i && (i = Dv._validateViewState(e.viewModel, i)), t) {
      const n = e.model.validateRange(t.selectionStart), o = t.selectionStart.equalsRange(n) ? t.selectionStartLeftoverVisibleColumns : 0, r = e.model.validatePosition(t.position), a = t.position.equals(r) ? t.leftoverVisibleColumns : 0;
      t = new Vi(n, t.selectionStartKind, o, r, a);
    } else {
      if (!i)
        return;
      const n = e.model.validateRange(e.coordinatesConverter.convertViewRangeToModelRange(i.selectionStart)), o = e.model.validatePosition(e.coordinatesConverter.convertViewPositionToModelPosition(i.position));
      t = new Vi(n, i.selectionStartKind, i.selectionStartLeftoverVisibleColumns, o, i.leftoverVisibleColumns);
    }
    if (i) {
      const n = e.coordinatesConverter.validateViewRange(i.selectionStart, t.selectionStart), o = e.coordinatesConverter.validateViewPosition(i.position, t.position);
      i = new Vi(n, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, o, t.leftoverVisibleColumns);
    } else {
      const n = e.coordinatesConverter.convertModelPositionToViewPosition(new F(t.selectionStart.startLineNumber, t.selectionStart.startColumn)), o = e.coordinatesConverter.convertModelPositionToViewPosition(new F(t.selectionStart.endLineNumber, t.selectionStart.endColumn)), r = new E(n.lineNumber, n.column, o.lineNumber, o.column), a = e.coordinatesConverter.convertModelPositionToViewPosition(t.position);
      i = new Vi(r, t.selectionStartKind, t.selectionStartLeftoverVisibleColumns, a, t.leftoverVisibleColumns);
    }
    this.modelState = t, this.viewState = i, this._updateTrackedRange(e);
  }
}
class KO {
  constructor(e) {
    this.context = e, this.cursors = [new Dv(e)], this.lastAddedCursorIndex = 0;
  }
  dispose() {
    for (const e of this.cursors)
      e.dispose(this.context);
  }
  startTrackingSelections() {
    for (const e of this.cursors)
      e.startTrackingSelection(this.context);
  }
  stopTrackingSelections() {
    for (const e of this.cursors)
      e.stopTrackingSelection(this.context);
  }
  updateContext(e) {
    this.context = e;
  }
  ensureValidState() {
    for (const e of this.cursors)
      e.ensureValidState(this.context);
  }
  readSelectionFromMarkers() {
    return this.cursors.map((e) => e.readSelectionFromMarkers(this.context));
  }
  getAll() {
    return this.cursors.map((e) => e.asCursorState());
  }
  getViewPositions() {
    return this.cursors.map((e) => e.viewState.position);
  }
  getTopMostViewPosition() {
    return oG(this.cursors, _o((e) => e.viewState.position, F.compare)).viewState.position;
  }
  getBottomMostViewPosition() {
    return sG(this.cursors, _o((e) => e.viewState.position, F.compare)).viewState.position;
  }
  getSelections() {
    return this.cursors.map((e) => e.modelState.selection);
  }
  getViewSelections() {
    return this.cursors.map((e) => e.viewState.selection);
  }
  setSelections(e) {
    this.setStates(Ye.fromModelSelections(e));
  }
  getPrimaryCursor() {
    return this.cursors[0].asCursorState();
  }
  setStates(e) {
    e !== null && (this.cursors[0].setState(this.context, e[0].modelState, e[0].viewState), this._setSecondaryStates(e.slice(1)));
  }
  /**
   * Creates or disposes secondary cursors as necessary to match the number of `secondarySelections`.
   */
  _setSecondaryStates(e) {
    const t = this.cursors.length - 1, i = e.length;
    if (t < i) {
      const n = i - t;
      for (let o = 0; o < n; o++)
        this._addSecondaryCursor();
    } else if (t > i) {
      const n = t - i;
      for (let o = 0; o < n; o++)
        this._removeSecondaryCursor(this.cursors.length - 2);
    }
    for (let n = 0; n < i; n++)
      this.cursors[n + 1].setState(this.context, e[n].modelState, e[n].viewState);
  }
  killSecondaryCursors() {
    this._setSecondaryStates([]);
  }
  _addSecondaryCursor() {
    this.cursors.push(new Dv(this.context)), this.lastAddedCursorIndex = this.cursors.length - 1;
  }
  getLastAddedCursorIndex() {
    return this.cursors.length === 1 || this.lastAddedCursorIndex === 0 ? 0 : this.lastAddedCursorIndex;
  }
  _removeSecondaryCursor(e) {
    this.lastAddedCursorIndex >= e + 1 && this.lastAddedCursorIndex--, this.cursors[e + 1].dispose(this.context), this.cursors.splice(e + 1, 1);
  }
  normalize() {
    if (this.cursors.length === 1)
      return;
    const e = this.cursors.slice(0), t = [];
    for (let i = 0, n = e.length; i < n; i++)
      t.push({
        index: i,
        selection: e[i].modelState.selection
      });
    t.sort(_o((i) => i.selection, E.compareRangesUsingStarts));
    for (let i = 0; i < t.length - 1; i++) {
      const n = t[i], o = t[i + 1], r = n.selection, a = o.selection;
      if (!this.context.cursorConfig.multiCursorMergeOverlapping)
        continue;
      let l;
      if (a.isEmpty() || r.isEmpty() ? l = a.getStartPosition().isBeforeOrEqual(r.getEndPosition()) : l = a.getStartPosition().isBefore(r.getEndPosition()), l) {
        const c = n.index < o.index ? i : i + 1, d = n.index < o.index ? i + 1 : i, h = t[d].index, u = t[c].index, g = t[d].selection, m = t[c].selection;
        if (!g.equalsSelection(m)) {
          const p = g.plusRange(m), A = g.selectionStartLineNumber === g.startLineNumber && g.selectionStartColumn === g.startColumn, _ = m.selectionStartLineNumber === m.startLineNumber && m.selectionStartColumn === m.startColumn;
          let b;
          h === this.lastAddedCursorIndex ? (b = A, this.lastAddedCursorIndex = u) : b = _;
          let C;
          b ? C = new Ue(p.startLineNumber, p.startColumn, p.endLineNumber, p.endColumn) : C = new Ue(p.endLineNumber, p.endColumn, p.startLineNumber, p.startColumn), t[c].selection = C;
          const w = Ye.fromModelSelection(C);
          e[u].setState(this.context, w.modelState, w.viewState);
        }
        for (const p of t)
          p.index > h && p.index--;
        e.splice(h, 1), t.splice(d, 1), this._removeSecondaryCursor(h - 1), i--;
      }
    }
  }
}
class JO {
  constructor(e, t, i, n) {
    this._cursorContextBrand = void 0, this.model = e, this.viewModel = t, this.coordinatesConverter = i, this.cursorConfig = n;
  }
}
class ore {
  constructor() {
    this.type = 0;
  }
}
class rre {
  constructor() {
    this.type = 1;
  }
}
class are {
  constructor(e) {
    this.type = 2, this._source = e;
  }
  hasChanged(e) {
    return this._source.hasChanged(e);
  }
}
class lre {
  constructor(e, t, i) {
    this.selections = e, this.modelSelections = t, this.reason = i, this.type = 3;
  }
}
class Fd {
  constructor(e) {
    this.type = 4, e ? (this.affectsMinimap = e.affectsMinimap, this.affectsOverviewRuler = e.affectsOverviewRuler, this.affectsGlyphMargin = e.affectsGlyphMargin, this.affectsLineNumber = e.affectsLineNumber) : (this.affectsMinimap = !0, this.affectsOverviewRuler = !0, this.affectsGlyphMargin = !0, this.affectsLineNumber = !0);
  }
}
class Qb {
  constructor() {
    this.type = 5;
  }
}
class cre {
  constructor(e) {
    this.type = 6, this.isFocused = e;
  }
}
class dre {
  constructor() {
    this.type = 7;
  }
}
class Gb {
  constructor() {
    this.type = 8;
  }
}
class z8 {
  constructor(e, t) {
    this.fromLineNumber = e, this.count = t, this.type = 9;
  }
}
class ND {
  constructor(e, t) {
    this.type = 10, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class TD {
  constructor(e, t) {
    this.type = 11, this.fromLineNumber = e, this.toLineNumber = t;
  }
}
class tA {
  constructor(e, t, i, n, o, r, a) {
    this.source = e, this.minimalReveal = t, this.range = i, this.selections = n, this.verticalType = o, this.revealHorizontal = r, this.scrollType = a, this.type = 12;
  }
}
class hre {
  constructor(e) {
    this.type = 13, this.scrollWidth = e.scrollWidth, this.scrollLeft = e.scrollLeft, this.scrollHeight = e.scrollHeight, this.scrollTop = e.scrollTop, this.scrollWidthChanged = e.scrollWidthChanged, this.scrollLeftChanged = e.scrollLeftChanged, this.scrollHeightChanged = e.scrollHeightChanged, this.scrollTopChanged = e.scrollTopChanged;
  }
}
class ure {
  constructor(e) {
    this.theme = e, this.type = 14;
  }
}
class gre {
  constructor(e) {
    this.type = 15, this.ranges = e;
  }
}
class fre {
  constructor() {
    this.type = 16;
  }
}
let mre = class {
  constructor() {
    this.type = 17;
  }
};
class pre extends V {
  constructor() {
    super(), this._onEvent = this._register(new B()), this.onEvent = this._onEvent.event, this._eventHandlers = [], this._viewEventQueue = null, this._isConsumingViewEventQueue = !1, this._collector = null, this._collectorCnt = 0, this._outgoingEvents = [];
  }
  emitOutgoingEvent(e) {
    this._addOutgoingEvent(e), this._emitOutgoingEvents();
  }
  _addOutgoingEvent(e) {
    for (let t = 0, i = this._outgoingEvents.length; t < i; t++) {
      const n = this._outgoingEvents[t].kind === e.kind ? this._outgoingEvents[t].attemptToMerge(e) : null;
      if (n) {
        this._outgoingEvents[t] = n;
        return;
      }
    }
    this._outgoingEvents.push(e);
  }
  _emitOutgoingEvents() {
    for (; this._outgoingEvents.length > 0; ) {
      if (this._collector || this._isConsumingViewEventQueue)
        return;
      const e = this._outgoingEvents.shift();
      e.isNoOp() || this._onEvent.fire(e);
    }
  }
  addViewEventHandler(e) {
    for (let t = 0, i = this._eventHandlers.length; t < i; t++)
      this._eventHandlers[t] === e && console.warn("Detected duplicate listener in ViewEventDispatcher", e);
    this._eventHandlers.push(e);
  }
  removeViewEventHandler(e) {
    for (let t = 0; t < this._eventHandlers.length; t++)
      if (this._eventHandlers[t] === e) {
        this._eventHandlers.splice(t, 1);
        break;
      }
  }
  beginEmitViewEvents() {
    return this._collectorCnt++, this._collectorCnt === 1 && (this._collector = new Are()), this._collector;
  }
  endEmitViewEvents() {
    if (this._collectorCnt--, this._collectorCnt === 0) {
      const e = this._collector.outgoingEvents, t = this._collector.viewEvents;
      this._collector = null;
      for (const i of e)
        this._addOutgoingEvent(i);
      t.length > 0 && this._emitMany(t);
    }
    this._emitOutgoingEvents();
  }
  emitSingleViewEvent(e) {
    try {
      this.beginEmitViewEvents().emitViewEvent(e);
    } finally {
      this.endEmitViewEvents();
    }
  }
  _emitMany(e) {
    this._viewEventQueue ? this._viewEventQueue = this._viewEventQueue.concat(e) : this._viewEventQueue = e, this._isConsumingViewEventQueue || this._consumeViewEventQueue();
  }
  _consumeViewEventQueue() {
    try {
      this._isConsumingViewEventQueue = !0, this._doConsumeQueue();
    } finally {
      this._isConsumingViewEventQueue = !1;
    }
  }
  _doConsumeQueue() {
    for (; this._viewEventQueue; ) {
      const e = this._viewEventQueue;
      this._viewEventQueue = null;
      const t = this._eventHandlers.slice(0);
      for (const i of t)
        i.handleEvents(e);
    }
  }
}
class Are {
  constructor() {
    this.viewEvents = [], this.outgoingEvents = [];
  }
  emitViewEvent(e) {
    this.viewEvents.push(e);
  }
  emitOutgoingEvent(e) {
    this.outgoingEvents.push(e);
  }
}
class VT {
  constructor(e, t, i, n) {
    this.kind = 0, this._oldContentWidth = e, this._oldContentHeight = t, this.contentWidth = i, this.contentHeight = n, this.contentWidthChanged = this._oldContentWidth !== this.contentWidth, this.contentHeightChanged = this._oldContentHeight !== this.contentHeight;
  }
  isNoOp() {
    return !this.contentWidthChanged && !this.contentHeightChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new VT(this._oldContentWidth, this._oldContentHeight, e.contentWidth, e.contentHeight);
  }
}
class zT {
  constructor(e, t) {
    this.kind = 1, this.oldHasFocus = e, this.hasFocus = t;
  }
  isNoOp() {
    return this.oldHasFocus === this.hasFocus;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new zT(this.oldHasFocus, e.hasFocus);
  }
}
class UT {
  constructor(e, t, i, n, o, r, a, l) {
    this.kind = 2, this._oldScrollWidth = e, this._oldScrollLeft = t, this._oldScrollHeight = i, this._oldScrollTop = n, this.scrollWidth = o, this.scrollLeft = r, this.scrollHeight = a, this.scrollTop = l, this.scrollWidthChanged = this._oldScrollWidth !== this.scrollWidth, this.scrollLeftChanged = this._oldScrollLeft !== this.scrollLeft, this.scrollHeightChanged = this._oldScrollHeight !== this.scrollHeight, this.scrollTopChanged = this._oldScrollTop !== this.scrollTop;
  }
  isNoOp() {
    return !this.scrollWidthChanged && !this.scrollLeftChanged && !this.scrollHeightChanged && !this.scrollTopChanged;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new UT(this._oldScrollWidth, this._oldScrollLeft, this._oldScrollHeight, this._oldScrollTop, e.scrollWidth, e.scrollLeft, e.scrollHeight, e.scrollTop);
  }
}
class _re {
  constructor() {
    this.kind = 3;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class bre {
  constructor() {
    this.kind = 4;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class Iv {
  constructor(e, t, i, n, o, r, a) {
    this.kind = 6, this.oldSelections = e, this.selections = t, this.oldModelVersionId = i, this.modelVersionId = n, this.source = o, this.reason = r, this.reachedMaxCursorCount = a;
  }
  static _selectionsAreEqual(e, t) {
    if (!e && !t)
      return !0;
    if (!e || !t)
      return !1;
    const i = e.length, n = t.length;
    if (i !== n)
      return !1;
    for (let o = 0; o < i; o++)
      if (!e[o].equalsSelection(t[o]))
        return !1;
    return !0;
  }
  isNoOp() {
    return Iv._selectionsAreEqual(this.oldSelections, this.selections) && this.oldModelVersionId === this.modelVersionId;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : new Iv(this.oldSelections, e.selections, this.oldModelVersionId, e.modelVersionId, e.source, e.reason, this.reachedMaxCursorCount || e.reachedMaxCursorCount);
  }
}
class wre {
  constructor() {
    this.kind = 5;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return e.kind !== this.kind ? null : this;
  }
}
class Cre {
  constructor(e) {
    this.event = e, this.kind = 7;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class vre {
  constructor(e) {
    this.event = e, this.kind = 8;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class Sre {
  constructor(e) {
    this.event = e, this.kind = 9;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class yre {
  constructor(e) {
    this.event = e, this.kind = 10;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class xre {
  constructor(e) {
    this.event = e, this.kind = 11;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class Ere {
  constructor(e) {
    this.event = e, this.kind = 12;
  }
  isNoOp() {
    return !1;
  }
  attemptToMerge(e) {
    return null;
  }
}
class Lre extends V {
  constructor(e, t, i, n) {
    super(), this._model = e, this._knownModelVersionId = this._model.getVersionId(), this._viewModel = t, this._coordinatesConverter = i, this.context = new JO(this._model, this._viewModel, this._coordinatesConverter, n), this._cursors = new KO(this.context), this._hasFocus = !1, this._isHandling = !1, this._compositionState = null, this._columnSelectData = null, this._autoClosedActions = [], this._prevEditOperationType = 0;
  }
  dispose() {
    this._cursors.dispose(), this._autoClosedActions = Ct(this._autoClosedActions), super.dispose();
  }
  updateConfiguration(e) {
    this.context = new JO(this._model, this._viewModel, this._coordinatesConverter, e), this._cursors.updateContext(this.context);
  }
  onLineMappingChanged(e) {
    this._knownModelVersionId === this._model.getVersionId() && this.setStates(e, "viewModel", 0, this.getCursorStates());
  }
  setHasFocus(e) {
    this._hasFocus = e;
  }
  _validateAutoClosedActions() {
    if (this._autoClosedActions.length > 0) {
      const e = this._cursors.getSelections();
      for (let t = 0; t < this._autoClosedActions.length; t++) {
        const i = this._autoClosedActions[t];
        i.isValid(e) || (i.dispose(), this._autoClosedActions.splice(t, 1), t--);
      }
    }
  }
  // ------ some getters/setters
  getPrimaryCursorState() {
    return this._cursors.getPrimaryCursor();
  }
  getLastAddedCursorIndex() {
    return this._cursors.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursors.getAll();
  }
  setStates(e, t, i, n) {
    let o = !1;
    const r = this.context.cursorConfig.multiCursorLimit;
    n !== null && n.length > r && (n = n.slice(0, r), o = !0);
    const a = iA.from(this._model, this);
    return this._cursors.setStates(n), this._cursors.normalize(), this._columnSelectData = null, this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, t, i, a, o);
  }
  setCursorColumnSelectData(e) {
    this._columnSelectData = e;
  }
  revealAll(e, t, i, n, o, r) {
    const a = this._cursors.getViewPositions();
    let l = null, c = null;
    a.length > 1 ? c = this._cursors.getViewSelections() : l = E.fromPositions(a[0], a[0]), e.emitViewEvent(new tA(t, i, l, c, n, o, r));
  }
  revealPrimary(e, t, i, n, o, r) {
    const l = [this._cursors.getPrimaryCursor().viewState.selection];
    e.emitViewEvent(new tA(t, i, null, l, n, o, r));
  }
  saveState() {
    const e = [], t = this._cursors.getSelections();
    for (let i = 0, n = t.length; i < n; i++) {
      const o = t[i];
      e.push({
        inSelectionMode: !o.isEmpty(),
        selectionStart: {
          lineNumber: o.selectionStartLineNumber,
          column: o.selectionStartColumn
        },
        position: {
          lineNumber: o.positionLineNumber,
          column: o.positionColumn
        }
      });
    }
    return e;
  }
  restoreState(e, t) {
    const i = [];
    for (let n = 0, o = t.length; n < o; n++) {
      const r = t[n];
      let a = 1, l = 1;
      r.position && r.position.lineNumber && (a = r.position.lineNumber), r.position && r.position.column && (l = r.position.column);
      let c = a, d = l;
      r.selectionStart && r.selectionStart.lineNumber && (c = r.selectionStart.lineNumber), r.selectionStart && r.selectionStart.column && (d = r.selectionStart.column), i.push({
        selectionStartLineNumber: c,
        selectionStartColumn: d,
        positionLineNumber: a,
        positionColumn: l
      });
    }
    this.setStates(e, "restoreState", 0, Ye.fromModelSelections(i)), this.revealAll(
      e,
      "restoreState",
      !1,
      0,
      !0,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  onModelContentChanged(e, t) {
    if (t instanceof yW) {
      if (this._isHandling)
        return;
      this._isHandling = !0;
      try {
        this.setStates(e, "modelChange", 0, this.getCursorStates());
      } finally {
        this._isHandling = !1;
      }
    } else {
      const i = t.rawContentChangedEvent;
      if (this._knownModelVersionId = i.versionId, this._isHandling)
        return;
      const n = i.containsEvent(
        1
        /* RawContentChangedType.Flush */
      );
      if (this._prevEditOperationType = 0, n)
        this._cursors.dispose(), this._cursors = new KO(this.context), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(e, "model", 1, null, !1);
      else if (this._hasFocus && i.resultingSelection && i.resultingSelection.length > 0) {
        const o = Ye.fromModelSelections(i.resultingSelection);
        this.setStates(e, "modelChange", i.isUndoing ? 5 : i.isRedoing ? 6 : 2, o) && this.revealAll(
          e,
          "modelChange",
          !1,
          0,
          !0,
          0
          /* editorCommon.ScrollType.Smooth */
        );
      } else {
        const o = this._cursors.readSelectionFromMarkers();
        this.setStates(e, "modelChange", 2, Ye.fromModelSelections(o));
      }
    }
  }
  getSelection() {
    return this._cursors.getPrimaryCursor().modelState.selection;
  }
  getTopMostViewPosition() {
    return this._cursors.getTopMostViewPosition();
  }
  getBottomMostViewPosition() {
    return this._cursors.getBottomMostViewPosition();
  }
  getCursorColumnSelectData() {
    if (this._columnSelectData)
      return this._columnSelectData;
    const e = this._cursors.getPrimaryCursor(), t = e.viewState.selectionStart.getStartPosition(), i = e.viewState.position;
    return {
      isReal: !1,
      fromViewLineNumber: t.lineNumber,
      fromViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, t),
      toViewLineNumber: i.lineNumber,
      toViewVisualColumn: this.context.cursorConfig.visibleColumnFromColumn(this._viewModel, i)
    };
  }
  getSelections() {
    return this._cursors.getSelections();
  }
  setSelections(e, t, i, n) {
    this.setStates(e, t, n, Ye.fromModelSelections(i));
  }
  getPrevEditOperationType() {
    return this._prevEditOperationType;
  }
  setPrevEditOperationType(e) {
    this._prevEditOperationType = e;
  }
  // ------ auxiliary handling logic
  _pushAutoClosedAction(e, t) {
    const i = [], n = [];
    for (let a = 0, l = e.length; a < l; a++)
      i.push({
        range: e[a],
        options: {
          description: "auto-closed-character",
          inlineClassName: "auto-closed-character",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      }), n.push({
        range: t[a],
        options: {
          description: "auto-closed-enclosing",
          stickiness: 1
          /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
        }
      });
    const o = this._model.deltaDecorations([], i), r = this._model.deltaDecorations([], n);
    this._autoClosedActions.push(new qO(this._model, o, r));
  }
  _executeEditOperation(e) {
    if (!e)
      return;
    e.shouldPushStackElementBefore && this._model.pushStackElement();
    const t = kre.executeCommands(this._model, this._cursors.getSelections(), e.commands);
    if (t) {
      this._interpretCommandResult(t);
      const i = [], n = [];
      for (let o = 0; o < e.commands.length; o++) {
        const r = e.commands[o];
        r instanceof RT && r.enclosingRange && r.closeCharacterRange && (i.push(r.closeCharacterRange), n.push(r.enclosingRange));
      }
      i.length > 0 && this._pushAutoClosedAction(i, n), this._prevEditOperationType = e.type;
    }
    e.shouldPushStackElementAfter && this._model.pushStackElement();
  }
  _interpretCommandResult(e) {
    (!e || e.length === 0) && (e = this._cursors.readSelectionFromMarkers()), this._columnSelectData = null, this._cursors.setSelections(e), this._cursors.normalize();
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- emitting events
  _emitStateChangedIfNecessary(e, t, i, n, o) {
    const r = iA.from(this._model, this);
    if (r.equals(n))
      return !1;
    const a = this._cursors.getSelections(), l = this._cursors.getViewSelections();
    if (e.emitViewEvent(new lre(l, a, i)), !n || n.cursorState.length !== r.cursorState.length || r.cursorState.some((c, d) => !c.modelState.equals(n.cursorState[d].modelState))) {
      const c = n ? n.cursorState.map((h) => h.modelState.selection) : null, d = n ? n.modelVersionId : 0;
      e.emitOutgoingEvent(new Iv(c, a, d, r.modelVersionId, t || "keyboard", i, o));
    }
    return !0;
  }
  // -----------------------------------------------------------------------------------------------------------
  // ----- handlers beyond this point
  _findAutoClosingPairs(e) {
    if (!e.length)
      return null;
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const o = e[i];
      if (!o.text || o.text.indexOf(`
`) >= 0)
        return null;
      const r = o.text.match(/([)\]}>'"`])([^)\]}>'"`]*)$/);
      if (!r)
        return null;
      const a = r[1], l = this.context.cursorConfig.autoClosingPairs.autoClosingPairsCloseSingleChar.get(a);
      if (!l || l.length !== 1)
        return null;
      const c = l[0].open, d = o.text.length - r[2].length - 1, h = o.text.lastIndexOf(c, d - 1);
      if (h === -1)
        return null;
      t.push([h, d]);
    }
    return t;
  }
  executeEdits(e, t, i, n) {
    let o = null;
    t === "snippet" && (o = this._findAutoClosingPairs(i)), o && (i[0]._isTracked = !0);
    const r = [], a = [], l = this._model.pushEditOperations(this.getSelections(), i, (c) => {
      if (o)
        for (let h = 0, u = o.length; h < u; h++) {
          const [g, m] = o[h], p = c[h], A = p.range.startLineNumber, _ = p.range.startColumn - 1 + g, b = p.range.startColumn - 1 + m;
          r.push(new E(A, b + 1, A, b + 2)), a.push(new E(A, _ + 1, A, b + 2));
        }
      const d = n(c);
      return d && (this._isHandling = !0), d;
    });
    l && (this._isHandling = !1, this.setSelections(
      e,
      t,
      l,
      0
      /* CursorChangeReason.NotSet */
    )), r.length > 0 && this._pushAutoClosedAction(r, a);
  }
  _executeEdit(e, t, i, n = 0) {
    if (this.context.cursorConfig.readOnly)
      return;
    const o = iA.from(this._model, this);
    this._cursors.stopTrackingSelections(), this._isHandling = !0;
    try {
      this._cursors.ensureValidState(), e();
    } catch (r) {
      Pe(r);
    }
    this._isHandling = !1, this._cursors.startTrackingSelections(), this._validateAutoClosedActions(), this._emitStateChangedIfNecessary(t, i, n, o, !1) && this.revealAll(
      t,
      i,
      !1,
      0,
      !0,
      0
      /* editorCommon.ScrollType.Smooth */
    );
  }
  getAutoClosedCharacters() {
    return qO.getAllAutoClosedCharacters(this._autoClosedActions);
  }
  startComposition(e) {
    this._compositionState = new nA(this._model, this.getSelections());
  }
  endComposition(e, t) {
    const i = this._compositionState ? this._compositionState.deduceOutcome(this._model, this.getSelections()) : null;
    this._compositionState = null, this._executeEdit(() => {
      t === "keyboard" && this._executeEditOperation(lh.compositionEndWithInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, i, this.getSelections(), this.getAutoClosedCharacters()));
    }, e, t);
  }
  type(e, t, i) {
    this._executeEdit(() => {
      if (i === "keyboard") {
        const n = t.length;
        let o = 0;
        for (; o < n; ) {
          const r = HM(t, o), a = t.substr(o, r);
          this._executeEditOperation(lh.typeWithInterceptors(!!this._compositionState, this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), this.getAutoClosedCharacters(), a)), o += r;
        }
      } else
        this._executeEditOperation(lh.typeWithoutInterceptors(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t));
    }, e, i);
  }
  compositionType(e, t, i, n, o, r) {
    if (t.length === 0 && i === 0 && n === 0) {
      if (o !== 0) {
        const a = this.getSelections().map((l) => {
          const c = l.getPosition();
          return new Ue(c.lineNumber, c.column + o, c.lineNumber, c.column + o);
        });
        this.setSelections(
          e,
          r,
          a,
          0
          /* CursorChangeReason.NotSet */
        );
      }
      return;
    }
    this._executeEdit(() => {
      this._executeEditOperation(lh.compositionType(this._prevEditOperationType, this.context.cursorConfig, this._model, this.getSelections(), t, i, n, o));
    }, e, r);
  }
  paste(e, t, i, n, o) {
    this._executeEdit(
      () => {
        this._executeEditOperation(lh.paste(this.context.cursorConfig, this._model, this.getSelections(), t, i, n || []));
      },
      e,
      o,
      4
      /* CursorChangeReason.Paste */
    );
  }
  cut(e, t) {
    this._executeEdit(() => {
      this._executeEditOperation(Eu.cut(this.context.cursorConfig, this._model, this.getSelections()));
    }, e, t);
  }
  executeCommand(e, t, i) {
    this._executeEdit(() => {
      this._cursors.killSecondaryCursors(), this._executeEditOperation(new is(0, [t], {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
  executeCommands(e, t, i) {
    this._executeEdit(() => {
      this._executeEditOperation(new is(0, t, {
        shouldPushStackElementBefore: !1,
        shouldPushStackElementAfter: !1
      }));
    }, e, i);
  }
}
class iA {
  static from(e, t) {
    return new iA(e.getVersionId(), t.getCursorStates());
  }
  constructor(e, t) {
    this.modelVersionId = e, this.cursorState = t;
  }
  equals(e) {
    if (!e || this.modelVersionId !== e.modelVersionId || this.cursorState.length !== e.cursorState.length)
      return !1;
    for (let t = 0, i = this.cursorState.length; t < i; t++)
      if (!this.cursorState[t].equals(e.cursorState[t]))
        return !1;
    return !0;
  }
}
class qO {
  static getAllAutoClosedCharacters(e) {
    let t = [];
    for (const i of e)
      t = t.concat(i.getAutoClosedCharactersRanges());
    return t;
  }
  constructor(e, t, i) {
    this._model = e, this._autoClosedCharactersDecorations = t, this._autoClosedEnclosingDecorations = i;
  }
  dispose() {
    this._autoClosedCharactersDecorations = this._model.deltaDecorations(this._autoClosedCharactersDecorations, []), this._autoClosedEnclosingDecorations = this._model.deltaDecorations(this._autoClosedEnclosingDecorations, []);
  }
  getAutoClosedCharactersRanges() {
    const e = [];
    for (let t = 0; t < this._autoClosedCharactersDecorations.length; t++) {
      const i = this._model.getDecorationRange(this._autoClosedCharactersDecorations[t]);
      i && e.push(i);
    }
    return e;
  }
  isValid(e) {
    const t = [];
    for (let i = 0; i < this._autoClosedEnclosingDecorations.length; i++) {
      const n = this._model.getDecorationRange(this._autoClosedEnclosingDecorations[i]);
      if (n && (t.push(n), n.startLineNumber !== n.endLineNumber))
        return !1;
    }
    t.sort(E.compareRangesUsingStarts), e.sort(E.compareRangesUsingStarts);
    for (let i = 0; i < e.length; i++)
      if (i >= t.length || !t[i].strictContainsRange(e[i]))
        return !1;
    return !0;
  }
}
class kre {
  static executeCommands(e, t, i) {
    const n = {
      model: e,
      selectionsBefore: t,
      trackedRanges: [],
      trackedRangesDirection: []
    }, o = this._innerExecuteCommands(n, i);
    for (let r = 0, a = n.trackedRanges.length; r < a; r++)
      n.model._setTrackedRange(
        n.trackedRanges[r],
        null,
        0
        /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */
      );
    return o;
  }
  static _innerExecuteCommands(e, t) {
    if (this._arrayIsEmpty(t))
      return null;
    const i = this._getEditOperations(e, t);
    if (i.operations.length === 0)
      return null;
    const n = i.operations, o = this._getLoserCursorMap(n);
    if (o.hasOwnProperty("0"))
      return console.warn("Ignoring commands"), null;
    const r = [];
    for (let c = 0, d = n.length; c < d; c++)
      o.hasOwnProperty(n[c].identifier.major.toString()) || r.push(n[c]);
    i.hadTrackedEditOperation && r.length > 0 && (r[0]._isTracked = !0);
    let a = e.model.pushEditOperations(e.selectionsBefore, r, (c) => {
      const d = [];
      for (let g = 0; g < e.selectionsBefore.length; g++)
        d[g] = [];
      for (const g of c)
        g.identifier && d[g.identifier.major].push(g);
      const h = (g, m) => g.identifier.minor - m.identifier.minor, u = [];
      for (let g = 0; g < e.selectionsBefore.length; g++)
        d[g].length > 0 ? (d[g].sort(h), u[g] = t[g].computeCursorState(e.model, {
          getInverseEditOperations: () => d[g],
          getTrackedSelection: (m) => {
            const p = parseInt(m, 10), A = e.model._getTrackedRange(e.trackedRanges[p]);
            return e.trackedRangesDirection[p] === 0 ? new Ue(A.startLineNumber, A.startColumn, A.endLineNumber, A.endColumn) : new Ue(A.endLineNumber, A.endColumn, A.startLineNumber, A.startColumn);
          }
        })) : u[g] = e.selectionsBefore[g];
      return u;
    });
    a || (a = e.selectionsBefore);
    const l = [];
    for (const c in o)
      o.hasOwnProperty(c) && l.push(parseInt(c, 10));
    l.sort((c, d) => d - c);
    for (const c of l)
      a.splice(c, 1);
    return a;
  }
  static _arrayIsEmpty(e) {
    for (let t = 0, i = e.length; t < i; t++)
      if (e[t])
        return !1;
    return !0;
  }
  static _getEditOperations(e, t) {
    let i = [], n = !1;
    for (let o = 0, r = t.length; o < r; o++) {
      const a = t[o];
      if (a) {
        const l = this._getEditOperationsFromCommand(e, o, a);
        i = i.concat(l.operations), n = n || l.hadTrackedEditOperation;
      }
    }
    return {
      operations: i,
      hadTrackedEditOperation: n
    };
  }
  static _getEditOperationsFromCommand(e, t, i) {
    const n = [];
    let o = 0;
    const r = (h, u, g = !1) => {
      E.isEmpty(h) && u === "" || n.push({
        identifier: {
          major: t,
          minor: o++
        },
        range: h,
        text: u,
        forceMoveMarkers: g,
        isAutoWhitespaceEdit: i.insertsAutoWhitespace
      });
    };
    let a = !1;
    const d = {
      addEditOperation: r,
      addTrackedEditOperation: (h, u, g) => {
        a = !0, r(h, u, g);
      },
      trackSelection: (h, u) => {
        const g = Ue.liftSelection(h);
        let m;
        if (g.isEmpty())
          if (typeof u == "boolean")
            u ? m = 2 : m = 3;
          else {
            const _ = e.model.getLineMaxColumn(g.startLineNumber);
            g.startColumn === _ ? m = 2 : m = 3;
          }
        else
          m = 1;
        const p = e.trackedRanges.length, A = e.model._setTrackedRange(null, g, m);
        return e.trackedRanges[p] = A, e.trackedRangesDirection[p] = g.getDirection(), p.toString();
      }
    };
    try {
      i.getEditOperations(e.model, d);
    } catch (h) {
      return Pe(h), {
        operations: [],
        hadTrackedEditOperation: !1
      };
    }
    return {
      operations: n,
      hadTrackedEditOperation: a
    };
  }
  static _getLoserCursorMap(e) {
    e = e.slice(0), e.sort((i, n) => -E.compareRangesUsingEnds(i.range, n.range));
    const t = {};
    for (let i = 1; i < e.length; i++) {
      const n = e[i - 1], o = e[i];
      if (E.getStartPosition(n.range).isBefore(E.getEndPosition(o.range))) {
        let r;
        n.identifier.major > o.identifier.major ? r = n.identifier.major : r = o.identifier.major, t[r.toString()] = !0;
        for (let a = 0; a < e.length; a++)
          e[a].identifier.major === r && (e.splice(a, 1), a < i && i--, a--);
        i > 0 && i--;
      }
    }
    return t;
  }
}
class Dre {
  constructor(e, t, i) {
    this.text = e, this.startSelection = t, this.endSelection = i;
  }
}
class nA {
  static _capture(e, t) {
    const i = [];
    for (const n of t) {
      if (n.startLineNumber !== n.endLineNumber)
        return null;
      i.push(new Dre(e.getLineContent(n.startLineNumber), n.startColumn - 1, n.endColumn - 1));
    }
    return i;
  }
  constructor(e, t) {
    this._original = nA._capture(e, t);
  }
  /**
   * Returns the inserted text during this composition.
   * If the composition resulted in existing text being changed (i.e. not a pure insertion) it returns null.
   */
  deduceOutcome(e, t) {
    if (!this._original)
      return null;
    const i = nA._capture(e, t);
    if (!i || this._original.length !== i.length)
      return null;
    const n = [];
    for (let o = 0, r = this._original.length; o < r; o++)
      n.push(nA._deduceOutcome(this._original[o], i[o]));
    return n;
  }
  static _deduceOutcome(e, t) {
    const i = Math.min(e.startSelection, t.startSelection, kA(e.text, t.text)), n = Math.min(e.text.length - e.endSelection, t.text.length - t.endSelection, NE(e.text, t.text)), o = e.text.substring(i, e.text.length - n), r = t.text.substring(i, t.text.length - n);
    return new toe(o, e.startSelection - i, e.endSelection - i, r, t.startSelection - i, t.endSelection - i);
  }
}
class Ire {
  constructor() {
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [];
  }
  insert(e) {
    this._hasPending = !0, this._inserts.push(e);
  }
  change(e) {
    this._hasPending = !0, this._changes.push(e);
  }
  remove(e) {
    this._hasPending = !0, this._removes.push(e);
  }
  mustCommit() {
    return this._hasPending;
  }
  commit(e) {
    if (!this._hasPending)
      return;
    const t = this._inserts, i = this._changes, n = this._removes;
    this._hasPending = !1, this._inserts = [], this._changes = [], this._removes = [], e._commitPendingChanges(t, i, n);
  }
}
class Mre {
  constructor(e, t, i, n, o) {
    this.id = e, this.afterLineNumber = t, this.ordinal = i, this.height = n, this.minWidth = o, this.prefixSum = 0;
  }
}
var Qc;
let Nre = (Qc = class {
  constructor(e, t, i, n) {
    this._instanceId = vH(++Qc.INSTANCE_COUNT), this._pendingChanges = new Ire(), this._lastWhitespaceId = 0, this._arr = [], this._prefixSumValidIndex = -1, this._minWidth = -1, this._lineCount = e, this._lineHeight = t, this._paddingTop = i, this._paddingBottom = n;
  }
  /**
   * Find the insertion index for a new value inside a sorted array of values.
   * If the value is already present in the sorted array, the insertion index will be after the already existing value.
   */
  static findInsertionIndex(e, t, i) {
    let n = 0, o = e.length;
    for (; n < o; ) {
      const r = n + o >>> 1;
      t === e[r].afterLineNumber ? i < e[r].ordinal ? o = r : n = r + 1 : t < e[r].afterLineNumber ? o = r : n = r + 1;
    }
    return n;
  }
  /**
   * Change the height of a line in pixels.
   */
  setLineHeight(e) {
    this._checkPendingChanges(), this._lineHeight = e;
  }
  /**
   * Changes the padding used to calculate vertical offsets.
   */
  setPadding(e, t) {
    this._paddingTop = e, this._paddingBottom = t;
  }
  /**
   * Set the number of lines.
   *
   * @param lineCount New number of lines.
   */
  onFlushed(e) {
    this._checkPendingChanges(), this._lineCount = e;
  }
  changeWhitespace(e) {
    let t = !1;
    try {
      e({
        insertWhitespace: (n, o, r, a) => {
          t = !0, n = n | 0, o = o | 0, r = r | 0, a = a | 0;
          const l = this._instanceId + ++this._lastWhitespaceId;
          return this._pendingChanges.insert(new Mre(l, n, o, r, a)), l;
        },
        changeOneWhitespace: (n, o, r) => {
          t = !0, o = o | 0, r = r | 0, this._pendingChanges.change({ id: n, newAfterLineNumber: o, newHeight: r });
        },
        removeWhitespace: (n) => {
          t = !0, this._pendingChanges.remove({ id: n });
        }
      });
    } finally {
      this._pendingChanges.commit(this);
    }
    return t;
  }
  _commitPendingChanges(e, t, i) {
    if ((e.length > 0 || i.length > 0) && (this._minWidth = -1), e.length + t.length + i.length <= 1) {
      for (const l of e)
        this._insertWhitespace(l);
      for (const l of t)
        this._changeOneWhitespace(l.id, l.newAfterLineNumber, l.newHeight);
      for (const l of i) {
        const c = this._findWhitespaceIndex(l.id);
        c !== -1 && this._removeWhitespace(c);
      }
      return;
    }
    const n = /* @__PURE__ */ new Set();
    for (const l of i)
      n.add(l.id);
    const o = /* @__PURE__ */ new Map();
    for (const l of t)
      o.set(l.id, l);
    const r = (l) => {
      const c = [];
      for (const d of l)
        if (!n.has(d.id)) {
          if (o.has(d.id)) {
            const h = o.get(d.id);
            d.afterLineNumber = h.newAfterLineNumber, d.height = h.newHeight;
          }
          c.push(d);
        }
      return c;
    }, a = r(this._arr).concat(r(e));
    a.sort((l, c) => l.afterLineNumber === c.afterLineNumber ? l.ordinal - c.ordinal : l.afterLineNumber - c.afterLineNumber), this._arr = a, this._prefixSumValidIndex = -1;
  }
  _checkPendingChanges() {
    this._pendingChanges.mustCommit() && this._pendingChanges.commit(this);
  }
  _insertWhitespace(e) {
    const t = Qc.findInsertionIndex(this._arr, e.afterLineNumber, e.ordinal);
    this._arr.splice(t, 0, e), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, t - 1);
  }
  _findWhitespaceIndex(e) {
    const t = this._arr;
    for (let i = 0, n = t.length; i < n; i++)
      if (t[i].id === e)
        return i;
    return -1;
  }
  _changeOneWhitespace(e, t, i) {
    const n = this._findWhitespaceIndex(e);
    if (n !== -1 && (this._arr[n].height !== i && (this._arr[n].height = i, this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, n - 1)), this._arr[n].afterLineNumber !== t)) {
      const o = this._arr[n];
      this._removeWhitespace(n), o.afterLineNumber = t, this._insertWhitespace(o);
    }
  }
  _removeWhitespace(e) {
    this._arr.splice(e, 1), this._prefixSumValidIndex = Math.min(this._prefixSumValidIndex, e - 1);
  }
  /**
   * Notify the layouter that lines have been deleted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the deletion started, inclusive
   * @param toLineNumber The line number at which the deletion ended, inclusive
   */
  onLinesDeleted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount -= t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && o <= t ? this._arr[i].afterLineNumber = e - 1 : o > t && (this._arr[i].afterLineNumber -= t - e + 1);
    }
  }
  /**
   * Notify the layouter that lines have been inserted (a continuous zone of lines).
   *
   * @param fromLineNumber The line number at which the insertion started, inclusive
   * @param toLineNumber The line number at which the insertion ended, inclusive.
   */
  onLinesInserted(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0, this._lineCount += t - e + 1;
    for (let i = 0, n = this._arr.length; i < n; i++) {
      const o = this._arr[i].afterLineNumber;
      e <= o && (this._arr[i].afterLineNumber += t - e + 1);
    }
  }
  /**
   * Get the sum of all the whitespaces.
   */
  getWhitespacesTotalHeight() {
    return this._checkPendingChanges(), this._arr.length === 0 ? 0 : this.getWhitespacesAccumulatedHeight(this._arr.length - 1);
  }
  /**
   * Return the sum of the heights of the whitespaces at [0..index].
   * This includes the whitespace at `index`.
   *
   * @param index The index of the whitespace.
   * @return The sum of the heights of all whitespaces before the one at `index`, including the one at `index`.
   */
  getWhitespacesAccumulatedHeight(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = Math.max(0, this._prefixSumValidIndex + 1);
    t === 0 && (this._arr[0].prefixSum = this._arr[0].height, t++);
    for (let i = t; i <= e; i++)
      this._arr[i].prefixSum = this._arr[i - 1].prefixSum + this._arr[i].height;
    return this._prefixSumValidIndex = Math.max(this._prefixSumValidIndex, e), this._arr[e].prefixSum;
  }
  /**
   * Get the sum of heights for all objects.
   *
   * @return The sum of heights for all objects.
   */
  getLinesTotalHeight() {
    this._checkPendingChanges();
    const e = this._lineHeight * this._lineCount, t = this.getWhitespacesTotalHeight();
    return e + t + this._paddingTop + this._paddingBottom;
  }
  /**
   * Returns the accumulated height of whitespaces before the given line number.
   *
   * @param lineNumber The line number
   */
  getWhitespaceAccumulatedHeightBeforeLineNumber(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this._findLastWhitespaceBeforeLineNumber(e);
    return t === -1 ? 0 : this.getWhitespacesAccumulatedHeight(t);
  }
  _findLastWhitespaceBeforeLineNumber(e) {
    e = e | 0;
    const t = this._arr;
    let i = 0, n = t.length - 1;
    for (; i <= n; ) {
      const r = (n - i | 0) / 2 | 0, a = i + r | 0;
      if (t[a].afterLineNumber < e) {
        if (a + 1 >= t.length || t[a + 1].afterLineNumber >= e)
          return a;
        i = a + 1 | 0;
      } else
        n = a - 1 | 0;
    }
    return -1;
  }
  _findFirstWhitespaceAfterLineNumber(e) {
    e = e | 0;
    const i = this._findLastWhitespaceBeforeLineNumber(e) + 1;
    return i < this._arr.length ? i : -1;
  }
  /**
   * Find the index of the first whitespace which has `afterLineNumber` >= `lineNumber`.
   * @return The index of the first whitespace with `afterLineNumber` >= `lineNumber` or -1 if no whitespace is found.
   */
  getFirstWhitespaceIndexAfterLineNumber(e) {
    return this._checkPendingChanges(), e = e | 0, this._findFirstWhitespaceAfterLineNumber(e);
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetForLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    let i;
    e > 1 ? i = this._lineHeight * (e - 1) : i = 0;
    const n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e - (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * Get the vertical offset (the sum of heights for all objects above) a certain line number.
   *
   * @param lineNumber The line number
   * @return The sum of heights for all objects above `lineNumber`.
   */
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    this._checkPendingChanges(), e = e | 0;
    const i = this._lineHeight * e, n = this.getWhitespaceAccumulatedHeightBeforeLineNumber(e + (t ? 1 : 0));
    return i + n + this._paddingTop;
  }
  /**
   * The maximum min width for all whitespaces.
   */
  getWhitespaceMinWidth() {
    if (this._checkPendingChanges(), this._minWidth === -1) {
      let e = 0;
      for (let t = 0, i = this._arr.length; t < i; t++)
        e = Math.max(e, this._arr[t].minWidth);
      this._minWidth = e;
    }
    return this._minWidth;
  }
  /**
   * Check if `verticalOffset` is below all lines.
   */
  isAfterLines(e) {
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e > t;
  }
  isInTopPadding(e) {
    return this._paddingTop === 0 ? !1 : (this._checkPendingChanges(), e < this._paddingTop);
  }
  isInBottomPadding(e) {
    if (this._paddingBottom === 0)
      return !1;
    this._checkPendingChanges();
    const t = this.getLinesTotalHeight();
    return e >= t - this._paddingBottom;
  }
  /**
   * Find the first line number that is at or after vertical offset `verticalOffset`.
   * i.e. if getVerticalOffsetForLine(line) is x and getVerticalOffsetForLine(line + 1) is y, then
   * getLineNumberAtOrAfterVerticalOffset(i) = line, x <= i < y.
   *
   * @param verticalOffset The vertical offset to search at.
   * @return The line number at or after vertical offset `verticalOffset`.
   */
  getLineNumberAtOrAfterVerticalOffset(e) {
    if (this._checkPendingChanges(), e = e | 0, e < 0)
      return 1;
    const t = this._lineCount | 0, i = this._lineHeight;
    let n = 1, o = t;
    for (; n < o; ) {
      const r = (n + o) / 2 | 0, a = this.getVerticalOffsetForLineNumber(r) | 0;
      if (e >= a + i)
        n = r + 1;
      else {
        if (e >= a)
          return r;
        o = r;
      }
    }
    return n > t ? t : n;
  }
  /**
   * Get all the lines and their relative vertical offsets that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return A structure describing the lines positioned between `verticalOffset1` and `verticalOffset2`.
   */
  getLinesViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this._lineHeight, n = this.getLineNumberAtOrAfterVerticalOffset(e) | 0, o = this.getVerticalOffsetForLineNumber(n) | 0;
    let r = this._lineCount | 0, a = this.getFirstWhitespaceIndexAfterLineNumber(n) | 0;
    const l = this.getWhitespacesCount() | 0;
    let c, d;
    a === -1 ? (a = l, d = r + 1, c = 0) : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
    let h = o, u = h;
    const g = 5e5;
    let m = 0;
    o >= g && (m = Math.floor(o / g) * g, m = Math.floor(m / i) * i, u -= m);
    const p = [], A = e + (t - e) / 2;
    let _ = -1;
    for (let S = n; S <= r; S++) {
      if (_ === -1) {
        const x = h, y = h + i;
        (x <= A && A < y || x > A) && (_ = S);
      }
      for (h += i, p[S - n] = u, u += i; d === S; )
        u += c, h += c, a++, a >= l ? d = r + 1 : (d = this.getAfterLineNumberForWhitespaceIndex(a) | 0, c = this.getHeightForWhitespaceIndex(a) | 0);
      if (h >= t) {
        r = S;
        break;
      }
    }
    _ === -1 && (_ = r);
    const b = this.getVerticalOffsetForLineNumber(r) | 0;
    let C = n, w = r;
    return C < w && o < e && C++, C < w && b + i > t && w--, {
      bigNumbersDelta: m,
      startLineNumber: n,
      endLineNumber: r,
      relativeVerticalOffset: p,
      centeredLineNumber: _,
      completelyVisibleStartLineNumber: C,
      completelyVisibleEndLineNumber: w,
      lineHeight: this._lineHeight
    };
  }
  getVerticalOffsetForWhitespaceIndex(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getAfterLineNumberForWhitespaceIndex(e);
    let i;
    t >= 1 ? i = this._lineHeight * t : i = 0;
    let n;
    return e > 0 ? n = this.getWhitespacesAccumulatedHeight(e - 1) : n = 0, i + n + this._paddingTop;
  }
  getWhitespaceIndexAtOrAfterVerticallOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    let t = 0, i = this.getWhitespacesCount() - 1;
    if (i < 0)
      return -1;
    const n = this.getVerticalOffsetForWhitespaceIndex(i), o = this.getHeightForWhitespaceIndex(i);
    if (e >= n + o)
      return -1;
    for (; t < i; ) {
      const r = Math.floor((t + i) / 2), a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (e >= a + l)
        t = r + 1;
      else {
        if (e >= a)
          return r;
        i = r;
      }
    }
    return t;
  }
  /**
   * Get exactly the whitespace that is layouted at `verticalOffset`.
   *
   * @param verticalOffset The vertical offset.
   * @return Precisely the whitespace that is layouted at `verticaloffset` or null.
   */
  getWhitespaceAtVerticalOffset(e) {
    this._checkPendingChanges(), e = e | 0;
    const t = this.getWhitespaceIndexAtOrAfterVerticallOffset(e);
    if (t < 0 || t >= this.getWhitespacesCount())
      return null;
    const i = this.getVerticalOffsetForWhitespaceIndex(t);
    if (i > e)
      return null;
    const n = this.getHeightForWhitespaceIndex(t), o = this.getIdForWhitespaceIndex(t), r = this.getAfterLineNumberForWhitespaceIndex(t);
    return {
      id: o,
      afterLineNumber: r,
      verticalOffset: i,
      height: n
    };
  }
  /**
   * Get a list of whitespaces that are positioned between `verticalOffset1` and `verticalOffset2`.
   *
   * @param verticalOffset1 The beginning of the viewport.
   * @param verticalOffset2 The end of the viewport.
   * @return An array with all the whitespaces in the viewport. If no whitespace is in viewport, the array is empty.
   */
  getWhitespaceViewportData(e, t) {
    this._checkPendingChanges(), e = e | 0, t = t | 0;
    const i = this.getWhitespaceIndexAtOrAfterVerticallOffset(e), n = this.getWhitespacesCount() - 1;
    if (i < 0)
      return [];
    const o = [];
    for (let r = i; r <= n; r++) {
      const a = this.getVerticalOffsetForWhitespaceIndex(r), l = this.getHeightForWhitespaceIndex(r);
      if (a >= t)
        break;
      o.push({
        id: this.getIdForWhitespaceIndex(r),
        afterLineNumber: this.getAfterLineNumberForWhitespaceIndex(r),
        verticalOffset: a,
        height: l
      });
    }
    return o;
  }
  /**
   * Get all whitespaces.
   */
  getWhitespaces() {
    return this._checkPendingChanges(), this._arr.slice(0);
  }
  /**
   * The number of whitespaces.
   */
  getWhitespacesCount() {
    return this._checkPendingChanges(), this._arr.length;
  }
  /**
   * Get the `id` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `id` of whitespace at `index`.
   */
  getIdForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].id;
  }
  /**
   * Get the `afterLineNumber` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `afterLineNumber` of whitespace at `index`.
   */
  getAfterLineNumberForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].afterLineNumber;
  }
  /**
   * Get the `height` for whitespace at index `index`.
   *
   * @param index The index of the whitespace.
   * @return `height` of whitespace at `index`.
   */
  getHeightForWhitespaceIndex(e) {
    return this._checkPendingChanges(), e = e | 0, this._arr[e].height;
  }
}, Qc.INSTANCE_COUNT = 0, Qc);
const Tre = 125;
class wp {
  constructor(e, t, i, n) {
    e = e | 0, t = t | 0, i = i | 0, n = n | 0, e < 0 && (e = 0), t < 0 && (t = 0), i < 0 && (i = 0), n < 0 && (n = 0), this.width = e, this.contentWidth = t, this.scrollWidth = Math.max(e, t), this.height = i, this.contentHeight = n, this.scrollHeight = Math.max(i, n);
  }
  equals(e) {
    return this.width === e.width && this.contentWidth === e.contentWidth && this.height === e.height && this.contentHeight === e.contentHeight;
  }
}
class Bre extends V {
  constructor(e, t) {
    super(), this._onDidContentSizeChange = this._register(new B()), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._dimensions = new wp(0, 0, 0, 0), this._scrollable = this._register(new vm({
      forceIntegerValues: !0,
      smoothScrollDuration: e,
      scheduleAtNextAnimationFrame: t
    })), this.onDidScroll = this._scrollable.onScroll;
  }
  getScrollable() {
    return this._scrollable;
  }
  setSmoothScrollDuration(e) {
    this._scrollable.setSmoothScrollDuration(e);
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  getScrollDimensions() {
    return this._dimensions;
  }
  setScrollDimensions(e) {
    if (this._dimensions.equals(e))
      return;
    const t = this._dimensions;
    this._dimensions = e, this._scrollable.setScrollDimensions({
      width: e.width,
      scrollWidth: e.scrollWidth,
      height: e.height,
      scrollHeight: e.scrollHeight
    }, !0);
    const i = t.contentWidth !== e.contentWidth, n = t.contentHeight !== e.contentHeight;
    (i || n) && this._onDidContentSizeChange.fire(new VT(t.contentWidth, t.contentHeight, e.contentWidth, e.contentHeight));
  }
  getFutureScrollPosition() {
    return this._scrollable.getFutureScrollPosition();
  }
  getCurrentScrollPosition() {
    return this._scrollable.getCurrentScrollPosition();
  }
  setScrollPositionNow(e) {
    this._scrollable.setScrollPositionNow(e);
  }
  setScrollPositionSmooth(e) {
    this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
}
class Rre extends V {
  constructor(e, t, i) {
    super(), this._configuration = e;
    const n = this._configuration.options, o = n.get(
      146
      /* EditorOption.layoutInfo */
    ), r = n.get(
      84
      /* EditorOption.padding */
    );
    this._linesLayout = new Nre(t, n.get(
      67
      /* EditorOption.lineHeight */
    ), r.top, r.bottom), this._maxLineWidth = 0, this._overlayWidgetsMinWidth = 0, this._scrollable = this._register(new Bre(0, i)), this._configureSmoothScrollDuration(), this._scrollable.setScrollDimensions(new wp(o.contentWidth, 0, o.height, 0)), this.onDidScroll = this._scrollable.onDidScroll, this.onDidContentSizeChange = this._scrollable.onDidContentSizeChange, this._updateHeight();
  }
  dispose() {
    super.dispose();
  }
  getScrollable() {
    return this._scrollable.getScrollable();
  }
  onHeightMaybeChanged() {
    this._updateHeight();
  }
  _configureSmoothScrollDuration() {
    this._scrollable.setSmoothScrollDuration(this._configuration.options.get(
      115
      /* EditorOption.smoothScrolling */
    ) ? Tre : 0);
  }
  // ---- begin view event handlers
  onConfigurationChanged(e) {
    const t = this._configuration.options;
    if (e.hasChanged(
      67
      /* EditorOption.lineHeight */
    ) && this._linesLayout.setLineHeight(t.get(
      67
      /* EditorOption.lineHeight */
    )), e.hasChanged(
      84
      /* EditorOption.padding */
    )) {
      const i = t.get(
        84
        /* EditorOption.padding */
      );
      this._linesLayout.setPadding(i.top, i.bottom);
    }
    if (e.hasChanged(
      146
      /* EditorOption.layoutInfo */
    )) {
      const i = t.get(
        146
        /* EditorOption.layoutInfo */
      ), n = i.contentWidth, o = i.height, r = this._scrollable.getScrollDimensions(), a = r.contentWidth;
      this._scrollable.setScrollDimensions(new wp(n, r.contentWidth, o, this._getContentHeight(n, o, a)));
    } else
      this._updateHeight();
    e.hasChanged(
      115
      /* EditorOption.smoothScrolling */
    ) && this._configureSmoothScrollDuration();
  }
  onFlushed(e) {
    this._linesLayout.onFlushed(e);
  }
  onLinesDeleted(e, t) {
    this._linesLayout.onLinesDeleted(e, t);
  }
  onLinesInserted(e, t) {
    this._linesLayout.onLinesInserted(e, t);
  }
  // ---- end view event handlers
  _getHorizontalScrollbarHeight(e, t) {
    const n = this._configuration.options.get(
      104
      /* EditorOption.scrollbar */
    );
    return n.horizontal === 2 || e >= t ? 0 : n.horizontalScrollbarSize;
  }
  _getContentHeight(e, t, i) {
    const n = this._configuration.options;
    let o = this._linesLayout.getLinesTotalHeight();
    return n.get(
      106
      /* EditorOption.scrollBeyondLastLine */
    ) ? o += Math.max(0, t - n.get(
      67
      /* EditorOption.lineHeight */
    ) - n.get(
      84
      /* EditorOption.padding */
    ).bottom) : n.get(
      104
      /* EditorOption.scrollbar */
    ).ignoreHorizontalScrollbarInContentHeight || (o += this._getHorizontalScrollbarHeight(e, i)), o;
  }
  _updateHeight() {
    const e = this._scrollable.getScrollDimensions(), t = e.width, i = e.height, n = e.contentWidth;
    this._scrollable.setScrollDimensions(new wp(t, e.contentWidth, i, this._getContentHeight(t, i, n)));
  }
  // ---- Layouting logic
  getCurrentViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getCurrentScrollPosition();
    return new bO(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  getFutureViewport() {
    const e = this._scrollable.getScrollDimensions(), t = this._scrollable.getFutureScrollPosition();
    return new bO(t.scrollTop, t.scrollLeft, e.width, e.height);
  }
  _computeContentWidth() {
    const e = this._configuration.options, t = this._maxLineWidth, i = e.get(
      147
      /* EditorOption.wrappingInfo */
    ), n = e.get(
      50
      /* EditorOption.fontInfo */
    ), o = e.get(
      146
      /* EditorOption.layoutInfo */
    );
    if (i.isViewportWrapping) {
      const r = e.get(
        73
        /* EditorOption.minimap */
      );
      return t > o.contentWidth + n.typicalHalfwidthCharacterWidth && r.enabled && r.side === "right" ? t + o.verticalScrollbarWidth : t;
    } else {
      const r = e.get(
        105
        /* EditorOption.scrollBeyondLastColumn */
      ) * n.typicalHalfwidthCharacterWidth, a = this._linesLayout.getWhitespaceMinWidth();
      return Math.max(t + r + o.verticalScrollbarWidth, a, this._overlayWidgetsMinWidth);
    }
  }
  setMaxLineWidth(e) {
    this._maxLineWidth = e, this._updateContentWidth();
  }
  setOverlayWidgetsMinWidth(e) {
    this._overlayWidgetsMinWidth = e, this._updateContentWidth();
  }
  _updateContentWidth() {
    const e = this._scrollable.getScrollDimensions();
    this._scrollable.setScrollDimensions(new wp(e.width, this._computeContentWidth(), e.height, e.contentHeight)), this._updateHeight();
  }
  // ---- view state
  saveState() {
    const e = this._scrollable.getFutureScrollPosition(), t = e.scrollTop, i = this._linesLayout.getLineNumberAtOrAfterVerticalOffset(t), n = this._linesLayout.getWhitespaceAccumulatedHeightBeforeLineNumber(i);
    return {
      scrollTop: t,
      scrollTopWithoutViewZones: t - n,
      scrollLeft: e.scrollLeft
    };
  }
  // ----
  changeWhitespace(e) {
    const t = this._linesLayout.changeWhitespace(e);
    return t && this.onHeightMaybeChanged(), t;
  }
  getVerticalOffsetForLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetForLineNumber(e, t);
  }
  getVerticalOffsetAfterLineNumber(e, t = !1) {
    return this._linesLayout.getVerticalOffsetAfterLineNumber(e, t);
  }
  isAfterLines(e) {
    return this._linesLayout.isAfterLines(e);
  }
  isInTopPadding(e) {
    return this._linesLayout.isInTopPadding(e);
  }
  isInBottomPadding(e) {
    return this._linesLayout.isInBottomPadding(e);
  }
  getLineNumberAtVerticalOffset(e) {
    return this._linesLayout.getLineNumberAtOrAfterVerticalOffset(e);
  }
  getWhitespaceAtVerticalOffset(e) {
    return this._linesLayout.getWhitespaceAtVerticalOffset(e);
  }
  getLinesViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getLinesViewportData(e.top, e.top + e.height);
  }
  getLinesViewportDataAtScrollTop(e) {
    const t = this._scrollable.getScrollDimensions();
    return e + t.height > t.scrollHeight && (e = t.scrollHeight - t.height), e < 0 && (e = 0), this._linesLayout.getLinesViewportData(e, e + t.height);
  }
  getWhitespaceViewportData() {
    const e = this.getCurrentViewport();
    return this._linesLayout.getWhitespaceViewportData(e.top, e.top + e.height);
  }
  getWhitespaces() {
    return this._linesLayout.getWhitespaces();
  }
  // ----
  getContentWidth() {
    return this._scrollable.getScrollDimensions().contentWidth;
  }
  getScrollWidth() {
    return this._scrollable.getScrollDimensions().scrollWidth;
  }
  getContentHeight() {
    return this._scrollable.getScrollDimensions().contentHeight;
  }
  getScrollHeight() {
    return this._scrollable.getScrollDimensions().scrollHeight;
  }
  getCurrentScrollLeft() {
    return this._scrollable.getCurrentScrollPosition().scrollLeft;
  }
  getCurrentScrollTop() {
    return this._scrollable.getCurrentScrollPosition().scrollTop;
  }
  validateScrollPosition(e) {
    return this._scrollable.validateScrollPosition(e);
  }
  setScrollPosition(e, t) {
    t === 1 ? this._scrollable.setScrollPositionNow(e) : this._scrollable.setScrollPositionSmooth(e);
  }
  hasPendingScrollAnimation() {
    return this._scrollable.hasPendingScrollAnimation();
  }
  deltaScrollNow(e, t) {
    const i = this._scrollable.getCurrentScrollPosition();
    this._scrollable.setScrollPositionNow({
      scrollLeft: i.scrollLeft + e,
      scrollTop: i.scrollTop + t
    });
  }
}
class Fre {
  constructor(e, t, i, n, o) {
    this.editorId = e, this.model = t, this.configuration = i, this._linesCollection = n, this._coordinatesConverter = o, this._decorationsCache = /* @__PURE__ */ Object.create(null), this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  _clearCachedModelDecorationsResolver() {
    this._cachedModelDecorationsResolver = null, this._cachedModelDecorationsResolverViewRange = null;
  }
  dispose() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  reset() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onModelDecorationsChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  onLineMappingChanged() {
    this._decorationsCache = /* @__PURE__ */ Object.create(null), this._clearCachedModelDecorationsResolver();
  }
  _getOrCreateViewModelDecoration(e) {
    const t = e.id;
    let i = this._decorationsCache[t];
    if (!i) {
      const n = e.range, o = e.options;
      let r;
      if (o.isWholeLine) {
        const a = this._coordinatesConverter.convertModelPositionToViewPosition(new F(n.startLineNumber, 1), 0, !1, !0), l = this._coordinatesConverter.convertModelPositionToViewPosition(
          new F(n.endLineNumber, this.model.getLineMaxColumn(n.endLineNumber)),
          1
          /* PositionAffinity.Right */
        );
        r = new E(a.lineNumber, a.column, l.lineNumber, l.column);
      } else
        r = this._coordinatesConverter.convertModelRangeToViewRange(
          n,
          1
          /* PositionAffinity.Right */
        );
      i = new w8(r, o), this._decorationsCache[t] = i;
    }
    return i;
  }
  getMinimapDecorationsInRange(e) {
    return this._getDecorationsInRange(e, !0, !1).decorations;
  }
  getDecorationsViewportData(e) {
    let t = this._cachedModelDecorationsResolver !== null;
    return t = t && e.equalsRange(this._cachedModelDecorationsResolverViewRange), t || (this._cachedModelDecorationsResolver = this._getDecorationsInRange(e, !1, !1), this._cachedModelDecorationsResolverViewRange = e), this._cachedModelDecorationsResolver;
  }
  getInlineDecorationsOnLine(e, t = !1, i = !1) {
    const n = new E(e, this._linesCollection.getViewLineMinColumn(e), e, this._linesCollection.getViewLineMaxColumn(e));
    return this._getDecorationsInRange(n, t, i).inlineDecorations[0];
  }
  _getDecorationsInRange(e, t, i) {
    const n = this._linesCollection.getDecorationsInRange(e, this.editorId, Jw(this.configuration.options), t, i), o = e.startLineNumber, r = e.endLineNumber, a = [];
    let l = 0;
    const c = [];
    for (let d = o; d <= r; d++)
      c[d - o] = [];
    for (let d = 0, h = n.length; d < h; d++) {
      const u = n[d], g = u.options;
      if (!Ore(this.model, u))
        continue;
      const m = this._getOrCreateViewModelDecoration(u), p = m.range;
      if (a[l++] = m, g.inlineClassName) {
        const A = new Jp(
          p,
          g.inlineClassName,
          g.inlineClassNameAffectsLetterSpacing ? 3 : 0
          /* InlineDecorationType.Regular */
        ), _ = Math.max(o, p.startLineNumber), b = Math.min(r, p.endLineNumber);
        for (let C = _; C <= b; C++)
          c[C - o].push(A);
      }
      if (g.beforeContentClassName && o <= p.startLineNumber && p.startLineNumber <= r) {
        const A = new Jp(
          new E(p.startLineNumber, p.startColumn, p.startLineNumber, p.startColumn),
          g.beforeContentClassName,
          1
          /* InlineDecorationType.Before */
        );
        c[p.startLineNumber - o].push(A);
      }
      if (g.afterContentClassName && o <= p.endLineNumber && p.endLineNumber <= r) {
        const A = new Jp(
          new E(p.endLineNumber, p.endColumn, p.endLineNumber, p.endColumn),
          g.afterContentClassName,
          2
          /* InlineDecorationType.After */
        );
        c[p.endLineNumber - o].push(A);
      }
    }
    return {
      decorations: a,
      inlineDecorations: c
    };
  }
}
function Ore(s, e) {
  return !(e.options.hideInCommentTokens && Pre(s, e) || e.options.hideInStringTokens && Hre(s, e));
}
function Pre(s, e) {
  return U8(
    s,
    e.range,
    (t) => t === 1
    /* StandardTokenType.Comment */
  );
}
function Hre(s, e) {
  return U8(
    s,
    e.range,
    (t) => t === 2
    /* StandardTokenType.String */
  );
}
function U8(s, e, t) {
  for (let i = e.startLineNumber; i <= e.endLineNumber; i++) {
    const n = s.tokenization.getLineTokens(i), o = i === e.startLineNumber, r = i === e.endLineNumber;
    let a = o ? n.findTokenIndexAtOffset(e.startColumn - 1) : 0;
    for (; a < n.getCount() && !(r && n.getStartOffset(a) > e.endColumn - 1); ) {
      if (!t(n.getStandardTokenType(a)))
        return !1;
      a++;
    }
  }
  return !0;
}
function ox(s, e) {
  return s === null ? e ? Mv.INSTANCE : Nv.INSTANCE : new Wre(s, e);
}
class Wre {
  constructor(e, t) {
    this._projectionData = e, this._isVisible = t;
  }
  isVisible() {
    return this._isVisible;
  }
  setVisible(e) {
    return this._isVisible = e, this;
  }
  getProjectionData() {
    return this._projectionData;
  }
  getViewLineCount() {
    return this._isVisible ? this._projectionData.getOutputLineCount() : 0;
  }
  getViewLineContent(e, t, i) {
    this._assertVisible();
    const n = i > 0 ? this._projectionData.breakOffsets[i - 1] : 0, o = this._projectionData.breakOffsets[i];
    let r;
    if (this._projectionData.injectionOffsets !== null) {
      const a = this._projectionData.injectionOffsets.map((c, d) => new Rr(0, 0, c + 1, this._projectionData.injectionOptions[d], 0));
      r = Rr.applyInjectedText(e.getLineContent(t), a).substring(n, o);
    } else
      r = e.getValueInRange({
        startLineNumber: t,
        startColumn: n + 1,
        endLineNumber: t,
        endColumn: o + 1
      });
    return i > 0 && (r = $O(this._projectionData.wrappedTextIndentLength) + r), r;
  }
  getViewLineLength(e, t, i) {
    return this._assertVisible(), this._projectionData.getLineLength(i);
  }
  getViewLineMinColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMinOutputOffset(i) + 1;
  }
  getViewLineMaxColumn(e, t, i) {
    return this._assertVisible(), this._projectionData.getMaxOutputOffset(i) + 1;
  }
  /**
   * Try using {@link getViewLinesData} instead.
  */
  getViewLineData(e, t, i) {
    const n = new Array();
    return this.getViewLinesData(e, t, i, 1, 0, [!0], n), n[0];
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    this._assertVisible();
    const l = this._projectionData, c = l.injectionOffsets, d = l.injectionOptions;
    let h = null;
    if (c) {
      h = [];
      let g = 0, m = 0;
      for (let p = 0; p < l.getOutputLineCount(); p++) {
        const A = new Array();
        h[p] = A;
        const _ = p > 0 ? l.breakOffsets[p - 1] : 0, b = l.breakOffsets[p];
        for (; m < c.length; ) {
          const C = d[m].content.length, w = c[m] + g, S = w + C;
          if (w > b)
            break;
          if (_ < S) {
            const x = d[m];
            if (x.inlineClassName) {
              const y = p > 0 ? l.wrappedTextIndentLength : 0, D = y + Math.max(w - _, 0), I = y + Math.min(S - _, b - _);
              D !== I && A.push(new kne(D, I, x.inlineClassName, x.inlineClassNameAffectsLetterSpacing));
            }
          }
          if (S <= b)
            g += C, m++;
          else
            break;
        }
      }
    }
    let u;
    c ? u = e.tokenization.getLineTokens(t).withInserted(c.map((g, m) => ({
      offset: g,
      text: d[m].content,
      tokenMetadata: Gi.defaultTokenMetadata
    }))) : u = e.tokenization.getLineTokens(t);
    for (let g = i; g < i + n; g++) {
      const m = o + g - i;
      if (!r[m]) {
        a[m] = null;
        continue;
      }
      a[m] = this._getViewLineData(u, h ? h[g] : null, g);
    }
  }
  _getViewLineData(e, t, i) {
    this._assertVisible();
    const n = this._projectionData, o = i > 0 ? n.wrappedTextIndentLength : 0, r = i > 0 ? n.breakOffsets[i - 1] : 0, a = n.breakOffsets[i], l = e.sliceAndInflate(r, a, o);
    let c = l.getLineContent();
    i > 0 && (c = $O(n.wrappedTextIndentLength) + c);
    const d = this._projectionData.getMinOutputOffset(i) + 1, h = c.length + 1, u = i + 1 < this.getViewLineCount(), g = i === 0 ? 0 : n.breakOffsetsVisibleColumn[i - 1];
    return new LT(c, u, d, h, g, l, t);
  }
  getModelColumnOfViewPosition(e, t) {
    return this._assertVisible(), this._projectionData.translateToInputOffset(e, t - 1) + 1;
  }
  getViewPositionOfModelPosition(e, t, i = 2) {
    return this._assertVisible(), this._projectionData.translateToOutputPosition(t - 1, i).toPosition(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    this._assertVisible();
    const i = this._projectionData.translateToOutputPosition(t - 1);
    return e + i.outputLineIndex;
  }
  normalizePosition(e, t, i) {
    const n = t.lineNumber - e;
    return this._projectionData.normalizeOutputPosition(e, t.column - 1, i).toPosition(n);
  }
  getInjectedTextAt(e, t) {
    return this._projectionData.getInjectedText(e, t - 1);
  }
  _assertVisible() {
    if (!this._isVisible)
      throw new Error("Not supported");
  }
}
const X1 = class X1 {
  constructor() {
  }
  isVisible() {
    return !0;
  }
  setVisible(e) {
    return e ? this : Nv.INSTANCE;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 1;
  }
  getViewLineContent(e, t, i) {
    return e.getLineContent(t);
  }
  getViewLineLength(e, t, i) {
    return e.getLineLength(t);
  }
  getViewLineMinColumn(e, t, i) {
    return e.getLineMinColumn(t);
  }
  getViewLineMaxColumn(e, t, i) {
    return e.getLineMaxColumn(t);
  }
  getViewLineData(e, t, i) {
    const n = e.tokenization.getLineTokens(t), o = n.getLineContent();
    return new LT(o, !1, 1, o.length + 1, 0, n.inflate(), null);
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    if (!r[o]) {
      a[o] = null;
      return;
    }
    a[o] = this.getViewLineData(e, t, 0);
  }
  getModelColumnOfViewPosition(e, t) {
    return t;
  }
  getViewPositionOfModelPosition(e, t) {
    return new F(e, t);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
  normalizePosition(e, t, i) {
    return t;
  }
  getInjectedTextAt(e, t) {
    return null;
  }
};
X1.INSTANCE = new X1();
let Mv = X1;
const Z1 = class Z1 {
  constructor() {
  }
  isVisible() {
    return !1;
  }
  setVisible(e) {
    return e ? Mv.INSTANCE : this;
  }
  getProjectionData() {
    return null;
  }
  getViewLineCount() {
    return 0;
  }
  getViewLineContent(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineLength(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMinColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineMaxColumn(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLineData(e, t, i) {
    throw new Error("Not supported");
  }
  getViewLinesData(e, t, i, n, o, r, a) {
    throw new Error("Not supported");
  }
  getModelColumnOfViewPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewPositionOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  getViewLineNumberOfModelPosition(e, t) {
    throw new Error("Not supported");
  }
  normalizePosition(e, t, i) {
    throw new Error("Not supported");
  }
  getInjectedTextAt(e, t) {
    throw new Error("Not supported");
  }
};
Z1.INSTANCE = new Z1();
let Nv = Z1;
const rx = [""];
function $O(s) {
  if (s >= rx.length)
    for (let e = 1; e <= s; e++)
      rx[e] = Vre(e);
  return rx[s];
}
function Vre(s) {
  return new Array(s + 1).join(" ");
}
class zre {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    this._editorId = e, this.model = t, this._validModelVersionId = -1, this._domLineBreaksComputerFactory = i, this._monospaceLineBreaksComputerFactory = n, this.fontInfo = o, this.tabSize = r, this.wrappingStrategy = a, this.wrappingColumn = l, this.wrappingIndent = c, this.wordBreak = d, this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  dispose() {
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []);
  }
  createCoordinatesConverter() {
    return new Qre(this);
  }
  _constructLines(e, t) {
    this.modelLineProjections = [], e && (this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, []));
    const i = this.model.getLinesContent(), n = this.model.getInjectedTextDecorations(this._editorId), o = i.length, r = this.createLineBreaksComputer(), a = new Pl(Rr.fromDecorations(n));
    for (let p = 0; p < o; p++) {
      const A = a.takeWhile((_) => _.lineNumber === p + 1);
      r.addRequest(i[p], A, t ? t[p] : null);
    }
    const l = r.finalize(), c = [], d = this.hiddenAreasDecorationIds.map((p) => this.model.getDecorationRange(p)).sort(E.compareRangesUsingStarts);
    let h = 1, u = 0, g = -1, m = g + 1 < d.length ? u + 1 : o + 2;
    for (let p = 0; p < o; p++) {
      const A = p + 1;
      A === m && (g++, h = d[g].startLineNumber, u = d[g].endLineNumber, m = g + 1 < d.length ? u + 1 : o + 2);
      const _ = A >= h && A <= u, b = ox(l[p], !_);
      c[p] = b.getViewLineCount(), this.modelLineProjections[p] = b;
    }
    this._validModelVersionId = this.model.getVersionId(), this.projectedModelLineLineCounts = new QG(c);
  }
  getHiddenAreas() {
    return this.hiddenAreasDecorationIds.map((e) => this.model.getDecorationRange(e));
  }
  setHiddenAreas(e) {
    const t = e.map((u) => this.model.validateRange(u)), i = Ure(t), n = this.hiddenAreasDecorationIds.map((u) => this.model.getDecorationRange(u)).sort(E.compareRangesUsingStarts);
    if (i.length === n.length) {
      let u = !1;
      for (let g = 0; g < i.length; g++)
        if (!i[g].equalsRange(n[g])) {
          u = !0;
          break;
        }
      if (!u)
        return !1;
    }
    const o = i.map((u) => ({
      range: u,
      options: He.EMPTY
    }));
    this.hiddenAreasDecorationIds = this.model.deltaDecorations(this.hiddenAreasDecorationIds, o);
    const r = i;
    let a = 1, l = 0, c = -1, d = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2, h = !1;
    for (let u = 0; u < this.modelLineProjections.length; u++) {
      const g = u + 1;
      g === d && (c++, a = r[c].startLineNumber, l = r[c].endLineNumber, d = c + 1 < r.length ? l + 1 : this.modelLineProjections.length + 2);
      let m = !1;
      if (g >= a && g <= l ? this.modelLineProjections[u].isVisible() && (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!1), m = !0) : (h = !0, this.modelLineProjections[u].isVisible() || (this.modelLineProjections[u] = this.modelLineProjections[u].setVisible(!0), m = !0)), m) {
        const p = this.modelLineProjections[u].getViewLineCount();
        this.projectedModelLineLineCounts.setValue(u, p);
      }
    }
    return h || this.setHiddenAreas([]), !0;
  }
  modelPositionIsVisible(e, t) {
    return e < 1 || e > this.modelLineProjections.length ? !1 : this.modelLineProjections[e - 1].isVisible();
  }
  getModelLineViewLineCount(e) {
    return e < 1 || e > this.modelLineProjections.length ? 1 : this.modelLineProjections[e - 1].getViewLineCount();
  }
  setTabSize(e) {
    return this.tabSize === e ? !1 : (this.tabSize = e, this._constructLines(
      /*resetHiddenAreas*/
      !1,
      null
    ), !0);
  }
  setWrappingSettings(e, t, i, n, o) {
    const r = this.fontInfo.equals(e), a = this.wrappingStrategy === t, l = this.wrappingColumn === i, c = this.wrappingIndent === n, d = this.wordBreak === o;
    if (r && a && l && c && d)
      return !1;
    const h = r && a && !l && c && d;
    this.fontInfo = e, this.wrappingStrategy = t, this.wrappingColumn = i, this.wrappingIndent = n, this.wordBreak = o;
    let u = null;
    if (h) {
      u = [];
      for (let g = 0, m = this.modelLineProjections.length; g < m; g++)
        u[g] = this.modelLineProjections[g].getProjectionData();
    }
    return this._constructLines(
      /*resetHiddenAreas*/
      !1,
      u
    ), !0;
  }
  createLineBreaksComputer() {
    return (this.wrappingStrategy === "advanced" ? this._domLineBreaksComputerFactory : this._monospaceLineBreaksComputerFactory).createLineBreaksComputer(this.fontInfo, this.tabSize, this.wrappingColumn, this.wrappingIndent, this.wordBreak);
  }
  onModelFlushed() {
    this._constructLines(
      /*resetHiddenAreas*/
      !0,
      null
    );
  }
  onModelLinesDeleted(e, t, i) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const n = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, o = this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections.splice(t - 1, i - t + 1), this.projectedModelLineLineCounts.removeValues(t - 1, i - t + 1), new ND(n, o);
  }
  onModelLinesInserted(e, t, i, n) {
    if (!e || e <= this._validModelVersionId)
      return null;
    const o = t > 2 && !this.modelLineProjections[t - 2].isVisible(), r = t === 1 ? 1 : this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1;
    let a = 0;
    const l = [], c = [];
    for (let d = 0, h = n.length; d < h; d++) {
      const u = ox(n[d], !o);
      l.push(u);
      const g = u.getViewLineCount();
      a += g, c[d] = g;
    }
    return this.modelLineProjections = this.modelLineProjections.slice(0, t - 1).concat(l).concat(this.modelLineProjections.slice(t - 1)), this.projectedModelLineLineCounts.insertValues(t - 1, c), new TD(r, r + a - 1);
  }
  onModelLineChanged(e, t, i) {
    if (e !== null && e <= this._validModelVersionId)
      return [!1, null, null, null];
    const n = t - 1, o = this.modelLineProjections[n].getViewLineCount(), r = this.modelLineProjections[n].isVisible(), a = ox(i, r);
    this.modelLineProjections[n] = a;
    const l = this.modelLineProjections[n].getViewLineCount();
    let c = !1, d = 0, h = -1, u = 0, g = -1, m = 0, p = -1;
    o > l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + l - 1, m = h + 1, p = m + (o - l) - 1, c = !0) : o < l ? (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + o - 1, u = h + 1, g = u + (l - o) - 1, c = !0) : (d = this.projectedModelLineLineCounts.getPrefixSum(t - 1) + 1, h = d + l - 1), this.projectedModelLineLineCounts.setValue(n, l);
    const A = d <= h ? new z8(d, h - d + 1) : null, _ = u <= g ? new TD(u, g) : null, b = m <= p ? new ND(m, p) : null;
    return [c, A, _, b];
  }
  acceptVersionId(e) {
    this._validModelVersionId = e, this.modelLineProjections.length === 1 && !this.modelLineProjections[0].isVisible() && this.setHiddenAreas([]);
  }
  getViewLineCount() {
    return this.projectedModelLineLineCounts.getTotalSum();
  }
  _toValidViewLineNumber(e) {
    if (e < 1)
      return 1;
    const t = this.getViewLineCount();
    return e > t ? t : e | 0;
  }
  getActiveIndentGuide(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t), i = this._toValidViewLineNumber(i);
    const n = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), o = this.convertViewPositionToModelPosition(t, this.getViewLineMinColumn(t)), r = this.convertViewPositionToModelPosition(i, this.getViewLineMinColumn(i)), a = this.model.guides.getActiveIndentGuide(n.lineNumber, o.lineNumber, r.lineNumber), l = this.convertModelPositionToViewPosition(a.startLineNumber, 1), c = this.convertModelPositionToViewPosition(a.endLineNumber, this.model.getLineMaxColumn(a.endLineNumber));
    return {
      startLineNumber: l.lineNumber,
      endLineNumber: c.lineNumber,
      indent: a.indent
    };
  }
  // #region ViewLineInfo
  getViewLineInfo(e) {
    e = this._toValidViewLineNumber(e);
    const t = this.projectedModelLineLineCounts.getIndexOf(e - 1), i = t.index, n = t.remainder;
    return new XO(i + 1, n);
  }
  getMinColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getMaxColumnOfViewLine(e) {
    return this.modelLineProjections[e.modelLineNumber - 1].getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx);
  }
  getModelStartPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMinColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new F(e.modelLineNumber, n);
  }
  getModelEndPositionOfViewLine(e) {
    const t = this.modelLineProjections[e.modelLineNumber - 1], i = t.getViewLineMaxColumn(this.model, e.modelLineNumber, e.modelLineWrappedLineIdx), n = t.getModelColumnOfViewPosition(e.modelLineWrappedLineIdx, i);
    return new F(e.modelLineNumber, n);
  }
  getViewLineInfosGroupedByModelRanges(e, t) {
    const i = this.getViewLineInfo(e), n = this.getViewLineInfo(t), o = new Array();
    let r = this.getModelStartPositionOfViewLine(i), a = new Array();
    for (let l = i.modelLineNumber; l <= n.modelLineNumber; l++) {
      const c = this.modelLineProjections[l - 1];
      if (c.isVisible()) {
        const d = l === i.modelLineNumber ? i.modelLineWrappedLineIdx : 0, h = l === n.modelLineNumber ? n.modelLineWrappedLineIdx + 1 : c.getViewLineCount();
        for (let u = d; u < h; u++)
          a.push(new XO(l, u));
      }
      if (!c.isVisible() && r) {
        const d = new F(l - 1, this.model.getLineMaxColumn(l - 1) + 1), h = E.fromPositions(r, d);
        o.push(new ZO(h, a)), a = [], r = null;
      } else c.isVisible() && !r && (r = new F(l, 1));
    }
    if (r) {
      const l = E.fromPositions(r, this.getModelEndPositionOfViewLine(n));
      o.push(new ZO(l, a));
    }
    return o;
  }
  // #endregion
  getViewLinesBracketGuides(e, t, i, n) {
    const o = i ? this.convertViewPositionToModelPosition(i.lineNumber, i.column) : null, r = [];
    for (const a of this.getViewLineInfosGroupedByModelRanges(e, t)) {
      const l = a.modelRange.startLineNumber, c = this.model.guides.getLinesBracketGuides(l, a.modelRange.endLineNumber, o, n);
      for (const d of a.viewLines) {
        const u = c[d.modelLineNumber - l].map((g) => {
          if (g.forWrappedLinesAfterColumn !== -1 && this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesAfterColumn).lineNumber >= d.modelLineWrappedLineIdx || g.forWrappedLinesBeforeOrAtColumn !== -1 && this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.forWrappedLinesBeforeOrAtColumn).lineNumber < d.modelLineWrappedLineIdx)
            return;
          if (!g.horizontalLine)
            return g;
          let m = -1;
          if (g.column !== -1) {
            const _ = this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.column);
            if (_.lineNumber === d.modelLineWrappedLineIdx)
              m = _.column;
            else if (_.lineNumber < d.modelLineWrappedLineIdx)
              m = this.getMinColumnOfViewLine(d);
            else if (_.lineNumber > d.modelLineWrappedLineIdx)
              return;
          }
          const p = this.convertModelPositionToViewPosition(d.modelLineNumber, g.horizontalLine.endColumn), A = this.modelLineProjections[d.modelLineNumber - 1].getViewPositionOfModelPosition(0, g.horizontalLine.endColumn);
          return A.lineNumber === d.modelLineWrappedLineIdx ? new vh(g.visibleColumn, m, g.className, new Hp(g.horizontalLine.top, p.column), -1, -1) : A.lineNumber < d.modelLineWrappedLineIdx || g.visibleColumn !== -1 ? void 0 : new vh(g.visibleColumn, m, g.className, new Hp(g.horizontalLine.top, this.getMaxColumnOfViewLine(d)), -1, -1);
        });
        r.push(u.filter((g) => !!g));
      }
    }
    return r;
  }
  getViewLinesIndentGuides(e, t) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const i = this.convertViewPositionToModelPosition(e, this.getViewLineMinColumn(e)), n = this.convertViewPositionToModelPosition(t, this.getViewLineMaxColumn(t));
    let o = [];
    const r = [], a = [], l = i.lineNumber - 1, c = n.lineNumber - 1;
    let d = null;
    for (let m = l; m <= c; m++) {
      const p = this.modelLineProjections[m];
      if (p.isVisible()) {
        const A = p.getViewLineNumberOfModelPosition(0, m === l ? i.column : 1), _ = p.getViewLineNumberOfModelPosition(0, this.model.getLineMaxColumn(m + 1)), b = _ - A + 1;
        let C = 0;
        b > 1 && p.getViewLineMinColumn(this.model, m + 1, _) === 1 && (C = A === 0 ? 1 : 2), r.push(b), a.push(C), d === null && (d = new F(m + 1, 0));
      } else
        d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, m)), d = null);
    }
    d !== null && (o = o.concat(this.model.guides.getLinesIndentGuides(d.lineNumber, n.lineNumber)), d = null);
    const h = t - e + 1, u = new Array(h);
    let g = 0;
    for (let m = 0, p = o.length; m < p; m++) {
      let A = o[m];
      const _ = Math.min(h - g, r[m]), b = a[m];
      let C;
      b === 2 ? C = 0 : b === 1 ? C = 1 : C = _;
      for (let w = 0; w < _; w++)
        w === C && (A = 0), u[g++] = A;
    }
    return u;
  }
  getViewLineContent(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineContent(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineLength(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineLength(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMinColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMinColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineMaxColumn(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineMaxColumn(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLineData(e) {
    const t = this.getViewLineInfo(e);
    return this.modelLineProjections[t.modelLineNumber - 1].getViewLineData(this.model, t.modelLineNumber, t.modelLineWrappedLineIdx);
  }
  getViewLinesData(e, t, i) {
    e = this._toValidViewLineNumber(e), t = this._toValidViewLineNumber(t);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1);
    let o = e;
    const r = n.index, a = n.remainder, l = [];
    for (let c = r, d = this.model.getLineCount(); c < d; c++) {
      const h = this.modelLineProjections[c];
      if (!h.isVisible())
        continue;
      const u = c === r ? a : 0;
      let g = h.getViewLineCount() - u, m = !1;
      if (o + g > t && (m = !0, g = t - o + 1), h.getViewLinesData(this.model, c + 1, u, g, o - e, i, l), o += g, m)
        break;
    }
    return l;
  }
  validateViewPosition(e, t, i) {
    e = this._toValidViewLineNumber(e);
    const n = this.projectedModelLineLineCounts.getIndexOf(e - 1), o = n.index, r = n.remainder, a = this.modelLineProjections[o], l = a.getViewLineMinColumn(this.model, o + 1, r), c = a.getViewLineMaxColumn(this.model, o + 1, r);
    t < l && (t = l), t > c && (t = c);
    const d = a.getModelColumnOfViewPosition(r, t);
    return this.model.validatePosition(new F(o + 1, d)).equals(i) ? new F(e, t) : this.convertModelPositionToViewPosition(i.lineNumber, i.column);
  }
  validateViewRange(e, t) {
    const i = this.validateViewPosition(e.startLineNumber, e.startColumn, t.getStartPosition()), n = this.validateViewPosition(e.endLineNumber, e.endColumn, t.getEndPosition());
    return new E(i.lineNumber, i.column, n.lineNumber, n.column);
  }
  convertViewPositionToModelPosition(e, t) {
    const i = this.getViewLineInfo(e), n = this.modelLineProjections[i.modelLineNumber - 1].getModelColumnOfViewPosition(i.modelLineWrappedLineIdx, t);
    return this.model.validatePosition(new F(i.modelLineNumber, n));
  }
  convertViewRangeToModelRange(e) {
    const t = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), i = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    return new E(t.lineNumber, t.column, i.lineNumber, i.column);
  }
  convertModelPositionToViewPosition(e, t, i = 2, n = !1, o = !1) {
    const r = this.model.validatePosition(new F(e, t)), a = r.lineNumber, l = r.column;
    let c = a - 1, d = !1;
    if (o)
      for (; c < this.modelLineProjections.length && !this.modelLineProjections[c].isVisible(); )
        c++, d = !0;
    else
      for (; c > 0 && !this.modelLineProjections[c].isVisible(); )
        c--, d = !0;
    if (c === 0 && !this.modelLineProjections[c].isVisible())
      return new F(n ? 0 : 1, 1);
    const h = 1 + this.projectedModelLineLineCounts.getPrefixSum(c);
    let u;
    return d ? o ? u = this.modelLineProjections[c].getViewPositionOfModelPosition(h, 1, i) : u = this.modelLineProjections[c].getViewPositionOfModelPosition(h, this.model.getLineMaxColumn(c + 1), i) : u = this.modelLineProjections[a - 1].getViewPositionOfModelPosition(h, l, i), u;
  }
  /**
   * @param affinity The affinity in case of an empty range. Has no effect for non-empty ranges.
  */
  convertModelRangeToViewRange(e, t = 0) {
    if (e.isEmpty()) {
      const i = this.convertModelPositionToViewPosition(e.startLineNumber, e.startColumn, t);
      return E.fromPositions(i);
    } else {
      const i = this.convertModelPositionToViewPosition(
        e.startLineNumber,
        e.startColumn,
        1
        /* PositionAffinity.Right */
      ), n = this.convertModelPositionToViewPosition(
        e.endLineNumber,
        e.endColumn,
        0
        /* PositionAffinity.Left */
      );
      return new E(i.lineNumber, i.column, n.lineNumber, n.column);
    }
  }
  getViewLineNumberOfModelPosition(e, t) {
    let i = e - 1;
    if (this.modelLineProjections[i].isVisible()) {
      const o = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
      return this.modelLineProjections[i].getViewLineNumberOfModelPosition(o, t);
    }
    for (; i > 0 && !this.modelLineProjections[i].isVisible(); )
      i--;
    if (i === 0 && !this.modelLineProjections[i].isVisible())
      return 1;
    const n = 1 + this.projectedModelLineLineCounts.getPrefixSum(i);
    return this.modelLineProjections[i].getViewLineNumberOfModelPosition(n, this.model.getLineMaxColumn(i + 1));
  }
  getDecorationsInRange(e, t, i, n, o) {
    const r = this.convertViewPositionToModelPosition(e.startLineNumber, e.startColumn), a = this.convertViewPositionToModelPosition(e.endLineNumber, e.endColumn);
    if (a.lineNumber - r.lineNumber <= e.endLineNumber - e.startLineNumber)
      return this.model.getDecorationsInRange(new E(r.lineNumber, 1, a.lineNumber, a.column), t, i, n, o);
    let l = [];
    const c = r.lineNumber - 1, d = a.lineNumber - 1;
    let h = null;
    for (let p = c; p <= d; p++)
      if (this.modelLineProjections[p].isVisible())
        h === null && (h = new F(p + 1, p === c ? r.column : 1));
      else if (h !== null) {
        const _ = this.model.getLineMaxColumn(p);
        l = l.concat(this.model.getDecorationsInRange(new E(h.lineNumber, h.column, p, _), t, i, n)), h = null;
      }
    h !== null && (l = l.concat(this.model.getDecorationsInRange(new E(h.lineNumber, h.column, a.lineNumber, a.column), t, i, n)), h = null), l.sort((p, A) => {
      const _ = E.compareRangesUsingStarts(p.range, A.range);
      return _ === 0 ? p.id < A.id ? -1 : p.id > A.id ? 1 : 0 : _;
    });
    const u = [];
    let g = 0, m = null;
    for (const p of l) {
      const A = p.id;
      m !== A && (m = A, u[g++] = p);
    }
    return u;
  }
  getInjectedTextAt(e) {
    const t = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[t.modelLineNumber - 1].getInjectedTextAt(t.modelLineWrappedLineIdx, e.column);
  }
  normalizePosition(e, t) {
    const i = this.getViewLineInfo(e.lineNumber);
    return this.modelLineProjections[i.modelLineNumber - 1].normalizePosition(i.modelLineWrappedLineIdx, e, t);
  }
  getLineIndentColumn(e) {
    const t = this.getViewLineInfo(e);
    return t.modelLineWrappedLineIdx === 0 ? this.model.getLineIndentColumn(t.modelLineNumber) : 0;
  }
}
function Ure(s) {
  if (s.length === 0)
    return [];
  const e = s.slice();
  e.sort(E.compareRangesUsingStarts);
  const t = [];
  let i = e[0].startLineNumber, n = e[0].endLineNumber;
  for (let o = 1, r = e.length; o < r; o++) {
    const a = e[o];
    a.startLineNumber > n + 1 ? (t.push(new E(i, 1, n, 1)), i = a.startLineNumber, n = a.endLineNumber) : a.endLineNumber > n && (n = a.endLineNumber);
  }
  return t.push(new E(i, 1, n, 1)), t;
}
class XO {
  constructor(e, t) {
    this.modelLineNumber = e, this.modelLineWrappedLineIdx = t;
  }
}
class ZO {
  constructor(e, t) {
    this.modelRange = e, this.viewLines = t;
  }
}
class Qre {
  constructor(e) {
    this._lines = e;
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._lines.convertViewPositionToModelPosition(e.lineNumber, e.column);
  }
  convertViewRangeToModelRange(e) {
    return this._lines.convertViewRangeToModelRange(e);
  }
  validateViewPosition(e, t) {
    return this._lines.validateViewPosition(e.lineNumber, e.column, t);
  }
  validateViewRange(e, t) {
    return this._lines.validateViewRange(e, t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e, t, i, n) {
    return this._lines.convertModelPositionToViewPosition(e.lineNumber, e.column, t, i, n);
  }
  convertModelRangeToViewRange(e, t) {
    return this._lines.convertModelRangeToViewRange(e, t);
  }
  modelPositionIsVisible(e) {
    return this._lines.modelPositionIsVisible(e.lineNumber, e.column);
  }
  getModelLineViewLineCount(e) {
    return this._lines.getModelLineViewLineCount(e);
  }
  getViewLineNumberOfModelPosition(e, t) {
    return this._lines.getViewLineNumberOfModelPosition(e, t);
  }
}
class Gre {
  constructor(e) {
    this.model = e;
  }
  dispose() {
  }
  createCoordinatesConverter() {
    return new jre(this);
  }
  getHiddenAreas() {
    return [];
  }
  setHiddenAreas(e) {
    return !1;
  }
  setTabSize(e) {
    return !1;
  }
  setWrappingSettings(e, t, i, n) {
    return !1;
  }
  createLineBreaksComputer() {
    const e = [];
    return {
      addRequest: (t, i, n) => {
        e.push(null);
      },
      finalize: () => e
    };
  }
  onModelFlushed() {
  }
  onModelLinesDeleted(e, t, i) {
    return new ND(t, i);
  }
  onModelLinesInserted(e, t, i, n) {
    return new TD(t, i);
  }
  onModelLineChanged(e, t, i) {
    return [!1, new z8(t, 1), null, null];
  }
  acceptVersionId(e) {
  }
  getViewLineCount() {
    return this.model.getLineCount();
  }
  getActiveIndentGuide(e, t, i) {
    return {
      startLineNumber: e,
      endLineNumber: e,
      indent: 0
    };
  }
  getViewLinesBracketGuides(e, t, i) {
    return new Array(t - e + 1).fill([]);
  }
  getViewLinesIndentGuides(e, t) {
    const i = t - e + 1, n = new Array(i);
    for (let o = 0; o < i; o++)
      n[o] = 0;
    return n;
  }
  getViewLineContent(e) {
    return this.model.getLineContent(e);
  }
  getViewLineLength(e) {
    return this.model.getLineLength(e);
  }
  getViewLineMinColumn(e) {
    return this.model.getLineMinColumn(e);
  }
  getViewLineMaxColumn(e) {
    return this.model.getLineMaxColumn(e);
  }
  getViewLineData(e) {
    const t = this.model.tokenization.getLineTokens(e), i = t.getLineContent();
    return new LT(i, !1, 1, i.length + 1, 0, t.inflate(), null);
  }
  getViewLinesData(e, t, i) {
    const n = this.model.getLineCount();
    e = Math.min(Math.max(1, e), n), t = Math.min(Math.max(1, t), n);
    const o = [];
    for (let r = e; r <= t; r++) {
      const a = r - e;
      o[a] = i[a] ? this.getViewLineData(r) : null;
    }
    return o;
  }
  getDecorationsInRange(e, t, i, n, o) {
    return this.model.getDecorationsInRange(e, t, i, n, o);
  }
  normalizePosition(e, t) {
    return this.model.normalizePosition(e, t);
  }
  getLineIndentColumn(e) {
    return this.model.getLineIndentColumn(e);
  }
  getInjectedTextAt(e) {
    return null;
  }
}
class jre {
  constructor(e) {
    this._lines = e;
  }
  _validPosition(e) {
    return this._lines.model.validatePosition(e);
  }
  _validRange(e) {
    return this._lines.model.validateRange(e);
  }
  // View -> Model conversion and related methods
  convertViewPositionToModelPosition(e) {
    return this._validPosition(e);
  }
  convertViewRangeToModelRange(e) {
    return this._validRange(e);
  }
  validateViewPosition(e, t) {
    return this._validPosition(t);
  }
  validateViewRange(e, t) {
    return this._validRange(t);
  }
  // Model -> View conversion and related methods
  convertModelPositionToViewPosition(e) {
    return this._validPosition(e);
  }
  convertModelRangeToViewRange(e) {
    return this._validRange(e);
  }
  modelPositionIsVisible(e) {
    const t = this._lines.model.getLineCount();
    return !(e.lineNumber < 1 || e.lineNumber > t);
  }
  getModelLineViewLineCount(e) {
    return 1;
  }
  getViewLineNumberOfModelPosition(e, t) {
    return e;
  }
}
const Od = qo.Right;
class Yre {
  constructor(e) {
    this.persist = 0, this._requiredLanes = 1, this.lanes = new Uint8Array(Math.ceil((e + 1) * Od / 8));
  }
  reset(e) {
    const t = Math.ceil((e + 1) * Od / 8);
    this.lanes.length < t ? this.lanes = new Uint8Array(t) : this.lanes.fill(0), this._requiredLanes = 1;
  }
  get requiredLanes() {
    return this._requiredLanes;
  }
  push(e, t, i) {
    i && (this.persist |= 1 << e - 1);
    for (let n = t.startLineNumber; n <= t.endLineNumber; n++) {
      const o = Od * n + (e - 1);
      this.lanes[o >>> 3] |= 1 << o % 8, this._requiredLanes = Math.max(this._requiredLanes, this.countAtLine(n));
    }
  }
  getLanesAtLine(e) {
    const t = [];
    let i = Od * e;
    for (let n = 0; n < Od; n++)
      (this.persist & 1 << n || this.lanes[i >>> 3] & 1 << i % 8) && t.push(n + 1), i++;
    return t.length ? t : [qo.Center];
  }
  countAtLine(e) {
    let t = Od * e, i = 0;
    for (let n = 0; n < Od; n++)
      (this.persist & 1 << n || this.lanes[t >>> 3] & 1 << t % 8) && i++, t++;
    return i;
  }
}
let Kre = class extends V {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    if (super(), this.languageConfigurationService = a, this._themeService = l, this._attachedView = c, this._transactionalTarget = d, this.hiddenAreasModel = new qre(), this.previousHiddenAreas = [], this._editorId = e, this._configuration = t, this.model = i, this._eventDispatcher = new pre(), this.onEvent = this._eventDispatcher.onEvent, this.cursorConfig = new ug(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._updateConfigurationViewLineCount = this._register(new zt(() => this._updateConfigurationViewLineCountNow(), 0)), this._hasFocus = !1, this._viewportStart = QT.create(this.model), this.glyphLanes = new Yre(0), this.model.isTooLargeForTokenization())
      this._lines = new Gre(this.model);
    else {
      const h = this._configuration.options, u = h.get(
        50
        /* EditorOption.fontInfo */
      ), g = h.get(
        140
        /* EditorOption.wrappingStrategy */
      ), m = h.get(
        147
        /* EditorOption.wrappingInfo */
      ), p = h.get(
        139
        /* EditorOption.wrappingIndent */
      ), A = h.get(
        130
        /* EditorOption.wordBreak */
      );
      this._lines = new zre(this._editorId, this.model, n, o, u, this.model.getOptions().tabSize, g, m.wrappingColumn, p, A);
    }
    this.coordinatesConverter = this._lines.createCoordinatesConverter(), this._cursor = this._register(new Lre(i, this, this.coordinatesConverter, this.cursorConfig)), this.viewLayout = this._register(new Rre(this._configuration, this.getLineCount(), r)), this._register(this.viewLayout.onDidScroll((h) => {
      h.scrollTopChanged && this._handleVisibleLinesChanged(), h.scrollTopChanged && this._viewportStart.invalidate(), this._eventDispatcher.emitSingleViewEvent(new hre(h)), this._eventDispatcher.emitOutgoingEvent(new UT(h.oldScrollWidth, h.oldScrollLeft, h.oldScrollHeight, h.oldScrollTop, h.scrollWidth, h.scrollLeft, h.scrollHeight, h.scrollTop));
    })), this._register(this.viewLayout.onDidContentSizeChange((h) => {
      this._eventDispatcher.emitOutgoingEvent(h);
    })), this._decorations = new Fre(this._editorId, this.model, this._configuration, this._lines, this.coordinatesConverter), this._registerModelEvents(), this._register(this._configuration.onDidChangeFast((h) => {
      try {
        const u = this._eventDispatcher.beginEmitViewEvents();
        this._onConfigurationChanged(u, h);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    })), this._register(Lv.getInstance().onDidChange(() => {
      this._eventDispatcher.emitSingleViewEvent(new fre());
    })), this._register(this._themeService.onDidColorThemeChange((h) => {
      this._invalidateDecorationsColorCache(), this._eventDispatcher.emitSingleViewEvent(new ure(h));
    })), this._updateConfigurationViewLineCountNow();
  }
  dispose() {
    super.dispose(), this._decorations.dispose(), this._lines.dispose(), this._viewportStart.dispose(), this._eventDispatcher.dispose();
  }
  createLineBreaksComputer() {
    return this._lines.createLineBreaksComputer();
  }
  addViewEventHandler(e) {
    this._eventDispatcher.addViewEventHandler(e);
  }
  removeViewEventHandler(e) {
    this._eventDispatcher.removeViewEventHandler(e);
  }
  _updateConfigurationViewLineCountNow() {
    this._configuration.setViewLineCount(this._lines.getViewLineCount());
  }
  getModelVisibleRanges() {
    const e = this.viewLayout.getLinesViewportData(), t = new E(e.startLineNumber, this.getLineMinColumn(e.startLineNumber), e.endLineNumber, this.getLineMaxColumn(e.endLineNumber));
    return this._toModelVisibleRanges(t);
  }
  visibleLinesStabilized() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !0);
  }
  _handleVisibleLinesChanged() {
    const e = this.getModelVisibleRanges();
    this._attachedView.setVisibleLines(e, !1);
  }
  setHasFocus(e) {
    this._hasFocus = e, this._cursor.setHasFocus(e), this._eventDispatcher.emitSingleViewEvent(new cre(e)), this._eventDispatcher.emitOutgoingEvent(new zT(!e, e));
  }
  onCompositionStart() {
    this._eventDispatcher.emitSingleViewEvent(new ore());
  }
  onCompositionEnd() {
    this._eventDispatcher.emitSingleViewEvent(new rre());
  }
  _captureStableViewport() {
    if (this._viewportStart.isValid && this.viewLayout.getCurrentScrollTop() > 0) {
      const e = new F(this._viewportStart.viewLineNumber, this.getLineMinColumn(this._viewportStart.viewLineNumber)), t = this.coordinatesConverter.convertViewPositionToModelPosition(e);
      return new tP(t, this._viewportStart.startLineDelta);
    }
    return new tP(null, 0);
  }
  _onConfigurationChanged(e, t) {
    const i = this._captureStableViewport(), n = this._configuration.options, o = n.get(
      50
      /* EditorOption.fontInfo */
    ), r = n.get(
      140
      /* EditorOption.wrappingStrategy */
    ), a = n.get(
      147
      /* EditorOption.wrappingInfo */
    ), l = n.get(
      139
      /* EditorOption.wrappingIndent */
    ), c = n.get(
      130
      /* EditorOption.wordBreak */
    );
    this._lines.setWrappingSettings(o, r, a.wrappingColumn, l, c) && (e.emitViewEvent(new Qb()), e.emitViewEvent(new Gb()), e.emitViewEvent(new Fd(null)), this._cursor.onLineMappingChanged(e), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this._updateConfigurationViewLineCount.schedule()), t.hasChanged(
      92
      /* EditorOption.readOnly */
    ) && (this._decorations.reset(), e.emitViewEvent(new Fd(null))), t.hasChanged(
      99
      /* EditorOption.renderValidationDecorations */
    ) && (this._decorations.reset(), e.emitViewEvent(new Fd(null))), e.emitViewEvent(new are(t)), this.viewLayout.onConfigurationChanged(t), i.recoverViewportStart(this.coordinatesConverter, this.viewLayout), ug.shouldRecreate(t) && (this.cursorConfig = new ug(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig));
  }
  _registerModelEvents() {
    this._register(this.model.onDidChangeContentOrInjectedText((e) => {
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        let n = !1, o = !1;
        const r = e instanceof Nh ? e.rawContentChangedEvent.changes : e.changes, a = e instanceof Nh ? e.rawContentChangedEvent.versionId : null, l = this._lines.createLineBreaksComputer();
        for (const h of r)
          switch (h.changeType) {
            case 4: {
              for (let u = 0; u < h.detail.length; u++) {
                const g = h.detail[u];
                let m = h.injectedTexts[u];
                m && (m = m.filter((p) => !p.ownerId || p.ownerId === this._editorId)), l.addRequest(g, m, null);
              }
              break;
            }
            case 2: {
              let u = null;
              h.injectedText && (u = h.injectedText.filter((g) => !g.ownerId || g.ownerId === this._editorId)), l.addRequest(h.detail, u, null);
              break;
            }
          }
        const c = l.finalize(), d = new Pl(c);
        for (const h of r)
          switch (h.changeType) {
            case 1: {
              this._lines.onModelFlushed(), i.emitViewEvent(new Qb()), this._decorations.reset(), this.viewLayout.onFlushed(this.getLineCount()), n = !0;
              break;
            }
            case 3: {
              const u = this._lines.onModelLinesDeleted(a, h.fromLineNumber, h.toLineNumber);
              u !== null && (i.emitViewEvent(u), this.viewLayout.onLinesDeleted(u.fromLineNumber, u.toLineNumber)), n = !0;
              break;
            }
            case 4: {
              const u = d.takeCount(h.detail.length), g = this._lines.onModelLinesInserted(a, h.fromLineNumber, h.toLineNumber, u);
              g !== null && (i.emitViewEvent(g), this.viewLayout.onLinesInserted(g.fromLineNumber, g.toLineNumber)), n = !0;
              break;
            }
            case 2: {
              const u = d.dequeue(), [g, m, p, A] = this._lines.onModelLineChanged(a, h.lineNumber, u);
              o = g, m && i.emitViewEvent(m), p && (i.emitViewEvent(p), this.viewLayout.onLinesInserted(p.fromLineNumber, p.toLineNumber)), A && (i.emitViewEvent(A), this.viewLayout.onLinesDeleted(A.fromLineNumber, A.toLineNumber));
              break;
            }
            case 5:
              break;
          }
        a !== null && this._lines.acceptVersionId(a), this.viewLayout.onHeightMaybeChanged(), !n && o && (i.emitViewEvent(new Gb()), i.emitViewEvent(new Fd(null)), this._cursor.onLineMappingChanged(i), this._decorations.onLineMappingChanged());
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      const t = this._viewportStart.isValid;
      if (this._viewportStart.invalidate(), this._configuration.setModelLineCount(this.model.getLineCount()), this._updateConfigurationViewLineCountNow(), !this._hasFocus && this.model.getAttachedEditorCount() >= 2 && t) {
        const i = this.model._getTrackedRange(this._viewportStart.modelTrackedRange);
        if (i) {
          const n = this.coordinatesConverter.convertModelPositionToViewPosition(i.getStartPosition()), o = this.viewLayout.getVerticalOffsetForLineNumber(n.lineNumber);
          this.viewLayout.setScrollPosition(
            { scrollTop: o + this._viewportStart.startLineDelta },
            1
            /* ScrollType.Immediate */
          );
        }
      }
      try {
        const i = this._eventDispatcher.beginEmitViewEvents();
        e instanceof Nh && i.emitOutgoingEvent(new yre(e.contentChangedEvent)), this._cursor.onModelContentChanged(i, e);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
      this._handleVisibleLinesChanged();
    })), this._register(this.model.onDidChangeTokens((e) => {
      const t = [];
      for (let i = 0, n = e.ranges.length; i < n; i++) {
        const o = e.ranges[i], r = this.coordinatesConverter.convertModelPositionToViewPosition(new F(o.fromLineNumber, 1)).lineNumber, a = this.coordinatesConverter.convertModelPositionToViewPosition(new F(o.toLineNumber, this.model.getLineMaxColumn(o.toLineNumber))).lineNumber;
        t[i] = {
          fromLineNumber: r,
          toLineNumber: a
        };
      }
      this._eventDispatcher.emitSingleViewEvent(new gre(t)), this._eventDispatcher.emitOutgoingEvent(new Ere(e));
    })), this._register(this.model.onDidChangeLanguageConfiguration((e) => {
      this._eventDispatcher.emitSingleViewEvent(new dre()), this.cursorConfig = new ug(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new Sre(e));
    })), this._register(this.model.onDidChangeLanguage((e) => {
      this.cursorConfig = new ug(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new vre(e));
    })), this._register(this.model.onDidChangeOptions((e) => {
      if (this._lines.setTabSize(this.model.getOptions().tabSize)) {
        try {
          const t = this._eventDispatcher.beginEmitViewEvents();
          t.emitViewEvent(new Qb()), t.emitViewEvent(new Gb()), t.emitViewEvent(new Fd(null)), this._cursor.onLineMappingChanged(t), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount());
        } finally {
          this._eventDispatcher.endEmitViewEvents();
        }
        this._updateConfigurationViewLineCount.schedule();
      }
      this.cursorConfig = new ug(this.model.getLanguageId(), this.model.getOptions(), this._configuration, this.languageConfigurationService), this._cursor.updateConfiguration(this.cursorConfig), this._eventDispatcher.emitOutgoingEvent(new xre(e));
    })), this._register(this.model.onDidChangeDecorations((e) => {
      this._decorations.onModelDecorationsChanged(), this._eventDispatcher.emitSingleViewEvent(new Fd(e)), this._eventDispatcher.emitOutgoingEvent(new Cre(e));
    }));
  }
  setHiddenAreas(e, t) {
    this.hiddenAreasModel.setHiddenAreas(t, e);
    const i = this.hiddenAreasModel.getMergedRanges();
    if (i === this.previousHiddenAreas)
      return;
    this.previousHiddenAreas = i;
    const n = this._captureStableViewport();
    let o = !1;
    try {
      const r = this._eventDispatcher.beginEmitViewEvents();
      o = this._lines.setHiddenAreas(i), o && (r.emitViewEvent(new Qb()), r.emitViewEvent(new Gb()), r.emitViewEvent(new Fd(null)), this._cursor.onLineMappingChanged(r), this._decorations.onLineMappingChanged(), this.viewLayout.onFlushed(this.getLineCount()), this.viewLayout.onHeightMaybeChanged());
      const a = n.viewportStartModelPosition?.lineNumber;
      a && i.some((c) => c.startLineNumber <= a && a <= c.endLineNumber) || n.recoverViewportStart(this.coordinatesConverter, this.viewLayout);
    } finally {
      this._eventDispatcher.endEmitViewEvents();
    }
    this._updateConfigurationViewLineCount.schedule(), o && this._eventDispatcher.emitOutgoingEvent(new bre());
  }
  getVisibleRangesPlusViewportAboveBelow() {
    const e = this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    ), t = this._configuration.options.get(
      67
      /* EditorOption.lineHeight */
    ), i = Math.max(20, Math.round(e.height / t)), n = this.viewLayout.getLinesViewportData(), o = Math.max(1, n.completelyVisibleStartLineNumber - i), r = Math.min(this.getLineCount(), n.completelyVisibleEndLineNumber + i);
    return this._toModelVisibleRanges(new E(o, this.getLineMinColumn(o), r, this.getLineMaxColumn(r)));
  }
  getVisibleRanges() {
    const e = this.getCompletelyVisibleViewRange();
    return this._toModelVisibleRanges(e);
  }
  getHiddenAreas() {
    return this._lines.getHiddenAreas();
  }
  _toModelVisibleRanges(e) {
    const t = this.coordinatesConverter.convertViewRangeToModelRange(e), i = this._lines.getHiddenAreas();
    if (i.length === 0)
      return [t];
    const n = [];
    let o = 0, r = t.startLineNumber, a = t.startColumn;
    const l = t.endLineNumber, c = t.endColumn;
    for (let d = 0, h = i.length; d < h; d++) {
      const u = i[d].startLineNumber, g = i[d].endLineNumber;
      g < r || u > l || (r < u && (n[o++] = new E(r, a, u - 1, this.model.getLineMaxColumn(u - 1))), r = g + 1, a = 1);
    }
    return (r < l || r === l && a < c) && (n[o++] = new E(r, a, l, c)), n;
  }
  getCompletelyVisibleViewRange() {
    const e = this.viewLayout.getLinesViewportData(), t = e.completelyVisibleStartLineNumber, i = e.completelyVisibleEndLineNumber;
    return new E(t, this.getLineMinColumn(t), i, this.getLineMaxColumn(i));
  }
  getCompletelyVisibleViewRangeAtScrollTop(e) {
    const t = this.viewLayout.getLinesViewportDataAtScrollTop(e), i = t.completelyVisibleStartLineNumber, n = t.completelyVisibleEndLineNumber;
    return new E(i, this.getLineMinColumn(i), n, this.getLineMaxColumn(n));
  }
  saveState() {
    const e = this.viewLayout.saveState(), t = e.scrollTop, i = this.viewLayout.getLineNumberAtVerticalOffset(t), n = this.coordinatesConverter.convertViewPositionToModelPosition(new F(i, this.getLineMinColumn(i))), o = this.viewLayout.getVerticalOffsetForLineNumber(i) - t;
    return {
      scrollLeft: e.scrollLeft,
      firstPosition: n,
      firstPositionDeltaTop: o
    };
  }
  reduceRestoreState(e) {
    if (typeof e.firstPosition > "u")
      return this._reduceRestoreStateCompatibility(e);
    const t = this.model.validatePosition(e.firstPosition), i = this.coordinatesConverter.convertModelPositionToViewPosition(t), n = this.viewLayout.getVerticalOffsetForLineNumber(i.lineNumber) - e.firstPositionDeltaTop;
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: n
    };
  }
  _reduceRestoreStateCompatibility(e) {
    return {
      scrollLeft: e.scrollLeft,
      scrollTop: e.scrollTopWithoutViewZones
    };
  }
  getTabSize() {
    return this.model.getOptions().tabSize;
  }
  getLineCount() {
    return this._lines.getViewLineCount();
  }
  /**
   * Gives a hint that a lot of requests are about to come in for these line numbers.
   */
  setViewport(e, t, i) {
    this._viewportStart.update(this, e);
  }
  getActiveIndentGuide(e, t, i) {
    return this._lines.getActiveIndentGuide(e, t, i);
  }
  getLinesIndentGuides(e, t) {
    return this._lines.getViewLinesIndentGuides(e, t);
  }
  getBracketGuidesInRangeByLine(e, t, i, n) {
    return this._lines.getViewLinesBracketGuides(e, t, i, n);
  }
  getLineContent(e) {
    return this._lines.getViewLineContent(e);
  }
  getLineLength(e) {
    return this._lines.getViewLineLength(e);
  }
  getLineMinColumn(e) {
    return this._lines.getViewLineMinColumn(e);
  }
  getLineMaxColumn(e) {
    return this._lines.getViewLineMaxColumn(e);
  }
  getLineFirstNonWhitespaceColumn(e) {
    const t = Sn(this.getLineContent(e));
    return t === -1 ? 0 : t + 1;
  }
  getLineLastNonWhitespaceColumn(e) {
    const t = Ru(this.getLineContent(e));
    return t === -1 ? 0 : t + 2;
  }
  getMinimapDecorationsInRange(e) {
    return this._decorations.getMinimapDecorationsInRange(e);
  }
  getDecorationsInViewport(e) {
    return this._decorations.getDecorationsViewportData(e).decorations;
  }
  getInjectedTextAt(e) {
    return this._lines.getInjectedTextAt(e);
  }
  getViewportViewLineRenderingData(e, t) {
    const n = this._decorations.getDecorationsViewportData(e).inlineDecorations[t - e.startLineNumber];
    return this._getViewLineRenderingData(t, n);
  }
  getViewLineRenderingData(e) {
    const t = this._decorations.getInlineDecorationsOnLine(e);
    return this._getViewLineRenderingData(e, t);
  }
  _getViewLineRenderingData(e, t) {
    const i = this.model.mightContainRTL(), n = this.model.mightContainNonBasicASCII(), o = this.getTabSize(), r = this._lines.getViewLineData(e);
    return r.inlineDecorations && (t = [
      ...t,
      ...r.inlineDecorations.map((a) => a.toInlineDecoration(e))
    ]), new $s(r.minColumn, r.maxColumn, r.content, r.continuesWithWrappedLine, i, n, r.tokens, t, o, r.startVisibleColumn);
  }
  getViewLineData(e) {
    return this._lines.getViewLineData(e);
  }
  getMinimapLinesRenderingData(e, t, i) {
    const n = this._lines.getViewLinesData(e, t, i);
    return new Lne(this.getTabSize(), n);
  }
  getAllOverviewRulerDecorations(e) {
    const t = this.model.getOverviewRulerDecorations(this._editorId, Jw(this._configuration.options)), i = new Jre();
    for (const n of t) {
      const o = n.options, r = o.overviewRuler;
      if (!r)
        continue;
      const a = r.position;
      if (a === 0)
        continue;
      const l = r.getColor(e.value), c = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.startLineNumber, n.range.startColumn), d = this.coordinatesConverter.getViewLineNumberOfModelPosition(n.range.endLineNumber, n.range.endColumn);
      i.accept(l, o.zIndex, c, d, a);
    }
    return i.asArray;
  }
  _invalidateDecorationsColorCache() {
    const e = this.model.getOverviewRulerDecorations();
    for (const t of e)
      t.options.overviewRuler?.invalidateCachedColor(), t.options.minimap?.invalidateCachedColor();
  }
  getValueInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueInRange(i, t);
  }
  getValueLengthInRange(e, t) {
    const i = this.coordinatesConverter.convertViewRangeToModelRange(e);
    return this.model.getValueLengthInRange(i, t);
  }
  modifyPosition(e, t) {
    const i = this.coordinatesConverter.convertViewPositionToModelPosition(e), n = this.model.modifyPosition(i, t);
    return this.coordinatesConverter.convertModelPositionToViewPosition(n);
  }
  deduceModelPositionRelativeToViewPosition(e, t, i) {
    const n = this.coordinatesConverter.convertViewPositionToModelPosition(e);
    this.model.getEOL().length === 2 && (t < 0 ? t -= i : t += i);
    const r = this.model.getOffsetAt(n) + t;
    return this.model.getPositionAt(r);
  }
  getPlainTextToCopy(e, t, i) {
    const n = i ? `\r
` : this.model.getEOL();
    e = e.slice(0), e.sort(E.compareRangesUsingStarts);
    let o = !1, r = !1;
    for (const l of e)
      l.isEmpty() ? o = !0 : r = !0;
    if (!r) {
      if (!t)
        return "";
      const l = e.map((d) => d.startLineNumber);
      let c = "";
      for (let d = 0; d < l.length; d++)
        d > 0 && l[d - 1] === l[d] || (c += this.model.getLineContent(l[d]) + n);
      return c;
    }
    if (o && t) {
      const l = [];
      let c = 0;
      for (const d of e) {
        const h = d.startLineNumber;
        d.isEmpty() ? h !== c && l.push(this.model.getLineContent(h)) : l.push(this.model.getValueInRange(
          d,
          i ? 2 : 0
          /* EndOfLinePreference.TextDefined */
        )), c = h;
      }
      return l.length === 1 ? l[0] : l;
    }
    const a = [];
    for (const l of e)
      l.isEmpty() || a.push(this.model.getValueInRange(
        l,
        i ? 2 : 0
        /* EndOfLinePreference.TextDefined */
      ));
    return a.length === 1 ? a[0] : a;
  }
  getRichTextToCopy(e, t) {
    const i = this.model.getLanguageId();
    if (i === Js || e.length !== 1)
      return null;
    let n = e[0];
    if (n.isEmpty()) {
      if (!t)
        return null;
      const d = n.startLineNumber;
      n = new E(d, this.model.getLineMinColumn(d), d, this.model.getLineMaxColumn(d));
    }
    const o = this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ), r = this._getColorMap(), l = /[:;\\\/<>]/.test(o.fontFamily) || o.fontFamily === Zn.fontFamily;
    let c;
    return l ? c = Zn.fontFamily : (c = o.fontFamily, c = c.replace(/"/g, "'"), /[,']/.test(c) || /[+ ]/.test(c) && (c = `'${c}'`), c = `${c}, ${Zn.fontFamily}`), {
      mode: i,
      html: `<div style="color: ${r[
        1
        /* ColorId.DefaultForeground */
      ]};background-color: ${r[
        2
        /* ColorId.DefaultBackground */
      ]};font-family: ${c};font-weight: ${o.fontWeight};font-size: ${o.fontSize}px;line-height: ${o.lineHeight}px;white-space: pre;">` + this._getHTMLToCopy(n, r) + "</div>"
    };
  }
  _getHTMLToCopy(e, t) {
    const i = e.startLineNumber, n = e.startColumn, o = e.endLineNumber, r = e.endColumn, a = this.getTabSize();
    let l = "";
    for (let c = i; c <= o; c++) {
      const d = this.model.tokenization.getLineTokens(c), h = d.getLineContent(), u = c === i ? n - 1 : 0, g = c === o ? r - 1 : h.length;
      h === "" ? l += "<br>" : l += qJ(h, d.inflate(), t, u, g, a, yn);
    }
    return l;
  }
  _getColorMap() {
    const e = ci.getColorMap(), t = ["#000000"];
    if (e)
      for (let i = 1, n = e.length; i < n; i++)
        t[i] = Y.Format.CSS.formatHex(e[i]);
    return t;
  }
  //#region cursor operations
  getPrimaryCursorState() {
    return this._cursor.getPrimaryCursorState();
  }
  getLastAddedCursorIndex() {
    return this._cursor.getLastAddedCursorIndex();
  }
  getCursorStates() {
    return this._cursor.getCursorStates();
  }
  setCursorStates(e, t, i) {
    return this._withViewEventsCollector((n) => this._cursor.setStates(n, e, t, i));
  }
  getCursorColumnSelectData() {
    return this._cursor.getCursorColumnSelectData();
  }
  getCursorAutoClosedCharacters() {
    return this._cursor.getAutoClosedCharacters();
  }
  setCursorColumnSelectData(e) {
    this._cursor.setCursorColumnSelectData(e);
  }
  getPrevEditOperationType() {
    return this._cursor.getPrevEditOperationType();
  }
  setPrevEditOperationType(e) {
    this._cursor.setPrevEditOperationType(e);
  }
  getSelection() {
    return this._cursor.getSelection();
  }
  getSelections() {
    return this._cursor.getSelections();
  }
  getPosition() {
    return this._cursor.getPrimaryCursorState().modelState.position;
  }
  setSelections(e, t, i = 0) {
    this._withViewEventsCollector((n) => this._cursor.setSelections(n, e, t, i));
  }
  saveCursorState() {
    return this._cursor.saveState();
  }
  restoreCursorState(e) {
    this._withViewEventsCollector((t) => this._cursor.restoreState(t, e));
  }
  _executeCursorEdit(e) {
    if (this._cursor.context.cursorConfig.readOnly) {
      this._eventDispatcher.emitOutgoingEvent(new wre());
      return;
    }
    this._withViewEventsCollector(e);
  }
  executeEdits(e, t, i) {
    this._executeCursorEdit((n) => this._cursor.executeEdits(n, e, t, i));
  }
  startComposition() {
    this._executeCursorEdit((e) => this._cursor.startComposition(e));
  }
  endComposition(e) {
    this._executeCursorEdit((t) => this._cursor.endComposition(t, e));
  }
  type(e, t) {
    this._executeCursorEdit((i) => this._cursor.type(i, e, t));
  }
  compositionType(e, t, i, n, o) {
    this._executeCursorEdit((r) => this._cursor.compositionType(r, e, t, i, n, o));
  }
  paste(e, t, i, n) {
    this._executeCursorEdit((o) => this._cursor.paste(o, e, t, i, n));
  }
  cut(e) {
    this._executeCursorEdit((t) => this._cursor.cut(t, e));
  }
  executeCommand(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommand(i, e, t));
  }
  executeCommands(e, t) {
    this._executeCursorEdit((i) => this._cursor.executeCommands(i, e, t));
  }
  revealAllCursors(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealAll(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealPrimaryCursor(e, t, i = !1) {
    this._withViewEventsCollector((n) => this._cursor.revealPrimary(
      n,
      e,
      i,
      0,
      t,
      0
      /* ScrollType.Smooth */
    ));
  }
  revealTopMostCursor(e) {
    const t = this._cursor.getTopMostViewPosition(), i = new E(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new tA(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealBottomMostCursor(e) {
    const t = this._cursor.getBottomMostViewPosition(), i = new E(t.lineNumber, t.column, t.lineNumber, t.column);
    this._withViewEventsCollector((n) => n.emitViewEvent(new tA(
      e,
      !1,
      i,
      null,
      0,
      !0,
      0
      /* ScrollType.Smooth */
    )));
  }
  revealRange(e, t, i, n, o) {
    this._withViewEventsCollector((r) => r.emitViewEvent(new tA(e, !1, i, null, n, t, o)));
  }
  //#endregion
  //#region viewLayout
  changeWhitespace(e) {
    this.viewLayout.changeWhitespace(e) && (this._eventDispatcher.emitSingleViewEvent(new mre()), this._eventDispatcher.emitOutgoingEvent(new _re()));
  }
  //#endregion
  _withViewEventsCollector(e) {
    return this._transactionalTarget.batchChanges(() => {
      try {
        const t = this._eventDispatcher.beginEmitViewEvents();
        return e(t);
      } finally {
        this._eventDispatcher.endEmitViewEvents();
      }
    });
  }
  batchEvents(e) {
    this._withViewEventsCollector(() => {
      e();
    });
  }
  normalizePosition(e, t) {
    return this._lines.normalizePosition(e, t);
  }
  /**
   * Gets the column at which indentation stops at a given line.
   * @internal
  */
  getLineIndentColumn(e) {
    return this._lines.getLineIndentColumn(e);
  }
};
class QT {
  static create(e) {
    const t = e._setTrackedRange(
      null,
      new E(1, 1, 1, 1),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
    return new QT(e, 1, !1, t, 0);
  }
  get viewLineNumber() {
    return this._viewLineNumber;
  }
  get isValid() {
    return this._isValid;
  }
  get modelTrackedRange() {
    return this._modelTrackedRange;
  }
  get startLineDelta() {
    return this._startLineDelta;
  }
  constructor(e, t, i, n, o) {
    this._model = e, this._viewLineNumber = t, this._isValid = i, this._modelTrackedRange = n, this._startLineDelta = o;
  }
  dispose() {
    this._model._setTrackedRange(
      this._modelTrackedRange,
      null,
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    );
  }
  update(e, t) {
    const i = e.coordinatesConverter.convertViewPositionToModelPosition(new F(t, e.getLineMinColumn(t))), n = e.model._setTrackedRange(
      this._modelTrackedRange,
      new E(i.lineNumber, i.column, i.lineNumber, i.column),
      1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    ), o = e.viewLayout.getVerticalOffsetForLineNumber(t), r = e.viewLayout.getCurrentScrollTop();
    this._viewLineNumber = t, this._isValid = !0, this._modelTrackedRange = n, this._startLineDelta = r - o;
  }
  invalidate() {
    this._isValid = !1;
  }
}
class Jre {
  constructor() {
    this._asMap = /* @__PURE__ */ Object.create(null), this.asArray = [];
  }
  accept(e, t, i, n, o) {
    const r = this._asMap[e];
    if (r) {
      const a = r.data, l = a[a.length - 3], c = a[a.length - 1];
      if (l === o && c + 1 >= i) {
        n > c && (a[a.length - 1] = n);
        return;
      }
      a.push(o, i, n);
    } else {
      const a = new o_(e, t, [o, i, n]);
      this._asMap[e] = a, this.asArray.push(a);
    }
  }
}
class qre {
  constructor() {
    this.hiddenAreas = /* @__PURE__ */ new Map(), this.shouldRecompute = !1, this.ranges = [];
  }
  setHiddenAreas(e, t) {
    const i = this.hiddenAreas.get(e);
    i && eP(i, t) || (this.hiddenAreas.set(e, t), this.shouldRecompute = !0);
  }
  /**
   * The returned array is immutable.
  */
  getMergedRanges() {
    if (!this.shouldRecompute)
      return this.ranges;
    this.shouldRecompute = !1;
    const e = Array.from(this.hiddenAreas.values()).reduce((t, i) => $re(t, i), []);
    return eP(this.ranges, e) ? this.ranges : (this.ranges = e, this.ranges);
  }
}
function $re(s, e) {
  const t = [];
  let i = 0, n = 0;
  for (; i < s.length && n < e.length; ) {
    const o = s[i], r = e[n];
    if (o.endLineNumber < r.startLineNumber - 1)
      t.push(s[i++]);
    else if (r.endLineNumber < o.startLineNumber - 1)
      t.push(e[n++]);
    else {
      const a = Math.min(o.startLineNumber, r.startLineNumber), l = Math.max(o.endLineNumber, r.endLineNumber);
      t.push(new E(a, 1, l, 1)), i++, n++;
    }
  }
  for (; i < s.length; )
    t.push(s[i++]);
  for (; n < e.length; )
    t.push(e[n++]);
  return t;
}
function eP(s, e) {
  if (s.length !== e.length)
    return !1;
  for (let t = 0; t < s.length; t++)
    if (!s[t].equalsRange(e[t]))
      return !1;
  return !0;
}
class tP {
  constructor(e, t) {
    this.viewportStartModelPosition = e, this.startLineDelta = t;
  }
  recoverViewportStart(e, t) {
    if (!this.viewportStartModelPosition)
      return;
    const i = e.convertModelPositionToViewPosition(this.viewportStartModelPosition), n = t.getVerticalOffsetForLineNumber(i.lineNumber);
    t.setScrollPosition(
      { scrollTop: n + this.startLineDelta },
      1
      /* ScrollType.Immediate */
    );
  }
}
var Xre = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ya = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Kd, Vh;
let u_ = (Vh = class extends V {
  //#endregion
  get isSimpleWidget() {
    return this._configuration.isSimpleWidget;
  }
  get contextMenuId() {
    return this._configuration.contextMenuId;
  }
  constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
    super(), this.languageConfigurationService = h, this._deliveryQueue = jz(), this._contributions = this._register(new tre()), this._onDidDispose = this._register(new B()), this.onDidDispose = this._onDidDispose.event, this._onDidChangeModelContent = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelContent = this._onDidChangeModelContent.event, this._onDidChangeModelLanguage = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguage = this._onDidChangeModelLanguage.event, this._onDidChangeModelLanguageConfiguration = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelLanguageConfiguration = this._onDidChangeModelLanguageConfiguration.event, this._onDidChangeModelOptions = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelOptions = this._onDidChangeModelOptions.event, this._onDidChangeModelDecorations = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelDecorations = this._onDidChangeModelDecorations.event, this._onDidChangeModelTokens = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModelTokens = this._onDidChangeModelTokens.event, this._onDidChangeConfiguration = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeConfiguration = this._onDidChangeConfiguration.event, this._onWillChangeModel = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onWillChangeModel = this._onWillChangeModel.event, this._onDidChangeModel = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeModel = this._onDidChangeModel.event, this._onDidChangeCursorPosition = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorPosition = this._onDidChangeCursorPosition.event, this._onDidChangeCursorSelection = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeCursorSelection = this._onDidChangeCursorSelection.event, this._onDidAttemptReadOnlyEdit = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDidAttemptReadOnlyEdit = this._onDidAttemptReadOnlyEdit.event, this._onDidLayoutChange = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidLayoutChange = this._onDidLayoutChange.event, this._editorTextFocus = this._register(new iP({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorText = this._editorTextFocus.onDidChangeToTrue, this.onDidBlurEditorText = this._editorTextFocus.onDidChangeToFalse, this._editorWidgetFocus = this._register(new iP({ deliveryQueue: this._deliveryQueue })), this.onDidFocusEditorWidget = this._editorWidgetFocus.onDidChangeToTrue, this.onDidBlurEditorWidget = this._editorWidgetFocus.onDidChangeToFalse, this._onWillType = this._register(new fn(this._contributions, this._deliveryQueue)), this.onWillType = this._onWillType.event, this._onDidType = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDidType = this._onDidType.event, this._onDidCompositionStart = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDidCompositionStart = this._onDidCompositionStart.event, this._onDidCompositionEnd = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDidCompositionEnd = this._onDidCompositionEnd.event, this._onDidPaste = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDidPaste = this._onDidPaste.event, this._onMouseUp = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseUp = this._onMouseUp.event, this._onMouseDown = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseDown = this._onMouseDown.event, this._onMouseDrag = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseDrag = this._onMouseDrag.event, this._onMouseDrop = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseDrop = this._onMouseDrop.event, this._onMouseDropCanceled = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseDropCanceled = this._onMouseDropCanceled.event, this._onDropIntoEditor = this._register(new fn(this._contributions, this._deliveryQueue)), this.onDropIntoEditor = this._onDropIntoEditor.event, this._onContextMenu = this._register(new fn(this._contributions, this._deliveryQueue)), this.onContextMenu = this._onContextMenu.event, this._onMouseMove = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseMove = this._onMouseMove.event, this._onMouseLeave = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseLeave = this._onMouseLeave.event, this._onMouseWheel = this._register(new fn(this._contributions, this._deliveryQueue)), this.onMouseWheel = this._onMouseWheel.event, this._onKeyUp = this._register(new fn(this._contributions, this._deliveryQueue)), this.onKeyUp = this._onKeyUp.event, this._onKeyDown = this._register(new fn(this._contributions, this._deliveryQueue)), this.onKeyDown = this._onKeyDown.event, this._onDidContentSizeChange = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidContentSizeChange = this._onDidContentSizeChange.event, this._onDidScrollChange = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidScrollChange = this._onDidScrollChange.event, this._onDidChangeViewZones = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeViewZones = this._onDidChangeViewZones.event, this._onDidChangeHiddenAreas = this._register(new B({ deliveryQueue: this._deliveryQueue })), this.onDidChangeHiddenAreas = this._onDidChangeHiddenAreas.event, this._updateCounter = 0, this._onBeginUpdate = this._register(new B()), this.onBeginUpdate = this._onBeginUpdate.event, this._onEndUpdate = this._register(new B()), this.onEndUpdate = this._onEndUpdate.event, this._actions = /* @__PURE__ */ new Map(), this._bannerDomNode = null, this._dropIntoEditorDecorations = this.createDecorationsCollection(), o.willCreateCodeEditor();
    const g = { ...t };
    this._domElement = e, this._overflowWidgetsDomNode = g.overflowWidgetsDomNode, delete g.overflowWidgetsDomNode, this._id = ++Zre, this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes = {}, this._telemetryData = i.telemetryData, this._configuration = this._register(this._createConfiguration(i.isSimpleWidget || !1, i.contextMenuId ?? (i.isSimpleWidget ? Qe.SimpleEditorContext : Qe.EditorContext), g, d)), this._register(this._configuration.onDidChange((A) => {
      this._onDidChangeConfiguration.fire(A);
      const _ = this._configuration.options;
      if (A.hasChanged(
        146
        /* EditorOption.layoutInfo */
      )) {
        const b = _.get(
          146
          /* EditorOption.layoutInfo */
        );
        this._onDidLayoutChange.fire(b);
      }
    })), this._contextKeyService = this._register(a.createScoped(this._domElement)), this._notificationService = c, this._codeEditorService = o, this._commandService = r, this._themeService = l, this._register(new tae(this, this._contextKeyService)), this._register(new iae(this, this._contextKeyService, u)), this._instantiationService = this._register(n.createChild(new Lm([Se, this._contextKeyService]))), this._modelData = null, this._focusTracker = new nae(e, this._overflowWidgetsDomNode), this._register(this._focusTracker.onChange(() => {
      this._editorWidgetFocus.setValue(this._focusTracker.hasFocus());
    })), this._contentWidgets = {}, this._overlayWidgets = {}, this._glyphMarginWidgets = {};
    let m;
    Array.isArray(i.contributions) ? m = i.contributions : m = pf.getEditorContributions(), this._contributions.initialize(this, m, this._instantiationService);
    for (const A of pf.getEditorActions()) {
      if (this._actions.has(A.id)) {
        Pe(new Error(`Cannot have two actions with the same id ${A.id}`));
        continue;
      }
      const _ = new W8(A.id, A.label, A.alias, A.metadata, A.precondition ?? void 0, (b) => this._instantiationService.invokeFunction((C) => Promise.resolve(A.runEditorCommand(C, this, b))), this._contextKeyService);
      this._actions.set(_.id, _);
    }
    const p = () => !this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) && this._configuration.options.get(
      36
      /* EditorOption.dropIntoEditor */
    ).enabled;
    this._register(new tU(this._domElement, {
      onDragOver: (A) => {
        if (!p())
          return;
        const _ = this.getTargetAtClientPoint(A.clientX, A.clientY);
        _?.position && this.showDropIndicatorAt(_.position);
      },
      onDrop: async (A) => {
        if (!p() || (this.removeDropIndicator(), !A.dataTransfer))
          return;
        const _ = this.getTargetAtClientPoint(A.clientX, A.clientY);
        _?.position && this._onDropIntoEditor.fire({ position: _.position, event: A });
      },
      onDragLeave: () => {
        this.removeDropIndicator();
      },
      onDragEnd: () => {
        this.removeDropIndicator();
      }
    })), this._codeEditorService.addCodeEditor(this);
  }
  writeScreenReaderContent(e) {
    this._modelData?.view.writeScreenReaderContent(e);
  }
  _createConfiguration(e, t, i, n) {
    return new fD(e, t, i, this._domElement, n);
  }
  getId() {
    return this.getEditorType() + ":" + this._id;
  }
  getEditorType() {
    return wS.ICodeEditor;
  }
  dispose() {
    this._codeEditorService.removeCodeEditor(this), this._focusTracker.dispose(), this._actions.clear(), this._contentWidgets = {}, this._overlayWidgets = {}, this._removeDecorationTypes(), this._postDetachModelCleanup(this._detachModel()), this._onDidDispose.fire(), super.dispose();
  }
  invokeWithinContext(e) {
    return this._instantiationService.invokeFunction(e);
  }
  updateOptions(e) {
    this._configuration.updateOptions(e || {});
  }
  getOptions() {
    return this._configuration.options;
  }
  getOption(e) {
    return this._configuration.options.get(e);
  }
  getRawOptions() {
    return this._configuration.getRawOptions();
  }
  getOverflowWidgetsDomNode() {
    return this._overflowWidgetsDomNode;
  }
  getConfiguredWordAtPosition(e) {
    return this._modelData ? Wt.getWordAtPosition(this._modelData.model, this._configuration.options.get(
      132
      /* EditorOption.wordSeparators */
    ), this._configuration.options.get(
      131
      /* EditorOption.wordSegmenterLocales */
    ), e) : null;
  }
  getValue(e = null) {
    if (!this._modelData)
      return "";
    const t = !!(e && e.preserveBOM);
    let i = 0;
    return e && e.lineEnding && e.lineEnding === `
` ? i = 1 : e && e.lineEnding && e.lineEnding === `\r
` && (i = 2), this._modelData.model.getValue(i, t);
  }
  setValue(e) {
    try {
      if (this._beginUpdate(), !this._modelData)
        return;
      this._modelData.model.setValue(e);
    } finally {
      this._endUpdate();
    }
  }
  getModel() {
    return this._modelData ? this._modelData.model : null;
  }
  setModel(e = null) {
    try {
      this._beginUpdate();
      const t = e;
      if (this._modelData === null && t === null || this._modelData && this._modelData.model === t)
        return;
      const i = {
        oldModelUrl: this._modelData?.model.uri || null,
        newModelUrl: t?.uri || null
      };
      this._onWillChangeModel.fire(i);
      const n = this.hasTextFocus(), o = this._detachModel();
      this._attachModel(t), n && this.hasModel() && this.focus(), this._removeDecorationTypes(), this._onDidChangeModel.fire(i), this._postDetachModelCleanup(o), this._contributionsDisposable = this._contributions.onAfterModelAttached();
    } finally {
      this._endUpdate();
    }
  }
  _removeDecorationTypes() {
    if (this._decorationTypeKeysToIds = {}, this._decorationTypeSubtypes) {
      for (const e in this._decorationTypeSubtypes) {
        const t = this._decorationTypeSubtypes[e];
        for (const i in t)
          this._removeDecorationType(e + "-" + i);
      }
      this._decorationTypeSubtypes = {};
    }
  }
  getVisibleRanges() {
    return this._modelData ? this._modelData.viewModel.getVisibleRanges() : [];
  }
  getVisibleRangesPlusViewportAboveBelow() {
    return this._modelData ? this._modelData.viewModel.getVisibleRangesPlusViewportAboveBelow() : [];
  }
  getWhitespaces() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getWhitespaces() : [];
  }
  static _getVerticalOffsetAfterPosition(e, t, i, n) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetAfterLineNumber(r.lineNumber, n);
  }
  getTopForLineNumber(e, t = !1) {
    return this._modelData ? Kd._getVerticalOffsetForPosition(this._modelData, e, 1, t) : -1;
  }
  getTopForPosition(e, t) {
    return this._modelData ? Kd._getVerticalOffsetForPosition(this._modelData, e, t, !1) : -1;
  }
  static _getVerticalOffsetForPosition(e, t, i, n = !1) {
    const o = e.model.validatePosition({
      lineNumber: t,
      column: i
    }), r = e.viewModel.coordinatesConverter.convertModelPositionToViewPosition(o);
    return e.viewModel.viewLayout.getVerticalOffsetForLineNumber(r.lineNumber, n);
  }
  getBottomForLineNumber(e, t = !1) {
    if (!this._modelData)
      return -1;
    const i = this._modelData.model.getLineMaxColumn(e);
    return Kd._getVerticalOffsetAfterPosition(this._modelData, e, i, t);
  }
  setHiddenAreas(e, t) {
    this._modelData?.viewModel.setHiddenAreas(e.map((i) => E.lift(i)), t);
  }
  getVisibleColumnFromPosition(e) {
    if (!this._modelData)
      return e.column;
    const t = this._modelData.model.validatePosition(e), i = this._modelData.model.getOptions().tabSize;
    return wi.visibleColumnFromColumn(this._modelData.model.getLineContent(t.lineNumber), t.column, i) + 1;
  }
  getPosition() {
    return this._modelData ? this._modelData.viewModel.getPosition() : null;
  }
  setPosition(e, t = "api") {
    if (this._modelData) {
      if (!F.isIPosition(e))
        throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, [{
        selectionStartLineNumber: e.lineNumber,
        selectionStartColumn: e.column,
        positionLineNumber: e.lineNumber,
        positionColumn: e.column
      }]);
    }
  }
  _sendRevealRange(e, t, i, n) {
    if (!this._modelData)
      return;
    if (!E.isIRange(e))
      throw new Error("Invalid arguments");
    const o = this._modelData.model.validateRange(e), r = this._modelData.viewModel.coordinatesConverter.convertModelRangeToViewRange(o);
    this._modelData.viewModel.revealRange("api", i, r, t, n);
  }
  revealLine(e, t = 0) {
    this._revealLine(e, 0, t);
  }
  revealLineInCenter(e, t = 0) {
    this._revealLine(e, 1, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._revealLine(e, 2, t);
  }
  revealLineNearTop(e, t = 0) {
    this._revealLine(e, 5, t);
  }
  _revealLine(e, t, i) {
    if (typeof e != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new E(e, 1, e, 1), t, !1, i);
  }
  revealPosition(e, t = 0) {
    this._revealPosition(e, 0, !0, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._revealPosition(e, 1, !0, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._revealPosition(e, 2, !0, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._revealPosition(e, 5, !0, t);
  }
  _revealPosition(e, t, i, n) {
    if (!F.isIPosition(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(new E(e.lineNumber, e.column, e.lineNumber, e.column), t, i, n);
  }
  getSelection() {
    return this._modelData ? this._modelData.viewModel.getSelection() : null;
  }
  getSelections() {
    return this._modelData ? this._modelData.viewModel.getSelections() : null;
  }
  setSelection(e, t = "api") {
    const i = Ue.isISelection(e), n = E.isIRange(e);
    if (!i && !n)
      throw new Error("Invalid arguments");
    if (i)
      this._setSelectionImpl(e, t);
    else if (n) {
      const o = {
        selectionStartLineNumber: e.startLineNumber,
        selectionStartColumn: e.startColumn,
        positionLineNumber: e.endLineNumber,
        positionColumn: e.endColumn
      };
      this._setSelectionImpl(o, t);
    }
  }
  _setSelectionImpl(e, t) {
    if (!this._modelData)
      return;
    const i = new Ue(e.selectionStartLineNumber, e.selectionStartColumn, e.positionLineNumber, e.positionColumn);
    this._modelData.viewModel.setSelections(t, [i]);
  }
  revealLines(e, t, i = 0) {
    this._revealLines(e, t, 0, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._revealLines(e, t, 1, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._revealLines(e, t, 2, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._revealLines(e, t, 5, i);
  }
  _revealLines(e, t, i, n) {
    if (typeof e != "number" || typeof t != "number")
      throw new Error("Invalid arguments");
    this._sendRevealRange(new E(e, 1, t, 1), i, !1, n);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._revealRange(e, i ? 1 : 0, n, t);
  }
  revealRangeInCenter(e, t = 0) {
    this._revealRange(e, 1, !0, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 2, !0, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._revealRange(e, 5, !0, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._revealRange(e, 6, !0, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._revealRange(e, 3, !0, t);
  }
  _revealRange(e, t, i, n) {
    if (!E.isIRange(e))
      throw new Error("Invalid arguments");
    this._sendRevealRange(E.lift(e), t, i, n);
  }
  setSelections(e, t = "api", i = 0) {
    if (this._modelData) {
      if (!e || e.length === 0)
        throw new Error("Invalid arguments");
      for (let n = 0, o = e.length; n < o; n++)
        if (!Ue.isISelection(e[n]))
          throw new Error("Invalid arguments");
      this._modelData.viewModel.setSelections(t, e, i);
    }
  }
  getContentWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentWidth() : -1;
  }
  getScrollWidth() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollWidth() : -1;
  }
  getScrollLeft() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollLeft() : -1;
  }
  getContentHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getContentHeight() : -1;
  }
  getScrollHeight() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getScrollHeight() : -1;
  }
  getScrollTop() {
    return this._modelData ? this._modelData.viewModel.viewLayout.getCurrentScrollTop() : -1;
  }
  setScrollLeft(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollLeft: e
      }, t);
    }
  }
  setScrollTop(e, t = 1) {
    if (this._modelData) {
      if (typeof e != "number")
        throw new Error("Invalid arguments");
      this._modelData.viewModel.viewLayout.setScrollPosition({
        scrollTop: e
      }, t);
    }
  }
  setScrollPosition(e, t = 1) {
    this._modelData && this._modelData.viewModel.viewLayout.setScrollPosition(e, t);
  }
  hasPendingScrollAnimation() {
    return this._modelData ? this._modelData.viewModel.viewLayout.hasPendingScrollAnimation() : !1;
  }
  saveViewState() {
    if (!this._modelData)
      return null;
    const e = this._contributions.saveViewState(), t = this._modelData.viewModel.saveCursorState(), i = this._modelData.viewModel.saveState();
    return {
      cursorState: t,
      viewState: i,
      contributionsState: e
    };
  }
  restoreViewState(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return;
    const t = e;
    if (t && t.cursorState && t.viewState) {
      const i = t.cursorState;
      Array.isArray(i) ? i.length > 0 && this._modelData.viewModel.restoreCursorState(i) : this._modelData.viewModel.restoreCursorState([i]), this._contributions.restoreViewState(t.contributionsState || {});
      const n = this._modelData.viewModel.reduceRestoreState(t.viewState);
      this._modelData.view.restoreState(n);
    }
  }
  handleInitialized() {
    this._getViewModel()?.visibleLinesStabilized();
  }
  getContribution(e) {
    return this._contributions.get(e);
  }
  getActions() {
    return Array.from(this._actions.values());
  }
  getSupportedActions() {
    let e = this.getActions();
    return e = e.filter((t) => t.isSupported()), e;
  }
  getAction(e) {
    return this._actions.get(e) || null;
  }
  trigger(e, t, i) {
    i = i || {};
    try {
      switch (this._beginUpdate(), t) {
        case "compositionStart":
          this._startComposition();
          return;
        case "compositionEnd":
          this._endComposition(e);
          return;
        case "type": {
          const o = i;
          this._type(e, o.text || "");
          return;
        }
        case "replacePreviousChar": {
          const o = i;
          this._compositionType(e, o.text || "", o.replaceCharCnt || 0, 0, 0);
          return;
        }
        case "compositionType": {
          const o = i;
          this._compositionType(e, o.text || "", o.replacePrevCharCnt || 0, o.replaceNextCharCnt || 0, o.positionDelta || 0);
          return;
        }
        case "paste": {
          const o = i;
          this._paste(e, o.text || "", o.pasteOnNewLine || !1, o.multicursorText || null, o.mode || null, o.clipboardEvent);
          return;
        }
        case "cut":
          this._cut(e);
          return;
      }
      const n = this.getAction(t);
      if (n) {
        Promise.resolve(n.run(i)).then(void 0, Pe);
        return;
      }
      if (!this._modelData || this._triggerEditorCommand(e, t, i))
        return;
      this._triggerCommand(t, i);
    } finally {
      this._endUpdate();
    }
  }
  _triggerCommand(e, t) {
    this._commandService.executeCommand(e, t);
  }
  _startComposition() {
    this._modelData && (this._modelData.viewModel.startComposition(), this._onDidCompositionStart.fire());
  }
  _endComposition(e) {
    this._modelData && (this._modelData.viewModel.endComposition(e), this._onDidCompositionEnd.fire());
  }
  _type(e, t) {
    !this._modelData || t.length === 0 || (e === "keyboard" && this._onWillType.fire(t), this._modelData.viewModel.type(t, e), e === "keyboard" && this._onDidType.fire(t));
  }
  _compositionType(e, t, i, n, o) {
    this._modelData && this._modelData.viewModel.compositionType(t, i, n, o, e);
  }
  _paste(e, t, i, n, o, r) {
    if (!this._modelData)
      return;
    const a = this._modelData.viewModel, l = a.getSelection().getStartPosition();
    a.paste(t, i, n, e);
    const c = a.getSelection().getStartPosition();
    e === "keyboard" && this._onDidPaste.fire({
      clipboardEvent: r,
      range: new E(l.lineNumber, l.column, c.lineNumber, c.column),
      languageId: o
    });
  }
  _cut(e) {
    this._modelData && this._modelData.viewModel.cut(e);
  }
  _triggerEditorCommand(e, t, i) {
    const n = pf.getEditorCommand(t);
    return n ? (i = i || {}, i.source = e, this._instantiationService.invokeFunction((o) => {
      Promise.resolve(n.runEditorCommand(o, this, i)).then(void 0, Pe);
    }), !0) : !1;
  }
  _getViewModel() {
    return this._modelData ? this._modelData.viewModel : null;
  }
  pushUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.pushStackElement(), !0);
  }
  popUndoStop() {
    return !this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ) ? !1 : (this._modelData.model.popStackElement(), !0);
  }
  executeEdits(e, t, i) {
    if (!this._modelData || this._configuration.options.get(
      92
      /* EditorOption.readOnly */
    ))
      return !1;
    let n;
    return i ? Array.isArray(i) ? n = () => i : n = i : n = () => null, this._modelData.viewModel.executeEdits(e, t, n), !0;
  }
  executeCommand(e, t) {
    this._modelData && this._modelData.viewModel.executeCommand(t, e);
  }
  executeCommands(e, t) {
    this._modelData && this._modelData.viewModel.executeCommands(t, e);
  }
  createDecorationsCollection(e) {
    return new sae(this, e);
  }
  changeDecorations(e) {
    return this._modelData ? this._modelData.model.changeDecorations(e, this._id) : null;
  }
  getLineDecorations(e) {
    return this._modelData ? this._modelData.model.getLineDecorations(e, this._id, Jw(this._configuration.options)) : null;
  }
  getDecorationsInRange(e) {
    return this._modelData ? this._modelData.model.getDecorationsInRange(e, this._id, Jw(this._configuration.options)) : null;
  }
  /**
   * @deprecated
   */
  deltaDecorations(e, t) {
    return this._modelData ? e.length === 0 && t.length === 0 ? e : this._modelData.model.deltaDecorations(e, t, this._id) : [];
  }
  removeDecorations(e) {
    !this._modelData || e.length === 0 || this._modelData.model.changeDecorations((t) => {
      t.deltaDecorations(e, []);
    });
  }
  removeDecorationsByType(e) {
    const t = this._decorationTypeKeysToIds[e];
    t && this.changeDecorations((i) => i.deltaDecorations(t, [])), this._decorationTypeKeysToIds.hasOwnProperty(e) && delete this._decorationTypeKeysToIds[e], this._decorationTypeSubtypes.hasOwnProperty(e) && delete this._decorationTypeSubtypes[e];
  }
  getLayoutInfo() {
    return this._configuration.options.get(
      146
      /* EditorOption.layoutInfo */
    );
  }
  createOverviewRuler(e) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.createOverviewRuler(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getDomNode() {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.domNode.domNode;
  }
  delegateVerticalScrollbarPointerDown(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateVerticalScrollbarPointerDown(e);
  }
  delegateScrollFromMouseWheelEvent(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.delegateScrollFromMouseWheelEvent(e);
  }
  layout(e, t = !1) {
    this._configuration.observeContainer(e), t || this.render();
  }
  focus() {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.focus();
  }
  hasTextFocus() {
    return !this._modelData || !this._modelData.hasRealView ? !1 : this._modelData.view.isFocused();
  }
  hasWidgetFocus() {
    return this._focusTracker && this._focusTracker.hasFocus();
  }
  addContentWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._contentWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a content widget with the same id:" + e.getId()), this._contentWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addContentWidget(t);
  }
  layoutContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutContentWidget(i);
    }
  }
  removeContentWidget(e) {
    const t = e.getId();
    if (this._contentWidgets.hasOwnProperty(t)) {
      const i = this._contentWidgets[t];
      delete this._contentWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeContentWidget(i);
    }
  }
  addOverlayWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._overlayWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting an overlay widget with the same id."), this._overlayWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addOverlayWidget(t);
  }
  layoutOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutOverlayWidget(i);
    }
  }
  removeOverlayWidget(e) {
    const t = e.getId();
    if (this._overlayWidgets.hasOwnProperty(t)) {
      const i = this._overlayWidgets[t];
      delete this._overlayWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeOverlayWidget(i);
    }
  }
  addGlyphMarginWidget(e) {
    const t = {
      widget: e,
      position: e.getPosition()
    };
    this._glyphMarginWidgets.hasOwnProperty(e.getId()) && console.warn("Overwriting a glyph margin widget with the same id."), this._glyphMarginWidgets[e.getId()] = t, this._modelData && this._modelData.hasRealView && this._modelData.view.addGlyphMarginWidget(t);
  }
  layoutGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      i.position = e.getPosition(), this._modelData && this._modelData.hasRealView && this._modelData.view.layoutGlyphMarginWidget(i);
    }
  }
  removeGlyphMarginWidget(e) {
    const t = e.getId();
    if (this._glyphMarginWidgets.hasOwnProperty(t)) {
      const i = this._glyphMarginWidgets[t];
      delete this._glyphMarginWidgets[t], this._modelData && this._modelData.hasRealView && this._modelData.view.removeGlyphMarginWidget(i);
    }
  }
  changeViewZones(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.change(e);
  }
  getTargetAtClientPoint(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? null : this._modelData.view.getTargetAtClientPoint(e, t);
  }
  getScrolledVisiblePosition(e) {
    if (!this._modelData || !this._modelData.hasRealView)
      return null;
    const t = this._modelData.model.validatePosition(e), i = this._configuration.options, n = i.get(
      146
      /* EditorOption.layoutInfo */
    ), o = Kd._getVerticalOffsetForPosition(this._modelData, t.lineNumber, t.column) - this.getScrollTop(), r = this._modelData.view.getOffsetForColumn(t.lineNumber, t.column) + n.glyphMarginWidth + n.lineNumbersWidth + n.decorationsWidth - this.getScrollLeft();
    return {
      top: o,
      left: r,
      height: i.get(
        67
        /* EditorOption.lineHeight */
      )
    };
  }
  getOffsetForColumn(e, t) {
    return !this._modelData || !this._modelData.hasRealView ? -1 : this._modelData.view.getOffsetForColumn(e, t);
  }
  render(e = !1) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.viewModel.batchEvents(() => {
      this._modelData.view.render(!0, e);
    });
  }
  setAriaOptions(e) {
    !this._modelData || !this._modelData.hasRealView || this._modelData.view.setAriaOptions(e);
  }
  applyFontInfo(e) {
    cn(e, this._configuration.options.get(
      50
      /* EditorOption.fontInfo */
    ));
  }
  setBanner(e, t) {
    this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), this._bannerDomNode = e, this._configuration.setReservedHeight(e ? t : 0), this._bannerDomNode && this._domElement.prepend(this._bannerDomNode);
  }
  _attachModel(e) {
    if (!e) {
      this._modelData = null;
      return;
    }
    const t = [];
    this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._configuration.setIsDominatedByLongLines(e.isDominatedByLongLines()), this._configuration.setModelLineCount(e.getLineCount());
    const i = e.onBeforeAttached(), n = new Kre(this._id, this._configuration, e, HT.create(fe(this._domElement)), WT.create(this._configuration.options), (a) => ys(fe(this._domElement), a), this.languageConfigurationService, this._themeService, i, {
      batchChanges: (a) => {
        try {
          return this._beginUpdate(), a();
        } finally {
          this._endUpdate();
        }
      }
    });
    t.push(e.onWillDispose(() => this.setModel(null))), t.push(n.onEvent((a) => {
      switch (a.kind) {
        case 0:
          this._onDidContentSizeChange.fire(a);
          break;
        case 1:
          this._editorTextFocus.setValue(a.hasFocus);
          break;
        case 2:
          this._onDidScrollChange.fire(a);
          break;
        case 3:
          this._onDidChangeViewZones.fire();
          break;
        case 4:
          this._onDidChangeHiddenAreas.fire();
          break;
        case 5:
          this._onDidAttemptReadOnlyEdit.fire();
          break;
        case 6: {
          if (a.reachedMaxCursorCount) {
            const h = this.getOption(
              80
              /* EditorOption.multiCursorLimit */
            ), u = f("cursors.maximum", "The number of cursors has been limited to {0}. Consider using [find and replace](https://code.visualstudio.com/docs/editor/codebasics#_find-and-replace) for larger changes or increase the editor multi cursor limit setting.", h);
            this._notificationService.prompt(H0.Warning, u, [
              {
                label: "Find and Replace",
                run: () => {
                  this._commandService.executeCommand("editor.action.startFindReplaceAction");
                }
              },
              {
                label: f("goToSetting", "Increase Multi Cursor Limit"),
                run: () => {
                  this._commandService.executeCommand("workbench.action.openSettings2", {
                    query: "editor.multiCursorLimit"
                  });
                }
              }
            ]);
          }
          const l = [];
          for (let h = 0, u = a.selections.length; h < u; h++)
            l[h] = a.selections[h].getPosition();
          const c = {
            position: l[0],
            secondaryPositions: l.slice(1),
            reason: a.reason,
            source: a.source
          };
          this._onDidChangeCursorPosition.fire(c);
          const d = {
            selection: a.selections[0],
            secondarySelections: a.selections.slice(1),
            modelVersionId: a.modelVersionId,
            oldSelections: a.oldSelections,
            oldModelVersionId: a.oldModelVersionId,
            source: a.source,
            reason: a.reason
          };
          this._onDidChangeCursorSelection.fire(d);
          break;
        }
        case 7:
          this._onDidChangeModelDecorations.fire(a.event);
          break;
        case 8:
          this._domElement.setAttribute("data-mode-id", e.getLanguageId()), this._onDidChangeModelLanguage.fire(a.event);
          break;
        case 9:
          this._onDidChangeModelLanguageConfiguration.fire(a.event);
          break;
        case 10:
          this._onDidChangeModelContent.fire(a.event);
          break;
        case 11:
          this._onDidChangeModelOptions.fire(a.event);
          break;
        case 12:
          this._onDidChangeModelTokens.fire(a.event);
          break;
      }
    }));
    const [o, r] = this._createView(n);
    if (r) {
      this._domElement.appendChild(o.domNode.domNode);
      let a = Object.keys(this._contentWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const d = a[l];
        o.addContentWidget(this._contentWidgets[d]);
      }
      a = Object.keys(this._overlayWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const d = a[l];
        o.addOverlayWidget(this._overlayWidgets[d]);
      }
      a = Object.keys(this._glyphMarginWidgets);
      for (let l = 0, c = a.length; l < c; l++) {
        const d = a[l];
        o.addGlyphMarginWidget(this._glyphMarginWidgets[d]);
      }
      o.render(!1, !0), o.domNode.domNode.setAttribute("data-uri", e.uri.toString());
    }
    this._modelData = new eae(e, n, o, r, t, i);
  }
  _createView(e) {
    let t;
    this.isSimpleWidget ? t = {
      paste: (o, r, a, l) => {
        this._paste("keyboard", o, r, a, l);
      },
      type: (o) => {
        this._type("keyboard", o);
      },
      compositionType: (o, r, a, l) => {
        this._compositionType("keyboard", o, r, a, l);
      },
      startComposition: () => {
        this._startComposition();
      },
      endComposition: () => {
        this._endComposition("keyboard");
      },
      cut: () => {
        this._cut("keyboard");
      }
    } : t = {
      paste: (o, r, a, l) => {
        const c = { text: o, pasteOnNewLine: r, multicursorText: a, mode: l };
        this._commandService.executeCommand("paste", c);
      },
      type: (o) => {
        const r = { text: o };
        this._commandService.executeCommand("type", r);
      },
      compositionType: (o, r, a, l) => {
        if (a || l) {
          const c = { text: o, replacePrevCharCnt: r, replaceNextCharCnt: a, positionDelta: l };
          this._commandService.executeCommand("compositionType", c);
        } else {
          const c = { text: o, replaceCharCnt: r };
          this._commandService.executeCommand("replacePreviousChar", c);
        }
      },
      startComposition: () => {
        this._commandService.executeCommand("compositionStart", {});
      },
      endComposition: () => {
        this._commandService.executeCommand("compositionEnd", {});
      },
      cut: () => {
        this._commandService.executeCommand("cut", {});
      }
    };
    const i = new xS(e.coordinatesConverter);
    return i.onKeyDown = (o) => this._onKeyDown.fire(o), i.onKeyUp = (o) => this._onKeyUp.fire(o), i.onContextMenu = (o) => this._onContextMenu.fire(o), i.onMouseMove = (o) => this._onMouseMove.fire(o), i.onMouseLeave = (o) => this._onMouseLeave.fire(o), i.onMouseDown = (o) => this._onMouseDown.fire(o), i.onMouseUp = (o) => this._onMouseUp.fire(o), i.onMouseDrag = (o) => this._onMouseDrag.fire(o), i.onMouseDrop = (o) => this._onMouseDrop.fire(o), i.onMouseDropCanceled = (o) => this._onMouseDropCanceled.fire(o), i.onMouseWheel = (o) => this._onMouseWheel.fire(o), [new ED(t, this._configuration, this._themeService.getColorTheme(), e, i, this._overflowWidgetsDomNode, this._instantiationService), !0];
  }
  _postDetachModelCleanup(e) {
    e?.removeAllDecorationsWithOwnerId(this._id);
  }
  _detachModel() {
    if (this._contributionsDisposable?.dispose(), this._contributionsDisposable = void 0, !this._modelData)
      return null;
    const e = this._modelData.model, t = this._modelData.hasRealView ? this._modelData.view.domNode.domNode : null;
    return this._modelData.dispose(), this._modelData = null, this._domElement.removeAttribute("data-mode-id"), t && this._domElement.contains(t) && t.remove(), this._bannerDomNode && this._domElement.contains(this._bannerDomNode) && this._bannerDomNode.remove(), e;
  }
  _removeDecorationType(e) {
    this._codeEditorService.removeDecorationType(e);
  }
  hasModel() {
    return this._modelData !== null;
  }
  showDropIndicatorAt(e) {
    const t = [{
      range: new E(e.lineNumber, e.column, e.lineNumber, e.column),
      options: Kd.dropIntoEditorDecorationOptions
    }];
    this._dropIntoEditorDecorations.set(t), this.revealPosition(
      e,
      1
      /* editorCommon.ScrollType.Immediate */
    );
  }
  removeDropIndicator() {
    this._dropIntoEditorDecorations.clear();
  }
  setContextValue(e, t) {
    this._contextKeyService.createKey(e, t);
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && this._onBeginUpdate.fire();
  }
  _endUpdate() {
    this._updateCounter--, this._updateCounter === 0 && this._onEndUpdate.fire();
  }
}, Kd = Vh, Vh.dropIntoEditorDecorationOptions = He.register({
  description: "workbench-dnd-target",
  className: "dnd-target"
}), Vh);
u_ = Kd = Xre([
  Ya(3, ke),
  Ya(4, Nt),
  Ya(5, bi),
  Ya(6, Se),
  Ya(7, nn),
  Ya(8, Oi),
  Ya(9, Lo),
  Ya(10, tn),
  Ya(11, ye)
], u_);
let Zre = 0;
class eae {
  constructor(e, t, i, n, o, r) {
    this.model = e, this.viewModel = t, this.view = i, this.hasRealView = n, this.listenersToRemove = o, this.attachedView = r;
  }
  dispose() {
    Ct(this.listenersToRemove), this.model.onBeforeDetached(this.attachedView), this.hasRealView && this.view.dispose(), this.viewModel.dispose();
  }
}
class iP extends V {
  constructor(e) {
    super(), this._emitterOptions = e, this._onDidChangeToTrue = this._register(new B(this._emitterOptions)), this.onDidChangeToTrue = this._onDidChangeToTrue.event, this._onDidChangeToFalse = this._register(new B(this._emitterOptions)), this.onDidChangeToFalse = this._onDidChangeToFalse.event, this._value = 0;
  }
  setValue(e) {
    const t = e ? 2 : 1;
    this._value !== t && (this._value = t, this._value === 2 ? this._onDidChangeToTrue.fire() : this._value === 1 && this._onDidChangeToFalse.fire());
  }
}
class fn extends B {
  constructor(e, t) {
    super({ deliveryQueue: t }), this._contributions = e;
  }
  fire(e) {
    this._contributions.onBeforeInteractionEvent(), super.fire(e);
  }
}
class tae extends V {
  constructor(e, t) {
    super(), this._editor = e, t.createKey("editorId", e.getId()), this._editorSimpleInput = R.editorSimpleInput.bindTo(t), this._editorFocus = R.focus.bindTo(t), this._textInputFocus = R.textInputFocus.bindTo(t), this._editorTextFocus = R.editorTextFocus.bindTo(t), this._tabMovesFocus = R.tabMovesFocus.bindTo(t), this._editorReadonly = R.readOnly.bindTo(t), this._inDiffEditor = R.inDiffEditor.bindTo(t), this._editorColumnSelection = R.columnSelection.bindTo(t), this._hasMultipleSelections = R.hasMultipleSelections.bindTo(t), this._hasNonEmptySelection = R.hasNonEmptySelection.bindTo(t), this._canUndo = R.canUndo.bindTo(t), this._canRedo = R.canRedo.bindTo(t), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromConfig())), this._register(this._editor.onDidChangeCursorSelection(() => this._updateFromSelection())), this._register(this._editor.onDidFocusEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorWidget(() => this._updateFromFocus())), this._register(this._editor.onDidFocusEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidBlurEditorText(() => this._updateFromFocus())), this._register(this._editor.onDidChangeModel(() => this._updateFromModel())), this._register(this._editor.onDidChangeConfiguration(() => this._updateFromModel())), this._register(Av.onDidChangeTabFocus((i) => this._tabMovesFocus.set(i))), this._updateFromConfig(), this._updateFromSelection(), this._updateFromFocus(), this._updateFromModel(), this._editorSimpleInput.set(this._editor.isSimpleWidget);
  }
  _updateFromConfig() {
    const e = this._editor.getOptions();
    this._tabMovesFocus.set(Av.getTabFocusMode()), this._editorReadonly.set(e.get(
      92
      /* EditorOption.readOnly */
    )), this._inDiffEditor.set(e.get(
      61
      /* EditorOption.inDiffEditor */
    )), this._editorColumnSelection.set(e.get(
      22
      /* EditorOption.columnSelection */
    ));
  }
  _updateFromSelection() {
    const e = this._editor.getSelections();
    e ? (this._hasMultipleSelections.set(e.length > 1), this._hasNonEmptySelection.set(e.some((t) => !t.isEmpty()))) : (this._hasMultipleSelections.reset(), this._hasNonEmptySelection.reset());
  }
  _updateFromFocus() {
    this._editorFocus.set(this._editor.hasWidgetFocus() && !this._editor.isSimpleWidget), this._editorTextFocus.set(this._editor.hasTextFocus() && !this._editor.isSimpleWidget), this._textInputFocus.set(this._editor.hasTextFocus());
  }
  _updateFromModel() {
    const e = this._editor.getModel();
    this._canUndo.set(!!(e && e.canUndo())), this._canRedo.set(!!(e && e.canRedo()));
  }
}
class iae extends V {
  constructor(e, t, i) {
    super(), this._editor = e, this._contextKeyService = t, this._languageFeaturesService = i, this._langId = R.languageId.bindTo(t), this._hasCompletionItemProvider = R.hasCompletionItemProvider.bindTo(t), this._hasCodeActionsProvider = R.hasCodeActionsProvider.bindTo(t), this._hasCodeLensProvider = R.hasCodeLensProvider.bindTo(t), this._hasDefinitionProvider = R.hasDefinitionProvider.bindTo(t), this._hasDeclarationProvider = R.hasDeclarationProvider.bindTo(t), this._hasImplementationProvider = R.hasImplementationProvider.bindTo(t), this._hasTypeDefinitionProvider = R.hasTypeDefinitionProvider.bindTo(t), this._hasHoverProvider = R.hasHoverProvider.bindTo(t), this._hasDocumentHighlightProvider = R.hasDocumentHighlightProvider.bindTo(t), this._hasDocumentSymbolProvider = R.hasDocumentSymbolProvider.bindTo(t), this._hasReferenceProvider = R.hasReferenceProvider.bindTo(t), this._hasRenameProvider = R.hasRenameProvider.bindTo(t), this._hasSignatureHelpProvider = R.hasSignatureHelpProvider.bindTo(t), this._hasInlayHintsProvider = R.hasInlayHintsProvider.bindTo(t), this._hasDocumentFormattingProvider = R.hasDocumentFormattingProvider.bindTo(t), this._hasDocumentSelectionFormattingProvider = R.hasDocumentSelectionFormattingProvider.bindTo(t), this._hasMultipleDocumentFormattingProvider = R.hasMultipleDocumentFormattingProvider.bindTo(t), this._hasMultipleDocumentSelectionFormattingProvider = R.hasMultipleDocumentSelectionFormattingProvider.bindTo(t), this._isInEmbeddedEditor = R.isInEmbeddedEditor.bindTo(t);
    const n = () => this._update();
    this._register(e.onDidChangeModel(n)), this._register(e.onDidChangeModelLanguage(n)), this._register(i.completionProvider.onDidChange(n)), this._register(i.codeActionProvider.onDidChange(n)), this._register(i.codeLensProvider.onDidChange(n)), this._register(i.definitionProvider.onDidChange(n)), this._register(i.declarationProvider.onDidChange(n)), this._register(i.implementationProvider.onDidChange(n)), this._register(i.typeDefinitionProvider.onDidChange(n)), this._register(i.hoverProvider.onDidChange(n)), this._register(i.documentHighlightProvider.onDidChange(n)), this._register(i.documentSymbolProvider.onDidChange(n)), this._register(i.referenceProvider.onDidChange(n)), this._register(i.renameProvider.onDidChange(n)), this._register(i.documentFormattingEditProvider.onDidChange(n)), this._register(i.documentRangeFormattingEditProvider.onDidChange(n)), this._register(i.signatureHelpProvider.onDidChange(n)), this._register(i.inlayHintsProvider.onDidChange(n)), n();
  }
  dispose() {
    super.dispose();
  }
  reset() {
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.reset(), this._hasCompletionItemProvider.reset(), this._hasCodeActionsProvider.reset(), this._hasCodeLensProvider.reset(), this._hasDefinitionProvider.reset(), this._hasDeclarationProvider.reset(), this._hasImplementationProvider.reset(), this._hasTypeDefinitionProvider.reset(), this._hasHoverProvider.reset(), this._hasDocumentHighlightProvider.reset(), this._hasDocumentSymbolProvider.reset(), this._hasReferenceProvider.reset(), this._hasRenameProvider.reset(), this._hasDocumentFormattingProvider.reset(), this._hasDocumentSelectionFormattingProvider.reset(), this._hasSignatureHelpProvider.reset(), this._isInEmbeddedEditor.reset();
    });
  }
  _update() {
    const e = this._editor.getModel();
    if (!e) {
      this.reset();
      return;
    }
    this._contextKeyService.bufferChangeEvents(() => {
      this._langId.set(e.getLanguageId()), this._hasCompletionItemProvider.set(this._languageFeaturesService.completionProvider.has(e)), this._hasCodeActionsProvider.set(this._languageFeaturesService.codeActionProvider.has(e)), this._hasCodeLensProvider.set(this._languageFeaturesService.codeLensProvider.has(e)), this._hasDefinitionProvider.set(this._languageFeaturesService.definitionProvider.has(e)), this._hasDeclarationProvider.set(this._languageFeaturesService.declarationProvider.has(e)), this._hasImplementationProvider.set(this._languageFeaturesService.implementationProvider.has(e)), this._hasTypeDefinitionProvider.set(this._languageFeaturesService.typeDefinitionProvider.has(e)), this._hasHoverProvider.set(this._languageFeaturesService.hoverProvider.has(e)), this._hasDocumentHighlightProvider.set(this._languageFeaturesService.documentHighlightProvider.has(e)), this._hasDocumentSymbolProvider.set(this._languageFeaturesService.documentSymbolProvider.has(e)), this._hasReferenceProvider.set(this._languageFeaturesService.referenceProvider.has(e)), this._hasRenameProvider.set(this._languageFeaturesService.renameProvider.has(e)), this._hasSignatureHelpProvider.set(this._languageFeaturesService.signatureHelpProvider.has(e)), this._hasInlayHintsProvider.set(this._languageFeaturesService.inlayHintsProvider.has(e)), this._hasDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.has(e) || this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.has(e)), this._hasMultipleDocumentFormattingProvider.set(this._languageFeaturesService.documentFormattingEditProvider.all(e).length + this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._hasMultipleDocumentSelectionFormattingProvider.set(this._languageFeaturesService.documentRangeFormattingEditProvider.all(e).length > 1), this._isInEmbeddedEditor.set(e.uri.scheme === Ie.walkThroughSnippet || e.uri.scheme === Ie.vscodeChatCodeBlock);
    });
  }
}
class nae extends V {
  constructor(e, t) {
    super(), this._onChange = this._register(new B()), this.onChange = this._onChange.event, this._hadFocus = void 0, this._hasDomElementFocus = !1, this._domFocusTracker = this._register(Wl(e)), this._overflowWidgetsDomNodeHasFocus = !1, this._register(this._domFocusTracker.onDidFocus(() => {
      this._hasDomElementFocus = !0, this._update();
    })), this._register(this._domFocusTracker.onDidBlur(() => {
      this._hasDomElementFocus = !1, this._update();
    })), t && (this._overflowWidgetsDomNode = this._register(Wl(t)), this._register(this._overflowWidgetsDomNode.onDidFocus(() => {
      this._overflowWidgetsDomNodeHasFocus = !0, this._update();
    })), this._register(this._overflowWidgetsDomNode.onDidBlur(() => {
      this._overflowWidgetsDomNodeHasFocus = !1, this._update();
    })));
  }
  _update() {
    const e = this._hasDomElementFocus || this._overflowWidgetsDomNodeHasFocus;
    this._hadFocus !== e && (this._hadFocus = e, this._onChange.fire(void 0));
  }
  hasFocus() {
    return this._hadFocus ?? !1;
  }
}
class sae {
  get length() {
    return this._decorationIds.length;
  }
  constructor(e, t) {
    this._editor = e, this._decorationIds = [], this._isChangingDecorations = !1, Array.isArray(t) && t.length > 0 && this.set(t);
  }
  onDidChange(e, t, i) {
    return this._editor.onDidChangeModelDecorations((n) => {
      this._isChangingDecorations || e.call(t, n);
    }, i);
  }
  getRange(e) {
    return !this._editor.hasModel() || e >= this._decorationIds.length ? null : this._editor.getModel().getDecorationRange(this._decorationIds[e]);
  }
  getRanges() {
    if (!this._editor.hasModel())
      return [];
    const e = this._editor.getModel(), t = [];
    for (const i of this._decorationIds) {
      const n = e.getDecorationRange(i);
      n && t.push(n);
    }
    return t;
  }
  has(e) {
    return this._decorationIds.includes(e.id);
  }
  clear() {
    this._decorationIds.length !== 0 && this.set([]);
  }
  set(e) {
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((t) => {
        this._decorationIds = t.deltaDecorations(this._decorationIds, e);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return this._decorationIds;
  }
  append(e) {
    let t = [];
    try {
      this._isChangingDecorations = !0, this._editor.changeDecorations((i) => {
        t = i.deltaDecorations([], e), this._decorationIds = this._decorationIds.concat(t);
      });
    } finally {
      this._isChangingDecorations = !1;
    }
    return t;
  }
}
const oae = encodeURIComponent("<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 6 3' enable-background='new 0 0 6 3' height='3' width='6'><g fill='"), rae = encodeURIComponent("'><polygon points='5.5,0 2.5,3 1.1,3 4.1,0'/><polygon points='4,0 6,2 6,0.6 5.4,0'/><polygon points='0,2 1,3 2.4,3 0,0.6'/></g></svg>");
function ax(s) {
  return oae + encodeURIComponent(s.toString()) + rae;
}
const aae = encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" height="3" width="12"><g fill="'), lae = encodeURIComponent('"><circle cx="1" cy="1" r="1"/><circle cx="5" cy="1" r="1"/><circle cx="9" cy="1" r="1"/></g></svg>');
function cae(s) {
  return aae + encodeURIComponent(s.toString()) + lae;
}
rr((s, e) => {
  const t = s.getColor(U0);
  t && e.addRule(`.monaco-editor .squiggly-error { background: url("data:image/svg+xml,${ax(t)}") repeat-x bottom left; }`);
  const i = s.getColor(zl);
  i && e.addRule(`.monaco-editor .squiggly-warning { background: url("data:image/svg+xml,${ax(i)}") repeat-x bottom left; }`);
  const n = s.getColor(Da);
  n && e.addRule(`.monaco-editor .squiggly-info { background: url("data:image/svg+xml,${ax(n)}") repeat-x bottom left; }`);
  const o = s.getColor(zj);
  o && e.addRule(`.monaco-editor .squiggly-hint { background: url("data:image/svg+xml,${cae(o)}") no-repeat bottom left; }`);
  const r = s.getColor(EX);
  r && e.addRule(`.monaco-editor.showUnused .squiggly-inline-unnecessary { opacity: ${r.rgba.a}; }`);
});
class gd {
  static capture(e) {
    if (e.getScrollTop() === 0 || e.hasPendingScrollAnimation())
      return new gd(e.getScrollTop(), e.getContentHeight(), null, 0, null);
    let t = null, i = 0;
    const n = e.getVisibleRanges();
    if (n.length > 0) {
      t = n[0].getStartPosition();
      const o = e.getTopForPosition(t.lineNumber, t.column);
      i = e.getScrollTop() - o;
    }
    return new gd(e.getScrollTop(), e.getContentHeight(), t, i, e.getPosition());
  }
  constructor(e, t, i, n, o) {
    this._initialScrollTop = e, this._initialContentHeight = t, this._visiblePosition = i, this._visiblePositionScrollDelta = n, this._cursorPosition = o;
  }
  restore(e) {
    if (!(this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop()) && this._visiblePosition) {
      const t = e.getTopForPosition(this._visiblePosition.lineNumber, this._visiblePosition.column);
      e.setScrollTop(t + this._visiblePositionScrollDelta);
    }
  }
  restoreRelativeVerticalPositionOfCursor(e) {
    if (this._initialContentHeight === e.getContentHeight() && this._initialScrollTop === e.getScrollTop())
      return;
    const t = e.getPosition();
    if (!this._cursorPosition || !t)
      return;
    const i = e.getTopForLineNumber(t.lineNumber) - e.getTopForLineNumber(this._cursorPosition.lineNumber);
    e.setScrollTop(
      e.getScrollTop() + i,
      1
      /* ScrollType.Immediate */
    );
  }
}
function dae(s, e, t, i) {
  if (s.length === 0)
    return e;
  if (e.length === 0)
    return s;
  const n = [];
  let o = 0, r = 0;
  for (; o < s.length && r < e.length; ) {
    const a = s[o], l = e[r], c = t(a), d = t(l);
    c < d ? (n.push(a), o++) : c > d ? (n.push(l), r++) : (n.push(i(a, l)), o++, r++);
  }
  for (; o < s.length; )
    n.push(s[o]), o++;
  for (; r < e.length; )
    n.push(e[r]), r++;
  return n;
}
function Tv(s, e) {
  const t = new X(), i = s.createDecorationsCollection();
  return t.add(nS({ debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
    const o = e.read(n);
    i.set(o);
  })), t.add({
    dispose: () => {
      i.clear();
    }
  }), t;
}
function Cp(s, e) {
  return s.appendChild(e), we(() => {
    e.remove();
  });
}
function hae(s, e) {
  return s.prepend(e), we(() => {
    e.remove();
  });
}
class Q8 extends V {
  get width() {
    return this._width;
  }
  get height() {
    return this._height;
  }
  get automaticLayout() {
    return this._automaticLayout;
  }
  constructor(e, t) {
    super(), this._automaticLayout = !1, this.elementSizeObserver = this._register(new S8(e, t)), this._width = ot(this, this.elementSizeObserver.getWidth()), this._height = ot(this, this.elementSizeObserver.getHeight()), this._register(this.elementSizeObserver.onDidChange((i) => xi((n) => {
      this._width.set(this.elementSizeObserver.getWidth(), n), this._height.set(this.elementSizeObserver.getHeight(), n);
    })));
  }
  observe(e) {
    this.elementSizeObserver.observe(e);
  }
  setAutomaticLayout(e) {
    this._automaticLayout = e, e ? this.elementSizeObserver.startObserving() : this.elementSizeObserver.stopObserving();
  }
}
function nP(s, e, t) {
  let i = e.get(), n = i, o = i;
  const r = ot("animatedValue", i);
  let a = -1;
  const l = 300;
  let c;
  t.add(sS({
    createEmptyChangeSummary: () => ({ animate: !1 }),
    handleChange: (h, u) => (h.didChange(e) && (u.animate = u.animate || h.change), !0)
  }, (h, u) => {
    c !== void 0 && (s.cancelAnimationFrame(c), c = void 0), n = o, i = e.read(h), a = Date.now() - (u.animate ? 0 : l), d();
  }));
  function d() {
    const h = Date.now() - a;
    o = Math.floor(uae(h, n, i - n, l)), h < l ? c = s.requestAnimationFrame(d) : o = i, r.set(o, void 0);
  }
  return r;
}
function uae(s, e, t, i) {
  return s === i ? e + t : t * (-Math.pow(2, -10 * s / i) + 1) + e;
}
class GT extends V {
  constructor(e, t, i) {
    super(), this._register(new BD(e, i)), this._register(fd(i, {
      height: t.actualHeight,
      top: t.actualTop
    }));
  }
}
class jg {
  get afterLineNumber() {
    return this._afterLineNumber.get();
  }
  constructor(e, t) {
    this._afterLineNumber = e, this.heightInPx = t, this.domNode = document.createElement("div"), this._actualTop = ot(this, void 0), this._actualHeight = ot(this, void 0), this.actualTop = this._actualTop, this.actualHeight = this._actualHeight, this.showInHiddenAreas = !0, this.onChange = this._afterLineNumber, this.onDomNodeTop = (i) => {
      this._actualTop.set(i, void 0);
    }, this.onComputedHeight = (i) => {
      this._actualHeight.set(i, void 0);
    };
  }
}
const e0 = class e0 {
  constructor(e, t) {
    this._editor = e, this._domElement = t, this._overlayWidgetId = `managedOverlayWidget-${e0._counter++}`, this._overlayWidget = {
      getId: () => this._overlayWidgetId,
      getDomNode: () => this._domElement,
      getPosition: () => null
    }, this._editor.addOverlayWidget(this._overlayWidget);
  }
  dispose() {
    this._editor.removeOverlayWidget(this._overlayWidget);
  }
};
e0._counter = 0;
let BD = e0;
function fd(s, e) {
  return et((t) => {
    for (let [i, n] of Object.entries(e))
      n && typeof n == "object" && "read" in n && (n = n.read(t)), typeof n == "number" && (n = `${n}px`), i = i.replace(/[A-Z]/g, (o) => "-" + o.toLowerCase()), s.style[i] = n;
  });
}
function Bv(s, e, t, i) {
  const n = new X(), o = [];
  return n.add(Yo((r, a) => {
    const l = e.read(r), c = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map();
    t && t(!0), s.changeViewZones((h) => {
      for (const u of o)
        h.removeZone(u), i?.delete(u);
      o.length = 0;
      for (const u of l) {
        const g = h.addZone(u);
        u.setZoneId && u.setZoneId(g), o.push(g), i?.add(g), c.set(u, g);
      }
    }), t && t(!1), a.add(sS({
      createEmptyChangeSummary() {
        return { zoneIds: [] };
      },
      handleChange(h, u) {
        const g = d.get(h.changedObservable);
        return g !== void 0 && u.zoneIds.push(g), !0;
      }
    }, (h, u) => {
      for (const g of l)
        g.onChange && (d.set(g.onChange, c.get(g)), g.onChange.read(h));
      t && t(!0), s.changeViewZones((g) => {
        for (const m of u.zoneIds)
          g.layoutZone(m);
      }), t && t(!1);
    }));
  })), n.add({
    dispose() {
      t && t(!0), s.changeViewZones((r) => {
        for (const a of o)
          r.removeZone(a);
      }), i?.clear(), t && t(!1);
    }
  }), n;
}
function sP(s, e) {
  const t = gC(e, (n) => n.original.startLineNumber <= s.lineNumber);
  if (!t)
    return E.fromPositions(s);
  if (t.original.endLineNumberExclusive <= s.lineNumber) {
    const n = s.lineNumber - t.original.endLineNumberExclusive + t.modified.endLineNumberExclusive;
    return E.fromPositions(new F(n, s.column));
  }
  if (!t.innerChanges)
    return E.fromPositions(new F(t.modified.startLineNumber, 1));
  const i = gC(t.innerChanges, (n) => n.originalRange.getStartPosition().isBeforeOrEqual(s));
  if (!i) {
    const n = s.lineNumber - t.original.startLineNumber + t.modified.startLineNumber;
    return E.fromPositions(new F(n, s.column));
  }
  if (i.originalRange.containsPosition(s))
    return i.modifiedRange;
  {
    const n = gae(i.originalRange.getEndPosition(), s);
    return E.fromPositions(n.addToPosition(i.modifiedRange.getEndPosition()));
  }
}
function gae(s, e) {
  return s.lineNumber === e.lineNumber ? new ad(0, e.column - s.column) : new ad(e.lineNumber - s.lineNumber, e.column - 1);
}
function fae(s, e) {
  let t;
  return s.filter((i) => {
    const n = e(i, t);
    return t = i, n;
  });
}
class Rv {
  static create(e, t = void 0) {
    return new oP(e, e, t);
  }
  static createWithDisposable(e, t, i = void 0) {
    const n = new X();
    return n.add(t), n.add(e), new oP(e, n, i);
  }
}
class oP extends Rv {
  constructor(e, t, i) {
    super(), this.object = e, this._disposable = t, this._debugOwner = i, this._refCount = 1, this._isDisposed = !1, this._owners = [], i && this._addOwner(i);
  }
  _addOwner(e) {
    e && this._owners.push(e);
  }
  createNewRef(e) {
    return this._refCount++, e && this._addOwner(e), new mae(this, e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._decreaseRefCount(this._debugOwner));
  }
  _decreaseRefCount(e) {
    if (this._refCount--, this._refCount === 0 && this._disposable.dispose(), e) {
      const t = this._owners.indexOf(e);
      t !== -1 && this._owners.splice(t, 1);
    }
  }
}
class mae extends Rv {
  constructor(e, t) {
    super(), this._base = e, this._debugOwner = t, this._isDisposed = !1;
  }
  get object() {
    return this._base.object;
  }
  createNewRef(e) {
    return this._base.createNewRef(e);
  }
  dispose() {
    this._isDisposed || (this._isDisposed = !0, this._base._decreaseRefCount(this._debugOwner));
  }
}
var jT = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, YT = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const pae = Rt("diff-review-insert", Z.add, f("accessibleDiffViewerInsertIcon", "Icon for 'Insert' in accessible diff viewer.")), Aae = Rt("diff-review-remove", Z.remove, f("accessibleDiffViewerRemoveIcon", "Icon for 'Remove' in accessible diff viewer.")), _ae = Rt("diff-review-close", Z.close, f("accessibleDiffViewerCloseIcon", "Icon for 'Close' in accessible diff viewer."));
var Rf;
let yh = (Rf = class extends V {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._parentNode = e, this._visible = t, this._setVisible = i, this._canClose = n, this._width = o, this._height = r, this._diffs = a, this._models = l, this._instantiationService = c, this._state = Uu(this, (d, h) => {
      const u = this._visible.read(d);
      if (this._parentNode.style.visibility = u ? "visible" : "hidden", !u)
        return null;
      const g = h.add(this._instantiationService.createInstance(RD, this._diffs, this._models, this._setVisible, this._canClose)), m = h.add(this._instantiationService.createInstance(FD, this._parentNode, g, this._width, this._height, this._models));
      return { model: g, view: m };
    }).recomputeInitiallyAndOnChange(this._store);
  }
  next() {
    xi((e) => {
      const t = this._visible.get();
      this._setVisible(!0, e), t && this._state.get().model.nextGroup(e);
    });
  }
  prev() {
    xi((e) => {
      this._setVisible(!0, e), this._state.get().model.previousGroup(e);
    });
  }
  close() {
    xi((e) => {
      this._setVisible(!1, e);
    });
  }
}, Rf._ttPolicy = Hu("diffReview", { createHTML: (e) => e }), Rf);
yh = jT([
  YT(8, ke)
], yh);
let RD = class extends V {
  constructor(e, t, i, n, o) {
    super(), this._diffs = e, this._models = t, this._setVisible = i, this.canClose = n, this._accessibilitySignalService = o, this._groups = ot(this, []), this._currentGroupIdx = ot(this, 0), this._currentElementIdx = ot(this, 0), this.groups = this._groups, this.currentGroup = this._currentGroupIdx.map((r, a) => this._groups.read(a)[r]), this.currentGroupIndex = this._currentGroupIdx, this.currentElement = this._currentElementIdx.map((r, a) => this.currentGroup.read(a)?.lines[r]), this._register(et((r) => {
      const a = this._diffs.read(r);
      if (!a) {
        this._groups.set([], void 0);
        return;
      }
      const l = bae(a, this._models.getOriginalModel().getLineCount(), this._models.getModifiedModel().getLineCount());
      xi((c) => {
        const d = this._models.getModifiedPosition();
        if (d) {
          const h = l.findIndex((u) => d?.lineNumber < u.range.modified.endLineNumberExclusive);
          h !== -1 && this._currentGroupIdx.set(h, c);
        }
        this._groups.set(l, c);
      });
    })), this._register(et((r) => {
      const a = this.currentElement.read(r);
      a?.type === In.Deleted ? this._accessibilitySignalService.playSignal(ua.diffLineDeleted, { source: "accessibleDiffViewer.currentElementChanged" }) : a?.type === In.Added && this._accessibilitySignalService.playSignal(ua.diffLineInserted, { source: "accessibleDiffViewer.currentElementChanged" });
    })), this._register(et((r) => {
      const a = this.currentElement.read(r);
      if (a && a.type !== In.Header) {
        const l = a.modifiedLineNumber ?? a.diff.modified.startLineNumber;
        this._models.modifiedSetSelection(E.fromPositions(new F(l, 1)));
      }
    }));
  }
  _goToGroupDelta(e, t) {
    const i = this.groups.get();
    !i || i.length <= 1 || HN(t, (n) => {
      this._currentGroupIdx.set(Be.ofLength(i.length).clipCyclic(this._currentGroupIdx.get() + e), n), this._currentElementIdx.set(0, n);
    });
  }
  nextGroup(e) {
    this._goToGroupDelta(1, e);
  }
  previousGroup(e) {
    this._goToGroupDelta(-1, e);
  }
  _goToLineDelta(e) {
    const t = this.currentGroup.get();
    !t || t.lines.length <= 1 || xi((i) => {
      this._currentElementIdx.set(Be.ofLength(t.lines.length).clip(this._currentElementIdx.get() + e), i);
    });
  }
  goToNextLine() {
    this._goToLineDelta(1);
  }
  goToPreviousLine() {
    this._goToLineDelta(-1);
  }
  goToLine(e) {
    const t = this.currentGroup.get();
    if (!t)
      return;
    const i = t.lines.indexOf(e);
    i !== -1 && xi((n) => {
      this._currentElementIdx.set(i, n);
    });
  }
  revealCurrentElementInEditor() {
    if (!this.canClose.get())
      return;
    this._setVisible(!1, void 0);
    const e = this.currentElement.get();
    e && (e.type === In.Deleted ? this._models.originalReveal(E.fromPositions(new F(e.originalLineNumber, 1))) : this._models.modifiedReveal(e.type !== In.Header ? E.fromPositions(new F(e.modifiedLineNumber, 1)) : void 0));
  }
  close() {
    this.canClose.get() && (this._setVisible(!1, void 0), this._models.modifiedFocus());
  }
};
RD = jT([
  YT(4, bS)
], RD);
const rp = 3;
function bae(s, e, t) {
  const i = [];
  for (const n of CM(s, (o, r) => r.modified.startLineNumber - o.modified.endLineNumberExclusive < 2 * rp)) {
    const o = [];
    o.push(new Cae());
    const r = new Ee(Math.max(1, n[0].original.startLineNumber - rp), Math.min(n[n.length - 1].original.endLineNumberExclusive + rp, e + 1)), a = new Ee(Math.max(1, n[0].modified.startLineNumber - rp), Math.min(n[n.length - 1].modified.endLineNumberExclusive + rp, t + 1));
    O4(n, (d, h) => {
      const u = new Ee(d ? d.original.endLineNumberExclusive : r.startLineNumber, h ? h.original.startLineNumber : r.endLineNumberExclusive), g = new Ee(d ? d.modified.endLineNumberExclusive : a.startLineNumber, h ? h.modified.startLineNumber : a.endLineNumberExclusive);
      u.forEach((m) => {
        o.push(new yae(m, g.startLineNumber + (m - u.startLineNumber)));
      }), h && (h.original.forEach((m) => {
        o.push(new vae(h, m));
      }), h.modified.forEach((m) => {
        o.push(new Sae(h, m));
      }));
    });
    const l = n[0].modified.join(n[n.length - 1].modified), c = n[0].original.join(n[n.length - 1].original);
    i.push(new wae(new Cn(l, c), o));
  }
  return i;
}
var In;
(function(s) {
  s[s.Header = 0] = "Header", s[s.Unchanged = 1] = "Unchanged", s[s.Deleted = 2] = "Deleted", s[s.Added = 3] = "Added";
})(In || (In = {}));
class wae {
  constructor(e, t) {
    this.range = e, this.lines = t;
  }
}
class Cae {
  constructor() {
    this.type = In.Header;
  }
}
class vae {
  constructor(e, t) {
    this.diff = e, this.originalLineNumber = t, this.type = In.Deleted, this.modifiedLineNumber = void 0;
  }
}
class Sae {
  constructor(e, t) {
    this.diff = e, this.modifiedLineNumber = t, this.type = In.Added, this.originalLineNumber = void 0;
  }
}
class yae {
  constructor(e, t) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.type = In.Unchanged;
  }
}
let FD = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._model = t, this._width = i, this._height = n, this._models = o, this._languageService = r, this.domNode = this._element, this.domNode.className = "monaco-component diff-review monaco-editor-background";
    const a = document.createElement("div");
    a.className = "diff-review-actions", this._actionBar = this._register(new wo(a)), this._register(et((l) => {
      this._actionBar.clear(), this._model.canClose.read(l) && this._actionBar.push(new Ks("diffreview.close", f("label.close", "Close"), "close-diff-review " + pe.asClassName(_ae), !0, async () => t.close()), { label: !1, icon: !0 });
    })), this._content = document.createElement("div"), this._content.className = "diff-review-content", this._content.setAttribute("role", "code"), this._scrollbar = this._register(new F_(this._content, {})), Rn(this.domNode, this._scrollbar.getDomNode(), a), this._register(et((l) => {
      this._height.read(l), this._width.read(l), this._scrollbar.scanDomNode();
    })), this._register(we(() => {
      Rn(this.domNode);
    })), this._register(fd(this.domNode, { width: this._width, height: this._height })), this._register(fd(this._content, { width: this._width, height: this._height })), this._register(Yo((l, c) => {
      this._model.currentGroup.read(l), this._render(c);
    })), this._register(Xt(this.domNode, "keydown", (l) => {
      (l.equals(
        18
        /* KeyCode.DownArrow */
      ) || l.equals(
        2066
        /* KeyCode.DownArrow */
      ) || l.equals(
        530
        /* KeyCode.DownArrow */
      )) && (l.preventDefault(), this._model.goToNextLine()), (l.equals(
        16
        /* KeyCode.UpArrow */
      ) || l.equals(
        2064
        /* KeyCode.UpArrow */
      ) || l.equals(
        528
        /* KeyCode.UpArrow */
      )) && (l.preventDefault(), this._model.goToPreviousLine()), (l.equals(
        9
        /* KeyCode.Escape */
      ) || l.equals(
        2057
        /* KeyCode.Escape */
      ) || l.equals(
        521
        /* KeyCode.Escape */
      ) || l.equals(
        1033
        /* KeyCode.Escape */
      )) && (l.preventDefault(), this._model.close()), (l.equals(
        10
        /* KeyCode.Space */
      ) || l.equals(
        3
        /* KeyCode.Enter */
      )) && (l.preventDefault(), this._model.revealCurrentElementInEditor());
    }));
  }
  _render(e) {
    const t = this._models.getOriginalOptions(), i = this._models.getModifiedOptions(), n = document.createElement("div");
    n.className = "diff-review-table", n.setAttribute("role", "list"), n.setAttribute("aria-label", f("ariaLabel", "Accessible Diff Viewer. Use arrow up and down to navigate.")), cn(n, i.get(
      50
      /* EditorOption.fontInfo */
    )), Rn(this._content, n);
    const o = this._models.getOriginalModel(), r = this._models.getModifiedModel();
    if (!o || !r)
      return;
    const a = o.getOptions(), l = r.getOptions(), c = i.get(
      67
      /* EditorOption.lineHeight */
    ), d = this._model.currentGroup.get();
    for (const h of d?.lines || []) {
      if (!d)
        break;
      let u;
      if (h.type === In.Header) {
        const m = document.createElement("div");
        m.className = "diff-review-row", m.setAttribute("role", "listitem");
        const p = d.range, A = this._model.currentGroupIndex.get(), _ = this._model.groups.get().length, b = (x) => x === 0 ? f("no_lines_changed", "no lines changed") : x === 1 ? f("one_line_changed", "1 line changed") : f("more_lines_changed", "{0} lines changed", x), C = b(p.original.length), w = b(p.modified.length);
        m.setAttribute("aria-label", f({
          key: "header",
          comment: [
            "This is the ARIA label for a git diff header.",
            "A git diff header looks like this: @@ -154,12 +159,39 @@.",
            "That encodes that at original line 154 (which is now line 159), 12 lines were removed/changed with 39 lines.",
            "Variables 0 and 1 refer to the diff index out of total number of diffs.",
            "Variables 2 and 4 will be numbers (a line number).",
            'Variables 3 and 5 will be "no lines changed", "1 line changed" or "X lines changed", localized separately.'
          ]
        }, "Difference {0} of {1}: original line {2}, {3}, modified line {4}, {5}", A + 1, _, p.original.startLineNumber, C, p.modified.startLineNumber, w));
        const S = document.createElement("div");
        S.className = "diff-review-cell diff-review-summary", S.appendChild(document.createTextNode(`${A + 1}/${_}: @@ -${p.original.startLineNumber},${p.original.length} +${p.modified.startLineNumber},${p.modified.length} @@`)), m.appendChild(S), u = m;
      } else
        u = this._createRow(h, c, this._width.get(), t, o, a, i, r, l);
      n.appendChild(u);
      const g = De((m) => (
        /** @description isSelected */
        this._model.currentElement.read(m) === h
      ));
      e.add(et((m) => {
        const p = g.read(m);
        u.tabIndex = p ? 0 : -1, p && u.focus();
      })), e.add(U(u, "focus", () => {
        this._model.goToLine(h);
      }));
    }
    this._scrollbar.scanDomNode();
  }
  _createRow(e, t, i, n, o, r, a, l, c) {
    const d = n.get(
      146
      /* EditorOption.layoutInfo */
    ), h = d.glyphMarginWidth + d.lineNumbersWidth, u = a.get(
      146
      /* EditorOption.layoutInfo */
    ), g = 10 + u.glyphMarginWidth + u.lineNumbersWidth;
    let m = "diff-review-row", p = "";
    const A = "diff-review-spacer";
    let _ = null;
    switch (e.type) {
      case In.Added:
        m = "diff-review-row line-insert", p = " char-insert", _ = pae;
        break;
      case In.Deleted:
        m = "diff-review-row line-delete", p = " char-delete", _ = Aae;
        break;
    }
    const b = document.createElement("div");
    b.style.minWidth = i + "px", b.className = m, b.setAttribute("role", "listitem"), b.ariaLevel = "";
    const C = document.createElement("div");
    C.className = "diff-review-cell", C.style.height = `${t}px`, b.appendChild(C);
    const w = document.createElement("span");
    w.style.width = h + "px", w.style.minWidth = h + "px", w.className = "diff-review-line-number" + p, e.originalLineNumber !== void 0 ? w.appendChild(document.createTextNode(String(e.originalLineNumber))) : w.innerText = " ", C.appendChild(w);
    const S = document.createElement("span");
    S.style.width = g + "px", S.style.minWidth = g + "px", S.style.paddingRight = "10px", S.className = "diff-review-line-number" + p, e.modifiedLineNumber !== void 0 ? S.appendChild(document.createTextNode(String(e.modifiedLineNumber))) : S.innerText = " ", C.appendChild(S);
    const x = document.createElement("span");
    if (x.className = A, _) {
      const I = document.createElement("span");
      I.className = pe.asClassName(_), I.innerText = "  ", x.appendChild(I);
    } else
      x.innerText = "  ";
    C.appendChild(x);
    let y;
    if (e.modifiedLineNumber !== void 0) {
      let I = this._getLineHtml(l, a, c.tabSize, e.modifiedLineNumber, this._languageService.languageIdCodec);
      yh._ttPolicy && (I = yh._ttPolicy.createHTML(I)), C.insertAdjacentHTML("beforeend", I), y = l.getLineContent(e.modifiedLineNumber);
    } else {
      let I = this._getLineHtml(o, n, r.tabSize, e.originalLineNumber, this._languageService.languageIdCodec);
      yh._ttPolicy && (I = yh._ttPolicy.createHTML(I)), C.insertAdjacentHTML("beforeend", I), y = o.getLineContent(e.originalLineNumber);
    }
    y.length === 0 && (y = f("blankLine", "blank"));
    let D = "";
    switch (e.type) {
      case In.Unchanged:
        e.originalLineNumber === e.modifiedLineNumber ? D = f({ key: "unchangedLine", comment: ["The placeholders are contents of the line and should not be translated."] }, "{0} unchanged line {1}", y, e.originalLineNumber) : D = f("equalLine", "{0} original line {1} modified line {2}", y, e.originalLineNumber, e.modifiedLineNumber);
        break;
      case In.Added:
        D = f("insertLine", "+ {0} modified line {1}", y, e.modifiedLineNumber);
        break;
      case In.Deleted:
        D = f("deleteLine", "- {0} original line {1}", y, e.originalLineNumber);
        break;
    }
    return b.setAttribute("aria-label", D), b;
  }
  _getLineHtml(e, t, i, n, o) {
    const r = e.getLineContent(n), a = t.get(
      50
      /* EditorOption.fontInfo */
    ), l = Gi.createEmpty(r, o), c = $s.isBasicASCII(r, e.mightContainNonBasicASCII()), d = $s.containsRTL(r, c, e.mightContainRTL());
    return CS(new km(a.isMonospace && !t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), a.canUseHalfwidthRightwardsArrow, r, !1, c, d, 0, l, [], i, 0, a.spaceWidth, a.middotWidth, a.wsmiddotWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ) !== hu.OFF, null)).html;
  }
};
FD = jT([
  YT(5, si)
], FD);
class xae {
  constructor(e) {
    this.editors = e;
  }
  getOriginalModel() {
    return this.editors.original.getModel();
  }
  getOriginalOptions() {
    return this.editors.original.getOptions();
  }
  originalReveal(e) {
    this.editors.original.revealRange(e), this.editors.original.setSelection(e), this.editors.original.focus();
  }
  getModifiedModel() {
    return this.editors.modified.getModel();
  }
  getModifiedOptions() {
    return this.editors.modified.getOptions();
  }
  modifiedReveal(e) {
    e && (this.editors.modified.revealRange(e), this.editors.modified.setSelection(e)), this.editors.modified.focus();
  }
  modifiedSetSelection(e) {
    this.editors.modified.setSelection(e);
  }
  modifiedFocus() {
    this.editors.modified.focus();
  }
  getModifiedPosition() {
    return this.editors.modified.getPosition() ?? void 0;
  }
}
L("diffEditor.move.border", "#8b8b8b9c", f("diffEditor.move.border", "The border color for text that got moved in the diff editor."));
L("diffEditor.moveActive.border", "#FFA500", f("diffEditor.moveActive.border", "The active border color for text that got moved in the diff editor."));
L("diffEditor.unchangedRegionShadow", { dark: "#000000", light: "#737373BF", hcDark: "#000000", hcLight: "#737373BF" }, f("diffEditor.unchangedRegionShadow", "The color of the shadow around unchanged region widgets."));
const Eae = Rt("diff-insert", Z.add, f("diffInsertIcon", "Line decoration for inserts in the diff editor.")), G8 = Rt("diff-remove", Z.remove, f("diffRemoveIcon", "Line decoration for removals in the diff editor.")), rP = He.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  linesDecorationsClassName: "insert-sign " + pe.asClassName(Eae),
  marginClassName: "gutter-insert"
}), aP = He.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  linesDecorationsClassName: "delete-sign " + pe.asClassName(G8),
  marginClassName: "gutter-delete"
}), lP = He.register({
  className: "line-insert",
  description: "line-insert",
  isWholeLine: !0,
  marginClassName: "gutter-insert"
}), cP = He.register({
  className: "line-delete",
  description: "line-delete",
  isWholeLine: !0,
  marginClassName: "gutter-delete"
}), dP = He.register({
  className: "char-insert",
  description: "char-insert",
  shouldFillLineOnLineBreak: !0
}), Lae = He.register({
  className: "char-insert",
  description: "char-insert",
  isWholeLine: !0
}), kae = He.register({
  className: "char-insert diff-range-empty",
  description: "char-insert diff-range-empty"
}), OD = He.register({
  className: "char-delete",
  description: "char-delete",
  shouldFillLineOnLineBreak: !0
}), Dae = He.register({
  className: "char-delete",
  description: "char-delete",
  isWholeLine: !0
}), Iae = He.register({
  className: "char-delete diff-range-empty",
  description: "char-delete diff-range-empty"
});
var j8 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, PD = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Jd;
const Y8 = We("diffProviderFactoryService");
let HD = class {
  constructor(e) {
    this.instantiationService = e;
  }
  createDiffProvider(e) {
    return this.instantiationService.createInstance(WD, e);
  }
};
HD = j8([
  PD(0, ke)
], HD);
$e(
  Y8,
  HD,
  1
  /* InstantiationType.Delayed */
);
var zh;
let WD = (zh = class {
  constructor(e, t, i) {
    this.editorWorkerService = t, this.telemetryService = i, this.onDidChangeEventEmitter = new B(), this.onDidChange = this.onDidChangeEventEmitter.event, this.diffAlgorithm = "advanced", this.diffAlgorithmOnDidChangeSubscription = void 0, this.setOptions(e);
  }
  dispose() {
    this.diffAlgorithmOnDidChangeSubscription?.dispose();
  }
  async computeDiff(e, t, i, n) {
    if (typeof this.diffAlgorithm != "string")
      return this.diffAlgorithm.computeDiff(e, t, i, n);
    if (e.isDisposed() || t.isDisposed())
      return {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      };
    if (e.getLineCount() === 1 && e.getLineMaxColumn(1) === 1)
      return t.getLineCount() === 1 && t.getLineMaxColumn(1) === 1 ? {
        changes: [],
        identical: !0,
        quitEarly: !1,
        moves: []
      } : {
        changes: [
          new qs(new Ee(1, 2), new Ee(1, t.getLineCount() + 1), [
            new Ps(e.getFullModelRange(), t.getFullModelRange())
          ])
        ],
        identical: !1,
        quitEarly: !1,
        moves: []
      };
    const o = JSON.stringify([e.uri.toString(), t.uri.toString()]), r = JSON.stringify([e.id, t.id, e.getAlternativeVersionId(), t.getAlternativeVersionId(), JSON.stringify(i)]), a = Jd.diffCache.get(o);
    if (a && a.context === r)
      return a.result;
    const l = es.create(), c = await this.editorWorkerService.computeDiff(e.uri, t.uri, i, this.diffAlgorithm), d = l.elapsed();
    if (this.telemetryService.publicLog2("diffEditor.computeDiff", {
      timeMs: d,
      timedOut: c?.quitEarly ?? !0,
      detectedMoves: i.computeMoves ? c?.moves.length ?? 0 : -1
    }), n.isCancellationRequested)
      return {
        changes: [],
        identical: !1,
        quitEarly: !0,
        moves: []
      };
    if (!c)
      throw new Error("no diff result available");
    return Jd.diffCache.size > 10 && Jd.diffCache.delete(Jd.diffCache.keys().next().value), Jd.diffCache.set(o, { result: c, context: r }), c;
  }
  setOptions(e) {
    let t = !1;
    e.diffAlgorithm && this.diffAlgorithm !== e.diffAlgorithm && (this.diffAlgorithmOnDidChangeSubscription?.dispose(), this.diffAlgorithmOnDidChangeSubscription = void 0, this.diffAlgorithm = e.diffAlgorithm, typeof e.diffAlgorithm != "string" && (this.diffAlgorithmOnDidChangeSubscription = e.diffAlgorithm.onDidChange(() => this.onDidChangeEventEmitter.fire())), t = !0), t && this.onDidChangeEventEmitter.fire();
  }
}, Jd = zh, zh.diffCache = /* @__PURE__ */ new Map(), zh);
WD = Jd = j8([
  PD(1, Sd),
  PD(2, eo)
], WD);
function KT() {
  return Mx && !!Mx.VSCODE_DEV;
}
function K8(s) {
  if (KT()) {
    const e = Mae();
    return e.add(s), {
      dispose() {
        e.delete(s);
      }
    };
  } else
    return { dispose() {
    } };
}
function Mae() {
  jb || (jb = /* @__PURE__ */ new Set());
  const s = globalThis;
  return s.$hotReload_applyNewExports || (s.$hotReload_applyNewExports = (e) => {
    const t = { config: { mode: void 0 }, ...e }, i = [];
    for (const n of jb) {
      const o = n(t);
      o && i.push(o);
    }
    if (i.length > 0)
      return (n) => {
        let o = !1;
        for (const r of i)
          r(n) && (o = !0);
        return o;
      };
  }), jb;
}
let jb;
KT() && K8(({ oldExports: s, newSrc: e, config: t }) => {
  if (t.mode === "patch-prototype")
    return (i) => {
      for (const n in i) {
        const o = i[n];
        if (console.log(`[hot-reload] Patching prototype methods of '${n}'`, { exportedItem: o }), typeof o == "function" && o.prototype) {
          const r = s[n];
          if (r) {
            for (const a of Object.getOwnPropertyNames(o.prototype)) {
              const l = Object.getOwnPropertyDescriptor(o.prototype, a), c = Object.getOwnPropertyDescriptor(r.prototype, a);
              l?.value?.toString() !== c?.value?.toString() && console.log(`[hot-reload] Patching prototype method '${n}.${a}'`), Object.defineProperty(r.prototype, a, l);
            }
            i[n] = r;
          }
        }
      }
      return !0;
    };
});
function Po(s, e) {
  return Nae([s], e), s;
}
function Nae(s, e) {
  KT() && fo("reload", (i) => K8(({ oldExports: n }) => {
    if ([...Object.values(n)].some((o) => s.includes(o)))
      return (o) => (i(void 0), !0);
  })).read(e);
}
var Tae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Bae = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let VD = class extends V {
  setActiveMovedText(e) {
    this._activeMovedText.set(e, void 0);
  }
  constructor(e, t, i) {
    super(), this.model = e, this._options = t, this._diffProviderFactoryService = i, this._isDiffUpToDate = ot(this, !1), this.isDiffUpToDate = this._isDiffUpToDate, this._diff = ot(this, void 0), this.diff = this._diff, this._unchangedRegions = ot(this, void 0), this.unchangedRegions = De(this, (a) => this._options.hideUnchangedRegions.read(a) ? this._unchangedRegions.read(a)?.regions ?? [] : (xi((l) => {
      for (const c of this._unchangedRegions.get()?.regions || [])
        c.collapseAll(l);
    }), [])), this.movedTextToCompare = ot(this, void 0), this._activeMovedText = ot(this, void 0), this._hoveredMovedText = ot(this, void 0), this.activeMovedText = De(this, (a) => this.movedTextToCompare.read(a) ?? this._hoveredMovedText.read(a) ?? this._activeMovedText.read(a)), this._cancellationTokenSource = new vs(), this._diffProvider = De(this, (a) => {
      const l = this._diffProviderFactoryService.createDiffProvider({
        diffAlgorithm: this._options.diffAlgorithm.read(a)
      }), c = fo("onDidChange", l.onDidChange);
      return {
        diffProvider: l,
        onChangeSignal: c
      };
    }), this._register(we(() => this._cancellationTokenSource.cancel()));
    const n = zN("contentChangedSignal"), o = this._register(new zt(() => n.trigger(void 0), 200));
    this._register(et((a) => {
      const l = this._unchangedRegions.read(a);
      if (!l || l.regions.some((m) => m.isDragged.read(a)))
        return;
      const c = l.originalDecorationIds.map((m) => e.original.getDecorationRange(m)).map((m) => m ? Ee.fromRangeInclusive(m) : void 0), d = l.modifiedDecorationIds.map((m) => e.modified.getDecorationRange(m)).map((m) => m ? Ee.fromRangeInclusive(m) : void 0), h = l.regions.map((m, p) => !c[p] || !d[p] ? void 0 : new Bc(c[p].startLineNumber, d[p].startLineNumber, c[p].length, m.visibleLineCountTop.read(a), m.visibleLineCountBottom.read(a))).filter(Pf), u = [];
      let g = !1;
      for (const m of CM(h, (p, A) => p.getHiddenModifiedRange(a).endLineNumberExclusive === A.getHiddenModifiedRange(a).startLineNumber))
        if (m.length > 1) {
          g = !0;
          const p = m.reduce((_, b) => _ + b.lineCount, 0), A = new Bc(m[0].originalLineNumber, m[0].modifiedLineNumber, p, m[0].visibleLineCountTop.get(), m[m.length - 1].visibleLineCountBottom.get());
          u.push(A);
        } else
          u.push(m[0]);
      if (g) {
        const m = e.original.deltaDecorations(l.originalDecorationIds, u.map((A) => ({ range: A.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), p = e.modified.deltaDecorations(l.modifiedDecorationIds, u.map((A) => ({ range: A.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
        xi((A) => {
          this._unchangedRegions.set({
            regions: u,
            originalDecorationIds: m,
            modifiedDecorationIds: p
          }, A);
        });
      }
    }));
    const r = (a, l, c) => {
      const d = Bc.fromDiffs(a.changes, e.original.getLineCount(), e.modified.getLineCount(), this._options.hideUnchangedRegionsMinimumLineCount.read(c), this._options.hideUnchangedRegionsContextLineCount.read(c));
      let h;
      const u = this._unchangedRegions.get();
      if (u) {
        const A = u.originalDecorationIds.map((w) => e.original.getDecorationRange(w)).map((w) => w ? Ee.fromRangeInclusive(w) : void 0), _ = u.modifiedDecorationIds.map((w) => e.modified.getDecorationRange(w)).map((w) => w ? Ee.fromRangeInclusive(w) : void 0);
        let C = fae(u.regions.map((w, S) => {
          if (!A[S] || !_[S])
            return;
          const x = A[S].length;
          return new Bc(
            A[S].startLineNumber,
            _[S].startLineNumber,
            x,
            // The visible area can shrink by edits -> we have to account for this
            Math.min(w.visibleLineCountTop.get(), x),
            Math.min(w.visibleLineCountBottom.get(), x - w.visibleLineCountTop.get())
          );
        }).filter(Pf), (w, S) => !S || w.modifiedLineNumber >= S.modifiedLineNumber + S.lineCount && w.originalLineNumber >= S.originalLineNumber + S.lineCount).map((w) => new Cn(w.getHiddenOriginalRange(c), w.getHiddenModifiedRange(c)));
        C = Cn.clip(C, Ee.ofLength(1, e.original.getLineCount()), Ee.ofLength(1, e.modified.getLineCount())), h = Cn.inverse(C, e.original.getLineCount(), e.modified.getLineCount());
      }
      const g = [];
      if (h)
        for (const A of d) {
          const _ = h.filter((b) => b.original.intersectsStrict(A.originalUnchangedRange) && b.modified.intersectsStrict(A.modifiedUnchangedRange));
          g.push(...A.setVisibleRanges(_, l));
        }
      else
        g.push(...d);
      const m = e.original.deltaDecorations(u?.originalDecorationIds || [], g.map((A) => ({ range: A.originalUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } }))), p = e.modified.deltaDecorations(u?.modifiedDecorationIds || [], g.map((A) => ({ range: A.modifiedUnchangedRange.toInclusiveRange(), options: { description: "unchanged" } })));
      this._unchangedRegions.set({
        regions: g,
        originalDecorationIds: m,
        modifiedDecorationIds: p
      }, l);
    };
    this._register(e.modified.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = vl.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(e.original.onDidChangeContent((a) => {
      if (this._diff.get()) {
        const c = vl.fromModelContentChanges(a.changes);
        this._lastDiff, e.original, e.modified;
      }
      this._isDiffUpToDate.set(!1, void 0), o.schedule();
    })), this._register(Yo(async (a, l) => {
      this._options.hideUnchangedRegionsMinimumLineCount.read(a), this._options.hideUnchangedRegionsContextLineCount.read(a), o.cancel(), n.read(a);
      const c = this._diffProvider.read(a);
      c.onChangeSignal.read(a), Po(y5, a), Po(aL, a), this._isDiffUpToDate.set(!1, void 0);
      let d = [];
      l.add(e.original.onDidChangeContent((g) => {
        const m = vl.fromModelContentChanges(g.changes);
        d = YC(d, m);
      }));
      let h = [];
      l.add(e.modified.onDidChangeContent((g) => {
        const m = vl.fromModelContentChanges(g.changes);
        h = YC(h, m);
      }));
      let u = await c.diffProvider.computeDiff(e.original, e.modified, {
        ignoreTrimWhitespace: this._options.ignoreTrimWhitespace.read(a),
        maxComputationTimeMs: this._options.maxComputationTimeMs.read(a),
        computeMoves: this._options.showMoves.read(a)
      }, this._cancellationTokenSource.token);
      this._cancellationTokenSource.token.isCancellationRequested || e.original.isDisposed() || e.modified.isDisposed() || (u = Rae(u, e.original, e.modified), u = (e.original, e.modified, void 0) ?? u, u = (e.original, e.modified, void 0) ?? u, xi((g) => {
        r(u, g), this._lastDiff = u;
        const m = JT.fromDiffResult(u);
        this._diff.set(m, g), this._isDiffUpToDate.set(!0, g);
        const p = this.movedTextToCompare.get();
        this.movedTextToCompare.set(p ? this._lastDiff.moves.find((A) => A.lineRangeMapping.modified.intersect(p.lineRangeMapping.modified)) : void 0, g);
      }));
    }));
  }
  ensureModifiedLineIsVisible(e, t, i) {
    if (this.diff.get()?.mappings.length === 0)
      return;
    const n = this._unchangedRegions.get()?.regions || [];
    for (const o of n)
      if (o.getHiddenModifiedRange(void 0).contains(e)) {
        o.showModifiedLine(e, t, i);
        return;
      }
  }
  ensureOriginalLineIsVisible(e, t, i) {
    if (this.diff.get()?.mappings.length === 0)
      return;
    const n = this._unchangedRegions.get()?.regions || [];
    for (const o of n)
      if (o.getHiddenOriginalRange(void 0).contains(e)) {
        o.showOriginalLine(e, t, i);
        return;
      }
  }
  async waitForDiff() {
    await c$(this.isDiffUpToDate, (e) => e);
  }
  serializeState() {
    return {
      collapsedRegions: this._unchangedRegions.get()?.regions.map((t) => ({ range: t.getHiddenModifiedRange(void 0).serialize() }))
    };
  }
  restoreSerializedState(e) {
    const t = e.collapsedRegions?.map((n) => Ee.deserialize(n.range)), i = this._unchangedRegions.get();
    !i || !t || xi((n) => {
      for (const o of i.regions)
        for (const r of t)
          if (o.modifiedUnchangedRange.intersect(r)) {
            o.setHiddenModifiedRange(r, n);
            break;
          }
    });
  }
};
VD = Tae([
  Bae(2, Y8)
], VD);
function Rae(s, e, t) {
  return {
    changes: s.changes.map((i) => new qs(i.original, i.modified, i.innerChanges ? i.innerChanges.map((n) => Fae(n, e, t)) : void 0)),
    moves: s.moves,
    identical: s.identical,
    quitEarly: s.quitEarly
  };
}
function Fae(s, e, t) {
  let i = s.originalRange, n = s.modifiedRange;
  return i.startColumn === 1 && n.startColumn === 1 && (i.endColumn !== 1 || n.endColumn !== 1) && i.endColumn === e.getLineMaxColumn(i.endLineNumber) && n.endColumn === t.getLineMaxColumn(n.endLineNumber) && i.endLineNumber < e.getLineCount() && n.endLineNumber < t.getLineCount() && (i = i.setEndPosition(i.endLineNumber + 1, 1), n = n.setEndPosition(n.endLineNumber + 1, 1)), new Ps(i, n);
}
class JT {
  static fromDiffResult(e) {
    return new JT(e.changes.map((t) => new J8(t)), e.moves || [], e.identical, e.quitEarly);
  }
  constructor(e, t, i, n) {
    this.mappings = e, this.movedTexts = t, this.identical = i, this.quitEarly = n;
  }
}
class J8 {
  constructor(e) {
    this.lineRangeMapping = e;
  }
}
class Bc {
  static fromDiffs(e, t, i, n, o) {
    const r = qs.inverse(e, t, i), a = [];
    for (const l of r) {
      let c = l.original.startLineNumber, d = l.modified.startLineNumber, h = l.original.length;
      const u = c === 1 && d === 1, g = c + h === t + 1 && d + h === i + 1;
      (u || g) && h >= o + n ? (u && !g && (h -= o), g && !u && (c += o, d += o, h -= o), a.push(new Bc(c, d, h, 0, 0))) : h >= o * 2 + n && (c += o, d += o, h -= o * 2, a.push(new Bc(c, d, h, 0, 0)));
    }
    return a;
  }
  get originalUnchangedRange() {
    return Ee.ofLength(this.originalLineNumber, this.lineCount);
  }
  get modifiedUnchangedRange() {
    return Ee.ofLength(this.modifiedLineNumber, this.lineCount);
  }
  constructor(e, t, i, n, o) {
    this.originalLineNumber = e, this.modifiedLineNumber = t, this.lineCount = i, this._visibleLineCountTop = ot(this, 0), this.visibleLineCountTop = this._visibleLineCountTop, this._visibleLineCountBottom = ot(this, 0), this.visibleLineCountBottom = this._visibleLineCountBottom, this._shouldHideControls = De(this, (l) => (
      /** @description isVisible */
      this.visibleLineCountTop.read(l) + this.visibleLineCountBottom.read(l) === this.lineCount && !this.isDragged.read(l)
    )), this.isDragged = ot(this, void 0);
    const r = Math.max(Math.min(n, this.lineCount), 0), a = Math.max(Math.min(o, this.lineCount - n), 0);
    _R(n === r), _R(o === a), this._visibleLineCountTop.set(r, void 0), this._visibleLineCountBottom.set(a, void 0);
  }
  setVisibleRanges(e, t) {
    const i = [], n = new go(e.map((l) => l.modified)).subtractFrom(this.modifiedUnchangedRange);
    let o = this.originalLineNumber, r = this.modifiedLineNumber;
    const a = this.modifiedLineNumber + this.lineCount;
    if (n.ranges.length === 0)
      this.showAll(t), i.push(this);
    else {
      let l = 0;
      for (const c of n.ranges) {
        const d = l === n.ranges.length - 1;
        l++;
        const h = (d ? a : c.endLineNumberExclusive) - r, u = new Bc(o, r, h, 0, 0);
        u.setHiddenModifiedRange(c, t), i.push(u), o = u.originalUnchangedRange.endLineNumberExclusive, r = u.modifiedUnchangedRange.endLineNumberExclusive;
      }
    }
    return i;
  }
  shouldHideControls(e) {
    return this._shouldHideControls.read(e);
  }
  getHiddenOriginalRange(e) {
    return Ee.ofLength(this.originalLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  getHiddenModifiedRange(e) {
    return Ee.ofLength(this.modifiedLineNumber + this._visibleLineCountTop.read(e), this.lineCount - this._visibleLineCountTop.read(e) - this._visibleLineCountBottom.read(e));
  }
  setHiddenModifiedRange(e, t) {
    const i = e.startLineNumber - this.modifiedLineNumber, n = this.modifiedLineNumber + this.lineCount - e.endLineNumberExclusive;
    this.setState(i, n, t);
  }
  getMaxVisibleLineCountTop() {
    return this.lineCount - this._visibleLineCountBottom.get();
  }
  getMaxVisibleLineCountBottom() {
    return this.lineCount - this._visibleLineCountTop.get();
  }
  showMoreAbove(e = 10, t) {
    const i = this.getMaxVisibleLineCountTop();
    this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + e, i), t);
  }
  showMoreBelow(e = 10, t) {
    const i = this.lineCount - this._visibleLineCountTop.get();
    this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + e, i), t);
  }
  showAll(e) {
    this._visibleLineCountBottom.set(this.lineCount - this._visibleLineCountTop.get(), e);
  }
  showModifiedLine(e, t, i) {
    const n = e + 1 - (this.modifiedLineNumber + this._visibleLineCountTop.get()), o = this.modifiedLineNumber - this._visibleLineCountBottom.get() + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(this._visibleLineCountTop.get() + n, i) : this._visibleLineCountBottom.set(this._visibleLineCountBottom.get() + o, i);
  }
  showOriginalLine(e, t, i) {
    const n = e - this.originalLineNumber, o = this.originalLineNumber + this.lineCount - e;
    t === 0 && n < o || t === 1 ? this._visibleLineCountTop.set(Math.min(this._visibleLineCountTop.get() + o - n, this.getMaxVisibleLineCountTop()), i) : this._visibleLineCountBottom.set(Math.min(this._visibleLineCountBottom.get() + n - o, this.getMaxVisibleLineCountBottom()), i);
  }
  collapseAll(e) {
    this._visibleLineCountTop.set(0, e), this._visibleLineCountBottom.set(0, e);
  }
  setState(e, t, i) {
    e = Math.max(Math.min(e, this.lineCount), 0), t = Math.max(Math.min(t, this.lineCount - e), 0), this._visibleLineCountTop.set(e, i), this._visibleLineCountBottom.set(t, i);
  }
}
class Oae extends V {
  get visibility() {
    return this._visibility;
  }
  set visibility(e) {
    this._visibility !== e && (this._visibility = e, this._diffActions.style.visibility = e ? "visible" : "hidden");
  }
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._getViewZoneId = e, this._marginDomNode = t, this._modifiedEditor = i, this._diff = n, this._editor = o, this._viewLineCounts = r, this._originalTextModel = a, this._contextMenuService = l, this._clipboardService = c, this._visibility = !1, this._marginDomNode.style.zIndex = "10", this._diffActions = document.createElement("div"), this._diffActions.className = pe.asClassName(Z.lightBulb) + " lightbulb-glyph", this._diffActions.style.position = "absolute";
    const d = this._modifiedEditor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    this._diffActions.style.right = "0px", this._diffActions.style.visibility = "hidden", this._diffActions.style.height = `${d}px`, this._diffActions.style.lineHeight = `${d}px`, this._marginDomNode.appendChild(this._diffActions);
    let h = 0;
    const u = i.getOption(
      128
      /* EditorOption.useShadowDOM */
    ) && !Ea, g = (m, p) => {
      this._contextMenuService.showContextMenu({
        domForShadowRoot: u ? i.getDomNode() ?? void 0 : void 0,
        getAnchor: () => ({ x: m, y: p }),
        getActions: () => {
          const A = [], _ = n.modified.isEmpty;
          return A.push(new Ks("diff.clipboard.copyDeletedContent", _ ? n.original.length > 1 ? f("diff.clipboard.copyDeletedLinesContent.label", "Copy deleted lines") : f("diff.clipboard.copyDeletedLinesContent.single.label", "Copy deleted line") : n.original.length > 1 ? f("diff.clipboard.copyChangedLinesContent.label", "Copy changed lines") : f("diff.clipboard.copyChangedLinesContent.single.label", "Copy changed line"), void 0, !0, async () => {
            const C = this._originalTextModel.getValueInRange(n.original.toExclusiveRange());
            await this._clipboardService.writeText(C);
          })), n.original.length > 1 && A.push(new Ks("diff.clipboard.copyDeletedLineContent", _ ? f("diff.clipboard.copyDeletedLineContent.label", "Copy deleted line ({0})", n.original.startLineNumber + h) : f("diff.clipboard.copyChangedLineContent.label", "Copy changed line ({0})", n.original.startLineNumber + h), void 0, !0, async () => {
            let C = this._originalTextModel.getLineContent(n.original.startLineNumber + h);
            C === "" && (C = this._originalTextModel.getEndOfLineSequence() === 0 ? `
` : `\r
`), await this._clipboardService.writeText(C);
          })), i.getOption(
            92
            /* EditorOption.readOnly */
          ) || A.push(new Ks("diff.inline.revertChange", f("diff.inline.revertChange.label", "Revert this change"), void 0, !0, async () => {
            this._editor.revert(this._diff);
          })), A;
        },
        autoSelectFirstItem: !0
      });
    };
    this._register(Xt(this._diffActions, "mousedown", (m) => {
      if (!m.leftButton)
        return;
      const { top: p, height: A } = ui(this._diffActions), _ = Math.floor(d / 3);
      m.preventDefault(), g(m.posx, p + A + _);
    })), this._register(i.onMouseMove((m) => {
      (m.target.type === 8 || m.target.type === 5) && m.target.detail.viewZoneId === this._getViewZoneId() ? (h = this._updateLightBulbPosition(this._marginDomNode, m.event.browserEvent.y, d), this.visibility = !0) : this.visibility = !1;
    })), this._register(i.onMouseDown((m) => {
      m.event.leftButton && (m.target.type === 8 || m.target.type === 5) && m.target.detail.viewZoneId === this._getViewZoneId() && (m.event.preventDefault(), h = this._updateLightBulbPosition(this._marginDomNode, m.event.browserEvent.y, d), g(m.event.posx, m.event.posy + d));
    }));
  }
  _updateLightBulbPosition(e, t, i) {
    const { top: n } = ui(e), o = t - n, r = Math.floor(o / i), a = r * i;
    if (this._diffActions.style.top = `${a}px`, this._viewLineCounts) {
      let l = 0;
      for (let c = 0; c < this._viewLineCounts.length; c++)
        if (l += this._viewLineCounts[c], r < l)
          return c;
    }
    return r;
  }
}
const hP = Hu("diffEditorWidget", { createHTML: (s) => s });
function Pae(s, e, t, i) {
  cn(i, e.fontInfo);
  const n = t.length > 0, o = new R0(1e4);
  let r = 0, a = 0;
  const l = [];
  for (let u = 0; u < s.lineTokens.length; u++) {
    const g = u + 1, m = s.lineTokens[u], p = s.lineBreakData[u], A = Qo.filter(t, g, 1, Number.MAX_SAFE_INTEGER);
    if (p) {
      let _ = 0;
      for (const b of p.breakOffsets) {
        const C = m.sliceAndInflate(_, b, 0);
        r = Math.max(r, uP(a, C, Qo.extractWrapped(A, _, b), n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++, _ = b;
      }
      l.push(p.breakOffsets.length);
    } else
      l.push(1), r = Math.max(r, uP(a, m, A, n, s.mightContainNonBasicASCII, s.mightContainRTL, e, o)), a++;
  }
  r += e.scrollBeyondLastColumn;
  const c = o.build(), d = hP ? hP.createHTML(c) : c;
  i.innerHTML = d;
  const h = r * e.typicalHalfwidthCharacterWidth;
  return {
    heightInLines: a,
    minWidthInPx: h,
    viewLineCounts: l
  };
}
class Hae {
  constructor(e, t, i, n) {
    this.lineTokens = e, this.lineBreakData = t, this.mightContainNonBasicASCII = i, this.mightContainRTL = n;
  }
}
class qT {
  static fromEditor(e) {
    const t = e.getOptions(), i = t.get(
      50
      /* EditorOption.fontInfo */
    ), n = t.get(
      146
      /* EditorOption.layoutInfo */
    );
    return new qT(e.getModel()?.getOptions().tabSize || 0, i, t.get(
      33
      /* EditorOption.disableMonospaceOptimizations */
    ), i.typicalHalfwidthCharacterWidth, t.get(
      105
      /* EditorOption.scrollBeyondLastColumn */
    ), t.get(
      67
      /* EditorOption.lineHeight */
    ), n.decorationsWidth, t.get(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), t.get(
      100
      /* EditorOption.renderWhitespace */
    ), t.get(
      95
      /* EditorOption.renderControlCharacters */
    ), t.get(
      51
      /* EditorOption.fontLigatures */
    ));
  }
  constructor(e, t, i, n, o, r, a, l, c, d, h) {
    this.tabSize = e, this.fontInfo = t, this.disableMonospaceOptimizations = i, this.typicalHalfwidthCharacterWidth = n, this.scrollBeyondLastColumn = o, this.lineHeight = r, this.lineDecorationsWidth = a, this.stopRenderingLineAfter = l, this.renderWhitespace = c, this.renderControlCharacters = d, this.fontLigatures = h;
  }
}
function uP(s, e, t, i, n, o, r, a) {
  a.appendString('<div class="view-line'), i || a.appendString(" char-delete"), a.appendString('" style="top:'), a.appendString(String(s * r.lineHeight)), a.appendString('px;width:1000000px;">');
  const l = e.getLineContent(), c = $s.isBasicASCII(l, n), d = $s.containsRTL(l, c, o), h = ET(new km(
    r.fontInfo.isMonospace && !r.disableMonospaceOptimizations,
    r.fontInfo.canUseHalfwidthRightwardsArrow,
    l,
    !1,
    c,
    d,
    0,
    e,
    t,
    r.tabSize,
    0,
    r.fontInfo.spaceWidth,
    r.fontInfo.middotWidth,
    r.fontInfo.wsmiddotWidth,
    r.stopRenderingLineAfter,
    r.renderWhitespace,
    r.renderControlCharacters,
    r.fontLigatures !== hu.OFF,
    null
    // Send no selections, original line cannot be selected
  ), a);
  return a.appendString("</div>"), h.characterMapping.getHorizontalOffset(h.characterMapping.length);
}
var Wae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let zD = class extends V {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    super(), this._targetWindow = e, this._editors = t, this._diffModel = i, this._options = n, this._diffEditorWidget = o, this._canIgnoreViewZoneUpdateEvent = r, this._origViewZonesToIgnore = a, this._modViewZonesToIgnore = l, this._clipboardService = c, this._contextMenuService = d, this._originalTopPadding = ot(this, 0), this._originalScrollOffset = ot(this, 0), this._originalScrollOffsetAnimated = nP(this._targetWindow, this._originalScrollOffset, this._store), this._modifiedTopPadding = ot(this, 0), this._modifiedScrollOffset = ot(this, 0), this._modifiedScrollOffsetAnimated = nP(this._targetWindow, this._modifiedScrollOffset, this._store);
    const h = ot("invalidateAlignmentsState", 0), u = this._register(new zt(() => {
      h.set(h.get() + 1, void 0);
    }, 0));
    this._register(this._editors.original.onDidChangeViewZones((C) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.modified.onDidChangeViewZones((C) => {
      this._canIgnoreViewZoneUpdateEvent() || u.schedule();
    })), this._register(this._editors.original.onDidChangeConfiguration((C) => {
      (C.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || C.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    })), this._register(this._editors.modified.onDidChangeConfiguration((C) => {
      (C.hasChanged(
        147
        /* EditorOption.wrappingInfo */
      ) || C.hasChanged(
        67
        /* EditorOption.lineHeight */
      )) && u.schedule();
    }));
    const g = this._diffModel.map((C) => C ? $t(
      this,
      C.model.original.onDidChangeTokens,
      () => C.model.original.tokenization.backgroundTokenizationState === 2
      /* BackgroundTokenizationState.Completed */
    ) : void 0).map((C, w) => C?.read(w)), m = De((C) => {
      const w = this._diffModel.read(C), S = w?.diff.read(C);
      if (!w || !S)
        return null;
      h.read(C);
      const y = this._options.renderSideBySide.read(C);
      return fP(this._editors.original, this._editors.modified, S.mappings, this._origViewZonesToIgnore, this._modViewZonesToIgnore, y);
    }), p = De((C) => {
      const w = this._diffModel.read(C)?.movedTextToCompare.read(C);
      if (!w)
        return null;
      h.read(C);
      const S = w.changes.map((x) => new J8(x));
      return fP(this._editors.original, this._editors.modified, S, this._origViewZonesToIgnore, this._modViewZonesToIgnore, !0);
    });
    function A() {
      const C = document.createElement("div");
      return C.className = "diagonal-fill", C;
    }
    const _ = this._register(new X());
    this.viewZones = Uu(this, (C, w) => {
      _.clear();
      const S = m.read(C) || [], x = [], y = [], D = this._modifiedTopPadding.read(C);
      D > 0 && y.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: D,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const I = this._originalTopPadding.read(C);
      I > 0 && x.push({
        afterLineNumber: 0,
        domNode: document.createElement("div"),
        heightInPx: I,
        showInHiddenAreas: !0,
        suppressMouseDown: !0
      });
      const Q = this._options.renderSideBySide.read(C), P = Q ? void 0 : this._editors.modified._getViewModel()?.createLineBreaksComputer();
      if (P) {
        const ae = this._editors.original.getModel();
        for (const be of S)
          if (be.diff)
            for (let Ce = be.originalRange.startLineNumber; Ce < be.originalRange.endLineNumberExclusive; Ce++) {
              if (Ce > ae.getLineCount())
                return { orig: x, mod: y };
              P?.addRequest(ae.getLineContent(Ce), null, null);
            }
      }
      const W = P?.finalize() ?? [];
      let j = 0;
      const H = this._editors.modified.getOption(
        67
        /* EditorOption.lineHeight */
      ), J = this._diffModel.read(C)?.movedTextToCompare.read(C), se = this._editors.original.getModel()?.mightContainNonBasicASCII() ?? !1, ce = this._editors.original.getModel()?.mightContainRTL() ?? !1, he = qT.fromEditor(this._editors.modified);
      for (const ae of S)
        if (ae.diff && !Q && (!this._options.useTrueInlineDiffRendering.read(C) || !$T(ae.diff))) {
          if (!ae.originalRange.isEmpty) {
            g.read(C);
            const Ce = document.createElement("div");
            Ce.classList.add("view-lines", "line-delete", "monaco-mouse-cursor-text");
            const Ft = this._editors.original.getModel();
            if (ae.originalRange.endLineNumberExclusive - 1 > Ft.getLineCount())
              return { orig: x, mod: y };
            const ut = new Hae(ae.originalRange.mapToLineArray((Ai) => Ft.tokenization.getLineTokens(Ai)), ae.originalRange.mapToLineArray((Ai) => W[j++]), se, ce), Ut = [];
            for (const Ai of ae.diff.innerChanges || [])
              Ut.push(new Jp(
                Ai.originalRange.delta(-(ae.diff.original.startLineNumber - 1)),
                OD.className,
                0
                /* InlineDecorationType.Regular */
              ));
            const ft = Pae(ut, he, Ut, Ce), ri = document.createElement("div");
            if (ri.className = "inline-deleted-margin-view-zone", cn(ri, he.fontInfo), this._options.renderIndicators.read(C))
              for (let Ai = 0; Ai < ft.heightInLines; Ai++) {
                const Io = document.createElement("div");
                Io.className = `delete-sign ${pe.asClassName(G8)}`, Io.setAttribute("style", `position:absolute;top:${Ai * H}px;width:${he.lineDecorationsWidth}px;height:${H}px;right:0;`), ri.appendChild(Io);
              }
            let io;
            _.add(new Oae(() => xc(io), ri, this._editors.modified, ae.diff, this._diffEditorWidget, ft.viewLineCounts, this._editors.original.getModel(), this._contextMenuService, this._clipboardService));
            for (let Ai = 0; Ai < ft.viewLineCounts.length; Ai++) {
              const Io = ft.viewLineCounts[Ai];
              Io > 1 && x.push({
                afterLineNumber: ae.originalRange.startLineNumber + Ai,
                domNode: A(),
                heightInPx: (Io - 1) * H,
                showInHiddenAreas: !0,
                suppressMouseDown: !0
              });
            }
            y.push({
              afterLineNumber: ae.modifiedRange.startLineNumber - 1,
              domNode: Ce,
              heightInPx: ft.heightInLines * H,
              minWidthInPx: ft.minWidthInPx,
              marginDomNode: ri,
              setZoneId(Ai) {
                io = Ai;
              },
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
          const be = document.createElement("div");
          be.className = "gutter-delete", x.push({
            afterLineNumber: ae.originalRange.endLineNumberExclusive - 1,
            domNode: A(),
            heightInPx: ae.modifiedHeightInPx,
            marginDomNode: be,
            showInHiddenAreas: !0,
            suppressMouseDown: !0
          });
        } else {
          const be = ae.modifiedHeightInPx - ae.originalHeightInPx;
          if (be > 0) {
            if (J?.lineRangeMapping.original.delta(-1).deltaLength(2).contains(ae.originalRange.endLineNumberExclusive - 1))
              continue;
            x.push({
              afterLineNumber: ae.originalRange.endLineNumberExclusive - 1,
              domNode: A(),
              heightInPx: be,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          } else {
            let Ce = function() {
              const ut = document.createElement("div");
              return ut.className = "arrow-revert-change " + pe.asClassName(Z.arrowRight), w.add(U(ut, "mousedown", (Ut) => Ut.stopPropagation())), w.add(U(ut, "click", (Ut) => {
                Ut.stopPropagation(), o.revert(ae.diff);
              })), de("div", {}, ut);
            };
            if (J?.lineRangeMapping.modified.delta(-1).deltaLength(2).contains(ae.modifiedRange.endLineNumberExclusive - 1))
              continue;
            let Ft;
            ae.diff && ae.diff.modified.isEmpty && this._options.shouldRenderOldRevertArrows.read(C) && (Ft = Ce()), y.push({
              afterLineNumber: ae.modifiedRange.endLineNumberExclusive - 1,
              domNode: A(),
              heightInPx: -be,
              marginDomNode: Ft,
              showInHiddenAreas: !0,
              suppressMouseDown: !0
            });
          }
        }
      for (const ae of p.read(C) ?? []) {
        if (!J?.lineRangeMapping.original.intersect(ae.originalRange) || !J?.lineRangeMapping.modified.intersect(ae.modifiedRange))
          continue;
        const be = ae.modifiedHeightInPx - ae.originalHeightInPx;
        be > 0 ? x.push({
          afterLineNumber: ae.originalRange.endLineNumberExclusive - 1,
          domNode: A(),
          heightInPx: be,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        }) : y.push({
          afterLineNumber: ae.modifiedRange.endLineNumberExclusive - 1,
          domNode: A(),
          heightInPx: -be,
          showInHiddenAreas: !0,
          suppressMouseDown: !0
        });
      }
      return { orig: x, mod: y };
    });
    let b = !1;
    this._register(this._editors.original.onDidScrollChange((C) => {
      C.scrollLeftChanged && !b && (b = !0, this._editors.modified.setScrollLeft(C.scrollLeft), b = !1);
    })), this._register(this._editors.modified.onDidScrollChange((C) => {
      C.scrollLeftChanged && !b && (b = !0, this._editors.original.setScrollLeft(C.scrollLeft), b = !1);
    })), this._originalScrollTop = $t(this._editors.original.onDidScrollChange, () => (
      /** @description original.getScrollTop */
      this._editors.original.getScrollTop()
    )), this._modifiedScrollTop = $t(this._editors.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this._editors.modified.getScrollTop()
    )), this._register(et((C) => {
      const w = this._originalScrollTop.read(C) - (this._originalScrollOffsetAnimated.get() - this._modifiedScrollOffsetAnimated.read(C)) - (this._originalTopPadding.get() - this._modifiedTopPadding.read(C));
      w !== this._editors.modified.getScrollTop() && this._editors.modified.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(et((C) => {
      const w = this._modifiedScrollTop.read(C) - (this._modifiedScrollOffsetAnimated.get() - this._originalScrollOffsetAnimated.read(C)) - (this._modifiedTopPadding.get() - this._originalTopPadding.read(C));
      w !== this._editors.original.getScrollTop() && this._editors.original.setScrollTop(
        w,
        1
        /* ScrollType.Immediate */
      );
    })), this._register(et((C) => {
      const w = this._diffModel.read(C)?.movedTextToCompare.read(C);
      let S = 0;
      if (w) {
        const x = this._editors.original.getTopForLineNumber(w.lineRangeMapping.original.startLineNumber, !0) - this._originalTopPadding.get();
        S = this._editors.modified.getTopForLineNumber(w.lineRangeMapping.modified.startLineNumber, !0) - this._modifiedTopPadding.get() - x;
      }
      S > 0 ? (this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(S, void 0)) : S < 0 ? (this._modifiedTopPadding.set(-S, void 0), this._originalTopPadding.set(0, void 0)) : setTimeout(() => {
        this._modifiedTopPadding.set(0, void 0), this._originalTopPadding.set(0, void 0);
      }, 400), this._editors.modified.hasTextFocus() ? this._originalScrollOffset.set(this._modifiedScrollOffset.get() - S, void 0, !0) : this._modifiedScrollOffset.set(this._originalScrollOffset.get() + S, void 0, !0);
    }));
  }
};
zD = Wae([
  gP(8, Yu),
  gP(9, ar)
], zD);
function fP(s, e, t, i, n, o) {
  const r = new Pl(mP(s, i)), a = new Pl(mP(e, n)), l = s.getOption(
    67
    /* EditorOption.lineHeight */
  ), c = e.getOption(
    67
    /* EditorOption.lineHeight */
  ), d = [];
  let h = 0, u = 0;
  function g(m, p) {
    for (; ; ) {
      let A = r.peek(), _ = a.peek();
      if (A && A.lineNumber >= m && (A = void 0), _ && _.lineNumber >= p && (_ = void 0), !A && !_)
        break;
      const b = A ? A.lineNumber - h : Number.MAX_VALUE, C = _ ? _.lineNumber - u : Number.MAX_VALUE;
      b < C ? (r.dequeue(), _ = {
        lineNumber: A.lineNumber - h + u,
        heightInPx: 0
      }) : b > C ? (a.dequeue(), A = {
        lineNumber: _.lineNumber - u + h,
        heightInPx: 0
      }) : (r.dequeue(), a.dequeue()), d.push({
        originalRange: Ee.ofLength(A.lineNumber, 1),
        modifiedRange: Ee.ofLength(_.lineNumber, 1),
        originalHeightInPx: l + A.heightInPx,
        modifiedHeightInPx: c + _.heightInPx,
        diff: void 0
      });
    }
  }
  for (const m of t) {
    let C = function(w, S, x = !1) {
      if (w < b || S < _)
        return;
      if (A)
        A = !1;
      else if (!x && (w === b || S === _))
        return;
      const y = new Ee(b, w), D = new Ee(_, S);
      if (y.isEmpty && D.isEmpty)
        return;
      const I = r.takeWhile((P) => P.lineNumber < w)?.reduce((P, W) => P + W.heightInPx, 0) ?? 0, Q = a.takeWhile((P) => P.lineNumber < S)?.reduce((P, W) => P + W.heightInPx, 0) ?? 0;
      d.push({
        originalRange: y,
        modifiedRange: D,
        originalHeightInPx: y.length * l + I,
        modifiedHeightInPx: D.length * c + Q,
        diff: m.lineRangeMapping
      }), b = w, _ = S;
    };
    const p = m.lineRangeMapping;
    g(p.original.startLineNumber, p.modified.startLineNumber);
    let A = !0, _ = p.modified.startLineNumber, b = p.original.startLineNumber;
    if (o)
      for (const w of p.innerChanges || []) {
        w.originalRange.startColumn > 1 && w.modifiedRange.startColumn > 1 && C(w.originalRange.startLineNumber, w.modifiedRange.startLineNumber);
        const S = s.getModel(), x = w.originalRange.endLineNumber <= S.getLineCount() ? S.getLineMaxColumn(w.originalRange.endLineNumber) : Number.MAX_SAFE_INTEGER;
        w.originalRange.endColumn < x && C(w.originalRange.endLineNumber, w.modifiedRange.endLineNumber);
      }
    C(p.original.endLineNumberExclusive, p.modified.endLineNumberExclusive, !0), h = p.original.endLineNumberExclusive, u = p.modified.endLineNumberExclusive;
  }
  return g(Number.MAX_VALUE, Number.MAX_VALUE), d;
}
function mP(s, e) {
  const t = [], i = [], n = s.getOption(
    147
    /* EditorOption.wrappingInfo */
  ).wrappingColumn !== -1, o = s._getViewModel().coordinatesConverter, r = s.getOption(
    67
    /* EditorOption.lineHeight */
  );
  if (n)
    for (let l = 1; l <= s.getModel().getLineCount(); l++) {
      const c = o.getModelLineViewLineCount(l);
      c > 1 && i.push({ lineNumber: l, heightInPx: r * (c - 1) });
    }
  for (const l of s.getWhitespaces()) {
    if (e.has(l.id))
      continue;
    const c = l.afterLineNumber === 0 ? 0 : o.convertViewPositionToModelPosition(new F(l.afterLineNumber, 1)).lineNumber;
    t.push({ lineNumber: c, heightInPx: l.height });
  }
  return dae(t, i, (l) => l.lineNumber, (l, c) => ({ lineNumber: l.lineNumber, heightInPx: l.heightInPx + c.heightInPx }));
}
function $T(s) {
  return s.innerChanges ? s.innerChanges.every((e) => pP(e.modifiedRange) && pP(e.originalRange) || e.originalRange.equalsRange(new E(1, 1, 1, 1))) : !1;
}
function pP(s) {
  return s.startLineNumber === s.endLineNumber;
}
const bA = class bA extends V {
  constructor(e, t, i, n, o) {
    super(), this._rootElement = e, this._diffModel = t, this._originalEditorLayoutInfo = i, this._modifiedEditorLayoutInfo = n, this._editors = o, this._originalScrollTop = $t(this, this._editors.original.onDidScrollChange, () => this._editors.original.getScrollTop()), this._modifiedScrollTop = $t(this, this._editors.modified.onDidScrollChange, () => this._editors.modified.getScrollTop()), this._viewZonesChanged = fo("onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this.width = ot(this, 0), this._modifiedViewZonesChangedSignal = fo("modified.onDidChangeViewZones", this._editors.modified.onDidChangeViewZones), this._originalViewZonesChangedSignal = fo("original.onDidChangeViewZones", this._editors.original.onDidChangeViewZones), this._state = Uu(this, (d, h) => {
      this._element.replaceChildren();
      const u = this._diffModel.read(d), g = u?.diff.read(d)?.movedTexts;
      if (!g || g.length === 0) {
        this.width.set(0, void 0);
        return;
      }
      this._viewZonesChanged.read(d);
      const m = this._originalEditorLayoutInfo.read(d), p = this._modifiedEditorLayoutInfo.read(d);
      if (!m || !p) {
        this.width.set(0, void 0);
        return;
      }
      this._modifiedViewZonesChangedSignal.read(d), this._originalViewZonesChangedSignal.read(d);
      const A = g.map((y) => {
        function D(ce, he) {
          const ae = he.getTopForLineNumber(ce.startLineNumber, !0), be = he.getTopForLineNumber(ce.endLineNumberExclusive, !0);
          return (ae + be) / 2;
        }
        const I = D(y.lineRangeMapping.original, this._editors.original), Q = this._originalScrollTop.read(d), P = D(y.lineRangeMapping.modified, this._editors.modified), W = this._modifiedScrollTop.read(d), j = I - Q, H = P - W, J = Math.min(I, P), se = Math.max(I, P);
        return { range: new Be(J, se), from: j, to: H, fromWithoutScroll: I, toWithoutScroll: P, move: y };
      });
      A.sort(v9(_o((y) => y.fromWithoutScroll > y.toWithoutScroll, S9), _o((y) => y.fromWithoutScroll > y.toWithoutScroll ? y.fromWithoutScroll : -y.toWithoutScroll, Ml)));
      const _ = XT.compute(A.map((y) => y.range)), b = 10, C = m.verticalScrollbarWidth, w = (_.getTrackCount() - 1) * 10 + b * 2, S = C + w + (p.contentLeft - bA.movedCodeBlockPadding);
      let x = 0;
      for (const y of A) {
        const D = _.getTrack(x), I = C + b + D * 10, Q = 15, P = 15, W = S, j = p.glyphMarginWidth + p.lineNumbersWidth, H = 18, J = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        J.classList.add("arrow-rectangle"), J.setAttribute("x", `${W - j}`), J.setAttribute("y", `${y.to - H / 2}`), J.setAttribute("width", `${j}`), J.setAttribute("height", `${H}`), this._element.appendChild(J);
        const se = document.createElementNS("http://www.w3.org/2000/svg", "g"), ce = document.createElementNS("http://www.w3.org/2000/svg", "path");
        ce.setAttribute("d", `M 0 ${y.from} L ${I} ${y.from} L ${I} ${y.to} L ${W - P} ${y.to}`), ce.setAttribute("fill", "none"), se.appendChild(ce);
        const he = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
        he.classList.add("arrow"), h.add(et((ae) => {
          ce.classList.toggle("currentMove", y.move === u.activeMovedText.read(ae)), he.classList.toggle("currentMove", y.move === u.activeMovedText.read(ae));
        })), he.setAttribute("points", `${W - P},${y.to - Q / 2} ${W},${y.to} ${W - P},${y.to + Q / 2}`), se.appendChild(he), this._element.appendChild(se), x++;
      }
      this.width.set(w, void 0);
    }), this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("class", "moved-blocks-lines"), this._rootElement.appendChild(this._element), this._register(we(() => this._element.remove())), this._register(et((d) => {
      const h = this._originalEditorLayoutInfo.read(d), u = this._modifiedEditorLayoutInfo.read(d);
      !h || !u || (this._element.style.left = `${h.width - h.verticalScrollbarWidth}px`, this._element.style.height = `${h.height}px`, this._element.style.width = `${h.verticalScrollbarWidth + h.contentLeft - bA.movedCodeBlockPadding + this.width.read(d)}px`);
    })), this._register(rS(this._state));
    const r = De((d) => {
      const u = this._diffModel.read(d)?.diff.read(d);
      return u ? u.movedTexts.map((g) => ({
        move: g,
        original: new jg(RC(g.lineRangeMapping.original.startLineNumber - 1), 18),
        modified: new jg(RC(g.lineRangeMapping.modified.startLineNumber - 1), 18)
      })) : [];
    });
    this._register(Bv(this._editors.original, r.map((d) => (
      /** @description movedBlockViewZones.original */
      d.map((h) => h.original)
    )))), this._register(Bv(this._editors.modified, r.map((d) => (
      /** @description movedBlockViewZones.modified */
      d.map((h) => h.modified)
    )))), this._register(Yo((d, h) => {
      const u = r.read(d);
      for (const g of u)
        h.add(new AP(this._editors.original, g.original, g.move, "original", this._diffModel.get())), h.add(new AP(this._editors.modified, g.modified, g.move, "modified", this._diffModel.get()));
    }));
    const a = fo("original.onDidFocusEditorWidget", (d) => this._editors.original.onDidFocusEditorWidget(() => setTimeout(() => d(void 0), 0))), l = fo("modified.onDidFocusEditorWidget", (d) => this._editors.modified.onDidFocusEditorWidget(() => setTimeout(() => d(void 0), 0)));
    let c = "modified";
    this._register(sS({
      createEmptyChangeSummary: () => {
      },
      handleChange: (d, h) => (d.didChange(a) && (c = "original"), d.didChange(l) && (c = "modified"), !0)
    }, (d) => {
      a.read(d), l.read(d);
      const h = this._diffModel.read(d);
      if (!h)
        return;
      const u = h.diff.read(d);
      let g;
      if (u && c === "original") {
        const m = this._editors.originalCursor.read(d);
        m && (g = u.movedTexts.find((p) => p.lineRangeMapping.original.contains(m.lineNumber)));
      }
      if (u && c === "modified") {
        const m = this._editors.modifiedCursor.read(d);
        m && (g = u.movedTexts.find((p) => p.lineRangeMapping.modified.contains(m.lineNumber)));
      }
      g !== h.movedTextToCompare.get() && h.movedTextToCompare.set(void 0, void 0), h.setActiveMovedText(g);
    }));
  }
};
bA.movedCodeBlockPadding = 4;
let Tf = bA;
class XT {
  static compute(e) {
    const t = [], i = [];
    for (const n of e) {
      let o = t.findIndex((r) => !r.intersectsStrict(n));
      o === -1 && (t.length >= 6 ? o = rG(t, _o((a) => a.intersectWithRangeLength(n), Ml)) : (o = t.length, t.push(new aN()))), t[o].addRange(n), i.push(o);
    }
    return new XT(t.length, i);
  }
  constructor(e, t) {
    this._trackCount = e, this.trackPerLineIdx = t;
  }
  getTrack(e) {
    return this.trackPerLineIdx[e];
  }
  getTrackCount() {
    return this._trackCount;
  }
}
class AP extends GT {
  constructor(e, t, i, n, o) {
    const r = it("div.diff-hidden-lines-widget");
    super(e, t, r.root), this._editor = e, this._move = i, this._kind = n, this._diffModel = o, this._nodes = it("div.diff-moved-code-block", { style: { marginRight: "4px" } }, [
      it("div.text-content@textContent"),
      it("div.action-bar@actionBar")
    ]), r.root.appendChild(this._nodes.root);
    const a = $t(this._editor.onDidLayoutChange, () => this._editor.getLayoutInfo());
    this._register(fd(this._nodes.root, {
      paddingRight: a.map((u) => u.verticalScrollbarWidth)
    }));
    let l;
    i.changes.length > 0 ? l = this._kind === "original" ? f("codeMovedToWithChanges", "Code moved with changes to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : f("codeMovedFromWithChanges", "Code moved with changes from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1) : l = this._kind === "original" ? f("codeMovedTo", "Code moved to line {0}-{1}", this._move.lineRangeMapping.modified.startLineNumber, this._move.lineRangeMapping.modified.endLineNumberExclusive - 1) : f("codeMovedFrom", "Code moved from line {0}-{1}", this._move.lineRangeMapping.original.startLineNumber, this._move.lineRangeMapping.original.endLineNumberExclusive - 1);
    const c = this._register(new wo(this._nodes.actionBar, {
      highlightToggledItems: !0
    })), d = new Ks("", l, "", !1);
    c.push(d, { icon: !1, label: !0 });
    const h = new Ks("", "Compare", pe.asClassName(Z.compareChanges), !0, () => {
      this._editor.focus(), this._diffModel.movedTextToCompare.set(this._diffModel.movedTextToCompare.get() === i ? void 0 : this._move, void 0);
    });
    this._register(et((u) => {
      const g = this._diffModel.movedTextToCompare.read(u) === i;
      h.checked = g;
    })), c.push(h, { icon: !1, label: !0 });
  }
}
class Vae extends V {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._decorations = De(this, (o) => {
      const r = this._diffModel.read(o), a = r?.diff.read(o);
      if (!a)
        return null;
      const l = this._diffModel.read(o).movedTextToCompare.read(o), c = this._options.renderIndicators.read(o), d = this._options.showEmptyDecorations.read(o), h = [], u = [];
      if (!l)
        for (const m of a.mappings)
          if (m.lineRangeMapping.original.isEmpty || h.push({ range: m.lineRangeMapping.original.toInclusiveRange(), options: c ? aP : cP }), m.lineRangeMapping.modified.isEmpty || u.push({ range: m.lineRangeMapping.modified.toInclusiveRange(), options: c ? rP : lP }), m.lineRangeMapping.modified.isEmpty || m.lineRangeMapping.original.isEmpty)
            m.lineRangeMapping.original.isEmpty || h.push({ range: m.lineRangeMapping.original.toInclusiveRange(), options: Dae }), m.lineRangeMapping.modified.isEmpty || u.push({ range: m.lineRangeMapping.modified.toInclusiveRange(), options: Lae });
          else {
            const p = this._options.useTrueInlineDiffRendering.read(o) && $T(m.lineRangeMapping);
            for (const A of m.lineRangeMapping.innerChanges || [])
              if (m.lineRangeMapping.original.contains(A.originalRange.startLineNumber) && h.push({ range: A.originalRange, options: A.originalRange.isEmpty() && d ? Iae : OD }), m.lineRangeMapping.modified.contains(A.modifiedRange.startLineNumber) && u.push({ range: A.modifiedRange, options: A.modifiedRange.isEmpty() && d && !p ? kae : dP }), p) {
                const _ = r.model.original.getValueInRange(A.originalRange);
                u.push({
                  range: A.modifiedRange,
                  options: {
                    description: "deleted-text",
                    before: {
                      content: _,
                      inlineClassName: "inline-deleted-text"
                    },
                    zIndex: 1e5,
                    showIfCollapsed: !0
                  }
                });
              }
          }
      if (l)
        for (const m of l.changes) {
          const p = m.original.toInclusiveRange();
          p && h.push({ range: p, options: c ? aP : cP });
          const A = m.modified.toInclusiveRange();
          A && u.push({ range: A, options: c ? rP : lP });
          for (const _ of m.innerChanges || [])
            h.push({ range: _.originalRange, options: OD }), u.push({ range: _.modifiedRange, options: dP });
        }
      const g = this._diffModel.read(o).activeMovedText.read(o);
      for (const m of a.movedTexts)
        h.push({
          range: m.lineRangeMapping.original.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedOriginal" + (m === g ? " currentMove" : ""),
            blockPadding: [Tf.movedCodeBlockPadding, 0, Tf.movedCodeBlockPadding, Tf.movedCodeBlockPadding]
          }
        }), u.push({
          range: m.lineRangeMapping.modified.toInclusiveRange(),
          options: {
            description: "moved",
            blockClassName: "movedModified" + (m === g ? " currentMove" : ""),
            blockPadding: [4, 0, 4, 4]
          }
        });
      return { originalDecorations: h, modifiedDecorations: u };
    }), this._register(Tv(this._editors.original, this._decorations.map((o) => o?.originalDecorations || []))), this._register(Tv(this._editors.modified, this._decorations.map((o) => o?.modifiedDecorations || [])));
  }
}
class zae {
  resetSash() {
    this._sashRatio.set(void 0, void 0);
  }
  constructor(e, t) {
    this._options = e, this.dimensions = t, this.sashLeft = VN(this, (i) => {
      const n = this._sashRatio.read(i) ?? this._options.splitViewDefaultRatio.read(i);
      return this._computeSashLeft(n, i);
    }, (i, n) => {
      const o = this.dimensions.width.get();
      this._sashRatio.set(i / o, n);
    }), this._sashRatio = ot(this, void 0);
  }
  /** @pure */
  _computeSashLeft(e, t) {
    const i = this.dimensions.width.read(t), n = Math.floor(this._options.splitViewDefaultRatio.read(t) * i), o = this._options.enableSplitViewResizing.read(t) ? Math.floor(e * i) : n, r = 100;
    return i <= r * 2 ? n : o < r ? r : o > i - r ? i - r : o;
  }
}
class q8 extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._domNode = e, this._dimensions = t, this._enabled = i, this._boundarySashes = n, this.sashLeft = o, this._resetSash = r, this._sash = this._register(new rn(this._domNode, {
      getVerticalSashTop: (a) => 0,
      getVerticalSashLeft: (a) => this.sashLeft.get(),
      getVerticalSashHeight: (a) => this._dimensions.height.get()
    }, {
      orientation: 0
      /* Orientation.VERTICAL */
    })), this._startSashPosition = void 0, this._register(this._sash.onDidStart(() => {
      this._startSashPosition = this.sashLeft.get();
    })), this._register(this._sash.onDidChange((a) => {
      this.sashLeft.set(this._startSashPosition + (a.currentX - a.startX), void 0);
    })), this._register(this._sash.onDidEnd(() => this._sash.layout())), this._register(this._sash.onDidReset(() => this._resetSash())), this._register(et((a) => {
      const l = this._boundarySashes.read(a);
      l && (this._sash.orthogonalEndSash = l.bottom);
    })), this._register(et((a) => {
      const l = this._enabled.read(a);
      this._sash.state = l ? 3 : 0, this.sashLeft.read(a), this._dimensions.height.read(a), this._sash.layout();
    }));
  }
}
class Uae extends V {
  constructor(e, t, i) {
    super(), this._editor = e, this._domNode = t, this.itemProvider = i, this.scrollTop = $t(this, this._editor.onDidScrollChange, (r) => (
      /** @description editor.onDidScrollChange */
      this._editor.getScrollTop()
    )), this.isScrollTopZero = this.scrollTop.map((r) => (
      /** @description isScrollTopZero */
      r === 0
    )), this.modelAttached = $t(this, this._editor.onDidChangeModel, (r) => (
      /** @description editor.onDidChangeModel */
      this._editor.hasModel()
    )), this.editorOnDidChangeViewZones = fo("onDidChangeViewZones", this._editor.onDidChangeViewZones), this.editorOnDidContentSizeChange = fo("onDidContentSizeChange", this._editor.onDidContentSizeChange), this.domNodeSizeChanged = zN("domNodeSizeChanged"), this.views = /* @__PURE__ */ new Map(), this._domNode.className = "gutter monaco-editor";
    const n = this._domNode.appendChild(it("div.scroll-decoration", { role: "presentation", ariaHidden: "true", style: { width: "100%" } }).root), o = new ResizeObserver(() => {
      xi((r) => {
        this.domNodeSizeChanged.trigger(r);
      });
    });
    o.observe(this._domNode), this._register(we(() => o.disconnect())), this._register(et((r) => {
      n.className = this.isScrollTopZero.read(r) ? "" : "scroll-decoration";
    })), this._register(et((r) => (
      /** @description EditorGutter.Render */
      this.render(r)
    )));
  }
  dispose() {
    super.dispose(), Rn(this._domNode);
  }
  render(e) {
    if (!this.modelAttached.read(e))
      return;
    this.domNodeSizeChanged.read(e), this.editorOnDidChangeViewZones.read(e), this.editorOnDidContentSizeChange.read(e);
    const t = this.scrollTop.read(e), i = this._editor.getVisibleRanges(), n = new Set(this.views.keys()), o = Be.ofStartAndLength(0, this._domNode.clientHeight);
    if (!o.isEmpty)
      for (const r of i) {
        const a = new Ee(r.startLineNumber, r.endLineNumber + 1), l = this.itemProvider.getIntersectingGutterItems(a, e);
        xi((c) => {
          for (const d of l) {
            if (!d.range.intersect(a))
              continue;
            n.delete(d.id);
            let h = this.views.get(d.id);
            if (h)
              h.item.set(d, c);
            else {
              const p = document.createElement("div");
              this._domNode.appendChild(p);
              const A = ot("item", d), _ = this.itemProvider.createView(A, p);
              h = new Qae(A, _, p), this.views.set(d.id, h);
            }
            const u = d.range.startLineNumber <= this._editor.getModel().getLineCount() ? this._editor.getTopForLineNumber(d.range.startLineNumber, !0) - t : this._editor.getBottomForLineNumber(d.range.startLineNumber - 1, !1) - t, m = (d.range.endLineNumberExclusive === 1 ? Math.max(u, this._editor.getTopForLineNumber(d.range.startLineNumber, !1) - t) : Math.max(u, this._editor.getBottomForLineNumber(d.range.endLineNumberExclusive - 1, !0) - t)) - u;
            h.domNode.style.top = `${u}px`, h.domNode.style.height = `${m}px`, h.gutterItemView.layout(Be.ofStartAndLength(u, m), o);
          }
        });
      }
    for (const r of n) {
      const a = this.views.get(r);
      a.gutterItemView.dispose(), a.domNode.remove(), this.views.delete(r);
    }
  }
}
class Qae {
  constructor(e, t, i) {
    this.item = e, this.gutterItemView = t, this.domNode = i;
  }
}
class $8 extends Au {
  constructor(e) {
    super(), this._getContext = e;
  }
  runAction(e, t) {
    const i = this._getContext();
    return super.runAction(e, i);
  }
}
class _P extends C5 {
  constructor(e) {
    super(), this._textModel = e;
  }
  getValueOfRange(e) {
    return this._textModel.getValueInRange(e);
  }
  get length() {
    const e = this._textModel.getLineCount(), t = this._textModel.getLineLength(e);
    return new ad(e - 1, t);
  }
}
class Gae extends V {
  constructor(e, t, i = {
    orientation: 0
    /* ActionsOrientation.HORIZONTAL */
  }) {
    super(), this.submenuActionViewItems = [], this.hasSecondaryActions = !1, this._onDidChangeDropdownVisibility = this._register(new Kz()), this.onDidChangeDropdownVisibility = this._onDidChangeDropdownVisibility.event, this.disposables = this._register(new X()), i.hoverDelegate = i.hoverDelegate ?? this._register(im()), this.options = i, this.toggleMenuAction = this._register(new g_(() => this.toggleMenuActionViewItem?.show(), i.toggleMenuTitle)), this.element = document.createElement("div"), this.element.className = "monaco-toolbar", e.appendChild(this.element), this.actionBar = this._register(new wo(this.element, {
      orientation: i.orientation,
      ariaLabel: i.ariaLabel,
      actionRunner: i.actionRunner,
      allowContextMenu: i.allowContextMenu,
      highlightToggledItems: i.highlightToggledItems,
      hoverDelegate: i.hoverDelegate,
      actionViewItemProvider: (n, o) => {
        if (n.id === g_.ID)
          return this.toggleMenuActionViewItem = new OC(n, n.menuActions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: pe.asClassNameArray(i.moreIcon ?? Z.toolBarMore),
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            isMenu: !0,
            hoverDelegate: this.options.hoverDelegate
          }), this.toggleMenuActionViewItem.setActionContext(this.actionBar.context), this.disposables.add(this._onDidChangeDropdownVisibility.add(this.toggleMenuActionViewItem.onDidChangeVisibility)), this.toggleMenuActionViewItem;
        if (i.actionViewItemProvider) {
          const r = i.actionViewItemProvider(n, o);
          if (r)
            return r;
        }
        if (n instanceof Uf) {
          const r = new OC(n, n.actions, t, {
            actionViewItemProvider: this.options.actionViewItemProvider,
            actionRunner: this.actionRunner,
            keybindingProvider: this.options.getKeyBinding,
            classNames: n.class,
            anchorAlignmentProvider: this.options.anchorAlignmentProvider,
            menuAsChild: !!this.options.renderDropdownAsChildElement,
            skipTelemetry: this.options.skipTelemetry,
            hoverDelegate: this.options.hoverDelegate
          });
          return r.setActionContext(this.actionBar.context), this.submenuActionViewItems.push(r), this.disposables.add(this._onDidChangeDropdownVisibility.add(r.onDidChangeVisibility)), r;
        }
      }
    }));
  }
  set actionRunner(e) {
    this.actionBar.actionRunner = e;
  }
  get actionRunner() {
    return this.actionBar.actionRunner;
  }
  getElement() {
    return this.element;
  }
  getItemAction(e) {
    return this.actionBar.getAction(e);
  }
  setActions(e, t) {
    this.clear();
    const i = e ? e.slice(0) : [];
    this.hasSecondaryActions = !!(t && t.length > 0), this.hasSecondaryActions && t && (this.toggleMenuAction.menuActions = t.slice(0), i.push(this.toggleMenuAction)), i.forEach((n) => {
      this.actionBar.push(n, { icon: this.options.icon ?? !0, label: this.options.label ?? !1, keybinding: this.getKeybindingLabel(n) });
    });
  }
  getKeybindingLabel(e) {
    return this.options.getKeyBinding?.(e)?.getLabel() ?? void 0;
  }
  clear() {
    this.submenuActionViewItems = [], this.disposables.clear(), this.actionBar.clear();
  }
  dispose() {
    this.clear(), this.disposables.dispose(), super.dispose();
  }
}
const t0 = class t0 extends Ks {
  constructor(e, t) {
    t = t || f("moreActions", "More Actions..."), super(t0.ID, t, void 0, !0), this._menuActions = [], this.toggleDropdownMenu = e;
  }
  async run() {
    this.toggleDropdownMenu();
  }
  get menuActions() {
    return this._menuActions;
  }
  set menuActions(e) {
    this._menuActions = e;
  }
};
t0.ID = "toolbar.toggle.more";
let g_ = t0;
var X8 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zo = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Fv = class extends Gae {
  constructor(e, t, i, n, o, r, a, l) {
    super(e, o, {
      // defaults
      getKeyBinding: (d) => r.lookupKeybinding(d.id) ?? void 0,
      // options (override defaults)
      ...t,
      // mandatory (overide options)
      allowContextMenu: !0,
      skipTelemetry: typeof t?.telemetrySource == "string"
    }), this._options = t, this._menuService = i, this._contextKeyService = n, this._contextMenuService = o, this._keybindingService = r, this._commandService = a, this._sessionDisposables = this._store.add(new X());
    const c = t?.telemetrySource;
    c && this._store.add(this.actionBar.onDidRun((d) => l.publicLog2("workbenchActionExecuted", { id: d.action.id, from: c })));
  }
  setActions(e, t = [], i) {
    this._sessionDisposables.clear();
    const n = e.slice(), o = t.slice(), r = [];
    let a = 0;
    const l = [];
    let c = !1;
    if (this._options?.hiddenItemStrategy !== -1)
      for (let d = 0; d < n.length; d++) {
        const h = n[d];
        !(h instanceof bo) && !(h instanceof mf) || h.hideActions && (r.push(h.hideActions.toggle), h.hideActions.toggle.checked && a++, h.hideActions.isHidden && (c = !0, n[d] = void 0, this._options?.hiddenItemStrategy !== 0 && (l[d] = h)));
      }
    if (this._options?.overflowBehavior !== void 0) {
      const d = jX(new Set(this._options.overflowBehavior.exempted), nt.map(n, (g) => g?.id)), h = this._options.overflowBehavior.maxItems - d.size;
      let u = 0;
      for (let g = 0; g < n.length; g++) {
        const m = n[g];
        m && (u++, !d.has(m.id) && u >= h && (n[g] = void 0, l[g] = m));
      }
    }
    FB(n), FB(l), super.setActions(n, Ri.join(l, o)), (r.length > 0 || n.length > 0) && this._sessionDisposables.add(U(this.getElement(), "contextmenu", (d) => {
      const h = new Ir(fe(this.getElement()), d), u = this.getItemAction(h.target);
      if (!u)
        return;
      h.preventDefault(), h.stopPropagation();
      const g = [];
      if (u instanceof bo && u.menuKeybinding)
        g.push(u.menuKeybinding);
      else if (!(u instanceof mf || u instanceof g_)) {
        const p = !!this._keybindingService.lookupKeybinding(u.id);
        g.push(g8(this._commandService, this._keybindingService, u.id, void 0, p));
      }
      if (r.length > 0) {
        let p = !1;
        if (a === 1 && this._options?.hiddenItemStrategy === 0) {
          p = !0;
          for (let A = 0; A < r.length; A++)
            if (r[A].checked) {
              r[A] = gf({
                id: u.id,
                label: u.label,
                checked: !0,
                enabled: !1,
                run() {
                }
              });
              break;
            }
        }
        if (!p && (u instanceof bo || u instanceof mf)) {
          if (!u.hideActions)
            return;
          g.push(u.hideActions.hide);
        } else
          g.push(gf({
            id: "label",
            label: f("hide", "Hide"),
            enabled: !1,
            run() {
            }
          }));
      }
      const m = Ri.join(g, r);
      this._options?.resetMenu && !i && (i = [this._options.resetMenu]), c && i && (m.push(new Ri()), m.push(gf({
        id: "resetThisMenu",
        label: f("resetThisMenu", "Reset Menu"),
        run: () => this._menuService.resetHiddenStates(i)
      }))), m.length !== 0 && this._contextMenuService.showContextMenu({
        getAnchor: () => h,
        getActions: () => m,
        // add context menu actions (iff appicable)
        menuId: this._options?.contextMenu,
        menuActionOptions: { renderShortTitle: !0, ...this._options?.menuOptions },
        skipTelemetry: typeof this._options?.telemetrySource == "string",
        contextKeyService: this._contextKeyService
      });
    }));
  }
};
Fv = X8([
  zo(2, sr),
  zo(3, Se),
  zo(4, ar),
  zo(5, bt),
  zo(6, bi),
  zo(7, eo)
], Fv);
let Ov = class extends Fv {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { resetMenu: t, ...i }, n, o, r, a, l, c), this._onDidChangeMenuItems = this._store.add(new B()), this.onDidChangeMenuItems = this._onDidChangeMenuItems.event;
    const d = this._store.add(n.createMenu(t, o, { emitEventsForSubmenuChanges: !0 })), h = () => {
      const u = [], g = [];
      UN(d, i?.menuOptions, { primary: u, secondary: g }, i?.toolbarOptions?.primaryGroup, i?.toolbarOptions?.shouldInlineSubmenu, i?.toolbarOptions?.useSeparatorsInPrimaryActions), e.classList.toggle("has-no-actions", u.length === 0 && g.length === 0), super.setActions(u, g);
    };
    this._store.add(d.onDidChange(() => {
      h(), this._onDidChangeMenuItems.fire(this);
    })), h();
  }
  /**
   * @deprecated The WorkbenchToolBar does not support this method because it works with menus.
   */
  setActions() {
    throw new lt("This toolbar is populated from a menu.");
  }
};
Ov = X8([
  zo(3, sr),
  zo(4, Se),
  zo(5, ar),
  zo(6, bt),
  zo(7, bi),
  zo(8, eo)
], Ov);
var Z8 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Pw = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const lx = [], Yb = 35;
let UD = class extends V {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(), this._diffModel = t, this._editors = i, this._options = n, this._sashLayout = o, this._boundarySashes = r, this._instantiationService = a, this._contextKeyService = l, this._menuService = c, this._menu = this._register(this._menuService.createMenu(Qe.DiffEditorHunkToolbar, this._contextKeyService)), this._actions = $t(this, this._menu.onDidChange, () => this._menu.getActions()), this._hasActions = this._actions.map((d) => d.length > 0), this._showSash = De(this, (d) => this._options.renderSideBySide.read(d) && this._hasActions.read(d)), this.width = De(this, (d) => this._hasActions.read(d) ? Yb : 0), this.elements = it("div.gutter@gutter", { style: { position: "absolute", height: "100%", width: Yb + "px" } }, []), this._currentDiff = De(this, (d) => {
      const h = this._diffModel.read(d);
      if (!h)
        return;
      const u = h.diff.read(d)?.mappings, g = this._editors.modifiedCursor.read(d);
      if (g)
        return u?.find((m) => m.lineRangeMapping.modified.contains(g.lineNumber));
    }), this._selectedDiffs = De(this, (d) => {
      const u = this._diffModel.read(d)?.diff.read(d);
      if (!u)
        return lx;
      const g = this._editors.modifiedSelections.read(d);
      if (g.every((_) => _.isEmpty()))
        return lx;
      const m = new go(g.map((_) => Ee.fromRangeInclusive(_))), A = u.mappings.filter((_) => _.lineRangeMapping.innerChanges && m.intersects(_.lineRangeMapping.modified)).map((_) => ({
        mapping: _,
        rangeMappings: _.lineRangeMapping.innerChanges.filter((b) => g.some((C) => E.areIntersecting(b.modifiedRange, C)))
      }));
      return A.length === 0 || A.every((_) => _.rangeMappings.length === 0) ? lx : A;
    }), this._register(hae(e, this.elements.root)), this._register(U(this.elements.root, "click", () => {
      this._editors.modified.focus();
    })), this._register(fd(this.elements.root, { display: this._hasActions.map((d) => d ? "block" : "none") })), Zr(this, (d) => this._showSash.read(d) ? new q8(e, this._sashLayout.dimensions, this._options.enableSplitViewResizing, this._boundarySashes, VN(this, (u) => this._sashLayout.sashLeft.read(u) - Yb, (u, g) => this._sashLayout.sashLeft.set(u + Yb, g)), () => this._sashLayout.resetSash()) : void 0).recomputeInitiallyAndOnChange(this._store), this._register(new Uae(this._editors.modified, this.elements.root, {
      getIntersectingGutterItems: (d, h) => {
        const u = this._diffModel.read(h);
        if (!u)
          return [];
        const g = u.diff.read(h);
        if (!g)
          return [];
        const m = this._selectedDiffs.read(h);
        if (m.length > 0) {
          const A = qs.fromRangeMappings(m.flatMap((_) => _.rangeMappings));
          return [
            new bP(A, !0, Qe.DiffEditorSelectionToolbar, void 0, u.model.original.uri, u.model.modified.uri)
          ];
        }
        const p = this._currentDiff.read(h);
        return g.mappings.map((A) => new bP(A.lineRangeMapping.withInnerChangesFromLineRanges(), A.lineRangeMapping === p?.lineRangeMapping, Qe.DiffEditorHunkToolbar, void 0, u.model.original.uri, u.model.modified.uri));
      },
      createView: (d, h) => this._instantiationService.createInstance(QD, d, h, this)
    })), this._register(U(this.elements.gutter, ee.MOUSE_WHEEL, (d) => {
      this._editors.modified.getOption(
        104
        /* EditorOption.scrollbar */
      ).handleMouseWheel && this._editors.modified.delegateScrollFromMouseWheelEvent(d);
    }, { passive: !1 }));
  }
  computeStagedValue(e) {
    const t = e.innerChanges ?? [], i = new _P(this._editors.modifiedModel.get()), n = new _P(this._editors.original.getModel());
    return new lG(t.map((a) => a.toTextEdit(i))).apply(n);
  }
  layout(e) {
    this.elements.gutter.style.left = e + "px";
  }
};
UD = Z8([
  Pw(6, ke),
  Pw(7, Se),
  Pw(8, sr)
], UD);
class bP {
  constructor(e, t, i, n, o, r) {
    this.mapping = e, this.showAlways = t, this.menuId = i, this.rangeOverride = n, this.originalUri = o, this.modifiedUri = r;
  }
  get id() {
    return this.mapping.modified.toString();
  }
  get range() {
    return this.rangeOverride ?? this.mapping.modified;
  }
}
let QD = class extends V {
  constructor(e, t, i, n) {
    super(), this._item = e, this._elements = it("div.gutterItem", { style: { height: "20px", width: "34px" } }, [
      it("div.background@background", {}, []),
      it("div.buttons@buttons", {}, [])
    ]), this._showAlways = this._item.map(this, (r) => r.showAlways), this._menuId = this._item.map(this, (r) => r.menuId), this._isSmall = ot(this, !1), this._lastItemRange = void 0, this._lastViewRange = void 0;
    const o = this._register(n.createInstance(Kf, "element", !0, { position: {
      hoverPosition: 1
      /* HoverPosition.RIGHT */
    } }));
    this._register(Cp(t, this._elements.root)), this._register(et((r) => {
      const a = this._showAlways.read(r);
      this._elements.root.classList.toggle("noTransition", !0), this._elements.root.classList.toggle("showAlways", a), setTimeout(() => {
        this._elements.root.classList.toggle("noTransition", !1);
      }, 0);
    })), this._register(Yo((r, a) => {
      this._elements.buttons.replaceChildren();
      const l = a.add(n.createInstance(Ov, this._elements.buttons, this._menuId.read(r), {
        orientation: 1,
        hoverDelegate: o,
        toolbarOptions: {
          primaryGroup: (c) => c.startsWith("primary")
        },
        overflowBehavior: { maxItems: this._isSmall.read(r) ? 1 : 3 },
        hiddenItemStrategy: 0,
        actionRunner: new $8(() => {
          const c = this._item.get(), d = c.mapping;
          return {
            mapping: d,
            originalWithModifiedChanges: i.computeStagedValue(d),
            originalUri: c.originalUri,
            modifiedUri: c.modifiedUri
          };
        }),
        menuOptions: {
          shouldForwardArgs: !0
        }
      }));
      a.add(l.onDidChangeMenuItems(() => {
        this._lastItemRange && this.layout(this._lastItemRange, this._lastViewRange);
      }));
    }));
  }
  layout(e, t) {
    this._lastItemRange = e, this._lastViewRange = t;
    let i = this._elements.buttons.clientHeight;
    this._isSmall.set(this._item.get().mapping.original.startLineNumber === 1 && e.length < 30, void 0), i = this._elements.buttons.clientHeight;
    const n = e.length / 2 - i / 2, o = i;
    let r = e.start + n;
    const a = Be.tryCreate(o, t.endExclusive - o - i), l = Be.tryCreate(e.start + o, e.endExclusive - i - o);
    l && a && l.start < l.endExclusive && (r = a.clip(r), r = l.clip(r)), this._elements.buttons.style.top = `${r - e.start}px`;
  }
};
QD = Z8([
  Pw(3, ke)
], QD);
function f_(s) {
  return GD.get(s);
}
const pc = class pc extends V {
  /**
   * Make sure that editor is not disposed yet!
  */
  static get(e) {
    let t = pc._map.get(e);
    if (!t) {
      t = new pc(e), pc._map.set(e, t);
      const i = e.onDidDispose(() => {
        const n = pc._map.get(e);
        n && (pc._map.delete(e), n.dispose(), i.dispose());
      });
    }
    return t;
  }
  _beginUpdate() {
    this._updateCounter++, this._updateCounter === 1 && (this._currentTransaction = new H_(() => {
    }));
  }
  _endUpdate() {
    if (this._updateCounter--, this._updateCounter === 0) {
      const e = this._currentTransaction;
      this._currentTransaction = void 0, e.finish();
    }
  }
  constructor(e) {
    super(), this.editor = e, this._updateCounter = 0, this._currentTransaction = void 0, this._model = ot(this, this.editor.getModel()), this.model = this._model, this.isReadonly = $t(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      92
      /* EditorOption.readOnly */
    )), this._versionId = qL({ owner: this, lazy: !0 }, this.editor.getModel()?.getVersionId() ?? null), this.versionId = this._versionId, this._selections = qL({ owner: this, equalsFn: aF(Yq(Ue.selectionsEqual)), lazy: !0 }, this.editor.getSelections() ?? null), this.selections = this._selections, this.isFocused = $t(this, (t) => {
      const i = this.editor.onDidFocusEditorWidget(t), n = this.editor.onDidBlurEditorWidget(t);
      return {
        dispose() {
          i.dispose(), n.dispose();
        }
      };
    }, () => this.editor.hasWidgetFocus()), this.value = VN(this, (t) => (this.versionId.read(t), this.model.read(t)?.getValue() ?? ""), (t, i) => {
      const n = this.model.get();
      n !== null && t !== n.getValue() && n.setValue(t);
    }), this.valueIsEmpty = De(this, (t) => (this.versionId.read(t), this.editor.getModel()?.getValueLength() === 0)), this.cursorSelection = iS({ owner: this, equalsFn: aF(Ue.selectionsEqual) }, (t) => this.selections.read(t)?.[0] ?? null), this.onDidType = zN(this), this.scrollTop = $t(this.editor.onDidScrollChange, () => this.editor.getScrollTop()), this.scrollLeft = $t(this.editor.onDidScrollChange, () => this.editor.getScrollLeft()), this.layoutInfo = $t(this.editor.onDidLayoutChange, () => this.editor.getLayoutInfo()), this.layoutInfoContentLeft = this.layoutInfo.map((t) => t.contentLeft), this.layoutInfoDecorationsLeft = this.layoutInfo.map((t) => t.decorationsLeft), this.contentWidth = $t(this.editor.onDidContentSizeChange, () => this.editor.getContentWidth()), this._overlayWidgetCounter = 0, this._register(this.editor.onBeginUpdate(() => this._beginUpdate())), this._register(this.editor.onEndUpdate(() => this._endUpdate())), this._register(this.editor.onDidChangeModel(() => {
      this._beginUpdate();
      try {
        this._model.set(this.editor.getModel(), this._currentTransaction), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidType((t) => {
      this._beginUpdate();
      try {
        this._forceUpdate(), this.onDidType.trigger(this._currentTransaction, t);
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeModelContent((t) => {
      this._beginUpdate();
      try {
        this._versionId.set(this.editor.getModel()?.getVersionId() ?? null, this._currentTransaction, t), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    })), this._register(this.editor.onDidChangeCursorSelection((t) => {
      this._beginUpdate();
      try {
        this._selections.set(this.editor.getSelections(), this._currentTransaction, t), this._forceUpdate();
      } finally {
        this._endUpdate();
      }
    }));
  }
  forceUpdate(e) {
    this._beginUpdate();
    try {
      return this._forceUpdate(), e ? e(this._currentTransaction) : void 0;
    } finally {
      this._endUpdate();
    }
  }
  _forceUpdate() {
    this._beginUpdate();
    try {
      this._model.set(this.editor.getModel(), this._currentTransaction), this._versionId.set(this.editor.getModel()?.getVersionId() ?? null, this._currentTransaction, void 0), this._selections.set(this.editor.getSelections(), this._currentTransaction, void 0);
    } finally {
      this._endUpdate();
    }
  }
  getOption(e) {
    return $t(this, (t) => this.editor.onDidChangeConfiguration((i) => {
      i.hasChanged(e) && t(void 0);
    }), () => this.editor.getOption(e));
  }
  setDecorations(e) {
    const t = new X(), i = this.editor.createDecorationsCollection();
    return t.add(nS({ owner: this, debugName: () => `Apply decorations from ${e.debugName}` }, (n) => {
      const o = e.read(n);
      i.set(o);
    })), t.add({
      dispose: () => {
        i.clear();
      }
    }), t;
  }
  createOverlayWidget(e) {
    const t = "observableOverlayWidget" + this._overlayWidgetCounter++, i = {
      getDomNode: () => e.domNode,
      getPosition: () => e.position.get(),
      getId: () => t,
      allowEditorOverflow: e.allowEditorOverflow,
      getMinContentWidthInPx: () => e.minContentWidthInPx.get()
    };
    this.editor.addOverlayWidget(i);
    const n = et((o) => {
      e.position.read(o), e.minContentWidthInPx.read(o), this.editor.layoutOverlayWidget(i);
    });
    return we(() => {
      n.dispose(), this.editor.removeOverlayWidget(i);
    });
  }
};
pc._map = /* @__PURE__ */ new Map();
let GD = pc;
var jae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Yae = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Hw, Uh;
let jD = (Uh = class extends V {
  static setBreadcrumbsSourceFactory(e) {
    this._breadcrumbsSourceFactory.set(e, void 0);
  }
  get isUpdatingHiddenAreas() {
    return this._isUpdatingHiddenAreas;
  }
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._instantiationService = n, this._modifiedOutlineSource = Zr(this, (l) => {
      const c = this._editors.modifiedModel.read(l), d = Hw._breadcrumbsSourceFactory.read(l);
      return !c || !d ? void 0 : d(c, this._instantiationService);
    }), this._isUpdatingHiddenAreas = !1, this._register(this._editors.original.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      xi((d) => {
        for (const h of this._editors.original.getSelections() || [])
          c?.ensureOriginalLineIsVisible(h.getStartPosition().lineNumber, 0, d), c?.ensureOriginalLineIsVisible(h.getEndPosition().lineNumber, 0, d);
      });
    })), this._register(this._editors.modified.onDidChangeCursorPosition((l) => {
      if (l.reason === 1)
        return;
      const c = this._diffModel.get();
      xi((d) => {
        for (const h of this._editors.modified.getSelections() || [])
          c?.ensureModifiedLineIsVisible(h.getStartPosition().lineNumber, 0, d), c?.ensureModifiedLineIsVisible(h.getEndPosition().lineNumber, 0, d);
      });
    }));
    const o = this._diffModel.map((l, c) => {
      const d = l?.unchangedRegions.read(c) ?? [];
      return d.length === 1 && d[0].modifiedLineNumber === 1 && d[0].lineCount === this._editors.modifiedModel.read(c)?.getLineCount() ? [] : d;
    });
    this.viewZones = Uu(this, (l, c) => {
      const d = this._modifiedOutlineSource.read(l);
      if (!d)
        return { origViewZones: [], modViewZones: [] };
      const h = [], u = [], g = this._options.renderSideBySide.read(l), m = this._options.compactMode.read(l), p = o.read(l);
      for (let A = 0; A < p.length; A++) {
        const _ = p[A];
        if (!_.shouldHideControls(l) && !(m && (A === 0 || A === p.length - 1)))
          if (m) {
            {
              const b = De(this, (w) => (
                /** @description hiddenOriginalRangeStart */
                _.getHiddenOriginalRange(w).startLineNumber - 1
              )), C = new jg(b, 12);
              h.push(C), c.add(new wP(this._editors.original, C, _, !g));
            }
            {
              const b = De(this, (w) => (
                /** @description hiddenModifiedRangeStart */
                _.getHiddenModifiedRange(w).startLineNumber - 1
              )), C = new jg(b, 12);
              u.push(C), c.add(new wP(this._editors.modified, C, _));
            }
          } else {
            {
              const b = De(this, (w) => (
                /** @description hiddenOriginalRangeStart */
                _.getHiddenOriginalRange(w).startLineNumber - 1
              )), C = new jg(b, 24);
              h.push(C), c.add(new CP(this._editors.original, C, _, _.originalUnchangedRange, !g, d, (w) => this._diffModel.get().ensureModifiedLineIsVisible(w, 2, void 0), this._options));
            }
            {
              const b = De(this, (w) => (
                /** @description hiddenModifiedRangeStart */
                _.getHiddenModifiedRange(w).startLineNumber - 1
              )), C = new jg(b, 24);
              u.push(C), c.add(new CP(this._editors.modified, C, _, _.modifiedUnchangedRange, !1, d, (w) => this._diffModel.get().ensureModifiedLineIsVisible(w, 2, void 0), this._options));
            }
          }
      }
      return { origViewZones: h, modViewZones: u };
    });
    const r = {
      description: "unchanged lines",
      className: "diff-unchanged-lines",
      isWholeLine: !0
    }, a = {
      description: "Fold Unchanged",
      glyphMarginHoverMessage: new Vo(void 0, { isTrusted: !0, supportThemeIcons: !0 }).appendMarkdown(f("foldUnchanged", "Fold Unchanged Region")),
      glyphMarginClassName: "fold-unchanged " + pe.asClassName(Z.fold),
      zIndex: 10001
    };
    this._register(Tv(this._editors.original, De(this, (l) => {
      const c = o.read(l), d = c.map((h) => ({
        range: h.originalUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const h of c)
        h.shouldHideControls(l) && d.push({
          range: E.fromPositions(new F(h.originalLineNumber, 1)),
          options: a
        });
      return d;
    }))), this._register(Tv(this._editors.modified, De(this, (l) => {
      const c = o.read(l), d = c.map((h) => ({
        range: h.modifiedUnchangedRange.toInclusiveRange(),
        options: r
      }));
      for (const h of c)
        h.shouldHideControls(l) && d.push({
          range: Ee.ofLength(h.modifiedLineNumber, 1).toInclusiveRange(),
          options: a
        });
      return d;
    }))), this._register(et((l) => {
      const c = o.read(l);
      this._isUpdatingHiddenAreas = !0;
      try {
        this._editors.original.setHiddenAreas(c.map((d) => d.getHiddenOriginalRange(l).toInclusiveRange()).filter(Pf)), this._editors.modified.setHiddenAreas(c.map((d) => d.getHiddenModifiedRange(l).toInclusiveRange()).filter(Pf));
      } finally {
        this._isUpdatingHiddenAreas = !1;
      }
    })), this._register(this._editors.modified.onMouseUp((l) => {
      if (!l.event.rightButton && l.target.position && l.target.element?.className.includes("fold-unchanged")) {
        const c = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const h = d.unchangedRegions.get().find((u) => u.modifiedUnchangedRange.includes(c));
        if (!h)
          return;
        h.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    })), this._register(this._editors.original.onMouseUp((l) => {
      if (!l.event.rightButton && l.target.position && l.target.element?.className.includes("fold-unchanged")) {
        const c = l.target.position.lineNumber, d = this._diffModel.get();
        if (!d)
          return;
        const h = d.unchangedRegions.get().find((u) => u.originalUnchangedRange.includes(c));
        if (!h)
          return;
        h.collapseAll(void 0), l.event.stopPropagation(), l.event.preventDefault();
      }
    }));
  }
}, Hw = Uh, Uh._breadcrumbsSourceFactory = ot(Hw, () => ({
  dispose() {
  },
  getBreadcrumbItems(e, t) {
    return [];
  }
})), Uh);
jD = Hw = jae([
  Yae(3, ke)
], jD);
class wP extends GT {
  constructor(e, t, i, n = !1) {
    const o = it("div.diff-hidden-lines-widget");
    super(e, t, o.root), this._unchangedRegion = i, this._hide = n, this._nodes = it("div.diff-hidden-lines-compact", [
      it("div.line-left", []),
      it("div.text@text", []),
      it("div.line-right", [])
    ]), o.root.appendChild(this._nodes.root), this._hide && this._nodes.root.replaceChildren(), this._register(et((r) => {
      if (!this._hide) {
        const a = this._unchangedRegion.getHiddenModifiedRange(r).length, l = f("hiddenLines", "{0} hidden lines", a);
        this._nodes.text.innerText = l;
      }
    }));
  }
}
class CP extends GT {
  constructor(e, t, i, n, o, r, a, l) {
    const c = it("div.diff-hidden-lines-widget");
    super(e, t, c.root), this._editor = e, this._unchangedRegion = i, this._unchangedRegionRange = n, this._hide = o, this._modifiedOutlineSource = r, this._revealModifiedHiddenLine = a, this._options = l, this._nodes = it("div.diff-hidden-lines", [
      it("div.top@top", { title: f("diff.hiddenLines.top", "Click or drag to show more above") }),
      it("div.center@content", { style: { display: "flex" } }, [
        it("div@first", { style: { display: "flex", justifyContent: "center", alignItems: "center", flexShrink: "0" } }, [de("a", { title: f("showUnchangedRegion", "Show Unchanged Region"), role: "button", onclick: () => {
          this._unchangedRegion.showAll(void 0);
        } }, ...kh("$(unfold)"))]),
        it("div@others", { style: { display: "flex", justifyContent: "center", alignItems: "center" } })
      ]),
      it("div.bottom@bottom", { title: f("diff.bottom", "Click or drag to show more below"), role: "button" })
    ]), c.root.appendChild(this._nodes.root), this._hide ? Rn(this._nodes.first) : this._register(fd(this._nodes.first, { width: f_(this._editor).layoutInfoContentLeft })), this._register(et((h) => {
      const u = this._unchangedRegion.visibleLineCountTop.read(h) + this._unchangedRegion.visibleLineCountBottom.read(h) === this._unchangedRegion.lineCount;
      this._nodes.bottom.classList.toggle("canMoveTop", !u), this._nodes.bottom.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(h) > 0), this._nodes.top.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(h) > 0), this._nodes.top.classList.toggle("canMoveBottom", !u);
      const g = this._unchangedRegion.isDragged.read(h), m = this._editor.getDomNode();
      m && (m.classList.toggle("draggingUnchangedRegion", !!g), g === "top" ? (m.classList.toggle("canMoveTop", this._unchangedRegion.visibleLineCountTop.read(h) > 0), m.classList.toggle("canMoveBottom", !u)) : g === "bottom" ? (m.classList.toggle("canMoveTop", !u), m.classList.toggle("canMoveBottom", this._unchangedRegion.visibleLineCountBottom.read(h) > 0)) : (m.classList.toggle("canMoveTop", !1), m.classList.toggle("canMoveBottom", !1)));
    }));
    const d = this._editor;
    this._register(U(this._nodes.top, "mousedown", (h) => {
      if (h.button !== 0)
        return;
      this._nodes.top.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), h.preventDefault();
      const u = h.clientY;
      let g = !1;
      const m = this._unchangedRegion.visibleLineCountTop.get();
      this._unchangedRegion.isDragged.set("top", void 0);
      const p = fe(this._nodes.top), A = U(p, "mousemove", (b) => {
        const w = b.clientY - u;
        g = g || Math.abs(w) > 2;
        const S = Math.round(w / d.getOption(
          67
          /* EditorOption.lineHeight */
        )), x = Math.max(0, Math.min(m + S, this._unchangedRegion.getMaxVisibleLineCountTop()));
        this._unchangedRegion.visibleLineCountTop.set(x, void 0);
      }), _ = U(p, "mouseup", (b) => {
        g || this._unchangedRegion.showMoreAbove(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0), this._nodes.top.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), this._unchangedRegion.isDragged.set(void 0, void 0), A.dispose(), _.dispose();
      });
    })), this._register(U(this._nodes.bottom, "mousedown", (h) => {
      if (h.button !== 0)
        return;
      this._nodes.bottom.classList.toggle("dragging", !0), this._nodes.root.classList.toggle("dragging", !0), h.preventDefault();
      const u = h.clientY;
      let g = !1;
      const m = this._unchangedRegion.visibleLineCountBottom.get();
      this._unchangedRegion.isDragged.set("bottom", void 0);
      const p = fe(this._nodes.bottom), A = U(p, "mousemove", (b) => {
        const w = b.clientY - u;
        g = g || Math.abs(w) > 2;
        const S = Math.round(w / d.getOption(
          67
          /* EditorOption.lineHeight */
        )), x = Math.max(0, Math.min(m - S, this._unchangedRegion.getMaxVisibleLineCountBottom())), y = this._unchangedRegionRange.endLineNumberExclusive > d.getModel().getLineCount() ? d.getContentHeight() : d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        this._unchangedRegion.visibleLineCountBottom.set(x, void 0);
        const D = this._unchangedRegionRange.endLineNumberExclusive > d.getModel().getLineCount() ? d.getContentHeight() : d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
        d.setScrollTop(d.getScrollTop() + (D - y));
      }), _ = U(p, "mouseup", (b) => {
        if (this._unchangedRegion.isDragged.set(void 0, void 0), !g) {
          const C = d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          this._unchangedRegion.showMoreBelow(this._options.hideUnchangedRegionsRevealLineCount.get(), void 0);
          const w = d.getTopForLineNumber(this._unchangedRegionRange.endLineNumberExclusive);
          d.setScrollTop(d.getScrollTop() + (w - C));
        }
        this._nodes.bottom.classList.toggle("dragging", !1), this._nodes.root.classList.toggle("dragging", !1), A.dispose(), _.dispose();
      });
    })), this._register(et((h) => {
      const u = [];
      if (!this._hide) {
        const g = i.getHiddenModifiedRange(h).length, m = f("hiddenLines", "{0} hidden lines", g), p = de("span", { title: f("diff.hiddenLines.expandAll", "Double click to unfold") }, m);
        p.addEventListener("dblclick", (b) => {
          b.button === 0 && (b.preventDefault(), this._unchangedRegion.showAll(void 0));
        }), u.push(p);
        const A = this._unchangedRegion.getHiddenModifiedRange(h), _ = this._modifiedOutlineSource.getBreadcrumbItems(A, h);
        if (_.length > 0) {
          u.push(de("span", void 0, "  |  "));
          for (let b = 0; b < _.length; b++) {
            const C = _[b], w = Fx.toIcon(C.kind), S = it("div.breadcrumb-item", {
              style: { display: "flex", alignItems: "center" }
            }, [
              LC(w),
              " ",
              C.name,
              ...b === _.length - 1 ? [] : [LC(Z.chevronRight)]
            ]).root;
            u.push(S), S.onclick = () => {
              this._revealModifiedHiddenLine(C.startLineNumber);
            };
          }
        }
      }
      Rn(this._nodes.others, ...u);
    }));
  }
}
var Kae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Jae = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, mr, kl;
let m_ = (kl = class extends V {
  constructor(e, t, i, n, o, r, a) {
    super(), this._editors = e, this._rootElement = t, this._diffModel = i, this._rootWidth = n, this._rootHeight = o, this._modifiedEditorLayoutInfo = r, this._themeService = a, this.width = mr.ENTIRE_DIFF_OVERVIEW_WIDTH;
    const l = $t(this._themeService.onDidColorThemeChange, () => this._themeService.getColorTheme()), c = De((u) => {
      const g = l.read(u), m = g.getColor(tY) || (g.getColor(Zj) || CL).transparent(2), p = g.getColor(iY) || (g.getColor(eY) || vL).transparent(2);
      return { insertColor: m, removeColor: p };
    }), d = rt(document.createElement("div"));
    d.setClassName("diffViewport"), d.setPosition("absolute");
    const h = it("div.diffOverview", {
      style: { position: "absolute", top: "0px", width: mr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px" }
    }).root;
    this._register(Cp(h, d.domNode)), this._register(Xt(h, ee.POINTER_DOWN, (u) => {
      this._editors.modified.delegateVerticalScrollbarPointerDown(u);
    })), this._register(U(h, ee.MOUSE_WHEEL, (u) => {
      this._editors.modified.delegateScrollFromMouseWheelEvent(u);
    }, { passive: !1 })), this._register(Cp(this._rootElement, h)), this._register(Yo((u, g) => {
      const m = this._diffModel.read(u), p = this._editors.original.createOverviewRuler("original diffOverviewRuler");
      p && (g.add(p), g.add(Cp(h, p.getDomNode())));
      const A = this._editors.modified.createOverviewRuler("modified diffOverviewRuler");
      if (A && (g.add(A), g.add(Cp(h, A.getDomNode()))), !p || !A)
        return;
      const _ = fo("viewZoneChanged", this._editors.original.onDidChangeViewZones), b = fo("viewZoneChanged", this._editors.modified.onDidChangeViewZones), C = fo("hiddenRangesChanged", this._editors.original.onDidChangeHiddenAreas), w = fo("hiddenRangesChanged", this._editors.modified.onDidChangeHiddenAreas);
      g.add(et((S) => {
        _.read(S), b.read(S), C.read(S), w.read(S);
        const x = c.read(S), y = m?.diff.read(S)?.mappings;
        function D(P, W, j) {
          const H = j._getViewModel();
          return H ? P.filter((J) => J.length > 0).map((J) => {
            const se = H.coordinatesConverter.convertModelPositionToViewPosition(new F(J.startLineNumber, 1)), ce = H.coordinatesConverter.convertModelPositionToViewPosition(new F(J.endLineNumberExclusive, 1)), he = ce.lineNumber - se.lineNumber;
            return new H8(se.lineNumber, ce.lineNumber, he, W.toString());
          }) : [];
        }
        const I = D((y || []).map((P) => P.lineRangeMapping.original), x.removeColor, this._editors.original), Q = D((y || []).map((P) => P.lineRangeMapping.modified), x.insertColor, this._editors.modified);
        p?.setZones(I), A?.setZones(Q);
      })), g.add(et((S) => {
        const x = this._rootHeight.read(S), y = this._rootWidth.read(S), D = this._modifiedEditorLayoutInfo.read(S);
        if (D) {
          const I = mr.ENTIRE_DIFF_OVERVIEW_WIDTH - 2 * mr.ONE_OVERVIEW_WIDTH;
          p.setLayout({
            top: 0,
            height: x,
            right: I + mr.ONE_OVERVIEW_WIDTH,
            width: mr.ONE_OVERVIEW_WIDTH
          }), A.setLayout({
            top: 0,
            height: x,
            right: 0,
            width: mr.ONE_OVERVIEW_WIDTH
          });
          const Q = this._editors.modifiedScrollTop.read(S), P = this._editors.modifiedScrollHeight.read(S), W = this._editors.modified.getOption(
            104
            /* EditorOption.scrollbar */
          ), j = new qf(W.verticalHasArrows ? W.arrowSize : 0, W.verticalScrollbarSize, 0, D.height, P, Q);
          d.setTop(j.getSliderPosition()), d.setHeight(j.getSliderSize());
        } else
          d.setTop(0), d.setHeight(0);
        h.style.height = x + "px", h.style.left = y - mr.ENTIRE_DIFF_OVERVIEW_WIDTH + "px", d.setWidth(mr.ENTIRE_DIFF_OVERVIEW_WIDTH);
      }));
    }));
  }
}, mr = kl, kl.ONE_OVERVIEW_WIDTH = 15, kl.ENTIRE_DIFF_OVERVIEW_WIDTH = kl.ONE_OVERVIEW_WIDTH * 2, kl);
m_ = mr = Kae([
  Jae(6, nn)
], m_);
const cx = [];
class qae extends V {
  constructor(e, t, i, n) {
    super(), this._editors = e, this._diffModel = t, this._options = i, this._widget = n, this._selectedDiffs = De(this, (o) => {
      const a = this._diffModel.read(o)?.diff.read(o);
      if (!a)
        return cx;
      const l = this._editors.modifiedSelections.read(o);
      if (l.every((u) => u.isEmpty()))
        return cx;
      const c = new go(l.map((u) => Ee.fromRangeInclusive(u))), h = a.mappings.filter((u) => u.lineRangeMapping.innerChanges && c.intersects(u.lineRangeMapping.modified)).map((u) => ({
        mapping: u,
        rangeMappings: u.lineRangeMapping.innerChanges.filter((g) => l.some((m) => E.areIntersecting(g.modifiedRange, m)))
      }));
      return h.length === 0 || h.every((u) => u.rangeMappings.length === 0) ? cx : h;
    }), this._register(Yo((o, r) => {
      if (!this._options.shouldRenderOldRevertArrows.read(o))
        return;
      const a = this._diffModel.read(o), l = a?.diff.read(o);
      if (!a || !l || a.movedTextToCompare.read(o))
        return;
      const c = [], d = this._selectedDiffs.read(o), h = new Set(d.map((u) => u.mapping));
      if (d.length > 0) {
        const u = this._editors.modifiedSelections.read(o), g = r.add(new Pv(u[u.length - 1].positionLineNumber, this._widget, d.flatMap((m) => m.rangeMappings), !0));
        this._editors.modified.addGlyphMarginWidget(g), c.push(g);
      }
      for (const u of l.mappings)
        if (!h.has(u) && !u.lineRangeMapping.modified.isEmpty && u.lineRangeMapping.innerChanges) {
          const g = r.add(new Pv(u.lineRangeMapping.modified.startLineNumber, this._widget, u.lineRangeMapping, !1));
          this._editors.modified.addGlyphMarginWidget(g), c.push(g);
        }
      r.add(we(() => {
        for (const u of c)
          this._editors.modified.removeGlyphMarginWidget(u);
      }));
    }));
  }
}
const i0 = class i0 extends V {
  getId() {
    return this._id;
  }
  constructor(e, t, i, n) {
    super(), this._lineNumber = e, this._widget = t, this._diffs = i, this._revertSelection = n, this._id = `revertButton${i0.counter++}`, this._domNode = it("div.revertButton", {
      title: this._revertSelection ? f("revertSelectedChanges", "Revert Selected Changes") : f("revertChange", "Revert Change")
    }, [LC(Z.arrowRight)]).root, this._register(U(this._domNode, ee.MOUSE_DOWN, (o) => {
      o.button !== 2 && (o.stopPropagation(), o.preventDefault());
    })), this._register(U(this._domNode, ee.MOUSE_UP, (o) => {
      o.stopPropagation(), o.preventDefault();
    })), this._register(U(this._domNode, ee.CLICK, (o) => {
      this._diffs instanceof Cn ? this._widget.revert(this._diffs) : this._widget.revertRangeMappings(this._diffs), o.stopPropagation(), o.preventDefault();
    }));
  }
  /**
   * Get the dom node of the glyph widget.
   */
  getDomNode() {
    return this._domNode;
  }
  /**
   * Get the placement of the glyph widget.
   */
  getPosition() {
    return {
      lane: qo.Right,
      range: {
        startColumn: 1,
        startLineNumber: this._lineNumber,
        endColumn: 1,
        endLineNumber: this._lineNumber
      },
      zIndex: 10001
    };
  }
};
i0.counter = 0;
let Pv = i0;
function Ka(s, e, t) {
  const i = s.bindTo(e);
  return nS({ debugName: () => `Set Context Key "${s.key}"` }, (n) => {
    i.set(t(n));
  });
}
var $ae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, vP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let YD = class extends V {
  get onDidContentSizeChange() {
    return this._onDidContentSizeChange.event;
  }
  constructor(e, t, i, n, o, r, a) {
    super(), this.originalEditorElement = e, this.modifiedEditorElement = t, this._options = i, this._argCodeEditorWidgetOptions = n, this._createInnerEditor = o, this._instantiationService = r, this._keybindingService = a, this.original = this._register(this._createLeftHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.originalEditor || {})), this.modified = this._register(this._createRightHandSideEditor(this._options.editorOptions.get(), this._argCodeEditorWidgetOptions.modifiedEditor || {})), this._onDidContentSizeChange = this._register(new B()), this.modifiedScrollTop = $t(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollTop */
      this.modified.getScrollTop()
    )), this.modifiedScrollHeight = $t(this, this.modified.onDidScrollChange, () => (
      /** @description modified.getScrollHeight */
      this.modified.getScrollHeight()
    )), this.modifiedObs = f_(this.modified), this.originalObs = f_(this.original), this.modifiedModel = this.modifiedObs.model, this.modifiedSelections = $t(this, this.modified.onDidChangeCursorSelection, () => this.modified.getSelections() ?? []), this.modifiedCursor = iS({ owner: this, equalsFn: F.equals }, (l) => this.modifiedSelections.read(l)[0]?.getPosition() ?? new F(1, 1)), this.originalCursor = $t(this, this.original.onDidChangeCursorPosition, () => this.original.getPosition() ?? new F(1, 1)), this._argCodeEditorWidgetOptions = null, this._register(sS({
      createEmptyChangeSummary: () => ({}),
      handleChange: (l, c) => (l.didChange(i.editorOptions) && Object.assign(c, l.change.changedOptions), !0)
    }, (l, c) => {
      i.editorOptions.read(l), this._options.renderSideBySide.read(l), this.modified.updateOptions(this._adjustOptionsForRightHandSide(l, c)), this.original.updateOptions(this._adjustOptionsForLeftHandSide(l, c));
    }));
  }
  _createLeftHandSideEditor(e, t) {
    const i = this._adjustOptionsForLeftHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.originalEditorElement, i, t);
    return n.setContextValue("isInDiffLeftEditor", !0), n;
  }
  _createRightHandSideEditor(e, t) {
    const i = this._adjustOptionsForRightHandSide(void 0, e), n = this._constructInnerEditor(this._instantiationService, this.modifiedEditorElement, i, t);
    return n.setContextValue("isInDiffRightEditor", !0), n;
  }
  _constructInnerEditor(e, t, i, n) {
    const o = this._createInnerEditor(e, t, i, n);
    return this._register(o.onDidContentSizeChange((r) => {
      const a = this.original.getContentWidth() + this.modified.getContentWidth() + m_.ENTIRE_DIFF_OVERVIEW_WIDTH, l = Math.max(this.modified.getContentHeight(), this.original.getContentHeight());
      this._onDidContentSizeChange.fire({
        contentHeight: l,
        contentWidth: a,
        contentHeightChanged: r.contentHeightChanged,
        contentWidthChanged: r.contentWidthChanged
      });
    })), o;
  }
  _adjustOptionsForLeftHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return this._options.renderSideBySide.get() ? (i.unicodeHighlight = this._options.editorOptions.get().unicodeHighlight || {}, i.wordWrapOverride1 = this._options.diffWordWrap.get()) : (i.wordWrapOverride1 = "off", i.wordWrapOverride2 = "off", i.stickyScroll = { enabled: !1 }, i.unicodeHighlight = { nonBasicASCII: !1, ambiguousCharacters: !1, invisibleCharacters: !1 }), i.glyphMargin = this._options.renderSideBySide.get(), t.originalAriaLabel && (i.ariaLabel = t.originalAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.readOnly = !this._options.originalEditable.get(), i.dropIntoEditor = { enabled: !i.readOnly }, i.extraEditorClassName = "original-in-monaco-diff-editor", i;
  }
  _adjustOptionsForRightHandSide(e, t) {
    const i = this._adjustOptionsForSubEditor(t);
    return t.modifiedAriaLabel && (i.ariaLabel = t.modifiedAriaLabel), i.ariaLabel = this._updateAriaLabel(i.ariaLabel), i.wordWrapOverride1 = this._options.diffWordWrap.get(), i.revealHorizontalRightPadding = Hr.revealHorizontalRightPadding.defaultValue + m_.ENTIRE_DIFF_OVERVIEW_WIDTH, i.scrollbar.verticalHasArrows = !1, i.extraEditorClassName = "modified-in-monaco-diff-editor", i;
  }
  _adjustOptionsForSubEditor(e) {
    const t = {
      ...e,
      dimension: {
        height: 0,
        width: 0
      }
    };
    return t.inDiffEditor = !0, t.automaticLayout = !1, t.scrollbar = { ...t.scrollbar || {} }, t.folding = !1, t.codeLens = this._options.diffCodeLens.get(), t.fixedOverflowWidgets = !0, t.minimap = { ...t.minimap || {} }, t.minimap.enabled = !1, this._options.hideUnchangedRegions.get() ? t.stickyScroll = { enabled: !1 } : t.stickyScroll = this._options.editorOptions.get().stickyScroll, t;
  }
  _updateAriaLabel(e) {
    e || (e = "");
    const t = f("diff-aria-navigation-tip", " use {0} to open the accessibility help.", this._keybindingService.lookupKeybinding("editor.action.accessibilityHelp")?.getAriaLabel());
    return this._options.accessibilityVerbose.get() ? e + t : e ? e.replaceAll(t, "") : "";
  }
};
YD = $ae([
  vP(5, ke),
  vP(6, bt)
], YD);
const n0 = class n0 extends V {
  constructor() {
    super(...arguments), this._id = ++n0.idCounter, this._onDidDispose = this._register(new B()), this.onDidDispose = this._onDidDispose.event;
  }
  getId() {
    return this.getEditorType() + ":v2:" + this._id;
  }
  // #region editorBrowser.IDiffEditor: Delegating to modified Editor
  getVisibleColumnFromPosition(e) {
    return this._targetEditor.getVisibleColumnFromPosition(e);
  }
  getPosition() {
    return this._targetEditor.getPosition();
  }
  setPosition(e, t = "api") {
    this._targetEditor.setPosition(e, t);
  }
  revealLine(e, t = 0) {
    this._targetEditor.revealLine(e, t);
  }
  revealLineInCenter(e, t = 0) {
    this._targetEditor.revealLineInCenter(e, t);
  }
  revealLineInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealLineInCenterIfOutsideViewport(e, t);
  }
  revealLineNearTop(e, t = 0) {
    this._targetEditor.revealLineNearTop(e, t);
  }
  revealPosition(e, t = 0) {
    this._targetEditor.revealPosition(e, t);
  }
  revealPositionInCenter(e, t = 0) {
    this._targetEditor.revealPositionInCenter(e, t);
  }
  revealPositionInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealPositionInCenterIfOutsideViewport(e, t);
  }
  revealPositionNearTop(e, t = 0) {
    this._targetEditor.revealPositionNearTop(e, t);
  }
  getSelection() {
    return this._targetEditor.getSelection();
  }
  getSelections() {
    return this._targetEditor.getSelections();
  }
  setSelection(e, t = "api") {
    this._targetEditor.setSelection(e, t);
  }
  setSelections(e, t = "api") {
    this._targetEditor.setSelections(e, t);
  }
  revealLines(e, t, i = 0) {
    this._targetEditor.revealLines(e, t, i);
  }
  revealLinesInCenter(e, t, i = 0) {
    this._targetEditor.revealLinesInCenter(e, t, i);
  }
  revealLinesInCenterIfOutsideViewport(e, t, i = 0) {
    this._targetEditor.revealLinesInCenterIfOutsideViewport(e, t, i);
  }
  revealLinesNearTop(e, t, i = 0) {
    this._targetEditor.revealLinesNearTop(e, t, i);
  }
  revealRange(e, t = 0, i = !1, n = !0) {
    this._targetEditor.revealRange(e, t, i, n);
  }
  revealRangeInCenter(e, t = 0) {
    this._targetEditor.revealRangeInCenter(e, t);
  }
  revealRangeInCenterIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeInCenterIfOutsideViewport(e, t);
  }
  revealRangeNearTop(e, t = 0) {
    this._targetEditor.revealRangeNearTop(e, t);
  }
  revealRangeNearTopIfOutsideViewport(e, t = 0) {
    this._targetEditor.revealRangeNearTopIfOutsideViewport(e, t);
  }
  revealRangeAtTop(e, t = 0) {
    this._targetEditor.revealRangeAtTop(e, t);
  }
  getSupportedActions() {
    return this._targetEditor.getSupportedActions();
  }
  focus() {
    this._targetEditor.focus();
  }
  trigger(e, t, i) {
    this._targetEditor.trigger(e, t, i);
  }
  createDecorationsCollection(e) {
    return this._targetEditor.createDecorationsCollection(e);
  }
  changeDecorations(e) {
    return this._targetEditor.changeDecorations(e);
  }
};
n0.idCounter = 0;
let KD = n0;
var Xae = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Zae = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let JD = class {
  get editorOptions() {
    return this._options;
  }
  constructor(e, t) {
    this._accessibilityService = t, this._diffEditorWidth = ot(this, 0), this._screenReaderMode = $t(this, this._accessibilityService.onDidChangeScreenReaderOptimized, () => this._accessibilityService.isScreenReaderOptimized()), this.couldShowInlineViewBecauseOfSize = De(this, (n) => this._options.read(n).renderSideBySide && this._diffEditorWidth.read(n) <= this._options.read(n).renderSideBySideInlineBreakpoint), this.renderOverviewRuler = De(this, (n) => this._options.read(n).renderOverviewRuler), this.renderSideBySide = De(this, (n) => this.compactMode.read(n) && this.shouldRenderInlineViewInSmartMode.read(n) ? !1 : this._options.read(n).renderSideBySide && !(this._options.read(n).useInlineViewWhenSpaceIsLimited && this.couldShowInlineViewBecauseOfSize.read(n) && !this._screenReaderMode.read(n))), this.readOnly = De(this, (n) => this._options.read(n).readOnly), this.shouldRenderOldRevertArrows = De(this, (n) => !(!this._options.read(n).renderMarginRevertIcon || !this.renderSideBySide.read(n) || this.readOnly.read(n) || this.shouldRenderGutterMenu.read(n))), this.shouldRenderGutterMenu = De(this, (n) => this._options.read(n).renderGutterMenu), this.renderIndicators = De(this, (n) => this._options.read(n).renderIndicators), this.enableSplitViewResizing = De(this, (n) => this._options.read(n).enableSplitViewResizing), this.splitViewDefaultRatio = De(this, (n) => this._options.read(n).splitViewDefaultRatio), this.ignoreTrimWhitespace = De(this, (n) => this._options.read(n).ignoreTrimWhitespace), this.maxComputationTimeMs = De(this, (n) => this._options.read(n).maxComputationTime), this.showMoves = De(this, (n) => this._options.read(n).experimental.showMoves && this.renderSideBySide.read(n)), this.isInEmbeddedEditor = De(this, (n) => this._options.read(n).isInEmbeddedEditor), this.diffWordWrap = De(this, (n) => this._options.read(n).diffWordWrap), this.originalEditable = De(this, (n) => this._options.read(n).originalEditable), this.diffCodeLens = De(this, (n) => this._options.read(n).diffCodeLens), this.accessibilityVerbose = De(this, (n) => this._options.read(n).accessibilityVerbose), this.diffAlgorithm = De(this, (n) => this._options.read(n).diffAlgorithm), this.showEmptyDecorations = De(this, (n) => this._options.read(n).experimental.showEmptyDecorations), this.onlyShowAccessibleDiffViewer = De(this, (n) => this._options.read(n).onlyShowAccessibleDiffViewer), this.compactMode = De(this, (n) => this._options.read(n).compactMode), this.trueInlineDiffRenderingEnabled = De(this, (n) => this._options.read(n).experimental.useTrueInlineView), this.useTrueInlineDiffRendering = De(this, (n) => !this.renderSideBySide.read(n) && this.trueInlineDiffRenderingEnabled.read(n)), this.hideUnchangedRegions = De(this, (n) => this._options.read(n).hideUnchangedRegions.enabled), this.hideUnchangedRegionsRevealLineCount = De(this, (n) => this._options.read(n).hideUnchangedRegions.revealLineCount), this.hideUnchangedRegionsContextLineCount = De(this, (n) => this._options.read(n).hideUnchangedRegions.contextLineCount), this.hideUnchangedRegionsMinimumLineCount = De(this, (n) => this._options.read(n).hideUnchangedRegions.minimumLineCount), this._model = ot(this, void 0), this.shouldRenderInlineViewInSmartMode = this._model.map(this, (n) => l$(this, (o) => {
      const r = n?.diff.read(o);
      return r ? ele(r, this.trueInlineDiffRenderingEnabled.read(o)) : void 0;
    })).flatten().map(this, (n) => !!n), this.inlineViewHideOriginalLineNumbers = this.compactMode;
    const i = { ...e, ...SP(e, Ki) };
    this._options = ot(this, i);
  }
  updateOptions(e) {
    const t = SP(e, this._options.get()), i = { ...this._options.get(), ...e, ...t };
    this._options.set(i, void 0, { changedOptions: e });
  }
  setWidth(e) {
    this._diffEditorWidth.set(e, void 0);
  }
  setModel(e) {
    this._model.set(e, void 0);
  }
};
JD = Xae([
  Zae(1, Lo)
], JD);
function ele(s, e) {
  return s.mappings.every((t) => tle(t.lineRangeMapping) || ile(t.lineRangeMapping) || e && $T(t.lineRangeMapping));
}
function tle(s) {
  return s.original.length === 0;
}
function ile(s) {
  return s.modified.length === 0;
}
function SP(s, e) {
  return {
    enableSplitViewResizing: ue(s.enableSplitViewResizing, e.enableSplitViewResizing),
    splitViewDefaultRatio: G9(s.splitViewDefaultRatio, 0.5, 0.1, 0.9),
    renderSideBySide: ue(s.renderSideBySide, e.renderSideBySide),
    renderMarginRevertIcon: ue(s.renderMarginRevertIcon, e.renderMarginRevertIcon),
    maxComputationTime: Vd(
      s.maxComputationTime,
      e.maxComputationTime,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    maxFileSize: Vd(
      s.maxFileSize,
      e.maxFileSize,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    ignoreTrimWhitespace: ue(s.ignoreTrimWhitespace, e.ignoreTrimWhitespace),
    renderIndicators: ue(s.renderIndicators, e.renderIndicators),
    originalEditable: ue(s.originalEditable, e.originalEditable),
    diffCodeLens: ue(s.diffCodeLens, e.diffCodeLens),
    renderOverviewRuler: ue(s.renderOverviewRuler, e.renderOverviewRuler),
    diffWordWrap: Gt(s.diffWordWrap, e.diffWordWrap, ["off", "on", "inherit"]),
    diffAlgorithm: Gt(s.diffAlgorithm, e.diffAlgorithm, ["legacy", "advanced"], { smart: "legacy", experimental: "advanced" }),
    accessibilityVerbose: ue(s.accessibilityVerbose, e.accessibilityVerbose),
    experimental: {
      showMoves: ue(s.experimental?.showMoves, e.experimental.showMoves),
      showEmptyDecorations: ue(s.experimental?.showEmptyDecorations, e.experimental.showEmptyDecorations),
      useTrueInlineView: ue(s.experimental?.useTrueInlineView, e.experimental.useTrueInlineView)
    },
    hideUnchangedRegions: {
      enabled: ue(s.hideUnchangedRegions?.enabled ?? s.experimental?.collapseUnchangedRegions, e.hideUnchangedRegions.enabled),
      contextLineCount: Vd(
        s.hideUnchangedRegions?.contextLineCount,
        e.hideUnchangedRegions.contextLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      minimumLineCount: Vd(
        s.hideUnchangedRegions?.minimumLineCount,
        e.hideUnchangedRegions.minimumLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      ),
      revealLineCount: Vd(
        s.hideUnchangedRegions?.revealLineCount,
        e.hideUnchangedRegions.revealLineCount,
        0,
        1073741824
        /* Constants.MAX_SAFE_SMALL_INTEGER */
      )
    },
    isInEmbeddedEditor: ue(s.isInEmbeddedEditor, e.isInEmbeddedEditor),
    onlyShowAccessibleDiffViewer: ue(s.onlyShowAccessibleDiffViewer, e.onlyShowAccessibleDiffViewer),
    renderSideBySideInlineBreakpoint: Vd(
      s.renderSideBySideInlineBreakpoint,
      e.renderSideBySideInlineBreakpoint,
      0,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ),
    useInlineViewWhenSpaceIsLimited: ue(s.useInlineViewWhenSpaceIsLimited, e.useInlineViewWhenSpaceIsLimited),
    renderGutterMenu: ue(s.renderGutterMenu, e.renderGutterMenu),
    compactMode: ue(s.compactMode, e.compactMode)
  };
}
var nle = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ap = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Hv = class extends KD {
  get onDidContentSizeChange() {
    return this._editors.onDidContentSizeChange;
  }
  constructor(e, t, i, n, o, r, a, l) {
    super(), this._domElement = e, this._parentContextKeyService = n, this._parentInstantiationService = o, this._accessibilitySignalService = a, this._editorProgressService = l, this.elements = it("div.monaco-diff-editor.side-by-side", { style: { position: "relative", height: "100%" } }, [
      it("div.editor.original@original", { style: { position: "absolute", height: "100%" } }),
      it("div.editor.modified@modified", { style: { position: "absolute", height: "100%" } }),
      it("div.accessibleDiffViewer@accessibleDiffViewer", { style: { position: "absolute", height: "100%" } })
    ]), this._diffModelSrc = this._register(R3(this, void 0)), this._diffModel = De(this, (w) => this._diffModelSrc.read(w)?.object), this.onDidChangeModel = te.fromObservableLight(this._diffModel), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._domElement)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Lm([Se, this._contextKeyService]))), this._boundarySashes = ot(this, void 0), this._accessibleDiffViewerShouldBeVisible = ot(this, !1), this._accessibleDiffViewerVisible = De(this, (w) => this._options.onlyShowAccessibleDiffViewer.read(w) ? !0 : this._accessibleDiffViewerShouldBeVisible.read(w)), this._movedBlocksLinesPart = ot(this, void 0), this._layoutInfo = De(this, (w) => {
      const S = this._rootSizeObserver.width.read(w), x = this._rootSizeObserver.height.read(w);
      this._rootSizeObserver.automaticLayout ? this.elements.root.style.height = "100%" : this.elements.root.style.height = x + "px";
      const y = this._sash.read(w), D = this._gutter.read(w), I = D?.width.read(w) ?? 0, Q = this._overviewRulerPart.read(w)?.width ?? 0;
      let P, W, j, H, J;
      if (!!y) {
        const ce = y.sashLeft.read(w), he = this._movedBlocksLinesPart.read(w)?.width.read(w) ?? 0;
        P = 0, W = ce - I - he, J = ce - I, j = ce, H = S - j - Q;
      } else {
        J = 0;
        const ce = this._options.inlineViewHideOriginalLineNumbers.read(w);
        P = I, ce ? W = 0 : W = Math.max(5, this._editors.originalObs.layoutInfoDecorationsLeft.read(w)), j = I + W, H = S - j - Q;
      }
      return this.elements.original.style.left = P + "px", this.elements.original.style.width = W + "px", this._editors.original.layout({ width: W, height: x }, !0), D?.layout(J), this.elements.modified.style.left = j + "px", this.elements.modified.style.width = H + "px", this._editors.modified.layout({ width: H, height: x }, !0), {
        modifiedEditor: this._editors.modified.getLayoutInfo(),
        originalEditor: this._editors.original.getLayoutInfo()
      };
    }), this._diffValue = this._diffModel.map((w, S) => w?.diff.read(S)), this.onDidUpdateDiff = te.fromObservableLight(this._diffValue), r.willCreateDiffEditor(), this._contextKeyService.createKey("isInDiffEditor", !0), this._domElement.appendChild(this.elements.root), this._register(we(() => this.elements.root.remove())), this._rootSizeObserver = this._register(new Q8(this.elements.root, t.dimension)), this._rootSizeObserver.setAutomaticLayout(t.automaticLayout ?? !1), this._options = this._instantiationService.createInstance(JD, t), this._register(et((w) => {
      this._options.setWidth(this._rootSizeObserver.width.read(w));
    })), this._contextKeyService.createKey(R.isEmbeddedDiffEditor.key, !1), this._register(Ka(R.isEmbeddedDiffEditor, this._contextKeyService, (w) => this._options.isInEmbeddedEditor.read(w))), this._register(Ka(R.comparingMovedCode, this._contextKeyService, (w) => !!this._diffModel.read(w)?.movedTextToCompare.read(w))), this._register(Ka(R.diffEditorRenderSideBySideInlineBreakpointReached, this._contextKeyService, (w) => this._options.couldShowInlineViewBecauseOfSize.read(w))), this._register(Ka(R.diffEditorInlineMode, this._contextKeyService, (w) => !this._options.renderSideBySide.read(w))), this._register(Ka(R.hasChanges, this._contextKeyService, (w) => (this._diffModel.read(w)?.diff.read(w)?.mappings.length ?? 0) > 0)), this._editors = this._register(this._instantiationService.createInstance(YD, this.elements.original, this.elements.modified, this._options, i, (w, S, x, y) => this._createInnerEditor(w, S, x, y))), this._register(Ka(R.diffEditorOriginalWritable, this._contextKeyService, (w) => this._options.originalEditable.read(w))), this._register(Ka(R.diffEditorModifiedWritable, this._contextKeyService, (w) => !this._options.readOnly.read(w))), this._register(Ka(R.diffEditorOriginalUri, this._contextKeyService, (w) => this._diffModel.read(w)?.model.original.uri.toString() ?? "")), this._register(Ka(R.diffEditorModifiedUri, this._contextKeyService, (w) => this._diffModel.read(w)?.model.modified.uri.toString() ?? "")), this._overviewRulerPart = Zr(this, (w) => this._options.renderOverviewRuler.read(w) ? this._instantiationService.createInstance(Po(m_, w), this._editors, this.elements.root, this._diffModel, this._rootSizeObserver.width, this._rootSizeObserver.height, this._layoutInfo.map((S) => S.modifiedEditor)) : void 0).recomputeInitiallyAndOnChange(this._store);
    const c = {
      height: this._rootSizeObserver.height,
      width: this._rootSizeObserver.width.map((w, S) => w - (this._overviewRulerPart.read(S)?.width ?? 0))
    };
    this._sashLayout = new zae(this._options, c), this._sash = Zr(this, (w) => {
      const S = this._options.renderSideBySide.read(w);
      return this.elements.root.classList.toggle("side-by-side", S), S ? new q8(this.elements.root, c, this._options.enableSplitViewResizing, this._boundarySashes, this._sashLayout.sashLeft, () => this._sashLayout.resetSash()) : void 0;
    }).recomputeInitiallyAndOnChange(this._store);
    const d = Zr(this, (w) => (
      /** @description UnchangedRangesFeature */
      this._instantiationService.createInstance(Po(jD, w), this._editors, this._diffModel, this._options)
    )).recomputeInitiallyAndOnChange(this._store);
    Zr(this, (w) => (
      /** @description DiffEditorDecorations */
      this._instantiationService.createInstance(Po(Vae, w), this._editors, this._diffModel, this._options, this)
    )).recomputeInitiallyAndOnChange(this._store);
    const h = /* @__PURE__ */ new Set(), u = /* @__PURE__ */ new Set();
    let g = !1;
    const m = Zr(this, (w) => (
      /** @description ViewZoneManager */
      this._instantiationService.createInstance(Po(zD, w), fe(this._domElement), this._editors, this._diffModel, this._options, this, () => g || d.get().isUpdatingHiddenAreas, h, u)
    )).recomputeInitiallyAndOnChange(this._store), p = De(this, (w) => {
      const S = m.read(w).viewZones.read(w).orig, x = d.read(w).viewZones.read(w).origViewZones;
      return S.concat(x);
    }), A = De(this, (w) => {
      const S = m.read(w).viewZones.read(w).mod, x = d.read(w).viewZones.read(w).modViewZones;
      return S.concat(x);
    });
    this._register(Bv(this._editors.original, p, (w) => {
      g = w;
    }, h));
    let _;
    this._register(Bv(this._editors.modified, A, (w) => {
      g = w, g ? _ = gd.capture(this._editors.modified) : (_?.restore(this._editors.modified), _ = void 0);
    }, u)), this._accessibleDiffViewer = Zr(this, (w) => this._instantiationService.createInstance(Po(yh, w), this.elements.accessibleDiffViewer, this._accessibleDiffViewerVisible, (S, x) => this._accessibleDiffViewerShouldBeVisible.set(S, x), this._options.onlyShowAccessibleDiffViewer.map((S) => !S), this._rootSizeObserver.width, this._rootSizeObserver.height, this._diffModel.map((S, x) => S?.diff.read(x)?.mappings.map((y) => y.lineRangeMapping)), new xae(this._editors))).recomputeInitiallyAndOnChange(this._store);
    const b = this._accessibleDiffViewerVisible.map((w) => w ? "hidden" : "visible");
    this._register(fd(this.elements.modified, { visibility: b })), this._register(fd(this.elements.original, { visibility: b })), this._createDiffEditorContributions(), r.addDiffEditor(this), this._gutter = Zr(this, (w) => this._options.shouldRenderGutterMenu.read(w) ? this._instantiationService.createInstance(Po(UD, w), this.elements.root, this._diffModel, this._editors, this._options, this._sashLayout, this._boundarySashes) : void 0), this._register(rS(this._layoutInfo)), Zr(this, (w) => (
      /** @description MovedBlocksLinesPart */
      new (Po(Tf, w))(this.elements.root, this._diffModel, this._layoutInfo.map((S) => S.originalEditor), this._layoutInfo.map((S) => S.modifiedEditor), this._editors)
    )).recomputeInitiallyAndOnChange(this._store, (w) => {
      this._movedBlocksLinesPart.set(w, void 0);
    }), this._register(te.runAndSubscribe(this._editors.modified.onDidChangeCursorPosition, (w) => this._handleCursorPositionChange(w, !0))), this._register(te.runAndSubscribe(this._editors.original.onDidChangeCursorPosition, (w) => this._handleCursorPositionChange(w, !1)));
    const C = this._diffModel.map(this, (w, S) => {
      if (w)
        return w.diff.read(S) === void 0 && !w.isDiffUpToDate.read(S);
    });
    this._register(Yo((w, S) => {
      if (C.read(w) === !0) {
        const x = this._editorProgressService.show(!0, 1e3);
        S.add(we(() => x.done()));
      }
    })), this._register(Yo((w, S) => {
      S.add(new (Po(qae, w))(this._editors, this._diffModel, this._options, this));
    })), this._register(Yo((w, S) => {
      const x = this._diffModel.read(w);
      if (x)
        for (const y of [x.model.original, x.model.modified])
          S.add(y.onWillDispose((D) => {
            Pe(new lt("TextModel got disposed before DiffEditorWidget model got reset")), this.setModel(null);
          }));
    })), this._register(et((w) => {
      this._options.setModel(this._diffModel.read(w));
    }));
  }
  _createInnerEditor(e, t, i, n) {
    return e.createInstance(u_, t, i, n);
  }
  _createDiffEditorContributions() {
    const e = pf.getDiffEditorContributions();
    for (const t of e)
      try {
        this._register(this._instantiationService.createInstance(t.ctor, this));
      } catch (i) {
        Pe(i);
      }
  }
  get _targetEditor() {
    return this._editors.modified;
  }
  getEditorType() {
    return wS.IDiffEditor;
  }
  layout(e) {
    this._rootSizeObserver.observe(e);
  }
  hasTextFocus() {
    return this._editors.original.hasTextFocus() || this._editors.modified.hasTextFocus();
  }
  saveViewState() {
    const e = this._editors.original.saveViewState(), t = this._editors.modified.saveViewState();
    return {
      original: e,
      modified: t,
      modelState: this._diffModel.get()?.serializeState()
    };
  }
  restoreViewState(e) {
    if (e && e.original && e.modified) {
      const t = e;
      this._editors.original.restoreViewState(t.original), this._editors.modified.restoreViewState(t.modified), t.modelState && this._diffModel.get()?.restoreSerializedState(t.modelState);
    }
  }
  handleInitialized() {
    this._editors.original.handleInitialized(), this._editors.modified.handleInitialized();
  }
  createViewModel(e) {
    return this._instantiationService.createInstance(VD, e, this._options);
  }
  getModel() {
    return this._diffModel.get()?.model ?? null;
  }
  setModel(e) {
    const t = e ? "model" in e ? Rv.create(e).createNewRef(this) : Rv.create(this.createViewModel(e), this) : null;
    this.setDiffModel(t);
  }
  setDiffModel(e, t) {
    const i = this._diffModel.get();
    !e && i && this._accessibleDiffViewer.get().close(), this._diffModel.get() !== e?.object && HN(t, (n) => {
      const o = e?.object;
      $t.batchEventsGlobally(n, () => {
        this._editors.original.setModel(o ? o.model.original : null), this._editors.modified.setModel(o ? o.model.modified : null);
      });
      const r = this._diffModelSrc.get()?.createNewRef(this);
      this._diffModelSrc.set(e?.createNewRef(this), n), setTimeout(() => {
        r?.dispose();
      }, 0);
    });
  }
  /**
   * @param changedOptions Only has values for top-level options that have actually changed.
   */
  updateOptions(e) {
    this._options.updateOptions(e);
  }
  getContainerDomNode() {
    return this._domElement;
  }
  getOriginalEditor() {
    return this._editors.original;
  }
  getModifiedEditor() {
    return this._editors.modified;
  }
  /**
   * @deprecated Use `this.getDiffComputationResult().changes2` instead.
   */
  getLineChanges() {
    const e = this._diffModel.get()?.diff.get();
    return e ? sle(e) : null;
  }
  revert(e) {
    const t = this._diffModel.get();
    !t || !t.isDiffUpToDate.get() || this._editors.modified.executeEdits("diffEditor", [
      {
        range: e.modified.toExclusiveRange(),
        text: t.model.original.getValueInRange(e.original.toExclusiveRange())
      }
    ]);
  }
  revertRangeMappings(e) {
    const t = this._diffModel.get();
    if (!t || !t.isDiffUpToDate.get())
      return;
    const i = e.map((n) => ({
      range: n.modifiedRange,
      text: t.model.original.getValueInRange(n.originalRange)
    }));
    this._editors.modified.executeEdits("diffEditor", i);
  }
  _goTo(e) {
    this._editors.modified.setPosition(new F(e.lineRangeMapping.modified.startLineNumber, 1)), this._editors.modified.revealRangeInCenter(e.lineRangeMapping.modified.toExclusiveRange());
  }
  goToDiff(e) {
    const t = this._diffModel.get()?.diff.get()?.mappings;
    if (!t || t.length === 0)
      return;
    const i = this._editors.modified.getPosition().lineNumber;
    let n;
    e === "next" ? n = t.find((o) => o.lineRangeMapping.modified.startLineNumber > i) ?? t[0] : n = gC(t, (o) => o.lineRangeMapping.modified.startLineNumber < i) ?? t[t.length - 1], this._goTo(n), n.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(ua.diffLineDeleted, { source: "diffEditor.goToDiff" }) : n.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(ua.diffLineInserted, { source: "diffEditor.goToDiff" }) : n && this._accessibilitySignalService.playSignal(ua.diffLineModified, { source: "diffEditor.goToDiff" });
  }
  revealFirstDiff() {
    const e = this._diffModel.get();
    e && this.waitForDiff().then(() => {
      const t = e.diff.get()?.mappings;
      !t || t.length === 0 || this._goTo(t[0]);
    });
  }
  accessibleDiffViewerNext() {
    this._accessibleDiffViewer.get().next();
  }
  accessibleDiffViewerPrev() {
    this._accessibleDiffViewer.get().prev();
  }
  async waitForDiff() {
    const e = this._diffModel.get();
    e && await e.waitForDiff();
  }
  mapToOtherSide() {
    const e = this._editors.modified.hasWidgetFocus(), t = e ? this._editors.modified : this._editors.original, i = e ? this._editors.original : this._editors.modified;
    let n;
    const o = t.getSelection();
    if (o) {
      const r = this._diffModel.get()?.diff.get()?.mappings.map((a) => e ? a.lineRangeMapping.flip() : a.lineRangeMapping);
      if (r) {
        const a = sP(o.getStartPosition(), r), l = sP(o.getEndPosition(), r);
        n = E.plusRange(a, l);
      }
    }
    return { destination: i, destinationSelection: n };
  }
  switchSide() {
    const { destination: e, destinationSelection: t } = this.mapToOtherSide();
    e.focus(), t && e.setSelection(t);
  }
  exitCompareMove() {
    const e = this._diffModel.get();
    e && e.movedTextToCompare.set(void 0, void 0);
  }
  collapseAllUnchangedRegions() {
    const e = this._diffModel.get()?.unchangedRegions.get();
    e && xi((t) => {
      for (const i of e)
        i.collapseAll(t);
    });
  }
  showAllUnchangedRegions() {
    const e = this._diffModel.get()?.unchangedRegions.get();
    e && xi((t) => {
      for (const i of e)
        i.showAll(t);
    });
  }
  _handleCursorPositionChange(e, t) {
    if (e?.reason === 3) {
      const i = this._diffModel.get()?.diff.get()?.mappings.find((n) => t ? n.lineRangeMapping.modified.contains(e.position.lineNumber) : n.lineRangeMapping.original.contains(e.position.lineNumber));
      i?.lineRangeMapping.modified.isEmpty ? this._accessibilitySignalService.playSignal(ua.diffLineDeleted, { source: "diffEditor.cursorPositionChanged" }) : i?.lineRangeMapping.original.isEmpty ? this._accessibilitySignalService.playSignal(ua.diffLineInserted, { source: "diffEditor.cursorPositionChanged" }) : i && this._accessibilitySignalService.playSignal(ua.diffLineModified, { source: "diffEditor.cursorPositionChanged" });
    }
  }
};
Hv = nle([
  ap(3, Se),
  ap(4, ke),
  ap(5, Nt),
  ap(6, bS),
  ap(7, P_)
], Hv);
function sle(s) {
  return s.mappings.map((e) => {
    const t = e.lineRangeMapping;
    let i, n, o, r, a = t.innerChanges;
    return t.original.isEmpty ? (i = t.original.startLineNumber - 1, n = 0, a = void 0) : (i = t.original.startLineNumber, n = t.original.endLineNumberExclusive - 1), t.modified.isEmpty ? (o = t.modified.startLineNumber - 1, r = 0, a = void 0) : (o = t.modified.startLineNumber, r = t.modified.endLineNumberExclusive - 1), {
      originalStartLineNumber: i,
      originalEndLineNumber: n,
      modifiedStartLineNumber: o,
      modifiedEndLineNumber: r,
      charChanges: a?.map((l) => ({
        originalStartLineNumber: l.originalRange.startLineNumber,
        originalStartColumn: l.originalRange.startColumn,
        originalEndLineNumber: l.originalRange.endLineNumber,
        originalEndColumn: l.originalRange.endColumn,
        modifiedStartLineNumber: l.modifiedRange.startLineNumber,
        modifiedStartColumn: l.modifiedRange.startColumn,
        modifiedEndLineNumber: l.modifiedRange.endLineNumber,
        modifiedEndColumn: l.modifiedRange.endColumn
      }))
    };
  });
}
var ZT = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, St = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ole = 0, yP = !1;
function rle(s) {
  if (!s) {
    if (yP)
      return;
    yP = !0;
  }
  ZJ(s || vt.document.body);
}
let Wv = class extends u_ {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g) {
    const m = { ...t };
    m.ariaLabel = m.ariaLabel || GL.editorViewAccessibleLabel, super(e, m, {}, i, n, o, r, c, d, h, u, g), l instanceof am ? this._standaloneKeybindingService = l : this._standaloneKeybindingService = null, rle(m.ariaContainerElement), f$((p, A) => i.createInstance(Kf, p, A, {})), m$(a);
  }
  addCommand(e, t, i) {
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add command because the editor is configured with an unrecognized KeybindingService"), null;
    const n = "DYNAMIC_" + ++ole, o = ne.deserialize(i);
    return this._standaloneKeybindingService.addDynamicKeybinding(n, e, t, o), n;
  }
  createContextKey(e, t) {
    return this._contextKeyService.createKey(e, t);
  }
  addAction(e) {
    if (typeof e.id != "string" || typeof e.label != "string" || typeof e.run != "function")
      throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
    if (!this._standaloneKeybindingService)
      return console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), V.None;
    const t = e.id, i = e.label, n = ne.and(ne.equals("editorId", this.getId()), ne.deserialize(e.precondition)), o = e.keybindings, r = ne.and(n, ne.deserialize(e.keybindingContext)), a = e.contextMenuGroupId || null, l = e.contextMenuOrder || 0, c = (g, ...m) => Promise.resolve(e.run(this, ...m)), d = new X(), h = this.getId() + ":" + t;
    if (d.add(mt.registerCommand(h, c)), a) {
      const g = {
        command: {
          id: h,
          title: i
        },
        when: n,
        group: a,
        order: l
      };
      d.add(mo.appendMenuItem(Qe.EditorContext, g));
    }
    if (Array.isArray(o))
      for (const g of o)
        d.add(this._standaloneKeybindingService.addDynamicKeybinding(h, g, c, r));
    const u = new W8(h, i, i, void 0, n, (...g) => Promise.resolve(e.run(this, ...g)), this._contextKeyService);
    return this._actions.set(t, u), d.add(we(() => {
      this._actions.delete(t);
    })), d;
  }
  _triggerCommand(e, t) {
    if (this._codeEditorService instanceof _C)
      try {
        this._codeEditorService.setActiveCodeEditor(this), super._triggerCommand(e, t);
      } finally {
        this._codeEditorService.setActiveCodeEditor(null);
      }
    else
      super._triggerCommand(e, t);
  }
};
Wv = ZT([
  St(2, ke),
  St(3, Nt),
  St(4, bi),
  St(5, Se),
  St(6, jl),
  St(7, bt),
  St(8, nn),
  St(9, Oi),
  St(10, Lo),
  St(11, tn),
  St(12, ye)
], Wv);
let qD = class extends Wv {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g, m, p, A) {
    const _ = { ...t };
    gv(h, _, !1);
    const b = c.registerEditorContainer(e);
    typeof _.theme == "string" && c.setTheme(_.theme), typeof _.autoDetectHighContrast < "u" && c.setAutoDetectHighContrast(!!_.autoDetectHighContrast);
    const C = _.model;
    delete _.model, super(e, _, i, n, o, r, a, l, c, d, u, p, A), this._configurationService = h, this._standaloneThemeService = c, this._register(b);
    let w;
    if (typeof C > "u") {
      const S = m.getLanguageIdByMimeType(_.language) || _.language || Js;
      w = eV(g, m, _.value || "", S, void 0), this._ownsModel = !0;
    } else
      w = C, this._ownsModel = !1;
    if (this._attachModel(w), w) {
      const S = {
        oldModelUrl: null,
        newModelUrl: w.uri
      };
      this._onDidChangeModel.fire(S);
    }
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    gv(this._configurationService, e, !1), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _postDetachModelCleanup(e) {
    super._postDetachModelCleanup(e), e && this._ownsModel && (e.dispose(), this._ownsModel = !1);
  }
};
qD = ZT([
  St(2, ke),
  St(3, Nt),
  St(4, bi),
  St(5, Se),
  St(6, jl),
  St(7, bt),
  St(8, cr),
  St(9, Oi),
  St(10, ht),
  St(11, Lo),
  St(12, Fi),
  St(13, si),
  St(14, tn),
  St(15, ye)
], qD);
let $D = class extends Hv {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u) {
    const g = { ...t };
    gv(l, g, !0);
    const m = r.registerEditorContainer(e);
    typeof g.theme == "string" && r.setTheme(g.theme), typeof g.autoDetectHighContrast < "u" && r.setAutoDetectHighContrast(!!g.autoDetectHighContrast), super(e, g, {}, n, i, o, u, d), this._configurationService = l, this._standaloneThemeService = r, this._register(m);
  }
  dispose() {
    super.dispose();
  }
  updateOptions(e) {
    gv(this._configurationService, e, !0), typeof e.theme == "string" && this._standaloneThemeService.setTheme(e.theme), typeof e.autoDetectHighContrast < "u" && this._standaloneThemeService.setAutoDetectHighContrast(!!e.autoDetectHighContrast), super.updateOptions(e);
  }
  _createInnerEditor(e, t, i) {
    return e.createInstance(Wv, t, i);
  }
  getOriginalEditor() {
    return super.getOriginalEditor();
  }
  getModifiedEditor() {
    return super.getModifiedEditor();
  }
  addCommand(e, t, i) {
    return this.getModifiedEditor().addCommand(e, t, i);
  }
  createContextKey(e, t) {
    return this.getModifiedEditor().createContextKey(e, t);
  }
  addAction(e) {
    return this.getModifiedEditor().addAction(e);
  }
};
$D = ZT([
  St(2, ke),
  St(3, Se),
  St(4, Nt),
  St(5, cr),
  St(6, Oi),
  St(7, ht),
  St(8, ar),
  St(9, P_),
  St(10, Yu),
  St(11, bS)
], $D);
function eV(s, e, t, i, n) {
  if (t = t || "", !i) {
    const o = t.indexOf(`
`);
    let r = t;
    return o !== -1 && (r = t.substring(0, o)), xP(s, t, e.createByFilepathOrFirstLine(n || null, r), n);
  }
  return xP(s, t, e.createById(i), n);
}
function xP(s, e, t, i) {
  return s.createModel(e, t, i);
}
var ale = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, EP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class lle {
  constructor(e, t) {
    this.viewModel = e, this.deltaScrollVertical = t;
  }
  getId() {
    return this.viewModel;
  }
}
let Vv = class extends V {
  constructor(e, t, i, n, o) {
    super(), this._container = e, this._overflowWidgetsDomNode = t, this._workbenchUIElementFactory = i, this._instantiationService = n, this._viewModel = ot(this, void 0), this._collapsed = De(this, (l) => this._viewModel.read(l)?.collapsed.read(l)), this._editorContentHeight = ot(this, 500), this.contentHeight = De(this, (l) => (this._collapsed.read(l) ? 0 : this._editorContentHeight.read(l)) + this._outerEditorHeight), this._modifiedContentWidth = ot(this, 0), this._modifiedWidth = ot(this, 0), this._originalContentWidth = ot(this, 0), this._originalWidth = ot(this, 0), this.maxScroll = De(this, (l) => {
      const c = this._modifiedContentWidth.read(l) - this._modifiedWidth.read(l), d = this._originalContentWidth.read(l) - this._originalWidth.read(l);
      return c > d ? { maxScroll: c, width: this._modifiedWidth.read(l) } : { maxScroll: d, width: this._originalWidth.read(l) };
    }), this._elements = it("div.multiDiffEntry", [
      it("div.header@header", [
        it("div.header-content", [
          it("div.collapse-button@collapseButton"),
          it("div.file-path", [
            it("div.title.modified.show-file-icons@primaryPath", []),
            it("div.status.deleted@status", ["R"]),
            it("div.title.original.show-file-icons@secondaryPath", [])
          ]),
          it("div.actions@actions")
        ])
      ]),
      it("div.editorParent", [
        it("div.editorContainer@editor")
      ])
    ]), this.editor = this._register(this._instantiationService.createInstance(Hv, this._elements.editor, {
      overflowWidgetsDomNode: this._overflowWidgetsDomNode
    }, {})), this.isModifedFocused = f_(this.editor.getModifiedEditor()).isFocused, this.isOriginalFocused = f_(this.editor.getOriginalEditor()).isFocused, this.isFocused = De(this, (l) => this.isModifedFocused.read(l) || this.isOriginalFocused.read(l)), this._resourceLabel = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.primaryPath)) : void 0, this._resourceLabel2 = this._workbenchUIElementFactory.createResourceLabel ? this._register(this._workbenchUIElementFactory.createResourceLabel(this._elements.secondaryPath)) : void 0, this._dataStore = this._register(new X()), this._headerHeight = 40, this._lastScrollTop = -1, this._isSettingScrollTop = !1;
    const r = new Lk(this._elements.collapseButton, {});
    this._register(et((l) => {
      r.element.className = "", r.icon = this._collapsed.read(l) ? Z.chevronRight : Z.chevronDown;
    })), this._register(r.onDidClick(() => {
      this._viewModel.get()?.collapsed.set(!this._collapsed.get(), void 0);
    })), this._register(et((l) => {
      this._elements.editor.style.display = this._collapsed.read(l) ? "none" : "block";
    })), this._register(this.editor.getModifiedEditor().onDidLayoutChange((l) => {
      const c = this.editor.getModifiedEditor().getLayoutInfo().contentWidth;
      this._modifiedWidth.set(c, void 0);
    })), this._register(this.editor.getOriginalEditor().onDidLayoutChange((l) => {
      const c = this.editor.getOriginalEditor().getLayoutInfo().contentWidth;
      this._originalWidth.set(c, void 0);
    })), this._register(this.editor.onDidContentSizeChange((l) => {
      mp((c) => {
        this._editorContentHeight.set(l.contentHeight, c), this._modifiedContentWidth.set(this.editor.getModifiedEditor().getContentWidth(), c), this._originalContentWidth.set(this.editor.getOriginalEditor().getContentWidth(), c);
      });
    })), this._register(this.editor.getOriginalEditor().onDidScrollChange((l) => {
      if (this._isSettingScrollTop || !l.scrollTopChanged || !this._data)
        return;
      const c = l.scrollTop - this._lastScrollTop;
      this._data.deltaScrollVertical(c);
    })), this._register(et((l) => {
      const c = this._viewModel.read(l)?.isActive.read(l);
      this._elements.root.classList.toggle("active", c);
    })), this._container.appendChild(this._elements.root), this._outerEditorHeight = this._headerHeight, this._contextKeyService = this._register(o.createScoped(this._elements.actions));
    const a = this._register(this._instantiationService.createChild(new Lm([Se, this._contextKeyService])));
    this._register(a.createInstance(Ov, this._elements.actions, Qe.MultiDiffEditorFileToolbar, {
      actionRunner: this._register(new $8(() => this._viewModel.get()?.modifiedUri)),
      menuOptions: {
        shouldForwardArgs: !0
      },
      toolbarOptions: { primaryGroup: (l) => l.startsWith("navigation") },
      actionViewItemProvider: (l, c) => J3(a, l, c)
    }));
  }
  setScrollLeft(e) {
    this._modifiedContentWidth.get() - this._modifiedWidth.get() > this._originalContentWidth.get() - this._originalWidth.get() ? this.editor.getModifiedEditor().setScrollLeft(e) : this.editor.getOriginalEditor().setScrollLeft(e);
  }
  setData(e) {
    this._data = e;
    function t(n) {
      return {
        ...n,
        scrollBeyondLastLine: !1,
        hideUnchangedRegions: {
          enabled: !0
        },
        scrollbar: {
          vertical: "hidden",
          horizontal: "hidden",
          handleMouseWheel: !1,
          useShadows: !1
        },
        renderOverviewRuler: !1,
        fixedOverflowWidgets: !0,
        overviewRulerBorder: !1
      };
    }
    if (!e) {
      mp((n) => {
        this._viewModel.set(void 0, n), this.editor.setDiffModel(null, n), this._dataStore.clear();
      });
      return;
    }
    const i = e.viewModel.documentDiffItem;
    if (mp((n) => {
      this._resourceLabel?.setUri(e.viewModel.modifiedUri ?? e.viewModel.originalUri, { strikethrough: e.viewModel.modifiedUri === void 0 });
      let o = !1, r = !1, a = !1, l = "";
      e.viewModel.modifiedUri && e.viewModel.originalUri && e.viewModel.modifiedUri.path !== e.viewModel.originalUri.path ? (l = "R", o = !0) : e.viewModel.modifiedUri ? e.viewModel.originalUri || (l = "A", a = !0) : (l = "D", r = !0), this._elements.status.classList.toggle("renamed", o), this._elements.status.classList.toggle("deleted", r), this._elements.status.classList.toggle("added", a), this._elements.status.innerText = l, this._resourceLabel2?.setUri(o ? e.viewModel.originalUri : void 0, { strikethrough: !0 }), this._dataStore.clear(), this._viewModel.set(e.viewModel, n), this.editor.setDiffModel(e.viewModel.diffEditorViewModelRef, n), this.editor.updateOptions(t(i.options ?? {}));
    }), i.onOptionsDidChange && this._dataStore.add(i.onOptionsDidChange(() => {
      this.editor.updateOptions(t(i.options ?? {}));
    })), e.viewModel.isAlive.recomputeInitiallyAndOnChange(this._dataStore, (n) => {
      n || this.setData(void 0);
    }), e.viewModel.documentDiffItem.contextKeys)
      for (const [n, o] of Object.entries(e.viewModel.documentDiffItem.contextKeys))
        this._contextKeyService.createKey(n, o);
  }
  render(e, t, i, n) {
    this._elements.root.style.visibility = "visible", this._elements.root.style.top = `${e.start}px`, this._elements.root.style.height = `${e.length}px`, this._elements.root.style.width = `${t}px`, this._elements.root.style.position = "absolute";
    const o = e.length - this._headerHeight, r = Math.max(0, Math.min(n.start - e.start, o));
    this._elements.header.style.transform = `translateY(${r}px)`, mp((a) => {
      this.editor.layout({
        width: t - 2 * 8 - 2 * 1,
        height: e.length - this._outerEditorHeight
      });
    });
    try {
      this._isSettingScrollTop = !0, this._lastScrollTop = i, this.editor.getOriginalEditor().setScrollTop(i);
    } finally {
      this._isSettingScrollTop = !1;
    }
    this._elements.header.classList.toggle("shadow", r > 0 || i > 0), this._elements.header.classList.toggle("collapsed", r === o);
  }
  hide() {
    this._elements.root.style.top = "-100000px", this._elements.root.style.visibility = "hidden";
  }
};
Vv = ale([
  EP(3, ke),
  EP(4, Se)
], Vv);
class cle {
  constructor(e) {
    this._create = e, this._unused = /* @__PURE__ */ new Set(), this._used = /* @__PURE__ */ new Set(), this._itemData = /* @__PURE__ */ new Map();
  }
  getUnusedObj(e) {
    let t;
    if (this._unused.size === 0)
      t = this._create(e), this._itemData.set(t, e);
    else {
      const i = [...this._unused.values()];
      t = i.find((n) => this._itemData.get(n).getId() === e.getId()) ?? i[0], this._unused.delete(t), this._itemData.set(t, e), t.setData(e);
    }
    return this._used.add(t), {
      object: t,
      dispose: () => {
        this._used.delete(t), this._unused.size > 5 ? t.dispose() : this._unused.add(t);
      }
    };
  }
  dispose() {
    for (const e of this._used)
      e.dispose();
    for (const e of this._unused)
      e.dispose();
    this._used.clear(), this._unused.clear();
  }
}
var dle = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, LP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let XD = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._element = e, this._dimension = t, this._viewModel = i, this._workbenchUIElementFactory = n, this._parentContextKeyService = o, this._parentInstantiationService = r, this._scrollableElements = it("div.scrollContent", [
      it("div@content", {
        style: {
          overflow: "hidden"
        }
      }),
      it("div.monaco-editor@overflowWidgetsDomNode", {})
    ]), this._scrollable = this._register(new vm({
      forceIntegerValues: !1,
      scheduleAtNextAnimationFrame: (l) => ys(fe(this._element), l),
      smoothScrollDuration: 100
    })), this._scrollableElement = this._register(new Y0(this._scrollableElements.root, {
      vertical: 1,
      horizontal: 1,
      useShadows: !1
    }, this._scrollable)), this._elements = it("div.monaco-component.multiDiffEditor", {}, [
      it("div", {}, [this._scrollableElement.getDomNode()]),
      it("div.placeholder@placeholder", {}, [it("div", [f("noChangedFiles", "No Changed Files")])])
    ]), this._sizeObserver = this._register(new Q8(this._element, void 0)), this._objectPool = this._register(new cle((l) => {
      const c = this._instantiationService.createInstance(Vv, this._scrollableElements.content, this._scrollableElements.overflowWidgetsDomNode, this._workbenchUIElementFactory);
      return c.setData(l), c;
    })), this.scrollTop = $t(this, this._scrollableElement.onScroll, () => (
      /** @description scrollTop */
      this._scrollableElement.getScrollPosition().scrollTop
    )), this.scrollLeft = $t(this, this._scrollableElement.onScroll, () => (
      /** @description scrollLeft */
      this._scrollableElement.getScrollPosition().scrollLeft
    )), this._viewItemsInfo = Uu(this, (l, c) => {
      const d = this._viewModel.read(l);
      if (!d)
        return { items: [], getItem: (m) => {
          throw new lt();
        } };
      const h = d.items.read(l), u = /* @__PURE__ */ new Map();
      return { items: h.map((m) => {
        const p = c.add(new hle(m, this._objectPool, this.scrollLeft, (_) => {
          this._scrollableElement.setScrollPosition({ scrollTop: this._scrollableElement.getScrollPosition().scrollTop + _ });
        })), A = this._lastDocStates?.[p.getKey()];
        return A && xi((_) => {
          p.setViewState(A, _);
        }), u.set(m, p), p;
      }), getItem: (m) => u.get(m) };
    }), this._viewItems = this._viewItemsInfo.map(this, (l) => l.items), this._spaceBetweenPx = 0, this._totalHeight = this._viewItems.map(this, (l, c) => l.reduce((d, h) => d + h.contentHeight.read(c) + this._spaceBetweenPx, 0)), this._contextKeyService = this._register(this._parentContextKeyService.createScoped(this._element)), this._instantiationService = this._register(this._parentInstantiationService.createChild(new Lm([Se, this._contextKeyService]))), this._lastDocStates = {}, this._contextKeyService.createKey(R.inMultiDiffEditor.key, !0), this._register(Yo((l, c) => {
      const d = this._viewModel.read(l);
      if (d && d.contextKeys)
        for (const [h, u] of Object.entries(d.contextKeys)) {
          const g = this._contextKeyService.createKey(h, void 0);
          g.set(u), c.add(we(() => g.reset()));
        }
    }));
    const a = this._parentContextKeyService.createKey(R.multiDiffEditorAllCollapsed.key, !1);
    this._register(et((l) => {
      const c = this._viewModel.read(l);
      if (c) {
        const d = c.items.read(l).every((h) => h.collapsed.read(l));
        a.set(d);
      }
    })), this._register(et((l) => {
      const c = this._dimension.read(l);
      this._sizeObserver.observe(c);
    })), this._register(et((l) => {
      const c = this._viewItems.read(l);
      this._elements.placeholder.classList.toggle("visible", c.length === 0);
    })), this._scrollableElements.content.style.position = "relative", this._register(et((l) => {
      const c = this._sizeObserver.height.read(l);
      this._scrollableElements.root.style.height = `${c}px`;
      const d = this._totalHeight.read(l);
      this._scrollableElements.content.style.height = `${d}px`;
      const h = this._sizeObserver.width.read(l);
      let u = h;
      const g = this._viewItems.read(l), m = w5(g, _o((p) => p.maxScroll.read(l).maxScroll, Ml));
      if (m) {
        const p = m.maxScroll.read(l);
        u = h + p.maxScroll;
      }
      this._scrollableElement.setScrollDimensions({
        width: h,
        height: c,
        scrollHeight: d,
        scrollWidth: u
      });
    })), e.replaceChildren(this._elements.root), this._register(we(() => {
      e.replaceChildren();
    })), this._register(this._register(et((l) => {
      mp((c) => {
        this.render(l);
      });
    })));
  }
  render(e) {
    const t = this.scrollTop.read(e);
    let i = 0, n = 0, o = 0;
    const r = this._sizeObserver.height.read(e), a = Be.ofStartAndLength(t, r), l = this._sizeObserver.width.read(e);
    for (const c of this._viewItems.read(e)) {
      const d = c.contentHeight.read(e), h = Math.min(d, r), u = Be.ofStartAndLength(n, h), g = Be.ofStartAndLength(o, d);
      if (g.isBefore(a))
        i -= d - h, c.hide();
      else if (g.isAfter(a))
        c.hide();
      else {
        const m = Math.max(0, Math.min(a.start - g.start, d - h));
        i -= m;
        const p = Be.ofStartAndLength(t + i, r);
        c.render(u, m, l, p);
      }
      n += h + this._spaceBetweenPx, o += d + this._spaceBetweenPx;
    }
    this._scrollableElements.content.style.transform = `translateY(${-(t + i)}px)`;
  }
};
XD = dle([
  LP(4, Se),
  LP(5, ke)
], XD);
class hle extends V {
  constructor(e, t, i, n) {
    super(), this.viewModel = e, this._objectPool = t, this._scrollLeft = i, this._deltaScrollVertical = n, this._templateRef = this._register(R3(this, void 0)), this.contentHeight = De(this, (o) => this._templateRef.read(o)?.object.contentHeight?.read(o) ?? this.viewModel.lastTemplateData.read(o).contentHeight), this.maxScroll = De(this, (o) => this._templateRef.read(o)?.object.maxScroll.read(o) ?? { maxScroll: 0, scrollWidth: 0 }), this.template = De(this, (o) => this._templateRef.read(o)?.object), this._isHidden = ot(this, !1), this._isFocused = De(this, (o) => this.template.read(o)?.isFocused.read(o) ?? !1), this.viewModel.setIsFocused(this._isFocused, void 0), this._register(et((o) => {
      const r = this._scrollLeft.read(o);
      this._templateRef.read(o)?.object.setScrollLeft(r);
    })), this._register(et((o) => {
      const r = this._templateRef.read(o);
      !r || !this._isHidden.read(o) || r.object.isFocused.read(o) || this._clear();
    }));
  }
  dispose() {
    this._clear(), super.dispose();
  }
  toString() {
    return `VirtualViewItem(${this.viewModel.documentDiffItem.modified?.uri.toString()})`;
  }
  getKey() {
    return this.viewModel.getKey();
  }
  setViewState(e, t) {
    this.viewModel.collapsed.set(e.collapsed, t), this._updateTemplateData(t);
    const i = this.viewModel.lastTemplateData.get(), n = e.selections?.map(Ue.liftSelection);
    this.viewModel.lastTemplateData.set({
      ...i,
      selections: n
    }, t);
    const o = this._templateRef.get();
    o && n && o.object.editor.setSelections(n);
  }
  _updateTemplateData(e) {
    const t = this._templateRef.get();
    t && this.viewModel.lastTemplateData.set({
      contentHeight: t.object.contentHeight.get(),
      selections: t.object.editor.getSelections() ?? void 0
    }, e);
  }
  _clear() {
    const e = this._templateRef.get();
    e && xi((t) => {
      this._updateTemplateData(t), e.object.hide(), this._templateRef.set(void 0, t);
    });
  }
  hide() {
    this._isHidden.set(!0, void 0);
  }
  render(e, t, i, n) {
    this._isHidden.set(!1, void 0);
    let o = this._templateRef.get();
    if (!o) {
      o = this._objectPool.getUnusedObj(new lle(this.viewModel, this._deltaScrollVertical)), this._templateRef.set(o, void 0);
      const r = this.viewModel.lastTemplateData.get().selections;
      r && o.object.editor.setSelections(r);
    }
    o.object.render(e, i, t, n);
  }
}
L("multiDiffEditor.headerBackground", { dark: "#262626", light: "tab.inactiveBackground", hcDark: "tab.inactiveBackground", hcLight: "tab.inactiveBackground" }, f("multiDiffEditor.headerBackground", "The background color of the diff editor's header"));
L("multiDiffEditor.background", $o, f("multiDiffEditor.background", "The background color of the multi file diff editor"));
L("multiDiffEditor.border", { dark: "sideBarSectionHeader.border", light: "#cccccc", hcDark: "sideBarSectionHeader.border", hcLight: "#cccccc" }, f("multiDiffEditor.border", "The border color of the multi file diff editor"));
var ule = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gle = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ZD = class extends V {
  constructor(e, t, i) {
    super(), this._element = e, this._workbenchUIElementFactory = t, this._instantiationService = i, this._dimension = ot(this, void 0), this._viewModel = ot(this, void 0), this._widgetImpl = Uu(this, (n, o) => (Po(Vv, n), o.add(this._instantiationService.createInstance(Po(XD, n), this._element, this._dimension, this._viewModel, this._workbenchUIElementFactory)))), this._register(rS(this._widgetImpl));
  }
};
ZD = ule([
  gle(2, ke)
], ZD);
function fle(s, e, t) {
  return Ae.initialize(t || {}).createInstance(qD, s, e);
}
function mle(s) {
  return Ae.get(Nt).onCodeEditorAdd((t) => {
    s(t);
  });
}
function ple(s) {
  return Ae.get(Nt).onDiffEditorAdd((t) => {
    s(t);
  });
}
function Ale() {
  return Ae.get(Nt).listCodeEditors();
}
function _le() {
  return Ae.get(Nt).listDiffEditors();
}
function ble(s, e, t) {
  return Ae.initialize(t || {}).createInstance($D, s, e);
}
function wle(s, e) {
  const t = Ae.initialize(e || {});
  return new ZD(s, {}, t);
}
function Cle(s) {
  if (typeof s.id != "string" || typeof s.run != "function")
    throw new Error("Invalid command descriptor, `id` and `run` are required properties!");
  return mt.registerCommand(s.id, s.run);
}
function vle(s) {
  if (typeof s.id != "string" || typeof s.label != "string" || typeof s.run != "function")
    throw new Error("Invalid action descriptor, `id`, `label` and `run` are required properties!");
  const e = ne.deserialize(s.precondition), t = (n, ...o) => Wn.runEditorCommand(n, o, e, (r, a, l) => Promise.resolve(s.run(a, ...l))), i = new X();
  if (i.add(mt.registerCommand(s.id, t)), s.contextMenuGroupId) {
    const n = {
      command: {
        id: s.id,
        title: s.label
      },
      when: e,
      group: s.contextMenuGroupId,
      order: s.contextMenuOrder || 0
    };
    i.add(mo.appendMenuItem(Qe.EditorContext, n));
  }
  if (Array.isArray(s.keybindings)) {
    const n = Ae.get(bt);
    if (!(n instanceof am))
      console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService");
    else {
      const o = ne.and(e, ne.deserialize(s.keybindingContext));
      i.add(n.addDynamicKeybindings(s.keybindings.map((r) => ({
        keybinding: r,
        command: s.id,
        when: o
      }))));
    }
  }
  return i;
}
function Sle(s) {
  return tV([s]);
}
function tV(s) {
  const e = Ae.get(bt);
  return e instanceof am ? e.addDynamicKeybindings(s.map((t) => ({
    keybinding: t.keybinding,
    command: t.command,
    commandArgs: t.commandArgs,
    when: ne.deserialize(t.when)
  }))) : (console.warn("Cannot add keybinding because the editor is configured with an unrecognized KeybindingService"), V.None);
}
function yle(s, e, t) {
  const i = Ae.get(si), n = i.getLanguageIdByMimeType(e) || e;
  return eV(Ae.get(Fi), i, s, n, t);
}
function xle(s, e) {
  const t = Ae.get(si), i = t.getLanguageIdByMimeType(e) || e || Js;
  s.setLanguage(t.createById(i));
}
function Ele(s, e, t) {
  s && Ae.get(Pa).changeOne(e, s.uri, t);
}
function Lle(s) {
  Ae.get(Pa).changeAll(s, []);
}
function kle(s) {
  return Ae.get(Pa).read(s);
}
function Dle(s) {
  return Ae.get(Pa).onMarkerChanged(s);
}
function Ile(s) {
  return Ae.get(Fi).getModel(s);
}
function Mle() {
  return Ae.get(Fi).getModels();
}
function Nle(s) {
  return Ae.get(Fi).onModelAdded(s);
}
function Tle(s) {
  return Ae.get(Fi).onModelRemoved(s);
}
function Ble(s) {
  return Ae.get(Fi).onModelLanguageChanged((t) => {
    s({
      model: t.model,
      oldLanguage: t.oldLanguageId
    });
  });
}
function Rle(s) {
  return gne(Ae.get(Fi), s);
}
function Fle(s, e) {
  const t = Ae.get(si), i = Ae.get(cr);
  return kT.colorizeElement(i, t, s, e).then(() => {
    i.registerEditorContainer(s);
  });
}
function Ole(s, e, t) {
  const i = Ae.get(si);
  return Ae.get(cr).registerEditorContainer(vt.document.body), kT.colorize(i, s, e, t);
}
function Ple(s, e, t = 4) {
  return Ae.get(cr).registerEditorContainer(vt.document.body), kT.colorizeModelLine(s, e, t);
}
function Hle(s) {
  const e = ci.get(s);
  return e || {
    getInitialState: () => jA,
    tokenize: (t, i, n) => E3(s, n)
  };
}
function Wle(s, e) {
  ci.getOrCreate(e);
  const t = Hle(e), i = bd(s), n = [];
  let o = t.getInitialState();
  for (let r = 0, a = i.length; r < a; r++) {
    const l = i[r], c = t.tokenize(l, !0, o);
    n[r] = c.tokens, o = c.endState;
  }
  return n;
}
function Vle(s, e) {
  Ae.get(cr).defineTheme(s, e);
}
function zle(s) {
  Ae.get(cr).setTheme(s);
}
function Ule() {
  GE.clearAllFontInfos();
}
function Qle(s, e) {
  return mt.registerCommand({ id: s, handler: e });
}
function Gle(s) {
  return Ae.get(lr).registerOpener({
    async open(t) {
      return typeof t == "string" && (t = _e.parse(t)), s.open(t);
    }
  });
}
function jle(s) {
  return Ae.get(Nt).registerCodeEditorOpenHandler(async (t, i, n) => {
    if (!i)
      return null;
    const o = t.options?.selection;
    let r;
    return o && typeof o.endLineNumber == "number" && typeof o.endColumn == "number" ? r = o : o && (r = { lineNumber: o.startLineNumber, column: o.startColumn }), await s.openCodeEditor(i, t.resource, r) ? i : null;
  });
}
function Yle() {
  return {
    // methods
    create: fle,
    getEditors: Ale,
    getDiffEditors: _le,
    onDidCreateEditor: mle,
    onDidCreateDiffEditor: ple,
    createDiffEditor: ble,
    addCommand: Cle,
    addEditorAction: vle,
    addKeybindingRule: Sle,
    addKeybindingRules: tV,
    createModel: yle,
    setModelLanguage: xle,
    setModelMarkers: Ele,
    getModelMarkers: kle,
    removeAllMarkers: Lle,
    onDidChangeMarkers: Dle,
    getModels: Mle,
    getModel: Ile,
    onDidCreateModel: Nle,
    onWillDisposeModel: Tle,
    onDidChangeModelLanguage: Ble,
    createWebWorker: Rle,
    colorizeElement: Fle,
    colorize: Ole,
    colorizeModelLine: Ple,
    tokenize: Wle,
    defineTheme: Vle,
    setTheme: zle,
    remeasureFonts: Ule,
    registerCommand: Qle,
    registerLinkOpener: Gle,
    registerEditorOpener: jle,
    // enums
    AccessibilitySupport: Hx,
    ContentWidgetPositionPreference: Gx,
    CursorChangeReason: jx,
    DefaultEndOfLine: Yx,
    EditorAutoIndentStrategy: Jx,
    EditorOption: qx,
    EndOfLinePreference: $x,
    EndOfLineSequence: Xx,
    MinimapPosition: cE,
    MinimapSectionHeaderStyle: dE,
    MouseTargetType: hE,
    OverlayWidgetPositionPreference: fE,
    OverviewRulerLane: mE,
    GlyphMarginLane: Zx,
    RenderLineNumbersType: _E,
    RenderMinimap: bE,
    ScrollbarVisibility: CE,
    ScrollType: wE,
    TextEditorCursorBlinkingStyle: LE,
    TextEditorCursorStyle: kE,
    TrackedRangeStickiness: DE,
    WrappingIndent: IE,
    InjectedTextCursorStops: iE,
    PositionAffinity: AE,
    ShowLightbulbIconMode: SE,
    // classes
    ConfigurationChangedEvent: Z4,
    BareFontInfo: Lh,
    FontInfo: QE,
    TextModelResolvedOptions: _w,
    FindMatch: RA,
    ApplyUpdateResult: Dp,
    EditorZoom: _c,
    createMultiFileDiffEditor: wle,
    // vars
    EditorType: wS,
    EditorOptions: Hr
  };
}
function Kle(s, e) {
  if (!e || !Array.isArray(e))
    return !1;
  for (const t of e)
    if (!s(t))
      return !1;
  return !0;
}
function Kb(s, e) {
  return typeof s == "boolean" ? s : e;
}
function kP(s, e) {
  return typeof s == "string" ? s : e;
}
function Jle(s) {
  const e = {};
  for (const t of s)
    e[t] = !0;
  return e;
}
function DP(s, e = !1) {
  e && (s = s.map(function(i) {
    return i.toLowerCase();
  }));
  const t = Jle(s);
  return e ? function(i) {
    return t[i.toLowerCase()] !== void 0 && t.hasOwnProperty(i.toLowerCase());
  } : function(i) {
    return t[i] !== void 0 && t.hasOwnProperty(i);
  };
}
function eI(s, e, t) {
  e = e.replace(/@@/g, "");
  let i = 0, n;
  do
    n = !1, e = e.replace(/@(\w+)/g, function(r, a) {
      n = !0;
      let l = "";
      if (typeof s[a] == "string")
        l = s[a];
      else if (s[a] && s[a] instanceof RegExp)
        l = s[a].source;
      else
        throw s[a] === void 0 ? It(s, "language definition does not contain attribute '" + a + "', used at: " + e) : It(s, "attribute reference '" + a + "' must be a string, used at: " + e);
      return oh(l) ? "" : "(?:" + l + ")";
    }), i++;
  while (n && i < 5);
  e = e.replace(/\x01/g, "@");
  const o = (s.ignoreCase ? "i" : "") + (s.unicode ? "u" : "");
  if (t && e.match(/\$[sS](\d\d?)/g)) {
    let a = null, l = null;
    return (c) => (l && a === c || (a = c, l = new RegExp(Nne(s, e, c), o)), l);
  }
  return new RegExp(e, o);
}
function qle(s, e, t, i) {
  if (i < 0)
    return s;
  if (i < e.length)
    return e[i];
  if (i >= 100) {
    i = i - 100;
    const n = t.split(".");
    if (n.unshift(t), i < n.length)
      return n[i];
  }
  return null;
}
function $le(s, e, t, i) {
  let n = -1, o = t, r = t.match(/^\$(([sS]?)(\d\d?)|#)(.*)$/);
  r && (r[3] && (n = parseInt(r[3]), r[2] && (n = n + 100)), o = r[4]);
  let a = "~", l = o;
  !o || o.length === 0 ? (a = "!=", l = "") : /^\w*$/.test(l) ? a = "==" : (r = o.match(/^(@|!@|~|!~|==|!=)(.*)$/), r && (a = r[1], l = r[2]));
  let c;
  if ((a === "~" || a === "!~") && /^(\w|\|)*$/.test(l)) {
    const d = DP(l.split("|"), s.ignoreCase);
    c = function(h) {
      return a === "~" ? d(h) : !d(h);
    };
  } else if (a === "@" || a === "!@") {
    const d = s[l];
    if (!d)
      throw It(s, "the @ match target '" + l + "' is not defined, in rule: " + e);
    if (!Kle(function(u) {
      return typeof u == "string";
    }, d))
      throw It(s, "the @ match target '" + l + "' must be an array of strings, in rule: " + e);
    const h = DP(d, s.ignoreCase);
    c = function(u) {
      return a === "@" ? h(u) : !h(u);
    };
  } else if (a === "~" || a === "!~")
    if (l.indexOf("$") < 0) {
      const d = eI(s, "^" + l + "$", !1);
      c = function(h) {
        return a === "~" ? d.test(h) : !d.test(h);
      };
    } else
      c = function(d, h, u, g) {
        return eI(s, "^" + Cc(s, l, h, u, g) + "$", !1).test(d);
      };
  else if (l.indexOf("$") < 0) {
    const d = Fl(s, l);
    c = function(h) {
      return a === "==" ? h === d : h !== d;
    };
  } else {
    const d = Fl(s, l);
    c = function(h, u, g, m, p) {
      const A = Cc(s, d, u, g, m);
      return a === "==" ? h === A : h !== A;
    };
  }
  return n === -1 ? {
    name: t,
    value: i,
    test: function(d, h, u, g) {
      return c(d, d, h, u, g);
    }
  } : {
    name: t,
    value: i,
    test: function(d, h, u, g) {
      const m = qle(d, h, u, n);
      return c(m || "", d, h, u, g);
    }
  };
}
function tI(s, e, t) {
  if (t) {
    if (typeof t == "string")
      return t;
    if (t.token || t.token === "") {
      if (typeof t.token != "string")
        throw It(s, "a 'token' attribute must be of type string, in rule: " + e);
      {
        const i = { token: t.token };
        if (t.token.indexOf("$") >= 0 && (i.tokenSubst = !0), typeof t.bracket == "string")
          if (t.bracket === "@open")
            i.bracket = 1;
          else if (t.bracket === "@close")
            i.bracket = -1;
          else
            throw It(s, "a 'bracket' attribute must be either '@open' or '@close', in rule: " + e);
        if (t.next) {
          if (typeof t.next != "string")
            throw It(s, "the next state must be a string value in rule: " + e);
          {
            let n = t.next;
            if (!/^(@pop|@push|@popall)$/.test(n) && (n[0] === "@" && (n = n.substr(1)), n.indexOf("$") < 0 && !Tne(s, Cc(s, n, "", [], ""))))
              throw It(s, "the next state '" + t.next + "' is not defined in rule: " + e);
            i.next = n;
          }
        }
        return typeof t.goBack == "number" && (i.goBack = t.goBack), typeof t.switchTo == "string" && (i.switchTo = t.switchTo), typeof t.log == "string" && (i.log = t.log), typeof t.nextEmbedded == "string" && (i.nextEmbedded = t.nextEmbedded, s.usesEmbedded = !0), i;
      }
    } else if (Array.isArray(t)) {
      const i = [];
      for (let n = 0, o = t.length; n < o; n++)
        i[n] = tI(s, e, t[n]);
      return { group: i };
    } else if (t.cases) {
      const i = [];
      for (const o in t.cases)
        if (t.cases.hasOwnProperty(o)) {
          const r = tI(s, e, t.cases[o]);
          o === "@default" || o === "@" || o === "" ? i.push({ test: void 0, value: r, name: o }) : o === "@eos" ? i.push({ test: function(a, l, c, d) {
            return d;
          }, value: r, name: o }) : i.push($le(s, e, o, r));
        }
      const n = s.defaultToken;
      return {
        test: function(o, r, a, l) {
          for (const c of i)
            if (!c.test || c.test(o, r, a, l))
              return c.value;
          return n;
        }
      };
    } else
      throw It(s, "an action must be a string, an object with a 'token' or 'cases' attribute, or an array of actions; in rule: " + e);
  } else return { token: "" };
}
class Xle {
  constructor(e) {
    this.regex = new RegExp(""), this.action = { token: "" }, this.matchOnlyAtLineStart = !1, this.name = "", this.name = e;
  }
  setRegex(e, t) {
    let i;
    if (typeof t == "string")
      i = t;
    else if (t instanceof RegExp)
      i = t.source;
    else
      throw It(e, "rules must start with a match string or regular expression: " + this.name);
    this.matchOnlyAtLineStart = i.length > 0 && i[0] === "^", this.name = this.name + ": " + i, this.regex = eI(e, "^(?:" + (this.matchOnlyAtLineStart ? i.substr(1) : i) + ")", !0);
  }
  setAction(e, t) {
    this.action = tI(e, this.name, t);
  }
  resolveRegex(e) {
    return this.regex instanceof RegExp ? this.regex : this.regex(e);
  }
}
function iV(s, e) {
  if (!e || typeof e != "object")
    throw new Error("Monarch: expecting a language definition object");
  const t = {
    languageId: s,
    includeLF: Kb(e.includeLF, !1),
    noThrow: !1,
    // raise exceptions during compilation
    maxStack: 100,
    start: typeof e.start == "string" ? e.start : null,
    ignoreCase: Kb(e.ignoreCase, !1),
    unicode: Kb(e.unicode, !1),
    tokenPostfix: kP(e.tokenPostfix, "." + s),
    defaultToken: kP(e.defaultToken, "source"),
    usesEmbedded: !1,
    // becomes true if we find a nextEmbedded action
    stateNames: {},
    tokenizer: {},
    brackets: []
  }, i = e;
  i.languageId = s, i.includeLF = t.includeLF, i.ignoreCase = t.ignoreCase, i.unicode = t.unicode, i.noThrow = t.noThrow, i.usesEmbedded = t.usesEmbedded, i.stateNames = e.tokenizer, i.defaultToken = t.defaultToken;
  function n(r, a, l) {
    for (const c of l) {
      let d = c.include;
      if (d) {
        if (typeof d != "string")
          throw It(t, "an 'include' attribute must be a string at: " + r);
        if (d[0] === "@" && (d = d.substr(1)), !e.tokenizer[d])
          throw It(t, "include target '" + d + "' is not defined at: " + r);
        n(r + "." + d, a, e.tokenizer[d]);
      } else {
        const h = new Xle(r);
        if (Array.isArray(c) && c.length >= 1 && c.length <= 3)
          if (h.setRegex(i, c[0]), c.length >= 3)
            if (typeof c[1] == "string")
              h.setAction(i, { token: c[1], next: c[2] });
            else if (typeof c[1] == "object") {
              const u = c[1];
              u.next = c[2], h.setAction(i, u);
            } else
              throw It(t, "a next state as the last element of a rule can only be given if the action is either an object or a string, at: " + r);
          else
            h.setAction(i, c[1]);
        else {
          if (!c.regex)
            throw It(t, "a rule must either be an array, or an object with a 'regex' or 'include' field at: " + r);
          c.name && typeof c.name == "string" && (h.name = c.name), c.matchOnlyAtStart && (h.matchOnlyAtLineStart = Kb(c.matchOnlyAtLineStart, !1)), h.setRegex(i, c.regex), h.setAction(i, c.action);
        }
        a.push(h);
      }
    }
  }
  if (!e.tokenizer || typeof e.tokenizer != "object")
    throw It(t, "a language definition must define the 'tokenizer' attribute as an object");
  t.tokenizer = [];
  for (const r in e.tokenizer)
    if (e.tokenizer.hasOwnProperty(r)) {
      t.start || (t.start = r);
      const a = e.tokenizer[r];
      t.tokenizer[r] = new Array(), n("tokenizer." + r, t.tokenizer[r], a);
    }
  if (t.usesEmbedded = i.usesEmbedded, e.brackets) {
    if (!Array.isArray(e.brackets))
      throw It(t, "the 'brackets' attribute must be defined as an array");
  } else
    e.brackets = [
      { open: "{", close: "}", token: "delimiter.curly" },
      { open: "[", close: "]", token: "delimiter.square" },
      { open: "(", close: ")", token: "delimiter.parenthesis" },
      { open: "<", close: ">", token: "delimiter.angle" }
    ];
  const o = [];
  for (const r of e.brackets) {
    let a = r;
    if (a && Array.isArray(a) && a.length === 3 && (a = { token: a[2], open: a[0], close: a[1] }), a.open === a.close)
      throw It(t, "open and close brackets in a 'brackets' attribute must be different: " + a.open + `
 hint: use the 'bracket' attribute if matching on equal brackets is required.`);
    if (typeof a.open == "string" && typeof a.token == "string" && typeof a.close == "string")
      o.push({
        token: a.token + t.tokenPostfix,
        open: Fl(t, a.open),
        close: Fl(t, a.close)
      });
    else
      throw It(t, "every element in the 'brackets' array must be a '{open,close,token}' object or array");
  }
  return t.brackets = o, t.noThrow = !0, t;
}
function Zle(s) {
  Qf.registerLanguage(s);
}
function ece() {
  let s = [];
  return s = s.concat(Qf.getLanguages()), s;
}
function tce(s) {
  return Ae.get(si).languageIdCodec.encodeLanguageId(s);
}
function ice(s, e) {
  return Ae.withServices(() => {
    const i = Ae.get(si).onDidRequestRichLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function nce(s, e) {
  return Ae.withServices(() => {
    const i = Ae.get(si).onDidRequestBasicLanguageFeatures((n) => {
      n === s && (i.dispose(), e());
    });
    return i;
  });
}
function sce(s, e) {
  if (!Ae.get(si).isRegisteredLanguageId(s))
    throw new Error(`Cannot set configuration for unknown language ${s}`);
  return Ae.get(tn).register(s, e, 100);
}
class oce {
  constructor(e, t) {
    this._languageId = e, this._actual = t;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  tokenize(e, t, i) {
    if (typeof this._actual.tokenize == "function")
      return p_.adaptTokenize(this._languageId, this._actual, e, i);
    throw new Error("Not supported!");
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenizeEncoded(e, i);
    return new A0(n.tokens, n.endState);
  }
}
class p_ {
  constructor(e, t, i, n) {
    this._languageId = e, this._actual = t, this._languageService = i, this._standaloneThemeService = n;
  }
  dispose() {
  }
  getInitialState() {
    return this._actual.getInitialState();
  }
  static _toClassicTokens(e, t) {
    const i = [];
    let n = 0;
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      let l = a.startIndex;
      o === 0 ? l = 0 : l < n && (l = n), i[o] = new xA(l, a.scopes, t), n = l;
    }
    return i;
  }
  static adaptTokenize(e, t, i, n) {
    const o = t.tokenize(i, n), r = p_._toClassicTokens(o.tokens, e);
    let a;
    return o.endState.equals(n) ? a = n : a = o.endState, new BM(r, a);
  }
  tokenize(e, t, i) {
    return p_.adaptTokenize(this._languageId, this._actual, e, i);
  }
  _toBinaryTokens(e, t) {
    const i = e.encodeLanguageId(this._languageId), n = this._standaloneThemeService.getColorTheme().tokenTheme, o = [];
    let r = 0, a = 0;
    for (let c = 0, d = t.length; c < d; c++) {
      const h = t[c], u = n.match(i, h.scopes) | 1024;
      if (r > 0 && o[r - 1] === u)
        continue;
      let g = h.startIndex;
      c === 0 ? g = 0 : g < a && (g = a), o[r++] = g, o[r++] = u, a = g;
    }
    const l = new Uint32Array(r);
    for (let c = 0; c < r; c++)
      l[c] = o[c];
    return l;
  }
  tokenizeEncoded(e, t, i) {
    const n = this._actual.tokenize(e, i), o = this._toBinaryTokens(this._languageService.languageIdCodec, n.tokens);
    let r;
    return n.endState.equals(i) ? r = i : r = n.endState, new A0(o, r);
  }
}
function rce(s) {
  return typeof s.getInitialState == "function";
}
function ace(s) {
  return "tokenizeEncoded" in s;
}
function nV(s) {
  return s && typeof s.then == "function";
}
function lce(s) {
  const e = Ae.get(cr);
  if (s) {
    const t = [null];
    for (let i = 1, n = s.length; i < n; i++)
      t[i] = Y.fromHex(s[i]);
    e.setColorMapOverride(t);
  } else
    e.setColorMapOverride(null);
}
function sV(s, e) {
  return ace(e) ? new oce(s, e) : new p_(s, e, Ae.get(si), Ae.get(cr));
}
function eB(s, e) {
  const t = new S7(async () => {
    const i = await Promise.resolve(e.create());
    return i ? rce(i) ? sV(s, i) : new a_(Ae.get(si), Ae.get(cr), s, iV(s, i), Ae.get(ht)) : null;
  });
  return ci.registerFactory(s, t);
}
function cce(s, e) {
  if (!Ae.get(si).isRegisteredLanguageId(s))
    throw new Error(`Cannot set tokens provider for unknown language ${s}`);
  return nV(e) ? eB(s, { create: () => e }) : ci.register(s, sV(s, e));
}
function dce(s, e) {
  const t = (i) => new a_(Ae.get(si), Ae.get(cr), s, iV(s, i), Ae.get(ht));
  return nV(e) ? eB(s, { create: () => e }) : ci.register(s, t(e));
}
function hce(s, e) {
  return Ae.get(ye).referenceProvider.register(s, e);
}
function uce(s, e) {
  return Ae.get(ye).renameProvider.register(s, e);
}
function gce(s, e) {
  return Ae.get(ye).newSymbolNamesProvider.register(s, e);
}
function fce(s, e) {
  return Ae.get(ye).signatureHelpProvider.register(s, e);
}
function mce(s, e) {
  return Ae.get(ye).hoverProvider.register(s, {
    provideHover: async (i, n, o, r) => {
      const a = i.getWordAtPosition(n);
      return Promise.resolve(e.provideHover(i, n, o, r)).then((l) => {
        if (l)
          return !l.range && a && (l.range = new E(n.lineNumber, a.startColumn, n.lineNumber, a.endColumn)), l.range || (l.range = new E(n.lineNumber, n.column, n.lineNumber, n.column)), l;
      });
    }
  });
}
function pce(s, e) {
  return Ae.get(ye).documentSymbolProvider.register(s, e);
}
function Ace(s, e) {
  return Ae.get(ye).documentHighlightProvider.register(s, e);
}
function _ce(s, e) {
  return Ae.get(ye).linkedEditingRangeProvider.register(s, e);
}
function bce(s, e) {
  return Ae.get(ye).definitionProvider.register(s, e);
}
function wce(s, e) {
  return Ae.get(ye).implementationProvider.register(s, e);
}
function Cce(s, e) {
  return Ae.get(ye).typeDefinitionProvider.register(s, e);
}
function vce(s, e) {
  return Ae.get(ye).codeLensProvider.register(s, e);
}
function Sce(s, e, t) {
  return Ae.get(ye).codeActionProvider.register(s, {
    providedCodeActionKinds: t?.providedCodeActionKinds,
    documentation: t?.documentation,
    provideCodeActions: (n, o, r, a) => {
      const c = Ae.get(Pa).read({ resource: n.uri }).filter((d) => E.areIntersectingOrTouching(d, o));
      return e.provideCodeActions(n, o, { markers: c, only: r.only, trigger: r.trigger }, a);
    },
    resolveCodeAction: e.resolveCodeAction
  });
}
function yce(s, e) {
  return Ae.get(ye).documentFormattingEditProvider.register(s, e);
}
function xce(s, e) {
  return Ae.get(ye).documentRangeFormattingEditProvider.register(s, e);
}
function Ece(s, e) {
  return Ae.get(ye).onTypeFormattingEditProvider.register(s, e);
}
function Lce(s, e) {
  return Ae.get(ye).linkProvider.register(s, e);
}
function kce(s, e) {
  return Ae.get(ye).completionProvider.register(s, e);
}
function Dce(s, e) {
  return Ae.get(ye).colorProvider.register(s, e);
}
function Ice(s, e) {
  return Ae.get(ye).foldingRangeProvider.register(s, e);
}
function Mce(s, e) {
  return Ae.get(ye).declarationProvider.register(s, e);
}
function Nce(s, e) {
  return Ae.get(ye).selectionRangeProvider.register(s, e);
}
function Tce(s, e) {
  return Ae.get(ye).documentSemanticTokensProvider.register(s, e);
}
function Bce(s, e) {
  return Ae.get(ye).documentRangeSemanticTokensProvider.register(s, e);
}
function Rce(s, e) {
  return Ae.get(ye).inlineCompletionsProvider.register(s, e);
}
function Fce(s, e) {
  return Ae.get(ye).inlineEditProvider.register(s, e);
}
function Oce(s, e) {
  return Ae.get(ye).inlayHintsProvider.register(s, e);
}
function Pce() {
  return {
    register: Zle,
    getLanguages: ece,
    onLanguage: ice,
    onLanguageEncountered: nce,
    getEncodedLanguageId: tce,
    // provider methods
    setLanguageConfiguration: sce,
    setColorMap: lce,
    registerTokensProviderFactory: eB,
    setTokensProvider: cce,
    setMonarchTokensProvider: dce,
    registerReferenceProvider: hce,
    registerRenameProvider: uce,
    registerNewSymbolNameProvider: gce,
    registerCompletionItemProvider: kce,
    registerSignatureHelpProvider: fce,
    registerHoverProvider: mce,
    registerDocumentSymbolProvider: pce,
    registerDocumentHighlightProvider: Ace,
    registerLinkedEditingRangeProvider: _ce,
    registerDefinitionProvider: bce,
    registerImplementationProvider: wce,
    registerTypeDefinitionProvider: Cce,
    registerCodeLensProvider: vce,
    registerCodeActionProvider: Sce,
    registerDocumentFormattingEditProvider: yce,
    registerDocumentRangeFormattingEditProvider: xce,
    registerOnTypeFormattingEditProvider: Ece,
    registerLinkProvider: Lce,
    registerColorProvider: Dce,
    registerFoldingRangeProvider: Ice,
    registerDeclarationProvider: Mce,
    registerSelectionRangeProvider: Nce,
    registerDocumentSemanticTokensProvider: Tce,
    registerDocumentRangeSemanticTokensProvider: Bce,
    registerInlineCompletionsProvider: Rce,
    registerInlineEditProvider: Fce,
    registerInlayHintsProvider: Oce,
    // enums
    DocumentHighlightKind: Kx,
    CompletionItemKind: zx,
    CompletionItemTag: Ux,
    CompletionItemInsertTextRule: Vx,
    SymbolKind: xE,
    SymbolTag: EE,
    IndentAction: tE,
    CompletionTriggerKind: Qx,
    SignatureHelpTriggerKind: yE,
    InlayHintKind: nE,
    InlineCompletionTriggerKind: sE,
    InlineEditTriggerKind: oE,
    CodeActionTriggerType: Wx,
    NewSymbolNameTag: uE,
    NewSymbolNameTriggerKind: gE,
    PartialAcceptTriggerKind: pE,
    HoverVerbosityAction: eE,
    // classes
    FoldingRangeKind: nd,
    SelectedSuggestionInfo: C7
  };
}
const tB = We("IEditorCancelService"), oV = new le("cancellableOperation", !1, f("cancellableOperation", "Whether the editor runs a cancellable operation, e.g. like 'Peek References'"));
$e(
  tB,
  class {
    constructor() {
      this._tokens = /* @__PURE__ */ new WeakMap();
    }
    add(s, e) {
      let t = this._tokens.get(s);
      t || (t = s.invokeWithinContext((n) => {
        const o = oV.bindTo(n.get(Se)), r = new Nn();
        return { key: o, tokens: r };
      }), this._tokens.set(s, t));
      let i;
      return t.key.set(!0), i = t.tokens.push(e), () => {
        i && (i(), t.key.set(!t.tokens.isEmpty()), i = void 0);
      };
    }
    cancel(s) {
      const e = this._tokens.get(s);
      if (!e)
        return;
      const t = e.tokens.pop();
      t && (t.cancel(), e.key.set(!e.tokens.isEmpty()));
    }
  },
  1
  /* InstantiationType.Delayed */
);
class Hce extends vs {
  constructor(e, t) {
    super(t), this.editor = e, this._unregister = e.invokeWithinContext((i) => i.get(tB).add(e, this));
  }
  dispose() {
    this._unregister(), super.dispose();
  }
}
re(new class extends Wn {
  constructor() {
    super({
      id: "editor.cancelOperation",
      kbOpts: {
        weight: 100,
        primary: 9
        /* KeyCode.Escape */
      },
      precondition: oV
    });
  }
  runEditorCommand(s, e) {
    s.get(tB).cancel(e);
  }
}());
let Wce = class iI {
  constructor(e, t) {
    if (this.flags = t, this.flags & 1) {
      const i = e.getModel();
      this.modelVersionId = i ? Vf("{0}#{1}", i.uri.toString(), i.getVersionId()) : null;
    } else
      this.modelVersionId = null;
    this.flags & 4 ? this.position = e.getPosition() : this.position = null, this.flags & 2 ? this.selection = e.getSelection() : this.selection = null, this.flags & 8 ? (this.scrollLeft = e.getScrollLeft(), this.scrollTop = e.getScrollTop()) : (this.scrollLeft = -1, this.scrollTop = -1);
  }
  _equals(e) {
    if (!(e instanceof iI))
      return !1;
    const t = e;
    return !(this.modelVersionId !== t.modelVersionId || this.scrollLeft !== t.scrollLeft || this.scrollTop !== t.scrollTop || !this.position && t.position || this.position && !t.position || this.position && t.position && !this.position.equals(t.position) || !this.selection && t.selection || this.selection && !t.selection || this.selection && t.selection && !this.selection.equalsRange(t.selection));
  }
  validate(e) {
    return this._equals(new iI(e, this.flags));
  }
};
class Vce extends Hce {
  constructor(e, t, i, n) {
    super(e, n), this._listener = new X(), t & 4 && this._listener.add(e.onDidChangeCursorPosition((o) => {
      (!i || !E.containsPosition(i, o.position)) && this.cancel();
    })), t & 2 && this._listener.add(e.onDidChangeCursorSelection((o) => {
      (!i || !E.containsRange(i, o.selection)) && this.cancel();
    })), t & 8 && this._listener.add(e.onDidScrollChange((o) => this.cancel())), t & 1 && (this._listener.add(e.onDidChangeModel((o) => this.cancel())), this._listener.add(e.onDidChangeModelContent((o) => this.cancel())));
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
class zce extends vs {
  constructor(e, t) {
    super(t), this._listener = e.onDidChangeContent(() => this.cancel());
  }
  dispose() {
    this._listener.dispose(), super.dispose();
  }
}
function rV(s) {
  return s && typeof s.getEditorType == "function" ? s.getEditorType() === wS.ICodeEditor : !1;
}
class IP {
  constructor(e) {
    this.value = e, this._lower = e.toLowerCase();
  }
  /**
   * Gives the value by which to index (for equality).
   */
  static toKey(e) {
    return typeof e == "string" ? e.toLowerCase() : e._lower;
  }
}
class Uce {
  constructor(e) {
    if (this._set = /* @__PURE__ */ new Set(), e)
      for (const t of e)
        this.add(t);
  }
  add(e) {
    this._set.add(IP.toKey(e));
  }
  has(e) {
    return this._set.has(IP.toKey(e));
  }
}
function Qce(s, e, t) {
  const i = [], n = new Uce(), o = s.ordered(t);
  for (const a of o)
    i.push(a), a.extensionId && n.add(a.extensionId);
  const r = e.ordered(t);
  for (const a of r) {
    if (a.extensionId) {
      if (n.has(a.extensionId))
        continue;
      n.add(a.extensionId);
    }
    i.push({
      displayName: a.displayName,
      extensionId: a.extensionId,
      provideDocumentFormattingEdits(l, c, d) {
        return a.provideDocumentRangeFormattingEdits(l, l.getFullModelRange(), c, d);
      }
    });
  }
  return i;
}
const wA = class wA {
  static setFormatterSelector(e) {
    return { dispose: wA._selectors.unshift(e) };
  }
  static async select(e, t, i, n) {
    if (e.length === 0)
      return;
    const o = nt.first(wA._selectors);
    if (o)
      return await o(e, t, i, n);
  }
};
wA._selectors = new Nn();
let nI = wA;
async function Gce(s, e, t, i, n, o) {
  const r = e.documentRangeFormattingEditProvider.ordered(t);
  for (const a of r) {
    const l = await Promise.resolve(a.provideDocumentRangeFormattingEdits(t, i, n, o)).catch(xs);
    if (Ys(l))
      return await s.computeMoreMinimalEdits(t.uri, l);
  }
}
async function jce(s, e, t, i, n) {
  const o = Qce(e.documentFormattingEditProvider, e.documentRangeFormattingEditProvider, t);
  for (const r of o) {
    const a = await Promise.resolve(r.provideDocumentFormattingEdits(t, i, n)).catch(xs);
    if (Ys(a))
      return await s.computeMoreMinimalEdits(t.uri, a);
  }
}
function Yce(s, e, t, i, n, o, r) {
  const a = e.onTypeFormattingEditProvider.ordered(t);
  return a.length === 0 || a[0].autoFormatTriggerCharacters.indexOf(n) < 0 ? Promise.resolve(void 0) : Promise.resolve(a[0].provideOnTypeFormattingEdits(t, i, n, o, r)).catch(xs).then((l) => s.computeMoreMinimalEdits(t.uri, l));
}
mt.registerCommand("_executeFormatRangeProvider", async function(s, ...e) {
  const [t, i, n] = e;
  jt(_e.isUri(t)), jt(E.isIRange(i));
  const o = s.get(Zs), r = s.get(Sd), a = s.get(ye), l = await o.createModelReference(t);
  try {
    return Gce(r, a, l.object.textEditorModel, E.lift(i), n, ct.None);
  } finally {
    l.dispose();
  }
});
mt.registerCommand("_executeFormatDocumentProvider", async function(s, ...e) {
  const [t, i] = e;
  jt(_e.isUri(t));
  const n = s.get(Zs), o = s.get(Sd), r = s.get(ye), a = await n.createModelReference(t);
  try {
    return jce(o, r, a.object.textEditorModel, i, ct.None);
  } finally {
    a.dispose();
  }
});
mt.registerCommand("_executeFormatOnTypeProvider", async function(s, ...e) {
  const [t, i, n, o] = e;
  jt(_e.isUri(t)), jt(F.isIPosition(i)), jt(typeof n == "string");
  const r = s.get(Zs), a = s.get(Sd), l = s.get(ye), c = await r.createModelReference(t);
  try {
    return Yce(a, l, c.object.textEditorModel, F.lift(i), n, o, ct.None);
  } finally {
    c.dispose();
  }
});
Hr.wrappingIndent.defaultValue = 0;
Hr.glyphMargin.defaultValue = !1;
Hr.autoIndent.defaultValue = 3;
Hr.overviewRulerLanes.defaultValue = 2;
nI.setFormatterSelector((s, e, t) => Promise.resolve(s[0]));
const Un = mH();
Un.editor = Yle();
Un.languages = Pce();
const Kce = Un.CancellationTokenSource, Jce = Un.Emitter, qce = Un.KeyCode, $ce = Un.KeyMod, Xce = Un.Position, Zce = Un.Range, ede = Un.Selection, tde = Un.SelectionDirection, ide = Un.MarkerSeverity, nde = Un.MarkerTag, sde = Un.Uri, ode = Un.Token, rde = Un.editor, ade = Un.languages, lde = globalThis.MonacoEnvironment;
(lde?.globalAPI || typeof define == "function" && define.amd) && (globalThis.monaco = Un);
typeof globalThis.require < "u" && typeof globalThis.require.config == "function" && globalThis.require.config({
  ignoreDuplicateModules: [
    "vscode-languageserver-types",
    "vscode-languageserver-types/main",
    "vscode-languageserver-textdocument",
    "vscode-languageserver-textdocument/main",
    "vscode-nls",
    "vscode-nls/vscode-nls",
    "jsonc-parser",
    "jsonc-parser/main",
    "vscode-uri",
    "vscode-uri/index",
    "vs/basic-languages/typescript/typescript"
  ]
});
const UAe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CancellationTokenSource: Kce,
  Emitter: Jce,
  KeyCode: qce,
  KeyMod: $ce,
  MarkerSeverity: ide,
  MarkerTag: nde,
  Position: Xce,
  Range: Zce,
  Selection: ede,
  SelectionDirection: tde,
  Token: ode,
  Uri: sde,
  editor: rde,
  languages: ade
}, Symbol.toStringTag, { value: "Module" })), aV = "editor.action.showHover", cde = "editor.action.showDefinitionPreviewHover", dde = "editor.action.scrollUpHover", hde = "editor.action.scrollDownHover", ude = "editor.action.scrollLeftHover", gde = "editor.action.scrollRightHover", fde = "editor.action.pageUpHover", mde = "editor.action.pageDownHover", pde = "editor.action.goToTopHover", Ade = "editor.action.goToBottomHover", ES = "editor.action.increaseHoverVerbosityLevel", _de = f({ key: "increaseHoverVerbosityLevel", comment: ["Label for action that will increase the hover verbosity level."] }, "Increase Hover Verbosity Level"), LS = "editor.action.decreaseHoverVerbosityLevel", bde = f({ key: "decreaseHoverVerbosityLevel", comment: ["Label for action that will decrease the hover verbosity level."] }, "Decrease Hover Verbosity Level");
function sI(s, e) {
  return !!s[e];
}
class dx {
  constructor(e, t) {
    this.target = e.target, this.isLeftClick = e.event.leftButton, this.isMiddleClick = e.event.middleButton, this.isRightClick = e.event.rightButton, this.hasTriggerModifier = sI(e.event, t.triggerModifier), this.hasSideBySideModifier = sI(e.event, t.triggerSideBySideModifier), this.isNoneOrSingleMouseDown = e.event.detail <= 1;
  }
}
class MP {
  constructor(e, t) {
    this.keyCodeIsTriggerKey = e.keyCode === t.triggerKey, this.keyCodeIsSideBySideKey = e.keyCode === t.triggerSideBySideKey, this.hasTriggerModifier = sI(e, t.triggerModifier);
  }
}
class Jb {
  constructor(e, t, i, n) {
    this.triggerKey = e, this.triggerModifier = t, this.triggerSideBySideKey = i, this.triggerSideBySideModifier = n;
  }
  equals(e) {
    return this.triggerKey === e.triggerKey && this.triggerModifier === e.triggerModifier && this.triggerSideBySideKey === e.triggerSideBySideKey && this.triggerSideBySideModifier === e.triggerSideBySideModifier;
  }
}
function NP(s) {
  return s === "altKey" ? ze ? new Jb(57, "metaKey", 6, "altKey") : new Jb(5, "ctrlKey", 6, "altKey") : ze ? new Jb(6, "altKey", 57, "metaKey") : new Jb(6, "altKey", 5, "ctrlKey");
}
class lV extends V {
  constructor(e, t) {
    super(), this._onMouseMoveOrRelevantKeyDown = this._register(new B()), this.onMouseMoveOrRelevantKeyDown = this._onMouseMoveOrRelevantKeyDown.event, this._onExecute = this._register(new B()), this.onExecute = this._onExecute.event, this._onCancel = this._register(new B()), this.onCancel = this._onCancel.event, this._editor = e, this._extractLineNumberFromMouseEvent = t?.extractLineNumberFromMouseEvent ?? ((i) => i.target.position ? i.target.position.lineNumber : 0), this._opts = NP(this._editor.getOption(
      78
      /* EditorOption.multiCursorModifier */
    )), this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._register(this._editor.onDidChangeConfiguration((i) => {
      if (i.hasChanged(
        78
        /* EditorOption.multiCursorModifier */
      )) {
        const n = NP(this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ));
        if (this._opts.equals(n))
          return;
        this._opts = n, this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._lineNumberOnMouseDown = 0, this._onCancel.fire();
      }
    })), this._register(this._editor.onMouseMove((i) => this._onEditorMouseMove(new dx(i, this._opts)))), this._register(this._editor.onMouseDown((i) => this._onEditorMouseDown(new dx(i, this._opts)))), this._register(this._editor.onMouseUp((i) => this._onEditorMouseUp(new dx(i, this._opts)))), this._register(this._editor.onKeyDown((i) => this._onEditorKeyDown(new MP(i, this._opts)))), this._register(this._editor.onKeyUp((i) => this._onEditorKeyUp(new MP(i, this._opts)))), this._register(this._editor.onMouseDrag(() => this._resetHandler())), this._register(this._editor.onDidChangeCursorSelection((i) => this._onDidChangeCursorSelection(i))), this._register(this._editor.onDidChangeModel((i) => this._resetHandler())), this._register(this._editor.onDidChangeModelContent(() => this._resetHandler())), this._register(this._editor.onDidScrollChange((i) => {
      (i.scrollTopChanged || i.scrollLeftChanged) && this._resetHandler();
    }));
  }
  _onDidChangeCursorSelection(e) {
    e.selection && e.selection.startColumn !== e.selection.endColumn && this._resetHandler();
  }
  _onEditorMouseMove(e) {
    this._lastMouseMoveEvent = e, this._onMouseMoveOrRelevantKeyDown.fire([e, null]);
  }
  _onEditorMouseDown(e) {
    this._hasTriggerKeyOnMouseDown = e.hasTriggerModifier, this._lineNumberOnMouseDown = this._extractLineNumberFromMouseEvent(e);
  }
  _onEditorMouseUp(e) {
    const t = this._extractLineNumberFromMouseEvent(e);
    this._hasTriggerKeyOnMouseDown && this._lineNumberOnMouseDown && this._lineNumberOnMouseDown === t && this._onExecute.fire(e);
  }
  _onEditorKeyDown(e) {
    this._lastMouseMoveEvent && (e.keyCodeIsTriggerKey || e.keyCodeIsSideBySideKey && e.hasTriggerModifier) ? this._onMouseMoveOrRelevantKeyDown.fire([this._lastMouseMoveEvent, e]) : e.hasTriggerModifier && this._onCancel.fire();
  }
  _onEditorKeyUp(e) {
    e.keyCodeIsTriggerKey && this._onCancel.fire();
  }
  _resetHandler() {
    this._lastMouseMoveEvent = null, this._hasTriggerKeyOnMouseDown = !1, this._onCancel.fire();
  }
}
var wde = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ja = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ku = class extends u_ {
  constructor(e, t, i, n, o, r, a, l, c, d, h, u, g) {
    super(e, { ...n.getRawOptions(), overflowWidgetsDomNode: n.getOverflowWidgetsDomNode() }, i, o, r, a, l, c, d, h, u, g), this._parentEditor = n, this._overwriteOptions = t, super.updateOptions(this._overwriteOptions), this._register(n.onDidChangeConfiguration((m) => this._onParentConfigurationChanged(m)));
  }
  getParentEditor() {
    return this._parentEditor;
  }
  _onParentConfigurationChanged(e) {
    super.updateOptions(this._parentEditor.getRawOptions()), super.updateOptions(this._overwriteOptions);
  }
  updateOptions(e) {
    m0(this._overwriteOptions, e, !0), super.updateOptions(this._overwriteOptions);
  }
};
ku = wde([
  Ja(4, ke),
  Ja(5, Nt),
  Ja(6, bi),
  Ja(7, Se),
  Ja(8, nn),
  Ja(9, Oi),
  Ja(10, Lo),
  Ja(11, tn),
  Ja(12, ye)
], ku);
const TP = new Y(new qe(0, 122, 204)), Cde = {
  showArrow: !0,
  showFrame: !0,
  className: "",
  frameColor: TP,
  arrowColor: TP,
  keepEditorSelection: !1
}, vde = "vs.editor.contrib.zoneWidget";
class Sde {
  constructor(e, t, i, n, o, r, a, l) {
    this.id = "", this.domNode = e, this.afterLineNumber = t, this.afterColumn = i, this.heightInLines = n, this.showInHiddenAreas = a, this.ordinal = l, this._onDomNodeTop = o, this._onComputedHeight = r;
  }
  onDomNodeTop(e) {
    this._onDomNodeTop(e);
  }
  onComputedHeight(e) {
    this._onComputedHeight(e);
  }
}
class yde {
  constructor(e, t) {
    this._id = e, this._domNode = t;
  }
  getId() {
    return this._id;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return null;
  }
}
const s0 = class s0 {
  constructor(e) {
    this._editor = e, this._ruleName = s0._IdGenerator.nextId(), this._decorations = this._editor.createDecorationsCollection(), this._color = null, this._height = -1;
  }
  dispose() {
    this.hide(), UE(this._ruleName);
  }
  set color(e) {
    this._color !== e && (this._color = e, this._updateStyle());
  }
  set height(e) {
    this._height !== e && (this._height = e, this._updateStyle());
  }
  _updateStyle() {
    UE(this._ruleName), aC(`.monaco-editor ${this._ruleName}`, `border-style: solid; border-color: transparent; border-bottom-color: ${this._color}; border-width: ${this._height}px; bottom: -${this._height}px !important; margin-left: -${this._height}px; `);
  }
  show(e) {
    e.column === 1 && (e = { lineNumber: e.lineNumber, column: 2 }), this._decorations.set([{
      range: E.fromPositions(e),
      options: {
        description: "zone-widget-arrow",
        className: this._ruleName,
        stickiness: 1
        /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
      }
    }]);
  }
  hide() {
    this._decorations.clear();
  }
};
s0._IdGenerator = new MN(".arrow-decoration-");
let oI = s0;
class xde {
  constructor(e, t = {}) {
    this._arrow = null, this._overlayWidget = null, this._resizeSash = null, this._viewZone = null, this._disposables = new X(), this.container = null, this._isShowing = !1, this.editor = e, this._positionMarkerId = this.editor.createDecorationsCollection(), this.options = ll(t), m0(this.options, Cde, !1), this.domNode = document.createElement("div"), this.options.isAccessible || (this.domNode.setAttribute("aria-hidden", "true"), this.domNode.setAttribute("role", "presentation")), this._disposables.add(this.editor.onDidLayoutChange((i) => {
      const n = this._getWidth(i);
      this.domNode.style.width = n + "px", this.domNode.style.left = this._getLeft(i) + "px", this._onWidth(n);
    }));
  }
  dispose() {
    this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._viewZone && this.editor.changeViewZones((e) => {
      this._viewZone && e.removeZone(this._viewZone.id), this._viewZone = null;
    }), this._positionMarkerId.clear(), this._disposables.dispose();
  }
  create() {
    this.domNode.classList.add("zone-widget"), this.options.className && this.domNode.classList.add(this.options.className), this.container = document.createElement("div"), this.container.classList.add("zone-widget-container"), this.domNode.appendChild(this.container), this.options.showArrow && (this._arrow = new oI(this.editor), this._disposables.add(this._arrow)), this._fillContainer(this.container), this._initSash(), this._applyStyles();
  }
  style(e) {
    e.frameColor && (this.options.frameColor = e.frameColor), e.arrowColor && (this.options.arrowColor = e.arrowColor), this._applyStyles();
  }
  _applyStyles() {
    if (this.container && this.options.frameColor) {
      const e = this.options.frameColor.toString();
      this.container.style.borderTopColor = e, this.container.style.borderBottomColor = e;
    }
    if (this._arrow && this.options.arrowColor) {
      const e = this.options.arrowColor.toString();
      this._arrow.color = e;
    }
  }
  _getWidth(e) {
    return e.width - e.minimap.minimapWidth - e.verticalScrollbarWidth;
  }
  _getLeft(e) {
    return e.minimap.minimapWidth > 0 && e.minimap.minimapLeft === 0 ? e.minimap.minimapWidth : 0;
  }
  _onViewZoneTop(e) {
    this.domNode.style.top = e + "px";
  }
  _onViewZoneHeight(e) {
    if (this.domNode.style.height = `${e}px`, this.container) {
      const t = e - this._decoratingElementsHeight();
      this.container.style.height = `${t}px`;
      const i = this.editor.getLayoutInfo();
      this._doLayout(t, this._getWidth(i));
    }
    this._resizeSash?.layout();
  }
  get position() {
    const e = this._positionMarkerId.getRange(0);
    if (e)
      return e.getStartPosition();
  }
  show(e, t) {
    const i = E.isIRange(e) ? E.lift(e) : E.fromPositions(e);
    this._isShowing = !0, this._showImpl(i, t), this._isShowing = !1, this._positionMarkerId.set([{ range: i, options: He.EMPTY }]);
  }
  hide() {
    this._viewZone && (this.editor.changeViewZones((e) => {
      this._viewZone && e.removeZone(this._viewZone.id);
    }), this._viewZone = null), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this._arrow?.hide(), this._positionMarkerId.clear();
  }
  _decoratingElementsHeight() {
    const e = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    let t = 0;
    if (this.options.showArrow) {
      const i = Math.round(e / 3);
      t += 2 * i;
    }
    if (this.options.showFrame) {
      const i = Math.round(e / 9);
      t += 2 * i;
    }
    return t;
  }
  _showImpl(e, t) {
    const i = e.getStartPosition(), n = this.editor.getLayoutInfo(), o = this._getWidth(n);
    this.domNode.style.width = `${o}px`, this.domNode.style.left = this._getLeft(n) + "px";
    const r = document.createElement("div");
    r.style.overflow = "hidden";
    const a = this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    );
    if (!this.options.allowUnlimitedHeight) {
      const u = Math.max(12, this.editor.getLayoutInfo().height / a * 0.8);
      t = Math.min(t, u);
    }
    let l = 0, c = 0;
    if (this._arrow && this.options.showArrow && (l = Math.round(a / 3), this._arrow.height = l, this._arrow.show(i)), this.options.showFrame && (c = Math.round(a / 9)), this.editor.changeViewZones((u) => {
      this._viewZone && u.removeZone(this._viewZone.id), this._overlayWidget && (this.editor.removeOverlayWidget(this._overlayWidget), this._overlayWidget = null), this.domNode.style.top = "-1000px", this._viewZone = new Sde(r, i.lineNumber, i.column, t, (g) => this._onViewZoneTop(g), (g) => this._onViewZoneHeight(g), this.options.showInHiddenAreas, this.options.ordinal), this._viewZone.id = u.addZone(this._viewZone), this._overlayWidget = new yde(vde + this._viewZone.id, this.domNode), this.editor.addOverlayWidget(this._overlayWidget);
    }), this.container && this.options.showFrame) {
      const u = this.options.frameWidth ? this.options.frameWidth : c;
      this.container.style.borderTopWidth = u + "px", this.container.style.borderBottomWidth = u + "px";
    }
    const d = t * a - this._decoratingElementsHeight();
    this.container && (this.container.style.top = l + "px", this.container.style.height = d + "px", this.container.style.overflow = "hidden"), this._doLayout(d, o), this.options.keepEditorSelection || this.editor.setSelection(e);
    const h = this.editor.getModel();
    if (h) {
      const u = h.validateRange(new E(e.startLineNumber, 1, e.endLineNumber + 1, 1));
      this.revealRange(u, u.startLineNumber === h.getLineCount());
    }
  }
  revealRange(e, t) {
    t ? this.editor.revealLineNearTop(
      e.endLineNumber,
      0
      /* ScrollType.Smooth */
    ) : this.editor.revealRange(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  setCssClass(e, t) {
    this.container && (t && this.container.classList.remove(t), this.container.classList.add(e));
  }
  _onWidth(e) {
  }
  _doLayout(e, t) {
  }
  _relayout(e) {
    this._viewZone && this._viewZone.heightInLines !== e && this.editor.changeViewZones((t) => {
      this._viewZone && (this._viewZone.heightInLines = e, t.layoutZone(this._viewZone.id));
    });
  }
  // --- sash
  _initSash() {
    if (this._resizeSash)
      return;
    this._resizeSash = this._disposables.add(new rn(this.domNode, this, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    })), this.options.isResizeable || (this._resizeSash.state = 0);
    let e;
    this._disposables.add(this._resizeSash.onDidStart((t) => {
      this._viewZone && (e = {
        startY: t.startY,
        heightInLines: this._viewZone.heightInLines
      });
    })), this._disposables.add(this._resizeSash.onDidEnd(() => {
      e = void 0;
    })), this._disposables.add(this._resizeSash.onDidChange((t) => {
      if (e) {
        const i = (t.currentY - e.startY) / this.editor.getOption(
          67
          /* EditorOption.lineHeight */
        ), n = i < 0 ? Math.ceil(i) : Math.floor(i), o = e.heightInLines + n;
        o > 5 && o < 35 && this._relayout(o);
      }
    }));
  }
  getHorizontalSashLeft() {
    return 0;
  }
  getHorizontalSashTop() {
    return (this.domNode.style.height === null ? 0 : parseInt(this.domNode.style.height)) - this._decoratingElementsHeight() / 2;
  }
  getHorizontalSashWidth() {
    const e = this.editor.getLayoutInfo();
    return e.width - e.minimap.minimapWidth;
  }
}
var cV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, dV = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const hV = We("IPeekViewService");
$e(
  hV,
  class {
    constructor() {
      this._widgets = /* @__PURE__ */ new Map();
    }
    addExclusiveWidget(s, e) {
      const t = this._widgets.get(s);
      t && (t.listener.dispose(), t.widget.dispose());
      const i = () => {
        const n = this._widgets.get(s);
        n && n.widget === e && (n.listener.dispose(), this._widgets.delete(s));
      };
      this._widgets.set(s, { widget: e, listener: e.onDidClose(i) });
    }
  },
  1
  /* InstantiationType.Delayed */
);
var ns;
(function(s) {
  s.inPeekEditor = new le("inReferenceSearchEditor", !0, f("inReferenceSearchEditor", "Whether the current code editor is embedded inside peek")), s.notInPeekEditor = s.inPeekEditor.toNegated();
})(ns || (ns = {}));
var Ff;
let zv = (Ff = class {
  constructor(e, t) {
    e instanceof ku && ns.inPeekEditor.bindTo(t);
  }
  dispose() {
  }
}, Ff.ID = "editor.contrib.referenceController", Ff);
zv = cV([
  dV(1, Se)
], zv);
rs(
  zv.ID,
  zv,
  0
  /* EditorContributionInstantiation.Eager */
);
function Ede(s) {
  const e = s.get(Nt).getFocusedCodeEditor();
  return e instanceof ku ? e.getParentEditor() : e;
}
const Lde = {
  headerBackgroundColor: Y.white,
  primaryHeadingColor: Y.fromHex("#333333"),
  secondaryHeadingColor: Y.fromHex("#6c6c6cb3")
};
let Uv = class extends xde {
  constructor(e, t, i) {
    super(e, t), this.instantiationService = i, this._onDidClose = new B(), this.onDidClose = this._onDidClose.event, m0(this.options, Lde, !1);
  }
  dispose() {
    this.disposed || (this.disposed = !0, super.dispose(), this._onDidClose.fire(this));
  }
  style(e) {
    const t = this.options;
    e.headerBackgroundColor && (t.headerBackgroundColor = e.headerBackgroundColor), e.primaryHeadingColor && (t.primaryHeadingColor = e.primaryHeadingColor), e.secondaryHeadingColor && (t.secondaryHeadingColor = e.secondaryHeadingColor), super.style(e);
  }
  _applyStyles() {
    super._applyStyles();
    const e = this.options;
    this._headElement && e.headerBackgroundColor && (this._headElement.style.backgroundColor = e.headerBackgroundColor.toString()), this._primaryHeading && e.primaryHeadingColor && (this._primaryHeading.style.color = e.primaryHeadingColor.toString()), this._secondaryHeading && e.secondaryHeadingColor && (this._secondaryHeading.style.color = e.secondaryHeadingColor.toString()), this._bodyElement && e.frameColor && (this._bodyElement.style.borderColor = e.frameColor.toString());
  }
  _fillContainer(e) {
    this.setCssClass("peekview-widget"), this._headElement = de(".head"), this._bodyElement = de(".body"), this._fillHead(this._headElement), this._fillBody(this._bodyElement), e.appendChild(this._headElement), e.appendChild(this._bodyElement);
  }
  _fillHead(e, t) {
    this._titleElement = de(".peekview-title"), this.options.supportOnTitleClick && (this._titleElement.classList.add("clickable"), Xt(this._titleElement, "click", (o) => this._onTitleClick(o))), K(this._headElement, this._titleElement), this._fillTitleIcon(this._titleElement), this._primaryHeading = de("span.filename"), this._secondaryHeading = de("span.dirname"), this._metaHeading = de("span.meta"), K(this._titleElement, this._primaryHeading, this._secondaryHeading, this._metaHeading);
    const i = de(".peekview-actions");
    K(this._headElement, i);
    const n = this._getActionBarOptions();
    this._actionbarWidget = new wo(i, n), this._disposables.add(this._actionbarWidget), t || this._actionbarWidget.push(new Ks("peekview.close", f("label.close", "Close"), pe.asClassName(Z.close), !0, () => (this.dispose(), Promise.resolve())), { label: !1, icon: !0 });
  }
  _fillTitleIcon(e) {
  }
  _getActionBarOptions() {
    return {
      actionViewItemProvider: J3.bind(void 0, this.instantiationService),
      orientation: 0
      /* ActionsOrientation.HORIZONTAL */
    };
  }
  _onTitleClick(e) {
  }
  setTitle(e, t) {
    this._primaryHeading && this._secondaryHeading && (this._primaryHeading.innerText = e, this._primaryHeading.setAttribute("title", e), t ? this._secondaryHeading.innerText = t : Bn(this._secondaryHeading));
  }
  setMetaTitle(e) {
    this._metaHeading && (e ? (this._metaHeading.innerText = e, ps(this._metaHeading)) : Dn(this._metaHeading));
  }
  _doLayout(e, t) {
    if (!this._isShowing && e < 0) {
      this.dispose();
      return;
    }
    const i = Math.ceil(this.editor.getOption(
      67
      /* EditorOption.lineHeight */
    ) * 1.2), n = Math.round(e - (i + 2));
    this._doLayoutHead(i, t), this._doLayoutBody(n, t);
  }
  _doLayoutHead(e, t) {
    this._headElement && (this._headElement.style.height = `${e}px`, this._headElement.style.lineHeight = this._headElement.style.height);
  }
  _doLayoutBody(e, t) {
    this._bodyElement && (this._bodyElement.style.height = `${e}px`);
  }
};
Uv = cV([
  dV(2, ke)
], Uv);
const kde = L("peekViewTitle.background", { dark: "#252526", light: "#F3F3F3", hcDark: Y.black, hcLight: Y.white }, f("peekViewTitleBackground", "Background color of the peek view title area.")), uV = L("peekViewTitleLabel.foreground", { dark: Y.white, light: Y.black, hcDark: Y.white, hcLight: Fa }, f("peekViewTitleForeground", "Color of the peek view title.")), gV = L("peekViewTitleDescription.foreground", { dark: "#ccccccb3", light: "#616161", hcDark: "#FFFFFF99", hcLight: "#292929" }, f("peekViewTitleInfoForeground", "Color of the peek view title info.")), Dde = L("peekView.border", { dark: Da, light: Da, hcDark: Je, hcLight: Je }, f("peekViewBorder", "Color of the peek view borders and arrow.")), Ide = L("peekViewResult.background", { dark: "#252526", light: "#F3F3F3", hcDark: Y.black, hcLight: Y.white }, f("peekViewResultsBackground", "Background color of the peek view result list."));
L("peekViewResult.lineForeground", { dark: "#bbbbbb", light: "#646465", hcDark: Y.white, hcLight: Fa }, f("peekViewResultsMatchForeground", "Foreground color for line nodes in the peek view result list."));
L("peekViewResult.fileForeground", { dark: Y.white, light: "#1E1E1E", hcDark: Y.white, hcLight: Fa }, f("peekViewResultsFileForeground", "Foreground color for file nodes in the peek view result list."));
L("peekViewResult.selectionBackground", { dark: "#3399ff33", light: "#3399ff33", hcDark: null, hcLight: null }, f("peekViewResultsSelectionBackground", "Background color of the selected entry in the peek view result list."));
L("peekViewResult.selectionForeground", { dark: Y.white, light: "#6C6C6C", hcDark: Y.white, hcLight: Fa }, f("peekViewResultsSelectionForeground", "Foreground color of the selected entry in the peek view result list."));
const fV = L("peekViewEditor.background", { dark: "#001F33", light: "#F2F8FC", hcDark: Y.black, hcLight: Y.white }, f("peekViewEditorBackground", "Background color of the peek view editor."));
L("peekViewEditorGutter.background", fV, f("peekViewEditorGutterBackground", "Background color of the gutter in the peek view editor."));
L("peekViewEditorStickyScroll.background", fV, f("peekViewEditorStickScrollBackground", "Background color of sticky scroll in the peek view editor."));
L("peekViewResult.matchHighlightBackground", { dark: "#ea5c004d", light: "#ea5c004d", hcDark: null, hcLight: null }, f("peekViewResultsMatchHighlight", "Match highlight color in the peek view result list."));
L("peekViewEditor.matchHighlightBackground", { dark: "#ff8f0099", light: "#f5d802de", hcDark: null, hcLight: null }, f("peekViewEditorMatchHighlight", "Match highlight color in the peek view editor."));
L("peekViewEditor.matchHighlightBorder", { dark: null, light: null, hcDark: Kt, hcLight: Kt }, f("peekViewEditorMatchHighlightBorder", "Match highlight border in the peek view editor."));
class md {
  constructor(e, t, i, n) {
    this.isProviderFirst = e, this.parent = t, this.link = i, this._rangeCallback = n, this.id = NL.nextId();
  }
  get uri() {
    return this.link.uri;
  }
  get range() {
    return this._range ?? this.link.targetSelectionRange ?? this.link.range;
  }
  set range(e) {
    this._range = e, this._rangeCallback(this);
  }
  get ariaMessage() {
    const e = this.parent.getPreview(this)?.preview(this.range);
    return e ? f({ key: "aria.oneReference.preview", comment: ["Placeholders are: 0: filename, 1:line number, 2: column number, 3: preview snippet of source code"] }, "{0} in {1} on line {2} at column {3}", e.value, Xo(this.uri), this.range.startLineNumber, this.range.startColumn) : f("aria.oneReference", "in {0} on line {1} at column {2}", Xo(this.uri), this.range.startLineNumber, this.range.startColumn);
  }
}
class Mde {
  constructor(e) {
    this._modelReference = e;
  }
  dispose() {
    this._modelReference.dispose();
  }
  preview(e, t = 8) {
    const i = this._modelReference.object.textEditorModel;
    if (!i)
      return;
    const { startLineNumber: n, startColumn: o, endLineNumber: r, endColumn: a } = e, l = i.getWordUntilPosition({ lineNumber: n, column: o - t }), c = new E(n, l.startColumn, n, o), d = new E(
      r,
      a,
      r,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), h = i.getValueInRange(c).replace(/^\s+/, ""), u = i.getValueInRange(e), g = i.getValueInRange(d).replace(/\s+$/, "");
    return {
      value: h + u + g,
      highlight: { start: h.length, end: h.length + u.length }
    };
  }
}
class A_ {
  constructor(e, t) {
    this.parent = e, this.uri = t, this.children = [], this._previews = new ws();
  }
  dispose() {
    Ct(this._previews.values()), this._previews.clear();
  }
  getPreview(e) {
    return this._previews.get(e.uri);
  }
  get ariaMessage() {
    const e = this.children.length;
    return e === 1 ? f("aria.fileReferences.1", "1 symbol in {0}, full path {1}", Xo(this.uri), this.uri.fsPath) : f("aria.fileReferences.N", "{0} symbols in {1}, full path {2}", e, Xo(this.uri), this.uri.fsPath);
  }
  async resolve(e) {
    if (this._previews.size !== 0)
      return this;
    for (const t of this.children)
      if (!this._previews.has(t.uri))
        try {
          const i = await e.createModelReference(t.uri);
          this._previews.set(t.uri, new Mde(i));
        } catch (i) {
          Pe(i);
        }
    return this;
  }
}
class Cs {
  constructor(e, t) {
    this.groups = [], this.references = [], this._onDidChangeReferenceRange = new B(), this.onDidChangeReferenceRange = this._onDidChangeReferenceRange.event, this._links = e, this._title = t;
    const [i] = e;
    e.sort(Cs._compareReferences);
    let n;
    for (const o of e)
      if ((!n || !Tt.isEqual(n.uri, o.uri, !0)) && (n = new A_(this, o.uri), this.groups.push(n)), n.children.length === 0 || Cs._compareReferences(o, n.children[n.children.length - 1]) !== 0) {
        const r = new md(i === o, n, o, (a) => this._onDidChangeReferenceRange.fire(a));
        this.references.push(r), n.children.push(r);
      }
  }
  dispose() {
    Ct(this.groups), this._onDidChangeReferenceRange.dispose(), this.groups.length = 0;
  }
  clone() {
    return new Cs(this._links, this._title);
  }
  get title() {
    return this._title;
  }
  get isEmpty() {
    return this.groups.length === 0;
  }
  get ariaMessage() {
    return this.isEmpty ? f("aria.result.0", "No results found") : this.references.length === 1 ? f("aria.result.1", "Found 1 symbol in {0}", this.references[0].uri.fsPath) : this.groups.length === 1 ? f("aria.result.n1", "Found {0} symbols in {1}", this.references.length, this.groups[0].uri.fsPath) : f("aria.result.nm", "Found {0} symbols in {1} files", this.references.length, this.groups.length);
  }
  nextOrPreviousReference(e, t) {
    const { parent: i } = e;
    let n = i.children.indexOf(e);
    const o = i.children.length, r = i.parent.groups.length;
    return r === 1 || t && n + 1 < o || !t && n > 0 ? (t ? n = (n + 1) % o : n = (n + o - 1) % o, i.children[n]) : (n = i.parent.groups.indexOf(i), t ? (n = (n + 1) % r, i.parent.groups[n].children[0]) : (n = (n + r - 1) % r, i.parent.groups[n].children[i.parent.groups[n].children.length - 1]));
  }
  nearestReference(e, t) {
    const i = this.references.map((n, o) => ({
      idx: o,
      prefixLen: kA(n.uri.toString(), e.toString()),
      offsetDist: Math.abs(n.range.startLineNumber - t.lineNumber) * 100 + Math.abs(n.range.startColumn - t.column)
    })).sort((n, o) => n.prefixLen > o.prefixLen ? -1 : n.prefixLen < o.prefixLen ? 1 : n.offsetDist < o.offsetDist ? -1 : n.offsetDist > o.offsetDist ? 1 : 0)[0];
    if (i)
      return this.references[i.idx];
  }
  referenceAt(e, t) {
    for (const i of this.references)
      if (i.uri.toString() === e.toString() && E.containsPosition(i.range, t))
        return i;
  }
  firstReference() {
    for (const e of this.references)
      if (e.isProviderFirst)
        return e;
    return this.references[0];
  }
  static _compareReferences(e, t) {
    return Tt.compare(e.uri, t.uri) || E.compareRangesUsingStarts(e.range, t.range);
  }
}
var kS = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, DS = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, rI;
let aI = class {
  constructor(e) {
    this._resolverService = e;
  }
  hasChildren(e) {
    return e instanceof Cs || e instanceof A_;
  }
  getChildren(e) {
    if (e instanceof Cs)
      return e.groups;
    if (e instanceof A_)
      return e.resolve(this._resolverService).then((t) => t.children);
    throw new Error("bad tree");
  }
};
aI = kS([
  DS(0, Zs)
], aI);
class Nde {
  getHeight() {
    return 23;
  }
  getTemplateId(e) {
    return e instanceof A_ ? Qv.id : Gv.id;
  }
}
let lI = class {
  constructor(e) {
    this._keybindingService = e;
  }
  getKeyboardNavigationLabel(e) {
    if (e instanceof md) {
      const t = e.parent.getPreview(e)?.preview(e.range);
      if (t)
        return t.value;
    }
    return Xo(e.uri);
  }
};
lI = kS([
  DS(0, bt)
], lI);
class Tde {
  getId(e) {
    return e instanceof md ? e.id : e.uri;
  }
}
let cI = class extends V {
  constructor(e, t) {
    super(), this._labelService = t;
    const i = document.createElement("div");
    i.classList.add("reference-file"), this.file = this._register(new rv(i, { supportHighlights: !0 })), this.badge = new kk(K(i, de(".count")), {}, Y3), e.appendChild(i);
  }
  set(e, t) {
    const i = $0(e.uri);
    this.file.setLabel(this._labelService.getUriBasenameLabel(e.uri), this._labelService.getUriLabel(i, { relative: !0 }), { title: this._labelService.getUriLabel(e.uri), matches: t });
    const n = e.children.length;
    this.badge.setCount(n), n > 1 ? this.badge.setTitleFormat(f("referencesCount", "{0} references", n)) : this.badge.setTitleFormat(f("referenceCount", "{0} reference", n));
  }
};
cI = kS([
  DS(1, Zf)
], cI);
var Qh;
let Qv = (Qh = class {
  constructor(e) {
    this._instantiationService = e, this.templateId = rI.id;
  }
  renderTemplate(e) {
    return this._instantiationService.createInstance(cI, e);
  }
  renderElement(e, t, i) {
    i.set(e.element, q0(e.filterData));
  }
  disposeTemplate(e) {
    e.dispose();
  }
}, rI = Qh, Qh.id = "FileReferencesRenderer", Qh);
Qv = rI = kS([
  DS(0, ke)
], Qv);
class Bde extends V {
  constructor(e) {
    super(), this.label = this._register(new zc(e));
  }
  set(e, t) {
    const i = e.parent.getPreview(e)?.preview(e.range);
    if (!i || !i.value)
      this.label.set(`${Xo(e.uri)}:${e.range.startLineNumber + 1}:${e.range.startColumn + 1}`);
    else {
      const { value: n, highlight: o } = i;
      t && !Tr.isDefault(t) ? (this.label.element.classList.toggle("referenceMatch", !1), this.label.set(n, q0(t))) : (this.label.element.classList.toggle("referenceMatch", !0), this.label.set(n, [o]));
    }
  }
}
const o0 = class o0 {
  constructor() {
    this.templateId = o0.id;
  }
  renderTemplate(e) {
    return new Bde(e);
  }
  renderElement(e, t, i) {
    i.set(e.element, e.filterData);
  }
  disposeTemplate(e) {
    e.dispose();
  }
};
o0.id = "OneReferenceRenderer";
let Gv = o0;
class Rde {
  getWidgetAriaLabel() {
    return f("treeAriaLabel", "References");
  }
  getAriaLabel(e) {
    return e.ariaMessage;
  }
}
var Fde = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, fg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const r0 = class r0 {
  constructor(e, t) {
    this._editor = e, this._model = t, this._decorations = /* @__PURE__ */ new Map(), this._decorationIgnoreSet = /* @__PURE__ */ new Set(), this._callOnDispose = new X(), this._callOnModelChange = new X(), this._callOnDispose.add(this._editor.onDidChangeModel(() => this._onModelChanged())), this._onModelChanged();
  }
  dispose() {
    this._callOnModelChange.dispose(), this._callOnDispose.dispose(), this.removeDecorations();
  }
  _onModelChanged() {
    this._callOnModelChange.clear();
    const e = this._editor.getModel();
    if (e) {
      for (const t of this._model.references)
        if (t.uri.toString() === e.uri.toString()) {
          this._addDecorations(t.parent);
          return;
        }
    }
  }
  _addDecorations(e) {
    if (!this._editor.hasModel())
      return;
    this._callOnModelChange.add(this._editor.getModel().onDidChangeDecorations(() => this._onDecorationChanged()));
    const t = [], i = [];
    for (let n = 0, o = e.children.length; n < o; n++) {
      const r = e.children[n];
      this._decorationIgnoreSet.has(r.id) || r.uri.toString() === this._editor.getModel().uri.toString() && (t.push({
        range: r.range,
        options: r0.DecorationOptions
      }), i.push(n));
    }
    this._editor.changeDecorations((n) => {
      const o = n.deltaDecorations([], t);
      for (let r = 0; r < o.length; r++)
        this._decorations.set(o[r], e.children[i[r]]);
    });
  }
  _onDecorationChanged() {
    const e = [], t = this._editor.getModel();
    if (t) {
      for (const [i, n] of this._decorations) {
        const o = t.getDecorationRange(i);
        if (!o)
          continue;
        let r = !1;
        if (!E.equalsRange(o, n.range)) {
          if (E.spansMultipleLines(o))
            r = !0;
          else {
            const a = n.range.endColumn - n.range.startColumn, l = o.endColumn - o.startColumn;
            a !== l && (r = !0);
          }
          r ? (this._decorationIgnoreSet.add(n.id), e.push(i)) : n.range = o;
        }
      }
      for (let i = 0, n = e.length; i < n; i++)
        this._decorations.delete(e[i]);
      this._editor.removeDecorations(e);
    }
  }
  removeDecorations() {
    this._editor.removeDecorations([...this._decorations.keys()]), this._decorations.clear();
  }
};
r0.DecorationOptions = He.register({
  description: "reference-decoration",
  stickiness: 1,
  className: "reference-decoration"
});
let dI = r0;
class Ode {
  constructor() {
    this.ratio = 0.7, this.heightInLines = 18;
  }
  static fromJSON(e) {
    let t, i;
    try {
      const n = JSON.parse(e);
      t = n.ratio, i = n.heightInLines;
    } catch {
    }
    return {
      ratio: t || 0.7,
      heightInLines: i || 18
    };
  }
}
class Pde extends Fk {
}
let hI = class extends Uv {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { showFrame: !1, showArrow: !0, isResizeable: !0, isAccessible: !0, supportOnTitleClick: !0 }, r), this._defaultTreeKeyboardSupport = t, this.layoutData = i, this._textModelResolverService = o, this._instantiationService = r, this._peekViewService = a, this._uriLabel = l, this._keybindingService = c, this._disposeOnNewModel = new X(), this._callOnDispose = new X(), this._onDidSelectReference = new B(), this.onDidSelectReference = this._onDidSelectReference.event, this._dim = new at(0, 0), this._isClosing = !1, this._applyTheme(n.getColorTheme()), this._callOnDispose.add(n.onDidColorThemeChange(this._applyTheme.bind(this))), this._peekViewService.addExclusiveWidget(e, this), this.create();
  }
  get isClosing() {
    return this._isClosing;
  }
  dispose() {
    this._isClosing = !0, this.setModel(void 0), this._callOnDispose.dispose(), this._disposeOnNewModel.dispose(), Ct(this._preview), Ct(this._previewNotAvailableMessage), Ct(this._tree), Ct(this._previewModelReference), this._splitView.dispose(), super.dispose();
  }
  _applyTheme(e) {
    const t = e.getColor(Dde) || Y.transparent;
    this.style({
      arrowColor: t,
      frameColor: t,
      headerBackgroundColor: e.getColor(kde) || Y.transparent,
      primaryHeadingColor: e.getColor(uV),
      secondaryHeadingColor: e.getColor(gV)
    });
  }
  show(e) {
    super.show(e, this.layoutData.heightInLines || 18);
  }
  focusOnReferenceTree() {
    this._tree.domFocus();
  }
  focusOnPreviewEditor() {
    this._preview.focus();
  }
  isPreviewEditorFocused() {
    return this._preview.hasTextFocus();
  }
  _onTitleClick(e) {
    this._preview && this._preview.getModel() && this._onDidSelectReference.fire({
      element: this._getFocusedReference(),
      kind: e.ctrlKey || e.metaKey || e.altKey ? "side" : "open",
      source: "title"
    });
  }
  _fillBody(e) {
    this.setCssClass("reference-zone-widget"), this._messageContainer = K(e, de("div.messages")), Dn(this._messageContainer), this._splitView = new OW(e, {
      orientation: 1
      /* Orientation.HORIZONTAL */
    }), this._previewContainer = K(e, de("div.preview.inline"));
    const t = {
      scrollBeyondLastLine: !1,
      scrollbar: {
        verticalScrollbarSize: 14,
        horizontal: "auto",
        useShadows: !0,
        verticalHasArrows: !1,
        horizontalHasArrows: !1,
        alwaysConsumeMouseWheel: !0
      },
      overviewRulerLanes: 2,
      fixedOverflowWidgets: !0,
      minimap: {
        enabled: !1
      }
    };
    this._preview = this._instantiationService.createInstance(ku, this._previewContainer, t, {}, this.editor), Dn(this._previewContainer), this._previewNotAvailableMessage = this._instantiationService.createInstance(ZA, f("missingPreviewMessage", "no preview available"), Js, ZA.DEFAULT_CREATION_OPTIONS, null), this._treeContainer = K(e, de("div.ref-tree.inline"));
    const i = {
      keyboardSupport: this._defaultTreeKeyboardSupport,
      accessibilityProvider: new Rde(),
      keyboardNavigationLabelProvider: this._instantiationService.createInstance(lI),
      identityProvider: new Tde(),
      openOnSingleClick: !0,
      selectionNavigation: !0,
      overrideStyles: {
        listBackground: Ide
      }
    };
    this._defaultTreeKeyboardSupport && this._callOnDispose.add(Xt(this._treeContainer, "keydown", (o) => {
      o.equals(
        9
        /* KeyCode.Escape */
      ) && (this._keybindingService.dispatchEvent(o, o.target), o.stopPropagation());
    }, !0)), this._tree = this._instantiationService.createInstance(Pde, "ReferencesWidget", this._treeContainer, new Nde(), [
      this._instantiationService.createInstance(Qv),
      this._instantiationService.createInstance(Gv)
    ], this._instantiationService.createInstance(aI), i), this._splitView.addView({
      onDidChange: te.None,
      element: this._previewContainer,
      minimumSize: 200,
      maximumSize: Number.MAX_VALUE,
      layout: (o) => {
        this._preview.layout({ height: this._dim.height, width: o });
      }
    }, ZC.Distribute), this._splitView.addView({
      onDidChange: te.None,
      element: this._treeContainer,
      minimumSize: 100,
      maximumSize: Number.MAX_VALUE,
      layout: (o) => {
        this._treeContainer.style.height = `${this._dim.height}px`, this._treeContainer.style.width = `${o}px`, this._tree.layout(this._dim.height, o);
      }
    }, ZC.Distribute), this._disposables.add(this._splitView.onDidSashChange(() => {
      this._dim.width && (this.layoutData.ratio = this._splitView.getViewSize(0) / this._dim.width);
    }, void 0));
    const n = (o, r) => {
      o instanceof md && (r === "show" && this._revealReference(o, !1), this._onDidSelectReference.fire({ element: o, kind: r, source: "tree" }));
    };
    this._disposables.add(this._tree.onDidOpen((o) => {
      o.sideBySide ? n(o.element, "side") : o.editorOptions.pinned ? n(o.element, "goto") : n(o.element, "show");
    })), Dn(this._treeContainer);
  }
  _onWidth(e) {
    this._dim && this._doLayoutBody(this._dim.height, e);
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._dim = new at(t, e), this.layoutData.heightInLines = this._viewZone ? this._viewZone.heightInLines : this.layoutData.heightInLines, this._splitView.layout(t), this._splitView.resizeView(0, t * this.layoutData.ratio);
  }
  setSelection(e) {
    return this._revealReference(e, !0).then(() => {
      this._model && (this._tree.setSelection([e]), this._tree.setFocus([e]));
    });
  }
  setModel(e) {
    return this._disposeOnNewModel.clear(), this._model = e, this._model ? this._onNewModel() : Promise.resolve();
  }
  _onNewModel() {
    return this._model ? this._model.isEmpty ? (this.setTitle(""), this._messageContainer.innerText = f("noResults", "No results"), ps(this._messageContainer), Promise.resolve(void 0)) : (Dn(this._messageContainer), this._decorationsManager = new dI(this._preview, this._model), this._disposeOnNewModel.add(this._decorationsManager), this._disposeOnNewModel.add(this._model.onDidChangeReferenceRange((e) => this._tree.rerender(e))), this._disposeOnNewModel.add(this._preview.onMouseDown((e) => {
      const { event: t, target: i } = e;
      if (t.detail !== 2)
        return;
      const n = this._getFocusedReference();
      n && this._onDidSelectReference.fire({
        element: { uri: n.uri, range: i.range },
        kind: t.ctrlKey || t.metaKey || t.altKey ? "side" : "open",
        source: "editor"
      });
    })), this.container.classList.add("results-loaded"), ps(this._treeContainer), ps(this._previewContainer), this._splitView.layout(this._dim.width), this.focusOnReferenceTree(), this._tree.setInput(this._model.groups.length === 1 ? this._model.groups[0] : this._model)) : Promise.resolve(void 0);
  }
  _getFocusedReference() {
    const [e] = this._tree.getFocus();
    if (e instanceof md)
      return e;
    if (e instanceof A_ && e.children.length > 0)
      return e.children[0];
  }
  async revealReference(e) {
    await this._revealReference(e, !1), this._onDidSelectReference.fire({ element: e, kind: "goto", source: "tree" });
  }
  async _revealReference(e, t) {
    if (this._revealedReference === e)
      return;
    this._revealedReference = e, e.uri.scheme !== Ie.inMemory ? this.setTitle(mJ(e.uri), this._uriLabel.getUriLabel($0(e.uri))) : this.setTitle(f("peekView.alternateTitle", "References"));
    const i = this._textModelResolverService.createModelReference(e.uri);
    this._tree.getInput() === e.parent ? this._tree.reveal(e) : (t && this._tree.reveal(e.parent), await this._tree.expand(e.parent), this._tree.reveal(e));
    const n = await i;
    if (!this._model) {
      n.dispose();
      return;
    }
    Ct(this._previewModelReference);
    const o = n.object;
    if (o) {
      const r = this._preview.getModel() === o.textEditorModel ? 0 : 1, a = E.lift(e.range).collapseToStart();
      this._previewModelReference = n, this._preview.setModel(o.textEditorModel), this._preview.setSelection(a), this._preview.revealRangeInCenter(a, r);
    } else
      this._preview.setModel(this._previewNotAvailableMessage), n.dispose();
  }
};
hI = Fde([
  fg(3, nn),
  fg(4, Zs),
  fg(5, ke),
  fg(6, hV),
  fg(7, Zf),
  fg(8, bt)
], hI);
var Hde = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ww;
const qu = new le("referenceSearchVisible", !1, f("referenceSearchVisible", "Whether reference peek is visible, like 'Peek References' or 'Peek Definition'"));
var Gh;
let __ = (Gh = class {
  static get(e) {
    return e.getContribution(Ww.ID);
  }
  constructor(e, t, i, n, o, r, a, l) {
    this._defaultTreeKeyboardSupport = e, this._editor = t, this._editorService = n, this._notificationService = o, this._instantiationService = r, this._storageService = a, this._configurationService = l, this._disposables = new X(), this._requestIdPool = 0, this._ignoreModelChangeEvent = !1, this._referenceSearchVisible = qu.bindTo(i);
  }
  dispose() {
    this._referenceSearchVisible.reset(), this._disposables.dispose(), this._widget?.dispose(), this._model?.dispose(), this._widget = void 0, this._model = void 0;
  }
  toggleWidget(e, t, i) {
    let n;
    if (this._widget && (n = this._widget.position), this.closeWidget(), n && e.containsPosition(n))
      return;
    this._peekMode = i, this._referenceSearchVisible.set(!0), this._disposables.add(this._editor.onDidChangeModelLanguage(() => {
      this.closeWidget();
    })), this._disposables.add(this._editor.onDidChangeModel(() => {
      this._ignoreModelChangeEvent || this.closeWidget();
    }));
    const o = "peekViewLayout", r = Ode.fromJSON(this._storageService.get(o, 0, "{}"));
    this._widget = this._instantiationService.createInstance(hI, this._editor, this._defaultTreeKeyboardSupport, r), this._widget.setTitle(f("labelLoading", "Loading...")), this._widget.show(e), this._disposables.add(this._widget.onDidClose(() => {
      t.cancel(), this._widget ? (this._storageService.store(
        o,
        JSON.stringify(this._widget.layoutData),
        0,
        1
        /* StorageTarget.MACHINE */
      ), this._widget.isClosing || this.closeWidget(), this._widget = void 0) : this.closeWidget();
    })), this._disposables.add(this._widget.onDidSelectReference((l) => {
      const { element: c, kind: d } = l;
      if (c)
        switch (d) {
          case "open":
            (l.source !== "editor" || !this._configurationService.getValue("editor.stablePeek")) && this.openReference(c, !1, !1);
            break;
          case "side":
            this.openReference(c, !0, !1);
            break;
          case "goto":
            i ? this._gotoReference(c, !0) : this.openReference(c, !1, !0);
            break;
        }
    }));
    const a = ++this._requestIdPool;
    t.then((l) => {
      if (a !== this._requestIdPool || !this._widget) {
        l.dispose();
        return;
      }
      return this._model?.dispose(), this._model = l, this._widget.setModel(this._model).then(() => {
        if (this._widget && this._model && this._editor.hasModel()) {
          this._model.isEmpty ? this._widget.setMetaTitle("") : this._widget.setMetaTitle(f("metaTitle.N", "{0} ({1})", this._model.title, this._model.references.length));
          const c = this._editor.getModel().uri, d = new F(e.startLineNumber, e.startColumn), h = this._model.nearestReference(c, d);
          if (h)
            return this._widget.setSelection(h).then(() => {
              this._widget && this._editor.getOption(
                87
                /* EditorOption.peekWidgetDefaultFocus */
              ) === "editor" && this._widget.focusOnPreviewEditor();
            });
        }
      });
    }, (l) => {
      this._notificationService.error(l);
    });
  }
  changeFocusBetweenPreviewAndReferences() {
    this._widget && (this._widget.isPreviewEditorFocused() ? this._widget.focusOnReferenceTree() : this._widget.focusOnPreviewEditor());
  }
  async goToNextOrPreviousReference(e) {
    if (!this._editor.hasModel() || !this._model || !this._widget)
      return;
    const t = this._widget.position;
    if (!t)
      return;
    const i = this._model.nearestReference(this._editor.getModel().uri, t);
    if (!i)
      return;
    const n = this._model.nextOrPreviousReference(i, e), o = this._editor.hasTextFocus(), r = this._widget.isPreviewEditorFocused();
    await this._widget.setSelection(n), await this._gotoReference(n, !1), o ? this._editor.focus() : this._widget && r && this._widget.focusOnPreviewEditor();
  }
  async revealReference(e) {
    !this._editor.hasModel() || !this._model || !this._widget || await this._widget.revealReference(e);
  }
  closeWidget(e = !0) {
    this._widget?.dispose(), this._model?.dispose(), this._referenceSearchVisible.reset(), this._disposables.clear(), this._widget = void 0, this._model = void 0, e && this._editor.focus(), this._requestIdPool += 1;
  }
  _gotoReference(e, t) {
    this._widget?.hide(), this._ignoreModelChangeEvent = !0;
    const i = E.lift(e.range).collapseToStart();
    return this._editorService.openCodeEditor({
      resource: e.uri,
      options: { selection: i, selectionSource: "code.jump", pinned: t }
    }, this._editor).then((n) => {
      if (this._ignoreModelChangeEvent = !1, !n || !this._widget) {
        this.closeWidget();
        return;
      }
      if (this._editor === n)
        this._widget.show(i), this._widget.focusOnReferenceTree();
      else {
        const o = Ww.get(n), r = this._model.clone();
        this.closeWidget(), n.focus(), o?.toggleWidget(i, ir((a) => Promise.resolve(r)), this._peekMode ?? !1);
      }
    }, (n) => {
      this._ignoreModelChangeEvent = !1, Pe(n);
    });
  }
  openReference(e, t, i) {
    t || this.closeWidget();
    const { uri: n, range: o } = e;
    this._editorService.openCodeEditor({
      resource: n,
      options: { selection: o, selectionSource: "code.jump", pinned: i }
    }, this._editor, t);
  }
}, Ww = Gh, Gh.ID = "editor.contrib.referencesController", Gh);
__ = Ww = Hde([
  mg(2, Se),
  mg(3, Nt),
  mg(4, Oi),
  mg(5, ke),
  mg(6, Jl),
  mg(7, ht)
], __);
function $u(s, e) {
  const t = Ede(s);
  if (!t)
    return;
  const i = __.get(t);
  i && e(i);
}
Hn.registerCommandAndKeybindingRule({
  id: "togglePeekWidgetFocus",
  weight: 100,
  primary: Qi(
    2089,
    60
    /* KeyCode.F2 */
  ),
  when: ne.or(qu, ns.inPeekEditor),
  handler(s) {
    $u(s, (e) => {
      e.changeFocusBetweenPreviewAndReferences();
    });
  }
});
Hn.registerCommandAndKeybindingRule({
  id: "goToNextReference",
  weight: 90,
  primary: 62,
  secondary: [
    70
    /* KeyCode.F12 */
  ],
  when: ne.or(qu, ns.inPeekEditor),
  handler(s) {
    $u(s, (e) => {
      e.goToNextOrPreviousReference(!0);
    });
  }
});
Hn.registerCommandAndKeybindingRule({
  id: "goToPreviousReference",
  weight: 90,
  primary: 1086,
  secondary: [
    1094
    /* KeyCode.F12 */
  ],
  when: ne.or(qu, ns.inPeekEditor),
  handler(s) {
    $u(s, (e) => {
      e.goToNextOrPreviousReference(!1);
    });
  }
});
mt.registerCommandAlias("goToNextReferenceFromEmbeddedEditor", "goToNextReference");
mt.registerCommandAlias("goToPreviousReferenceFromEmbeddedEditor", "goToPreviousReference");
mt.registerCommandAlias("closeReferenceSearchEditor", "closeReferenceSearch");
mt.registerCommand("closeReferenceSearch", (s) => $u(s, (e) => e.closeWidget()));
Hn.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: -1,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: ne.and(ns.inPeekEditor, ne.not("config.editor.stablePeek"))
});
Hn.registerKeybindingRule({
  id: "closeReferenceSearch",
  weight: 250,
  primary: 9,
  secondary: [
    1033
    /* KeyCode.Escape */
  ],
  when: ne.and(qu, ne.not("config.editor.stablePeek"), ne.or(R.editorTextFocus, YW.negate()))
});
Hn.registerCommandAndKeybindingRule({
  id: "revealReference",
  weight: 200,
  primary: 3,
  mac: {
    primary: 3,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ]
  },
  when: ne.and(qu, qW, AT.negate(), _T.negate()),
  handler(s) {
    const t = s.get(Do).lastFocusedList?.getFocus();
    Array.isArray(t) && t[0] instanceof md && $u(s, (i) => i.revealReference(t[0]));
  }
});
Hn.registerCommandAndKeybindingRule({
  id: "openReferenceToSide",
  weight: 100,
  primary: 2051,
  mac: {
    primary: 259
    /* KeyCode.Enter */
  },
  when: ne.and(qu, qW, AT.negate(), _T.negate()),
  handler(s) {
    const t = s.get(Do).lastFocusedList?.getFocus();
    Array.isArray(t) && t[0] instanceof md && $u(s, (i) => i.openReference(t[0], !0, !0));
  }
});
mt.registerCommand("openReference", (s) => {
  const t = s.get(Do).lastFocusedList?.getFocus();
  Array.isArray(t) && t[0] instanceof md && $u(s, (i) => i.openReference(t[0], !1, !0));
});
var mV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, vp = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const iB = new le("hasSymbols", !1, f("hasSymbols", "Whether there are symbol locations that can be navigated via keyboard-only.")), IS = We("ISymbolNavigationService");
let uI = class {
  constructor(e, t, i, n) {
    this._editorService = t, this._notificationService = i, this._keybindingService = n, this._currentModel = void 0, this._currentIdx = -1, this._ignoreEditorChange = !1, this._ctxHasSymbols = iB.bindTo(e);
  }
  reset() {
    this._ctxHasSymbols.reset(), this._currentState?.dispose(), this._currentMessage?.dispose(), this._currentModel = void 0, this._currentIdx = -1;
  }
  put(e) {
    const t = e.parent.parent;
    if (t.references.length <= 1) {
      this.reset();
      return;
    }
    this._currentModel = t, this._currentIdx = t.references.indexOf(e), this._ctxHasSymbols.set(!0), this._showMessage();
    const i = new gI(this._editorService), n = i.onDidChange((o) => {
      if (this._ignoreEditorChange)
        return;
      const r = this._editorService.getActiveCodeEditor();
      if (!r)
        return;
      const a = r.getModel(), l = r.getPosition();
      if (!a || !l)
        return;
      let c = !1, d = !1;
      for (const h of t.references)
        if (IN(h.uri, a.uri))
          c = !0, d = d || E.containsPosition(h.range, l);
        else if (c)
          break;
      (!c || !d) && this.reset();
    });
    this._currentState = jo(i, n);
  }
  revealNext(e) {
    if (!this._currentModel)
      return Promise.resolve();
    this._currentIdx += 1, this._currentIdx %= this._currentModel.references.length;
    const t = this._currentModel.references[this._currentIdx];
    return this._showMessage(), this._ignoreEditorChange = !0, this._editorService.openCodeEditor({
      resource: t.uri,
      options: {
        selection: E.collapseToStart(t.range),
        selectionRevealType: 3
        /* TextEditorSelectionRevealType.NearTopIfOutsideViewport */
      }
    }, e).finally(() => {
      this._ignoreEditorChange = !1;
    });
  }
  _showMessage() {
    this._currentMessage?.dispose();
    const e = this._keybindingService.lookupKeybinding("editor.gotoNextSymbolFromResult"), t = e ? f("location.kb", "Symbol {0} of {1}, {2} for next", this._currentIdx + 1, this._currentModel.references.length, e.getLabel()) : f("location", "Symbol {0} of {1}", this._currentIdx + 1, this._currentModel.references.length);
    this._currentMessage = this._notificationService.status(t);
  }
};
uI = mV([
  vp(0, Se),
  vp(1, Nt),
  vp(2, Oi),
  vp(3, bt)
], uI);
$e(
  IS,
  uI,
  1
  /* InstantiationType.Delayed */
);
re(new class extends Wn {
  constructor() {
    super({
      id: "editor.gotoNextSymbolFromResult",
      precondition: iB,
      kbOpts: {
        weight: 100,
        primary: 70
        /* KeyCode.F12 */
      }
    });
  }
  runEditorCommand(s, e) {
    return s.get(IS).revealNext(e);
  }
}());
Hn.registerCommandAndKeybindingRule({
  id: "editor.gotoNextSymbolFromResult.cancel",
  weight: 100,
  when: iB,
  primary: 9,
  handler(s) {
    s.get(IS).reset();
  }
});
let gI = class {
  constructor(e) {
    this._listener = /* @__PURE__ */ new Map(), this._disposables = new X(), this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._disposables.add(e.onCodeEditorRemove(this._onDidRemoveEditor, this)), this._disposables.add(e.onCodeEditorAdd(this._onDidAddEditor, this)), e.listCodeEditors().forEach(this._onDidAddEditor, this);
  }
  dispose() {
    this._disposables.dispose(), this._onDidChange.dispose(), Ct(this._listener.values());
  }
  _onDidAddEditor(e) {
    this._listener.set(e, jo(e.onDidChangeCursorPosition((t) => this._onDidChange.fire({ editor: e })), e.onDidChangeModelContent((t) => this._onDidChange.fire({ editor: e }))));
  }
  _onDidRemoveEditor(e) {
    this._listener.get(e)?.dispose(), this._listener.delete(e);
  }
};
gI = mV([
  vp(0, Nt)
], gI);
var Wde = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, BP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Vw, Gc;
let xa = (Gc = class {
  static get(e) {
    return e.getContribution(Vw.ID);
  }
  constructor(e, t, i) {
    this._openerService = i, this._messageWidget = new On(), this._messageListeners = new X(), this._mouseOverMessage = !1, this._editor = e, this._visible = Vw.MESSAGE_VISIBLE.bindTo(t);
  }
  dispose() {
    this._message?.dispose(), this._messageListeners.dispose(), this._messageWidget.dispose(), this._visible.reset();
  }
  showMessage(e, t) {
    Ia(Sa(e) ? e.value : e), this._visible.set(!0), this._messageWidget.clear(), this._messageListeners.clear(), this._message = Sa(e) ? Z0(e, {
      actionHandler: {
        callback: (n) => {
          this.closeMessage(), BN(this._openerService, n, Sa(e) ? e.isTrusted : void 0);
        },
        disposables: this._messageListeners
      }
    }) : void 0, this._messageWidget.value = new RP(this._editor, t, typeof e == "string" ? e : this._message.element), this._messageListeners.add(te.debounce(this._editor.onDidBlurEditorText, (n, o) => o, 0)(() => {
      this._mouseOverMessage || this._messageWidget.value && yi(ln(), this._messageWidget.value.getDomNode()) || this.closeMessage();
    })), this._messageListeners.add(this._editor.onDidChangeCursorPosition(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidDispose(() => this.closeMessage())), this._messageListeners.add(this._editor.onDidChangeModel(() => this.closeMessage())), this._messageListeners.add(U(this._messageWidget.value.getDomNode(), ee.MOUSE_ENTER, () => this._mouseOverMessage = !0, !0)), this._messageListeners.add(U(this._messageWidget.value.getDomNode(), ee.MOUSE_LEAVE, () => this._mouseOverMessage = !1, !0));
    let i;
    this._messageListeners.add(this._editor.onMouseMove((n) => {
      n.target.position && (i ? i.containsPosition(n.target.position) || this.closeMessage() : i = new E(t.lineNumber - 3, 1, n.target.position.lineNumber + 3, 1));
    }));
  }
  closeMessage() {
    this._visible.reset(), this._messageListeners.clear(), this._messageWidget.value && this._messageListeners.add(RP.fadeOut(this._messageWidget.value));
  }
}, Vw = Gc, Gc.ID = "editor.contrib.messageController", Gc.MESSAGE_VISIBLE = new le("messageVisible", !1, f("messageVisible", "Whether the editor is currently showing an inline message")), Gc);
xa = Vw = Wde([
  BP(1, Se),
  BP(2, lr)
], xa);
const Vde = Wn.bindToContribution(xa.get);
re(new Vde({
  id: "leaveEditorMessage",
  precondition: xa.MESSAGE_VISIBLE,
  handler: (s) => s.closeMessage(),
  kbOpts: {
    weight: 130,
    primary: 9
    /* KeyCode.Escape */
  }
}));
let RP = class {
  static fadeOut(e) {
    const t = () => {
      e.dispose(), clearTimeout(i), e.getDomNode().removeEventListener("animationend", t);
    }, i = setTimeout(t, 110);
    return e.getDomNode().addEventListener("animationend", t), e.getDomNode().classList.add("fadeOut"), { dispose: t };
  }
  constructor(e, { lineNumber: t, column: i }, n) {
    this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._editor = e, this._editor.revealLinesInCenterIfOutsideViewport(
      t,
      t,
      0
      /* ScrollType.Smooth */
    ), this._position = { lineNumber: t, column: i }, this._domNode = document.createElement("div"), this._domNode.classList.add("monaco-editor-overlaymessage"), this._domNode.style.marginLeft = "-6px";
    const o = document.createElement("div");
    o.classList.add("anchor", "top"), this._domNode.appendChild(o);
    const r = document.createElement("div");
    typeof n == "string" ? (r.classList.add("message"), r.textContent = n) : (n.classList.add("message"), r.appendChild(n)), this._domNode.appendChild(r);
    const a = document.createElement("div");
    a.classList.add("anchor", "below"), this._domNode.appendChild(a), this._editor.addContentWidget(this), this._domNode.classList.add("fadeIn");
  }
  dispose() {
    this._editor.removeContentWidget(this);
  }
  getId() {
    return "messageoverlay";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      position: this._position,
      preference: [
        1,
        2
      ],
      positionAffinity: 1
    };
  }
  afterRender(e) {
    this._domNode.classList.toggle(
      "below",
      e === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
};
rs(
  xa.ID,
  xa,
  4
  /* EditorContributionInstantiation.Lazy */
);
function fI(s, e) {
  return e.uri.scheme === s.uri.scheme ? !0 : !HE(e.uri, Ie.walkThroughSnippet, Ie.vscodeChatCodeBlock, Ie.vscodeChatCodeCompareBlock);
}
async function K_(s, e, t, i, n) {
  const r = t.ordered(s, i).map((l) => Promise.resolve(n(l, s, e)).then(void 0, (c) => {
    xs(c);
  })), a = await Promise.all(r);
  return mm(a.flat()).filter((l) => fI(s, l));
}
function MS(s, e, t, i, n) {
  return K_(e, t, s, i, (o, r, a) => o.provideDefinition(r, a, n));
}
function nB(s, e, t, i, n) {
  return K_(e, t, s, i, (o, r, a) => o.provideDeclaration(r, a, n));
}
function sB(s, e, t, i, n) {
  return K_(e, t, s, i, (o, r, a) => o.provideImplementation(r, a, n));
}
function oB(s, e, t, i, n) {
  return K_(e, t, s, i, (o, r, a) => o.provideTypeDefinition(r, a, n));
}
function J_(s, e, t, i, n, o) {
  return K_(e, t, s, n, async (r, a, l) => {
    const c = (await r.provideReferences(a, l, { includeDeclaration: !0 }, o))?.filter((h) => fI(a, h));
    if (!i || !c || c.length !== 2)
      return c;
    const d = (await r.provideReferences(a, l, { includeDeclaration: !1 }, o))?.filter((h) => fI(a, h));
    return d && d.length === 1 ? d : c;
  });
}
async function Wa(s) {
  const e = await s(), t = new Cs(e, ""), i = t.references.map((n) => n.link);
  return t.dispose(), i;
}
or("_executeDefinitionProvider", (s, e, t) => {
  const i = s.get(ye), n = MS(i.definitionProvider, e, t, !1, ct.None);
  return Wa(() => n);
});
or("_executeDefinitionProvider_recursive", (s, e, t) => {
  const i = s.get(ye), n = MS(i.definitionProvider, e, t, !0, ct.None);
  return Wa(() => n);
});
or("_executeTypeDefinitionProvider", (s, e, t) => {
  const i = s.get(ye), n = oB(i.typeDefinitionProvider, e, t, !1, ct.None);
  return Wa(() => n);
});
or("_executeTypeDefinitionProvider_recursive", (s, e, t) => {
  const i = s.get(ye), n = oB(i.typeDefinitionProvider, e, t, !0, ct.None);
  return Wa(() => n);
});
or("_executeDeclarationProvider", (s, e, t) => {
  const i = s.get(ye), n = nB(i.declarationProvider, e, t, !1, ct.None);
  return Wa(() => n);
});
or("_executeDeclarationProvider_recursive", (s, e, t) => {
  const i = s.get(ye), n = nB(i.declarationProvider, e, t, !0, ct.None);
  return Wa(() => n);
});
or("_executeReferenceProvider", (s, e, t) => {
  const i = s.get(ye), n = J_(i.referenceProvider, e, t, !1, !1, ct.None);
  return Wa(() => n);
});
or("_executeReferenceProvider_recursive", (s, e, t) => {
  const i = s.get(ye), n = J_(i.referenceProvider, e, t, !1, !0, ct.None);
  return Wa(() => n);
});
or("_executeImplementationProvider", (s, e, t) => {
  const i = s.get(ye), n = sB(i.implementationProvider, e, t, !1, ct.None);
  return Wa(() => n);
});
or("_executeImplementationProvider_recursive", (s, e, t) => {
  const i = s.get(ye), n = sB(i.implementationProvider, e, t, !0, ct.None);
  return Wa(() => n);
});
mo.appendMenuItem(Qe.EditorContext, {
  submenu: Qe.EditorContextPeek,
  title: f("peek.submenu", "Peek"),
  group: "navigation",
  order: 100
});
class cm {
  static is(e) {
    return !e || typeof e != "object" ? !1 : !!(e instanceof cm || F.isIPosition(e.position) && e.model);
  }
  constructor(e, t) {
    this.model = e, this.position = t;
  }
}
const Ro = class Ro extends BU {
  static all() {
    return Ro._allSymbolNavigationCommands.values();
  }
  static _patchConfig(e) {
    const t = { ...e, f1: !0 };
    if (t.menu)
      for (const i of nt.wrap(t.menu))
        (i.id === Qe.EditorContext || i.id === Qe.EditorContextPeek) && (i.when = ne.and(e.precondition, i.when));
    return t;
  }
  constructor(e, t) {
    super(Ro._patchConfig(t)), this.configuration = e, Ro._allSymbolNavigationCommands.set(t.id, this);
  }
  runEditorCommand(e, t, i, n) {
    if (!t.hasModel())
      return Promise.resolve(void 0);
    const o = e.get(Oi), r = e.get(Nt), a = e.get(P_), l = e.get(IS), c = e.get(ye), d = e.get(ke), h = t.getModel(), u = t.getPosition(), g = cm.is(i) ? i : new cm(h, u), m = new Vce(
      t,
      5
      /* CodeEditorStateFlag.Position */
    ), p = Z7(this._getLocationModel(c, g.model, g.position, m.token), m.token).then(async (A) => {
      if (!A || m.token.isCancellationRequested)
        return;
      Ia(A.ariaMessage);
      let _;
      if (A.referenceAt(h.uri, u)) {
        const C = this._getAlternativeCommand(t);
        !Ro._activeAlternativeCommands.has(C) && Ro._allSymbolNavigationCommands.has(C) && (_ = Ro._allSymbolNavigationCommands.get(C));
      }
      const b = A.references.length;
      if (b === 0) {
        if (!this.configuration.muteMessage) {
          const C = h.getWordAtPosition(u);
          xa.get(t)?.showMessage(this._getNoResultFoundMessage(C), u);
        }
      } else if (b === 1 && _)
        Ro._activeAlternativeCommands.add(this.desc.id), d.invokeFunction((C) => _.runEditorCommand(C, t, i, n).finally(() => {
          Ro._activeAlternativeCommands.delete(this.desc.id);
        }));
      else
        return this._onResult(r, l, t, A, n);
    }, (A) => {
      o.error(A);
    }).finally(() => {
      m.dispose();
    });
    return a.showWhile(p, 250), p;
  }
  async _onResult(e, t, i, n, o) {
    const r = this._getGoToPreference(i);
    if (!(i instanceof ku) && (this.configuration.openInPeek || r === "peek" && n.references.length > 1))
      this._openInPeek(i, n, o);
    else {
      const a = n.firstReference(), l = n.references.length > 1 && r === "gotoAndPeek", c = await this._openReference(i, e, a, this.configuration.openToSide, !l);
      l && c ? this._openInPeek(c, n, o) : n.dispose(), r === "goto" && t.put(a);
    }
  }
  async _openReference(e, t, i, n, o) {
    let r;
    if (v7(i) && (r = i.targetSelectionRange), r || (r = i.range), !r)
      return;
    const a = await t.openCodeEditor({
      resource: i.uri,
      options: {
        selection: E.collapseToStart(r),
        selectionRevealType: 3,
        selectionSource: "code.jump"
        /* TextEditorSelectionSource.JUMP */
      }
    }, e, n);
    if (a) {
      if (o) {
        const l = a.getModel(), c = a.createDecorationsCollection([{ range: r, options: { description: "symbol-navigate-action-highlight", className: "symbolHighlight" } }]);
        setTimeout(() => {
          a.getModel() === l && c.clear();
        }, 350);
      }
      return a;
    }
  }
  _openInPeek(e, t, i) {
    const n = __.get(e);
    n && e.hasModel() ? n.toggleWidget(i ?? e.getSelection(), ir((o) => Promise.resolve(t)), this.configuration.openInPeek) : t.dispose();
  }
};
Ro._allSymbolNavigationCommands = /* @__PURE__ */ new Map(), Ro._activeAlternativeCommands = /* @__PURE__ */ new Set();
let Ul = Ro;
class q_ extends Ul {
  async _getLocationModel(e, t, i, n) {
    return new Cs(await MS(e.definitionProvider, t, i, !1, n), f("def.title", "Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? f("noResultWord", "No definition found for '{0}'", e.word) : f("generic.noResults", "No definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDefinitions;
  }
}
var jc;
os((jc = class extends q_ {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: jc.id,
      title: {
        ...ni("actions.goToDecl.label", "Go to Definition"),
        mnemonicTitle: f({ key: "miGotoDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Definition")
      },
      precondition: R.hasDefinitionProvider,
      keybinding: [{
        when: R.editorTextFocus,
        primary: 70,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ne.and(R.editorTextFocus, GW),
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }],
      menu: [{
        id: Qe.EditorContext,
        group: "navigation",
        order: 1.1
      }, {
        id: Qe.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 2
      }]
    }), mt.registerCommandAlias("editor.action.goToDeclaration", jc.id);
  }
}, jc.id = "editor.action.revealDefinition", jc));
var Yc;
os((Yc = class extends q_ {
  constructor() {
    super({
      openToSide: !0,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Yc.id,
      title: ni("actions.goToDeclToSide.label", "Open Definition to the Side"),
      precondition: ne.and(R.hasDefinitionProvider, R.isInEmbeddedEditor.toNegated()),
      keybinding: [{
        when: R.editorTextFocus,
        primary: Qi(
          2089,
          70
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        when: ne.and(R.editorTextFocus, GW),
        primary: Qi(
          2089,
          2118
          /* KeyCode.F12 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    }), mt.registerCommandAlias("editor.action.openDeclarationToTheSide", Yc.id);
  }
}, Yc.id = "editor.action.revealDefinitionAside", Yc));
var Kc;
os((Kc = class extends q_ {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Kc.id,
      title: ni("actions.previewDecl.label", "Peek Definition"),
      precondition: ne.and(R.hasDefinitionProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: R.editorTextFocus,
        primary: 582,
        linux: {
          primary: 3140
          /* KeyCode.F10 */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: Qe.EditorContextPeek,
        group: "peek",
        order: 2
      }
    }), mt.registerCommandAlias("editor.action.previewDeclaration", Kc.id);
  }
}, Kc.id = "editor.action.peekDefinition", Kc));
class pV extends Ul {
  async _getLocationModel(e, t, i, n) {
    return new Cs(await nB(e.declarationProvider, t, i, !1, n), f("decl.title", "Declarations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? f("decl.noResultWord", "No declaration found for '{0}'", e.word) : f("decl.generic.noResults", "No declaration found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeDeclarationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleDeclarations;
  }
}
var jh;
os((jh = class extends pV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: jh.id,
      title: {
        ...ni("actions.goToDeclaration.label", "Go to Declaration"),
        mnemonicTitle: f({ key: "miGotoDeclaration", comment: ["&& denotes a mnemonic"] }, "Go to &&Declaration")
      },
      precondition: ne.and(R.hasDeclarationProvider, R.isInEmbeddedEditor.toNegated()),
      menu: [{
        id: Qe.EditorContext,
        group: "navigation",
        order: 1.3
      }, {
        id: Qe.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? f("decl.noResultWord", "No declaration found for '{0}'", e.word) : f("decl.generic.noResults", "No declaration found");
  }
}, jh.id = "editor.action.revealDeclaration", jh));
os(class extends pV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.peekDeclaration",
      title: ni("actions.peekDecl.label", "Peek Declaration"),
      precondition: ne.and(R.hasDeclarationProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      menu: {
        id: Qe.EditorContextPeek,
        group: "peek",
        order: 3
      }
    });
  }
});
class AV extends Ul {
  async _getLocationModel(e, t, i, n) {
    return new Cs(await oB(e.typeDefinitionProvider, t, i, !1, n), f("typedef.title", "Type Definitions"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? f("goToTypeDefinition.noResultWord", "No type definition found for '{0}'", e.word) : f("goToTypeDefinition.generic.noResults", "No type definition found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeTypeDefinitionCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleTypeDefinitions;
  }
}
var Yh;
os((Yh = class extends AV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Yh.ID,
      title: {
        ...ni("actions.goToTypeDefinition.label", "Go to Type Definition"),
        mnemonicTitle: f({ key: "miGotoTypeDefinition", comment: ["&& denotes a mnemonic"] }, "Go to &&Type Definition")
      },
      precondition: R.hasTypeDefinitionProvider,
      keybinding: {
        when: R.editorTextFocus,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: Qe.EditorContext,
        group: "navigation",
        order: 1.4
      }, {
        id: Qe.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 3
      }]
    });
  }
}, Yh.ID = "editor.action.goToTypeDefinition", Yh));
var Kh;
os((Kh = class extends AV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: Kh.ID,
      title: ni("actions.peekTypeDefinition.label", "Peek Type Definition"),
      precondition: ne.and(R.hasTypeDefinitionProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      menu: {
        id: Qe.EditorContextPeek,
        group: "peek",
        order: 4
      }
    });
  }
}, Kh.ID = "editor.action.peekTypeDefinition", Kh));
class _V extends Ul {
  async _getLocationModel(e, t, i, n) {
    return new Cs(await sB(e.implementationProvider, t, i, !1, n), f("impl.title", "Implementations"));
  }
  _getNoResultFoundMessage(e) {
    return e && e.word ? f("goToImplementation.noResultWord", "No implementation found for '{0}'", e.word) : f("goToImplementation.generic.noResults", "No implementation found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeImplementationCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleImplementations;
  }
}
var Jh;
os((Jh = class extends _V {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: Jh.ID,
      title: {
        ...ni("actions.goToImplementation.label", "Go to Implementations"),
        mnemonicTitle: f({ key: "miGotoImplementation", comment: ["&& denotes a mnemonic"] }, "Go to &&Implementations")
      },
      precondition: R.hasImplementationProvider,
      keybinding: {
        when: R.editorTextFocus,
        primary: 2118,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: Qe.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: Qe.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 4
      }]
    });
  }
}, Jh.ID = "editor.action.goToImplementation", Jh));
var qh;
os((qh = class extends _V {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: qh.ID,
      title: ni("actions.peekImplementation.label", "Peek Implementations"),
      precondition: ne.and(R.hasImplementationProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: R.editorTextFocus,
        primary: 3142,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: {
        id: Qe.EditorContextPeek,
        group: "peek",
        order: 5
      }
    });
  }
}, qh.ID = "editor.action.peekImplementation", qh));
class bV extends Ul {
  _getNoResultFoundMessage(e) {
    return e ? f("references.no", "No references found for '{0}'", e.word) : f("references.noGeneric", "No references found");
  }
  _getAlternativeCommand(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).alternativeReferenceCommand;
  }
  _getGoToPreference(e) {
    return e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
}
os(class extends bV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !1,
      muteMessage: !1
    }, {
      id: "editor.action.goToReferences",
      title: {
        ...ni("goToReferences.label", "Go to References"),
        mnemonicTitle: f({ key: "miGotoReference", comment: ["&& denotes a mnemonic"] }, "Go to &&References")
      },
      precondition: ne.and(R.hasReferenceProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      keybinding: {
        when: R.editorTextFocus,
        primary: 1094,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menu: [{
        id: Qe.EditorContext,
        group: "navigation",
        order: 1.45
      }, {
        id: Qe.MenubarGoMenu,
        precondition: null,
        group: "4_symbol_nav",
        order: 5
      }]
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Cs(await J_(e.referenceProvider, t, i, !0, !1, n), f("ref.title", "References"));
  }
});
os(class extends bV {
  constructor() {
    super({
      openToSide: !1,
      openInPeek: !0,
      muteMessage: !1
    }, {
      id: "editor.action.referenceSearch.trigger",
      title: ni("references.action.label", "Peek References"),
      precondition: ne.and(R.hasReferenceProvider, ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated()),
      menu: {
        id: Qe.EditorContextPeek,
        group: "peek",
        order: 6
      }
    });
  }
  async _getLocationModel(e, t, i, n) {
    return new Cs(await J_(e.referenceProvider, t, i, !1, !1, n), f("ref.title", "References"));
  }
});
class zde extends Ul {
  constructor(e, t, i) {
    super(e, {
      id: "editor.action.goToLocation",
      title: ni("label.generic", "Go to Any Symbol"),
      precondition: ne.and(ns.notInPeekEditor, R.isInEmbeddedEditor.toNegated())
    }), this._references = t, this._gotoMultipleBehaviour = i;
  }
  async _getLocationModel(e, t, i, n) {
    return new Cs(this._references, f("generic.title", "Locations"));
  }
  _getNoResultFoundMessage(e) {
    return e && f("generic.noResult", "No results for '{0}'", e.word) || "";
  }
  _getGoToPreference(e) {
    return this._gotoMultipleBehaviour ?? e.getOption(
      58
      /* EditorOption.gotoLocation */
    ).multipleReferences;
  }
  _getAlternativeCommand() {
    return "";
  }
}
mt.registerCommand({
  id: "editor.action.goToLocations",
  metadata: {
    description: "Go to locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: _e },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" },
      { name: "noResultsMessage", description: "Human readable message that shows when locations is empty." }
    ]
  },
  handler: async (s, e, t, i, n, o, r) => {
    jt(_e.isUri(e)), jt(F.isIPosition(t)), jt(Array.isArray(i)), jt(typeof n > "u" || typeof n == "string"), jt(typeof r > "u" || typeof r == "boolean");
    const a = s.get(Nt), l = await a.openCodeEditor({ resource: e }, a.getFocusedCodeEditor());
    if (rV(l))
      return l.setPosition(t), l.revealPositionInCenterIfOutsideViewport(
        t,
        0
        /* ScrollType.Smooth */
      ), l.invokeWithinContext((c) => {
        const d = new class extends zde {
          _getNoResultFoundMessage(h) {
            return o || super._getNoResultFoundMessage(h);
          }
        }({
          muteMessage: !o,
          openInPeek: !!r,
          openToSide: !1
        }, i, n);
        c.get(ke).invokeFunction(d.run.bind(d), l);
      });
  }
});
mt.registerCommand({
  id: "editor.action.peekLocations",
  metadata: {
    description: "Peek locations from a position in a file",
    args: [
      { name: "uri", description: "The text document in which to start", constraint: _e },
      { name: "position", description: "The position at which to start", constraint: F.isIPosition },
      { name: "locations", description: "An array of locations.", constraint: Array },
      { name: "multiple", description: "Define what to do when having multiple results, either `peek`, `gotoAndPeek`, or `goto`" }
    ]
  },
  handler: async (s, e, t, i, n) => {
    s.get(bi).executeCommand("editor.action.goToLocations", e, t, i, n, void 0, !0);
  }
});
mt.registerCommand({
  id: "editor.action.findReferences",
  handler: (s, e, t) => {
    jt(_e.isUri(e)), jt(F.isIPosition(t));
    const i = s.get(ye), n = s.get(Nt);
    return n.openCodeEditor({ resource: e }, n.getFocusedCodeEditor()).then((o) => {
      if (!rV(o) || !o.hasModel())
        return;
      const r = __.get(o);
      if (!r)
        return;
      const a = ir((c) => J_(i.referenceProvider, o.getModel(), F.lift(t), !1, !1, c).then((d) => new Cs(d, f("ref.title", "References")))), l = new E(t.lineNumber, t.column, t.lineNumber, t.column);
      return Promise.resolve(r.toggleWidget(l, a, !1));
    });
  }
});
mt.registerCommandAlias("editor.action.showReferences", "editor.action.peekLocations");
var Ude = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hx = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Sp, Jc;
let b_ = (Jc = class {
  constructor(e, t, i, n) {
    this.textModelResolverService = t, this.languageService = i, this.languageFeaturesService = n, this.toUnhook = new X(), this.toUnhookForKeyboard = new X(), this.currentWordAtPosition = null, this.previousPromise = null, this.editor = e, this.linkDecorations = this.editor.createDecorationsCollection();
    const o = new lV(e);
    this.toUnhook.add(o), this.toUnhook.add(o.onMouseMoveOrRelevantKeyDown(([r, a]) => {
      this.startFindDefinitionFromMouse(r, a ?? void 0);
    })), this.toUnhook.add(o.onExecute((r) => {
      this.isEnabled(r) && this.gotoDefinition(r.target.position, r.hasSideBySideModifier).catch((a) => {
        Pe(a);
      }).finally(() => {
        this.removeLinkDecorations();
      });
    })), this.toUnhook.add(o.onCancel(() => {
      this.removeLinkDecorations(), this.currentWordAtPosition = null;
    }));
  }
  static get(e) {
    return e.getContribution(Sp.ID);
  }
  async startFindDefinitionFromCursor(e) {
    await this.startFindDefinition(e), this.toUnhookForKeyboard.add(this.editor.onDidChangeCursorPosition(() => {
      this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear();
    })), this.toUnhookForKeyboard.add(this.editor.onKeyDown((t) => {
      t && (this.currentWordAtPosition = null, this.removeLinkDecorations(), this.toUnhookForKeyboard.clear());
    }));
  }
  startFindDefinitionFromMouse(e, t) {
    if (e.target.type === 9 && this.linkDecorations.length > 0)
      return;
    if (!this.editor.hasModel() || !this.isEnabled(e, t)) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    const i = e.target.position;
    this.startFindDefinition(i);
  }
  async startFindDefinition(e) {
    this.toUnhookForKeyboard.clear();
    const t = e ? this.editor.getModel()?.getWordAtPosition(e) : null;
    if (!t) {
      this.currentWordAtPosition = null, this.removeLinkDecorations();
      return;
    }
    if (this.currentWordAtPosition && this.currentWordAtPosition.startColumn === t.startColumn && this.currentWordAtPosition.endColumn === t.endColumn && this.currentWordAtPosition.word === t.word)
      return;
    this.currentWordAtPosition = t;
    const i = new Wce(
      this.editor,
      15
      /* CodeEditorStateFlag.Scroll */
    );
    this.previousPromise && (this.previousPromise.cancel(), this.previousPromise = null), this.previousPromise = ir((r) => this.findDefinition(e, r));
    let n;
    try {
      n = await this.previousPromise;
    } catch (r) {
      Pe(r);
      return;
    }
    if (!n || !n.length || !i.validate(this.editor)) {
      this.removeLinkDecorations();
      return;
    }
    const o = n[0].originSelectionRange ? E.lift(n[0].originSelectionRange) : new E(e.lineNumber, t.startColumn, e.lineNumber, t.endColumn);
    if (n.length > 1) {
      let r = o;
      for (const { originSelectionRange: a } of n)
        a && (r = E.plusRange(r, a));
      this.addDecoration(r, new Vo().appendText(f("multipleResults", "Click to show {0} definitions.", n.length)));
    } else {
      const r = n[0];
      if (!r.uri)
        return;
      this.textModelResolverService.createModelReference(r.uri).then((a) => {
        if (!a.object || !a.object.textEditorModel) {
          a.dispose();
          return;
        }
        const { object: { textEditorModel: l } } = a, { startLineNumber: c } = r.range;
        if (c < 1 || c > l.getLineCount()) {
          a.dispose();
          return;
        }
        const d = this.getPreviewValue(l, c, r), h = this.languageService.guessLanguageIdByFilepathOrFirstLine(l.uri);
        this.addDecoration(o, d ? new Vo().appendCodeblock(h || "", d) : void 0), a.dispose();
      });
    }
  }
  getPreviewValue(e, t, i) {
    let n = i.range;
    return n.endLineNumber - n.startLineNumber >= Sp.MAX_SOURCE_PREVIEW_LINES && (n = this.getPreviewRangeBasedOnIndentation(e, t)), this.stripIndentationFromPreviewRange(e, t, n);
  }
  stripIndentationFromPreviewRange(e, t, i) {
    let o = e.getLineFirstNonWhitespaceColumn(t);
    for (let a = t + 1; a < i.endLineNumber; a++) {
      const l = e.getLineFirstNonWhitespaceColumn(a);
      o = Math.min(o, l);
    }
    return e.getValueInRange(i).replace(new RegExp(`^\\s{${o - 1}}`, "gm"), "").trim();
  }
  getPreviewRangeBasedOnIndentation(e, t) {
    const i = e.getLineFirstNonWhitespaceColumn(t), n = Math.min(e.getLineCount(), t + Sp.MAX_SOURCE_PREVIEW_LINES);
    let o = t + 1;
    for (; o < n; o++) {
      const r = e.getLineFirstNonWhitespaceColumn(o);
      if (i === r)
        break;
    }
    return new E(t, 1, o + 1, 1);
  }
  addDecoration(e, t) {
    const i = {
      range: e,
      options: {
        description: "goto-definition-link",
        inlineClassName: "goto-definition-link",
        hoverMessage: t
      }
    };
    this.linkDecorations.set([i]);
  }
  removeLinkDecorations() {
    this.linkDecorations.clear();
  }
  isEnabled(e, t) {
    return this.editor.hasModel() && e.isLeftClick && e.isNoneOrSingleMouseDown && e.target.type === 6 && !(e.target.detail.injectedText?.options instanceof dd) && (e.hasTriggerModifier || (t ? t.keyCodeIsTriggerKey : !1)) && this.languageFeaturesService.definitionProvider.has(this.editor.getModel());
  }
  findDefinition(e, t) {
    const i = this.editor.getModel();
    return i ? MS(this.languageFeaturesService.definitionProvider, i, e, !1, t) : Promise.resolve(null);
  }
  gotoDefinition(e, t) {
    return this.editor.setPosition(e), this.editor.invokeWithinContext((i) => {
      const n = !t && this.editor.getOption(
        89
        /* EditorOption.definitionLinkOpensInPeek */
      ) && !this.isInPeekEditor(i);
      return new q_({ openToSide: t, openInPeek: n, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(i);
    });
  }
  isInPeekEditor(e) {
    const t = e.get(Se);
    return ns.inPeekEditor.getValue(t);
  }
  dispose() {
    this.toUnhook.dispose(), this.toUnhookForKeyboard.dispose();
  }
}, Sp = Jc, Jc.ID = "editor.contrib.gotodefinitionatposition", Jc.MAX_SOURCE_PREVIEW_LINES = 8, Jc);
b_ = Sp = Ude([
  hx(1, Zs),
  hx(2, si),
  hx(3, ye)
], b_);
rs(
  b_.ID,
  b_,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
const Qde = "editor.action.inlineSuggest.showPrevious", Gde = "editor.action.inlineSuggest.showNext";
var rB = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Uo = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, zw;
let FP = class extends V {
  constructor(e, t, i) {
    super(), this.editor = e, this.model = t, this.instantiationService = i, this.alwaysShowToolbar = $t(this, this.editor.onDidChangeConfiguration, () => this.editor.getOption(
      62
      /* EditorOption.inlineSuggest */
    ).showToolbar === "always"), this.sessionPosition = void 0, this.position = De(this, (n) => {
      const o = this.model.read(n)?.primaryGhostText.read(n);
      if (!this.alwaysShowToolbar.read(n) || !o || o.parts.length === 0)
        return this.sessionPosition = void 0, null;
      const r = o.parts[0].column;
      this.sessionPosition && this.sessionPosition.lineNumber !== o.lineNumber && (this.sessionPosition = void 0);
      const a = new F(o.lineNumber, Math.min(r, this.sessionPosition?.column ?? Number.MAX_SAFE_INTEGER));
      return this.sessionPosition = a, a;
    }), this._register(Yo((n, o) => {
      const r = this.model.read(n);
      if (!r || !this.alwaysShowToolbar.read(n))
        return;
      const a = Uu((c, d) => {
        const h = d.add(this.instantiationService.createInstance(jv, this.editor, !0, this.position, r.selectedInlineCompletionIndex, r.inlineCompletionsCount, r.activeCommands));
        return e.addContentWidget(h), d.add(we(() => e.removeContentWidget(h))), d.add(et((u) => {
          this.position.read(u) && r.lastTriggerKind.read(u) !== Rx.Explicit && r.triggerExplicitly();
        })), h;
      }), l = O3(this, (c, d) => !!this.position.read(c) || !!d);
      o.add(et((c) => {
        l.read(c) && a.read(c);
      }));
    }));
  }
};
FP = rB([
  Uo(2, ke)
], FP);
const jde = Rt("inline-suggestion-hints-next", Z.chevronRight, f("parameterHintsNextIcon", "Icon for show next parameter hint.")), Yde = Rt("inline-suggestion-hints-previous", Z.chevronLeft, f("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var qc;
let jv = (qc = class extends V {
  static get dropDownVisible() {
    return this._dropDownVisible;
  }
  createCommandAction(e, t, i) {
    const n = new Ks(e, t, i, !0, () => this._commandService.executeCommand(e)), o = this.keybindingService.lookupKeybinding(e, this._contextKeyService);
    let r = t;
    return o && (r = f({ key: "content", comment: ["A label", "A keybinding"] }, "{0} ({1})", t, o.getLabel())), n.tooltip = r, n;
  }
  constructor(e, t, i, n, o, r, a, l, c, d, h) {
    super(), this.editor = e, this.withBorder = t, this._position = i, this._currentSuggestionIdx = n, this._suggestionCount = o, this._extraCommands = r, this._commandService = a, this.keybindingService = c, this._contextKeyService = d, this._menuService = h, this.id = `InlineSuggestionHintsContentWidget${zw.id++}`, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this.nodes = it("div.inlineSuggestionsHints", { className: this.withBorder ? ".withBorder" : "" }, [
      it("div@toolBar")
    ]), this.previousAction = this.createCommandAction(Qde, f("previous", "Previous"), pe.asClassName(Yde)), this.availableSuggestionCountAction = new Ks("inlineSuggestionHints.availableSuggestionCount", "", void 0, !1), this.nextAction = this.createCommandAction(Gde, f("next", "Next"), pe.asClassName(jde)), this.inlineCompletionsActionsMenus = this._register(this._menuService.createMenu(Qe.InlineCompletionsActions, this._contextKeyService)), this.clearAvailableSuggestionCountLabelDebounced = this._register(new zt(() => {
      this.availableSuggestionCountAction.label = "";
    }, 100)), this.disableButtonsDebounced = this._register(new zt(() => {
      this.previousAction.enabled = this.nextAction.enabled = !1;
    }, 100)), this.toolBar = this._register(l.createInstance(mI, this.nodes.toolBar, Qe.InlineSuggestionToolbar, {
      menuOptions: { renderShortTitle: !0 },
      toolbarOptions: { primaryGroup: (u) => u.startsWith("primary") },
      actionViewItemProvider: (u, g) => {
        if (u instanceof bo)
          return l.createInstance(Jde, u, void 0);
        if (u === this.availableSuggestionCountAction) {
          const m = new Kde(void 0, u, { label: !0, icon: !1 });
          return m.setClass("availableSuggestionCount"), m;
        }
      },
      telemetrySource: "InlineSuggestionToolbar"
    })), this.toolBar.setPrependedPrimaryActions([
      this.previousAction,
      this.availableSuggestionCountAction,
      this.nextAction
    ]), this._register(this.toolBar.onDidChangeDropdownVisibility((u) => {
      zw._dropDownVisible = u;
    })), this._register(et((u) => {
      this._position.read(u), this.editor.layoutContentWidget(this);
    })), this._register(et((u) => {
      const g = this._suggestionCount.read(u), m = this._currentSuggestionIdx.read(u);
      g !== void 0 ? (this.clearAvailableSuggestionCountLabelDebounced.cancel(), this.availableSuggestionCountAction.label = `${m + 1}/${g}`) : this.clearAvailableSuggestionCountLabelDebounced.schedule(), g !== void 0 && g > 1 ? (this.disableButtonsDebounced.cancel(), this.previousAction.enabled = this.nextAction.enabled = !0) : this.disableButtonsDebounced.schedule();
    })), this._register(et((u) => {
      const m = this._extraCommands.read(u).map((p) => ({
        class: void 0,
        id: p.id,
        enabled: !0,
        tooltip: p.tooltip || "",
        label: p.title,
        run: (A) => this._commandService.executeCommand(p.id)
      }));
      for (const [p, A] of this.inlineCompletionsActionsMenus.getActions())
        for (const _ of A)
          _ instanceof bo && m.push(_);
      m.length > 0 && m.unshift(new Ri()), this.toolBar.setAdditionalSecondaryActions(m);
    }));
  }
  getId() {
    return this.id;
  }
  getDomNode() {
    return this.nodes.root;
  }
  getPosition() {
    return {
      position: this._position.get(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ],
      positionAffinity: 3
    };
  }
}, zw = qc, qc._dropDownVisible = !1, qc.id = 0, qc);
jv = zw = rB([
  Uo(6, bi),
  Uo(7, ke),
  Uo(8, bt),
  Uo(9, Se),
  Uo(10, sr)
], jv);
class Kde extends nm {
  constructor() {
    super(...arguments), this._className = void 0;
  }
  setClass(e) {
    this._className = e;
  }
  render(e) {
    super.render(e), this._className && e.classList.add(this._className);
  }
  updateTooltip() {
  }
}
class Jde extends Su {
  updateLabel() {
    const e = this._keybindingService.lookupKeybinding(this._action.id, this._contextKeyService);
    if (!e)
      return super.updateLabel();
    if (this.label) {
      const t = it("div.keybinding").root;
      this._register(new j_(t, Us, { disableTitle: !0, ...nie })).set(e), this.label.textContent = this._action.label, this.label.appendChild(t), this.label.classList.add("inlineSuggestionStatusBarItemLabel");
    }
  }
  updateTooltip() {
  }
}
let mI = class extends Fv {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, { resetMenu: t, ...i }, n, o, r, a, l, c), this.menuId = t, this.options2 = i, this.menuService = n, this.contextKeyService = o, this.menu = this._store.add(this.menuService.createMenu(this.menuId, this.contextKeyService, { emitEventsForSubmenuChanges: !0 })), this.additionalActions = [], this.prependedPrimaryActions = [], this._store.add(this.menu.onDidChange(() => this.updateToolbar())), this.updateToolbar();
  }
  updateToolbar() {
    const e = [], t = [];
    UN(this.menu, this.options2?.menuOptions, { primary: e, secondary: t }, this.options2?.toolbarOptions?.primaryGroup, this.options2?.toolbarOptions?.shouldInlineSubmenu, this.options2?.toolbarOptions?.useSeparatorsInPrimaryActions), t.push(...this.additionalActions), e.unshift(...this.prependedPrimaryActions), this.setActions(e, t);
  }
  setPrependedPrimaryActions(e) {
    pi(this.prependedPrimaryActions, e, (t, i) => t === i) || (this.prependedPrimaryActions = e, this.updateToolbar());
  }
  setAdditionalSecondaryActions(e) {
    pi(this.additionalActions, e, (t, i) => t === i) || (this.additionalActions = e, this.updateToolbar());
  }
};
mI = rB([
  Uo(3, sr),
  Uo(4, Se),
  Uo(5, ar),
  Uo(6, bt),
  Uo(7, bi),
  Uo(8, eo)
], mI);
function NS(s, e, t) {
  const i = ui(s);
  return !(e < i.left || e > i.left + i.width || t < i.top || t > i.top + i.height);
}
let qde = class {
  constructor(e, t, i) {
    this.value = e, this.isComplete = t, this.hasLoadingMessage = i;
  }
};
class wV extends V {
  constructor(e, t) {
    super(), this._editor = e, this._computer = t, this._onResult = this._register(new B()), this.onResult = this._onResult.event, this._firstWaitScheduler = this._register(new zt(() => this._triggerAsyncComputation(), 0)), this._secondWaitScheduler = this._register(new zt(() => this._triggerSyncComputation(), 0)), this._loadingMessageScheduler = this._register(new zt(() => this._triggerLoadingMessage(), 0)), this._state = 0, this._asyncIterable = null, this._asyncIterableDone = !1, this._result = [];
  }
  dispose() {
    this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), super.dispose();
  }
  get _hoverTime() {
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).delay;
  }
  get _firstWaitTime() {
    return this._hoverTime / 2;
  }
  get _secondWaitTime() {
    return this._hoverTime - this._firstWaitTime;
  }
  get _loadingMessageTime() {
    return 3 * this._hoverTime;
  }
  _setState(e, t = !0) {
    this._state = e, t && this._fireResult();
  }
  _triggerAsyncComputation() {
    this._setState(
      2
      /* HoverOperationState.SecondWait */
    ), this._secondWaitScheduler.schedule(this._secondWaitTime), this._computer.computeAsync ? (this._asyncIterableDone = !1, this._asyncIterable = o6((e) => this._computer.computeAsync(e)), (async () => {
      try {
        for await (const e of this._asyncIterable)
          e && (this._result.push(e), this._fireResult());
        this._asyncIterableDone = !0, (this._state === 3 || this._state === 4) && this._setState(
          0
          /* HoverOperationState.Idle */
        );
      } catch (e) {
        Pe(e);
      }
    })()) : this._asyncIterableDone = !0;
  }
  _triggerSyncComputation() {
    this._computer.computeSync && (this._result = this._result.concat(this._computer.computeSync())), this._setState(
      this._asyncIterableDone ? 0 : 3
      /* HoverOperationState.WaitingForAsync */
    );
  }
  _triggerLoadingMessage() {
    this._state === 3 && this._setState(
      4
      /* HoverOperationState.WaitingForAsyncShowingLoading */
    );
  }
  _fireResult() {
    if (this._state === 1 || this._state === 2)
      return;
    const e = this._state === 0, t = this._state === 4;
    this._onResult.fire(new qde(this._result.slice(0), e, t));
  }
  start(e) {
    if (e === 0)
      this._state === 0 && (this._setState(
        1
        /* HoverOperationState.FirstWait */
      ), this._firstWaitScheduler.schedule(this._firstWaitTime), this._loadingMessageScheduler.schedule(this._loadingMessageTime));
    else
      switch (this._state) {
        case 0:
          this._triggerAsyncComputation(), this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
        case 2:
          this._secondWaitScheduler.cancel(), this._triggerSyncComputation();
          break;
      }
  }
  cancel() {
    this._firstWaitScheduler.cancel(), this._secondWaitScheduler.cancel(), this._loadingMessageScheduler.cancel(), this._asyncIterable && (this._asyncIterable.cancel(), this._asyncIterable = null), this._result = [], this._setState(0, !1);
  }
}
class ux {
  constructor(e, t, i, n) {
    this.priority = e, this.range = t, this.initialMousePosX = i, this.initialMousePosY = n, this.type = 1;
  }
  equals(e) {
    return e.type === 1 && this.range.equalsRange(e.range);
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 1 && t.lineNumber === this.range.startLineNumber;
  }
}
class $de {
  constructor(e, t, i, n, o, r) {
    this.priority = e, this.owner = t, this.range = i, this.initialMousePosX = n, this.initialMousePosY = o, this.supportsMarkerHover = r, this.type = 2;
  }
  equals(e) {
    return e.type === 2 && this.owner === e.owner;
  }
  canAdoptVisibleHover(e, t) {
    return e.type === 2 && this.owner === e.owner;
  }
}
class w_ {
  constructor(e) {
    this.renderedHoverParts = e;
  }
  dispose() {
    for (const e of this.renderedHoverParts)
      e.dispose();
  }
}
const aB = new class {
  constructor() {
    this._participants = [];
  }
  register(e) {
    this._participants.push(e);
  }
  getAll() {
    return this._participants;
  }
}();
class lB {
  constructor() {
    this._onDidWillResize = new B(), this.onDidWillResize = this._onDidWillResize.event, this._onDidResize = new B(), this.onDidResize = this._onDidResize.event, this._sashListener = new X(), this._size = new at(0, 0), this._minSize = new at(0, 0), this._maxSize = new at(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER), this.domNode = document.createElement("div"), this._eastSash = new rn(this.domNode, { getVerticalSashLeft: () => this._size.width }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._westSash = new rn(this.domNode, { getVerticalSashLeft: () => 0 }, {
      orientation: 0
      /* Orientation.VERTICAL */
    }), this._northSash = new rn(this.domNode, { getHorizontalSashTop: () => 0 }, { orientation: 1, orthogonalEdge: $C.North }), this._southSash = new rn(this.domNode, { getHorizontalSashTop: () => this._size.height }, { orientation: 1, orthogonalEdge: $C.South }), this._northSash.orthogonalStartSash = this._westSash, this._northSash.orthogonalEndSash = this._eastSash, this._southSash.orthogonalStartSash = this._westSash, this._southSash.orthogonalEndSash = this._eastSash;
    let e, t = 0, i = 0;
    this._sashListener.add(te.any(this._northSash.onDidStart, this._eastSash.onDidStart, this._southSash.onDidStart, this._westSash.onDidStart)(() => {
      e === void 0 && (this._onDidWillResize.fire(), e = this._size, t = 0, i = 0);
    })), this._sashListener.add(te.any(this._northSash.onDidEnd, this._eastSash.onDidEnd, this._southSash.onDidEnd, this._westSash.onDidEnd)(() => {
      e !== void 0 && (e = void 0, t = 0, i = 0, this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(this._eastSash.onDidChange((n) => {
      e && (i = n.currentX - n.startX, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, east: !0 }));
    })), this._sashListener.add(this._westSash.onDidChange((n) => {
      e && (i = -(n.currentX - n.startX), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, west: !0 }));
    })), this._sashListener.add(this._northSash.onDidChange((n) => {
      e && (t = -(n.currentY - n.startY), this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, north: !0 }));
    })), this._sashListener.add(this._southSash.onDidChange((n) => {
      e && (t = n.currentY - n.startY, this.layout(e.height + t, e.width + i), this._onDidResize.fire({ dimension: this._size, done: !1, south: !0 }));
    })), this._sashListener.add(te.any(this._eastSash.onDidReset, this._westSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._size.height, this._preferredSize.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    })), this._sashListener.add(te.any(this._northSash.onDidReset, this._southSash.onDidReset)((n) => {
      this._preferredSize && (this.layout(this._preferredSize.height, this._size.width), this._onDidResize.fire({ dimension: this._size, done: !0 }));
    }));
  }
  dispose() {
    this._northSash.dispose(), this._southSash.dispose(), this._eastSash.dispose(), this._westSash.dispose(), this._sashListener.dispose(), this._onDidResize.dispose(), this._onDidWillResize.dispose(), this.domNode.remove();
  }
  enableSashes(e, t, i, n) {
    this._northSash.state = e ? 3 : 0, this._eastSash.state = t ? 3 : 0, this._southSash.state = i ? 3 : 0, this._westSash.state = n ? 3 : 0;
  }
  layout(e = this.size.height, t = this.size.width) {
    const { height: i, width: n } = this._minSize, { height: o, width: r } = this._maxSize;
    e = Math.max(i, Math.min(o, e)), t = Math.max(n, Math.min(r, t));
    const a = new at(t, e);
    at.equals(a, this._size) || (this.domNode.style.height = e + "px", this.domNode.style.width = t + "px", this._size = a, this._northSash.layout(), this._eastSash.layout(), this._southSash.layout(), this._westSash.layout());
  }
  clearSashHoverState() {
    this._eastSash.clearSashHoverState(), this._westSash.clearSashHoverState(), this._northSash.clearSashHoverState(), this._southSash.clearSashHoverState();
  }
  get size() {
    return this._size;
  }
  set maxSize(e) {
    this._maxSize = e;
  }
  get maxSize() {
    return this._maxSize;
  }
  set minSize(e) {
    this._minSize = e;
  }
  get minSize() {
    return this._minSize;
  }
  set preferredSize(e) {
    this._preferredSize = e;
  }
  get preferredSize() {
    return this._preferredSize;
  }
}
const Xde = 30, Zde = 24;
class ehe extends V {
  constructor(e, t = new at(10, 10)) {
    super(), this._editor = e, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._resizableNode = this._register(new lB()), this._contentPosition = null, this._isResizing = !1, this._resizableNode.domNode.style.position = "absolute", this._resizableNode.minSize = at.lift(t), this._resizableNode.layout(t.height, t.width), this._resizableNode.enableSashes(!0, !0, !0, !0), this._register(this._resizableNode.onDidResize((i) => {
      this._resize(new at(i.dimension.width, i.dimension.height)), i.done && (this._isResizing = !1);
    })), this._register(this._resizableNode.onDidWillResize(() => {
      this._isResizing = !0;
    }));
  }
  get isResizing() {
    return this._isResizing;
  }
  getDomNode() {
    return this._resizableNode.domNode;
  }
  getPosition() {
    return this._contentPosition;
  }
  get position() {
    return this._contentPosition?.position ? F.lift(this._contentPosition.position) : void 0;
  }
  _availableVerticalSpaceAbove(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    return !t || !i ? void 0 : ui(t).top + i.top - Xde;
  }
  _availableVerticalSpaceBelow(e) {
    const t = this._editor.getDomNode(), i = this._editor.getScrolledVisiblePosition(e);
    if (!t || !i)
      return;
    const n = ui(t), o = mu(t.ownerDocument.body), r = n.top + i.top + i.height;
    return o.height - r - Zde;
  }
  _findPositionPreference(e, t) {
    const i = Math.min(this._availableVerticalSpaceBelow(t) ?? 1 / 0, e), n = Math.min(this._availableVerticalSpaceAbove(t) ?? 1 / 0, e), o = Math.min(Math.max(n, i), e), r = Math.min(e, o);
    let a;
    return this._editor.getOption(
      60
      /* EditorOption.hover */
    ).above ? a = r <= n ? 1 : 2 : a = r <= i ? 2 : 1, a === 1 ? this._resizableNode.enableSashes(!0, !0, !1, !1) : this._resizableNode.enableSashes(!1, !0, !0, !1), a;
  }
  _resize(e) {
    this._resizableNode.layout(e.height, e.width);
  }
}
var the = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qb = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Xr;
const OP = 30, ihe = 6;
var $c;
let pI = ($c = class extends ehe {
  get isVisibleFromKeyboard() {
    return this._renderedHover?.source === 1;
  }
  get isVisible() {
    return this._hoverVisibleKey.get() ?? !1;
  }
  get isFocused() {
    return this._hoverFocusedKey.get() ?? !1;
  }
  constructor(e, t, i, n, o) {
    const r = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8, a = 150, l = new at(a, r);
    super(e, l), this._configurationService = i, this._accessibilityService = n, this._keybindingService = o, this._hover = this._register(new yN()), this._onDidResize = this._register(new B()), this.onDidResize = this._onDidResize.event, this._minimumSize = l, this._hoverVisibleKey = R.hoverVisible.bindTo(t), this._hoverFocusedKey = R.hoverFocused.bindTo(t), K(this._resizableNode.domNode, this._hover.containerDomNode), this._resizableNode.domNode.style.zIndex = "50", this._register(this._editor.onDidLayoutChange(() => {
      this.isVisible && this._updateMaxDimensions();
    })), this._register(this._editor.onDidChangeConfiguration((d) => {
      d.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    }));
    const c = this._register(Wl(this._resizableNode.domNode));
    this._register(c.onDidFocus(() => {
      this._hoverFocusedKey.set(!0);
    })), this._register(c.onDidBlur(() => {
      this._hoverFocusedKey.set(!1);
    })), this._setRenderedHover(void 0), this._editor.addContentWidget(this);
  }
  dispose() {
    super.dispose(), this._renderedHover?.dispose(), this._editor.removeContentWidget(this);
  }
  getId() {
    return Xr.ID;
  }
  static _applyDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, o = typeof i == "number" ? `${i}px` : i;
    e.style.width = n, e.style.height = o;
  }
  _setContentsDomNodeDimensions(e, t) {
    const i = this._hover.contentsDomNode;
    return Xr._applyDimensions(i, e, t);
  }
  _setContainerDomNodeDimensions(e, t) {
    const i = this._hover.containerDomNode;
    return Xr._applyDimensions(i, e, t);
  }
  _setHoverWidgetDimensions(e, t) {
    this._setContentsDomNodeDimensions(e, t), this._setContainerDomNodeDimensions(e, t), this._layoutContentWidget();
  }
  static _applyMaxDimensions(e, t, i) {
    const n = typeof t == "number" ? `${t}px` : t, o = typeof i == "number" ? `${i}px` : i;
    e.style.maxWidth = n, e.style.maxHeight = o;
  }
  _setHoverWidgetMaxDimensions(e, t) {
    Xr._applyMaxDimensions(this._hover.contentsDomNode, e, t), Xr._applyMaxDimensions(this._hover.containerDomNode, e, t), this._hover.containerDomNode.style.setProperty("--vscode-hover-maxWidth", typeof e == "number" ? `${e}px` : e), this._layoutContentWidget();
  }
  _setAdjustedHoverWidgetDimensions(e) {
    this._setHoverWidgetMaxDimensions("none", "none");
    const t = e.width, i = e.height;
    this._setHoverWidgetDimensions(t, i);
  }
  _updateResizableNodeMaxDimensions() {
    const e = this._findMaximumRenderingWidth() ?? 1 / 0, t = this._findMaximumRenderingHeight() ?? 1 / 0;
    this._resizableNode.maxSize = new at(e, t), this._setHoverWidgetMaxDimensions(e, t);
  }
  _resize(e) {
    Xr._lastDimensions = new at(e.width, e.height), this._setAdjustedHoverWidgetDimensions(e), this._resizableNode.layout(e.height, e.width), this._updateResizableNodeMaxDimensions(), this._hover.scrollbar.scanDomNode(), this._editor.layoutContentWidget(this), this._onDidResize.fire();
  }
  _findAvailableSpaceVertically() {
    const e = this._renderedHover?.showAtPosition;
    if (e)
      return this._positionPreference === 1 ? this._availableVerticalSpaceAbove(e) : this._availableVerticalSpaceBelow(e);
  }
  _findMaximumRenderingHeight() {
    const e = this._findAvailableSpaceVertically();
    if (!e)
      return;
    let t = ihe;
    return Array.from(this._hover.contentsDomNode.children).forEach((i) => {
      t += i.clientHeight;
    }), Math.min(e, t);
  }
  _isHoverTextOverflowing() {
    this._hover.containerDomNode.style.setProperty("--vscode-hover-whiteSpace", "nowrap"), this._hover.containerDomNode.style.setProperty("--vscode-hover-sourceWhiteSpace", "nowrap");
    const e = Array.from(this._hover.contentsDomNode.children).some((t) => t.scrollWidth > t.clientWidth);
    return this._hover.containerDomNode.style.removeProperty("--vscode-hover-whiteSpace"), this._hover.containerDomNode.style.removeProperty("--vscode-hover-sourceWhiteSpace"), e;
  }
  _findMaximumRenderingWidth() {
    if (!this._editor || !this._editor.hasModel())
      return;
    const e = this._isHoverTextOverflowing(), t = typeof this._contentWidth > "u" ? 0 : this._contentWidth - 2;
    return e || this._hover.containerDomNode.clientWidth < t ? mu(this._hover.containerDomNode.ownerDocument.body).width - 14 : this._hover.containerDomNode.clientWidth + 2;
  }
  isMouseGettingCloser(e, t) {
    if (!this._renderedHover)
      return !1;
    if (this._renderedHover.initialMousePosX === void 0 || this._renderedHover.initialMousePosY === void 0)
      return this._renderedHover.initialMousePosX = e, this._renderedHover.initialMousePosY = t, !1;
    const i = ui(this.getDomNode());
    this._renderedHover.closestMouseDistance === void 0 && (this._renderedHover.closestMouseDistance = PP(this._renderedHover.initialMousePosX, this._renderedHover.initialMousePosY, i.left, i.top, i.width, i.height));
    const n = PP(e, t, i.left, i.top, i.width, i.height);
    return n > this._renderedHover.closestMouseDistance + 4 ? !1 : (this._renderedHover.closestMouseDistance = Math.min(this._renderedHover.closestMouseDistance, n), !0);
  }
  _setRenderedHover(e) {
    this._renderedHover?.dispose(), this._renderedHover = e, this._hoverVisibleKey.set(!!e), this._hover.containerDomNode.classList.toggle("hidden", !e);
  }
  _updateFont() {
    const { fontSize: e, lineHeight: t } = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), i = this._hover.contentsDomNode;
    i.style.fontSize = `${e}px`, i.style.lineHeight = `${t / e}`, Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((o) => this._editor.applyFontInfo(o));
  }
  _updateContent(e) {
    const t = this._hover.contentsDomNode;
    t.style.paddingBottom = "", t.textContent = "", t.appendChild(e);
  }
  _layoutContentWidget() {
    this._editor.layoutContentWidget(this), this._hover.onContentsChanged();
  }
  _updateMaxDimensions() {
    const e = Math.max(this._editor.getLayoutInfo().height / 4, 250, Xr._lastDimensions.height), t = Math.max(this._editor.getLayoutInfo().width * 0.66, 500, Xr._lastDimensions.width);
    this._setHoverWidgetMaxDimensions(t, e);
  }
  _render(e) {
    this._setRenderedHover(e), this._updateFont(), this._updateContent(e.domNode), this._updateMaxDimensions(), this.onContentsChanged(), this._editor.render();
  }
  getPosition() {
    return this._renderedHover ? {
      position: this._renderedHover.showAtPosition,
      secondaryPosition: this._renderedHover.showAtSecondaryPosition,
      positionAffinity: this._renderedHover.shouldAppearBeforeContent ? 3 : void 0,
      preference: [
        this._positionPreference ?? 1
        /* ContentWidgetPositionPreference.ABOVE */
      ]
    } : null;
  }
  show(e) {
    if (!this._editor || !this._editor.hasModel())
      return;
    this._render(e);
    const t = _h(this._hover.containerDomNode), i = e.showAtPosition;
    this._positionPreference = this._findPositionPreference(t, i) ?? 1, this.onContentsChanged(), e.shouldFocus && this._hover.containerDomNode.focus(), this._onDidResize.fire();
    const o = this._hover.containerDomNode.ownerDocument.activeElement === this._hover.containerDomNode && d3(this._configurationService.getValue("accessibility.verbosity.hover") === !0 && this._accessibilityService.isScreenReaderOptimized(), this._keybindingService.lookupKeybinding("editor.action.accessibleView")?.getAriaLabel() ?? "");
    o && (this._hover.contentsDomNode.ariaLabel = this._hover.contentsDomNode.textContent + ", " + o);
  }
  hide() {
    if (!this._renderedHover)
      return;
    const e = this._renderedHover.shouldFocus || this._hoverFocusedKey.get();
    this._setRenderedHover(void 0), this._resizableNode.maxSize = new at(1 / 0, 1 / 0), this._resizableNode.clearSashHoverState(), this._hoverFocusedKey.set(!1), this._editor.layoutContentWidget(this), e && this._editor.focus();
  }
  _removeConstraintsRenderNormally() {
    const e = this._editor.getLayoutInfo();
    this._resizableNode.layout(e.height, e.width), this._setHoverWidgetDimensions("auto", "auto");
  }
  setMinimumDimensions(e) {
    this._minimumSize = new at(Math.max(this._minimumSize.width, e.width), Math.max(this._minimumSize.height, e.height)), this._updateMinimumWidth();
  }
  _updateMinimumWidth() {
    const e = typeof this._contentWidth > "u" ? this._minimumSize.width : Math.min(this._contentWidth, this._minimumSize.width);
    this._resizableNode.minSize = new at(e, this._minimumSize.height);
  }
  onContentsChanged() {
    this._removeConstraintsRenderNormally();
    const e = this._hover.containerDomNode;
    let t = _h(e), i = Rs(e);
    if (this._resizableNode.layout(t, i), this._setHoverWidgetDimensions(i, t), t = _h(e), i = Rs(e), this._contentWidth = i, this._updateMinimumWidth(), this._resizableNode.layout(t, i), this._renderedHover?.showAtPosition) {
      const n = _h(this._hover.containerDomNode);
      this._positionPreference = this._findPositionPreference(n, this._renderedHover.showAtPosition);
    }
    this._layoutContentWidget();
  }
  focus() {
    this._hover.containerDomNode.focus();
  }
  scrollUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t.lineHeight });
  }
  scrollDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    );
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t.lineHeight });
  }
  scrollLeft() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e - OP });
  }
  scrollRight() {
    const e = this._hover.scrollbar.getScrollPosition().scrollLeft;
    this._hover.scrollbar.setScrollPosition({ scrollLeft: e + OP });
  }
  pageUp() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e - t });
  }
  pageDown() {
    const e = this._hover.scrollbar.getScrollPosition().scrollTop, t = this._hover.scrollbar.getScrollDimensions().height;
    this._hover.scrollbar.setScrollPosition({ scrollTop: e + t });
  }
  goToTop() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: 0 });
  }
  goToBottom() {
    this._hover.scrollbar.setScrollPosition({ scrollTop: this._hover.scrollbar.getScrollDimensions().scrollHeight });
  }
}, Xr = $c, $c.ID = "editor.contrib.resizableContentHoverWidget", $c._lastDimensions = new at(0, 0), $c);
pI = Xr = the([
  qb(1, Se),
  qb(2, ht),
  qb(3, Lo),
  qb(4, bt)
], pI);
function PP(s, e, t, i, n, o) {
  const r = t + n / 2, a = i + o / 2, l = Math.max(Math.abs(s - r) - n / 2, 0), c = Math.max(Math.abs(e - a) - o / 2, 0);
  return Math.sqrt(l * l + c * c);
}
class Yv {
  get anchor() {
    return this._anchor;
  }
  set anchor(e) {
    this._anchor = e;
  }
  get shouldFocus() {
    return this._shouldFocus;
  }
  set shouldFocus(e) {
    this._shouldFocus = e;
  }
  get source() {
    return this._source;
  }
  set source(e) {
    this._source = e;
  }
  get insistOnKeepingHoverVisible() {
    return this._insistOnKeepingHoverVisible;
  }
  set insistOnKeepingHoverVisible(e) {
    this._insistOnKeepingHoverVisible = e;
  }
  constructor(e, t) {
    this._editor = e, this._participants = t, this._anchor = null, this._shouldFocus = !1, this._source = 0, this._insistOnKeepingHoverVisible = !1;
  }
  static _getLineDecorations(e, t) {
    if (t.type !== 1 && !t.supportsMarkerHover)
      return [];
    const i = e.getModel(), n = t.range.startLineNumber;
    if (n > i.getLineCount())
      return [];
    const o = i.getLineMaxColumn(n);
    return e.getLineDecorations(n).filter((r) => {
      if (r.options.isWholeLine)
        return !0;
      const a = r.range.startLineNumber === n ? r.range.startColumn : 1, l = r.range.endLineNumber === n ? r.range.endColumn : o;
      if (r.options.showIfCollapsed) {
        if (a > t.range.startColumn + 1 || t.range.endColumn - 1 > l)
          return !1;
      } else if (a > t.range.startColumn || t.range.endColumn > l)
        return !1;
      return !0;
    });
  }
  computeAsync(e) {
    const t = this._anchor;
    if (!this._editor.hasModel() || !t)
      return Gs.EMPTY;
    const i = Yv._getLineDecorations(this._editor, t);
    return Gs.merge(this._participants.map((n) => n.computeAsync ? n.computeAsync(t, i, e) : Gs.EMPTY));
  }
  computeSync() {
    if (!this._editor.hasModel() || !this._anchor)
      return [];
    const e = Yv._getLineDecorations(this._editor, this._anchor);
    let t = [];
    for (const i of this._participants)
      t = t.concat(i.computeSync(this._anchor, e));
    return mm(t);
  }
}
class CV {
  constructor(e, t, i) {
    this.anchor = e, this.hoverParts = t, this.isComplete = i;
  }
  filter(e) {
    const t = this.hoverParts.filter((i) => i.isValidForHoverAnchor(e));
    return t.length === this.hoverParts.length ? this : new nhe(this, this.anchor, t, this.isComplete);
  }
}
class nhe extends CV {
  constructor(e, t, i, n) {
    super(t, i, n), this.original = e;
  }
  filter(e) {
    return this.original.filter(e);
  }
}
var she = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ohe = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const HP = de;
let AI = class extends V {
  get hasContent() {
    return this._hasContent;
  }
  constructor(e) {
    super(), this._keybindingService = e, this.actions = [], this._hasContent = !1, this.hoverElement = HP("div.hover-row.status-bar"), this.hoverElement.tabIndex = 0, this.actionsElement = K(this.hoverElement, HP("div.actions"));
  }
  addAction(e) {
    const t = this._keybindingService.lookupKeybinding(e.commandId), i = t ? t.getLabel() : null;
    this._hasContent = !0;
    const n = this._register(K0.render(this.actionsElement, e, i));
    return this.actions.push(n), n;
  }
  append(e) {
    const t = K(this.actionsElement, e);
    return this._hasContent = !0, t;
  }
};
AI = she([
  ohe(0, bt)
], AI);
class rhe {
  constructor(e, t, i) {
    this.provider = e, this.hover = t, this.ordinal = i;
  }
}
async function ahe(s, e, t, i, n) {
  const o = await Promise.resolve(s.provideHover(t, i, n)).catch(xs);
  if (!(!o || !lhe(o)))
    return new rhe(s, o, e);
}
function cB(s, e, t, i, n = !1) {
  const r = s.ordered(e, n).map((a, l) => ahe(a, l, e, t, i));
  return Gs.fromPromises(r).coalesce();
}
function vV(s, e, t, i, n = !1) {
  return cB(s, e, t, i, n).map((o) => o.hover).toPromise();
}
or("_executeHoverProvider", (s, e, t) => {
  const i = s.get(ye);
  return vV(i.hoverProvider, e, t, ct.None);
});
or("_executeHoverProvider_recursive", (s, e, t) => {
  const i = s.get(ye);
  return vV(i.hoverProvider, e, t, ct.None, !0);
});
function lhe(s) {
  const e = typeof s.range < "u", t = typeof s.contents < "u" && s.contents && s.contents.length > 0;
  return e && t;
}
var che = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Pd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Yg = de, dhe = Rt("hover-increase-verbosity", Z.add, f("increaseHoverVerbosity", "Icon for increaseing hover verbosity.")), hhe = Rt("hover-decrease-verbosity", Z.remove, f("decreaseHoverVerbosity", "Icon for decreasing hover verbosity."));
class Dr {
  constructor(e, t, i, n, o, r = void 0) {
    this.owner = e, this.range = t, this.contents = i, this.isBeforeContent = n, this.ordinal = o, this.source = r;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
class SV {
  constructor(e, t, i) {
    this.hover = e, this.hoverProvider = t, this.hoverPosition = i;
  }
  supportsVerbosityAction(e) {
    switch (e) {
      case fs.Increase:
        return this.hover.canIncreaseVerbosity ?? !1;
      case fs.Decrease:
        return this.hover.canDecreaseVerbosity ?? !1;
    }
  }
}
let C_ = class {
  constructor(e, t, i, n, o, r, a, l) {
    this._editor = e, this._languageService = t, this._openerService = i, this._configurationService = n, this._languageFeaturesService = o, this._keybindingService = r, this._hoverService = a, this._commandService = l, this.hoverOrdinal = 3;
  }
  createLoadingMessage(e) {
    return new Dr(this, e.range, [new Vo().appendText(f("modesContentHover.loading", "Loading..."))], !1, 2e3);
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
    let a = 1e3;
    const l = i.getLineLength(n), c = i.getLanguageIdAtPosition(e.range.startLineNumber, e.range.startColumn), d = this._editor.getOption(
      118
      /* EditorOption.stopRenderingLineAfter */
    ), h = this._configurationService.getValue("editor.maxTokenizationLineLength", {
      overrideIdentifier: c
    });
    let u = !1;
    d >= 0 && l > d && e.range.startColumn >= d && (u = !0, r.push(new Dr(this, e.range, [{
      value: f("stopped rendering", "Rendering paused for long line for performance reasons. This can be configured via `editor.stopRenderingLineAfter`.")
    }], !1, a++))), !u && typeof h == "number" && l >= h && r.push(new Dr(this, e.range, [{
      value: f("too many characters", "Tokenization is skipped for long lines for performance reasons. This can be configured via `editor.maxTokenizationLineLength`.")
    }], !1, a++));
    let g = !1;
    for (const m of t) {
      const p = m.range.startLineNumber === n ? m.range.startColumn : 1, A = m.range.endLineNumber === n ? m.range.endColumn : o, _ = m.options.hoverMessage;
      if (!_ || Xf(_))
        continue;
      m.options.beforeContentClassName && (g = !0);
      const b = new E(e.range.startLineNumber, p, e.range.startLineNumber, A);
      r.push(new Dr(this, b, H4(_), g, a++));
    }
    return r;
  }
  computeAsync(e, t, i) {
    if (!this._editor.hasModel() || e.type !== 1)
      return Gs.EMPTY;
    const n = this._editor.getModel(), o = this._languageFeaturesService.hoverProvider;
    return o.has(n) ? this._getMarkdownHovers(o, n, e, i) : Gs.EMPTY;
  }
  _getMarkdownHovers(e, t, i, n) {
    const o = i.range.getStartPosition();
    return cB(e, t, o, n).filter((l) => !Xf(l.hover.contents)).map((l) => {
      const c = l.hover.range ? E.lift(l.hover.range) : i.range, d = new SV(l.hover, l.provider, o);
      return new Dr(this, c, l.hover.contents, !1, l.ordinal, d);
    });
  }
  renderHoverParts(e, t) {
    return this._renderedHoverParts = new uhe(t, e.fragment, this, this._editor, this._languageService, this._openerService, this._commandService, this._keybindingService, this._hoverService, this._configurationService, e.onContentsChanged), this._renderedHoverParts;
  }
  updateMarkdownHoverVerbosityLevel(e, t, i) {
    return Promise.resolve(this._renderedHoverParts?.updateMarkdownHoverPartVerbosityLevel(e, t, i));
  }
};
C_ = che([
  Pd(1, si),
  Pd(2, lr),
  Pd(3, ht),
  Pd(4, ye),
  Pd(5, bt),
  Pd(6, jl),
  Pd(7, bi)
], C_);
class $b {
  constructor(e, t, i) {
    this.hoverPart = e, this.hoverElement = t, this.disposables = i;
  }
  dispose() {
    this.disposables.dispose();
  }
}
class uhe {
  constructor(e, t, i, n, o, r, a, l, c, d, h) {
    this._hoverParticipant = i, this._editor = n, this._languageService = o, this._openerService = r, this._commandService = a, this._keybindingService = l, this._hoverService = c, this._configurationService = d, this._onFinishedRendering = h, this._ongoingHoverOperations = /* @__PURE__ */ new Map(), this._disposables = new X(), this.renderedHoverParts = this._renderHoverParts(e, t, this._onFinishedRendering), this._disposables.add(we(() => {
      this.renderedHoverParts.forEach((u) => {
        u.dispose();
      }), this._ongoingHoverOperations.forEach((u) => {
        u.tokenSource.dispose(!0);
      });
    }));
  }
  _renderHoverParts(e, t, i) {
    return e.sort(_o((n) => n.ordinal, Ml)), e.map((n) => {
      const o = this._renderHoverPart(n, i);
      return t.appendChild(o.hoverElement), o;
    });
  }
  _renderHoverPart(e, t) {
    const i = this._renderMarkdownHover(e, t), n = i.hoverElement, o = e.source, r = new X();
    if (r.add(i), !o)
      return new $b(e, n, r);
    const a = o.supportsVerbosityAction(fs.Increase), l = o.supportsVerbosityAction(fs.Decrease);
    if (!a && !l)
      return new $b(e, n, r);
    const c = Yg("div.verbosity-actions");
    return n.prepend(c), r.add(this._renderHoverExpansionAction(c, fs.Increase, a)), r.add(this._renderHoverExpansionAction(c, fs.Decrease, l)), new $b(e, n, r);
  }
  _renderMarkdownHover(e, t) {
    return ghe(this._editor, e, this._languageService, this._openerService, t);
  }
  _renderHoverExpansionAction(e, t, i) {
    const n = new X(), o = t === fs.Increase, r = K(e, Yg(pe.asCSSSelector(o ? dhe : hhe)));
    r.tabIndex = 0;
    const a = new Kf("mouse", !1, { target: e, position: {
      hoverPosition: 0
      /* HoverPosition.LEFT */
    } }, this._configurationService, this._hoverService);
    if (n.add(this._hoverService.setupManagedHover(a, r, fhe(this._keybindingService, t))), !i)
      return r.classList.add("disabled"), n;
    r.classList.add("enabled");
    const l = () => this._commandService.executeCommand(t === fs.Increase ? ES : LS);
    return n.add(new h3(r, l)), n.add(new u3(r, l, [
      3,
      10
      /* KeyCode.Space */
    ])), n;
  }
  async updateMarkdownHoverPartVerbosityLevel(e, t, i = !0) {
    const n = this._editor.getModel();
    if (!n)
      return;
    const o = this._getRenderedHoverPartAtIndex(t), r = o?.hoverPart.source;
    if (!o || !r?.supportsVerbosityAction(e))
      return;
    const a = await this._fetchHover(r, n, e);
    if (!a)
      return;
    const l = new SV(a, r.hoverProvider, r.hoverPosition), c = o.hoverPart, d = new Dr(this._hoverParticipant, c.range, a.contents, c.isBeforeContent, c.ordinal, l), h = this._renderHoverPart(d, this._onFinishedRendering);
    return this._replaceRenderedHoverPartAtIndex(t, h, d), i && this._focusOnHoverPartWithIndex(t), {
      hoverPart: d,
      hoverElement: h.hoverElement
    };
  }
  async _fetchHover(e, t, i) {
    let n = i === fs.Increase ? 1 : -1;
    const o = e.hoverProvider, r = this._ongoingHoverOperations.get(o);
    r && (r.tokenSource.cancel(), n += r.verbosityDelta);
    const a = new vs();
    this._ongoingHoverOperations.set(o, { verbosityDelta: n, tokenSource: a });
    const l = { verbosityRequest: { verbosityDelta: n, previousHover: e.hover } };
    let c;
    try {
      c = await Promise.resolve(o.provideHover(t, e.hoverPosition, a.token, l));
    } catch (d) {
      xs(d);
    }
    return a.dispose(), this._ongoingHoverOperations.delete(o), c;
  }
  _replaceRenderedHoverPartAtIndex(e, t, i) {
    if (e >= this.renderedHoverParts.length || e < 0)
      return;
    const n = this.renderedHoverParts[e], o = n.hoverElement, r = t.hoverElement, a = Array.from(r.children);
    o.replaceChildren(...a);
    const l = new $b(i, o, t.disposables);
    o.focus(), n.dispose(), this.renderedHoverParts[e] = l;
  }
  _focusOnHoverPartWithIndex(e) {
    this.renderedHoverParts[e].hoverElement.focus();
  }
  _getRenderedHoverPartAtIndex(e) {
    return this.renderedHoverParts[e];
  }
  dispose() {
    this._disposables.dispose();
  }
}
function ghe(s, e, t, i, n) {
  const o = new X(), r = Yg("div.hover-row"), a = Yg("div.hover-row-contents");
  r.appendChild(a);
  const l = e.contents;
  for (const d of l) {
    if (Xf(d))
      continue;
    const h = Yg("div.markdown-hover"), u = K(h, Yg("div.hover-contents")), g = o.add(new Cu({ editor: s }, t, i));
    o.add(g.onDidRenderAsync(() => {
      u.className = "hover-contents code-hover-contents", n();
    }));
    const m = o.add(g.render(d));
    u.appendChild(m.element), a.appendChild(h);
  }
  return {
    hoverPart: e,
    hoverElement: r,
    dispose() {
      o.dispose();
    }
  };
}
function fhe(s, e) {
  switch (e) {
    case fs.Increase: {
      const t = s.lookupKeybinding(ES);
      return t ? f("increaseVerbosityWithKb", "Increase Hover Verbosity ({0})", t.getLabel()) : f("increaseVerbosity", "Increase Hover Verbosity");
    }
    case fs.Decrease: {
      const t = s.lookupKeybinding(LS);
      return t ? f("decreaseVerbosityWithKb", "Decrease Hover Verbosity ({0})", t.getLabel()) : f("decreaseVerbosity", "Decrease Hover Verbosity");
    }
  }
}
var yV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _I = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let Kv = class {
  constructor(e) {
    this._editorWorkerService = e;
  }
  async provideDocumentColors(e, t) {
    return this._editorWorkerService.computeDefaultDocumentColors(e.uri);
  }
  provideColorPresentations(e, t, i) {
    const n = t.range, o = t.color, r = o.alpha, a = new Y(new qe(Math.round(255 * o.red), Math.round(255 * o.green), Math.round(255 * o.blue), r)), l = r ? Y.Format.CSS.formatRGB(a) : Y.Format.CSS.formatRGBA(a), c = r ? Y.Format.CSS.formatHSL(a) : Y.Format.CSS.formatHSLA(a), d = r ? Y.Format.CSS.formatHex(a) : Y.Format.CSS.formatHexA(a), h = [];
    return h.push({ label: l, textEdit: { range: n, text: l } }), h.push({ label: c, textEdit: { range: n, text: c } }), h.push({ label: d, textEdit: { range: n, text: d } }), h;
  }
};
Kv = yV([
  _I(0, Sd)
], Kv);
let bI = class extends V {
  constructor(e, t) {
    super(), this._register(e.colorProvider.register("*", new Kv(t)));
  }
};
bI = yV([
  _I(0, ye),
  _I(1, Sd)
], bI);
p8(bI);
async function xV(s, e, t, i = !0) {
  return dB(new mhe(), s, e, t, i);
}
function EV(s, e, t, i) {
  return Promise.resolve(t.provideColorPresentations(s, e, i));
}
class mhe {
  constructor() {
  }
  async compute(e, t, i, n) {
    const o = await e.provideDocumentColors(t, i);
    if (Array.isArray(o))
      for (const r of o)
        n.push({ colorInfo: r, provider: e });
    return Array.isArray(o);
  }
}
class phe {
  constructor() {
  }
  async compute(e, t, i, n) {
    const o = await e.provideDocumentColors(t, i);
    if (Array.isArray(o))
      for (const r of o)
        n.push({ range: r.range, color: [r.color.red, r.color.green, r.color.blue, r.color.alpha] });
    return Array.isArray(o);
  }
}
class Ahe {
  constructor(e) {
    this.colorInfo = e;
  }
  async compute(e, t, i, n) {
    const o = await e.provideColorPresentations(t, this.colorInfo, ct.None);
    return Array.isArray(o) && n.push(...o), Array.isArray(o);
  }
}
async function dB(s, e, t, i, n) {
  let o = !1, r;
  const a = [], l = e.ordered(t);
  for (let c = l.length - 1; c >= 0; c--) {
    const d = l[c];
    if (d instanceof Kv)
      r = d;
    else
      try {
        await s.compute(d, t, i, a) && (o = !0);
      } catch (h) {
        xs(h);
      }
  }
  return o ? a : r && n ? (await s.compute(r, t, i, a), a) : [];
}
function LV(s, e) {
  const { colorProvider: t } = s.get(ye), i = s.get(Fi).getModel(e);
  if (!i)
    throw Go();
  const n = s.get(ht).getValue("editor.defaultColorDecorators", { resource: e });
  return { model: i, colorProviderRegistry: t, isDefaultColorDecoratorsEnabled: n };
}
mt.registerCommand("_executeDocumentColorProvider", function(s, ...e) {
  const [t] = e;
  if (!(t instanceof _e))
    throw Go();
  const { model: i, colorProviderRegistry: n, isDefaultColorDecoratorsEnabled: o } = LV(s, t);
  return dB(new phe(), n, i, ct.None, o);
});
mt.registerCommand("_executeColorPresentationProvider", function(s, ...e) {
  const [t, i] = e, { uri: n, range: o } = i;
  if (!(n instanceof _e) || !Array.isArray(t) || t.length !== 4 || !E.isIRange(o))
    throw Go();
  const { model: r, colorProviderRegistry: a, isDefaultColorDecoratorsEnabled: l } = LV(s, n), [c, d, h, u] = t;
  return dB(new Ahe({ range: o, color: { red: c, green: d, blue: h, alpha: u } }), a, r, ct.None, l);
});
var _he = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gx = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, wI;
const bhe = /* @__PURE__ */ Object.create({});
var Xc;
let dm = (Xc = class extends V {
  // ms
  constructor(e, t, i, n) {
    super(), this._editor = e, this._configurationService = t, this._languageFeaturesService = i, this._localToDispose = this._register(new X()), this._decorationsIds = [], this._colorDatas = /* @__PURE__ */ new Map(), this._colorDecoratorIds = this._editor.createDecorationsCollection(), this._ruleFactory = new _v(this._editor), this._decoratorLimitReporter = new whe(), this._colorDecorationClassRefs = this._register(new X()), this._debounceInformation = n.for(i.colorProvider, "Document Colors", { min: wI.RECOMPUTE_TIME }), this._register(e.onDidChangeModel(() => {
      this._isColorDecoratorsEnabled = this.isEnabled(), this.updateColors();
    })), this._register(e.onDidChangeModelLanguage(() => this.updateColors())), this._register(i.colorProvider.onDidChange(() => this.updateColors())), this._register(e.onDidChangeConfiguration((o) => {
      const r = this._isColorDecoratorsEnabled;
      this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
        148
        /* EditorOption.defaultColorDecorators */
      );
      const a = r !== this._isColorDecoratorsEnabled || o.hasChanged(
        21
        /* EditorOption.colorDecoratorsLimit */
      ), l = o.hasChanged(
        148
        /* EditorOption.defaultColorDecorators */
      );
      (a || l) && (this._isColorDecoratorsEnabled ? this.updateColors() : this.removeAllDecorations());
    })), this._timeoutTimer = null, this._computePromise = null, this._isColorDecoratorsEnabled = this.isEnabled(), this._isDefaultColorDecoratorsEnabled = this._editor.getOption(
      148
      /* EditorOption.defaultColorDecorators */
    ), this.updateColors();
  }
  isEnabled() {
    const e = this._editor.getModel();
    if (!e)
      return !1;
    const t = e.getLanguageId(), i = this._configurationService.getValue(t);
    if (i && typeof i == "object") {
      const n = i.colorDecorators;
      if (n && n.enable !== void 0 && !n.enable)
        return n.enable;
    }
    return this._editor.getOption(
      20
      /* EditorOption.colorDecorators */
    );
  }
  static get(e) {
    return e.getContribution(this.ID);
  }
  dispose() {
    this.stop(), this.removeAllDecorations(), super.dispose();
  }
  updateColors() {
    if (this.stop(), !this._isColorDecoratorsEnabled)
      return;
    const e = this._editor.getModel();
    !e || !this._languageFeaturesService.colorProvider.has(e) || (this._localToDispose.add(this._editor.onDidChangeModelContent(() => {
      this._timeoutTimer || (this._timeoutTimer = new nr(), this._timeoutTimer.cancelAndSet(() => {
        this._timeoutTimer = null, this.beginCompute();
      }, this._debounceInformation.get(e)));
    })), this.beginCompute());
  }
  async beginCompute() {
    this._computePromise = ir(async (e) => {
      const t = this._editor.getModel();
      if (!t)
        return [];
      const i = new es(!1), n = await xV(this._languageFeaturesService.colorProvider, t, e, this._isDefaultColorDecoratorsEnabled);
      return this._debounceInformation.update(t, i.elapsed()), n;
    });
    try {
      const e = await this._computePromise;
      this.updateDecorations(e), this.updateColorDecorators(e), this._computePromise = null;
    } catch (e) {
      Pe(e);
    }
  }
  stop() {
    this._timeoutTimer && (this._timeoutTimer.cancel(), this._timeoutTimer = null), this._computePromise && (this._computePromise.cancel(), this._computePromise = null), this._localToDispose.clear();
  }
  updateDecorations(e) {
    const t = e.map((i) => ({
      range: {
        startLineNumber: i.colorInfo.range.startLineNumber,
        startColumn: i.colorInfo.range.startColumn,
        endLineNumber: i.colorInfo.range.endLineNumber,
        endColumn: i.colorInfo.range.endColumn
      },
      options: He.EMPTY
    }));
    this._editor.changeDecorations((i) => {
      this._decorationsIds = i.deltaDecorations(this._decorationsIds, t), this._colorDatas = /* @__PURE__ */ new Map(), this._decorationsIds.forEach((n, o) => this._colorDatas.set(n, e[o]));
    });
  }
  updateColorDecorators(e) {
    this._colorDecorationClassRefs.clear();
    const t = [], i = this._editor.getOption(
      21
      /* EditorOption.colorDecoratorsLimit */
    );
    for (let o = 0; o < e.length && t.length < i; o++) {
      const { red: r, green: a, blue: l, alpha: c } = e[o].colorInfo.color, d = new qe(Math.round(r * 255), Math.round(a * 255), Math.round(l * 255), c), h = `rgba(${d.r}, ${d.g}, ${d.b}, ${d.a})`, u = this._colorDecorationClassRefs.add(this._ruleFactory.createClassNameRef({
        backgroundColor: h
      }));
      t.push({
        range: {
          startLineNumber: e[o].colorInfo.range.startLineNumber,
          startColumn: e[o].colorInfo.range.startColumn,
          endLineNumber: e[o].colorInfo.range.endLineNumber,
          endColumn: e[o].colorInfo.range.endColumn
        },
        options: {
          description: "colorDetector",
          before: {
            content: z7,
            inlineClassName: `${u.className} colorpicker-color-decoration`,
            inlineClassNameAffectsLetterSpacing: !0,
            attachedData: bhe
          }
        }
      });
    }
    const n = i < e.length ? i : !1;
    this._decoratorLimitReporter.update(e.length, n), this._colorDecoratorIds.set(t);
  }
  removeAllDecorations() {
    this._editor.removeDecorations(this._decorationsIds), this._decorationsIds = [], this._colorDecoratorIds.clear(), this._colorDecorationClassRefs.clear();
  }
  getColorData(e) {
    const t = this._editor.getModel();
    if (!t)
      return null;
    const i = t.getDecorationsInRange(E.fromPositions(e, e)).filter((n) => this._colorDatas.has(n.id));
    return i.length === 0 ? null : this._colorDatas.get(i[0].id);
  }
  isColorDecoration(e) {
    return this._colorDecoratorIds.has(e);
  }
}, wI = Xc, Xc.ID = "editor.contrib.colorDetector", Xc.RECOMPUTE_TIME = 1e3, Xc);
dm = wI = _he([
  gx(1, ht),
  gx(2, ye),
  gx(3, W0)
], dm);
class whe {
  constructor() {
    this._onDidChange = new B(), this._computed = 0, this._limited = !1;
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
rs(
  dm.ID,
  dm,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
class Che {
  get color() {
    return this._color;
  }
  set color(e) {
    this._color.equals(e) || (this._color = e, this._onDidChangeColor.fire(e));
  }
  get presentation() {
    return this.colorPresentations[this.presentationIndex];
  }
  get colorPresentations() {
    return this._colorPresentations;
  }
  set colorPresentations(e) {
    this._colorPresentations = e, this.presentationIndex > e.length - 1 && (this.presentationIndex = 0), this._onDidChangePresentation.fire(this.presentation);
  }
  constructor(e, t, i) {
    this.presentationIndex = i, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, this._onDidChangeColor = new B(), this.onDidChangeColor = this._onDidChangeColor.event, this._onDidChangePresentation = new B(), this.onDidChangePresentation = this._onDidChangePresentation.event, this.originalColor = e, this._color = e, this._colorPresentations = t;
  }
  selectNextColorPresentation() {
    this.presentationIndex = (this.presentationIndex + 1) % this.colorPresentations.length, this.flushColor(), this._onDidChangePresentation.fire(this.presentation);
  }
  guessColorPresentation(e, t) {
    let i = -1;
    for (let n = 0; n < this.colorPresentations.length; n++)
      if (t.toLowerCase() === this.colorPresentations[n].label) {
        i = n;
        break;
      }
    if (i === -1) {
      const n = t.split("(")[0].toLowerCase();
      for (let o = 0; o < this.colorPresentations.length; o++)
        if (this.colorPresentations[o].label.toLowerCase().startsWith(n)) {
          i = o;
          break;
        }
    }
    i !== -1 && i !== this.presentationIndex && (this.presentationIndex = i, this._onDidChangePresentation.fire(this.presentation));
  }
  flushColor() {
    this._onColorFlushed.fire(this._color);
  }
}
const zs = de;
class vhe extends V {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.showingStandaloneColorPicker = n, this._closeButton = null, this._domNode = zs(".colorpicker-header"), K(e, this._domNode), this._pickedColorNode = K(this._domNode, zs(".picked-color")), K(this._pickedColorNode, zs("span.codicon.codicon-color-mode")), this._pickedColorPresentation = K(this._pickedColorNode, document.createElement("span")), this._pickedColorPresentation.classList.add("picked-color-presentation");
    const o = f("clickToToggleColorOptions", "Click to toggle color options (rgb/hsl/hex)");
    this._pickedColorNode.setAttribute("title", o), this._originalColorNode = K(this._domNode, zs(".original-color")), this._originalColorNode.style.backgroundColor = Y.Format.CSS.format(this.model.originalColor) || "", this.backgroundColor = i.getColorTheme().getColor(vC) || Y.white, this._register(i.onDidColorThemeChange((r) => {
      this.backgroundColor = r.getColor(vC) || Y.white;
    })), this._register(U(this._pickedColorNode, ee.CLICK, () => this.model.selectNextColorPresentation())), this._register(U(this._originalColorNode, ee.CLICK, () => {
      this.model.color = this.model.originalColor, this.model.flushColor();
    })), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this._register(t.onDidChangePresentation(this.onDidChangePresentation, this)), this._pickedColorNode.style.backgroundColor = Y.Format.CSS.format(t.color) || "", this._pickedColorNode.classList.toggle("light", t.color.rgba.a < 0.5 ? this.backgroundColor.isLighter() : t.color.isLighter()), this.onDidChangeColor(this.model.color), this.showingStandaloneColorPicker && (this._domNode.classList.add("standalone-colorpicker"), this._closeButton = this._register(new She(this._domNode)));
  }
  get closeButton() {
    return this._closeButton;
  }
  get pickedColorNode() {
    return this._pickedColorNode;
  }
  get originalColorNode() {
    return this._originalColorNode;
  }
  onDidChangeColor(e) {
    this._pickedColorNode.style.backgroundColor = Y.Format.CSS.format(e) || "", this._pickedColorNode.classList.toggle("light", e.rgba.a < 0.5 ? this.backgroundColor.isLighter() : e.isLighter()), this.onDidChangePresentation();
  }
  onDidChangePresentation() {
    this._pickedColorPresentation.textContent = this.model.presentation ? this.model.presentation.label : "";
  }
}
class She extends V {
  constructor(e) {
    super(), this._onClicked = this._register(new B()), this.onClicked = this._onClicked.event, this._button = document.createElement("div"), this._button.classList.add("close-button"), K(e, this._button);
    const t = document.createElement("div");
    t.classList.add("close-button-inner-div"), K(this._button, t), K(t, zs(".button" + pe.asCSSSelector(Rt("color-picker-close", Z.close, f("closeIcon", "Icon to close the color picker"))))).classList.add("close-icon"), this._register(U(this._button, ee.CLICK, () => {
      this._onClicked.fire();
    }));
  }
}
class yhe extends V {
  constructor(e, t, i, n = !1) {
    super(), this.model = t, this.pixelRatio = i, this._insertButton = null, this._domNode = zs(".colorpicker-body"), K(e, this._domNode), this._saturationBox = new xhe(this._domNode, this.model, this.pixelRatio), this._register(this._saturationBox), this._register(this._saturationBox.onDidChange(this.onDidSaturationValueChange, this)), this._register(this._saturationBox.onColorFlushed(this.flushColor, this)), this._opacityStrip = new Ehe(this._domNode, this.model, n), this._register(this._opacityStrip), this._register(this._opacityStrip.onDidChange(this.onDidOpacityChange, this)), this._register(this._opacityStrip.onColorFlushed(this.flushColor, this)), this._hueStrip = new Lhe(this._domNode, this.model, n), this._register(this._hueStrip), this._register(this._hueStrip.onDidChange(this.onDidHueChange, this)), this._register(this._hueStrip.onColorFlushed(this.flushColor, this)), n && (this._insertButton = this._register(new khe(this._domNode)), this._domNode.classList.add("standalone-colorpicker"));
  }
  flushColor() {
    this.model.flushColor();
  }
  onDidSaturationValueChange({ s: e, v: t }) {
    const i = this.model.color.hsva;
    this.model.color = new Y(new _a(i.h, e, t, i.a));
  }
  onDidOpacityChange(e) {
    const t = this.model.color.hsva;
    this.model.color = new Y(new _a(t.h, t.s, t.v, e));
  }
  onDidHueChange(e) {
    const t = this.model.color.hsva, i = (1 - e) * 360;
    this.model.color = new Y(new _a(i === 360 ? 0 : i, t.s, t.v, t.a));
  }
  get domNode() {
    return this._domNode;
  }
  get saturationBox() {
    return this._saturationBox;
  }
  get enterButton() {
    return this._insertButton;
  }
  layout() {
    this._saturationBox.layout(), this._opacityStrip.layout(), this._hueStrip.layout();
  }
}
class xhe extends V {
  constructor(e, t, i) {
    super(), this.model = t, this.pixelRatio = i, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, this._domNode = zs(".saturation-wrap"), K(e, this._domNode), this._canvas = document.createElement("canvas"), this._canvas.className = "saturation-box", K(this._domNode, this._canvas), this.selection = zs(".saturation-selection"), K(this._domNode, this.selection), this.layout(), this._register(U(this._domNode, ee.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(this.model.onDidChangeColor(this.onDidChangeColor, this)), this.monitor = null;
  }
  get domNode() {
    return this._domNode;
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    this.monitor = this._register(new Cm());
    const t = ui(this._domNode);
    e.target !== this.selection && this.onDidChangePosition(e.offsetX, e.offsetY), this.monitor.startMonitoring(e.target, e.pointerId, e.buttons, (n) => this.onDidChangePosition(n.pageX - t.left, n.pageY - t.top), () => null);
    const i = U(e.target.ownerDocument, ee.POINTER_UP, () => {
      this._onColorFlushed.fire(), i.dispose(), this.monitor && (this.monitor.stopMonitoring(!0), this.monitor = null);
    }, !0);
  }
  onDidChangePosition(e, t) {
    const i = Math.max(0, Math.min(1, e / this.width)), n = Math.max(0, Math.min(1, 1 - t / this.height));
    this.paintSelection(i, n), this._onDidChange.fire({ s: i, v: n });
  }
  layout() {
    this.width = this._domNode.offsetWidth, this.height = this._domNode.offsetHeight, this._canvas.width = this.width * this.pixelRatio, this._canvas.height = this.height * this.pixelRatio, this.paint();
    const e = this.model.color.hsva;
    this.paintSelection(e.s, e.v);
  }
  paint() {
    const e = this.model.color.hsva, t = new Y(new _a(e.h, 1, 1, 1)), i = this._canvas.getContext("2d"), n = i.createLinearGradient(0, 0, this._canvas.width, 0);
    n.addColorStop(0, "rgba(255, 255, 255, 1)"), n.addColorStop(0.5, "rgba(255, 255, 255, 0.5)"), n.addColorStop(1, "rgba(255, 255, 255, 0)");
    const o = i.createLinearGradient(0, 0, 0, this._canvas.height);
    o.addColorStop(0, "rgba(0, 0, 0, 0)"), o.addColorStop(1, "rgba(0, 0, 0, 1)"), i.rect(0, 0, this._canvas.width, this._canvas.height), i.fillStyle = Y.Format.CSS.format(t), i.fill(), i.fillStyle = n, i.fill(), i.fillStyle = o, i.fill();
  }
  paintSelection(e, t) {
    this.selection.style.left = `${e * this.width}px`, this.selection.style.top = `${this.height - t * this.height}px`;
  }
  onDidChangeColor(e) {
    if (this.monitor && this.monitor.isMonitoring())
      return;
    this.paint();
    const t = e.hsva;
    this.paintSelection(t.s, t.v);
  }
}
class kV extends V {
  constructor(e, t, i = !1) {
    super(), this.model = t, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._onColorFlushed = new B(), this.onColorFlushed = this._onColorFlushed.event, i ? (this.domNode = K(e, zs(".standalone-strip")), this.overlay = K(this.domNode, zs(".standalone-overlay"))) : (this.domNode = K(e, zs(".strip")), this.overlay = K(this.domNode, zs(".overlay"))), this.slider = K(this.domNode, zs(".slider")), this.slider.style.top = "0px", this._register(U(this.domNode, ee.POINTER_DOWN, (n) => this.onPointerDown(n))), this._register(t.onDidChangeColor(this.onDidChangeColor, this)), this.layout();
  }
  layout() {
    this.height = this.domNode.offsetHeight - this.slider.offsetHeight;
    const e = this.getValue(this.model.color);
    this.updateSliderPosition(e);
  }
  onDidChangeColor(e) {
    const t = this.getValue(e);
    this.updateSliderPosition(t);
  }
  onPointerDown(e) {
    if (!e.target || !(e.target instanceof Element))
      return;
    const t = this._register(new Cm()), i = ui(this.domNode);
    this.domNode.classList.add("grabbing"), e.target !== this.slider && this.onDidChangeTop(e.offsetY), t.startMonitoring(e.target, e.pointerId, e.buttons, (o) => this.onDidChangeTop(o.pageY - i.top), () => null);
    const n = U(e.target.ownerDocument, ee.POINTER_UP, () => {
      this._onColorFlushed.fire(), n.dispose(), t.stopMonitoring(!0), this.domNode.classList.remove("grabbing");
    }, !0);
  }
  onDidChangeTop(e) {
    const t = Math.max(0, Math.min(1, 1 - e / this.height));
    this.updateSliderPosition(t), this._onDidChange.fire(t);
  }
  updateSliderPosition(e) {
    this.slider.style.top = `${(1 - e) * this.height}px`;
  }
}
class Ehe extends kV {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("opacity-strip"), this.onDidChangeColor(this.model.color);
  }
  onDidChangeColor(e) {
    super.onDidChangeColor(e);
    const { r: t, g: i, b: n } = e.rgba, o = new Y(new qe(t, i, n, 1)), r = new Y(new qe(t, i, n, 0));
    this.overlay.style.background = `linear-gradient(to bottom, ${o} 0%, ${r} 100%)`;
  }
  getValue(e) {
    return e.hsva.a;
  }
}
class Lhe extends kV {
  constructor(e, t, i = !1) {
    super(e, t, i), this.domNode.classList.add("hue-strip");
  }
  getValue(e) {
    return 1 - e.hsva.h / 360;
  }
}
class khe extends V {
  constructor(e) {
    super(), this._onClicked = this._register(new B()), this.onClicked = this._onClicked.event, this._button = K(e, document.createElement("button")), this._button.classList.add("insert-button"), this._button.textContent = "Insert", this._register(U(this._button, ee.CLICK, () => {
      this._onClicked.fire();
    }));
  }
  get button() {
    return this._button;
  }
}
class Dhe extends to {
  constructor(e, t, i, n, o = !1) {
    super(), this.model = t, this.pixelRatio = i, this._register(TA.getInstance(fe(e)).onDidChange(() => this.layout())), this._domNode = zs(".colorpicker-widget"), e.appendChild(this._domNode), this.header = this._register(new vhe(this._domNode, this.model, n, o)), this.body = this._register(new yhe(this._domNode, this.model, this.pixelRatio, o));
  }
  layout() {
    this.body.layout();
  }
  get domNode() {
    return this._domNode;
  }
}
var DV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, IV = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class Ihe {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n, this.forceShowAtRange = !0;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
let Jv = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this.hoverOrdinal = 2;
  }
  computeSync(e, t) {
    return [];
  }
  computeAsync(e, t, i) {
    return Gs.fromPromise(this._computeAsync(e, t, i));
  }
  async _computeAsync(e, t, i) {
    if (!this._editor.hasModel())
      return [];
    const n = dm.get(this._editor);
    if (!n)
      return [];
    for (const o of t) {
      if (!n.isColorDecoration(o))
        continue;
      const r = n.getColorData(o.range.getStartPosition());
      if (r)
        return [await MV(this, this._editor.getModel(), r.colorInfo, r.provider)];
    }
    return [];
  }
  renderHoverParts(e, t) {
    const i = NV(this, this._editor, this._themeService, t, e);
    if (!i)
      return new w_([]);
    this._colorPicker = i.colorPicker;
    const n = {
      hoverPart: i.hoverPart,
      hoverElement: this._colorPicker.domNode,
      dispose() {
        i.disposables.dispose();
      }
    };
    return new w_([n]);
  }
  handleResize() {
    this._colorPicker?.layout();
  }
  isColorPickerVisible() {
    return !!this._colorPicker;
  }
};
Jv = DV([
  IV(1, nn)
], Jv);
class Mhe {
  constructor(e, t, i, n) {
    this.owner = e, this.range = t, this.model = i, this.provider = n;
  }
}
let qv = class {
  constructor(e, t) {
    this._editor = e, this._themeService = t, this._color = null;
  }
  async createColorHover(e, t, i) {
    if (!this._editor.hasModel() || !dm.get(this._editor))
      return null;
    const o = await xV(i, this._editor.getModel(), ct.None);
    let r = null, a = null;
    for (const h of o) {
      const u = h.colorInfo;
      E.containsRange(u.range, e.range) && (r = u, a = h.provider);
    }
    const l = r ?? e, c = a ?? t, d = !!r;
    return { colorHover: await MV(this, this._editor.getModel(), l, c), foundInEditor: d };
  }
  async updateEditorModel(e) {
    if (!this._editor.hasModel())
      return;
    const t = e.model;
    let i = new E(e.range.startLineNumber, e.range.startColumn, e.range.endLineNumber, e.range.endColumn);
    this._color && (await Uw(this._editor.getModel(), t, this._color, i, e), i = TV(this._editor, i, t));
  }
  renderHoverParts(e, t) {
    return NV(this, this._editor, this._themeService, t, e);
  }
  set color(e) {
    this._color = e;
  }
  get color() {
    return this._color;
  }
};
qv = DV([
  IV(1, nn)
], qv);
async function MV(s, e, t, i) {
  const n = e.getValueInRange(t.range), { red: o, green: r, blue: a, alpha: l } = t.color, c = new qe(Math.round(o * 255), Math.round(r * 255), Math.round(a * 255), l), d = new Y(c), h = await EV(e, t, i, ct.None), u = new Che(d, [], 0);
  return u.colorPresentations = h || [], u.guessColorPresentation(d, n), s instanceof Jv ? new Ihe(s, E.lift(t.range), u, i) : new Mhe(s, E.lift(t.range), u, i);
}
function NV(s, e, t, i, n) {
  if (i.length === 0 || !e.hasModel())
    return;
  if (n.setMinimumDimensions) {
    const u = e.getOption(
      67
      /* EditorOption.lineHeight */
    ) + 8;
    n.setMinimumDimensions(new at(302, u));
  }
  const o = new X(), r = i[0], a = e.getModel(), l = r.model, c = o.add(new Dhe(n.fragment, l, e.getOption(
    144
    /* EditorOption.pixelRatio */
  ), t, s instanceof qv));
  let d = !1, h = new E(r.range.startLineNumber, r.range.startColumn, r.range.endLineNumber, r.range.endColumn);
  if (s instanceof qv) {
    const u = r.model.color;
    s.color = u, Uw(a, l, u, h, r), o.add(l.onColorFlushed((g) => {
      s.color = g;
    }));
  } else
    o.add(l.onColorFlushed(async (u) => {
      await Uw(a, l, u, h, r), d = !0, h = TV(e, h, l);
    }));
  return o.add(l.onDidChangeColor((u) => {
    Uw(a, l, u, h, r);
  })), o.add(e.onDidChangeModelContent((u) => {
    d ? d = !1 : (n.hide(), e.focus());
  })), { hoverPart: r, colorPicker: c, disposables: o };
}
function TV(s, e, t) {
  const i = [], n = t.presentation.textEdit ?? { range: e, text: t.presentation.label, forceMoveMarkers: !1 };
  i.push(n), t.presentation.additionalTextEdits && i.push(...t.presentation.additionalTextEdits);
  const o = E.lift(n.range), r = s.getModel()._setTrackedRange(
    null,
    o,
    3
    /* TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */
  );
  return s.executeEdits("colorpicker", i), s.pushUndoStop(), s.getModel()._getTrackedRange(r) ?? o;
}
async function Uw(s, e, t, i, n) {
  const o = await EV(s, {
    range: i,
    color: {
      red: t.rgba.r / 255,
      green: t.rgba.g / 255,
      blue: t.rgba.b / 255,
      alpha: t.rgba.a
    }
  }, n.provider, ct.None);
  e.colorPresentations = o || [];
}
class BV {
  constructor(e, t) {
    this.range = e, this.direction = t;
  }
}
class hB {
  constructor(e, t, i) {
    this.hint = e, this.anchor = t, this.provider = i, this._isResolved = !1;
  }
  with(e) {
    const t = new hB(this.hint, e.anchor, this.provider);
    return t._isResolved = this._isResolved, t._currentResolve = this._currentResolve, t;
  }
  async resolve(e) {
    if (typeof this.provider.resolveInlayHint == "function") {
      if (this._currentResolve)
        return await this._currentResolve, e.isCancellationRequested ? void 0 : this.resolve(e);
      this._isResolved || (this._currentResolve = this._doResolve(e).finally(() => this._currentResolve = void 0)), await this._currentResolve;
    }
  }
  async _doResolve(e) {
    try {
      const t = await Promise.resolve(this.provider.resolveInlayHint(this.hint, e));
      this.hint.tooltip = t?.tooltip ?? this.hint.tooltip, this.hint.label = t?.label ?? this.hint.label, this.hint.textEdits = t?.textEdits ?? this.hint.textEdits, this._isResolved = !0;
    } catch (t) {
      xs(t), this._isResolved = !1;
    }
  }
}
const lf = class lf {
  static async create(e, t, i, n) {
    const o = [], r = e.ordered(t).reverse().map((a) => i.map(async (l) => {
      try {
        const c = await a.provideInlayHints(t, l, n);
        (c?.hints.length || a.onDidChangeInlayHints) && o.push([c ?? lf._emptyInlayHintList, a]);
      } catch (c) {
        xs(c);
      }
    }));
    if (await Promise.all(r.flat()), n.isCancellationRequested || t.isDisposed())
      throw new _d();
    return new lf(i, o, t);
  }
  constructor(e, t, i) {
    this._disposables = new X(), this.ranges = e, this.provider = /* @__PURE__ */ new Set();
    const n = [];
    for (const [o, r] of t) {
      this._disposables.add(o), this.provider.add(r);
      for (const a of o.hints) {
        const l = i.validatePosition(a.position);
        let c = "before";
        const d = lf._getRangeAtPosition(i, l);
        let h;
        d.getStartPosition().isBefore(l) ? (h = E.fromPositions(d.getStartPosition(), l), c = "after") : (h = E.fromPositions(l, d.getEndPosition()), c = "before"), n.push(new hB(a, new BV(h, c), r));
      }
    }
    this.items = n.sort((o, r) => F.compare(o.hint.position, r.hint.position));
  }
  dispose() {
    this._disposables.dispose();
  }
  static _getRangeAtPosition(e, t) {
    const i = t.lineNumber, n = e.getWordAtPosition(t);
    if (n)
      return new E(i, n.startColumn, i, n.endColumn);
    e.tokenization.tokenizeIfCheap(i);
    const o = e.tokenization.getLineTokens(i), r = t.column - 1, a = o.findTokenIndexAtOffset(r);
    let l = o.getStartOffset(a), c = o.getEndOffset(a);
    return c - l === 1 && (l === r && a > 1 ? (l = o.getStartOffset(a - 1), c = o.getEndOffset(a - 1)) : c === r && a < o.getCount() - 1 && (l = o.getStartOffset(a + 1), c = o.getEndOffset(a + 1))), new E(i, l + 1, i, c + 1);
  }
};
lf._emptyInlayHintList = Object.freeze({ dispose() {
}, hints: [] });
let $v = lf;
function Nhe(s) {
  return _e.from({
    scheme: Ie.command,
    path: s.id,
    query: s.arguments && encodeURIComponent(JSON.stringify(s.arguments))
  }).toString();
}
const RV = function() {
  if (typeof crypto == "object" && typeof crypto.randomUUID == "function")
    return crypto.randomUUID.bind(crypto);
  let s;
  typeof crypto == "object" && typeof crypto.getRandomValues == "function" ? s = crypto.getRandomValues.bind(crypto) : s = function(i) {
    for (let n = 0; n < i.length; n++)
      i[n] = Math.floor(Math.random() * 256);
    return i;
  };
  const e = new Uint8Array(16), t = [];
  for (let i = 0; i < 256; i++)
    t.push(i.toString(16).padStart(2, "0"));
  return function() {
    s(e), e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128;
    let n = 0, o = "";
    return o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += "-", o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o += t[e[n++]], o;
  };
}();
async function The(s, e, t, i) {
  const n = s.get(Zs), o = s.get(ar), r = s.get(bi), a = s.get(ke), l = s.get(Oi);
  if (await i.item.resolve(ct.None), !i.part.location)
    return;
  const c = i.part.location, d = [], h = new Set(mo.getMenuItems(Qe.EditorContext).map((g) => ff(g) ? g.command.id : RV()));
  for (const g of Ul.all())
    h.has(g.desc.id) && d.push(new Ks(g.desc.id, bo.label(g.desc, { renderShortTitle: !0 }), void 0, !0, async () => {
      const m = await n.createModelReference(c.uri);
      try {
        const p = new cm(m.object.textEditorModel, E.getStartPosition(c.range)), A = i.item.anchor.range;
        await a.invokeFunction(g.runEditorCommand.bind(g), e, p, A);
      } finally {
        m.dispose();
      }
    }));
  if (i.part.command) {
    const { command: g } = i.part;
    d.push(new Ri()), d.push(new Ks(g.id, g.title, void 0, !0, async () => {
      try {
        await r.executeCommand(g.id, ...g.arguments ?? []);
      } catch (m) {
        l.notify({
          severity: H0.Error,
          source: i.item.provider.displayName,
          message: m
        });
      }
    }));
  }
  const u = e.getOption(
    128
    /* EditorOption.useShadowDOM */
  );
  o.showContextMenu({
    domForShadowRoot: u ? e.getDomNode() ?? void 0 : void 0,
    getAnchor: () => {
      const g = ui(t);
      return { x: g.left, y: g.top + g.height + 8 };
    },
    getActions: () => d,
    onHide: () => {
      e.focus();
    },
    autoSelectFirstItem: !0
  });
}
async function Bhe(s, e, t, i) {
  const o = await s.get(Zs).createModelReference(i.uri);
  await t.invokeWithinContext(async (r) => {
    const a = e.hasSideBySideModifier, l = r.get(Se), c = ns.inPeekEditor.getValue(l), d = !a && t.getOption(
      89
      /* EditorOption.definitionLinkOpensInPeek */
    ) && !c;
    return new q_({ openToSide: a, openInPeek: d, muteMessage: !0 }, { title: { value: "", original: "" }, id: "", precondition: void 0 }).run(r, new cm(o.object.textEditorModel, E.getStartPosition(i.range)), E.lift(i.range));
  }), o.dispose();
}
var Rhe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, pg = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Sg;
class Xv {
  constructor() {
    this._entries = new Vu(50);
  }
  get(e) {
    const t = Xv._key(e);
    return this._entries.get(t);
  }
  set(e, t) {
    const i = Xv._key(e);
    this._entries.set(i, t);
  }
  static _key(e) {
    return `${e.uri.toString()}/${e.getVersionId()}`;
  }
}
const FV = We("IInlayHintsCache");
$e(
  FV,
  Xv,
  1
  /* InstantiationType.Delayed */
);
class CI {
  constructor(e, t) {
    this.item = e, this.index = t;
  }
  get part() {
    const e = this.item.hint.label;
    return typeof e == "string" ? { label: e } : e[this.index];
  }
}
class Fhe {
  constructor(e, t) {
    this.part = e, this.hasTriggerModifier = t;
  }
}
var Dl;
let vI = (Dl = class {
  static get(e) {
    return e.getContribution(Sg.ID) ?? void 0;
  }
  constructor(e, t, i, n, o, r, a) {
    this._editor = e, this._languageFeaturesService = t, this._inlayHintsCache = n, this._commandService = o, this._notificationService = r, this._instaService = a, this._disposables = new X(), this._sessionDisposables = new X(), this._decorationsMetadata = /* @__PURE__ */ new Map(), this._ruleFactory = new _v(this._editor), this._activeRenderMode = 0, this._debounceInfo = i.for(t.inlayHintsProvider, "InlayHint", { min: 25 }), this._disposables.add(t.inlayHintsProvider.onDidChange(() => this._update())), this._disposables.add(e.onDidChangeModel(() => this._update())), this._disposables.add(e.onDidChangeModelLanguage(() => this._update())), this._disposables.add(e.onDidChangeConfiguration((l) => {
      l.hasChanged(
        142
        /* EditorOption.inlayHints */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._sessionDisposables.dispose(), this._removeAllDecorations(), this._disposables.dispose();
  }
  _update() {
    this._sessionDisposables.clear(), this._removeAllDecorations();
    const e = this._editor.getOption(
      142
      /* EditorOption.inlayHints */
    );
    if (e.enabled === "off")
      return;
    const t = this._editor.getModel();
    if (!t || !this._languageFeaturesService.inlayHintsProvider.has(t))
      return;
    if (e.enabled === "on")
      this._activeRenderMode = 0;
    else {
      let a, l;
      e.enabled === "onUnlessPressed" ? (a = 0, l = 1) : (a = 1, l = 0), this._activeRenderMode = a, this._sessionDisposables.add(bl.getInstance().event((c) => {
        if (!this._editor.hasModel())
          return;
        const d = c.altKey && c.ctrlKey && !(c.shiftKey || c.metaKey) ? l : a;
        if (d !== this._activeRenderMode) {
          this._activeRenderMode = d;
          const h = this._editor.getModel(), u = this._copyInlayHintsWithCurrentAnchor(h);
          this._updateHintsDecorators([h.getFullModelRange()], u), r.schedule(0);
        }
      }));
    }
    const i = this._inlayHintsCache.get(t);
    i && this._updateHintsDecorators([t.getFullModelRange()], i), this._sessionDisposables.add(we(() => {
      t.isDisposed() || this._cacheHintsForFastRestore(t);
    }));
    let n;
    const o = /* @__PURE__ */ new Set(), r = new zt(async () => {
      const a = Date.now();
      n?.dispose(!0), n = new vs();
      const l = t.onWillDispose(() => n?.cancel());
      try {
        const c = n.token, d = await $v.create(this._languageFeaturesService.inlayHintsProvider, t, this._getHintsRanges(), c);
        if (r.delay = this._debounceInfo.update(t, Date.now() - a), c.isCancellationRequested) {
          d.dispose();
          return;
        }
        for (const h of d.provider)
          typeof h.onDidChangeInlayHints == "function" && !o.has(h) && (o.add(h), this._sessionDisposables.add(h.onDidChangeInlayHints(() => {
            r.isScheduled() || r.schedule();
          })));
        this._sessionDisposables.add(d), this._updateHintsDecorators(d.ranges, d.items), this._cacheHintsForFastRestore(t);
      } catch (c) {
        Pe(c);
      } finally {
        n.dispose(), l.dispose();
      }
    }, this._debounceInfo.get(t));
    this._sessionDisposables.add(r), this._sessionDisposables.add(we(() => n?.dispose(!0))), r.schedule(0), this._sessionDisposables.add(this._editor.onDidScrollChange((a) => {
      (a.scrollTopChanged || !r.isScheduled()) && r.schedule();
    })), this._sessionDisposables.add(this._editor.onDidChangeModelContent((a) => {
      n?.cancel();
      const l = Math.max(r.delay, 1250);
      r.schedule(l);
    })), this._sessionDisposables.add(this._installDblClickGesture(() => r.schedule(0))), this._sessionDisposables.add(this._installLinkGesture()), this._sessionDisposables.add(this._installContextMenu());
  }
  _installLinkGesture() {
    const e = new X(), t = e.add(new lV(this._editor)), i = new X();
    return e.add(i), e.add(t.onMouseMoveOrRelevantKeyDown((n) => {
      const [o] = n, r = this._getInlayHintLabelPart(o), a = this._editor.getModel();
      if (!r || !a) {
        i.clear();
        return;
      }
      const l = new vs();
      i.add(we(() => l.dispose(!0))), r.item.resolve(l.token), this._activeInlayHintPart = r.part.command || r.part.location ? new Fhe(r, o.hasTriggerModifier) : void 0;
      const c = a.validatePosition(r.item.hint.position).lineNumber, d = new E(c, 1, c, a.getLineMaxColumn(c)), h = this._getInlineHintsForRange(d);
      this._updateHintsDecorators([d], h), i.add(we(() => {
        this._activeInlayHintPart = void 0, this._updateHintsDecorators([d], h);
      }));
    })), e.add(t.onCancel(() => i.clear())), e.add(t.onExecute(async (n) => {
      const o = this._getInlayHintLabelPart(n);
      if (o) {
        const r = o.part;
        r.location ? this._instaService.invokeFunction(Bhe, n, this._editor, r.location) : Ox.is(r.command) && await this._invokeCommand(r.command, o.item);
      }
    })), e;
  }
  _getInlineHintsForRange(e) {
    const t = /* @__PURE__ */ new Set();
    for (const i of this._decorationsMetadata.values())
      e.containsRange(i.item.anchor.range) && t.add(i.item);
    return Array.from(t);
  }
  _installDblClickGesture(e) {
    return this._editor.onMouseUp(async (t) => {
      if (t.event.detail !== 2)
        return;
      const i = this._getInlayHintLabelPart(t);
      if (i && (t.event.preventDefault(), await i.item.resolve(ct.None), Ys(i.item.hint.textEdits))) {
        const n = i.item.hint.textEdits.map((o) => ms.replace(E.lift(o.range), o.text));
        this._editor.executeEdits("inlayHint.default", n), e();
      }
    });
  }
  _installContextMenu() {
    return this._editor.onContextMenu(async (e) => {
      if (!Bi(e.event.target))
        return;
      const t = this._getInlayHintLabelPart(e);
      t && await this._instaService.invokeFunction(The, this._editor, e.event.target, t);
    });
  }
  _getInlayHintLabelPart(e) {
    if (e.target.type !== 6)
      return;
    const t = e.target.detail.injectedText?.options;
    if (t instanceof dd && t?.attachedData instanceof CI)
      return t.attachedData;
  }
  async _invokeCommand(e, t) {
    try {
      await this._commandService.executeCommand(e.id, ...e.arguments ?? []);
    } catch (i) {
      this._notificationService.notify({
        severity: H0.Error,
        source: t.provider.displayName,
        message: i
      });
    }
  }
  _cacheHintsForFastRestore(e) {
    const t = this._copyInlayHintsWithCurrentAnchor(e);
    this._inlayHintsCache.set(e, t);
  }
  // return inlay hints but with an anchor that reflects "updates"
  // that happened after receiving them, e.g adding new lines before a hint
  _copyInlayHintsWithCurrentAnchor(e) {
    const t = /* @__PURE__ */ new Map();
    for (const [i, n] of this._decorationsMetadata) {
      if (t.has(n.item))
        continue;
      const o = e.getDecorationRange(i);
      if (o) {
        const r = new BV(o, n.item.anchor.direction), a = n.item.with({ anchor: r });
        t.set(n.item, a);
      }
    }
    return Array.from(t.values());
  }
  _getHintsRanges() {
    const t = this._editor.getModel(), i = this._editor.getVisibleRangesPlusViewportAboveBelow(), n = [];
    for (const o of i.sort(E.compareRangesUsingStarts)) {
      const r = t.validateRange(new E(o.startLineNumber - 30, o.startColumn, o.endLineNumber + 30, o.endColumn));
      n.length === 0 || !E.areIntersectingOrTouching(n[n.length - 1], r) ? n.push(r) : n[n.length - 1] = E.plusRange(n[n.length - 1], r);
    }
    return n;
  }
  _updateHintsDecorators(e, t) {
    const i = [], n = (m, p, A, _, b) => {
      const C = {
        content: A,
        inlineClassNameAffectsLetterSpacing: !0,
        inlineClassName: p.className,
        cursorStops: _,
        attachedData: b
      };
      i.push({
        item: m,
        classNameRef: p,
        decoration: {
          range: m.anchor.range,
          options: {
            // className: "rangeHighlight", // DEBUG highlight to see to what range a hint is attached
            description: "InlayHint",
            showIfCollapsed: m.anchor.range.isEmpty(),
            // "original" range is empty
            collapseOnReplaceEdit: !m.anchor.range.isEmpty(),
            stickiness: 0,
            [m.anchor.direction]: this._activeRenderMode === 0 ? C : void 0
          }
        }
      });
    }, o = (m, p) => {
      const A = this._ruleFactory.createClassNameRef({
        width: `${r / 3 | 0}px`,
        display: "inline-block"
      });
      n(m, A, " ", p ? Aa.Right : Aa.None);
    }, { fontSize: r, fontFamily: a, padding: l, isUniform: c } = this._getLayoutInfo(), d = "--code-editorInlayHintsFontFamily";
    this._editor.getContainerDomNode().style.setProperty(d, a);
    let h = { line: 0, totalLen: 0 };
    for (const m of t) {
      if (h.line !== m.anchor.range.startLineNumber && (h = { line: m.anchor.range.startLineNumber, totalLen: 0 }), h.totalLen > Sg._MAX_LABEL_LEN)
        continue;
      m.hint.paddingLeft && o(m, !1);
      const p = typeof m.hint.label == "string" ? [{ label: m.hint.label }] : m.hint.label;
      for (let A = 0; A < p.length; A++) {
        const _ = p[A], b = A === 0, C = A === p.length - 1, w = {
          fontSize: `${r}px`,
          fontFamily: `var(${d}), ${Zn.fontFamily}`,
          verticalAlign: c ? "baseline" : "middle",
          unicodeBidi: "isolate"
        };
        Ys(m.hint.textEdits) && (w.cursor = "default"), this._fillInColors(w, m.hint), (_.command || _.location) && this._activeInlayHintPart?.part.item === m && this._activeInlayHintPart.part.index === A && (w.textDecoration = "underline", this._activeInlayHintPart.hasTriggerModifier && (w.color = Wi(Uj), w.cursor = "pointer")), l && (b && C ? (w.padding = `1px ${Math.max(1, r / 4) | 0}px`, w.borderRadius = `${r / 4 | 0}px`) : b ? (w.padding = `1px 0 1px ${Math.max(1, r / 4) | 0}px`, w.borderRadius = `${r / 4 | 0}px 0 0 ${r / 4 | 0}px`) : C ? (w.padding = `1px ${Math.max(1, r / 4) | 0}px 1px 0`, w.borderRadius = `0 ${r / 4 | 0}px ${r / 4 | 0}px 0`) : w.padding = "1px 0 1px 0");
        let S = _.label;
        h.totalLen += S.length;
        let x = !1;
        const y = h.totalLen - Sg._MAX_LABEL_LEN;
        if (y > 0 && (S = S.slice(0, -y) + "…", x = !0), n(m, this._ruleFactory.createClassNameRef(w), Ohe(S), C && !m.hint.paddingRight ? Aa.Right : Aa.None, new CI(m, A)), x)
          break;
      }
      if (m.hint.paddingRight && o(m, !0), i.length > Sg._MAX_DECORATORS)
        break;
    }
    const u = [];
    for (const [m, p] of this._decorationsMetadata) {
      const A = this._editor.getModel()?.getDecorationRange(m);
      A && e.some((_) => _.containsRange(A)) && (u.push(m), p.classNameRef.dispose(), this._decorationsMetadata.delete(m));
    }
    const g = gd.capture(this._editor);
    this._editor.changeDecorations((m) => {
      const p = m.deltaDecorations(u, i.map((A) => A.decoration));
      for (let A = 0; A < p.length; A++) {
        const _ = i[A];
        this._decorationsMetadata.set(p[A], _);
      }
    }), g.restore(this._editor);
  }
  _fillInColors(e, t) {
    t.kind === eC.Parameter ? (e.backgroundColor = Wi($j), e.color = Wi(qj)) : t.kind === eC.Type ? (e.backgroundColor = Wi(Jj), e.color = Wi(Kj)) : (e.backgroundColor = Wi(_N), e.color = Wi(AN));
  }
  _getLayoutInfo() {
    const e = this._editor.getOption(
      142
      /* EditorOption.inlayHints */
    ), t = e.padding, i = this._editor.getOption(
      52
      /* EditorOption.fontSize */
    ), n = this._editor.getOption(
      49
      /* EditorOption.fontFamily */
    );
    let o = e.fontSize;
    (!o || o < 5 || o > i) && (o = i);
    const r = e.fontFamily || n;
    return { fontSize: o, fontFamily: r, padding: t, isUniform: !t && r === n && o === i };
  }
  _removeAllDecorations() {
    this._editor.removeDecorations(Array.from(this._decorationsMetadata.keys()));
    for (const e of this._decorationsMetadata.values())
      e.classNameRef.dispose();
    this._decorationsMetadata.clear();
  }
}, Sg = Dl, Dl.ID = "editor.contrib.InlayHints", Dl._MAX_DECORATORS = 1500, Dl._MAX_LABEL_LEN = 43, Dl);
vI = Sg = Rhe([
  pg(1, ye),
  pg(2, W0),
  pg(3, FV),
  pg(4, bi),
  pg(5, Oi),
  pg(6, ke)
], vI);
function Ohe(s) {
  return s.replace(/[ \t]/g, " ");
}
mt.registerCommand("_executeInlayHintProvider", async (s, ...e) => {
  const [t, i] = e;
  jt(_e.isUri(t)), jt(E.isIRange(i));
  const { inlayHintsProvider: n } = s.get(ye), o = await s.get(Zs).createModelReference(t);
  try {
    const r = await $v.create(n, o.object.textEditorModel, [E.lift(i)], ct.None), a = r.items.map((l) => l.hint);
    return setTimeout(() => r.dispose(), 0), a;
  } finally {
    o.dispose();
  }
});
var Phe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, rc = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class WP extends $de {
  constructor(e, t, i, n) {
    super(10, t, e.item.anchor.range, i, n, !0), this.part = e;
  }
}
let SI = class extends C_ {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, t, i, r, l, n, o, c), this._resolverService = a, this.hoverOrdinal = 6;
  }
  suggestHoverAnchor(e) {
    if (!vI.get(this._editor) || e.target.type !== 6)
      return null;
    const i = e.target.detail.injectedText?.options;
    return i instanceof dd && i.attachedData instanceof CI ? new WP(i.attachedData, this, e.event.posx, e.event.posy) : null;
  }
  computeSync() {
    return [];
  }
  computeAsync(e, t, i) {
    return e instanceof WP ? new Gs(async (n) => {
      const { part: o } = e;
      if (await o.item.resolve(i), i.isCancellationRequested)
        return;
      let r;
      typeof o.item.hint.tooltip == "string" ? r = new Vo().appendText(o.item.hint.tooltip) : o.item.hint.tooltip && (r = o.item.hint.tooltip), r && n.emitOne(new Dr(this, e.range, [r], !1, 0)), Ys(o.item.hint.textEdits) && n.emitOne(new Dr(this, e.range, [new Vo().appendText(f("hint.dbl", "Double-click to insert"))], !1, 10001));
      let a;
      if (typeof o.part.tooltip == "string" ? a = new Vo().appendText(o.part.tooltip) : o.part.tooltip && (a = o.part.tooltip), a && n.emitOne(new Dr(this, e.range, [a], !1, 1)), o.part.location || o.part.command) {
        let c;
        const h = this._editor.getOption(
          78
          /* EditorOption.multiCursorModifier */
        ) === "altKey" ? ze ? f("links.navigate.kb.meta.mac", "cmd + click") : f("links.navigate.kb.meta", "ctrl + click") : ze ? f("links.navigate.kb.alt.mac", "option + click") : f("links.navigate.kb.alt", "alt + click");
        o.part.location && o.part.command ? c = new Vo().appendText(f("hint.defAndCommand", "Go to Definition ({0}), right click for more", h)) : o.part.location ? c = new Vo().appendText(f("hint.def", "Go to Definition ({0})", h)) : o.part.command && (c = new Vo(`[${f("hint.cmd", "Execute Command")}](${Nhe(o.part.command)} "${o.part.command.title}") (${h})`, { isTrusted: !0 })), c && n.emitOne(new Dr(this, e.range, [c], !1, 1e4));
      }
      const l = await this._resolveInlayHintLabelPartHover(o, i);
      for await (const c of l)
        n.emitOne(c);
    }) : Gs.EMPTY;
  }
  async _resolveInlayHintLabelPartHover(e, t) {
    if (!e.part.location)
      return Gs.EMPTY;
    const { uri: i, range: n } = e.part.location, o = await this._resolverService.createModelReference(i);
    try {
      const r = o.object.textEditorModel;
      return this._languageFeaturesService.hoverProvider.has(r) ? cB(this._languageFeaturesService.hoverProvider, r, new F(n.startLineNumber, n.startColumn), t).filter((a) => !Xf(a.hover.contents)).map((a) => new Dr(this, e.item.anchor.range, a.hover.contents, !1, 2 + a.ordinal)) : Gs.EMPTY;
    } finally {
      o.dispose();
    }
  }
};
SI = Phe([
  rc(1, si),
  rc(2, lr),
  rc(3, bt),
  rc(4, jl),
  rc(5, ht),
  rc(6, Zs),
  rc(7, ye),
  rc(8, bi)
], SI);
class uB extends V {
  constructor(e, t, i, n, o, r) {
    super();
    const a = t.anchor, l = t.hoverParts;
    this._renderedHoverParts = this._register(new yI(e, i, l, r, o));
    const { showAtPosition: c, showAtSecondaryPosition: d } = uB.computeHoverPositions(e, a.range, l);
    this.shouldAppearBeforeContent = l.some((h) => h.isBeforeContent), this.showAtPosition = c, this.showAtSecondaryPosition = d, this.initialMousePosX = a.initialMousePosX, this.initialMousePosY = a.initialMousePosY, this.shouldFocus = n.shouldFocus, this.source = n.source;
  }
  get domNode() {
    return this._renderedHoverParts.domNode;
  }
  get domNodeHasChildren() {
    return this._renderedHoverParts.domNodeHasChildren;
  }
  get focusedHoverPartIndex() {
    return this._renderedHoverParts.focusedHoverPartIndex;
  }
  async updateHoverVerbosityLevel(e, t, i) {
    this._renderedHoverParts.updateHoverVerbosityLevel(e, t, i);
  }
  isColorPickerVisible() {
    return this._renderedHoverParts.isColorPickerVisible();
  }
  static computeHoverPositions(e, t, i) {
    let n = 1;
    if (e.hasModel()) {
      const d = e._getViewModel(), h = d.coordinatesConverter, u = h.convertModelRangeToViewRange(t), g = d.getLineMinColumn(u.startLineNumber), m = new F(u.startLineNumber, g);
      n = h.convertViewPositionToModelPosition(m).column;
    }
    const o = t.startLineNumber;
    let r = t.startColumn, a;
    for (const d of i) {
      const h = d.range, u = h.startLineNumber === o, g = h.endLineNumber === o;
      if (u && g) {
        const p = h.startColumn, A = Math.min(r, p);
        r = Math.max(A, n);
      }
      d.forceShowAtRange && (a = h);
    }
    let l, c;
    if (a) {
      const d = a.getStartPosition();
      l = d, c = d;
    } else
      l = t.getStartPosition(), c = new F(o, r);
    return {
      showAtPosition: l,
      showAtSecondaryPosition: c
    };
  }
}
class Hhe {
  constructor(e, t) {
    this._statusBar = t, e.appendChild(this._statusBar.hoverElement);
  }
  get hoverElement() {
    return this._statusBar.hoverElement;
  }
  get actions() {
    return this._statusBar.actions;
  }
  dispose() {
    this._statusBar.dispose();
  }
}
const a0 = class a0 extends V {
  constructor(e, t, i, n, o) {
    super(), this._renderedParts = [], this._focusedHoverPartIndex = -1, this._context = o, this._fragment = document.createDocumentFragment(), this._register(this._renderParts(t, i, o, n)), this._register(this._registerListenersOnRenderedParts()), this._register(this._createEditorDecorations(e, i)), this._updateMarkdownAndColorParticipantInfo(t);
  }
  _createEditorDecorations(e, t) {
    if (t.length === 0)
      return V.None;
    let i = t[0].range;
    for (const o of t) {
      const r = o.range;
      i = E.plusRange(i, r);
    }
    const n = e.createDecorationsCollection();
    return n.set([{
      range: i,
      options: a0._DECORATION_OPTIONS
    }]), we(() => {
      n.clear();
    });
  }
  _renderParts(e, t, i, n) {
    const o = new AI(n), r = {
      fragment: this._fragment,
      statusBar: o,
      ...i
    }, a = new X();
    for (const c of e) {
      const d = this._renderHoverPartsForParticipant(t, c, r);
      a.add(d);
      for (const h of d.renderedHoverParts)
        this._renderedParts.push({
          type: "hoverPart",
          participant: c,
          hoverPart: h.hoverPart,
          hoverElement: h.hoverElement
        });
    }
    const l = this._renderStatusBar(this._fragment, o);
    return l && (a.add(l), this._renderedParts.push({
      type: "statusBar",
      hoverElement: l.hoverElement,
      actions: l.actions
    })), we(() => {
      a.dispose();
    });
  }
  _renderHoverPartsForParticipant(e, t, i) {
    const n = e.filter((r) => r.owner === t);
    return n.length > 0 ? t.renderHoverParts(i, n) : new w_([]);
  }
  _renderStatusBar(e, t) {
    if (t.hasContent)
      return new Hhe(e, t);
  }
  _registerListenersOnRenderedParts() {
    const e = new X();
    return this._renderedParts.forEach((t, i) => {
      const n = t.hoverElement;
      n.tabIndex = 0, e.add(U(n, ee.FOCUS_IN, (o) => {
        o.stopPropagation(), this._focusedHoverPartIndex = i;
      })), e.add(U(n, ee.FOCUS_OUT, (o) => {
        o.stopPropagation(), this._focusedHoverPartIndex = -1;
      }));
    }), e;
  }
  _updateMarkdownAndColorParticipantInfo(e) {
    const t = e.find((i) => i instanceof C_ && !(i instanceof SI));
    t && (this._markdownHoverParticipant = t), this._colorHoverParticipant = e.find((i) => i instanceof Jv);
  }
  async updateHoverVerbosityLevel(e, t, i) {
    if (!this._markdownHoverParticipant)
      return;
    const n = this._normalizedIndexToMarkdownHoverIndexRange(this._markdownHoverParticipant, t);
    if (n === void 0)
      return;
    const o = await this._markdownHoverParticipant.updateMarkdownHoverVerbosityLevel(e, n, i);
    o && (this._renderedParts[t] = {
      type: "hoverPart",
      participant: this._markdownHoverParticipant,
      hoverPart: o.hoverPart,
      hoverElement: o.hoverElement
    }, this._context.onContentsChanged());
  }
  isColorPickerVisible() {
    return this._colorHoverParticipant?.isColorPickerVisible() ?? !1;
  }
  _normalizedIndexToMarkdownHoverIndexRange(e, t) {
    const i = this._renderedParts[t];
    if (!i || i.type !== "hoverPart" || !(i.participant === e))
      return;
    const o = this._renderedParts.findIndex((r) => r.type === "hoverPart" && r.participant === e);
    if (o === -1)
      throw new lt();
    return t - o;
  }
  get domNode() {
    return this._fragment;
  }
  get domNodeHasChildren() {
    return this._fragment.hasChildNodes();
  }
  get focusedHoverPartIndex() {
    return this._focusedHoverPartIndex;
  }
};
a0._DECORATION_OPTIONS = He.register({
  description: "content-hover-highlight",
  className: "hoverHighlight"
});
let yI = a0;
var Whe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, VP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let xI = class extends V {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._currentResult = null, this._onContentsChanged = this._register(new B()), this.onContentsChanged = this._onContentsChanged.event, this._contentHoverWidget = this._register(this._instantiationService.createInstance(pI, this._editor)), this._participants = this._initializeHoverParticipants(), this._computer = new Yv(this._editor, this._participants), this._hoverOperation = this._register(new wV(this._editor, this._computer)), this._registerListeners();
  }
  _initializeHoverParticipants() {
    const e = [];
    for (const t of aB.getAll()) {
      const i = this._instantiationService.createInstance(t, this._editor);
      e.push(i);
    }
    return e.sort((t, i) => t.hoverOrdinal - i.hoverOrdinal), this._register(this._contentHoverWidget.onDidResize(() => {
      this._participants.forEach((t) => t.handleResize?.());
    })), e;
  }
  _registerListeners() {
    this._register(this._hoverOperation.onResult((t) => {
      if (!this._computer.anchor)
        return;
      const i = t.hasLoadingMessage ? this._addLoadingMessage(t.value) : t.value;
      this._withResult(new CV(this._computer.anchor, i, t.isComplete));
    }));
    const e = this._contentHoverWidget.getDomNode();
    this._register(Xt(e, "keydown", (t) => {
      t.equals(
        9
        /* KeyCode.Escape */
      ) && this.hide();
    })), this._register(Xt(e, "mouseleave", (t) => {
      this._onMouseLeave(t);
    })), this._register(ci.onDidChange(() => {
      this._contentHoverWidget.position && this._currentResult && this._setCurrentResult(this._currentResult);
    }));
  }
  /**
   * Returns true if the hover shows now or will show.
   */
  _startShowingOrUpdateHover(e, t, i, n, o) {
    if (!(this._contentHoverWidget.position && this._currentResult))
      return e ? (this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : !1;
    const a = this._editor.getOption(
      60
      /* EditorOption.hover */
    ).sticky, l = o && this._contentHoverWidget.isMouseGettingCloser(o.event.posx, o.event.posy);
    return a && l ? (e && this._startHoverOperationIfNecessary(e, t, i, n, !0), !0) : e ? this._currentResult.anchor.equals(e) ? !0 : e.canAdoptVisibleHover(this._currentResult.anchor, this._contentHoverWidget.position) ? (this._setCurrentResult(this._currentResult.filter(e)), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), this._startHoverOperationIfNecessary(e, t, i, n, !1), !0) : (this._setCurrentResult(null), !1);
  }
  _startHoverOperationIfNecessary(e, t, i, n, o) {
    this._computer.anchor && this._computer.anchor.equals(e) || (this._hoverOperation.cancel(), this._computer.anchor = e, this._computer.shouldFocus = n, this._computer.source = i, this._computer.insistOnKeepingHoverVisible = o, this._hoverOperation.start(t));
  }
  _setCurrentResult(e) {
    let t = e;
    if (this._currentResult === t)
      return;
    t && t.hoverParts.length === 0 && (t = null), this._currentResult = t, this._currentResult ? this._showHover(this._currentResult) : this._hideHover();
  }
  _addLoadingMessage(e) {
    if (!this._computer.anchor)
      return e;
    for (const t of this._participants) {
      if (!t.createLoadingMessage)
        continue;
      const i = t.createLoadingMessage(this._computer.anchor);
      if (i)
        return e.slice(0).concat([i]);
    }
    return e;
  }
  _withResult(e) {
    if (this._contentHoverWidget.position && this._currentResult && this._currentResult.isComplete || this._setCurrentResult(e), !e.isComplete)
      return;
    const n = e.hoverParts.length === 0, o = this._computer.insistOnKeepingHoverVisible;
    n && o || this._setCurrentResult(e);
  }
  _showHover(e) {
    const t = this._getHoverContext();
    this._renderedContentHover = new uB(this._editor, e, this._participants, this._computer, t, this._keybindingService), this._renderedContentHover.domNodeHasChildren ? this._contentHoverWidget.show(this._renderedContentHover) : this._renderedContentHover.dispose();
  }
  _hideHover() {
    this._contentHoverWidget.hide();
  }
  _getHoverContext() {
    return { hide: () => {
      this.hide();
    }, onContentsChanged: () => {
      this._onContentsChanged.fire(), this._contentHoverWidget.onContentsChanged();
    }, setMinimumDimensions: (n) => {
      this._contentHoverWidget.setMinimumDimensions(n);
    } };
  }
  showsOrWillShow(e) {
    if (this._contentHoverWidget.isResizing)
      return !0;
    const i = this._findHoverAnchorCandidates(e);
    if (!(i.length > 0))
      return this._startShowingOrUpdateHover(null, 0, 0, !1, e);
    const o = i[0];
    return this._startShowingOrUpdateHover(o, 0, 0, !1, e);
  }
  _findHoverAnchorCandidates(e) {
    const t = [];
    for (const n of this._participants) {
      if (!n.suggestHoverAnchor)
        continue;
      const o = n.suggestHoverAnchor(e);
      o && t.push(o);
    }
    const i = e.target;
    switch (i.type) {
      case 6: {
        t.push(new ux(0, i.range, e.event.posx, e.event.posy));
        break;
      }
      case 7: {
        const n = this._editor.getOption(
          50
          /* EditorOption.fontInfo */
        ).typicalHalfwidthCharacterWidth / 2;
        if (!(!i.detail.isAfterLines && typeof i.detail.horizontalDistanceToText == "number" && i.detail.horizontalDistanceToText < n))
          break;
        t.push(new ux(0, i.range, e.event.posx, e.event.posy));
        break;
      }
    }
    return t.sort((n, o) => o.priority - n.priority), t;
  }
  _onMouseLeave(e) {
    const t = this._editor.getDomNode();
    (!t || !NS(t, e.x, e.y)) && this.hide();
  }
  startShowingAtRange(e, t, i, n) {
    this._startShowingOrUpdateHover(new ux(0, e, void 0, void 0), t, i, n, null);
  }
  async updateHoverVerbosityLevel(e, t, i) {
    this._renderedContentHover?.updateHoverVerbosityLevel(e, t, i);
  }
  focusedHoverPartIndex() {
    return this._renderedContentHover?.focusedHoverPartIndex ?? -1;
  }
  containsNode(e) {
    return e ? this._contentHoverWidget.getDomNode().contains(e) : !1;
  }
  focus() {
    this._contentHoverWidget.focus();
  }
  scrollUp() {
    this._contentHoverWidget.scrollUp();
  }
  scrollDown() {
    this._contentHoverWidget.scrollDown();
  }
  scrollLeft() {
    this._contentHoverWidget.scrollLeft();
  }
  scrollRight() {
    this._contentHoverWidget.scrollRight();
  }
  pageUp() {
    this._contentHoverWidget.pageUp();
  }
  pageDown() {
    this._contentHoverWidget.pageDown();
  }
  goToTop() {
    this._contentHoverWidget.goToTop();
  }
  goToBottom() {
    this._contentHoverWidget.goToBottom();
  }
  hide() {
    this._computer.anchor = null, this._hoverOperation.cancel(), this._setCurrentResult(null);
  }
  getDomNode() {
    return this._contentHoverWidget.getDomNode();
  }
  get isColorPickerVisible() {
    return this._renderedContentHover?.isColorPickerVisible() ?? !1;
  }
  get isVisibleFromKeyboard() {
    return this._contentHoverWidget.isVisibleFromKeyboard;
  }
  get isVisible() {
    return this._contentHoverWidget.isVisible;
  }
  get isFocused() {
    return this._contentHoverWidget.isFocused;
  }
  get isResizing() {
    return this._contentHoverWidget.isResizing;
  }
  get widget() {
    return this._contentHoverWidget;
  }
};
xI = Whe([
  VP(1, ke),
  VP(2, bt)
], xI);
var Vhe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zP = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, EI, $h;
let zn = ($h = class extends V {
  constructor(e, t, i) {
    super(), this._editor = e, this._instantiationService = t, this._keybindingService = i, this._onHoverContentsChanged = this._register(new B()), this.shouldKeepOpenOnEditorMouseMoveOrLeave = !1, this._listenersStore = new X(), this._hoverState = {
      mouseDown: !1,
      activatedByDecoratorClick: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new zt(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  static get(e) {
    return e.getContribution(EI.ID);
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.hidingDelay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    this._hoverState.mouseDown = !0, !this._shouldNotHideCurrentHoverWidget(e) && this._hideWidgets();
  }
  _shouldNotHideCurrentHoverWidget(e) {
    return this._isMouseOnContentHoverWidget(e) || this._isContentWidgetResizing();
  }
  _isMouseOnContentHoverWidget(e) {
    const t = this._contentWidget?.getDomNode();
    return t ? NS(t, e.event.posx, e.event.posy) : !1;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._cancelScheduler(), this._shouldNotHideCurrentHoverWidget(e)) || this._hideWidgets();
  }
  _shouldNotRecomputeCurrentHoverWidget(e) {
    const t = this._hoverSettings.sticky, i = (r, a) => {
      const l = this._isMouseOnContentHoverWidget(r);
      return a && l;
    }, n = (r) => {
      const a = this._isMouseOnContentHoverWidget(r), l = this._contentWidget?.isColorPickerVisible ?? !1;
      return a && l;
    }, o = (r, a) => (a && this._contentWidget?.containsNode(r.event.browserEvent.view?.document.activeElement) && !r.event.browserEvent.view?.getSelection()?.isCollapsed) ?? !1;
    return i(e, t) || n(e) || o(e, t);
  }
  _onEditorMouseMove(e) {
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._mouseMoveEvent = e, this._contentWidget?.isFocused || this._contentWidget?.isResizing))
      return;
    const t = this._hoverSettings.sticky;
    if (t && this._contentWidget?.isVisibleFromKeyboard)
      return;
    if (this._shouldNotRecomputeCurrentHoverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    const n = this._hoverSettings.hidingDelay;
    if (this._contentWidget?.isVisible && t && n > 0) {
      this._reactToEditorMouseMoveRunner.isScheduled() || this._reactToEditorMouseMoveRunner.schedule(n);
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    if (!e)
      return;
    const i = e.target.element?.classList.contains("colorpicker-color-decoration"), n = this._editor.getOption(
      149
      /* EditorOption.colorDecoratorsActivatedOn */
    ), o = this._hoverSettings.enabled, r = this._hoverState.activatedByDecoratorClick;
    if (i && (n === "click" && !r || n === "hover" && !o || n === "clickAndHover" && !o && !r) || !i && !o && !r) {
      this._hideWidgets();
      return;
    }
    this._tryShowHoverWidget(e) || this._hideWidgets();
  }
  _tryShowHoverWidget(e) {
    return this._getOrCreateContentWidget().showsOrWillShow(e);
  }
  _onKeyDown(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._keybindingService.softDispatch(e, this._editor.getDomNode()), i = t.kind === 1 || t.kind === 2 && (t.commandId === aV || t.commandId === ES || t.commandId === LS) && this._contentWidget?.isVisible;
    e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || i || this._hideWidgets();
  }
  _hideWidgets() {
    this._hoverState.mouseDown && this._contentWidget?.isColorPickerVisible || jv.dropDownVisible || (this._hoverState.activatedByDecoratorClick = !1, this._contentWidget?.hide());
  }
  _getOrCreateContentWidget() {
    return this._contentWidget || (this._contentWidget = this._instantiationService.createInstance(xI, this._editor), this._listenersStore.add(this._contentWidget.onContentsChanged(() => this._onHoverContentsChanged.fire()))), this._contentWidget;
  }
  showContentHover(e, t, i, n, o = !1) {
    this._hoverState.activatedByDecoratorClick = o, this._getOrCreateContentWidget().startShowingAtRange(e, t, i, n);
  }
  _isContentWidgetResizing() {
    return this._contentWidget?.widget.isResizing || !1;
  }
  focusedHoverPartIndex() {
    return this._getOrCreateContentWidget().focusedHoverPartIndex();
  }
  updateHoverVerbosityLevel(e, t, i) {
    this._getOrCreateContentWidget().updateHoverVerbosityLevel(e, t, i);
  }
  focus() {
    this._contentWidget?.focus();
  }
  scrollUp() {
    this._contentWidget?.scrollUp();
  }
  scrollDown() {
    this._contentWidget?.scrollDown();
  }
  scrollLeft() {
    this._contentWidget?.scrollLeft();
  }
  scrollRight() {
    this._contentWidget?.scrollRight();
  }
  pageUp() {
    this._contentWidget?.pageUp();
  }
  pageDown() {
    this._contentWidget?.pageDown();
  }
  goToTop() {
    this._contentWidget?.goToTop();
  }
  goToBottom() {
    this._contentWidget?.goToBottom();
  }
  get isColorPickerVisible() {
    return this._contentWidget?.isColorPickerVisible;
  }
  get isHoverVisible() {
    return this._contentWidget?.isVisible;
  }
  dispose() {
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), this._contentWidget?.dispose();
  }
}, EI = $h, $h.ID = "editor.contrib.contentHover", $h);
zn = EI = Vhe([
  zP(1, ke),
  zP(2, bt)
], zn);
var _r;
(function(s) {
  s.NoAutoFocus = "noAutoFocus", s.FocusIfVisible = "focusIfVisible", s.AutoFocusImmediately = "autoFocusImmediately";
})(_r || (_r = {}));
class zhe extends Vt {
  constructor() {
    super({
      id: aV,
      label: f({
        key: "showOrFocusHover",
        comment: [
          "Label for action that will trigger the showing/focusing of a hover in the editor.",
          "If the hover is not visible, it will show the hover.",
          "This allows for users to show the hover without using the mouse."
        ]
      }, "Show or Focus Hover"),
      metadata: {
        description: ni("showOrFocusHoverDescription", "Show or focus the editor hover which shows documentation, references, and other content for a symbol at the current cursor position."),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              focus: {
                description: "Controls if and when the hover should take focus upon being triggered by this action.",
                enum: [_r.NoAutoFocus, _r.FocusIfVisible, _r.AutoFocusImmediately],
                enumDescriptions: [
                  f("showOrFocusHover.focus.noAutoFocus", "The hover will not automatically take focus."),
                  f("showOrFocusHover.focus.focusIfVisible", "The hover will take focus only if it is already visible."),
                  f("showOrFocusHover.focus.autoFocusImmediately", "The hover will automatically take focus when it appears.")
                ],
                default: _r.FocusIfVisible
              }
            }
          }
        }]
      },
      alias: "Show or Focus Hover",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2087
          /* KeyCode.KeyI */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = zn.get(t);
    if (!n)
      return;
    const o = i?.focus;
    let r = _r.FocusIfVisible;
    Object.values(_r).includes(o) ? r = o : typeof o == "boolean" && o && (r = _r.AutoFocusImmediately);
    const a = (c) => {
      const d = t.getPosition(), h = new E(d.lineNumber, d.column, d.lineNumber, d.column);
      n.showContentHover(h, 1, 1, c);
    }, l = t.getOption(
      2
      /* EditorOption.accessibilitySupport */
    ) === 2;
    n.isHoverVisible ? r !== _r.NoAutoFocus ? n.focus() : a(l) : a(l || r === _r.AutoFocusImmediately);
  }
}
class Uhe extends Vt {
  constructor() {
    super({
      id: cde,
      label: f({
        key: "showDefinitionPreviewHover",
        comment: [
          "Label for action that will trigger the showing of definition preview hover in the editor.",
          "This allows for users to show the definition preview hover without using the mouse."
        ]
      }, "Show Definition Preview Hover"),
      alias: "Show Definition Preview Hover",
      precondition: void 0,
      metadata: {
        description: ni("showDefinitionPreviewHoverDescription", "Show the definition preview hover in the editor.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    if (!i)
      return;
    const n = t.getPosition();
    if (!n)
      return;
    const o = new E(n.lineNumber, n.column, n.lineNumber, n.column), r = b_.get(t);
    if (!r)
      return;
    r.startFindDefinitionFromCursor(n).then(() => {
      i.showContentHover(o, 1, 1, !0);
    });
  }
}
class Qhe extends Vt {
  constructor() {
    super({
      id: dde,
      label: f({
        key: "scrollUpHover",
        comment: [
          "Action that allows to scroll up in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Up Hover"),
      alias: "Scroll Up Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 16,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("scrollUpHoverDescription", "Scroll up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.scrollUp();
  }
}
class Ghe extends Vt {
  constructor() {
    super({
      id: hde,
      label: f({
        key: "scrollDownHover",
        comment: [
          "Action that allows to scroll down in the hover widget with the up arrow when the hover widget is focused."
        ]
      }, "Scroll Down Hover"),
      alias: "Scroll Down Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 18,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("scrollDownHoverDescription", "Scroll down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.scrollDown();
  }
}
class jhe extends Vt {
  constructor() {
    super({
      id: ude,
      label: f({
        key: "scrollLeftHover",
        comment: [
          "Action that allows to scroll left in the hover widget with the left arrow when the hover widget is focused."
        ]
      }, "Scroll Left Hover"),
      alias: "Scroll Left Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 15,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("scrollLeftHoverDescription", "Scroll left the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.scrollLeft();
  }
}
class Yhe extends Vt {
  constructor() {
    super({
      id: gde,
      label: f({
        key: "scrollRightHover",
        comment: [
          "Action that allows to scroll right in the hover widget with the right arrow when the hover widget is focused."
        ]
      }, "Scroll Right Hover"),
      alias: "Scroll Right Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 17,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("scrollRightHoverDescription", "Scroll right the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.scrollRight();
  }
}
class Khe extends Vt {
  constructor() {
    super({
      id: fde,
      label: f({
        key: "pageUpHover",
        comment: [
          "Action that allows to page up in the hover widget with the page up command when the hover widget is focused."
        ]
      }, "Page Up Hover"),
      alias: "Page Up Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 11,
        secondary: [
          528
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("pageUpHoverDescription", "Page up the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.pageUp();
  }
}
class Jhe extends Vt {
  constructor() {
    super({
      id: mde,
      label: f({
        key: "pageDownHover",
        comment: [
          "Action that allows to page down in the hover widget with the page down command when the hover widget is focused."
        ]
      }, "Page Down Hover"),
      alias: "Page Down Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 12,
        secondary: [
          530
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("pageDownHoverDescription", "Page down the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.pageDown();
  }
}
class qhe extends Vt {
  constructor() {
    super({
      id: pde,
      label: f({
        key: "goToTopHover",
        comment: [
          "Action that allows to go to the top of the hover widget with the home command when the hover widget is focused."
        ]
      }, "Go To Top Hover"),
      alias: "Go To Bottom Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 14,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("goToTopHoverDescription", "Go to the top of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.goToTop();
  }
}
class $he extends Vt {
  constructor() {
    super({
      id: Ade,
      label: f({
        key: "goToBottomHover",
        comment: [
          "Action that allows to go to the bottom in the hover widget with the end command when the hover widget is focused."
        ]
      }, "Go To Bottom Hover"),
      alias: "Go To Bottom Hover",
      precondition: R.hoverFocused,
      kbOpts: {
        kbExpr: R.hoverFocused,
        primary: 13,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: ni("goToBottomHoverDescription", "Go to the bottom of the editor hover.")
      }
    });
  }
  run(e, t) {
    const i = zn.get(t);
    i && i.goToBottom();
  }
}
class Xhe extends Vt {
  constructor() {
    super({
      id: ES,
      label: _de,
      alias: "Increase Hover Verbosity Level",
      precondition: R.hoverVisible
    });
  }
  run(e, t, i) {
    const n = zn.get(t);
    if (!n)
      return;
    const o = i?.index !== void 0 ? i.index : n.focusedHoverPartIndex();
    n.updateHoverVerbosityLevel(fs.Increase, o, i?.focus);
  }
}
class Zhe extends Vt {
  constructor() {
    super({
      id: LS,
      label: bde,
      alias: "Decrease Hover Verbosity Level",
      precondition: R.hoverVisible
    });
  }
  run(e, t, i) {
    const n = zn.get(t);
    if (!n)
      return;
    const o = i?.index !== void 0 ? i.index : n.focusedHoverPartIndex();
    zn.get(t)?.updateHoverVerbosityLevel(fs.Decrease, o, i?.focus);
  }
}
const sa = class sa {
  constructor(e) {
    this.value = e;
  }
  equals(e) {
    return this.value === e.value;
  }
  contains(e) {
    return this.equals(e) || this.value === "" || e.value.startsWith(this.value + sa.sep);
  }
  intersects(e) {
    return this.contains(e) || e.contains(this);
  }
  append(...e) {
    return new sa((this.value ? [this.value, ...e] : e).join(sa.sep));
  }
};
sa.sep = ".", sa.None = new sa("@@none@@"), sa.Empty = new sa("");
let Zi = sa;
const Mi = new class {
  constructor() {
    this.QuickFix = new Zi("quickfix"), this.Refactor = new Zi("refactor"), this.RefactorExtract = this.Refactor.append("extract"), this.RefactorInline = this.Refactor.append("inline"), this.RefactorMove = this.Refactor.append("move"), this.RefactorRewrite = this.Refactor.append("rewrite"), this.Notebook = new Zi("notebook"), this.Source = new Zi("source"), this.SourceOrganizeImports = this.Source.append("organizeImports"), this.SourceFixAll = this.Source.append("fixAll"), this.SurroundWith = this.Refactor.append("surround");
  }
}();
var pd;
(function(s) {
  s.Refactor = "refactor", s.RefactorPreview = "refactor preview", s.Lightbulb = "lightbulb", s.Default = "other (default)", s.SourceAction = "source action", s.QuickFix = "quick fix action", s.FixAll = "fix all", s.OrganizeImports = "organize imports", s.AutoFix = "auto fix", s.QuickFixHover = "quick fix hover window", s.OnSave = "save participants", s.ProblemsView = "problems view";
})(pd || (pd = {}));
function eue(s, e) {
  return !(s.include && !s.include.intersects(e) || s.excludes && s.excludes.some((t) => OV(e, t, s.include)) || !s.includeSourceActions && Mi.Source.contains(e));
}
function tue(s, e) {
  const t = e.kind ? new Zi(e.kind) : void 0;
  return !(s.include && (!t || !s.include.contains(t)) || s.excludes && t && s.excludes.some((i) => OV(t, i, s.include)) || !s.includeSourceActions && t && Mi.Source.contains(t) || s.onlyIncludePreferredActions && !e.isPreferred);
}
function OV(s, e, t) {
  return !(!e.contains(s) || t && e.contains(t));
}
class ch {
  static fromUser(e, t) {
    return !e || typeof e != "object" ? new ch(t.kind, t.apply, !1) : new ch(ch.getKindFromUser(e, t.kind), ch.getApplyFromUser(e, t.apply), ch.getPreferredUser(e));
  }
  static getApplyFromUser(e, t) {
    switch (typeof e.apply == "string" ? e.apply.toLowerCase() : "") {
      case "first":
        return "first";
      case "never":
        return "never";
      case "ifsingle":
        return "ifSingle";
      default:
        return t;
    }
  }
  static getKindFromUser(e, t) {
    return typeof e.kind == "string" ? new Zi(e.kind) : t;
  }
  static getPreferredUser(e) {
    return typeof e.preferred == "boolean" ? e.preferred : !1;
  }
  constructor(e, t, i) {
    this.kind = e, this.apply = t, this.preferred = i;
  }
}
class iue {
  constructor(e, t, i) {
    this.action = e, this.provider = t, this.highlightRange = i;
  }
  async resolve(e) {
    if (this.provider?.resolveCodeAction && !this.action.edit) {
      let t;
      try {
        t = await this.provider.resolveCodeAction(this.action, e);
      } catch (i) {
        xs(i);
      }
      t && (this.action.edit = t.edit);
    }
    return this;
  }
}
const nue = "editor.action.codeAction", PV = "editor.action.quickFix", sue = "editor.action.autoFix", oue = "editor.action.refactor", rue = "editor.action.sourceAction", UP = "editor.action.organizeImports", QP = "editor.action.fixAll";
class sA extends V {
  static codeActionsPreferredComparator(e, t) {
    return e.isPreferred && !t.isPreferred ? -1 : !e.isPreferred && t.isPreferred ? 1 : 0;
  }
  static codeActionsComparator({ action: e }, { action: t }) {
    return e.isAI && !t.isAI ? 1 : !e.isAI && t.isAI ? -1 : Ys(e.diagnostics) ? Ys(t.diagnostics) ? sA.codeActionsPreferredComparator(e, t) : -1 : Ys(t.diagnostics) ? 1 : sA.codeActionsPreferredComparator(e, t);
  }
  constructor(e, t, i) {
    super(), this.documentation = t, this._register(i), this.allActions = [...e].sort(sA.codeActionsComparator), this.validActions = this.allActions.filter(({ action: n }) => !n.disabled);
  }
  get hasAutoFix() {
    return this.validActions.some(({ action: e }) => !!e.kind && Mi.QuickFix.contains(new Zi(e.kind)) && !!e.isPreferred);
  }
  get hasAIFix() {
    return this.validActions.some(({ action: e }) => !!e.isAI);
  }
  get allAIFixes() {
    return this.validActions.every(({ action: e }) => !!e.isAI);
  }
}
const GP = { actions: [], documentation: void 0 };
async function Kg(s, e, t, i, n, o) {
  const r = i.filter || {}, a = {
    ...r,
    excludes: [...r.excludes || [], Mi.Notebook]
  }, l = {
    only: r.include?.value,
    trigger: i.type
  }, c = new zce(e, o), d = i.type === 2, h = aue(s, e, d ? a : r), u = new X(), g = h.map(async (p) => {
    try {
      n.report(p);
      const A = await p.provideCodeActions(e, t, l, c.token);
      if (A && u.add(A), c.token.isCancellationRequested)
        return GP;
      const _ = (A?.actions || []).filter((C) => C && tue(r, C)), b = cue(p, _, r.include);
      return {
        actions: _.map((C) => new iue(C, p)),
        documentation: b
      };
    } catch (A) {
      if (Ad(A))
        throw A;
      return xs(A), GP;
    }
  }), m = s.onDidChange(() => {
    const p = s.all(e);
    pi(p, h) || c.cancel();
  });
  try {
    const p = await Promise.all(g), A = p.map((b) => b.actions).flat(), _ = [
      ...mm(p.map((b) => b.documentation)),
      ...lue(s, e, i, A)
    ];
    return new sA(A, _, u);
  } finally {
    m.dispose(), c.dispose();
  }
}
function aue(s, e, t) {
  return s.all(e).filter((i) => i.providedCodeActionKinds ? i.providedCodeActionKinds.some((n) => eue(t, new Zi(n))) : !0);
}
function* lue(s, e, t, i) {
  if (e && i.length)
    for (const n of s.all(e))
      n._getAdditionalMenuItems && (yield* n._getAdditionalMenuItems?.({ trigger: t.type, only: t.filter?.include?.value }, i.map((o) => o.action)));
}
function cue(s, e, t) {
  if (!s.documentation)
    return;
  const i = s.documentation.map((n) => ({ kind: new Zi(n.kind), command: n.command }));
  if (t) {
    let n;
    for (const o of i)
      o.kind.contains(t) && (n ? n.kind.contains(o.kind) && (n = o) : n = o);
    if (n)
      return n?.command;
  }
  for (const n of e)
    if (n.kind) {
      for (const o of i)
        if (o.kind.contains(new Zi(n.kind)))
          return o.command;
    }
}
var xh;
(function(s) {
  s.OnSave = "onSave", s.FromProblemsView = "fromProblemsView", s.FromCodeActions = "fromCodeActions", s.FromAILightbulb = "fromAILightbulb";
})(xh || (xh = {}));
async function due(s, e, t, i, n = ct.None) {
  const o = s.get(L3), r = s.get(bi), a = s.get(eo), l = s.get(Oi);
  if (a.publicLog2("codeAction.applyCodeAction", {
    codeActionTitle: e.action.title,
    codeActionKind: e.action.kind,
    codeActionIsPreferred: !!e.action.isPreferred,
    reason: t
  }), await e.resolve(n), !n.isCancellationRequested && !(e.action.edit?.edits.length && !(await o.apply(e.action.edit, {
    editor: i?.editor,
    label: e.action.title,
    quotableLabel: e.action.title,
    code: "undoredo.codeAction",
    respectAutoSaveConfig: t !== xh.OnSave,
    showPreview: i?.preview
  })).isApplied) && e.action.command)
    try {
      await r.executeCommand(e.action.command.id, ...e.action.command.arguments || []);
    } catch (c) {
      const d = hue(c);
      l.error(typeof d == "string" ? d : f("applyCodeActionFailed", "An unknown error occurred while applying the code action"));
    }
}
function hue(s) {
  return typeof s == "string" ? s : s instanceof Error && typeof s.message == "string" ? s.message : void 0;
}
mt.registerCommand("_executeCodeActionProvider", async function(s, e, t, i, n) {
  if (!(e instanceof _e))
    throw Go();
  const { codeActionProvider: o } = s.get(ye), r = s.get(Fi).getModel(e);
  if (!r)
    throw Go();
  const a = Ue.isISelection(t) ? Ue.liftSelection(t) : E.isIRange(t) ? r.validateRange(t) : void 0;
  if (!a)
    throw Go();
  const l = typeof i == "string" ? new Zi(i) : void 0, c = await Kg(o, r, a, { type: 1, triggerAction: pd.Default, filter: { includeSourceActions: !0, include: l } }, Ic.None, ct.None), d = [], h = Math.min(c.validActions.length, typeof n == "number" ? n : 0);
  for (let u = 0; u < h; u++)
    d.push(c.validActions[u].resolve(ct.None));
  try {
    return await Promise.all(d), c.validActions.map((u) => u.action);
  } finally {
    setTimeout(() => c.dispose(), 100);
  }
});
var uue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gue = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, LI, Xh;
let kI = (Xh = class {
  constructor(e) {
    this.keybindingService = e;
  }
  getResolver() {
    const e = new Br(() => this.keybindingService.getKeybindings().filter((t) => LI.codeActionCommands.indexOf(t.command) >= 0).filter((t) => t.resolvedKeybinding).map((t) => {
      let i = t.commandArgs;
      return t.command === UP ? i = { kind: Mi.SourceOrganizeImports.value } : t.command === QP && (i = { kind: Mi.SourceFixAll.value }), {
        resolvedKeybinding: t.resolvedKeybinding,
        ...ch.fromUser(i, {
          kind: Zi.None,
          apply: "never"
          /* CodeActionAutoApply.Never */
        })
      };
    }));
    return (t) => {
      if (t.kind)
        return this.bestKeybindingForCodeAction(t, e.value)?.resolvedKeybinding;
    };
  }
  bestKeybindingForCodeAction(e, t) {
    if (!e.kind)
      return;
    const i = new Zi(e.kind);
    return t.filter((n) => n.kind.contains(i)).filter((n) => n.preferred ? e.isPreferred : !0).reduceRight((n, o) => n ? n.kind.contains(o.kind) ? o : n : o, void 0);
  }
}, LI = Xh, Xh.codeActionCommands = [
  oue,
  nue,
  rue,
  UP,
  QP
], Xh);
kI = LI = uue([
  gue(0, bt)
], kI);
L("symbolIcon.arrayForeground", Re, f("symbolIcon.arrayForeground", "The foreground color for array symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.booleanForeground", Re, f("symbolIcon.booleanForeground", "The foreground color for boolean symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.classForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, f("symbolIcon.classForeground", "The foreground color for class symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.colorForeground", Re, f("symbolIcon.colorForeground", "The foreground color for color symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.constantForeground", Re, f("symbolIcon.constantForeground", "The foreground color for constant symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.constructorForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, f("symbolIcon.constructorForeground", "The foreground color for constructor symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.enumeratorForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, f("symbolIcon.enumeratorForeground", "The foreground color for enumerator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.enumeratorMemberForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, f("symbolIcon.enumeratorMemberForeground", "The foreground color for enumerator member symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.eventForeground", {
  dark: "#EE9D28",
  light: "#D67E00",
  hcDark: "#EE9D28",
  hcLight: "#D67E00"
}, f("symbolIcon.eventForeground", "The foreground color for event symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.fieldForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, f("symbolIcon.fieldForeground", "The foreground color for field symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.fileForeground", Re, f("symbolIcon.fileForeground", "The foreground color for file symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.folderForeground", Re, f("symbolIcon.folderForeground", "The foreground color for folder symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.functionForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, f("symbolIcon.functionForeground", "The foreground color for function symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.interfaceForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, f("symbolIcon.interfaceForeground", "The foreground color for interface symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.keyForeground", Re, f("symbolIcon.keyForeground", "The foreground color for key symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.keywordForeground", Re, f("symbolIcon.keywordForeground", "The foreground color for keyword symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.methodForeground", {
  dark: "#B180D7",
  light: "#652D90",
  hcDark: "#B180D7",
  hcLight: "#652D90"
}, f("symbolIcon.methodForeground", "The foreground color for method symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.moduleForeground", Re, f("symbolIcon.moduleForeground", "The foreground color for module symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.namespaceForeground", Re, f("symbolIcon.namespaceForeground", "The foreground color for namespace symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.nullForeground", Re, f("symbolIcon.nullForeground", "The foreground color for null symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.numberForeground", Re, f("symbolIcon.numberForeground", "The foreground color for number symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.objectForeground", Re, f("symbolIcon.objectForeground", "The foreground color for object symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.operatorForeground", Re, f("symbolIcon.operatorForeground", "The foreground color for operator symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.packageForeground", Re, f("symbolIcon.packageForeground", "The foreground color for package symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.propertyForeground", Re, f("symbolIcon.propertyForeground", "The foreground color for property symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.referenceForeground", Re, f("symbolIcon.referenceForeground", "The foreground color for reference symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.snippetForeground", Re, f("symbolIcon.snippetForeground", "The foreground color for snippet symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.stringForeground", Re, f("symbolIcon.stringForeground", "The foreground color for string symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.structForeground", Re, f("symbolIcon.structForeground", "The foreground color for struct symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.textForeground", Re, f("symbolIcon.textForeground", "The foreground color for text symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.typeParameterForeground", Re, f("symbolIcon.typeParameterForeground", "The foreground color for type parameter symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.unitForeground", Re, f("symbolIcon.unitForeground", "The foreground color for unit symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
L("symbolIcon.variableForeground", {
  dark: "#75BEFF",
  light: "#007ACC",
  hcDark: "#75BEFF",
  hcLight: "#007ACC"
}, f("symbolIcon.variableForeground", "The foreground color for variable symbols. These symbols appear in the outline, breadcrumb, and suggest widget."));
const HV = Object.freeze({ kind: Zi.Empty, title: f("codeAction.widget.id.more", "More Actions...") }), fue = Object.freeze([
  { kind: Mi.QuickFix, title: f("codeAction.widget.id.quickfix", "Quick Fix") },
  { kind: Mi.RefactorExtract, title: f("codeAction.widget.id.extract", "Extract"), icon: Z.wrench },
  { kind: Mi.RefactorInline, title: f("codeAction.widget.id.inline", "Inline"), icon: Z.wrench },
  { kind: Mi.RefactorRewrite, title: f("codeAction.widget.id.convert", "Rewrite"), icon: Z.wrench },
  { kind: Mi.RefactorMove, title: f("codeAction.widget.id.move", "Move"), icon: Z.wrench },
  { kind: Mi.SurroundWith, title: f("codeAction.widget.id.surround", "Surround With"), icon: Z.surroundWith },
  { kind: Mi.Source, title: f("codeAction.widget.id.source", "Source Action"), icon: Z.symbolFile },
  HV
]);
function mue(s, e, t) {
  if (!e)
    return s.map((o) => ({
      kind: "action",
      item: o,
      group: HV,
      disabled: !!o.action.disabled,
      label: o.action.disabled || o.action.title,
      canPreview: !!o.action.edit?.edits.length
    }));
  const i = fue.map((o) => ({ group: o, actions: [] }));
  for (const o of s) {
    const r = o.action.kind ? new Zi(o.action.kind) : Zi.None;
    for (const a of i)
      if (a.group.kind.contains(r)) {
        a.actions.push(o);
        break;
      }
  }
  const n = [];
  for (const o of i)
    if (o.actions.length) {
      n.push({ kind: "header", group: o.group });
      for (const r of o.actions) {
        const a = o.group;
        n.push({
          kind: "action",
          item: r,
          group: r.action.isAI ? { title: a.title, kind: a.kind, icon: Z.sparkle } : a,
          label: r.action.title,
          disabled: !!r.action.disabled,
          keybinding: t(r.action)
        });
      }
    }
  return n;
}
var pue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Aue = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, yg;
const jP = Rt("gutter-lightbulb", Z.lightBulb, f("gutterLightbulbWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor.")), YP = Rt("gutter-lightbulb-auto-fix", Z.lightbulbAutofix, f("gutterLightbulbAutoFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and a quick fix is available.")), KP = Rt("gutter-lightbulb-sparkle", Z.lightbulbSparkle, f("gutterLightbulbAIFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix is available.")), JP = Rt("gutter-lightbulb-aifix-auto-fix", Z.lightbulbSparkleAutofix, f("gutterLightbulbAIFixAutoFixWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available.")), qP = Rt("gutter-lightbulb-sparkle-filled", Z.sparkleFilled, f("gutterLightbulbSparkleFilledWidget", "Icon which spawns code actions menu from the gutter when there is no space in the editor and an AI fix and a quick fix is available."));
var br;
(function(s) {
  s.Hidden = {
    type: 0
    /* Type.Hidden */
  };
  class e {
    constructor(i, n, o, r) {
      this.actions = i, this.trigger = n, this.editorPosition = o, this.widgetPosition = r, this.type = 1;
    }
  }
  s.Showing = e;
})(br || (br = {}));
var Il;
let DI = (Il = class extends V {
  constructor(e, t) {
    super(), this._editor = e, this._keybindingService = t, this._onClick = this._register(new B()), this.onClick = this._onClick.event, this._state = br.Hidden, this._gutterState = br.Hidden, this._iconClasses = [], this.lightbulbClasses = [
      "codicon-" + jP.id,
      "codicon-" + JP.id,
      "codicon-" + YP.id,
      "codicon-" + KP.id,
      "codicon-" + qP.id
    ], this.gutterDecoration = yg.GUTTER_DECORATION, this._domNode = de("div.lightBulbWidget"), this._domNode.role = "listbox", this._register(xn.ignoreTarget(this._domNode)), this._editor.addContentWidget(this), this._register(this._editor.onDidChangeModelContent((i) => {
      const n = this._editor.getModel();
      (this.state.type !== 1 || !n || this.state.editorPosition.lineNumber >= n.getLineCount()) && this.hide(), (this.gutterState.type !== 1 || !n || this.gutterState.editorPosition.lineNumber >= n.getLineCount()) && this.gutterHide();
    })), this._register(O6(this._domNode, (i) => {
      if (this.state.type !== 1)
        return;
      this._editor.focus(), i.preventDefault();
      const { top: n, height: o } = ui(this._domNode), r = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let a = Math.floor(r / 3);
      this.state.widgetPosition.position !== null && this.state.widgetPosition.position.lineNumber < this.state.editorPosition.lineNumber && (a += r), this._onClick.fire({
        x: i.posx,
        y: n + o + a,
        actions: this.state.actions,
        trigger: this.state.trigger
      });
    })), this._register(U(this._domNode, "mouseenter", (i) => {
      (i.buttons & 1) === 1 && this.hide();
    })), this._register(te.runAndSubscribe(this._keybindingService.onDidUpdateKeybindings, () => {
      this._preferredKbLabel = this._keybindingService.lookupKeybinding(sue)?.getLabel() ?? void 0, this._quickFixKbLabel = this._keybindingService.lookupKeybinding(PV)?.getLabel() ?? void 0, this._updateLightBulbTitleAndIcon();
    })), this._register(this._editor.onMouseDown(async (i) => {
      if (!i.target.element || !this.lightbulbClasses.some((l) => i.target.element && i.target.element.classList.contains(l)) || this.gutterState.type !== 1)
        return;
      this._editor.focus();
      const { top: n, height: o } = ui(i.target.element), r = this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      );
      let a = Math.floor(r / 3);
      this.gutterState.widgetPosition.position !== null && this.gutterState.widgetPosition.position.lineNumber < this.gutterState.editorPosition.lineNumber && (a += r), this._onClick.fire({
        x: i.event.posx,
        y: n + o + a,
        actions: this.gutterState.actions,
        trigger: this.gutterState.trigger
      });
    }));
  }
  dispose() {
    super.dispose(), this._editor.removeContentWidget(this), this._gutterDecorationID && this._removeGutterDecoration(this._gutterDecorationID);
  }
  getId() {
    return "LightBulbWidget";
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._state.type === 1 ? this._state.widgetPosition : null;
  }
  update(e, t, i) {
    if (e.validActions.length <= 0)
      return this.gutterHide(), this.hide();
    if (!this._editor.hasTextFocus())
      return this.gutterHide(), this.hide();
    if (!this._editor.getOptions().get(
      65
      /* EditorOption.lightbulb */
    ).enabled)
      return this.gutterHide(), this.hide();
    const r = this._editor.getModel();
    if (!r)
      return this.gutterHide(), this.hide();
    const { lineNumber: a, column: l } = r.validatePosition(i), c = r.getOptions().tabSize, d = this._editor.getOptions().get(
      50
      /* EditorOption.fontInfo */
    ), h = r.getLineContent(a), u = dS(h, c), g = d.spaceWidth * u > 22, m = (S) => S > 2 && this._editor.getTopForLineNumber(S) === this._editor.getTopForLineNumber(S - 1), p = this._editor.getLineDecorations(a);
    let A = !1;
    if (p)
      for (const S of p) {
        const x = S.options.glyphMarginClassName;
        if (x && !this.lightbulbClasses.some((y) => x.includes(y))) {
          A = !0;
          break;
        }
      }
    let _ = a, b = 1;
    if (!g) {
      const S = (x) => {
        const y = r.getLineContent(x);
        return /^\s*$|^\s+/.test(y) || y.length <= b;
      };
      if (a > 1 && !m(a - 1)) {
        const x = r.getLineCount(), y = a === x, D = a > 1 && S(a - 1), I = !y && S(a + 1), Q = S(a), P = !I && !D;
        if (!I && !D && !A)
          return this.gutterState = new br.Showing(e, t, i, {
            position: { lineNumber: _, column: b },
            preference: yg._posPref
          }), this.renderGutterLightbub(), this.hide();
        D || y || D && !Q ? _ -= 1 : (I || P && Q) && (_ += 1);
      } else if (a === 1 && (a === r.getLineCount() || !S(a + 1) && !S(a)))
        if (this.gutterState = new br.Showing(e, t, i, {
          position: { lineNumber: _, column: b },
          preference: yg._posPref
        }), A)
          this.gutterHide();
        else
          return this.renderGutterLightbub(), this.hide();
      else if (a < r.getLineCount() && !m(a + 1))
        _ += 1;
      else if (l * d.spaceWidth < 22)
        return this.hide();
      b = /^\S\s*$/.test(r.getLineContent(_)) ? 2 : 1;
    }
    this.state = new br.Showing(e, t, i, {
      position: { lineNumber: _, column: b },
      preference: yg._posPref
    }), this._gutterDecorationID && (this._removeGutterDecoration(this._gutterDecorationID), this.gutterHide());
    const C = e.validActions, w = e.validActions[0].action.kind;
    if (C.length !== 1 || !w) {
      this._editor.layoutContentWidget(this);
      return;
    }
    this._editor.layoutContentWidget(this);
  }
  hide() {
    this.state !== br.Hidden && (this.state = br.Hidden, this._editor.layoutContentWidget(this));
  }
  gutterHide() {
    this.gutterState !== br.Hidden && (this._gutterDecorationID && this._removeGutterDecoration(this._gutterDecorationID), this.gutterState = br.Hidden);
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state = e, this._updateLightBulbTitleAndIcon();
  }
  get gutterState() {
    return this._gutterState;
  }
  set gutterState(e) {
    this._gutterState = e, this._updateGutterLightBulbTitleAndIcon();
  }
  _updateLightBulbTitleAndIcon() {
    if (this._domNode.classList.remove(...this._iconClasses), this._iconClasses = [], this.state.type !== 1)
      return;
    let e, t = !1;
    this.state.actions.allAIFixes ? (e = Z.sparkleFilled, this.state.actions.validActions.length === 1 && (t = !0)) : this.state.actions.hasAutoFix ? this.state.actions.hasAIFix ? e = Z.lightbulbSparkleAutofix : e = Z.lightbulbAutofix : this.state.actions.hasAIFix ? e = Z.lightbulbSparkle : e = Z.lightBulb, this._updateLightbulbTitle(this.state.actions.hasAutoFix, t), this._iconClasses = pe.asClassNameArray(e), this._domNode.classList.add(...this._iconClasses);
  }
  _updateGutterLightBulbTitleAndIcon() {
    if (this.gutterState.type !== 1)
      return;
    let e, t = !1;
    this.gutterState.actions.allAIFixes ? (e = qP, this.gutterState.actions.validActions.length === 1 && (t = !0)) : this.gutterState.actions.hasAutoFix ? this.gutterState.actions.hasAIFix ? e = JP : e = YP : this.gutterState.actions.hasAIFix ? e = KP : e = jP, this._updateLightbulbTitle(this.gutterState.actions.hasAutoFix, t);
    const i = He.register({
      description: "codicon-gutter-lightbulb-decoration",
      glyphMarginClassName: pe.asClassName(e),
      glyphMargin: { position: qo.Left },
      stickiness: 1
    });
    this.gutterDecoration = i;
  }
  /* Gutter Helper Functions */
  renderGutterLightbub() {
    const e = this._editor.getSelection();
    e && (this._gutterDecorationID === void 0 ? this._addGutterDecoration(e.startLineNumber) : this._updateGutterDecoration(this._gutterDecorationID, e.startLineNumber));
  }
  _addGutterDecoration(e) {
    this._editor.changeDecorations((t) => {
      this._gutterDecorationID = t.addDecoration(new E(e, 0, e, 0), this.gutterDecoration);
    });
  }
  _removeGutterDecoration(e) {
    this._editor.changeDecorations((t) => {
      t.removeDecoration(e), this._gutterDecorationID = void 0;
    });
  }
  _updateGutterDecoration(e, t) {
    this._editor.changeDecorations((i) => {
      i.changeDecoration(e, new E(t, 0, t, 0)), i.changeDecorationOptions(e, this.gutterDecoration);
    });
  }
  _updateLightbulbTitle(e, t) {
    this.state.type === 1 && (t ? this.title = f("codeActionAutoRun", "Run: {0}", this.state.actions.validActions[0].action.title) : e && this._preferredKbLabel ? this.title = f("preferredcodeActionWithKb", "Show Code Actions. Preferred Quick Fix Available ({0})", this._preferredKbLabel) : !e && this._quickFixKbLabel ? this.title = f("codeActionWithKb", "Show Code Actions ({0})", this._quickFixKbLabel) : e || (this.title = f("codeAction", "Show Code Actions")));
  }
  set title(e) {
    this._domNode.title = e;
  }
}, yg = Il, Il.GUTTER_DECORATION = He.register({
  description: "codicon-gutter-lightbulb-decoration",
  glyphMarginClassName: pe.asClassName(Z.lightBulb),
  glyphMargin: { position: qo.Left },
  stickiness: 1
}), Il.ID = "editor.contrib.lightbulbWidget", Il._posPref = [
  0
  /* ContentWidgetPositionPreference.EXACT */
], Il);
DI = yg = pue([
  Aue(1, bt)
], DI);
var WV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, II = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const VV = "acceptSelectedCodeAction", zV = "previewSelectedCodeAction";
class _ue {
  get templateId() {
    return "header";
  }
  renderTemplate(e) {
    e.classList.add("group-header");
    const t = document.createElement("span");
    return e.append(t), { container: e, text: t };
  }
  renderElement(e, t, i) {
    i.text.textContent = e.group?.title ?? "";
  }
  disposeTemplate(e) {
  }
}
let MI = class {
  get templateId() {
    return "action";
  }
  constructor(e, t) {
    this._supportsPreview = e, this._keybindingService = t;
  }
  renderTemplate(e) {
    e.classList.add(this.templateId);
    const t = document.createElement("div");
    t.className = "icon", e.append(t);
    const i = document.createElement("span");
    i.className = "title", e.append(i);
    const n = new j_(e, Us);
    return { container: e, icon: t, text: i, keybinding: n };
  }
  renderElement(e, t, i) {
    if (e.group?.icon ? (i.icon.className = pe.asClassName(e.group.icon), e.group.icon.color && (i.icon.style.color = oe(e.group.icon.color.id))) : (i.icon.className = pe.asClassName(Z.lightBulb), i.icon.style.color = "var(--vscode-editorLightBulb-foreground)"), !e.item || !e.label)
      return;
    i.text.textContent = UV(e.label), i.keybinding.set(e.keybinding), $6(!!e.keybinding, i.keybinding.element);
    const n = this._keybindingService.lookupKeybinding(VV)?.getLabel(), o = this._keybindingService.lookupKeybinding(zV)?.getLabel();
    i.container.classList.toggle("option-disabled", e.disabled), e.disabled ? i.container.title = e.label : n && o ? this._supportsPreview && e.canPreview ? i.container.title = f({ key: "label-preview", comment: ['placeholders are keybindings, e.g "F2 to Apply, Shift+F2 to Preview"'] }, "{0} to Apply, {1} to Preview", n, o) : i.container.title = f({ key: "label", comment: ['placeholder is a keybinding, e.g "F2 to Apply"'] }, "{0} to Apply", n) : i.container.title = "";
  }
  disposeTemplate(e) {
    e.keybinding.dispose();
  }
};
MI = WV([
  II(1, bt)
], MI);
class bue extends UIEvent {
  constructor() {
    super("acceptSelectedAction");
  }
}
class $P extends UIEvent {
  constructor() {
    super("previewSelectedAction");
  }
}
function wue(s) {
  if (s.kind === "action")
    return s.label;
}
let NI = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this._delegate = n, this._contextViewService = o, this._keybindingService = r, this._actionLineHeight = 24, this._headerLineHeight = 26, this.cts = this._register(new vs()), this.domNode = document.createElement("div"), this.domNode.classList.add("actionList");
    const a = {
      getHeight: (l) => l.kind === "header" ? this._headerLineHeight : this._actionLineHeight,
      getTemplateId: (l) => l.kind
    };
    this._list = this._register(new ko(e, this.domNode, a, [
      new MI(t, this._keybindingService),
      new _ue()
    ], {
      keyboardSupport: !1,
      typeNavigationEnabled: !0,
      keyboardNavigationLabelProvider: { getKeyboardNavigationLabel: wue },
      accessibilityProvider: {
        getAriaLabel: (l) => {
          if (l.kind === "action") {
            let c = l.label ? UV(l?.label) : "";
            return l.disabled && (c = f({ key: "customQuickFixWidget.labels", comment: ["Action widget labels for accessibility."] }, "{0}, Disabled Reason: {1}", c, l.disabled)), c;
          }
          return null;
        },
        getWidgetAriaLabel: () => f({ key: "customQuickFixWidget", comment: ["An action widget option"] }, "Action Widget"),
        getRole: (l) => l.kind === "action" ? "option" : "separator",
        getWidgetRole: () => "listbox"
      }
    })), this._list.style(Qu), this._register(this._list.onMouseClick((l) => this.onListClick(l))), this._register(this._list.onMouseOver((l) => this.onListHover(l))), this._register(this._list.onDidChangeFocus(() => this.onFocus())), this._register(this._list.onDidChangeSelection((l) => this.onListSelection(l))), this._allMenuItems = i, this._list.splice(0, this._list.length, this._allMenuItems), this._list.length && this.focusNext();
  }
  focusCondition(e) {
    return !e.disabled && e.kind === "action";
  }
  hide(e) {
    this._delegate.onHide(e), this.cts.cancel(), this._contextViewService.hideContextView();
  }
  layout(e) {
    const t = this._allMenuItems.filter((l) => l.kind === "header").length, n = this._allMenuItems.length * this._actionLineHeight + t * this._headerLineHeight - t * this._actionLineHeight;
    this._list.layout(n);
    let o = e;
    if (this._allMenuItems.length >= 50)
      o = 380;
    else {
      const l = this._allMenuItems.map((c, d) => {
        const h = this.domNode.ownerDocument.getElementById(this._list.getElementID(d));
        if (h) {
          h.style.width = "auto";
          const u = h.getBoundingClientRect().width;
          return h.style.width = "", u;
        }
        return 0;
      });
      o = Math.max(...l, e);
    }
    const a = Math.min(n, this.domNode.ownerDocument.body.clientHeight * 0.7);
    return this._list.layout(a, o), this.domNode.style.height = `${a}px`, this._list.domFocus(), o;
  }
  focusPrevious() {
    this._list.focusPrevious(1, !0, void 0, this.focusCondition);
  }
  focusNext() {
    this._list.focusNext(1, !0, void 0, this.focusCondition);
  }
  acceptSelected(e) {
    const t = this._list.getFocus();
    if (t.length === 0)
      return;
    const i = t[0], n = this._list.element(i);
    if (!this.focusCondition(n))
      return;
    const o = e ? new $P() : new bue();
    this._list.setSelection([i], o);
  }
  onListSelection(e) {
    if (!e.elements.length)
      return;
    const t = e.elements[0];
    t.item && this.focusCondition(t) ? this._delegate.onSelect(t.item, e.browserEvent instanceof $P) : this._list.setSelection([]);
  }
  onFocus() {
    const e = this._list.getFocus();
    if (e.length === 0)
      return;
    const t = e[0], i = this._list.element(t);
    this._delegate.onFocus?.(i.item);
  }
  async onListHover(e) {
    const t = e.element;
    if (t && t.item && this.focusCondition(t)) {
      if (this._delegate.onHover && !t.disabled && t.kind === "action") {
        const i = await this._delegate.onHover(t.item, this.cts.token);
        t.canPreview = i ? i.canPreview : void 0;
      }
      e.index && this._list.splice(e.index, 1, [t]);
    }
    this._list.setFocus(typeof e.index == "number" ? [e.index] : []);
  }
  onListClick(e) {
    e.element && this.focusCondition(e.element) && this._list.setFocus([]);
  }
};
NI = WV([
  II(4, Yl),
  II(5, bt)
], NI);
function UV(s) {
  return s.replace(/\r\n|\r|\n/g, " ");
}
var Cue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, fx = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
L("actionBar.toggledBackground", R_, f("actionBar.toggledBackground", "Background color for toggled action items in action bar."));
const Du = {
  Visible: new le("codeActionMenuVisible", !1, f("codeActionMenuVisible", "Whether the action widget list is visible"))
}, Xu = We("actionWidgetService");
let Iu = class extends V {
  get isVisible() {
    return Du.Visible.getValue(this._contextKeyService) || !1;
  }
  constructor(e, t, i) {
    super(), this._contextViewService = e, this._contextKeyService = t, this._instantiationService = i, this._list = this._register(new On());
  }
  show(e, t, i, n, o, r, a) {
    const l = Du.Visible.bindTo(this._contextKeyService), c = this._instantiationService.createInstance(NI, e, t, i, n);
    this._contextViewService.showContextView({
      getAnchor: () => o,
      render: (d) => (l.set(!0), this._renderWidget(d, c, a ?? [])),
      onHide: (d) => {
        l.reset(), this._onWidgetClosed(d);
      }
    }, r, !1);
  }
  acceptSelected(e) {
    this._list.value?.acceptSelected(e);
  }
  focusPrevious() {
    this._list?.value?.focusPrevious();
  }
  focusNext() {
    this._list?.value?.focusNext();
  }
  hide(e) {
    this._list.value?.hide(e), this._list.clear();
  }
  _renderWidget(e, t, i) {
    const n = document.createElement("div");
    if (n.classList.add("action-widget"), e.appendChild(n), this._list.value = t, this._list.value)
      n.appendChild(this._list.value.domNode);
    else
      throw new Error("List has no value");
    const o = new X(), r = document.createElement("div"), a = e.appendChild(r);
    a.classList.add("context-view-block"), o.add(U(a, ee.MOUSE_DOWN, (g) => g.stopPropagation()));
    const l = document.createElement("div"), c = e.appendChild(l);
    c.classList.add("context-view-pointerBlock"), o.add(U(c, ee.POINTER_MOVE, () => c.remove())), o.add(U(c, ee.MOUSE_DOWN, () => c.remove()));
    let d = 0;
    if (i.length) {
      const g = this._createActionBar(".action-widget-action-bar", i);
      g && (n.appendChild(g.getContainer().parentElement), o.add(g), d = g.getContainer().offsetWidth);
    }
    const h = this._list.value?.layout(d);
    n.style.width = `${h}px`;
    const u = o.add(Wl(e));
    return o.add(u.onDidBlur(() => this.hide(!0))), o;
  }
  _createActionBar(e, t) {
    if (!t.length)
      return;
    const i = de(e), n = new wo(i);
    return n.push(t, { icon: !1, label: !0 }), n;
  }
  _onWidgetClosed(e) {
    this._list.value?.hide(e);
  }
};
Iu = Cue([
  fx(0, Yl),
  fx(1, Se),
  fx(2, ke)
], Iu);
$e(
  Xu,
  Iu,
  1
  /* InstantiationType.Delayed */
);
const $_ = 1100;
os(class extends bm {
  constructor() {
    super({
      id: "hideCodeActionWidget",
      title: ni("hideCodeActionWidget.title", "Hide action widget"),
      precondition: Du.Visible,
      keybinding: {
        weight: $_,
        primary: 9,
        secondary: [
          1033
          /* KeyCode.Escape */
        ]
      }
    });
  }
  run(s) {
    s.get(Xu).hide(!0);
  }
});
os(class extends bm {
  constructor() {
    super({
      id: "selectPrevCodeAction",
      title: ni("selectPrevCodeAction.title", "Select previous action"),
      precondition: Du.Visible,
      keybinding: {
        weight: $_,
        primary: 16,
        secondary: [
          2064
          /* KeyCode.UpArrow */
        ],
        mac: { primary: 16, secondary: [
          2064,
          302
          /* KeyCode.KeyP */
        ] }
      }
    });
  }
  run(s) {
    const e = s.get(Xu);
    e instanceof Iu && e.focusPrevious();
  }
});
os(class extends bm {
  constructor() {
    super({
      id: "selectNextCodeAction",
      title: ni("selectNextCodeAction.title", "Select next action"),
      precondition: Du.Visible,
      keybinding: {
        weight: $_,
        primary: 18,
        secondary: [
          2066
          /* KeyCode.DownArrow */
        ],
        mac: { primary: 18, secondary: [
          2066,
          300
          /* KeyCode.KeyN */
        ] }
      }
    });
  }
  run(s) {
    const e = s.get(Xu);
    e instanceof Iu && e.focusNext();
  }
});
os(class extends bm {
  constructor() {
    super({
      id: VV,
      title: ni("acceptSelected.title", "Accept selected action"),
      precondition: Du.Visible,
      keybinding: {
        weight: $_,
        primary: 3,
        secondary: [
          2137
          /* KeyCode.Period */
        ]
      }
    });
  }
  run(s) {
    const e = s.get(Xu);
    e instanceof Iu && e.acceptSelected();
  }
});
os(class extends bm {
  constructor() {
    super({
      id: zV,
      title: ni("previewSelected.title", "Preview selected action"),
      precondition: Du.Visible,
      keybinding: {
        weight: $_,
        primary: 2051
      }
    });
  }
  run(s) {
    const e = s.get(Xu);
    e instanceof Iu && e.acceptSelected(!0);
  }
});
const vue = new le("supportedCodeAction", ""), XP = "_typescript.applyFixAllCodeAction";
class Sue extends V {
  constructor(e, t, i, n = 250) {
    super(), this._editor = e, this._markerService = t, this._signalChange = i, this._delay = n, this._autoTriggerTimer = this._register(new nr()), this._register(this._markerService.onMarkerChanged((o) => this._onMarkerChanges(o))), this._register(this._editor.onDidChangeCursorPosition(() => this._tryAutoTrigger()));
  }
  trigger(e) {
    const t = this._getRangeOfSelectionUnlessWhitespaceEnclosed(e);
    this._signalChange(t ? { trigger: e, selection: t } : void 0);
  }
  _onMarkerChanges(e) {
    const t = this._editor.getModel();
    t && e.some((i) => IN(i, t.uri)) && this._tryAutoTrigger();
  }
  _tryAutoTrigger() {
    this._autoTriggerTimer.cancelAndSet(() => {
      this.trigger({ type: 2, triggerAction: pd.Default });
    }, this._delay);
  }
  _getRangeOfSelectionUnlessWhitespaceEnclosed(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getSelection();
    if (e.type === 1)
      return t;
    const i = this._editor.getOption(
      65
      /* EditorOption.lightbulb */
    ).enabled;
    if (i !== Ho.Off) {
      {
        if (i === Ho.On)
          return t;
        if (i === Ho.OnCode) {
          if (!t.isEmpty())
            return t;
          const o = this._editor.getModel(), { lineNumber: r, column: a } = t.getPosition(), l = o.getLineContent(r);
          if (l.length === 0)
            return;
          if (a === 1) {
            if (/\s/.test(l[0]))
              return;
          } else if (a === o.getLineMaxColumn(r)) {
            if (/\s/.test(l[l.length - 1]))
              return;
          } else if (/\s/.test(l[a - 2]) && /\s/.test(l[a - 1]))
            return;
        }
      }
      return t;
    }
  }
}
var dh;
(function(s) {
  s.Empty = {
    type: 0
    /* Type.Empty */
  };
  class e {
    constructor(i, n, o) {
      this.trigger = i, this.position = n, this._cancellablePromise = o, this.type = 1, this.actions = o.catch((r) => {
        if (Ad(r))
          return QV;
        throw r;
      });
    }
    cancel() {
      this._cancellablePromise.cancel();
    }
  }
  s.Triggered = e;
})(dh || (dh = {}));
const QV = Object.freeze({
  allActions: [],
  validActions: [],
  dispose: () => {
  },
  documentation: [],
  hasAutoFix: !1,
  hasAIFix: !1,
  allAIFixes: !1
});
class yue extends V {
  constructor(e, t, i, n, o, r, a) {
    super(), this._editor = e, this._registry = t, this._markerService = i, this._progressService = o, this._configurationService = r, this._telemetryService = a, this._codeActionOracle = this._register(new On()), this._state = dh.Empty, this._onDidChangeState = this._register(new B()), this.onDidChangeState = this._onDidChangeState.event, this._disposed = !1, this._supportedCodeActions = vue.bindTo(n), this._register(this._editor.onDidChangeModel(() => this._update())), this._register(this._editor.onDidChangeModelLanguage(() => this._update())), this._register(this._registry.onDidChange(() => this._update())), this._register(this._editor.onDidChangeConfiguration((l) => {
      l.hasChanged(
        65
        /* EditorOption.lightbulb */
      ) && this._update();
    })), this._update();
  }
  dispose() {
    this._disposed || (this._disposed = !0, super.dispose(), this.setState(dh.Empty, !0));
  }
  _settingEnabledNearbyQuickfixes() {
    const e = this._editor?.getModel();
    return this._configurationService ? this._configurationService.getValue("editor.codeActionWidget.includeNearbyQuickFixes", { resource: e?.uri }) : !1;
  }
  _update() {
    if (this._disposed)
      return;
    this._codeActionOracle.value = void 0, this.setState(dh.Empty);
    const e = this._editor.getModel();
    if (e && this._registry.has(e) && !this._editor.getOption(
      92
      /* EditorOption.readOnly */
    )) {
      const t = this._registry.all(e).flatMap((i) => i.providedCodeActionKinds ?? []);
      this._supportedCodeActions.set(t.join(" ")), this._codeActionOracle.value = new Sue(this._editor, this._markerService, (i) => {
        if (!i) {
          this.setState(dh.Empty);
          return;
        }
        const n = i.selection.getStartPosition(), o = ir(async (l) => {
          if (this._settingEnabledNearbyQuickfixes() && i.trigger.type === 1 && (i.trigger.triggerAction === pd.QuickFix || i.trigger.filter?.include?.contains(Mi.QuickFix))) {
            const c = await Kg(this._registry, e, i.selection, i.trigger, Ic.None, l), d = [...c.allActions];
            if (l.isCancellationRequested)
              return QV;
            const h = c.validActions?.some((g) => g.action.kind ? Mi.QuickFix.contains(new Zi(g.action.kind)) : !1), u = this._markerService.read({ resource: e.uri });
            if (h) {
              for (const g of c.validActions)
                g.action.command?.arguments?.some((m) => typeof m == "string" && m.includes(XP)) && (g.action.diagnostics = [...u.filter((m) => m.relatedInformation)]);
              return { validActions: c.validActions, allActions: d, documentation: c.documentation, hasAutoFix: c.hasAutoFix, hasAIFix: c.hasAIFix, allAIFixes: c.allAIFixes, dispose: () => {
                c.dispose();
              } };
            } else if (!h && u.length > 0) {
              const g = i.selection.getPosition();
              let m = g, p = Number.MAX_VALUE;
              const A = [...c.validActions];
              for (const b of u) {
                const C = b.endColumn, w = b.endLineNumber, S = b.startLineNumber;
                if (w === g.lineNumber || S === g.lineNumber) {
                  m = new F(w, C);
                  const x = {
                    type: i.trigger.type,
                    triggerAction: i.trigger.triggerAction,
                    filter: { include: i.trigger.filter?.include ? i.trigger.filter?.include : Mi.QuickFix },
                    autoApply: i.trigger.autoApply,
                    context: { notAvailableMessage: i.trigger.context?.notAvailableMessage || "", position: m }
                  }, y = new Ue(m.lineNumber, m.column, m.lineNumber, m.column), D = await Kg(this._registry, e, y, x, Ic.None, l);
                  if (D.validActions.length !== 0) {
                    for (const I of D.validActions)
                      I.action.command?.arguments?.some((Q) => typeof Q == "string" && Q.includes(XP)) && (I.action.diagnostics = [...u.filter((Q) => Q.relatedInformation)]);
                    c.allActions.length === 0 && d.push(...D.allActions), Math.abs(g.column - C) < p ? A.unshift(...D.validActions) : A.push(...D.validActions);
                  }
                  p = Math.abs(g.column - C);
                }
              }
              const _ = A.filter((b, C, w) => w.findIndex((S) => S.action.title === b.action.title) === C);
              return _.sort((b, C) => b.action.isPreferred && !C.action.isPreferred ? -1 : !b.action.isPreferred && C.action.isPreferred || b.action.isAI && !C.action.isAI ? 1 : !b.action.isAI && C.action.isAI ? -1 : 0), { validActions: _, allActions: d, documentation: c.documentation, hasAutoFix: c.hasAutoFix, hasAIFix: c.hasAIFix, allAIFixes: c.allAIFixes, dispose: () => {
                c.dispose();
              } };
            }
          }
          if (i.trigger.type === 1) {
            const c = new es(), d = await Kg(this._registry, e, i.selection, i.trigger, Ic.None, l);
            return this._telemetryService && this._telemetryService.publicLog2("codeAction.invokedDurations", {
              codeActions: d.validActions.length,
              duration: c.elapsed()
            }), d;
          }
          return Kg(this._registry, e, i.selection, i.trigger, Ic.None, l);
        });
        i.trigger.type === 1 && this._progressService?.showWhile(o, 250);
        const r = new dh.Triggered(i.trigger, n, o);
        let a = !1;
        this._state.type === 1 && (a = this._state.trigger.type === 1 && r.type === 1 && r.trigger.type === 2 && this._state.position !== r.position), a ? setTimeout(() => {
          this.setState(r);
        }, 500) : this.setState(r);
      }, void 0), this._codeActionOracle.value.trigger({ type: 2, triggerAction: pd.Default });
    } else
      this._supportedCodeActions.reset();
  }
  trigger(e) {
    this._codeActionOracle.value?.trigger(e);
  }
  setState(e, t) {
    e !== this._state && (this._state.type === 1 && this._state.cancel(), this._state = e, !t && !this._disposed && this._onDidChangeState.fire(e));
  }
}
var xue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Kr = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, xg;
const Eue = "quickfix-edit-highlight";
var Zc;
let TI = (Zc = class extends V {
  static get(e) {
    return e.getContribution(xg.ID);
  }
  constructor(e, t, i, n, o, r, a, l, c, d, h) {
    super(), this._commandService = a, this._configurationService = l, this._actionWidgetService = c, this._instantiationService = d, this._telemetryService = h, this._activeCodeActions = this._register(new On()), this._showDisabled = !1, this._disposed = !1, this._editor = e, this._model = this._register(new yue(this._editor, o.codeActionProvider, t, i, r, l, this._telemetryService)), this._register(this._model.onDidChangeState((u) => this.update(u))), this._lightBulbWidget = new Br(() => {
      const u = this._editor.getContribution(DI.ID);
      return u && this._register(u.onClick((g) => this.showCodeActionsFromLightbulb(g.actions, g))), u;
    }), this._resolver = n.createInstance(kI), this._register(this._editor.onDidLayoutChange(() => this._actionWidgetService.hide()));
  }
  dispose() {
    this._disposed = !0, super.dispose();
  }
  async showCodeActionsFromLightbulb(e, t) {
    if (e.allAIFixes && e.validActions.length === 1) {
      const i = e.validActions[0], n = i.action.command;
      n && n.id === "inlineChat.start" && n.arguments && n.arguments.length >= 1 && (n.arguments[0] = { ...n.arguments[0], autoSend: !1 }), await this._applyCodeAction(i, !1, !1, xh.FromAILightbulb);
      return;
    }
    await this.showCodeActionList(e, t, { includeDisabledActions: !1, fromLightbulb: !0 });
  }
  showCodeActions(e, t, i) {
    return this.showCodeActionList(t, i, { includeDisabledActions: !1, fromLightbulb: !1 });
  }
  manualTriggerAtCurrentPosition(e, t, i, n) {
    if (!this._editor.hasModel())
      return;
    xa.get(this._editor)?.closeMessage();
    const o = this._editor.getPosition();
    this._trigger({ type: 1, triggerAction: t, filter: i, autoApply: n, context: { notAvailableMessage: e, position: o } });
  }
  _trigger(e) {
    return this._model.trigger(e);
  }
  async _applyCodeAction(e, t, i, n) {
    try {
      await this._instantiationService.invokeFunction(due, e, n, { preview: i, editor: this._editor });
    } finally {
      t && this._trigger({ type: 2, triggerAction: pd.QuickFix, filter: {} });
    }
  }
  hideLightBulbWidget() {
    this._lightBulbWidget.rawValue?.hide(), this._lightBulbWidget.rawValue?.gutterHide();
  }
  async update(e) {
    if (e.type !== 1) {
      this.hideLightBulbWidget();
      return;
    }
    let t;
    try {
      t = await e.actions;
    } catch (n) {
      Pe(n);
      return;
    }
    if (!(this._disposed || this._editor.getSelection()?.startLineNumber !== e.position.lineNumber))
      if (this._lightBulbWidget.value?.update(t, e.trigger, e.position), e.trigger.type === 1) {
        if (e.trigger.filter?.include) {
          const o = this.tryGetValidActionToApply(e.trigger, t);
          if (o) {
            try {
              this.hideLightBulbWidget(), await this._applyCodeAction(o, !1, !1, xh.FromCodeActions);
            } finally {
              t.dispose();
            }
            return;
          }
          if (e.trigger.context) {
            const r = this.getInvalidActionThatWouldHaveBeenApplied(e.trigger, t);
            if (r && r.action.disabled) {
              xa.get(this._editor)?.showMessage(r.action.disabled, e.trigger.context.position), t.dispose();
              return;
            }
          }
        }
        const n = !!e.trigger.filter?.include;
        if (e.trigger.context && (!t.allActions.length || !n && !t.validActions.length)) {
          xa.get(this._editor)?.showMessage(e.trigger.context.notAvailableMessage, e.trigger.context.position), this._activeCodeActions.value = t, t.dispose();
          return;
        }
        this._activeCodeActions.value = t, this.showCodeActionList(t, this.toCoords(e.position), { includeDisabledActions: n, fromLightbulb: !1 });
      } else
        this._actionWidgetService.isVisible ? t.dispose() : this._activeCodeActions.value = t;
  }
  getInvalidActionThatWouldHaveBeenApplied(e, t) {
    if (t.allActions.length && (e.autoApply === "first" && t.validActions.length === 0 || e.autoApply === "ifSingle" && t.allActions.length === 1))
      return t.allActions.find(({ action: i }) => i.disabled);
  }
  tryGetValidActionToApply(e, t) {
    if (t.validActions.length && (e.autoApply === "first" && t.validActions.length > 0 || e.autoApply === "ifSingle" && t.validActions.length === 1))
      return t.validActions[0];
  }
  async showCodeActionList(e, t, i) {
    const n = this._editor.createDecorationsCollection(), o = this._editor.getDomNode();
    if (!o)
      return;
    const r = i.includeDisabledActions && (this._showDisabled || e.validActions.length === 0) ? e.allActions : e.validActions;
    if (!r.length)
      return;
    const a = F.isIPosition(t) ? this.toCoords(t) : t, l = {
      onSelect: async (c, d) => {
        this._applyCodeAction(
          c,
          /* retrigger */
          !0,
          !!d,
          i.fromLightbulb ? xh.FromAILightbulb : xh.FromCodeActions
        ), this._actionWidgetService.hide(!1), n.clear();
      },
      onHide: (c) => {
        this._editor?.focus(), n.clear();
      },
      onHover: async (c, d) => {
        if (d.isCancellationRequested)
          return;
        let h = !1;
        const u = c.action.kind;
        if (u) {
          const g = new Zi(u);
          h = [
            Mi.RefactorExtract,
            Mi.RefactorInline,
            Mi.RefactorRewrite,
            Mi.RefactorMove,
            Mi.Source
          ].some((p) => p.contains(g));
        }
        return { canPreview: h || !!c.action.edit?.edits.length };
      },
      onFocus: (c) => {
        if (c && c.action) {
          const d = c.action.ranges, h = c.action.diagnostics;
          if (n.clear(), d && d.length > 0) {
            const u = h && h?.length > 1 ? h.map((g) => ({ range: g, options: xg.DECORATION })) : d.map((g) => ({ range: g, options: xg.DECORATION }));
            n.set(u);
          } else if (h && h.length > 0) {
            const u = h.map((m) => ({ range: m, options: xg.DECORATION }));
            n.set(u);
            const g = h[0];
            if (g.startLineNumber && g.startColumn) {
              const m = this._editor.getModel()?.getWordAtPosition({ lineNumber: g.startLineNumber, column: g.startColumn })?.word;
              vu(f("editingNewSelection", "Context: {0} at line {1} and column {2}.", m, g.startLineNumber, g.startColumn));
            }
          }
        } else
          n.clear();
      }
    };
    this._actionWidgetService.show("codeActionWidget", !0, mue(r, this._shouldShowHeaders(), this._resolver.getResolver()), l, a, o, this._getActionBarActions(e, t, i));
  }
  toCoords(e) {
    if (!this._editor.hasModel())
      return { x: 0, y: 0 };
    this._editor.revealPosition(
      e,
      1
      /* ScrollType.Immediate */
    ), this._editor.render();
    const t = this._editor.getScrolledVisiblePosition(e), i = ui(this._editor.getDomNode()), n = i.left + t.left, o = i.top + t.top + t.height;
    return { x: n, y: o };
  }
  _shouldShowHeaders() {
    const e = this._editor?.getModel();
    return this._configurationService.getValue("editor.codeActionWidget.showHeaders", { resource: e?.uri });
  }
  _getActionBarActions(e, t, i) {
    if (i.fromLightbulb)
      return [];
    const n = e.documentation.map((o) => ({
      id: o.id,
      label: o.title,
      tooltip: o.tooltip ?? "",
      class: void 0,
      enabled: !0,
      run: () => this._commandService.executeCommand(o.id, ...o.arguments ?? [])
    }));
    return i.includeDisabledActions && e.validActions.length > 0 && e.allActions.length !== e.validActions.length && n.push(this._showDisabled ? {
      id: "hideMoreActions",
      label: f("hideMoreActions", "Hide Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !1, this.showCodeActionList(e, t, i))
    } : {
      id: "showMoreActions",
      label: f("showMoreActions", "Show Disabled"),
      enabled: !0,
      tooltip: "",
      class: void 0,
      run: () => (this._showDisabled = !0, this.showCodeActionList(e, t, i))
    }), n;
  }
}, xg = Zc, Zc.ID = "editor.contrib.codeActionController", Zc.DECORATION = He.register({
  description: "quickfix-highlight",
  className: Eue
}), Zc);
TI = xg = xue([
  Kr(1, Pa),
  Kr(2, Se),
  Kr(3, ke),
  Kr(4, ye),
  Kr(5, P_),
  Kr(6, bi),
  Kr(7, ht),
  Kr(8, Xu),
  Kr(9, ke),
  Kr(10, eo)
], TI);
rr((s, e) => {
  ((n, o) => {
    o && e.addRule(`.monaco-editor ${n} { background-color: ${o}; }`);
  })(".quickfix-edit-highlight", s.getColor(Cl));
  const i = s.getColor(Lc);
  i && e.addRule(`.monaco-editor .quickfix-edit-highlight { border: 1px ${Ca(s.type) ? "dotted" : "solid"} ${i}; box-sizing: border-box; }`);
});
var GV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Zv = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class ZP {
  constructor(e, t, i) {
    this.marker = e, this.index = t, this.total = i;
  }
}
let BI = class {
  constructor(e, t, i) {
    this._markerService = t, this._configService = i, this._onDidChange = new B(), this.onDidChange = this._onDidChange.event, this._dispoables = new X(), this._markers = [], this._nextIdx = -1, _e.isUri(e) ? this._resourceFilter = (a) => a.toString() === e.toString() : e && (this._resourceFilter = e);
    const n = this._configService.getValue("problems.sortOrder"), o = (a, l) => {
      let c = LA(a.resource.toString(), l.resource.toString());
      return c === 0 && (n === "position" ? c = E.compareRangesUsingStarts(a, l) || Yt.compare(a.severity, l.severity) : c = Yt.compare(a.severity, l.severity) || E.compareRangesUsingStarts(a, l)), c;
    }, r = () => {
      this._markers = this._markerService.read({
        resource: _e.isUri(e) ? e : void 0,
        severities: Yt.Error | Yt.Warning | Yt.Info
      }), typeof e == "function" && (this._markers = this._markers.filter((a) => this._resourceFilter(a.resource))), this._markers.sort(o);
    };
    r(), this._dispoables.add(t.onMarkerChanged((a) => {
      (!this._resourceFilter || a.some((l) => this._resourceFilter(l))) && (r(), this._nextIdx = -1, this._onDidChange.fire());
    }));
  }
  dispose() {
    this._dispoables.dispose(), this._onDidChange.dispose();
  }
  matches(e) {
    return !this._resourceFilter && !e ? !0 : !this._resourceFilter || !e ? !1 : this._resourceFilter(e);
  }
  get selected() {
    const e = this._markers[this._nextIdx];
    return e && new ZP(e, this._nextIdx + 1, this._markers.length);
  }
  _initIdx(e, t, i) {
    let n = !1, o = this._markers.findIndex((r) => r.resource.toString() === e.uri.toString());
    o < 0 && (o = wM(this._markers, { resource: e.uri }, (r, a) => LA(r.resource.toString(), a.resource.toString())), o < 0 && (o = ~o));
    for (let r = o; r < this._markers.length; r++) {
      let a = E.lift(this._markers[r]);
      if (a.isEmpty()) {
        const l = e.getWordAtPosition(a.getStartPosition());
        l && (a = new E(a.startLineNumber, l.startColumn, a.startLineNumber, l.endColumn));
      }
      if (t && (a.containsPosition(t) || t.isBeforeOrEqual(a.getStartPosition()))) {
        this._nextIdx = r, n = !0;
        break;
      }
      if (this._markers[r].resource.toString() !== e.uri.toString())
        break;
    }
    n || (this._nextIdx = i ? 0 : this._markers.length - 1), this._nextIdx < 0 && (this._nextIdx = this._markers.length - 1);
  }
  resetIndex() {
    this._nextIdx = -1;
  }
  move(e, t, i) {
    if (this._markers.length === 0)
      return !1;
    const n = this._nextIdx;
    return this._nextIdx === -1 ? this._initIdx(t, i, e) : e ? this._nextIdx = (this._nextIdx + 1) % this._markers.length : e || (this._nextIdx = (this._nextIdx - 1 + this._markers.length) % this._markers.length), n !== this._nextIdx;
  }
  find(e, t) {
    let i = this._markers.findIndex((n) => n.resource.toString() === e.toString());
    if (!(i < 0)) {
      for (; i < this._markers.length; i++)
        if (E.containsPosition(this._markers[i], t))
          return new ZP(this._markers[i], i + 1, this._markers.length);
    }
  }
};
BI = GV([
  Zv(1, Pa),
  Zv(2, ht)
], BI);
const jV = We("IMarkerNavigationService");
let RI = class {
  constructor(e, t) {
    this._markerService = e, this._configService = t, this._provider = new Nn();
  }
  getMarkerList(e) {
    for (const t of this._provider) {
      const i = t.getMarkerList(e);
      if (i)
        return i;
    }
    return new BI(e, this._markerService, this._configService);
  }
};
RI = GV([
  Zv(0, Pa),
  Zv(1, ht)
], RI);
$e(
  jV,
  RI,
  1
  /* InstantiationType.Delayed */
);
var FI;
(function(s) {
  function e(t) {
    switch (t) {
      case ii.Ignore:
        return "severity-ignore " + pe.asClassName(Z.info);
      case ii.Info:
        return pe.asClassName(Z.info);
      case ii.Warning:
        return pe.asClassName(Z.warning);
      case ii.Error:
        return pe.asClassName(Z.error);
      default:
        return "";
    }
  }
  s.className = e;
})(FI || (FI = {}));
var Lue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ag = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, OI;
class kue {
  constructor(e, t, i, n, o) {
    this._openerService = n, this._labelService = o, this._lines = 0, this._longestLineLength = 0, this._relatedDiagnostics = /* @__PURE__ */ new WeakMap(), this._disposables = new X(), this._editor = t;
    const r = document.createElement("div");
    r.className = "descriptioncontainer", this._messageBlock = document.createElement("div"), this._messageBlock.classList.add("message"), this._messageBlock.setAttribute("aria-live", "assertive"), this._messageBlock.setAttribute("role", "alert"), r.appendChild(this._messageBlock), this._relatedBlock = document.createElement("div"), r.appendChild(this._relatedBlock), this._disposables.add(Xt(this._relatedBlock, "click", (a) => {
      a.preventDefault();
      const l = this._relatedDiagnostics.get(a.target);
      l && i(l);
    })), this._scrollable = new c3(r, {
      horizontal: 1,
      vertical: 1,
      useShadows: !1,
      horizontalScrollbarSize: 6,
      verticalScrollbarSize: 6
    }), e.appendChild(this._scrollable.getDomNode()), this._disposables.add(this._scrollable.onScroll((a) => {
      r.style.left = `-${a.scrollLeft}px`, r.style.top = `-${a.scrollTop}px`;
    })), this._disposables.add(this._scrollable);
  }
  dispose() {
    Ct(this._disposables);
  }
  update(e) {
    const { source: t, message: i, relatedInformation: n, code: o } = e;
    let r = (t?.length || 0) + 2;
    o && (typeof o == "string" ? r += o.length : r += o.value.length);
    const a = bd(i);
    this._lines = a.length, this._longestLineLength = 0;
    for (const u of a)
      this._longestLineLength = Math.max(u.length + r, this._longestLineLength);
    Bn(this._messageBlock), this._messageBlock.setAttribute("aria-label", this.getAriaLabel(e)), this._editor.applyFontInfo(this._messageBlock);
    let l = this._messageBlock;
    for (const u of a)
      l = document.createElement("div"), l.innerText = u, u === "" && (l.style.height = this._messageBlock.style.lineHeight), this._messageBlock.appendChild(l);
    if (t || o) {
      const u = document.createElement("span");
      if (u.classList.add("details"), l.appendChild(u), t) {
        const g = document.createElement("span");
        g.innerText = t, g.classList.add("source"), u.appendChild(g);
      }
      if (o)
        if (typeof o == "string") {
          const g = document.createElement("span");
          g.innerText = `(${o})`, g.classList.add("code"), u.appendChild(g);
        } else {
          this._codeLink = de("a.code-link"), this._codeLink.setAttribute("href", `${o.target.toString()}`), this._codeLink.onclick = (m) => {
            this._openerService.open(o.target, { allowCommands: !0 }), m.preventDefault(), m.stopPropagation();
          };
          const g = K(this._codeLink, de("span"));
          g.innerText = o.value, u.appendChild(this._codeLink);
        }
    }
    if (Bn(this._relatedBlock), this._editor.applyFontInfo(this._relatedBlock), Ys(n)) {
      const u = this._relatedBlock.appendChild(document.createElement("div"));
      u.style.paddingTop = `${Math.floor(this._editor.getOption(
        67
        /* EditorOption.lineHeight */
      ) * 0.66)}px`, this._lines += 1;
      for (const g of n) {
        const m = document.createElement("div"), p = document.createElement("a");
        p.classList.add("filename"), p.innerText = `${this._labelService.getUriBasenameLabel(g.resource)}(${g.startLineNumber}, ${g.startColumn}): `, p.title = this._labelService.getUriLabel(g.resource), this._relatedDiagnostics.set(p, g);
        const A = document.createElement("span");
        A.innerText = g.message, m.appendChild(p), m.appendChild(A), this._lines += 1, u.appendChild(m);
      }
    }
    const c = this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), d = Math.ceil(c.typicalFullwidthCharacterWidth * this._longestLineLength * 0.75), h = c.lineHeight * this._lines;
    this._scrollable.setScrollDimensions({ scrollWidth: d, scrollHeight: h });
  }
  layout(e, t) {
    this._scrollable.getDomNode().style.height = `${e}px`, this._scrollable.getDomNode().style.width = `${t}px`, this._scrollable.setScrollDimensions({ width: t, height: e });
  }
  getHeightInLines() {
    return Math.min(17, this._lines);
  }
  getAriaLabel(e) {
    let t = "";
    switch (e.severity) {
      case Yt.Error:
        t = f("Error", "Error");
        break;
      case Yt.Warning:
        t = f("Warning", "Warning");
        break;
      case Yt.Info:
        t = f("Info", "Info");
        break;
      case Yt.Hint:
        t = f("Hint", "Hint");
        break;
    }
    let i = f("marker aria", "{0} at {1}. ", t, e.startLineNumber + ":" + e.startColumn);
    const n = this._editor.getModel();
    return n && e.startLineNumber <= n.getLineCount() && e.startLineNumber >= 1 && (i = `${n.getLineContent(e.startLineNumber)}, ${i}`), i;
  }
}
var Zh;
let v_ = (Zh = class extends Uv {
  constructor(e, t, i, n, o, r, a) {
    super(e, { showArrow: !0, showFrame: !0, isAccessible: !0, frameWidth: 1 }, o), this._themeService = t, this._openerService = i, this._menuService = n, this._contextKeyService = r, this._labelService = a, this._callOnDispose = new X(), this._onDidSelectRelatedInformation = new B(), this.onDidSelectRelatedInformation = this._onDidSelectRelatedInformation.event, this._severity = Yt.Warning, this._backgroundColor = Y.white, this._applyTheme(t.getColorTheme()), this._callOnDispose.add(t.onDidColorThemeChange(this._applyTheme.bind(this))), this.create();
  }
  _applyTheme(e) {
    this._backgroundColor = e.getColor(Nue);
    let t = PI, i = Due;
    this._severity === Yt.Warning ? (t = Qw, i = Iue) : this._severity === Yt.Info && (t = HI, i = Mue);
    const n = e.getColor(t), o = e.getColor(i);
    this.style({
      arrowColor: n,
      frameColor: n,
      headerBackgroundColor: o,
      primaryHeadingColor: e.getColor(uV),
      secondaryHeadingColor: e.getColor(gV)
    });
  }
  _applyStyles() {
    this._parentContainer && (this._parentContainer.style.backgroundColor = this._backgroundColor ? this._backgroundColor.toString() : ""), super._applyStyles();
  }
  dispose() {
    this._callOnDispose.dispose(), super.dispose();
  }
  _fillHead(e) {
    super._fillHead(e), this._disposables.add(this._actionbarWidget.actionRunner.onWillRun((n) => this.editor.focus()));
    const t = [], i = this._menuService.getMenuActions(OI.TitleMenu, this._contextKeyService);
    UN(i, t), this._actionbarWidget.push(t, { label: !1, icon: !0, index: 0 });
  }
  _fillTitleIcon(e) {
    this._icon = K(e, de(""));
  }
  _fillBody(e) {
    this._parentContainer = e, e.classList.add("marker-widget"), this._parentContainer.tabIndex = 0, this._parentContainer.setAttribute("role", "tooltip"), this._container = document.createElement("div"), e.appendChild(this._container), this._message = new kue(this._container, this.editor, (t) => this._onDidSelectRelatedInformation.fire(t), this._openerService, this._labelService), this._disposables.add(this._message);
  }
  show() {
    throw new Error("call showAtMarker");
  }
  showAtMarker(e, t, i) {
    this._container.classList.remove("stale"), this._message.update(e), this._severity = e.severity, this._applyTheme(this._themeService.getColorTheme());
    const n = E.lift(e), o = this.editor.getPosition(), r = o && n.containsPosition(o) ? o : n.getStartPosition();
    super.show(r, this.computeRequiredHeight());
    const a = this.editor.getModel();
    if (a) {
      const l = i > 1 ? f("problems", "{0} of {1} problems", t, i) : f("change", "{0} of {1} problem", t, i);
      this.setTitle(Xo(a.uri), l);
    }
    this._icon.className = `codicon ${FI.className(Yt.toSeverity(this._severity))}`, this.editor.revealPositionNearTop(
      r,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  updateMarker(e) {
    this._container.classList.remove("stale"), this._message.update(e);
  }
  showStale() {
    this._container.classList.add("stale"), this._relayout();
  }
  _doLayoutBody(e, t) {
    super._doLayoutBody(e, t), this._heightInPixel = e, this._message.layout(e, t), this._container.style.height = `${e}px`;
  }
  _onWidth(e) {
    this._message.layout(this._heightInPixel, e);
  }
  _relayout() {
    super._relayout(this.computeRequiredHeight());
  }
  computeRequiredHeight() {
    return 3 + this._message.getHeightInLines();
  }
}, OI = Zh, Zh.TitleMenu = new Qe("gotoErrorTitleMenu"), Zh);
v_ = OI = Lue([
  Ag(1, nn),
  Ag(2, lr),
  Ag(3, sr),
  Ag(4, ke),
  Ag(5, Se),
  Ag(6, Zf)
], v_);
const e4 = WA(U0, Wj), t4 = WA(zl, VA), i4 = WA(Da, zA), PI = L("editorMarkerNavigationError.background", { dark: e4, light: e4, hcDark: Je, hcLight: Je }, f("editorMarkerNavigationError", "Editor marker navigation widget error color.")), Due = L("editorMarkerNavigationError.headerBackground", { dark: Me(PI, 0.1), light: Me(PI, 0.1), hcDark: null, hcLight: null }, f("editorMarkerNavigationErrorHeaderBackground", "Editor marker navigation widget error heading background.")), Qw = L("editorMarkerNavigationWarning.background", { dark: t4, light: t4, hcDark: Je, hcLight: Je }, f("editorMarkerNavigationWarning", "Editor marker navigation widget warning color.")), Iue = L("editorMarkerNavigationWarning.headerBackground", { dark: Me(Qw, 0.1), light: Me(Qw, 0.1), hcDark: "#0C141F", hcLight: Me(Qw, 0.2) }, f("editorMarkerNavigationWarningBackground", "Editor marker navigation widget warning heading background.")), HI = L("editorMarkerNavigationInfo.background", { dark: i4, light: i4, hcDark: Je, hcLight: Je }, f("editorMarkerNavigationInfo", "Editor marker navigation widget info color.")), Mue = L("editorMarkerNavigationInfo.headerBackground", { dark: Me(HI, 0.1), light: Me(HI, 0.1), hcDark: null, hcLight: null }, f("editorMarkerNavigationInfoHeaderBackground", "Editor marker navigation widget info heading background.")), Nue = L("editorMarkerNavigation.background", $o, f("editorMarkerNavigationBackground", "Editor marker navigation widget background."));
var Tue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Xb = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, yp, eu;
let Mu = (eu = class {
  static get(e) {
    return e.getContribution(yp.ID);
  }
  constructor(e, t, i, n, o) {
    this._markerNavigationService = t, this._contextKeyService = i, this._editorService = n, this._instantiationService = o, this._sessionDispoables = new X(), this._editor = e, this._widgetVisible = YV.bindTo(this._contextKeyService);
  }
  dispose() {
    this._cleanUp(), this._sessionDispoables.dispose();
  }
  _cleanUp() {
    this._widgetVisible.reset(), this._sessionDispoables.clear(), this._widget = void 0, this._model = void 0;
  }
  _getOrCreateModel(e) {
    if (this._model && this._model.matches(e))
      return this._model;
    let t = !1;
    return this._model && (t = !0, this._cleanUp()), this._model = this._markerNavigationService.getMarkerList(e), t && this._model.move(!0, this._editor.getModel(), this._editor.getPosition()), this._widget = this._instantiationService.createInstance(v_, this._editor), this._widget.onDidClose(() => this.close(), this, this._sessionDispoables), this._widgetVisible.set(!0), this._sessionDispoables.add(this._model), this._sessionDispoables.add(this._widget), this._sessionDispoables.add(this._editor.onDidChangeCursorPosition((i) => {
      (!this._model?.selected || !E.containsPosition(this._model?.selected.marker, i.position)) && this._model?.resetIndex();
    })), this._sessionDispoables.add(this._model.onDidChange(() => {
      if (!this._widget || !this._widget.position || !this._model)
        return;
      const i = this._model.find(this._editor.getModel().uri, this._widget.position);
      i ? this._widget.updateMarker(i.marker) : this._widget.showStale();
    })), this._sessionDispoables.add(this._widget.onDidSelectRelatedInformation((i) => {
      this._editorService.openCodeEditor({
        resource: i.resource,
        options: { pinned: !0, revealIfOpened: !0, selection: E.lift(i).collapseToStart() }
      }, this._editor), this.close(!1);
    })), this._sessionDispoables.add(this._editor.onDidChangeModel(() => this._cleanUp())), this._model;
  }
  close(e = !0) {
    this._cleanUp(), e && this._editor.focus();
  }
  showAtMarker(e) {
    if (this._editor.hasModel()) {
      const t = this._getOrCreateModel(this._editor.getModel().uri);
      t.resetIndex(), t.move(!0, this._editor.getModel(), new F(e.startLineNumber, e.startColumn)), t.selected && this._widget.showAtMarker(t.selected.marker, t.selected.index, t.selected.total);
    }
  }
  async nagivate(e, t) {
    if (this._editor.hasModel()) {
      const i = this._getOrCreateModel(t ? void 0 : this._editor.getModel().uri);
      if (i.move(e, this._editor.getModel(), this._editor.getPosition()), !i.selected)
        return;
      if (i.selected.marker.resource.toString() !== this._editor.getModel().uri.toString()) {
        this._cleanUp();
        const n = await this._editorService.openCodeEditor({
          resource: i.selected.marker.resource,
          options: { pinned: !1, revealIfOpened: !0, selectionRevealType: 2, selection: i.selected.marker }
        }, this._editor);
        n && (yp.get(n)?.close(), yp.get(n)?.nagivate(e, t));
      } else
        this._widget.showAtMarker(i.selected.marker, i.selected.index, i.selected.total);
    }
  }
}, yp = eu, eu.ID = "editor.contrib.markerController", eu);
Mu = yp = Tue([
  Xb(1, jV),
  Xb(2, Se),
  Xb(3, Nt),
  Xb(4, ke)
], Mu);
class TS extends Vt {
  constructor(e, t, i) {
    super(i), this._next = e, this._multiFile = t;
  }
  async run(e, t) {
    t.hasModel() && Mu.get(t)?.nagivate(this._next, this._multiFile);
  }
}
const ph = class ph extends TS {
  constructor() {
    super(!0, !1, {
      id: ph.ID,
      label: ph.LABEL,
      alias: "Go to Next Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 578,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: v_.TitleMenu,
        title: ph.LABEL,
        icon: Rt("marker-navigation-next", Z.arrowDown, f("nextMarkerIcon", "Icon for goto next marker.")),
        group: "navigation",
        order: 1
      }
    });
  }
};
ph.ID = "editor.action.marker.next", ph.LABEL = f("markerAction.next.label", "Go to Next Problem (Error, Warning, Info)");
let e1 = ph;
const Ah = class Ah extends TS {
  constructor() {
    super(!1, !1, {
      id: Ah.ID,
      label: Ah.LABEL,
      alias: "Go to Previous Problem (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 1602,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: v_.TitleMenu,
        title: Ah.LABEL,
        icon: Rt("marker-navigation-previous", Z.arrowUp, f("previousMarkerIcon", "Icon for goto previous marker.")),
        group: "navigation",
        order: 2
      }
    });
  }
};
Ah.ID = "editor.action.marker.prev", Ah.LABEL = f("markerAction.previous.label", "Go to Previous Problem (Error, Warning, Info)");
let WI = Ah;
class Bue extends TS {
  constructor() {
    super(!0, !0, {
      id: "editor.action.marker.nextInFiles",
      label: f("markerAction.nextInFiles.label", "Go to Next Problem in Files (Error, Warning, Info)"),
      alias: "Go to Next Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 66,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: Qe.MenubarGoMenu,
        title: f({ key: "miGotoNextProblem", comment: ["&& denotes a mnemonic"] }, "Next &&Problem"),
        group: "6_problem_nav",
        order: 1
      }
    });
  }
}
class Rue extends TS {
  constructor() {
    super(!1, !0, {
      id: "editor.action.marker.prevInFiles",
      label: f("markerAction.previousInFiles.label", "Go to Previous Problem in Files (Error, Warning, Info)"),
      alias: "Go to Previous Problem in Files (Error, Warning, Info)",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 1090,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: Qe.MenubarGoMenu,
        title: f({ key: "miGotoPreviousProblem", comment: ["&& denotes a mnemonic"] }, "Previous &&Problem"),
        group: "6_problem_nav",
        order: 2
      }
    });
  }
}
rs(
  Mu.ID,
  Mu,
  4
  /* EditorContributionInstantiation.Lazy */
);
Ge(e1);
Ge(WI);
Ge(Bue);
Ge(Rue);
const YV = new le("markersNavigationVisible", !1), Fue = Wn.bindToContribution(Mu.get);
re(new Fue({
  id: "closeMarkersNavigation",
  precondition: YV,
  handler: (s) => s.close(),
  kbOpts: {
    weight: 150,
    kbExpr: R.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
var Oue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, mx = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const Mo = de;
class Pue {
  constructor(e, t, i) {
    this.owner = e, this.range = t, this.marker = i;
  }
  isValidForHoverAnchor(e) {
    return e.type === 1 && this.range.startColumn <= e.range.startColumn && this.range.endColumn >= e.range.endColumn;
  }
}
const n4 = {
  type: 1,
  filter: { include: Mi.QuickFix },
  triggerAction: pd.QuickFixHover
};
let VI = class {
  constructor(e, t, i, n) {
    this._editor = e, this._markerDecorationsService = t, this._openerService = i, this._languageFeaturesService = n, this.hoverOrdinal = 1, this.recentMarkerCodeActionsInfo = void 0;
  }
  computeSync(e, t) {
    if (!this._editor.hasModel() || e.type !== 1 && !e.supportsMarkerHover)
      return [];
    const i = this._editor.getModel(), n = e.range.startLineNumber, o = i.getLineMaxColumn(n), r = [];
    for (const a of t) {
      const l = a.range.startLineNumber === n ? a.range.startColumn : 1, c = a.range.endLineNumber === n ? a.range.endColumn : o, d = this._markerDecorationsService.getMarker(i.uri, a);
      if (!d)
        continue;
      const h = new E(e.range.startLineNumber, l, e.range.startLineNumber, c);
      r.push(new Pue(this, h, d));
    }
    return r;
  }
  renderHoverParts(e, t) {
    if (!t.length)
      return new w_([]);
    const i = new X(), n = [];
    t.forEach((r) => {
      const a = this._renderMarkerHover(r);
      e.fragment.appendChild(a.hoverElement), n.push(a);
    });
    const o = t.length === 1 ? t[0] : t.sort((r, a) => Yt.compare(r.marker.severity, a.marker.severity))[0];
    return this.renderMarkerStatusbar(e, o, i), new w_(n);
  }
  _renderMarkerHover(e) {
    const t = new X(), i = Mo("div.hover-row"), n = K(i, Mo("div.marker.hover-contents")), { source: o, message: r, code: a, relatedInformation: l } = e.marker;
    this._editor.applyFontInfo(n);
    const c = K(n, Mo("span"));
    if (c.style.whiteSpace = "pre-wrap", c.innerText = r, o || a)
      if (a && typeof a != "string") {
        const h = Mo("span");
        if (o) {
          const p = K(h, Mo("span"));
          p.innerText = o;
        }
        const u = K(h, Mo("a.code-link"));
        u.setAttribute("href", a.target.toString()), t.add(U(u, "click", (p) => {
          this._openerService.open(a.target, { allowCommands: !0 }), p.preventDefault(), p.stopPropagation();
        }));
        const g = K(u, Mo("span"));
        g.innerText = a.value;
        const m = K(n, h);
        m.style.opacity = "0.6", m.style.paddingLeft = "6px";
      } else {
        const h = K(n, Mo("span"));
        h.style.opacity = "0.6", h.style.paddingLeft = "6px", h.innerText = o && a ? `${o}(${a})` : o || `(${a})`;
      }
    if (Ys(l))
      for (const { message: h, resource: u, startLineNumber: g, startColumn: m } of l) {
        const p = K(n, Mo("div"));
        p.style.marginTop = "8px";
        const A = K(p, Mo("a"));
        A.innerText = `${Xo(u)}(${g}, ${m}): `, A.style.cursor = "pointer", t.add(U(A, "click", (b) => {
          if (b.stopPropagation(), b.preventDefault(), this._openerService) {
            const C = { selection: { startLineNumber: g, startColumn: m } };
            this._openerService.open(u, {
              fromUserGesture: !0,
              editorOptions: C
            }).catch(Pe);
          }
        }));
        const _ = K(p, Mo("span"));
        _.innerText = h, this._editor.applyFontInfo(_);
      }
    return {
      hoverPart: e,
      hoverElement: i,
      dispose: () => t.dispose()
    };
  }
  renderMarkerStatusbar(e, t, i) {
    if (t.marker.severity === Yt.Error || t.marker.severity === Yt.Warning || t.marker.severity === Yt.Info) {
      const n = Mu.get(this._editor);
      n && e.statusBar.addAction({
        label: f("view problem", "View Problem"),
        commandId: e1.ID,
        run: () => {
          e.hide(), n.showAtMarker(t.marker), this._editor.focus();
        }
      });
    }
    if (!this._editor.getOption(
      92
      /* EditorOption.readOnly */
    )) {
      const n = e.statusBar.append(Mo("div"));
      this.recentMarkerCodeActionsInfo && (UC.makeKey(this.recentMarkerCodeActionsInfo.marker) === UC.makeKey(t.marker) ? this.recentMarkerCodeActionsInfo.hasCodeActions || (n.textContent = f("noQuickFixes", "No quick fixes available")) : this.recentMarkerCodeActionsInfo = void 0);
      const o = this.recentMarkerCodeActionsInfo && !this.recentMarkerCodeActionsInfo.hasCodeActions ? V.None : zf(() => n.textContent = f("checkingForQuickFixes", "Checking for quick fixes..."), 200, i);
      n.textContent || (n.textContent = " ");
      const r = this.getCodeActions(t.marker);
      i.add(we(() => r.cancel())), r.then((a) => {
        if (o.dispose(), this.recentMarkerCodeActionsInfo = { marker: t.marker, hasCodeActions: a.validActions.length > 0 }, !this.recentMarkerCodeActionsInfo.hasCodeActions) {
          a.dispose(), n.textContent = f("noQuickFixes", "No quick fixes available");
          return;
        }
        n.style.display = "none";
        let l = !1;
        i.add(we(() => {
          l || a.dispose();
        })), e.statusBar.addAction({
          label: f("quick fixes", "Quick Fix..."),
          commandId: PV,
          run: (c) => {
            l = !0;
            const d = TI.get(this._editor), h = ui(c);
            e.hide(), d?.showCodeActions(n4, a, {
              x: h.left,
              y: h.top,
              width: h.width,
              height: h.height
            });
          }
        });
      }, Pe);
    }
  }
  getCodeActions(e) {
    return ir((t) => Kg(this._languageFeaturesService.codeActionProvider, this._editor.getModel(), new E(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), n4, Ic.None, t));
  }
};
VI = Oue([
  mx(1, KN),
  mx(2, lr),
  mx(3, ye)
], VI);
class Hue {
  get lineNumber() {
    return this._lineNumber;
  }
  set lineNumber(e) {
    this._lineNumber = e;
  }
  get lane() {
    return this._laneOrLine;
  }
  set lane(e) {
    this._laneOrLine = e;
  }
  constructor(e) {
    this._editor = e, this._lineNumber = -1, this._laneOrLine = qo.Center;
  }
  computeSync() {
    const e = (o) => ({
      value: o
    }), t = this._editor.getLineDecorations(this._lineNumber), i = [], n = this._laneOrLine === "lineNo";
    if (!t)
      return i;
    for (const o of t) {
      const r = o.options.glyphMargin?.position ?? qo.Center;
      if (!n && r !== this._laneOrLine)
        continue;
      const a = n ? o.options.lineNumberHoverMessage : o.options.glyphMarginHoverMessage;
      !a || Xf(a) || i.push(...H4(a).map(e));
    }
    return i;
  }
}
var Wue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, s4 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, zI;
const o4 = de;
var tu;
let UI = (tu = class extends V {
  constructor(e, t, i) {
    super(), this._renderDisposeables = this._register(new X()), this._editor = e, this._isVisible = !1, this._messages = [], this._hover = this._register(new yN()), this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible), this._markdownRenderer = this._register(new Cu({ editor: this._editor }, t, i)), this._computer = new Hue(this._editor), this._hoverOperation = this._register(new wV(this._editor, this._computer)), this._register(this._hoverOperation.onResult((n) => {
      this._withResult(n.value);
    })), this._register(this._editor.onDidChangeModelDecorations(() => this._onModelDecorationsChanged())), this._register(this._editor.onDidChangeConfiguration((n) => {
      n.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._updateFont();
    })), this._register(Xt(this._hover.containerDomNode, "mouseleave", (n) => {
      this._onMouseLeave(n);
    })), this._editor.addOverlayWidget(this);
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  getId() {
    return zI.ID;
  }
  getDomNode() {
    return this._hover.containerDomNode;
  }
  getPosition() {
    return null;
  }
  _updateFont() {
    Array.prototype.slice.call(this._hover.contentsDomNode.getElementsByClassName("code")).forEach((t) => this._editor.applyFontInfo(t));
  }
  _onModelDecorationsChanged() {
    this._isVisible && (this._hoverOperation.cancel(), this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  showsOrWillShow(e) {
    const t = e.target;
    return t.type === 2 && t.detail.glyphMarginLane ? (this._startShowingAt(t.position.lineNumber, t.detail.glyphMarginLane), !0) : t.type === 3 ? (this._startShowingAt(t.position.lineNumber, "lineNo"), !0) : !1;
  }
  _startShowingAt(e, t) {
    this._computer.lineNumber === e && this._computer.lane === t || (this._hoverOperation.cancel(), this.hide(), this._computer.lineNumber = e, this._computer.lane = t, this._hoverOperation.start(
      0
      /* HoverStartMode.Delayed */
    ));
  }
  hide() {
    this._computer.lineNumber = -1, this._hoverOperation.cancel(), this._isVisible && (this._isVisible = !1, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
  }
  _withResult(e) {
    this._messages = e, this._messages.length > 0 ? this._renderMessages(this._computer.lineNumber, this._messages) : this.hide();
  }
  _renderMessages(e, t) {
    this._renderDisposeables.clear();
    const i = document.createDocumentFragment();
    for (const n of t) {
      const o = o4("div.hover-row.markdown-hover"), r = K(o, o4("div.hover-contents")), a = this._renderDisposeables.add(this._markdownRenderer.render(n.value));
      r.appendChild(a.element), i.appendChild(o);
    }
    this._updateContents(i), this._showAt(e);
  }
  _updateContents(e) {
    this._hover.contentsDomNode.textContent = "", this._hover.contentsDomNode.appendChild(e), this._updateFont();
  }
  _showAt(e) {
    this._isVisible || (this._isVisible = !0, this._hover.containerDomNode.classList.toggle("hidden", !this._isVisible));
    const t = this._editor.getLayoutInfo(), i = this._editor.getTopForLineNumber(e), n = this._editor.getScrollTop(), o = this._editor.getOption(
      67
      /* EditorOption.lineHeight */
    ), r = this._hover.containerDomNode.clientHeight, a = i - n - (r - o) / 2, l = t.glyphMarginLeft + t.glyphMarginWidth + (this._computer.lane === "lineNo" ? t.lineNumbersWidth : 0);
    this._hover.containerDomNode.style.left = `${l}px`, this._hover.containerDomNode.style.top = `${Math.max(Math.round(a), 0)}px`;
  }
  _onMouseLeave(e) {
    const t = this._editor.getDomNode();
    (!t || !NS(t, e.x, e.y)) && this.hide();
  }
}, zI = tu, tu.ID = "editor.contrib.modesGlyphHoverWidget", tu);
UI = zI = Wue([
  s4(1, si),
  s4(2, lr)
], UI);
var Vue = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, zue = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Of;
let t1 = (Of = class extends V {
  constructor(e, t) {
    super(), this._editor = e, this._instantiationService = t, this.shouldKeepOpenOnEditorMouseMoveOrLeave = !1, this._listenersStore = new X(), this._hoverState = {
      mouseDown: !1
    }, this._reactToEditorMouseMoveRunner = this._register(new zt(() => this._reactToEditorMouseMove(this._mouseMoveEvent), 0)), this._hookListeners(), this._register(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        60
        /* EditorOption.hover */
      ) && (this._unhookListeners(), this._hookListeners());
    }));
  }
  _hookListeners() {
    const e = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._hoverSettings = {
      enabled: e.enabled,
      sticky: e.sticky,
      hidingDelay: e.hidingDelay
    }, e.enabled ? (this._listenersStore.add(this._editor.onMouseDown((t) => this._onEditorMouseDown(t))), this._listenersStore.add(this._editor.onMouseUp(() => this._onEditorMouseUp())), this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))) : (this._listenersStore.add(this._editor.onMouseMove((t) => this._onEditorMouseMove(t))), this._listenersStore.add(this._editor.onKeyDown((t) => this._onKeyDown(t)))), this._listenersStore.add(this._editor.onMouseLeave((t) => this._onEditorMouseLeave(t))), this._listenersStore.add(this._editor.onDidChangeModel(() => {
      this._cancelScheduler(), this._hideWidgets();
    })), this._listenersStore.add(this._editor.onDidChangeModelContent(() => this._cancelScheduler())), this._listenersStore.add(this._editor.onDidScrollChange((t) => this._onEditorScrollChanged(t)));
  }
  _unhookListeners() {
    this._listenersStore.clear();
  }
  _cancelScheduler() {
    this._mouseMoveEvent = void 0, this._reactToEditorMouseMoveRunner.cancel();
  }
  _onEditorScrollChanged(e) {
    (e.scrollTopChanged || e.scrollLeftChanged) && this._hideWidgets();
  }
  _onEditorMouseDown(e) {
    this._hoverState.mouseDown = !0, !this._isMouseOnMarginHoverWidget(e) && this._hideWidgets();
  }
  _isMouseOnMarginHoverWidget(e) {
    const t = this._glyphWidget?.getDomNode();
    return t ? NS(t, e.event.posx, e.event.posy) : !1;
  }
  _onEditorMouseUp() {
    this._hoverState.mouseDown = !1;
  }
  _onEditorMouseLeave(e) {
    this.shouldKeepOpenOnEditorMouseMoveOrLeave || (this._cancelScheduler(), this._isMouseOnMarginHoverWidget(e)) || this._hideWidgets();
  }
  _shouldNotRecomputeCurrentHoverWidget(e) {
    const t = this._hoverSettings.sticky, i = this._isMouseOnMarginHoverWidget(e);
    return t && i;
  }
  _onEditorMouseMove(e) {
    if (this.shouldKeepOpenOnEditorMouseMoveOrLeave)
      return;
    if (this._mouseMoveEvent = e, this._shouldNotRecomputeCurrentHoverWidget(e)) {
      this._reactToEditorMouseMoveRunner.cancel();
      return;
    }
    this._reactToEditorMouseMove(e);
  }
  _reactToEditorMouseMove(e) {
    !e || this._tryShowHoverWidget(e) || this._hideWidgets();
  }
  _tryShowHoverWidget(e) {
    return this._getOrCreateGlyphWidget().showsOrWillShow(e);
  }
  _onKeyDown(e) {
    this._editor.hasModel() && (e.keyCode === 5 || e.keyCode === 6 || e.keyCode === 57 || e.keyCode === 4 || this._hideWidgets());
  }
  _hideWidgets() {
    this._glyphWidget?.hide();
  }
  _getOrCreateGlyphWidget() {
    return this._glyphWidget || (this._glyphWidget = this._instantiationService.createInstance(UI, this._editor)), this._glyphWidget;
  }
  dispose() {
    super.dispose(), this._unhookListeners(), this._listenersStore.dispose(), this._glyphWidget?.dispose();
  }
}, Of.ID = "editor.contrib.marginHover", Of);
t1 = Vue([
  zue(1, ke)
], t1);
const gB = new class {
  constructor() {
    this._implementations = [];
  }
  register(e) {
    return this._implementations.push(e), {
      dispose: () => {
        const t = this._implementations.indexOf(e);
        t !== -1 && this._implementations.splice(t, 1);
      }
    };
  }
  getImplementations() {
    return this._implementations;
  }
}();
class Uue {
}
class Que {
}
class Gue {
}
rs(
  zn.ID,
  zn,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
rs(
  t1.ID,
  t1,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Ge(zhe);
Ge(Uhe);
Ge(Qhe);
Ge(Ghe);
Ge(jhe);
Ge(Yhe);
Ge(Khe);
Ge(Jhe);
Ge(qhe);
Ge($he);
Ge(Xhe);
Ge(Zhe);
aB.register(C_);
aB.register(VI);
rr((s, e) => {
  const t = s.getColor(e3);
  t && (e.addRule(`.monaco-editor .monaco-hover .hover-row:not(:first-child):not(:empty) { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-top: 1px solid ${t.transparent(0.5)}; }`), e.addRule(`.monaco-editor .monaco-hover hr { border-bottom: 0px solid ${t.transparent(0.5)}; }`));
});
gB.register(new Uue());
gB.register(new Que());
gB.register(new Gue());
const Fo = class Fo {
  constructor() {
    this.value = "", this.pos = 0;
  }
  static isDigitCharacter(e) {
    return e >= 48 && e <= 57;
  }
  static isVariableCharacter(e) {
    return e === 95 || e >= 97 && e <= 122 || e >= 65 && e <= 90;
  }
  text(e) {
    this.value = e, this.pos = 0;
  }
  tokenText(e) {
    return this.value.substr(e.pos, e.len);
  }
  next() {
    if (this.pos >= this.value.length)
      return { type: 14, pos: this.pos, len: 0 };
    const e = this.pos;
    let t = 0, i = this.value.charCodeAt(e), n;
    if (n = Fo._table[i], typeof n == "number")
      return this.pos += 1, { type: n, pos: e, len: 1 };
    if (Fo.isDigitCharacter(i)) {
      n = 8;
      do
        t += 1, i = this.value.charCodeAt(e + t);
      while (Fo.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    if (Fo.isVariableCharacter(i)) {
      n = 9;
      do
        i = this.value.charCodeAt(e + ++t);
      while (Fo.isVariableCharacter(i) || Fo.isDigitCharacter(i));
      return this.pos += t, { type: n, pos: e, len: t };
    }
    n = 10;
    do
      t += 1, i = this.value.charCodeAt(e + t);
    while (!isNaN(i) && typeof Fo._table[i] > "u" && !Fo.isDigitCharacter(i) && !Fo.isVariableCharacter(i));
    return this.pos += t, { type: n, pos: e, len: t };
  }
};
Fo._table = {
  36: 0,
  58: 1,
  44: 2,
  123: 3,
  125: 4,
  92: 5,
  47: 6,
  124: 7,
  43: 11,
  45: 12,
  63: 13
};
let QI = Fo;
class Im {
  constructor() {
    this._children = [];
  }
  appendChild(e) {
    return e instanceof qn && this._children[this._children.length - 1] instanceof qn ? this._children[this._children.length - 1].value += e.value : (e.parent = this, this._children.push(e)), this;
  }
  replace(e, t) {
    const { parent: i } = e, n = i.children.indexOf(e), o = i.children.slice(0);
    o.splice(n, 1, ...t), i._children = o, function r(a, l) {
      for (const c of a)
        c.parent = l, r(c.children, c);
    }(t, i);
  }
  get children() {
    return this._children;
  }
  get rightMostDescendant() {
    return this._children.length > 0 ? this._children[this._children.length - 1].rightMostDescendant : this;
  }
  get snippet() {
    let e = this;
    for (; ; ) {
      if (!e)
        return;
      if (e instanceof X_)
        return e;
      e = e.parent;
    }
  }
  toString() {
    return this.children.reduce((e, t) => e + t.toString(), "");
  }
  len() {
    return 0;
  }
}
class qn extends Im {
  constructor(e) {
    super(), this.value = e;
  }
  toString() {
    return this.value;
  }
  len() {
    return this.value.length;
  }
  clone() {
    return new qn(this.value);
  }
}
class KV extends Im {
}
class ho extends KV {
  static compareByIndex(e, t) {
    return e.index === t.index ? 0 : e.isFinalTabstop ? 1 : t.isFinalTabstop || e.index < t.index ? -1 : e.index > t.index ? 1 : 0;
  }
  constructor(e) {
    super(), this.index = e;
  }
  get isFinalTabstop() {
    return this.index === 0;
  }
  get choice() {
    return this._children.length === 1 && this._children[0] instanceof Mm ? this._children[0] : void 0;
  }
  clone() {
    const e = new ho(this.index);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
class Mm extends Im {
  constructor() {
    super(...arguments), this.options = [];
  }
  appendChild(e) {
    return e instanceof qn && (e.parent = this, this.options.push(e)), this;
  }
  toString() {
    return this.options[0].value;
  }
  len() {
    return this.options[0].len();
  }
  clone() {
    const e = new Mm();
    return this.options.forEach(e.appendChild, e), e;
  }
}
class fB extends Im {
  constructor() {
    super(...arguments), this.regexp = new RegExp("");
  }
  resolve(e) {
    const t = this;
    let i = !1, n = e.replace(this.regexp, function() {
      return i = !0, t._replace(Array.prototype.slice.call(arguments, 0, -2));
    });
    return !i && this._children.some((o) => o instanceof vr && !!o.elseValue) && (n = this._replace([])), n;
  }
  _replace(e) {
    let t = "";
    for (const i of this._children)
      if (i instanceof vr) {
        let n = e[i.index] || "";
        n = i.resolve(n), t += n;
      } else
        t += i.toString();
    return t;
  }
  toString() {
    return "";
  }
  clone() {
    const e = new fB();
    return e.regexp = new RegExp(this.regexp.source, (this.regexp.ignoreCase ? "i" : "") + (this.regexp.global ? "g" : "")), e._children = this.children.map((t) => t.clone()), e;
  }
}
class vr extends Im {
  constructor(e, t, i, n) {
    super(), this.index = e, this.shorthandName = t, this.ifValue = i, this.elseValue = n;
  }
  resolve(e) {
    return this.shorthandName === "upcase" ? e ? e.toLocaleUpperCase() : "" : this.shorthandName === "downcase" ? e ? e.toLocaleLowerCase() : "" : this.shorthandName === "capitalize" ? e ? e[0].toLocaleUpperCase() + e.substr(1) : "" : this.shorthandName === "pascalcase" ? e ? this._toPascalCase(e) : "" : this.shorthandName === "camelcase" ? e ? this._toCamelCase(e) : "" : e && typeof this.ifValue == "string" ? this.ifValue : !e && typeof this.elseValue == "string" ? this.elseValue : e || "";
  }
  _toPascalCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i) => i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  _toCamelCase(e) {
    const t = e.match(/[a-z0-9]+/gi);
    return t ? t.map((i, n) => n === 0 ? i.charAt(0).toLowerCase() + i.substr(1) : i.charAt(0).toUpperCase() + i.substr(1)).join("") : e;
  }
  clone() {
    return new vr(this.index, this.shorthandName, this.ifValue, this.elseValue);
  }
}
class S_ extends KV {
  constructor(e) {
    super(), this.name = e;
  }
  resolve(e) {
    let t = e.resolve(this);
    return this.transform && (t = this.transform.resolve(t || "")), t !== void 0 ? (this._children = [new qn(t)], !0) : !1;
  }
  clone() {
    const e = new S_(this.name);
    return this.transform && (e.transform = this.transform.clone()), e._children = this.children.map((t) => t.clone()), e;
  }
}
function r4(s, e) {
  const t = [...s];
  for (; t.length > 0; ) {
    const i = t.shift();
    if (!e(i))
      break;
    t.unshift(...i.children);
  }
}
class X_ extends Im {
  get placeholderInfo() {
    if (!this._placeholders) {
      const e = [];
      let t;
      this.walk(function(i) {
        return i instanceof ho && (e.push(i), t = !t || t.index < i.index ? i : t), !0;
      }), this._placeholders = { all: e, last: t };
    }
    return this._placeholders;
  }
  get placeholders() {
    const { all: e } = this.placeholderInfo;
    return e;
  }
  offset(e) {
    let t = 0, i = !1;
    return this.walk((n) => n === e ? (i = !0, !1) : (t += n.len(), !0)), i ? t : -1;
  }
  fullLen(e) {
    let t = 0;
    return r4([e], (i) => (t += i.len(), !0)), t;
  }
  enclosingPlaceholders(e) {
    const t = [];
    let { parent: i } = e;
    for (; i; )
      i instanceof ho && t.push(i), i = i.parent;
    return t;
  }
  resolveVariables(e) {
    return this.walk((t) => (t instanceof S_ && t.resolve(e) && (this._placeholders = void 0), !0)), this;
  }
  appendChild(e) {
    return this._placeholders = void 0, super.appendChild(e);
  }
  replace(e, t) {
    return this._placeholders = void 0, super.replace(e, t);
  }
  clone() {
    const e = new X_();
    return this._children = this.children.map((t) => t.clone()), e;
  }
  walk(e) {
    r4(this.children, e);
  }
}
class i1 {
  constructor() {
    this._scanner = new QI(), this._token = { type: 14, pos: 0, len: 0 };
  }
  static escape(e) {
    return e.replace(/\$|}|\\/g, "\\$&");
  }
  static guessNeedsClipboard(e) {
    return /\${?CLIPBOARD/.test(e);
  }
  parse(e, t, i) {
    const n = new X_();
    return this.parseFragment(e, n), this.ensureFinalTabstop(n, i ?? !1, t ?? !1), n;
  }
  parseFragment(e, t) {
    const i = t.children.length;
    for (this._scanner.text(e), this._token = this._scanner.next(); this._parse(t); )
      ;
    const n = /* @__PURE__ */ new Map(), o = [];
    t.walk((l) => (l instanceof ho && (l.isFinalTabstop ? n.set(0, void 0) : !n.has(l.index) && l.children.length > 0 ? n.set(l.index, l.children) : o.push(l)), !0));
    const r = (l, c) => {
      const d = n.get(l.index);
      if (!d)
        return;
      const h = new ho(l.index);
      h.transform = l.transform;
      for (const u of d) {
        const g = u.clone();
        h.appendChild(g), g instanceof ho && n.has(g.index) && !c.has(g.index) && (c.add(g.index), r(g, c), c.delete(g.index));
      }
      t.replace(l, [h]);
    }, a = /* @__PURE__ */ new Set();
    for (const l of o)
      r(l, a);
    return t.children.slice(i);
  }
  ensureFinalTabstop(e, t, i) {
    (t || i && e.placeholders.length > 0) && (e.placeholders.find((o) => o.index === 0) || e.appendChild(new ho(0)));
  }
  _accept(e, t) {
    if (e === void 0 || this._token.type === e) {
      const i = t ? this._scanner.tokenText(this._token) : !0;
      return this._token = this._scanner.next(), i;
    }
    return !1;
  }
  _backTo(e) {
    return this._scanner.pos = e.pos + e.len, this._token = e, !1;
  }
  _until(e) {
    const t = this._token;
    for (; this._token.type !== e; ) {
      if (this._token.type === 14)
        return !1;
      if (this._token.type === 5) {
        const n = this._scanner.next();
        if (n.type !== 0 && n.type !== 4 && n.type !== 5)
          return !1;
      }
      this._token = this._scanner.next();
    }
    const i = this._scanner.value.substring(t.pos, this._token.pos).replace(/\\(\$|}|\\)/g, "$1");
    return this._token = this._scanner.next(), i;
  }
  _parse(e) {
    return this._parseEscaped(e) || this._parseTabstopOrVariableName(e) || this._parseComplexPlaceholder(e) || this._parseComplexVariable(e) || this._parseAnything(e);
  }
  // \$, \\, \} -> just text
  _parseEscaped(e) {
    let t;
    return (t = this._accept(5, !0)) ? (t = this._accept(0, !0) || this._accept(4, !0) || this._accept(5, !0) || t, e.appendChild(new qn(t)), !0) : !1;
  }
  // $foo -> variable, $1 -> tabstop
  _parseTabstopOrVariableName(e) {
    let t;
    const i = this._token;
    return this._accept(
      0
      /* TokenType.Dollar */
    ) && (t = this._accept(9, !0) || this._accept(8, !0)) ? (e.appendChild(/^\d+$/.test(t) ? new ho(Number(t)) : new S_(t)), !0) : this._backTo(i);
  }
  // ${1:<children>}, ${1} -> placeholder
  _parseComplexPlaceholder(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(8, !0))))
      return this._backTo(i);
    const o = new ho(Number(t));
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(o), !0;
        if (!this._parse(o))
          return e.appendChild(new qn("${" + t + ":")), o.children.forEach(e.appendChild, e), !0;
      }
    else if (o.index > 0 && this._accept(
      7
      /* TokenType.Pipe */
    )) {
      const r = new Mm();
      for (; ; ) {
        if (this._parseChoiceElement(r)) {
          if (this._accept(
            2
            /* TokenType.Comma */
          ))
            continue;
          if (this._accept(
            7
            /* TokenType.Pipe */
          ) && (o.appendChild(r), this._accept(
            4
            /* TokenType.CurlyClose */
          )))
            return e.appendChild(o), !0;
        }
        return this._backTo(i), !1;
      }
    } else return this._accept(
      6
      /* TokenType.Forwardslash */
    ) ? this._parseTransform(o) ? (e.appendChild(o), !0) : (this._backTo(i), !1) : this._accept(
      4
      /* TokenType.CurlyClose */
    ) ? (e.appendChild(o), !0) : this._backTo(i);
  }
  _parseChoiceElement(e) {
    const t = this._token, i = [];
    for (; !(this._token.type === 2 || this._token.type === 7); ) {
      let n;
      if ((n = this._accept(5, !0)) ? n = this._accept(2, !0) || this._accept(7, !0) || this._accept(5, !0) || n : n = this._accept(void 0, !0), !n)
        return this._backTo(t), !1;
      i.push(n);
    }
    return i.length === 0 ? (this._backTo(t), !1) : (e.appendChild(new qn(i.join(""))), !0);
  }
  // ${foo:<children>}, ${foo} -> variable
  _parseComplexVariable(e) {
    let t;
    const i = this._token;
    if (!(this._accept(
      0
      /* TokenType.Dollar */
    ) && this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (t = this._accept(9, !0))))
      return this._backTo(i);
    const o = new S_(t);
    if (this._accept(
      1
      /* TokenType.Colon */
    ))
      for (; ; ) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(o), !0;
        if (!this._parse(o))
          return e.appendChild(new qn("${" + t + ":")), o.children.forEach(e.appendChild, e), !0;
      }
    else return this._accept(
      6
      /* TokenType.Forwardslash */
    ) ? this._parseTransform(o) ? (e.appendChild(o), !0) : (this._backTo(i), !1) : this._accept(
      4
      /* TokenType.CurlyClose */
    ) ? (e.appendChild(o), !0) : this._backTo(i);
  }
  _parseTransform(e) {
    const t = new fB();
    let i = "", n = "";
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let o;
      if (o = this._accept(5, !0)) {
        o = this._accept(6, !0) || o, i += o;
        continue;
      }
      if (this._token.type !== 14) {
        i += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    for (; !this._accept(
      6
      /* TokenType.Forwardslash */
    ); ) {
      let o;
      if (o = this._accept(5, !0)) {
        o = this._accept(5, !0) || this._accept(6, !0) || o, t.appendChild(new qn(o));
        continue;
      }
      if (!(this._parseFormatString(t) || this._parseAnything(t)))
        return !1;
    }
    for (; !this._accept(
      4
      /* TokenType.CurlyClose */
    ); ) {
      if (this._token.type !== 14) {
        n += this._accept(void 0, !0);
        continue;
      }
      return !1;
    }
    try {
      t.regexp = new RegExp(i, n);
    } catch {
      return !1;
    }
    return e.transform = t, !0;
  }
  _parseFormatString(e) {
    const t = this._token;
    if (!this._accept(
      0
      /* TokenType.Dollar */
    ))
      return !1;
    let i = !1;
    this._accept(
      3
      /* TokenType.CurlyOpen */
    ) && (i = !0);
    const n = this._accept(8, !0);
    if (n)
      if (i) {
        if (this._accept(
          4
          /* TokenType.CurlyClose */
        ))
          return e.appendChild(new vr(Number(n))), !0;
        if (!this._accept(
          1
          /* TokenType.Colon */
        ))
          return this._backTo(t), !1;
      } else return e.appendChild(new vr(Number(n))), !0;
    else return this._backTo(t), !1;
    if (this._accept(
      6
      /* TokenType.Forwardslash */
    )) {
      const o = this._accept(9, !0);
      return !o || !this._accept(
        4
        /* TokenType.CurlyClose */
      ) ? (this._backTo(t), !1) : (e.appendChild(new vr(Number(n), o)), !0);
    } else if (this._accept(
      11
      /* TokenType.Plus */
    )) {
      const o = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (o)
        return e.appendChild(new vr(Number(n), void 0, o, void 0)), !0;
    } else if (this._accept(
      12
      /* TokenType.Dash */
    )) {
      const o = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (o)
        return e.appendChild(new vr(Number(n), void 0, void 0, o)), !0;
    } else if (this._accept(
      13
      /* TokenType.QuestionMark */
    )) {
      const o = this._until(
        1
        /* TokenType.Colon */
      );
      if (o) {
        const r = this._until(
          4
          /* TokenType.CurlyClose */
        );
        if (r)
          return e.appendChild(new vr(Number(n), void 0, o, r)), !0;
      }
    } else {
      const o = this._until(
        4
        /* TokenType.CurlyClose */
      );
      if (o)
        return e.appendChild(new vr(Number(n), void 0, void 0, o)), !0;
    }
    return this._backTo(t), !1;
  }
  _parseAnything(e) {
    return this._token.type !== 14 ? (e.appendChild(new qn(this._scanner.tokenText(this._token))), this._accept(void 0), !0) : !1;
  }
}
const jue = f("defaultLabel", "input"), Yue = f("label.preserveCaseToggle", "Preserve Case");
class Kue extends xm {
  constructor(e) {
    super({
      // TODO: does this need its own icon?
      icon: Z.preserveCase,
      title: Yue + e.appendTitle,
      isChecked: e.isChecked,
      hoverDelegate: e.hoverDelegate ?? Ls("element"),
      inputActiveOptionBorder: e.inputActiveOptionBorder,
      inputActiveOptionForeground: e.inputActiveOptionForeground,
      inputActiveOptionBackground: e.inputActiveOptionBackground
    });
  }
}
class Jue extends to {
  constructor(e, t, i, n) {
    super(), this._showOptionButtons = i, this.fixFocusOnOptionClickEnabled = !0, this.cachedOptionsWidth = 0, this._onDidOptionChange = this._register(new B()), this.onDidOptionChange = this._onDidOptionChange.event, this._onKeyDown = this._register(new B()), this.onKeyDown = this._onKeyDown.event, this._onMouseDown = this._register(new B()), this._onInput = this._register(new B()), this._onKeyUp = this._register(new B()), this._onPreserveCaseKeyDown = this._register(new B()), this.onPreserveCaseKeyDown = this._onPreserveCaseKeyDown.event, this.contextViewProvider = t, this.placeholder = n.placeholder || "", this.validation = n.validation, this.label = n.label || jue;
    const o = n.appendPreserveCaseLabel || "", r = n.history || [], a = !!n.flexibleHeight, l = !!n.flexibleWidth, c = n.flexibleMaxHeight;
    this.domNode = document.createElement("div"), this.domNode.classList.add("monaco-findInput"), this.inputBox = this._register(new BW(this.domNode, this.contextViewProvider, {
      ariaLabel: this.label || "",
      placeholder: this.placeholder || "",
      validationOptions: {
        validation: this.validation
      },
      history: r,
      showHistoryHint: n.showHistoryHint,
      flexibleHeight: a,
      flexibleWidth: l,
      flexibleMaxHeight: c,
      inputBoxStyles: n.inputBoxStyles
    })), this.preserveCase = this._register(new Kue({
      appendTitle: o,
      isChecked: !1,
      ...n.toggleStyles
    })), this._register(this.preserveCase.onChange((u) => {
      this._onDidOptionChange.fire(u), !u && this.fixFocusOnOptionClickEnabled && this.inputBox.focus(), this.validate();
    })), this._register(this.preserveCase.onKeyDown((u) => {
      this._onPreserveCaseKeyDown.fire(u);
    })), this._showOptionButtons ? this.cachedOptionsWidth = this.preserveCase.width() : this.cachedOptionsWidth = 0;
    const d = [this.preserveCase.domNode];
    this.onkeydown(this.domNode, (u) => {
      if (u.equals(
        15
        /* KeyCode.LeftArrow */
      ) || u.equals(
        17
        /* KeyCode.RightArrow */
      ) || u.equals(
        9
        /* KeyCode.Escape */
      )) {
        const g = d.indexOf(this.domNode.ownerDocument.activeElement);
        if (g >= 0) {
          let m = -1;
          u.equals(
            17
            /* KeyCode.RightArrow */
          ) ? m = (g + 1) % d.length : u.equals(
            15
            /* KeyCode.LeftArrow */
          ) && (g === 0 ? m = d.length - 1 : m = g - 1), u.equals(
            9
            /* KeyCode.Escape */
          ) ? (d[g].blur(), this.inputBox.focus()) : m >= 0 && d[m].focus(), Ve.stop(u, !0);
        }
      }
    });
    const h = document.createElement("div");
    h.className = "controls", h.style.display = this._showOptionButtons ? "block" : "none", h.appendChild(this.preserveCase.domNode), this.domNode.appendChild(h), e?.appendChild(this.domNode), this.onkeydown(this.inputBox.inputElement, (u) => this._onKeyDown.fire(u)), this.onkeyup(this.inputBox.inputElement, (u) => this._onKeyUp.fire(u)), this.oninput(this.inputBox.inputElement, (u) => this._onInput.fire()), this.onmousedown(this.inputBox.inputElement, (u) => this._onMouseDown.fire(u));
  }
  enable() {
    this.domNode.classList.remove("disabled"), this.inputBox.enable(), this.preserveCase.enable();
  }
  disable() {
    this.domNode.classList.add("disabled"), this.inputBox.disable(), this.preserveCase.disable();
  }
  setEnabled(e) {
    e ? this.enable() : this.disable();
  }
  select() {
    this.inputBox.select();
  }
  focus() {
    this.inputBox.focus();
  }
  getPreserveCase() {
    return this.preserveCase.checked;
  }
  setPreserveCase(e) {
    this.preserveCase.checked = e;
  }
  focusOnPreserve() {
    this.preserveCase.focus();
  }
  validate() {
    this.inputBox?.validate();
  }
  set width(e) {
    this.inputBox.paddingRight = this.cachedOptionsWidth, this.domNode.style.width = e + "px";
  }
  dispose() {
    super.dispose();
  }
}
var JV = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, qV = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
const mB = new le("suggestWidgetVisible", !1, f("suggestWidgetVisible", "Whether suggestion are visible")), pB = "historyNavigationWidgetFocus", $V = "historyNavigationForwardsEnabled", XV = "historyNavigationBackwardsEnabled";
let oA;
const Zb = [];
function ZV(s, e) {
  if (Zb.includes(e))
    throw new Error("Cannot register the same widget multiple times");
  Zb.push(e);
  const t = new X(), i = new le(pB, !1).bindTo(s), n = new le($V, !0).bindTo(s), o = new le(XV, !0).bindTo(s), r = () => {
    i.set(!0), oA = e;
  }, a = () => {
    i.set(!1), oA === e && (oA = void 0);
  };
  return x0(e.element) && r(), t.add(e.onDidFocus(() => r())), t.add(e.onDidBlur(() => a())), t.add(we(() => {
    Zb.splice(Zb.indexOf(e), 1), a();
  })), {
    historyNavigationForwardsEnablement: n,
    historyNavigationBackwardsEnablement: o,
    dispose() {
      t.dispose();
    }
  };
}
let GI = class extends RW {
  constructor(e, t, i, n) {
    super(e, t, i);
    const o = this._register(n.createScoped(this.inputBox.element));
    this._register(ZV(o, this.inputBox));
  }
};
GI = JV([
  qV(3, Se)
], GI);
let jI = class extends Jue {
  constructor(e, t, i, n, o = !1) {
    super(e, t, o, i);
    const r = this._register(n.createScoped(this.inputBox.element));
    this._register(ZV(r, this.inputBox));
  }
};
jI = JV([
  qV(3, Se)
], jI);
Hn.registerCommandAndKeybindingRule({
  id: "history.showPrevious",
  weight: 200,
  when: ne.and(ne.has(pB), ne.equals(XV, !0), ne.not("isComposing"), mB.isEqualTo(!1)),
  primary: 16,
  secondary: [
    528
    /* KeyCode.UpArrow */
  ],
  handler: (s) => {
    oA?.showPreviousValue();
  }
});
Hn.registerCommandAndKeybindingRule({
  id: "history.showNext",
  weight: 200,
  when: ne.and(ne.has(pB), ne.equals($V, !0), ne.not("isComposing"), mB.isEqualTo(!1)),
  primary: 18,
  secondary: [
    530
    /* KeyCode.DownArrow */
  ],
  handler: (s) => {
    oA?.showNextValue();
  }
});
const Te = {
  Visible: mB,
  HasFocusedSuggestion: new le("suggestWidgetHasFocusedSuggestion", !1, f("suggestWidgetHasSelection", "Whether any suggestion is focused")),
  DetailsVisible: new le("suggestWidgetDetailsVisible", !1, f("suggestWidgetDetailsVisible", "Whether suggestion details are visible")),
  MultipleSuggestions: new le("suggestWidgetMultipleSuggestions", !1, f("suggestWidgetMultipleSuggestions", "Whether there are multiple suggestions to pick from")),
  MakesTextEdit: new le("suggestionMakesTextEdit", !0, f("suggestionMakesTextEdit", "Whether inserting the current suggestion yields in a change or has everything already been typed")),
  AcceptSuggestionsOnEnter: new le("acceptSuggestionOnEnter", !0, f("acceptSuggestionOnEnter", "Whether suggestions are inserted when pressing Enter")),
  HasInsertAndReplaceRange: new le("suggestionHasInsertAndReplaceRange", !1, f("suggestionHasInsertAndReplaceRange", "Whether the current suggestion has insert and replace behaviour")),
  InsertMode: new le("suggestionInsertMode", void 0, { type: "string", description: f("suggestionInsertMode", "Whether the default behaviour is to insert or replace") }),
  CanResolve: new le("suggestionCanResolve", !1, f("suggestionCanResolve", "Whether the current suggestion supports to resolve further details"))
}, Uc = new Qe("suggestWidgetStatusBar");
class que {
  constructor(e, t, i, n) {
    this.position = e, this.completion = t, this.container = i, this.provider = n, this.isInvalid = !1, this.score = Tr.Default, this.distance = 0, this.textLabel = typeof t.label == "string" ? t.label : t.label?.label, this.labelLow = this.textLabel.toLowerCase(), this.isInvalid = !this.textLabel, this.sortTextLow = t.sortText && t.sortText.toLowerCase(), this.filterTextLow = t.filterText && t.filterText.toLowerCase(), this.extensionId = t.extensionId, E.isIRange(t.range) ? (this.editStart = new F(t.range.startLineNumber, t.range.startColumn), this.editInsertEnd = new F(t.range.endLineNumber, t.range.endColumn), this.editReplaceEnd = new F(t.range.endLineNumber, t.range.endColumn), this.isInvalid = this.isInvalid || E.spansMultipleLines(t.range) || t.range.startLineNumber !== e.lineNumber) : (this.editStart = new F(t.range.insert.startLineNumber, t.range.insert.startColumn), this.editInsertEnd = new F(t.range.insert.endLineNumber, t.range.insert.endColumn), this.editReplaceEnd = new F(t.range.replace.endLineNumber, t.range.replace.endColumn), this.isInvalid = this.isInvalid || E.spansMultipleLines(t.range.insert) || E.spansMultipleLines(t.range.replace) || t.range.insert.startLineNumber !== e.lineNumber || t.range.replace.startLineNumber !== e.lineNumber || t.range.insert.startColumn !== t.range.replace.startColumn), typeof n.resolveCompletionItem != "function" && (this._resolveCache = Promise.resolve(), this._resolveDuration = 0);
  }
  // ---- resolving
  get isResolved() {
    return this._resolveDuration !== void 0;
  }
  get resolveDuration() {
    return this._resolveDuration !== void 0 ? this._resolveDuration : -1;
  }
  async resolve(e) {
    if (!this._resolveCache) {
      const t = e.onCancellationRequested(() => {
        this._resolveCache = void 0, this._resolveDuration = void 0;
      }), i = new es(!0);
      this._resolveCache = Promise.resolve(this.provider.resolveCompletionItem(this.completion, e)).then((n) => {
        Object.assign(this.completion, n), this._resolveDuration = i.elapsed();
      }, (n) => {
        Ad(n) && (this._resolveCache = void 0, this._resolveDuration = void 0);
      }).finally(() => {
        t.dispose();
      });
    }
    return this._resolveCache;
  }
}
const l0 = class l0 {
  constructor(e = 2, t = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new Map(), o = !0) {
    this.snippetSortOrder = e, this.kindFilter = t, this.providerFilter = i, this.providerItemsToReuse = n, this.showDeprecated = o;
  }
};
l0.default = new l0();
let y_ = l0;
class $ue {
  constructor(e, t, i, n) {
    this.items = e, this.needsClipboard = t, this.durations = i, this.disposable = n;
  }
}
async function AB(s, e, t, i = y_.default, n = {
  triggerKind: 0
  /* languages.CompletionTriggerKind.Invoke */
}, o = ct.None) {
  const r = new es();
  t = t.clone();
  const a = e.getWordAtPosition(t), l = a ? new E(t.lineNumber, a.startColumn, t.lineNumber, a.endColumn) : E.fromPositions(t), c = { replace: l, insert: l.setEndPosition(t.lineNumber, t.column) }, d = [], h = new X(), u = [];
  let g = !1;
  const m = (A, _, b) => {
    let C = !1;
    if (!_)
      return C;
    for (const w of _.suggestions)
      if (!i.kindFilter.has(w.kind)) {
        if (!i.showDeprecated && w?.tags?.includes(
          1
          /* languages.CompletionItemTag.Deprecated */
        ))
          continue;
        w.range || (w.range = c), w.sortText || (w.sortText = typeof w.label == "string" ? w.label : w.label.label), !g && w.insertTextRules && w.insertTextRules & 4 && (g = i1.guessNeedsClipboard(w.insertText)), d.push(new que(t, w, _, A)), C = !0;
      }
    return DM(_) && h.add(_), u.push({
      providerName: A._debugDisplayName ?? "unknown_provider",
      elapsedProvider: _.duration ?? -1,
      elapsedOverall: b.elapsed()
    }), C;
  }, p = (async () => {
  })();
  for (const A of s.orderedGroups(e)) {
    let _ = !1;
    if (await Promise.all(A.map(async (b) => {
      if (i.providerItemsToReuse.has(b)) {
        const C = i.providerItemsToReuse.get(b);
        C.forEach((w) => d.push(w)), _ = _ || C.length > 0;
        return;
      }
      if (!(i.providerFilter.size > 0 && !i.providerFilter.has(b)))
        try {
          const C = new es(), w = await b.provideCompletionItems(e, t, n, o);
          _ = m(b, w, C) || _;
        } catch (C) {
          xs(C);
        }
    })), _ || o.isCancellationRequested)
      break;
  }
  return await p, o.isCancellationRequested ? (h.dispose(), Promise.reject(new _d())) : new $ue(d.sort(ege(i.snippetSortOrder)), g, { entries: u, elapsed: r.elapsed() }, h);
}
function _B(s, e) {
  if (s.sortTextLow && e.sortTextLow) {
    if (s.sortTextLow < e.sortTextLow)
      return -1;
    if (s.sortTextLow > e.sortTextLow)
      return 1;
  }
  return s.textLabel < e.textLabel ? -1 : s.textLabel > e.textLabel ? 1 : s.completion.kind - e.completion.kind;
}
function Xue(s, e) {
  if (s.completion.kind !== e.completion.kind) {
    if (s.completion.kind === 27)
      return -1;
    if (e.completion.kind === 27)
      return 1;
  }
  return _B(s, e);
}
function Zue(s, e) {
  if (s.completion.kind !== e.completion.kind) {
    if (s.completion.kind === 27)
      return 1;
    if (e.completion.kind === 27)
      return -1;
  }
  return _B(s, e);
}
const BS = /* @__PURE__ */ new Map();
BS.set(0, Xue);
BS.set(2, Zue);
BS.set(1, _B);
function ege(s) {
  return BS.get(s);
}
mt.registerCommand("_executeCompletionItemProvider", async (s, ...e) => {
  const [t, i, n, o] = e;
  jt(_e.isUri(t)), jt(F.isIPosition(i)), jt(typeof n == "string" || !n), jt(typeof o == "number" || !o);
  const { completionProvider: r } = s.get(ye), a = await s.get(Zs).createModelReference(t);
  try {
    const l = {
      incomplete: !1,
      suggestions: []
    }, c = [], d = a.object.textEditorModel.validatePosition(i), h = await AB(r, a.object.textEditorModel, d, void 0, {
      triggerCharacter: n ?? void 0,
      triggerKind: n ? 1 : 0
      /* languages.CompletionTriggerKind.Invoke */
    });
    for (const u of h.items)
      c.length < (o ?? 0) && c.push(u.resolve(ct.None)), l.incomplete = l.incomplete || u.container.incomplete, l.suggestions.push(u.completion);
    try {
      return await Promise.all(c), l;
    } finally {
      setTimeout(() => h.disposable.dispose(), 100);
    }
  } finally {
    a.dispose();
  }
});
function tge(s, e) {
  s.getContribution("editor.contrib.suggestController")?.triggerSuggest((/* @__PURE__ */ new Set()).add(e), void 0, !0);
}
class Jg {
  static isAllOff(e) {
    return e.other === "off" && e.comments === "off" && e.strings === "off";
  }
  static isAllOn(e) {
    return e.other === "on" && e.comments === "on" && e.strings === "on";
  }
  static valueFor(e, t) {
    switch (t) {
      case 1:
        return e.comments;
      case 2:
        return e.strings;
      default:
        return e.other;
    }
  }
}
function a4(s, e = yn) {
  return fj(s, e) ? s.charAt(0).toUpperCase() + s.slice(1) : s;
}
var ige = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, nge = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class l4 {
  constructor(e) {
    this._delegates = e;
  }
  resolve(e) {
    for (const t of this._delegates) {
      const i = t.resolve(e);
      if (i !== void 0)
        return i;
    }
  }
}
class c4 {
  constructor(e, t, i, n) {
    this._model = e, this._selection = t, this._selectionIdx = i, this._overtypingCapturer = n;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "SELECTION" || t === "TM_SELECTED_TEXT") {
      let i = this._model.getValueInRange(this._selection) || void 0, n = this._selection.startLineNumber !== this._selection.endLineNumber;
      if (!i && this._overtypingCapturer) {
        const o = this._overtypingCapturer.getLastOvertypedInfo(this._selectionIdx);
        o && (i = o.value, n = o.multiline);
      }
      if (i && n && e.snippet) {
        const o = this._model.getLineContent(this._selection.startLineNumber), r = Ii(o, 0, this._selection.startColumn - 1);
        let a = r;
        e.snippet.walk((c) => c === e ? !1 : (c instanceof qn && (a = Ii(bd(c.value).pop())), !0));
        const l = kA(a, r);
        i = i.replace(/(\r\n|\r|\n)(.*)/g, (c, d, h) => `${d}${a.substr(l)}${h}`);
      }
      return i;
    } else {
      if (t === "TM_CURRENT_LINE")
        return this._model.getLineContent(this._selection.positionLineNumber);
      if (t === "TM_CURRENT_WORD") {
        const i = this._model.getWordAtPosition({
          lineNumber: this._selection.positionLineNumber,
          column: this._selection.positionColumn
        });
        return i && i.word || void 0;
      } else {
        if (t === "TM_LINE_INDEX")
          return String(this._selection.positionLineNumber - 1);
        if (t === "TM_LINE_NUMBER")
          return String(this._selection.positionLineNumber);
        if (t === "CURSOR_INDEX")
          return String(this._selectionIdx);
        if (t === "CURSOR_NUMBER")
          return String(this._selectionIdx + 1);
      }
    }
  }
}
class d4 {
  constructor(e, t) {
    this._labelService = e, this._model = t;
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "TM_FILENAME")
      return Pc(this._model.uri.fsPath);
    if (t === "TM_FILENAME_BASE") {
      const i = Pc(this._model.uri.fsPath), n = i.lastIndexOf(".");
      return n <= 0 ? i : i.slice(0, n);
    } else {
      if (t === "TM_DIRECTORY")
        return cH(this._model.uri.fsPath) === "." ? "" : this._labelService.getUriLabel($0(this._model.uri));
      if (t === "TM_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri);
      if (t === "RELATIVE_FILEPATH")
        return this._labelService.getUriLabel(this._model.uri, { relative: !0, noPrefix: !0 });
    }
  }
}
class h4 {
  constructor(e, t, i, n) {
    this._readClipboardText = e, this._selectionIdx = t, this._selectionCount = i, this._spread = n;
  }
  resolve(e) {
    if (e.name !== "CLIPBOARD")
      return;
    const t = this._readClipboardText();
    if (t) {
      if (this._spread) {
        const i = t.split(/\r\n|\n|\r/).filter((n) => !AH(n));
        if (i.length === this._selectionCount)
          return i[this._selectionIdx];
      }
      return t;
    }
  }
}
let n1 = class {
  constructor(e, t, i) {
    this._model = e, this._selection = t, this._languageConfigurationService = i;
  }
  resolve(e) {
    const { name: t } = e, i = this._model.getLanguageIdAtPosition(this._selection.selectionStartLineNumber, this._selection.selectionStartColumn), n = this._languageConfigurationService.getLanguageConfiguration(i).comments;
    if (n) {
      if (t === "LINE_COMMENT")
        return n.lineCommentToken || void 0;
      if (t === "BLOCK_COMMENT_START")
        return n.blockCommentStartToken || void 0;
      if (t === "BLOCK_COMMENT_END")
        return n.blockCommentEndToken || void 0;
    }
  }
};
n1 = ige([
  nge(2, tn)
], n1);
const oa = class oa {
  constructor() {
    this._date = /* @__PURE__ */ new Date();
  }
  resolve(e) {
    const { name: t } = e;
    if (t === "CURRENT_YEAR")
      return String(this._date.getFullYear());
    if (t === "CURRENT_YEAR_SHORT")
      return String(this._date.getFullYear()).slice(-2);
    if (t === "CURRENT_MONTH")
      return String(this._date.getMonth().valueOf() + 1).padStart(2, "0");
    if (t === "CURRENT_DATE")
      return String(this._date.getDate().valueOf()).padStart(2, "0");
    if (t === "CURRENT_HOUR")
      return String(this._date.getHours().valueOf()).padStart(2, "0");
    if (t === "CURRENT_MINUTE")
      return String(this._date.getMinutes().valueOf()).padStart(2, "0");
    if (t === "CURRENT_SECOND")
      return String(this._date.getSeconds().valueOf()).padStart(2, "0");
    if (t === "CURRENT_DAY_NAME")
      return oa.dayNames[this._date.getDay()];
    if (t === "CURRENT_DAY_NAME_SHORT")
      return oa.dayNamesShort[this._date.getDay()];
    if (t === "CURRENT_MONTH_NAME")
      return oa.monthNames[this._date.getMonth()];
    if (t === "CURRENT_MONTH_NAME_SHORT")
      return oa.monthNamesShort[this._date.getMonth()];
    if (t === "CURRENT_SECONDS_UNIX")
      return String(Math.floor(this._date.getTime() / 1e3));
    if (t === "CURRENT_TIMEZONE_OFFSET") {
      const i = this._date.getTimezoneOffset(), n = i > 0 ? "-" : "+", o = Math.trunc(Math.abs(i / 60)), r = o < 10 ? "0" + o : o, a = Math.abs(i) - o * 60, l = a < 10 ? "0" + a : a;
      return n + r + ":" + l;
    }
  }
};
oa.dayNames = [f("Sunday", "Sunday"), f("Monday", "Monday"), f("Tuesday", "Tuesday"), f("Wednesday", "Wednesday"), f("Thursday", "Thursday"), f("Friday", "Friday"), f("Saturday", "Saturday")], oa.dayNamesShort = [f("SundayShort", "Sun"), f("MondayShort", "Mon"), f("TuesdayShort", "Tue"), f("WednesdayShort", "Wed"), f("ThursdayShort", "Thu"), f("FridayShort", "Fri"), f("SaturdayShort", "Sat")], oa.monthNames = [f("January", "January"), f("February", "February"), f("March", "March"), f("April", "April"), f("May", "May"), f("June", "June"), f("July", "July"), f("August", "August"), f("September", "September"), f("October", "October"), f("November", "November"), f("December", "December")], oa.monthNamesShort = [f("JanuaryShort", "Jan"), f("FebruaryShort", "Feb"), f("MarchShort", "Mar"), f("AprilShort", "Apr"), f("MayShort", "May"), f("JuneShort", "Jun"), f("JulyShort", "Jul"), f("AugustShort", "Aug"), f("SeptemberShort", "Sep"), f("OctoberShort", "Oct"), f("NovemberShort", "Nov"), f("DecemberShort", "Dec")];
let s1 = oa;
class u4 {
  constructor(e) {
    this._workspaceService = e;
  }
  resolve(e) {
    if (!this._workspaceService)
      return;
    const t = Rq(this._workspaceService.getWorkspace());
    if (!Tq(t)) {
      if (e.name === "WORKSPACE_NAME")
        return this._resolveWorkspaceName(t);
      if (e.name === "WORKSPACE_FOLDER")
        return this._resoveWorkspacePath(t);
    }
  }
  _resolveWorkspaceName(e) {
    if (UL(e))
      return Pc(e.uri.path);
    let t = Pc(e.configPath.path);
    return t.endsWith(QL) && (t = t.substr(0, t.length - QL.length - 1)), t;
  }
  _resoveWorkspacePath(e) {
    if (UL(e))
      return a4(e.uri.fsPath);
    const t = Pc(e.configPath.path);
    let i = e.configPath.fsPath;
    return i.endsWith(t) && (i = i.substr(0, i.length - t.length - 1)), i ? a4(i) : "/";
  }
}
class g4 {
  resolve(e) {
    const { name: t } = e;
    if (t === "RANDOM")
      return Math.random().toString().slice(-6);
    if (t === "RANDOM_HEX")
      return Math.random().toString(16).slice(-6);
    if (t === "UUID")
      return RV();
  }
}
var sge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, oge = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, pr;
const Oo = class Oo {
  constructor(e, t, i) {
    this._editor = e, this._snippet = t, this._snippetLineLeadingWhitespace = i, this._offset = -1, this._nestingLevel = 1, this._placeholderGroups = RB(t.placeholders, ho.compareByIndex), this._placeholderGroupsIdx = -1;
  }
  initialize(e) {
    this._offset = e.newPosition;
  }
  dispose() {
    this._placeholderDecorations && this._editor.removeDecorations([...this._placeholderDecorations.values()]), this._placeholderGroups.length = 0;
  }
  _initDecorations() {
    if (this._offset === -1)
      throw new Error("Snippet not initialized!");
    if (this._placeholderDecorations)
      return;
    this._placeholderDecorations = /* @__PURE__ */ new Map();
    const e = this._editor.getModel();
    this._editor.changeDecorations((t) => {
      for (const i of this._snippet.placeholders) {
        const n = this._snippet.offset(i), o = this._snippet.fullLen(i), r = E.fromPositions(e.getPositionAt(this._offset + n), e.getPositionAt(this._offset + n + o)), a = i.isFinalTabstop ? Oo._decor.inactiveFinal : Oo._decor.inactive, l = t.addDecoration(r, a);
        this._placeholderDecorations.set(i, l);
      }
    });
  }
  move(e) {
    if (!this._editor.hasModel())
      return [];
    if (this._initDecorations(), this._placeholderGroupsIdx >= 0) {
      const n = [];
      for (const o of this._placeholderGroups[this._placeholderGroupsIdx])
        if (o.transform) {
          const r = this._placeholderDecorations.get(o), a = this._editor.getModel().getDecorationRange(r), l = this._editor.getModel().getValueInRange(a), c = o.transform.resolve(l).split(/\r\n|\r|\n/);
          for (let d = 1; d < c.length; d++)
            c[d] = this._editor.getModel().normalizeIndentation(this._snippetLineLeadingWhitespace + c[d]);
          n.push(ms.replace(a, c.join(this._editor.getModel().getEOL())));
        }
      n.length > 0 && this._editor.executeEdits("snippet.placeholderTransform", n);
    }
    let t = !1;
    e === !0 && this._placeholderGroupsIdx < this._placeholderGroups.length - 1 ? (this._placeholderGroupsIdx += 1, t = !0) : e === !1 && this._placeholderGroupsIdx > 0 && (this._placeholderGroupsIdx -= 1, t = !0);
    const i = this._editor.getModel().changeDecorations((n) => {
      const o = /* @__PURE__ */ new Set(), r = [];
      for (const a of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const l = this._placeholderDecorations.get(a), c = this._editor.getModel().getDecorationRange(l);
        r.push(new Ue(c.startLineNumber, c.startColumn, c.endLineNumber, c.endColumn)), t = t && this._hasPlaceholderBeenCollapsed(a), n.changeDecorationOptions(l, a.isFinalTabstop ? Oo._decor.activeFinal : Oo._decor.active), o.add(a);
        for (const d of this._snippet.enclosingPlaceholders(a)) {
          const h = this._placeholderDecorations.get(d);
          n.changeDecorationOptions(h, d.isFinalTabstop ? Oo._decor.activeFinal : Oo._decor.active), o.add(d);
        }
      }
      for (const [a, l] of this._placeholderDecorations)
        o.has(a) || n.changeDecorationOptions(l, a.isFinalTabstop ? Oo._decor.inactiveFinal : Oo._decor.inactive);
      return r;
    });
    return t ? this.move(e) : i ?? [];
  }
  _hasPlaceholderBeenCollapsed(e) {
    let t = e;
    for (; t; ) {
      if (t instanceof ho) {
        const i = this._placeholderDecorations.get(t);
        if (this._editor.getModel().getDecorationRange(i).isEmpty() && t.toString().length > 0)
          return !0;
      }
      t = t.parent;
    }
    return !1;
  }
  get isAtFirstPlaceholder() {
    return this._placeholderGroupsIdx <= 0 || this._placeholderGroups.length === 0;
  }
  get isAtLastPlaceholder() {
    return this._placeholderGroupsIdx === this._placeholderGroups.length - 1;
  }
  get hasPlaceholder() {
    return this._snippet.placeholders.length > 0;
  }
  /**
   * A snippet is trivial when it has no placeholder or only a final placeholder at
   * its very end
   */
  get isTrivialSnippet() {
    if (this._snippet.placeholders.length === 0)
      return !0;
    if (this._snippet.placeholders.length === 1) {
      const [e] = this._snippet.placeholders;
      if (e.isFinalTabstop && this._snippet.rightMostDescendant === e)
        return !0;
    }
    return !1;
  }
  computePossibleSelections() {
    const e = /* @__PURE__ */ new Map();
    for (const t of this._placeholderGroups) {
      let i;
      for (const n of t) {
        if (n.isFinalTabstop)
          break;
        i || (i = [], e.set(n.index, i));
        const o = this._placeholderDecorations.get(n), r = this._editor.getModel().getDecorationRange(o);
        if (!r) {
          e.delete(n.index);
          break;
        }
        i.push(r);
      }
    }
    return e;
  }
  get activeChoice() {
    if (!this._placeholderDecorations)
      return;
    const e = this._placeholderGroups[this._placeholderGroupsIdx][0];
    if (!e?.choice)
      return;
    const t = this._placeholderDecorations.get(e);
    if (!t)
      return;
    const i = this._editor.getModel().getDecorationRange(t);
    if (i)
      return { range: i, choice: e.choice };
  }
  get hasChoice() {
    let e = !1;
    return this._snippet.walk((t) => (e = t instanceof Mm, !e)), e;
  }
  merge(e) {
    const t = this._editor.getModel();
    this._nestingLevel *= 10, this._editor.changeDecorations((i) => {
      for (const n of this._placeholderGroups[this._placeholderGroupsIdx]) {
        const o = e.shift();
        console.assert(o._offset !== -1), console.assert(!o._placeholderDecorations);
        const r = o._snippet.placeholderInfo.last.index;
        for (const l of o._snippet.placeholderInfo.all)
          l.isFinalTabstop ? l.index = n.index + (r + 1) / this._nestingLevel : l.index = n.index + l.index / this._nestingLevel;
        this._snippet.replace(n, o._snippet.children);
        const a = this._placeholderDecorations.get(n);
        i.removeDecoration(a), this._placeholderDecorations.delete(n);
        for (const l of o._snippet.placeholders) {
          const c = o._snippet.offset(l), d = o._snippet.fullLen(l), h = E.fromPositions(t.getPositionAt(o._offset + c), t.getPositionAt(o._offset + c + d)), u = i.addDecoration(h, Oo._decor.inactive);
          this._placeholderDecorations.set(l, u);
        }
      }
      this._placeholderGroups = RB(this._snippet.placeholders, ho.compareByIndex);
    });
  }
};
Oo._decor = {
  active: He.register({ description: "snippet-placeholder-1", stickiness: 0, className: "snippet-placeholder" }),
  inactive: He.register({ description: "snippet-placeholder-2", stickiness: 1, className: "snippet-placeholder" }),
  activeFinal: He.register({ description: "snippet-placeholder-3", stickiness: 1, className: "finish-snippet-placeholder" }),
  inactiveFinal: He.register({ description: "snippet-placeholder-4", stickiness: 1, className: "finish-snippet-placeholder" })
};
let o1 = Oo;
const f4 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
let YI = pr = class {
  static adjustWhitespace(e, t, i, n, o) {
    const r = e.getLineContent(t.lineNumber), a = Ii(r, 0, t.column - 1);
    let l;
    return n.walk((c) => {
      if (!(c instanceof qn) || c.parent instanceof Mm || o && !o.has(c))
        return !0;
      const d = c.value.split(/\r\n|\r|\n/);
      if (i) {
        const u = n.offset(c);
        if (u === 0)
          d[0] = e.normalizeIndentation(d[0]);
        else {
          l = l ?? n.toString();
          const g = l.charCodeAt(u - 1);
          (g === 10 || g === 13) && (d[0] = e.normalizeIndentation(a + d[0]));
        }
        for (let g = 1; g < d.length; g++)
          d[g] = e.normalizeIndentation(a + d[g]);
      }
      const h = d.join(e.getEOL());
      return h !== c.value && (c.parent.replace(c, [new qn(h)]), l = void 0), !0;
    }), a;
  }
  static adjustSelection(e, t, i, n) {
    if (i !== 0 || n !== 0) {
      const { positionLineNumber: o, positionColumn: r } = t, a = r - i, l = r + n, c = e.validateRange({
        startLineNumber: o,
        startColumn: a,
        endLineNumber: o,
        endColumn: l
      });
      t = Ue.createWithDirection(c.startLineNumber, c.startColumn, c.endLineNumber, c.endColumn, t.getDirection());
    }
    return t;
  }
  static createEditsAndSnippetsFromSelections(e, t, i, n, o, r, a, l, c) {
    const d = [], h = [];
    if (!e.hasModel())
      return { edits: d, snippets: h };
    const u = e.getModel(), g = e.invokeWithinContext((w) => w.get(BC)), m = e.invokeWithinContext((w) => new d4(w.get(Zf), u)), p = () => a, A = u.getValueInRange(pr.adjustSelection(u, e.getSelection(), i, 0)), _ = u.getValueInRange(pr.adjustSelection(u, e.getSelection(), 0, n)), b = u.getLineFirstNonWhitespaceColumn(e.getSelection().positionLineNumber), C = e.getSelections().map((w, S) => ({ selection: w, idx: S })).sort((w, S) => E.compareRangesUsingStarts(w.selection, S.selection));
    for (const { selection: w, idx: S } of C) {
      let x = pr.adjustSelection(u, w, i, 0), y = pr.adjustSelection(u, w, 0, n);
      A !== u.getValueInRange(x) && (x = w), _ !== u.getValueInRange(y) && (y = w);
      const D = w.setStartPosition(x.startLineNumber, x.startColumn).setEndPosition(y.endLineNumber, y.endColumn), I = new i1().parse(t, !0, o), Q = D.getStartPosition(), P = pr.adjustWhitespace(u, Q, r || S > 0 && b !== u.getLineFirstNonWhitespaceColumn(w.positionLineNumber), I);
      I.resolveVariables(new l4([
        m,
        new h4(p, S, C.length, e.getOption(
          79
          /* EditorOption.multiCursorPaste */
        ) === "spread"),
        new c4(u, w, S, l),
        new n1(u, w, c),
        new s1(),
        new u4(g),
        new g4()
      ])), d[S] = ms.replace(D, I.toString()), d[S].identifier = { major: S, minor: 0 }, d[S]._isTracked = !0, h[S] = new o1(e, I, P);
    }
    return { edits: d, snippets: h };
  }
  static createEditsAndSnippetsFromEdits(e, t, i, n, o, r, a) {
    if (!e.hasModel() || t.length === 0)
      return { edits: [], snippets: [] };
    const l = [], c = e.getModel(), d = new i1(), h = new X_(), u = new l4([
      e.invokeWithinContext((m) => new d4(m.get(Zf), c)),
      new h4(() => o, 0, e.getSelections().length, e.getOption(
        79
        /* EditorOption.multiCursorPaste */
      ) === "spread"),
      new c4(c, e.getSelection(), 0, r),
      new n1(c, e.getSelection(), a),
      new s1(),
      new u4(e.invokeWithinContext((m) => m.get(BC))),
      new g4()
    ]);
    t = t.sort((m, p) => E.compareRangesUsingStarts(m.range, p.range));
    let g = 0;
    for (let m = 0; m < t.length; m++) {
      const { range: p, template: A } = t[m];
      if (m > 0) {
        const S = t[m - 1].range, x = E.fromPositions(S.getEndPosition(), p.getStartPosition()), y = new qn(c.getValueInRange(x));
        h.appendChild(y), g += y.value.length;
      }
      const _ = d.parseFragment(A, h);
      pr.adjustWhitespace(c, p.getStartPosition(), !0, h, new Set(_)), h.resolveVariables(u);
      const b = h.toString(), C = b.slice(g);
      g = b.length;
      const w = ms.replace(p, C);
      w.identifier = { major: m, minor: 0 }, w._isTracked = !0, l.push(w);
    }
    return d.ensureFinalTabstop(h, i, !0), {
      edits: l,
      snippets: [new o1(e, h, "")]
    };
  }
  constructor(e, t, i = f4, n) {
    this._editor = e, this._template = t, this._options = i, this._languageConfigurationService = n, this._templateMerges = [], this._snippets = [];
  }
  dispose() {
    Ct(this._snippets);
  }
  _logInfo() {
    return `template="${this._template}", merged_templates="${this._templateMerges.join(" -> ")}"`;
  }
  insert() {
    if (!this._editor.hasModel())
      return;
    const { edits: e, snippets: t } = typeof this._template == "string" ? pr.createEditsAndSnippetsFromSelections(this._editor, this._template, this._options.overwriteBefore, this._options.overwriteAfter, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService) : pr.createEditsAndSnippetsFromEdits(this._editor, this._template, !1, this._options.adjustWhitespace, this._options.clipboardText, this._options.overtypingCapturer, this._languageConfigurationService);
    this._snippets = t, this._editor.executeEdits("snippet", e, (i) => {
      const n = i.filter((o) => !!o.identifier);
      for (let o = 0; o < t.length; o++)
        t[o].initialize(n[o].textChange);
      return this._snippets[0].hasPlaceholder ? this._move(!0) : n.map((o) => Ue.fromPositions(o.range.getEndPosition()));
    }), this._editor.revealRange(this._editor.getSelections()[0]);
  }
  merge(e, t = f4) {
    if (!this._editor.hasModel())
      return;
    this._templateMerges.push([this._snippets[0]._nestingLevel, this._snippets[0]._placeholderGroupsIdx, e]);
    const { edits: i, snippets: n } = pr.createEditsAndSnippetsFromSelections(this._editor, e, t.overwriteBefore, t.overwriteAfter, !0, t.adjustWhitespace, t.clipboardText, t.overtypingCapturer, this._languageConfigurationService);
    this._editor.executeEdits("snippet", i, (o) => {
      const r = o.filter((l) => !!l.identifier);
      for (let l = 0; l < n.length; l++)
        n[l].initialize(r[l].textChange);
      const a = n[0].isTrivialSnippet;
      if (!a) {
        for (const l of this._snippets)
          l.merge(n);
        console.assert(n.length === 0);
      }
      return this._snippets[0].hasPlaceholder && !a ? this._move(void 0) : r.map((l) => Ue.fromPositions(l.range.getEndPosition()));
    });
  }
  next() {
    const e = this._move(!0);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  prev() {
    const e = this._move(!1);
    this._editor.setSelections(e), this._editor.revealPositionInCenterIfOutsideViewport(e[0].getPosition());
  }
  _move(e) {
    const t = [];
    for (const i of this._snippets) {
      const n = i.move(e);
      t.push(...n);
    }
    return t;
  }
  get isAtFirstPlaceholder() {
    return this._snippets[0].isAtFirstPlaceholder;
  }
  get isAtLastPlaceholder() {
    return this._snippets[0].isAtLastPlaceholder;
  }
  get hasPlaceholder() {
    return this._snippets[0].hasPlaceholder;
  }
  get hasChoice() {
    return this._snippets[0].hasChoice;
  }
  get activeChoice() {
    return this._snippets[0].activeChoice;
  }
  isSelectionWithinPlaceholders() {
    if (!this.hasPlaceholder)
      return !1;
    const e = this._editor.getSelections();
    if (e.length < this._snippets.length)
      return !1;
    const t = /* @__PURE__ */ new Map();
    for (const i of this._snippets) {
      const n = i.computePossibleSelections();
      if (t.size === 0)
        for (const [o, r] of n) {
          r.sort(E.compareRangesUsingStarts);
          for (const a of e)
            if (r[0].containsRange(a)) {
              t.set(o, []);
              break;
            }
        }
      if (t.size === 0)
        return !1;
      t.forEach((o, r) => {
        o.push(...n.get(r));
      });
    }
    e.sort(E.compareRangesUsingStarts);
    for (const [i, n] of t) {
      if (n.length !== e.length) {
        t.delete(i);
        continue;
      }
      n.sort(E.compareRangesUsingStarts);
      for (let o = 0; o < n.length; o++)
        if (!n[o].containsRange(e[o])) {
          t.delete(i);
          continue;
        }
    }
    return t.size > 0;
  }
};
YI = pr = sge([
  oge(3, tn)
], YI);
var rge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ew = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Eg;
const m4 = {
  overwriteBefore: 0,
  overwriteAfter: 0,
  undoStopBefore: !0,
  undoStopAfter: !0,
  adjustWhitespace: !0,
  clipboardText: void 0,
  overtypingCapturer: void 0
};
var pa;
let ss = (pa = class {
  static get(e) {
    return e.getContribution(Eg.ID);
  }
  constructor(e, t, i, n, o) {
    this._editor = e, this._logService = t, this._languageFeaturesService = i, this._languageConfigurationService = o, this._snippetListener = new X(), this._modelVersionId = -1, this._inSnippet = Eg.InSnippetMode.bindTo(n), this._hasNextTabstop = Eg.HasNextTabstop.bindTo(n), this._hasPrevTabstop = Eg.HasPrevTabstop.bindTo(n);
  }
  dispose() {
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), this._session?.dispose(), this._snippetListener.dispose();
  }
  insert(e, t) {
    try {
      this._doInsert(e, typeof t > "u" ? m4 : { ...m4, ...t });
    } catch (i) {
      this.cancel(), this._logService.error(i), this._logService.error("snippet_error"), this._logService.error("insert_template=", e), this._logService.error("existing_template=", this._session ? this._session._logInfo() : "<no_session>");
    }
  }
  _doInsert(e, t) {
    if (this._editor.hasModel()) {
      if (this._snippetListener.clear(), t.undoStopBefore && this._editor.getModel().pushStackElement(), this._session && typeof e != "string" && this.cancel(), this._session ? (jt(typeof e == "string"), this._session.merge(e, t)) : (this._modelVersionId = this._editor.getModel().getAlternativeVersionId(), this._session = new YI(this._editor, e, t, this._languageConfigurationService), this._session.insert()), t.undoStopAfter && this._editor.getModel().pushStackElement(), this._session?.hasChoice) {
        const i = {
          _debugDisplayName: "snippetChoiceCompletions",
          provideCompletionItems: (c, d) => {
            if (!this._session || c !== this._editor.getModel() || !F.equals(this._editor.getPosition(), d))
              return;
            const { activeChoice: h } = this._session;
            if (!h || h.choice.options.length === 0)
              return;
            const u = c.getValueInRange(h.range), g = !!h.choice.options.find((p) => p.value === u), m = [];
            for (let p = 0; p < h.choice.options.length; p++) {
              const A = h.choice.options[p];
              m.push({
                kind: 13,
                label: A.value,
                insertText: A.value,
                sortText: "a".repeat(p + 1),
                range: h.range,
                filterText: g ? `${u}_${A.value}` : void 0,
                command: { id: "jumpToNextSnippetPlaceholder", title: f("next", "Go to next placeholder...") }
              });
            }
            return { suggestions: m };
          }
        }, n = this._editor.getModel();
        let o, r = !1;
        const a = () => {
          o?.dispose(), r = !1;
        }, l = () => {
          r || (o = this._languageFeaturesService.completionProvider.register({
            language: n.getLanguageId(),
            pattern: n.uri.fsPath,
            scheme: n.uri.scheme,
            exclusive: !0
          }, i), this._snippetListener.add(o), r = !0);
        };
        this._choiceCompletions = { provider: i, enable: l, disable: a };
      }
      this._updateState(), this._snippetListener.add(this._editor.onDidChangeModelContent((i) => i.isFlush && this.cancel())), this._snippetListener.add(this._editor.onDidChangeModel(() => this.cancel())), this._snippetListener.add(this._editor.onDidChangeCursorSelection(() => this._updateState()));
    }
  }
  _updateState() {
    if (!(!this._session || !this._editor.hasModel())) {
      if (this._modelVersionId === this._editor.getModel().getAlternativeVersionId())
        return this.cancel();
      if (!this._session.hasPlaceholder)
        return this.cancel();
      if (this._session.isAtLastPlaceholder || !this._session.isSelectionWithinPlaceholders())
        return this._editor.getModel().pushStackElement(), this.cancel();
      this._inSnippet.set(!0), this._hasPrevTabstop.set(!this._session.isAtFirstPlaceholder), this._hasNextTabstop.set(!this._session.isAtLastPlaceholder), this._handleChoice();
    }
  }
  _handleChoice() {
    if (!this._session || !this._editor.hasModel()) {
      this._currentChoice = void 0;
      return;
    }
    const { activeChoice: e } = this._session;
    if (!e || !this._choiceCompletions) {
      this._choiceCompletions?.disable(), this._currentChoice = void 0;
      return;
    }
    this._currentChoice !== e.choice && (this._currentChoice = e.choice, this._choiceCompletions.enable(), queueMicrotask(() => {
      tge(this._editor, this._choiceCompletions.provider);
    }));
  }
  finish() {
    for (; this._inSnippet.get(); )
      this.next();
  }
  cancel(e = !1) {
    this._inSnippet.reset(), this._hasPrevTabstop.reset(), this._hasNextTabstop.reset(), this._snippetListener.clear(), this._currentChoice = void 0, this._session?.dispose(), this._session = void 0, this._modelVersionId = -1, e && this._editor.setSelections([this._editor.getSelection()]);
  }
  prev() {
    this._session?.prev(), this._updateState();
  }
  next() {
    this._session?.next(), this._updateState();
  }
  isInSnippet() {
    return !!this._inSnippet.get();
  }
}, Eg = pa, pa.ID = "snippetController2", pa.InSnippetMode = new le("inSnippetMode", !1, f("inSnippetMode", "Whether the editor in current in snippet mode")), pa.HasNextTabstop = new le("hasNextTabstop", !1, f("hasNextTabstop", "Whether there is a next tab stop when in snippet mode")), pa.HasPrevTabstop = new le("hasPrevTabstop", !1, f("hasPrevTabstop", "Whether there is a previous tab stop when in snippet mode")), pa);
ss = Eg = rge([
  ew(1, Es),
  ew(2, ye),
  ew(3, Se),
  ew(4, tn)
], ss);
rs(
  ss.ID,
  ss,
  4
  /* EditorContributionInstantiation.Lazy */
);
const RS = Wn.bindToContribution(ss.get);
re(new RS({
  id: "jumpToNextSnippetPlaceholder",
  precondition: ne.and(ss.InSnippetMode, ss.HasNextTabstop),
  handler: (s) => s.next(),
  kbOpts: {
    weight: 130,
    kbExpr: R.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
re(new RS({
  id: "jumpToPrevSnippetPlaceholder",
  precondition: ne.and(ss.InSnippetMode, ss.HasPrevTabstop),
  handler: (s) => s.prev(),
  kbOpts: {
    weight: 130,
    kbExpr: R.textInputFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
re(new RS({
  id: "leaveSnippet",
  precondition: ss.InSnippetMode,
  handler: (s) => s.cancel(!0),
  kbOpts: {
    weight: 130,
    kbExpr: R.textInputFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
re(new RS({
  id: "acceptSnippet",
  precondition: ss.InSnippetMode,
  handler: (s) => s.finish()
  // kbOpts: {
  // 	weight: KeybindingWeight.EditorContrib + 30,
  // 	kbExpr: EditorContextKeys.textFocus,
  // 	primary: KeyCode.Enter,
  // }
}));
var age = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, p4 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, xp;
class bB {
  constructor(e) {
    this.name = e;
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = i[0].score[0];
    for (let o = 0; o < i.length; o++) {
      const { score: r, completion: a } = i[o];
      if (r[0] !== n)
        break;
      if (a.preselect)
        return o;
    }
    return 0;
  }
}
class A4 extends bB {
  constructor() {
    super("first");
  }
  memorize(e, t, i) {
  }
  toJSON() {
  }
  fromJSON() {
  }
}
class lge extends bB {
  constructor() {
    super("recentlyUsed"), this._cache = new Vu(300, 0.66), this._seq = 0;
  }
  memorize(e, t, i) {
    const n = `${e.getLanguageId()}/${i.textLabel}`;
    this._cache.set(n, {
      touch: this._seq++,
      type: i.completion.kind,
      insertText: i.completion.insertText
    });
  }
  select(e, t, i) {
    if (i.length === 0)
      return 0;
    const n = e.getLineContent(t.lineNumber).substr(t.column - 10, t.column - 1);
    if (/\s$/.test(n))
      return super.select(e, t, i);
    const o = i[0].score[0];
    let r = -1, a = -1, l = -1;
    for (let c = 0; c < i.length && i[c].score[0] === o; c++) {
      const d = `${e.getLanguageId()}/${i[c].textLabel}`, h = this._cache.peek(d);
      if (h && h.touch > l && h.type === i[c].completion.kind && h.insertText === i[c].completion.insertText && (l = h.touch, a = c), i[c].completion.preselect && r === -1)
        return r = c;
    }
    return a !== -1 ? a : r !== -1 ? r : 0;
  }
  toJSON() {
    return this._cache.toJSON();
  }
  fromJSON(e) {
    this._cache.clear();
    const t = 0;
    for (const [i, n] of e)
      n.touch = t, n.type = typeof n.type == "number" ? n.type : EA.fromString(n.type), this._cache.set(i, n);
    this._seq = this._cache.size;
  }
}
class cge extends bB {
  constructor() {
    super("recentlyUsedByPrefix"), this._trie = wf.forStrings(), this._seq = 0;
  }
  memorize(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t), o = `${e.getLanguageId()}/${n}`;
    this._trie.set(o, {
      type: i.completion.kind,
      insertText: i.completion.insertText,
      touch: this._seq++
    });
  }
  select(e, t, i) {
    const { word: n } = e.getWordUntilPosition(t);
    if (!n)
      return super.select(e, t, i);
    const o = `${e.getLanguageId()}/${n}`;
    let r = this._trie.get(o);
    if (r || (r = this._trie.findSubstr(o)), r)
      for (let a = 0; a < i.length; a++) {
        const { kind: l, insertText: c } = i[a].completion;
        if (l === r.type && c === r.insertText)
          return a;
      }
    return super.select(e, t, i);
  }
  toJSON() {
    const e = [];
    return this._trie.forEach((t, i) => e.push([i, t])), e.sort((t, i) => -(t[1].touch - i[1].touch)).forEach((t, i) => t[1].touch = i), e.slice(0, 200);
  }
  fromJSON(e) {
    if (this._trie.clear(), e.length > 0) {
      this._seq = e[0][1].touch + 1;
      for (const [t, i] of e)
        i.type = typeof i.type == "number" ? i.type : EA.fromString(i.type), this._trie.set(t, i);
    }
  }
}
var ed;
let KI = (ed = class {
  constructor(e, t) {
    this._storageService = e, this._configService = t, this._disposables = new X(), this._persistSoon = new zt(() => this._saveState(), 500), this._disposables.add(e.onWillSaveState((i) => {
      i.reason === tk.SHUTDOWN && this._saveState();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._persistSoon.dispose();
  }
  memorize(e, t, i) {
    this._withStrategy(e, t).memorize(e, t, i), this._persistSoon.schedule();
  }
  select(e, t, i) {
    return this._withStrategy(e, t).select(e, t, i);
  }
  _withStrategy(e, t) {
    const i = this._configService.getValue("editor.suggestSelection", {
      overrideIdentifier: e.getLanguageIdAtPosition(t.lineNumber, t.column),
      resource: e.uri
    });
    if (this._strategy?.name !== i) {
      this._saveState();
      const n = xp._strategyCtors.get(i) || A4;
      this._strategy = new n();
      try {
        const r = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, a = this._storageService.get(`${xp._storagePrefix}/${i}`, r);
        a && this._strategy.fromJSON(JSON.parse(a));
      } catch {
      }
    }
    return this._strategy;
  }
  _saveState() {
    if (this._strategy) {
      const t = this._configService.getValue("editor.suggest.shareSuggestSelections") ? 0 : 1, i = JSON.stringify(this._strategy);
      this._storageService.store(
        `${xp._storagePrefix}/${this._strategy.name}`,
        i,
        t,
        1
        /* StorageTarget.MACHINE */
      );
    }
  }
}, xp = ed, ed._strategyCtors = /* @__PURE__ */ new Map([
  ["recentlyUsedByPrefix", cge],
  ["recentlyUsed", lge],
  ["first", A4]
]), ed._storagePrefix = "suggest/memories", ed);
KI = xp = age([
  p4(0, Jl),
  p4(1, ht)
], KI);
const FS = We("ISuggestMemories");
$e(
  FS,
  KI,
  1
  /* InstantiationType.Delayed */
);
var dge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, hge = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, JI, iu;
let r1 = (iu = class {
  constructor(e, t) {
    this._editor = e, this._enabled = !1, this._ckAtEnd = JI.AtEnd.bindTo(t), this._configListener = this._editor.onDidChangeConfiguration((i) => i.hasChanged(
      124
      /* EditorOption.tabCompletion */
    ) && this._update()), this._update();
  }
  dispose() {
    this._configListener.dispose(), this._selectionListener?.dispose(), this._ckAtEnd.reset();
  }
  _update() {
    const e = this._editor.getOption(
      124
      /* EditorOption.tabCompletion */
    ) === "on";
    if (this._enabled !== e)
      if (this._enabled = e, this._enabled) {
        const t = () => {
          if (!this._editor.hasModel()) {
            this._ckAtEnd.set(!1);
            return;
          }
          const i = this._editor.getModel(), n = this._editor.getSelection(), o = i.getWordAtPosition(n.getStartPosition());
          if (!o) {
            this._ckAtEnd.set(!1);
            return;
          }
          this._ckAtEnd.set(o.endColumn === n.getStartPosition().column);
        };
        this._selectionListener = this._editor.onDidChangeCursorSelection(t), t();
      } else this._selectionListener && (this._ckAtEnd.reset(), this._selectionListener.dispose(), this._selectionListener = void 0);
  }
}, JI = iu, iu.AtEnd = new le("atEndOfWord", !1), iu);
r1 = JI = dge([
  hge(1, Se)
], r1);
var uge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, gge = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Ep, nu;
let hm = (nu = class {
  constructor(e, t) {
    this._editor = e, this._index = 0, this._ckOtherSuggestions = Ep.OtherSuggestions.bindTo(t);
  }
  dispose() {
    this.reset();
  }
  reset() {
    this._ckOtherSuggestions.reset(), this._listener?.dispose(), this._model = void 0, this._acceptNext = void 0, this._ignore = !1;
  }
  set({ model: e, index: t }, i) {
    if (e.items.length === 0) {
      this.reset();
      return;
    }
    if (Ep._moveIndex(!0, e, t) === t) {
      this.reset();
      return;
    }
    this._acceptNext = i, this._model = e, this._index = t, this._listener = this._editor.onDidChangeCursorPosition(() => {
      this._ignore || this.reset();
    }), this._ckOtherSuggestions.set(!0);
  }
  static _moveIndex(e, t, i) {
    let n = i;
    for (let o = t.items.length; o > 0 && (n = (n + t.items.length + (e ? 1 : -1)) % t.items.length, !(n === i || !t.items[n].completion.additionalTextEdits)); o--)
      ;
    return n;
  }
  next() {
    this._move(!0);
  }
  prev() {
    this._move(!1);
  }
  _move(e) {
    if (this._model)
      try {
        this._ignore = !0, this._index = Ep._moveIndex(e, this._model, this._index), this._acceptNext({ index: this._index, item: this._model.items[this._index], model: this._model });
      } finally {
        this._ignore = !1;
      }
  }
}, Ep = nu, nu.OtherSuggestions = new le("hasOtherSuggestions", !1), nu);
hm = Ep = uge([
  gge(1, Se)
], hm);
class fge {
  constructor(e, t, i, n) {
    this._disposables = new X(), this._disposables.add(i.onDidSuggest((o) => {
      o.completionModel.items.length === 0 && this.reset();
    })), this._disposables.add(i.onDidCancel((o) => {
      this.reset();
    })), this._disposables.add(t.onDidShow(() => this._onItem(t.getFocusedItem()))), this._disposables.add(t.onDidFocus(this._onItem, this)), this._disposables.add(t.onDidHide(this.reset, this)), this._disposables.add(e.onWillType((o) => {
      if (this._active && !t.isFrozen() && i.state !== 0) {
        const r = o.charCodeAt(o.length - 1);
        this._active.acceptCharacters.has(r) && e.getOption(
          0
          /* EditorOption.acceptSuggestionOnCommitCharacter */
        ) && n(this._active.item);
      }
    }));
  }
  _onItem(e) {
    if (!e || !Ys(e.item.completion.commitCharacters)) {
      this.reset();
      return;
    }
    if (this._active && this._active.item.item === e.item)
      return;
    const t = new tL();
    for (const i of e.item.completion.commitCharacters)
      i.length > 0 && t.add(i.charCodeAt(0));
    this._active = { acceptCharacters: t, item: e };
  }
  reset() {
    this._active = void 0;
  }
  dispose() {
    this._disposables.dispose();
  }
}
const ao = class ao {
  async provideSelectionRanges(e, t) {
    const i = [];
    for (const n of t) {
      const o = [];
      i.push(o);
      const r = /* @__PURE__ */ new Map();
      await new Promise((a) => ao._bracketsRightYield(a, 0, e, n, r)), await new Promise((a) => ao._bracketsLeftYield(a, 0, e, n, r, o));
    }
    return i;
  }
  static _bracketsRightYield(e, t, i, n, o) {
    const r = /* @__PURE__ */ new Map(), a = Date.now();
    for (; ; ) {
      if (t >= ao._maxRounds) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const l = i.bracketPairs.findNextBracket(n);
      if (!l) {
        e();
        break;
      }
      if (Date.now() - a > ao._maxDuration) {
        setTimeout(() => ao._bracketsRightYield(e, t + 1, i, n, o));
        break;
      }
      if (l.bracketInfo.isOpeningBracket) {
        const d = l.bracketInfo.bracketText, h = r.has(d) ? r.get(d) : 0;
        r.set(d, h + 1);
      } else {
        const d = l.bracketInfo.getOpeningBrackets()[0].bracketText;
        let h = r.has(d) ? r.get(d) : 0;
        if (h -= 1, r.set(d, Math.max(0, h)), h < 0) {
          let u = o.get(d);
          u || (u = new Nn(), o.set(d, u)), u.push(l.range);
        }
      }
      n = l.range.getEndPosition();
    }
  }
  static _bracketsLeftYield(e, t, i, n, o, r) {
    const a = /* @__PURE__ */ new Map(), l = Date.now();
    for (; ; ) {
      if (t >= ao._maxRounds && o.size === 0) {
        e();
        break;
      }
      if (!n) {
        e();
        break;
      }
      const c = i.bracketPairs.findPrevBracket(n);
      if (!c) {
        e();
        break;
      }
      if (Date.now() - l > ao._maxDuration) {
        setTimeout(() => ao._bracketsLeftYield(e, t + 1, i, n, o, r));
        break;
      }
      if (c.bracketInfo.isOpeningBracket) {
        const h = c.bracketInfo.bracketText;
        let u = a.has(h) ? a.get(h) : 0;
        if (u -= 1, a.set(h, Math.max(0, u)), u < 0) {
          const g = o.get(h);
          if (g) {
            const m = g.shift();
            g.size === 0 && o.delete(h);
            const p = E.fromPositions(c.range.getEndPosition(), m.getStartPosition()), A = E.fromPositions(c.range.getStartPosition(), m.getEndPosition());
            r.push({ range: p }), r.push({ range: A }), ao._addBracketLeading(i, A, r);
          }
        }
      } else {
        const h = c.bracketInfo.getOpeningBrackets()[0].bracketText, u = a.has(h) ? a.get(h) : 0;
        a.set(h, u + 1);
      }
      n = c.range.getStartPosition();
    }
  }
  static _addBracketLeading(e, t, i) {
    if (t.startLineNumber === t.endLineNumber)
      return;
    const n = t.startLineNumber, o = e.getLineFirstNonWhitespaceColumn(n);
    o !== 0 && o !== t.startColumn && (i.push({ range: E.fromPositions(new F(n, o), t.getEndPosition()) }), i.push({ range: E.fromPositions(new F(n, 1), t.getEndPosition()) }));
    const r = n - 1;
    if (r > 0) {
      const a = e.getLineFirstNonWhitespaceColumn(r);
      a === t.startColumn && a !== e.getLineLastNonWhitespaceColumn(r) && (i.push({ range: E.fromPositions(new F(r, a), t.getEndPosition()) }), i.push({ range: E.fromPositions(new F(r, 1), t.getEndPosition()) }));
    }
  }
};
ao._maxDuration = 30, ao._maxRounds = 2;
let qI = ao;
const ra = class ra {
  static async create(e, t) {
    if (!t.getOption(
      119
      /* EditorOption.suggest */
    ).localityBonus || !t.hasModel())
      return ra.None;
    const i = t.getModel(), n = t.getPosition();
    if (!e.canComputeWordRanges(i.uri))
      return ra.None;
    const [o] = await new qI().provideSelectionRanges(i, [n]);
    if (o.length === 0)
      return ra.None;
    const r = await e.computeWordRanges(i.uri, o[0].range);
    if (!r)
      return ra.None;
    const a = i.getWordUntilPosition(n);
    return delete r[a.word], new class extends ra {
      distance(l, c) {
        if (!n.equals(t.getPosition()))
          return 0;
        if (c.kind === 17)
          return 2 << 20;
        const d = typeof c.label == "string" ? c.label : c.label.label, h = r[d];
        if (P4(h))
          return 2 << 20;
        const u = wM(h, E.fromPositions(l), E.compareRangesUsingStarts), g = u >= 0 ? h[u] : h[Math.max(0, ~u - 1)];
        let m = o.length;
        for (const p of o) {
          if (!E.containsRange(p.range, g))
            break;
          m -= 1;
        }
        return m;
      }
    }();
  }
};
ra.None = new class extends ra {
  distance() {
    return 0;
  }
}();
let a1 = ra, _4 = class {
  constructor(e, t) {
    this.leadingLineContent = e, this.characterCountDelta = t;
  }
};
class yc {
  constructor(e, t, i, n, o, r, a = GA.default, l = void 0) {
    this.clipboardText = l, this._snippetCompareFn = yc._compareCompletionItems, this._items = e, this._column = t, this._wordDistance = n, this._options = o, this._refilterKind = 1, this._lineContext = i, this._fuzzyScoreOptions = a, r === "top" ? this._snippetCompareFn = yc._compareCompletionItemsSnippetsUp : r === "bottom" && (this._snippetCompareFn = yc._compareCompletionItemsSnippetsDown);
  }
  get lineContext() {
    return this._lineContext;
  }
  set lineContext(e) {
    (this._lineContext.leadingLineContent !== e.leadingLineContent || this._lineContext.characterCountDelta !== e.characterCountDelta) && (this._refilterKind = this._lineContext.characterCountDelta < e.characterCountDelta && this._filteredItems ? 2 : 1, this._lineContext = e);
  }
  get items() {
    return this._ensureCachedState(), this._filteredItems;
  }
  getItemsByProvider() {
    return this._ensureCachedState(), this._itemsByProvider;
  }
  getIncompleteProvider() {
    this._ensureCachedState();
    const e = /* @__PURE__ */ new Set();
    for (const [t, i] of this.getItemsByProvider())
      i.length > 0 && i[0].container.incomplete && e.add(t);
    return e;
  }
  get stats() {
    return this._ensureCachedState(), this._stats;
  }
  _ensureCachedState() {
    this._refilterKind !== 0 && this._createCachedState();
  }
  _createCachedState() {
    this._itemsByProvider = /* @__PURE__ */ new Map();
    const e = [], { leadingLineContent: t, characterCountDelta: i } = this._lineContext;
    let n = "", o = "";
    const r = this._refilterKind === 1 ? this._items : this._filteredItems, a = [], l = !this._options.filterGraceful || r.length > 2e3 ? $f : sJ;
    for (let c = 0; c < r.length; c++) {
      const d = r[c];
      if (d.isInvalid)
        continue;
      const h = this._itemsByProvider.get(d.provider);
      h ? h.push(d) : this._itemsByProvider.set(d.provider, [d]);
      const u = d.position.column - d.editStart.column, g = u + i - (d.position.column - this._column);
      if (n.length !== g && (n = g === 0 ? "" : t.slice(-g), o = n.toLowerCase()), d.word = n, g === 0)
        d.score = Tr.Default;
      else {
        let m = 0;
        for (; m < u; ) {
          const p = n.charCodeAt(m);
          if (p === 32 || p === 9)
            m += 1;
          else
            break;
        }
        if (m >= g)
          d.score = Tr.Default;
        else if (typeof d.completion.filterText == "string") {
          const p = l(n, o, m, d.completion.filterText, d.filterTextLow, 0, this._fuzzyScoreOptions);
          if (!p)
            continue;
          ME(d.completion.filterText, d.textLabel) === 0 ? d.score = p : (d.score = eJ(n, o, m, d.textLabel, d.labelLow, 0), d.score[0] = p[0]);
        } else {
          const p = l(n, o, m, d.textLabel, d.labelLow, 0, this._fuzzyScoreOptions);
          if (!p)
            continue;
          d.score = p;
        }
      }
      d.idx = c, d.distance = this._wordDistance.distance(d.position, d.completion), a.push(d), e.push(d.textLabel.length);
    }
    this._filteredItems = a.sort(this._snippetCompareFn), this._refilterKind = 0, this._stats = {
      pLabelLen: e.length ? vx(e.length - 0.85, e, (c, d) => c - d) : 0
    };
  }
  static _compareCompletionItems(e, t) {
    return e.score[0] > t.score[0] ? -1 : e.score[0] < t.score[0] ? 1 : e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : e.idx < t.idx ? -1 : e.idx > t.idx ? 1 : 0;
  }
  static _compareCompletionItemsSnippetsDown(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return 1;
      if (t.completion.kind === 27)
        return -1;
    }
    return yc._compareCompletionItems(e, t);
  }
  static _compareCompletionItemsSnippetsUp(e, t) {
    if (e.completion.kind !== t.completion.kind) {
      if (e.completion.kind === 27)
        return -1;
      if (t.completion.kind === 27)
        return 1;
    }
    return yc._compareCompletionItems(e, t);
  }
}
const aa = class aa extends V {
  constructor(e, t) {
    super(), this.contextKeyService = e, this.model = t, this.inlineCompletionVisible = aa.inlineSuggestionVisible.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentation = aa.inlineSuggestionHasIndentation.bindTo(this.contextKeyService), this.inlineCompletionSuggestsIndentationLessThanTabSize = aa.inlineSuggestionHasIndentationLessThanTabSize.bindTo(this.contextKeyService), this.suppressSuggestions = aa.suppressSuggestions.bindTo(this.contextKeyService), this._register(et((i) => {
      const o = this.model.read(i)?.state.read(i), r = !!o?.inlineCompletion && o?.primaryGhostText !== void 0 && !o?.primaryGhostText.isEmpty();
      this.inlineCompletionVisible.set(r), o?.primaryGhostText && o?.inlineCompletion && this.suppressSuggestions.set(o.inlineCompletion.inlineCompletion.source.inlineCompletions.suppressSuggestions);
    })), this._register(et((i) => {
      const n = this.model.read(i);
      let o = !1, r = !0;
      const a = n?.primaryGhostText.read(i);
      if (n?.selectedSuggestItem && a && a.parts.length > 0) {
        const { column: l, lines: c } = a.parts[0], d = c[0], h = n.textModel.getLineIndentColumn(a.lineNumber);
        if (l <= h) {
          let g = Sn(d);
          g === -1 && (g = d.length - 1), o = g > 0;
          const m = n.textModel.getOptions().tabSize;
          r = wi.visibleColumnFromColumn(d, g + 1, m) < m;
        }
      }
      this.inlineCompletionSuggestsIndentation.set(o), this.inlineCompletionSuggestsIndentationLessThanTabSize.set(r);
    }));
  }
};
aa.inlineSuggestionVisible = new le("inlineSuggestionVisible", !1, f("inlineSuggestionVisible", "Whether an inline suggestion is visible")), aa.inlineSuggestionHasIndentation = new le("inlineSuggestionHasIndentation", !1, f("inlineSuggestionHasIndentation", "Whether the inline suggestion starts with whitespace")), aa.inlineSuggestionHasIndentationLessThanTabSize = new le("inlineSuggestionHasIndentationLessThanTabSize", !0, f("inlineSuggestionHasIndentationLessThanTabSize", "Whether the inline suggestion starts with whitespace that is less than what would be inserted by tab")), aa.suppressSuggestions = new le("inlineSuggestionSuppressSuggestions", void 0, f("suppressSuggestions", "Whether suggestions should be suppressed for the current suggestion"));
let x_ = aa;
var mge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, ac = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, $I;
class Hd {
  static shouldAutoTrigger(e) {
    if (!e.hasModel())
      return !1;
    const t = e.getModel(), i = e.getPosition();
    t.tokenization.tokenizeIfCheap(i.lineNumber);
    const n = t.getWordAtPosition(i);
    return !(!n || n.endColumn !== i.column && n.startColumn + 1 !== i.column || !isNaN(Number(n.word)));
  }
  constructor(e, t, i) {
    this.leadingLineContent = e.getLineContent(t.lineNumber).substr(0, t.column - 1), this.leadingWord = e.getWordUntilPosition(t), this.lineNumber = t.lineNumber, this.column = t.column, this.triggerOptions = i;
  }
}
function pge(s, e, t) {
  if (!e.getContextKeyValue(x_.inlineSuggestionVisible.key))
    return !0;
  const i = e.getContextKeyValue(x_.suppressSuggestions.key);
  return i !== void 0 ? !i : !s.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
function Age(s, e, t) {
  if (!e.getContextKeyValue("inlineSuggestionVisible"))
    return !0;
  const i = e.getContextKeyValue(x_.suppressSuggestions.key);
  return i !== void 0 ? !i : !s.getOption(
    62
    /* EditorOption.inlineSuggest */
  ).suppressSuggestions;
}
let l1 = $I = class {
  constructor(e, t, i, n, o, r, a, l, c) {
    this._editor = e, this._editorWorkerService = t, this._clipboardService = i, this._telemetryService = n, this._logService = o, this._contextKeyService = r, this._configurationService = a, this._languageFeaturesService = l, this._envService = c, this._toDispose = new X(), this._triggerCharacterListener = new X(), this._triggerQuickSuggest = new nr(), this._triggerState = void 0, this._completionDisposables = new X(), this._onDidCancel = new B(), this._onDidTrigger = new B(), this._onDidSuggest = new B(), this.onDidCancel = this._onDidCancel.event, this.onDidTrigger = this._onDidTrigger.event, this.onDidSuggest = this._onDidSuggest.event, this._telemetryGate = 0, this._currentSelection = this._editor.getSelection() || new Ue(1, 1, 1, 1), this._toDispose.add(this._editor.onDidChangeModel(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeModelLanguage(() => {
      this._updateTriggerCharacters(), this.cancel();
    })), this._toDispose.add(this._editor.onDidChangeConfiguration(() => {
      this._updateTriggerCharacters();
    })), this._toDispose.add(this._languageFeaturesService.completionProvider.onDidChange(() => {
      this._updateTriggerCharacters(), this._updateActiveSuggestSession();
    }));
    let d = !1;
    this._toDispose.add(this._editor.onDidCompositionStart(() => {
      d = !0;
    })), this._toDispose.add(this._editor.onDidCompositionEnd(() => {
      d = !1, this._onCompositionEnd();
    })), this._toDispose.add(this._editor.onDidChangeCursorSelection((h) => {
      d || this._onCursorChange(h);
    })), this._toDispose.add(this._editor.onDidChangeModelContent(() => {
      !d && this._triggerState !== void 0 && this._refilterCompletionItems();
    })), this._updateTriggerCharacters();
  }
  dispose() {
    Ct(this._triggerCharacterListener), Ct([this._onDidCancel, this._onDidSuggest, this._onDidTrigger, this._triggerQuickSuggest]), this._toDispose.dispose(), this._completionDisposables.dispose(), this.cancel();
  }
  _updateTriggerCharacters() {
    if (this._triggerCharacterListener.clear(), this._editor.getOption(
      92
      /* EditorOption.readOnly */
    ) || !this._editor.hasModel() || !this._editor.getOption(
      122
      /* EditorOption.suggestOnTriggerCharacters */
    ))
      return;
    const e = /* @__PURE__ */ new Map();
    for (const i of this._languageFeaturesService.completionProvider.all(this._editor.getModel()))
      for (const n of i.triggerCharacters || []) {
        let o = e.get(n);
        o || (o = /* @__PURE__ */ new Set(), e.set(n, o)), o.add(i);
      }
    const t = (i) => {
      if (!Age(this._editor, this._contextKeyService, this._configurationService) || Hd.shouldAutoTrigger(this._editor))
        return;
      if (!i) {
        const r = this._editor.getPosition();
        i = this._editor.getModel().getLineContent(r.lineNumber).substr(0, r.column - 1);
      }
      let n = "";
      gu(i.charCodeAt(i.length - 1)) ? Si(i.charCodeAt(i.length - 2)) && (n = i.substr(i.length - 2)) : n = i.charAt(i.length - 1);
      const o = e.get(n);
      if (o) {
        const r = /* @__PURE__ */ new Map();
        if (this._completionModel)
          for (const [a, l] of this._completionModel.getItemsByProvider())
            o.has(a) || r.set(a, l);
        this.trigger({
          auto: !0,
          triggerKind: 1,
          triggerCharacter: n,
          retrigger: !!this._completionModel,
          clipboardText: this._completionModel?.clipboardText,
          completionOptions: { providerFilter: o, providerItemsToReuse: r }
        });
      }
    };
    this._triggerCharacterListener.add(this._editor.onDidType(t)), this._triggerCharacterListener.add(this._editor.onDidCompositionEnd(() => t()));
  }
  // --- trigger/retrigger/cancel suggest
  get state() {
    return this._triggerState ? this._triggerState.auto ? 2 : 1 : 0;
  }
  cancel(e = !1) {
    this._triggerState !== void 0 && (this._triggerQuickSuggest.cancel(), this._requestToken?.cancel(), this._requestToken = void 0, this._triggerState = void 0, this._completionModel = void 0, this._context = void 0, this._onDidCancel.fire({ retrigger: e }));
  }
  clear() {
    this._completionDisposables.clear();
  }
  _updateActiveSuggestSession() {
    this._triggerState !== void 0 && (!this._editor.hasModel() || !this._languageFeaturesService.completionProvider.has(this._editor.getModel()) ? this.cancel() : this.trigger({ auto: this._triggerState.auto, retrigger: !0 }));
  }
  _onCursorChange(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._currentSelection;
    if (this._currentSelection = this._editor.getSelection(), !e.selection.isEmpty() || e.reason !== 0 && e.reason !== 3 || e.source !== "keyboard" && e.source !== "deleteLeft") {
      this.cancel();
      return;
    }
    this._triggerState === void 0 && e.reason === 0 ? (t.containsRange(this._currentSelection) || t.getEndPosition().isBeforeOrEqual(this._currentSelection.getPosition())) && this._doTriggerQuickSuggest() : this._triggerState !== void 0 && e.reason === 3 && this._refilterCompletionItems();
  }
  _onCompositionEnd() {
    this._triggerState === void 0 ? this._doTriggerQuickSuggest() : this._refilterCompletionItems();
  }
  _doTriggerQuickSuggest() {
    Jg.isAllOff(this._editor.getOption(
      90
      /* EditorOption.quickSuggestions */
    )) || this._editor.getOption(
      119
      /* EditorOption.suggest */
    ).snippetsPreventQuickSuggestions && ss.get(this._editor)?.isInSnippet() || (this.cancel(), this._triggerQuickSuggest.cancelAndSet(() => {
      if (this._triggerState !== void 0 || !Hd.shouldAutoTrigger(this._editor) || !this._editor.hasModel() || !this._editor.hasWidgetFocus())
        return;
      const e = this._editor.getModel(), t = this._editor.getPosition(), i = this._editor.getOption(
        90
        /* EditorOption.quickSuggestions */
      );
      if (!Jg.isAllOff(i)) {
        if (!Jg.isAllOn(i)) {
          e.tokenization.tokenizeIfCheap(t.lineNumber);
          const n = e.tokenization.getLineTokens(t.lineNumber), o = n.getStandardTokenType(n.findTokenIndexAtOffset(Math.max(t.column - 1 - 1, 0)));
          if (Jg.valueFor(i, o) !== "on")
            return;
        }
        pge(this._editor, this._contextKeyService, this._configurationService) && this._languageFeaturesService.completionProvider.has(e) && this.trigger({ auto: !0 });
      }
    }, this._editor.getOption(
      91
      /* EditorOption.quickSuggestionsDelay */
    )));
  }
  _refilterCompletionItems() {
    jt(this._editor.hasModel()), jt(this._triggerState !== void 0);
    const e = this._editor.getModel(), t = this._editor.getPosition(), i = new Hd(e, t, { ...this._triggerState, refilter: !0 });
    this._onNewContext(i);
  }
  trigger(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel(), i = new Hd(t, this._editor.getPosition(), e);
    this.cancel(e.retrigger), this._triggerState = e, this._onDidTrigger.fire({ auto: e.auto, shy: e.shy ?? !1, position: this._editor.getPosition() }), this._context = i;
    let n = {
      triggerKind: e.triggerKind ?? 0
      /* CompletionTriggerKind.Invoke */
    };
    e.triggerCharacter && (n = {
      triggerKind: 1,
      triggerCharacter: e.triggerCharacter
    }), this._requestToken = new vs();
    const o = this._editor.getOption(
      113
      /* EditorOption.snippetSuggestions */
    );
    let r = 1;
    switch (o) {
      case "top":
        r = 0;
        break;
      case "bottom":
        r = 2;
        break;
    }
    const { itemKind: a, showDeprecated: l } = $I.createSuggestFilter(this._editor), c = new y_(r, e.completionOptions?.kindFilter ?? a, e.completionOptions?.providerFilter, e.completionOptions?.providerItemsToReuse, l), d = a1.create(this._editorWorkerService, this._editor), h = AB(this._languageFeaturesService.completionProvider, t, this._editor.getPosition(), c, n, this._requestToken.token);
    Promise.all([h, d]).then(async ([u, g]) => {
      if (this._requestToken?.dispose(), !this._editor.hasModel())
        return;
      let m = e?.clipboardText;
      if (!m && u.needsClipboard && (m = await this._clipboardService.readText()), this._triggerState === void 0)
        return;
      const p = this._editor.getModel(), A = new Hd(p, this._editor.getPosition(), e), _ = {
        ...GA.default,
        firstMatchCanBeWeak: !this._editor.getOption(
          119
          /* EditorOption.suggest */
        ).matchOnWordStartOnly
      };
      if (this._completionModel = new yc(u.items, this._context.column, {
        leadingLineContent: A.leadingLineContent,
        characterCountDelta: A.column - this._context.column
      }, g, this._editor.getOption(
        119
        /* EditorOption.suggest */
      ), this._editor.getOption(
        113
        /* EditorOption.snippetSuggestions */
      ), _, m), this._completionDisposables.add(u.disposable), this._onNewContext(A), this._reportDurationsTelemetry(u.durations), !this._envService.isBuilt || this._envService.isExtensionDevelopment)
        for (const b of u.items)
          b.isInvalid && this._logService.warn(`[suggest] did IGNORE invalid completion item from ${b.provider._debugDisplayName}`, b.completion);
    }).catch(Pe);
  }
  _reportDurationsTelemetry(e) {
    this._telemetryGate++ % 230 === 0 && setTimeout(() => {
      this._telemetryService.publicLog2("suggest.durations.json", { data: JSON.stringify(e) }), this._logService.debug("suggest.durations.json", e);
    });
  }
  static createSuggestFilter(e) {
    const t = /* @__PURE__ */ new Set();
    e.getOption(
      113
      /* EditorOption.snippetSuggestions */
    ) === "none" && t.add(
      27
      /* CompletionItemKind.Snippet */
    );
    const n = e.getOption(
      119
      /* EditorOption.suggest */
    );
    return n.showMethods || t.add(
      0
      /* CompletionItemKind.Method */
    ), n.showFunctions || t.add(
      1
      /* CompletionItemKind.Function */
    ), n.showConstructors || t.add(
      2
      /* CompletionItemKind.Constructor */
    ), n.showFields || t.add(
      3
      /* CompletionItemKind.Field */
    ), n.showVariables || t.add(
      4
      /* CompletionItemKind.Variable */
    ), n.showClasses || t.add(
      5
      /* CompletionItemKind.Class */
    ), n.showStructs || t.add(
      6
      /* CompletionItemKind.Struct */
    ), n.showInterfaces || t.add(
      7
      /* CompletionItemKind.Interface */
    ), n.showModules || t.add(
      8
      /* CompletionItemKind.Module */
    ), n.showProperties || t.add(
      9
      /* CompletionItemKind.Property */
    ), n.showEvents || t.add(
      10
      /* CompletionItemKind.Event */
    ), n.showOperators || t.add(
      11
      /* CompletionItemKind.Operator */
    ), n.showUnits || t.add(
      12
      /* CompletionItemKind.Unit */
    ), n.showValues || t.add(
      13
      /* CompletionItemKind.Value */
    ), n.showConstants || t.add(
      14
      /* CompletionItemKind.Constant */
    ), n.showEnums || t.add(
      15
      /* CompletionItemKind.Enum */
    ), n.showEnumMembers || t.add(
      16
      /* CompletionItemKind.EnumMember */
    ), n.showKeywords || t.add(
      17
      /* CompletionItemKind.Keyword */
    ), n.showWords || t.add(
      18
      /* CompletionItemKind.Text */
    ), n.showColors || t.add(
      19
      /* CompletionItemKind.Color */
    ), n.showFiles || t.add(
      20
      /* CompletionItemKind.File */
    ), n.showReferences || t.add(
      21
      /* CompletionItemKind.Reference */
    ), n.showColors || t.add(
      22
      /* CompletionItemKind.Customcolor */
    ), n.showFolders || t.add(
      23
      /* CompletionItemKind.Folder */
    ), n.showTypeParameters || t.add(
      24
      /* CompletionItemKind.TypeParameter */
    ), n.showSnippets || t.add(
      27
      /* CompletionItemKind.Snippet */
    ), n.showUsers || t.add(
      25
      /* CompletionItemKind.User */
    ), n.showIssues || t.add(
      26
      /* CompletionItemKind.Issue */
    ), { itemKind: t, showDeprecated: n.showDeprecated };
  }
  _onNewContext(e) {
    if (this._context) {
      if (e.lineNumber !== this._context.lineNumber) {
        this.cancel();
        return;
      }
      if (Ii(e.leadingLineContent) !== Ii(this._context.leadingLineContent)) {
        this.cancel();
        return;
      }
      if (e.column < this._context.column) {
        e.leadingWord.word ? this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 }) : this.cancel();
        return;
      }
      if (this._completionModel) {
        if (e.leadingWord.word.length !== 0 && e.leadingWord.startColumn > this._context.leadingWord.startColumn) {
          if (Hd.shouldAutoTrigger(this._editor) && this._context) {
            const i = this._completionModel.getItemsByProvider();
            this.trigger({
              auto: this._context.triggerOptions.auto,
              retrigger: !0,
              clipboardText: this._completionModel.clipboardText,
              completionOptions: { providerItemsToReuse: i }
            });
          }
          return;
        }
        if (e.column > this._context.column && this._completionModel.getIncompleteProvider().size > 0 && e.leadingWord.word.length !== 0) {
          const t = /* @__PURE__ */ new Map(), i = /* @__PURE__ */ new Set();
          for (const [n, o] of this._completionModel.getItemsByProvider())
            o.length > 0 && o[0].container.incomplete ? i.add(n) : t.set(n, o);
          this.trigger({
            auto: this._context.triggerOptions.auto,
            triggerKind: 2,
            retrigger: !0,
            clipboardText: this._completionModel.clipboardText,
            completionOptions: { providerFilter: i, providerItemsToReuse: t }
          });
        } else {
          const t = this._completionModel.lineContext;
          let i = !1;
          if (this._completionModel.lineContext = {
            leadingLineContent: e.leadingLineContent,
            characterCountDelta: e.column - this._context.column
          }, this._completionModel.items.length === 0) {
            const n = Hd.shouldAutoTrigger(this._editor);
            if (!this._context) {
              this.cancel();
              return;
            }
            if (n && this._context.leadingWord.endColumn < e.leadingWord.startColumn) {
              this.trigger({ auto: this._context.triggerOptions.auto, retrigger: !0 });
              return;
            }
            if (this._context.triggerOptions.auto) {
              this.cancel();
              return;
            } else if (this._completionModel.lineContext = t, i = this._completionModel.items.length > 0, i && e.leadingWord.word.length === 0) {
              this.cancel();
              return;
            }
          }
          this._onDidSuggest.fire({
            completionModel: this._completionModel,
            triggerOptions: e.triggerOptions,
            isFrozen: i
          });
        }
      }
    }
  }
};
l1 = $I = mge([
  ac(1, Sd),
  ac(2, Yu),
  ac(3, eo),
  ac(4, Es),
  ac(5, Se),
  ac(6, ht),
  ac(7, ye),
  ac(8, uN)
], l1);
const c0 = class c0 {
  constructor(e, t) {
    this._disposables = new X(), this._lastOvertyped = [], this._locked = !1, this._disposables.add(e.onWillType(() => {
      if (this._locked || !e.hasModel())
        return;
      const i = e.getSelections(), n = i.length;
      let o = !1;
      for (let a = 0; a < n; a++)
        if (!i[a].isEmpty()) {
          o = !0;
          break;
        }
      if (!o) {
        this._lastOvertyped.length !== 0 && (this._lastOvertyped.length = 0);
        return;
      }
      this._lastOvertyped = [];
      const r = e.getModel();
      for (let a = 0; a < n; a++) {
        const l = i[a];
        if (r.getValueLengthInRange(l) > c0._maxSelectionLength)
          return;
        this._lastOvertyped[a] = { value: r.getValueInRange(l), multiline: l.startLineNumber !== l.endLineNumber };
      }
    })), this._disposables.add(t.onDidTrigger((i) => {
      this._locked = !0;
    })), this._disposables.add(t.onDidCancel((i) => {
      this._locked = !1;
    }));
  }
  getLastOvertypedInfo(e) {
    if (e >= 0 && e < this._lastOvertyped.length)
      return this._lastOvertyped[e];
  }
  dispose() {
    this._disposables.dispose();
  }
};
c0._maxSelectionLength = 51200;
let XI = c0;
var _ge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, px = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
let ZI = class {
  constructor(e, t, i, n, o) {
    this._menuId = t, this._menuService = n, this._contextKeyService = o, this._menuDisposables = new X(), this.element = K(e, de(".suggest-status-bar"));
    const r = (a) => a instanceof bo ? i.createInstance(QN, a, { useComma: !0 }) : void 0;
    this._leftActions = new wo(this.element, { actionViewItemProvider: r }), this._rightActions = new wo(this.element, { actionViewItemProvider: r }), this._leftActions.domNode.classList.add("left"), this._rightActions.domNode.classList.add("right");
  }
  dispose() {
    this._menuDisposables.dispose(), this._leftActions.dispose(), this._rightActions.dispose(), this.element.remove();
  }
  show() {
    const e = this._menuService.createMenu(this._menuId, this._contextKeyService), t = () => {
      const i = [], n = [];
      for (const [o, r] of e.getActions())
        o === "left" ? i.push(...r) : n.push(...r);
      this._leftActions.clear(), this._leftActions.push(i), this._rightActions.clear(), this._rightActions.push(n);
    };
    this._menuDisposables.add(e.onDidChange(() => t())), this._menuDisposables.add(e);
  }
  hide() {
    this._menuDisposables.clear();
  }
};
ZI = _ge([
  px(2, ke),
  px(3, sr),
  px(4, Se)
], ZI);
var bge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, wge = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function wB(s) {
  return !!s && !!(s.completion.documentation || s.completion.detail && s.completion.detail !== s.completion.label);
}
let eM = class {
  constructor(e, t) {
    this._editor = e, this._onDidClose = new B(), this.onDidClose = this._onDidClose.event, this._onDidChangeContents = new B(), this.onDidChangeContents = this._onDidChangeContents.event, this._disposables = new X(), this._renderDisposeable = new X(), this._borderWidth = 1, this._size = new at(330, 0), this.domNode = de(".suggest-details"), this.domNode.classList.add("no-docs"), this._markdownRenderer = t.createInstance(Cu, { editor: e }), this._body = de(".body"), this._scrollbar = new F_(this._body, {
      alwaysConsumeMouseWheel: !0
    }), K(this.domNode, this._scrollbar.getDomNode()), this._disposables.add(this._scrollbar), this._header = K(this._body, de(".header")), this._close = K(this._header, de("span" + pe.asCSSSelector(Z.close))), this._close.title = f("details.close", "Close"), this._type = K(this._header, de("p.type")), this._docs = K(this._body, de("p.docs")), this._configureFont(), this._disposables.add(this._editor.onDidChangeConfiguration((i) => {
      i.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) && this._configureFont();
    }));
  }
  dispose() {
    this._disposables.dispose(), this._renderDisposeable.dispose();
  }
  _configureFont() {
    const e = this._editor.getOptions(), t = e.get(
      50
      /* EditorOption.fontInfo */
    ), i = t.getMassagedFontFamily(), n = e.get(
      120
      /* EditorOption.suggestFontSize */
    ) || t.fontSize, o = e.get(
      121
      /* EditorOption.suggestLineHeight */
    ) || t.lineHeight, r = t.fontWeight, a = `${n}px`, l = `${o}px`;
    this.domNode.style.fontSize = a, this.domNode.style.lineHeight = `${o / n}`, this.domNode.style.fontWeight = r, this.domNode.style.fontFeatureSettings = t.fontFeatureSettings, this._type.style.fontFamily = i, this._close.style.height = l, this._close.style.width = l;
  }
  getLayoutInfo() {
    const e = this._editor.getOption(
      121
      /* EditorOption.suggestLineHeight */
    ) || this._editor.getOption(
      50
      /* EditorOption.fontInfo */
    ).lineHeight, t = this._borderWidth, i = t * 2;
    return {
      lineHeight: e,
      borderWidth: t,
      borderHeight: i,
      verticalPadding: 22,
      horizontalPadding: 14
    };
  }
  renderLoading() {
    this._type.textContent = f("loading", "Loading..."), this._docs.textContent = "", this.domNode.classList.remove("no-docs", "no-type"), this.layout(this.size.width, this.getLayoutInfo().lineHeight * 2), this._onDidChangeContents.fire(this);
  }
  renderItem(e, t) {
    this._renderDisposeable.clear();
    let { detail: i, documentation: n } = e.completion;
    if (t) {
      let o = "";
      o += `score: ${e.score[0]}
`, o += `prefix: ${e.word ?? "(no prefix)"}
`, o += `word: ${e.completion.filterText ? e.completion.filterText + " (filterText)" : e.textLabel}
`, o += `distance: ${e.distance} (localityBonus-setting)
`, o += `index: ${e.idx}, based on ${e.completion.sortText && `sortText: "${e.completion.sortText}"` || "label"}
`, o += `commit_chars: ${e.completion.commitCharacters?.join("")}
`, n = new Vo().appendCodeblock("empty", o), i = `Provider: ${e.provider._debugDisplayName}`;
    }
    if (!t && !wB(e)) {
      this.clearContents();
      return;
    }
    if (this.domNode.classList.remove("no-docs", "no-type"), i) {
      const o = i.length > 1e5 ? `${i.substr(0, 1e5)}…` : i;
      this._type.textContent = o, this._type.title = o, ps(this._type), this._type.classList.toggle("auto-wrap", !/\r?\n^\s+/gmi.test(o));
    } else
      Bn(this._type), this._type.title = "", Dn(this._type), this.domNode.classList.add("no-type");
    if (Bn(this._docs), typeof n == "string")
      this._docs.classList.remove("markdown-docs"), this._docs.textContent = n;
    else if (n) {
      this._docs.classList.add("markdown-docs"), Bn(this._docs);
      const o = this._markdownRenderer.render(n);
      this._docs.appendChild(o.element), this._renderDisposeable.add(o), this._renderDisposeable.add(this._markdownRenderer.onDidRenderAsync(() => {
        this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
      }));
    }
    this.domNode.style.userSelect = "text", this.domNode.tabIndex = -1, this._close.onmousedown = (o) => {
      o.preventDefault(), o.stopPropagation();
    }, this._close.onclick = (o) => {
      o.preventDefault(), o.stopPropagation(), this._onDidClose.fire();
    }, this._body.scrollTop = 0, this.layout(this._size.width, this._type.clientHeight + this._docs.clientHeight), this._onDidChangeContents.fire(this);
  }
  clearContents() {
    this.domNode.classList.add("no-docs"), this._type.textContent = "", this._docs.textContent = "";
  }
  get isEmpty() {
    return this.domNode.classList.contains("no-docs");
  }
  get size() {
    return this._size;
  }
  layout(e, t) {
    const i = new at(e, t);
    at.equals(i, this._size) || (this._size = i, H6(this.domNode, e, t)), this._scrollbar.scanDomNode();
  }
  scrollDown(e = 8) {
    this._body.scrollTop += e;
  }
  scrollUp(e = 8) {
    this._body.scrollTop -= e;
  }
  scrollTop() {
    this._body.scrollTop = 0;
  }
  scrollBottom() {
    this._body.scrollTop = this._body.scrollHeight;
  }
  pageDown() {
    this.scrollDown(80);
  }
  pageUp() {
    this.scrollUp(80);
  }
  set borderWidth(e) {
    this._borderWidth = e;
  }
  get borderWidth() {
    return this._borderWidth;
  }
};
eM = bge([
  wge(1, ke)
], eM);
class Cge {
  constructor(e, t) {
    this.widget = e, this._editor = t, this.allowEditorOverflow = !0, this._disposables = new X(), this._added = !1, this._preferAlignAtTop = !0, this._resizable = new lB(), this._resizable.domNode.classList.add("suggest-details-container"), this._resizable.domNode.appendChild(e.domNode), this._resizable.enableSashes(!1, !0, !0, !1);
    let i, n, o = 0, r = 0;
    this._disposables.add(this._resizable.onDidWillResize(() => {
      i = this._topLeft, n = this._resizable.size;
    })), this._disposables.add(this._resizable.onDidResize((a) => {
      if (i && n) {
        this.widget.layout(a.dimension.width, a.dimension.height);
        let l = !1;
        a.west && (r = n.width - a.dimension.width, l = !0), a.north && (o = n.height - a.dimension.height, l = !0), l && this._applyTopLeft({
          top: i.top + o,
          left: i.left + r
        });
      }
      a.done && (i = void 0, n = void 0, o = 0, r = 0, this._userSize = a.dimension);
    })), this._disposables.add(this.widget.onDidChangeContents(() => {
      this._anchorBox && this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, this._preferAlignAtTop);
    }));
  }
  dispose() {
    this._resizable.dispose(), this._disposables.dispose(), this.hide();
  }
  getId() {
    return "suggest.details";
  }
  getDomNode() {
    return this._resizable.domNode;
  }
  getPosition() {
    return this._topLeft ? { preference: this._topLeft } : null;
  }
  show() {
    this._added || (this._editor.addOverlayWidget(this), this._added = !0);
  }
  hide(e = !1) {
    this._resizable.clearSashHoverState(), this._added && (this._editor.removeOverlayWidget(this), this._added = !1, this._anchorBox = void 0, this._topLeft = void 0), e && (this._userSize = void 0, this.widget.clearContents());
  }
  placeAtAnchor(e, t) {
    const i = e.getBoundingClientRect();
    this._anchorBox = i, this._preferAlignAtTop = t, this._placeAtAnchor(this._anchorBox, this._userSize ?? this.widget.size, t);
  }
  _placeAtAnchor(e, t, i) {
    const n = mu(this.getDomNode().ownerDocument.body), o = this.widget.getLayoutInfo(), r = new at(220, 2 * o.lineHeight), a = e.top, l = function() {
      const S = n.width - (e.left + e.width + o.borderWidth + o.horizontalPadding), x = -o.borderWidth + e.left + e.width, y = new at(S, n.height - e.top - o.borderHeight - o.verticalPadding), D = y.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: a, left: x, fit: S - t.width, maxSizeTop: y, maxSizeBottom: D, minSize: r.with(Math.min(S, r.width)) };
    }(), c = function() {
      const S = e.left - o.borderWidth - o.horizontalPadding, x = Math.max(o.horizontalPadding, e.left - t.width - o.borderWidth), y = new at(S, n.height - e.top - o.borderHeight - o.verticalPadding), D = y.with(void 0, e.top + e.height - o.borderHeight - o.verticalPadding);
      return { top: a, left: x, fit: S - t.width, maxSizeTop: y, maxSizeBottom: D, minSize: r.with(Math.min(S, r.width)) };
    }(), d = function() {
      const S = e.left, x = -o.borderWidth + e.top + e.height, y = new at(e.width - o.borderHeight, n.height - e.top - e.height - o.verticalPadding);
      return { top: x, left: S, fit: y.height - t.height, maxSizeBottom: y, maxSizeTop: y, minSize: r.with(y.width) };
    }(), h = [l, c, d], u = h.find((S) => S.fit >= 0) ?? h.sort((S, x) => x.fit - S.fit)[0], g = e.top + e.height - o.borderHeight;
    let m, p = t.height;
    const A = Math.max(u.maxSizeTop.height, u.maxSizeBottom.height);
    p > A && (p = A);
    let _;
    i ? p <= u.maxSizeTop.height ? (m = !0, _ = u.maxSizeTop) : (m = !1, _ = u.maxSizeBottom) : p <= u.maxSizeBottom.height ? (m = !1, _ = u.maxSizeBottom) : (m = !0, _ = u.maxSizeTop);
    let { top: b, left: C } = u;
    !m && p > e.height && (b = g - p);
    const w = this._editor.getDomNode();
    if (w) {
      const S = w.getBoundingClientRect();
      b -= S.top, C -= S.left;
    }
    this._applyTopLeft({ left: C, top: b }), this._resizable.enableSashes(!m, u === l, m, u !== l), this._resizable.minSize = u.minSize, this._resizable.maxSize = _, this._resizable.layout(p, Math.min(_.width, t.width)), this.widget.layout(this._resizable.size.width, this._resizable.size.height);
  }
  _applyTopLeft(e) {
    this._topLeft = e, this._editor.layoutOverlayWidget(this);
  }
}
var ba;
(function(s) {
  s[s.FILE = 0] = "FILE", s[s.FOLDER = 1] = "FOLDER", s[s.ROOT_FOLDER = 2] = "ROOT_FOLDER";
})(ba || (ba = {}));
const vge = /(?:\/|^)(?:([^\/]+)\/)?([^\/]+)$/;
function tw(s, e, t, i, n) {
  if (pe.isThemeIcon(n))
    return [`codicon-${n.id}`, "predefined-file-icon"];
  if (_e.isUri(n))
    return [];
  const o = i === ba.ROOT_FOLDER ? ["rootfolder-icon"] : i === ba.FOLDER ? ["folder-icon"] : ["file-icon"];
  if (t) {
    let r;
    if (t.scheme === Ie.data)
      r = ld.parseMetaData(t).get(ld.META_DATA_LABEL);
    else {
      const a = t.path.match(vge);
      a ? (r = iw(a[2].toLowerCase()), a[1] && o.push(`${iw(a[1].toLowerCase())}-name-dir-icon`)) : r = iw(t.authority.toLowerCase());
    }
    if (i === ba.ROOT_FOLDER)
      o.push(`${r}-root-name-folder-icon`);
    else if (i === ba.FOLDER)
      o.push(`${r}-name-folder-icon`);
    else {
      if (r) {
        if (o.push(`${r}-name-file-icon`), o.push("name-file-icon"), r.length <= 255) {
          const l = r.split(".");
          for (let c = 1; c < l.length; c++)
            o.push(`${l.slice(c).join(".")}-ext-file-icon`);
        }
        o.push("ext-file-icon");
      }
      const a = Sge(s, e, t);
      a && o.push(`${iw(a)}-lang-file-icon`);
    }
  }
  return o;
}
function Sge(s, e, t) {
  if (!t)
    return null;
  let i = null;
  if (t.scheme === Ie.data) {
    const o = ld.parseMetaData(t).get(ld.META_DATA_MIME);
    o && (i = e.getLanguageIdByMimeType(o));
  } else {
    const n = s.getModel(t);
    n && (i = n.getLanguageId());
  }
  return i && i !== Js ? i : e.guessLanguageIdByFilepathOrFirstLine(t);
}
function iw(s) {
  return s.replace(/[\s]/g, "/");
}
var yge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Ax = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
function e9(s) {
  return `suggest-aria-id:${s}`;
}
const xge = Rt("suggest-more-info", Z.chevronRight, f("suggestMoreInfoIcon", "Icon for more information in the suggest widget."));
var kr;
const Ege = new (kr = class {
  extract(e, t) {
    if (e.textLabel.match(kr._regexStrict))
      return t[0] = e.textLabel, !0;
    if (e.completion.detail && e.completion.detail.match(kr._regexStrict))
      return t[0] = e.completion.detail, !0;
    if (e.completion.documentation) {
      const i = typeof e.completion.documentation == "string" ? e.completion.documentation : e.completion.documentation.value, n = kr._regexRelaxed.exec(i);
      if (n && (n.index === 0 || n.index + n[0].length === i.length))
        return t[0] = n[0], !0;
    }
    return !1;
  }
}, kr._regexRelaxed = /(#([\da-fA-F]{3}){1,2}|(rgb|hsl)a\(\s*(\d{1,3}%?\s*,\s*){3}(1|0?\.\d+)\)|(rgb|hsl)\(\s*\d{1,3}%?(\s*,\s*\d{1,3}%?){2}\s*\))/, kr._regexStrict = new RegExp(`^${kr._regexRelaxed.source}$`, "i"), kr)();
let tM = class {
  constructor(e, t, i, n) {
    this._editor = e, this._modelService = t, this._languageService = i, this._themeService = n, this._onDidToggleDetails = new B(), this.onDidToggleDetails = this._onDidToggleDetails.event, this.templateId = "suggestion";
  }
  dispose() {
    this._onDidToggleDetails.dispose();
  }
  renderTemplate(e) {
    const t = new X(), i = e;
    i.classList.add("show-file-icons");
    const n = K(e, de(".icon")), o = K(n, de("span.colorspan")), r = K(e, de(".contents")), a = K(r, de(".main")), l = K(a, de(".icon-label.codicon")), c = K(a, de("span.left")), d = K(a, de("span.right")), h = new rv(c, { supportHighlights: !0, supportIcons: !0 });
    t.add(h);
    const u = K(c, de("span.signature-label")), g = K(c, de("span.qualifier-label")), m = K(d, de("span.details-label")), p = K(d, de("span.readMore" + pe.asCSSSelector(xge)));
    return p.title = f("readMore", "Read More"), { root: i, left: c, right: d, icon: n, colorspan: o, iconLabel: h, iconContainer: l, parametersLabel: u, qualifierLabel: g, detailsLabel: m, readMore: p, disposables: t, configureFont: () => {
      const _ = this._editor.getOptions(), b = _.get(
        50
        /* EditorOption.fontInfo */
      ), C = b.getMassagedFontFamily(), w = b.fontFeatureSettings, S = _.get(
        120
        /* EditorOption.suggestFontSize */
      ) || b.fontSize, x = _.get(
        121
        /* EditorOption.suggestLineHeight */
      ) || b.lineHeight, y = b.fontWeight, D = b.letterSpacing, I = `${S}px`, Q = `${x}px`, P = `${D}px`;
      i.style.fontSize = I, i.style.fontWeight = y, i.style.letterSpacing = P, a.style.fontFamily = C, a.style.fontFeatureSettings = w, a.style.lineHeight = Q, n.style.height = Q, n.style.width = Q, p.style.height = Q, p.style.width = Q;
    } };
  }
  renderElement(e, t, i) {
    i.configureFont();
    const { completion: n } = e;
    i.root.id = e9(t), i.colorspan.style.backgroundColor = "";
    const o = {
      labelEscapeNewLines: !0,
      matches: q0(e.score)
    }, r = [];
    if (n.kind === 19 && Ege.extract(e, r))
      i.icon.className = "icon customcolor", i.iconContainer.className = "icon hide", i.colorspan.style.backgroundColor = r[0];
    else if (n.kind === 20 && this._themeService.getFileIconTheme().hasFileIcons) {
      i.icon.className = "icon hide", i.iconContainer.className = "icon hide";
      const a = tw(this._modelService, this._languageService, _e.from({ scheme: "fake", path: e.textLabel }), ba.FILE), l = tw(this._modelService, this._languageService, _e.from({ scheme: "fake", path: n.detail }), ba.FILE);
      o.extraClasses = a.length > l.length ? a : l;
    } else n.kind === 23 && this._themeService.getFileIconTheme().hasFolderIcons ? (i.icon.className = "icon hide", i.iconContainer.className = "icon hide", o.extraClasses = [
      tw(this._modelService, this._languageService, _e.from({ scheme: "fake", path: e.textLabel }), ba.FOLDER),
      tw(this._modelService, this._languageService, _e.from({ scheme: "fake", path: n.detail }), ba.FOLDER)
    ].flat()) : (i.icon.className = "icon hide", i.iconContainer.className = "", i.iconContainer.classList.add("suggest-icon", ...pe.asClassNameArray(EA.toIcon(n.kind))));
    n.tags && n.tags.indexOf(
      1
      /* CompletionItemTag.Deprecated */
    ) >= 0 && (o.extraClasses = (o.extraClasses || []).concat(["deprecated"]), o.matches = []), i.iconLabel.setLabel(e.textLabel, void 0, o), typeof n.label == "string" ? (i.parametersLabel.textContent = "", i.detailsLabel.textContent = _x(n.detail || ""), i.root.classList.add("string-label")) : (i.parametersLabel.textContent = _x(n.label.detail || ""), i.detailsLabel.textContent = _x(n.label.description || ""), i.root.classList.remove("string-label")), this._editor.getOption(
      119
      /* EditorOption.suggest */
    ).showInlineDetails ? ps(i.detailsLabel) : Dn(i.detailsLabel), wB(e) ? (i.right.classList.add("can-expand-details"), ps(i.readMore), i.readMore.onmousedown = (a) => {
      a.stopPropagation(), a.preventDefault();
    }, i.readMore.onclick = (a) => {
      a.stopPropagation(), a.preventDefault(), this._onDidToggleDetails.fire();
    }) : (i.right.classList.remove("can-expand-details"), Dn(i.readMore), i.readMore.onmousedown = null, i.readMore.onclick = null);
  }
  disposeTemplate(e) {
    e.disposables.dispose();
  }
};
tM = yge([
  Ax(1, Fi),
  Ax(2, si),
  Ax(3, nn)
], tM);
function _x(s) {
  return s.replace(/\r\n|\r|\n/g, "");
}
var Lge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, nw = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, Lg;
L("editorSuggestWidget.background", Ao, f("editorSuggestWidgetBackground", "Background color of the suggest widget."));
L("editorSuggestWidget.border", pN, f("editorSuggestWidgetBorder", "Border color of the suggest widget."));
const kge = L("editorSuggestWidget.foreground", Fa, f("editorSuggestWidgetForeground", "Foreground color of the suggest widget."));
L("editorSuggestWidget.selectedForeground", SC, f("editorSuggestWidgetSelectedForeground", "Foreground color of the selected entry in the suggest widget."));
L("editorSuggestWidget.selectedIconForeground", vN, f("editorSuggestWidgetSelectedIconForeground", "Icon foreground color of the selected entry in the suggest widget."));
const Dge = L("editorSuggestWidget.selectedBackground", yC, f("editorSuggestWidgetSelectedBackground", "Background color of the selected entry in the suggest widget."));
L("editorSuggestWidget.highlightForeground", Rg, f("editorSuggestWidgetHighlightForeground", "Color of the match highlights in the suggest widget."));
L("editorSuggestWidget.focusHighlightForeground", sK, f("editorSuggestWidgetFocusHighlightForeground", "Color of the match highlights in the suggest widget when an item is focused."));
L("editorSuggestWidgetStatus.foreground", Me(kge, 0.5), f("editorSuggestWidgetStatusForeground", "Foreground color of the suggest widget status."));
class Ige {
  constructor(e, t) {
    this._service = e, this._key = `suggestWidget.size/${t.getEditorType()}/${t instanceof ku}`;
  }
  restore() {
    const e = this._service.get(
      this._key,
      0
      /* StorageScope.PROFILE */
    ) ?? "";
    try {
      const t = JSON.parse(e);
      if (at.is(t))
        return at.lift(t);
    } catch {
    }
  }
  store(e) {
    this._service.store(
      this._key,
      JSON.stringify(e),
      0,
      1
      /* StorageTarget.MACHINE */
    );
  }
  reset() {
    this._service.remove(
      this._key,
      0
      /* StorageScope.PROFILE */
    );
  }
}
var td;
let iM = (td = class {
  constructor(e, t, i, n, o) {
    this.editor = e, this._storageService = t, this._state = 0, this._isAuto = !1, this._pendingLayout = new On(), this._pendingShowDetails = new On(), this._ignoreFocusEvents = !1, this._forceRenderingAbove = !1, this._explainMode = !1, this._showTimeout = new nr(), this._disposables = new X(), this._onDidSelect = new uu(), this._onDidFocus = new uu(), this._onDidHide = new B(), this._onDidShow = new B(), this.onDidSelect = this._onDidSelect.event, this.onDidFocus = this._onDidFocus.event, this.onDidHide = this._onDidHide.event, this.onDidShow = this._onDidShow.event, this._onDetailsKeydown = new B(), this.onDetailsKeyDown = this._onDetailsKeydown.event, this.element = new lB(), this.element.domNode.classList.add("editor-widget", "suggest-widget"), this._contentWidget = new Mge(this, e), this._persistedSize = new Ige(t, e);
    class r {
      constructor(g, m, p = !1, A = !1) {
        this.persistedSize = g, this.currentSize = m, this.persistHeight = p, this.persistWidth = A;
      }
    }
    let a;
    this._disposables.add(this.element.onDidWillResize(() => {
      this._contentWidget.lockPreference(), a = new r(this._persistedSize.restore(), this.element.size);
    })), this._disposables.add(this.element.onDidResize((u) => {
      if (this._resize(u.dimension.width, u.dimension.height), a && (a.persistHeight = a.persistHeight || !!u.north || !!u.south, a.persistWidth = a.persistWidth || !!u.east || !!u.west), !!u.done) {
        if (a) {
          const { itemHeight: g, defaultSize: m } = this.getLayoutInfo(), p = Math.round(g / 2);
          let { width: A, height: _ } = this.element.size;
          (!a.persistHeight || Math.abs(a.currentSize.height - _) <= p) && (_ = a.persistedSize?.height ?? m.height), (!a.persistWidth || Math.abs(a.currentSize.width - A) <= p) && (A = a.persistedSize?.width ?? m.width), this._persistedSize.store(new at(A, _));
        }
        this._contentWidget.unlockPreference(), a = void 0;
      }
    })), this._messageElement = K(this.element.domNode, de(".message")), this._listElement = K(this.element.domNode, de(".tree"));
    const l = this._disposables.add(o.createInstance(eM, this.editor));
    l.onDidClose(this.toggleDetails, this, this._disposables), this._details = new Cge(l, this.editor);
    const c = () => this.element.domNode.classList.toggle("no-icons", !this.editor.getOption(
      119
      /* EditorOption.suggest */
    ).showIcons);
    c();
    const d = o.createInstance(tM, this.editor);
    this._disposables.add(d), this._disposables.add(d.onDidToggleDetails(() => this.toggleDetails())), this._list = new ko("SuggestWidget", this._listElement, {
      getHeight: (u) => this.getLayoutInfo().itemHeight,
      getTemplateId: (u) => "suggestion"
    }, [d], {
      alwaysConsumeMouseWheel: !0,
      useShadows: !1,
      mouseSupport: !1,
      multipleSelectionSupport: !1,
      accessibilityProvider: {
        getRole: () => "option",
        getWidgetAriaLabel: () => f("suggest", "Suggest"),
        getWidgetRole: () => "listbox",
        getAriaLabel: (u) => {
          let g = u.textLabel;
          if (typeof u.completion.label != "string") {
            const { detail: _, description: b } = u.completion.label;
            _ && b ? g = f("label.full", "{0} {1}, {2}", g, _, b) : _ ? g = f("label.detail", "{0} {1}", g, _) : b && (g = f("label.desc", "{0}, {1}", g, b));
          }
          if (!u.isResolved || !this._isDetailsVisible())
            return g;
          const { documentation: m, detail: p } = u.completion, A = Vf("{0}{1}", p || "", m ? typeof m == "string" ? m : m.value : "");
          return f("ariaCurrenttSuggestionReadDetails", "{0}, docs: {1}", g, A);
        }
      }
    }), this._list.style(ym({
      listInactiveFocusBackground: Dge,
      listInactiveFocusOutline: Kt
    })), this._status = o.createInstance(ZI, this.element.domNode, Uc);
    const h = () => this.element.domNode.classList.toggle("with-status-bar", this.editor.getOption(
      119
      /* EditorOption.suggest */
    ).showStatusBar);
    h(), this._disposables.add(n.onDidColorThemeChange((u) => this._onThemeChange(u))), this._onThemeChange(n.getColorTheme()), this._disposables.add(this._list.onMouseDown((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onTap((u) => this._onListMouseDownOrTap(u))), this._disposables.add(this._list.onDidChangeSelection((u) => this._onListSelection(u))), this._disposables.add(this._list.onDidChangeFocus((u) => this._onListFocus(u))), this._disposables.add(this.editor.onDidChangeCursorSelection(() => this._onCursorSelectionChanged())), this._disposables.add(this.editor.onDidChangeConfiguration((u) => {
      u.hasChanged(
        119
        /* EditorOption.suggest */
      ) && (h(), c()), this._completionModel && (u.hasChanged(
        50
        /* EditorOption.fontInfo */
      ) || u.hasChanged(
        120
        /* EditorOption.suggestFontSize */
      ) || u.hasChanged(
        121
        /* EditorOption.suggestLineHeight */
      )) && this._list.splice(0, this._list.length, this._completionModel.items);
    })), this._ctxSuggestWidgetVisible = Te.Visible.bindTo(i), this._ctxSuggestWidgetDetailsVisible = Te.DetailsVisible.bindTo(i), this._ctxSuggestWidgetMultipleSuggestions = Te.MultipleSuggestions.bindTo(i), this._ctxSuggestWidgetHasFocusedSuggestion = Te.HasFocusedSuggestion.bindTo(i), this._disposables.add(Xt(this._details.widget.domNode, "keydown", (u) => {
      this._onDetailsKeydown.fire(u);
    })), this._disposables.add(this.editor.onMouseDown((u) => this._onEditorMouseDown(u)));
  }
  dispose() {
    this._details.widget.dispose(), this._details.dispose(), this._list.dispose(), this._status.dispose(), this._disposables.dispose(), this._loadingTimeout?.dispose(), this._pendingLayout.dispose(), this._pendingShowDetails.dispose(), this._showTimeout.dispose(), this._contentWidget.dispose(), this.element.dispose();
  }
  _onEditorMouseDown(e) {
    this._details.widget.domNode.contains(e.target.element) ? this._details.widget.domNode.focus() : this.element.domNode.contains(e.target.element) && this.editor.focus();
  }
  _onCursorSelectionChanged() {
    this._state !== 0 && this._contentWidget.layout();
  }
  _onListMouseDownOrTap(e) {
    typeof e.element > "u" || typeof e.index > "u" || (e.browserEvent.preventDefault(), e.browserEvent.stopPropagation(), this._select(e.element, e.index));
  }
  _onListSelection(e) {
    e.elements.length && this._select(e.elements[0], e.indexes[0]);
  }
  _select(e, t) {
    const i = this._completionModel;
    i && (this._onDidSelect.fire({ item: e, index: t, model: i }), this.editor.focus());
  }
  _onThemeChange(e) {
    this._details.widget.borderWidth = Ca(e.type) ? 2 : 1;
  }
  _onListFocus(e) {
    if (this._ignoreFocusEvents)
      return;
    if (!e.elements.length) {
      this._currentSuggestionDetails && (this._currentSuggestionDetails.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = void 0), this.editor.setAriaOptions({ activeDescendant: void 0 }), this._ctxSuggestWidgetHasFocusedSuggestion.set(!1);
      return;
    }
    if (!this._completionModel)
      return;
    this._ctxSuggestWidgetHasFocusedSuggestion.set(!0);
    const t = e.elements[0], i = e.indexes[0];
    t !== this._focusedItem && (this._currentSuggestionDetails?.cancel(), this._currentSuggestionDetails = void 0, this._focusedItem = t, this._list.reveal(i), this._currentSuggestionDetails = ir(async (n) => {
      const o = zf(() => {
        this._isDetailsVisible() && this.showDetails(!0);
      }, 250), r = n.onCancellationRequested(() => o.dispose());
      try {
        return await t.resolve(n);
      } finally {
        o.dispose(), r.dispose();
      }
    }), this._currentSuggestionDetails.then(() => {
      i >= this._list.length || t !== this._list.element(i) || (this._ignoreFocusEvents = !0, this._list.splice(i, 1, [t]), this._list.setFocus([i]), this._ignoreFocusEvents = !1, this._isDetailsVisible() ? this.showDetails(!1) : this.element.domNode.classList.remove("docs-side"), this.editor.setAriaOptions({ activeDescendant: e9(i) }));
    }).catch(Pe)), this._onDidFocus.fire({ item: t, index: i, model: this._completionModel });
  }
  _setState(e) {
    if (this._state !== e)
      switch (this._state = e, this.element.domNode.classList.toggle(
        "frozen",
        e === 4
        /* State.Frozen */
      ), this.element.domNode.classList.remove("message"), e) {
        case 0:
          Dn(this._messageElement, this._listElement, this._status.element), this._details.hide(!0), this._status.hide(), this._contentWidget.hide(), this._ctxSuggestWidgetVisible.reset(), this._ctxSuggestWidgetMultipleSuggestions.reset(), this._ctxSuggestWidgetHasFocusedSuggestion.reset(), this._showTimeout.cancel(), this.element.domNode.classList.remove("visible"), this._list.splice(0, this._list.length), this._focusedItem = void 0, this._cappedHeight = void 0, this._explainMode = !1;
          break;
        case 1:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = Lg.LOADING_MESSAGE, Dn(this._listElement, this._status.element), ps(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, vu(Lg.LOADING_MESSAGE);
          break;
        case 2:
          this.element.domNode.classList.add("message"), this._messageElement.textContent = Lg.NO_SUGGESTIONS_MESSAGE, Dn(this._listElement, this._status.element), ps(this._messageElement), this._details.hide(), this._show(), this._focusedItem = void 0, vu(Lg.NO_SUGGESTIONS_MESSAGE);
          break;
        case 3:
          Dn(this._messageElement), ps(this._listElement, this._status.element), this._show();
          break;
        case 4:
          Dn(this._messageElement), ps(this._listElement, this._status.element), this._show();
          break;
        case 5:
          Dn(this._messageElement), ps(this._listElement, this._status.element), this._details.show(), this._show();
          break;
      }
  }
  _show() {
    this._status.show(), this._contentWidget.show(), this._layout(this._persistedSize.restore()), this._ctxSuggestWidgetVisible.set(!0), this._showTimeout.cancelAndSet(() => {
      this.element.domNode.classList.add("visible"), this._onDidShow.fire(this);
    }, 100);
  }
  showTriggered(e, t) {
    this._state === 0 && (this._contentWidget.setPosition(this.editor.getPosition()), this._isAuto = !!e, this._isAuto || (this._loadingTimeout = zf(() => this._setState(
      1
      /* State.Loading */
    ), t)));
  }
  showSuggestions(e, t, i, n, o) {
    if (this._contentWidget.setPosition(this.editor.getPosition()), this._loadingTimeout?.dispose(), this._currentSuggestionDetails?.cancel(), this._currentSuggestionDetails = void 0, this._completionModel !== e && (this._completionModel = e), i && this._state !== 2 && this._state !== 0) {
      this._setState(
        4
        /* State.Frozen */
      );
      return;
    }
    const r = this._completionModel.items.length, a = r === 0;
    if (this._ctxSuggestWidgetMultipleSuggestions.set(r > 1), a) {
      this._setState(
        n ? 0 : 2
        /* State.Empty */
      ), this._completionModel = void 0;
      return;
    }
    this._focusedItem = void 0, this._onDidFocus.pause(), this._onDidSelect.pause();
    try {
      this._list.splice(0, this._list.length, this._completionModel.items), this._setState(
        i ? 4 : 3
        /* State.Open */
      ), this._list.reveal(t, 0), this._list.setFocus(o ? [] : [t]);
    } finally {
      this._onDidFocus.resume(), this._onDidSelect.resume();
    }
    this._pendingLayout.value = oC(fe(this.element.domNode), () => {
      this._pendingLayout.clear(), this._layout(this.element.size), this._details.widget.domNode.classList.remove("focused");
    });
  }
  focusSelected() {
    this._list.length > 0 && this._list.setFocus([0]);
  }
  selectNextPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageDown(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNextPage(), !0;
    }
  }
  selectNext() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusNext(1, !0), !0;
    }
  }
  selectLast() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollBottom(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusLast(), !0;
    }
  }
  selectPreviousPage() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.pageUp(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPreviousPage(), !0;
    }
  }
  selectPrevious() {
    switch (this._state) {
      case 0:
        return !1;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusPrevious(1, !0), !1;
    }
  }
  selectFirst() {
    switch (this._state) {
      case 0:
        return !1;
      case 5:
        return this._details.widget.scrollTop(), !0;
      case 1:
        return !this._isAuto;
      default:
        return this._list.focusFirst(), !0;
    }
  }
  getFocusedItem() {
    if (this._state !== 0 && this._state !== 2 && this._state !== 1 && this._completionModel && this._list.getFocus().length > 0)
      return {
        item: this._list.getFocusedElements()[0],
        index: this._list.getFocus()[0],
        model: this._completionModel
      };
  }
  toggleDetailsFocus() {
    this._state === 5 ? (this._setState(
      3
      /* State.Open */
    ), this._details.widget.domNode.classList.remove("focused")) : this._state === 3 && this._isDetailsVisible() && (this._setState(
      5
      /* State.Details */
    ), this._details.widget.domNode.classList.add("focused"));
  }
  toggleDetails() {
    this._isDetailsVisible() ? (this._pendingShowDetails.clear(), this._ctxSuggestWidgetDetailsVisible.set(!1), this._setDetailsVisible(!1), this._details.hide(), this.element.domNode.classList.remove("shows-details")) : (wB(this._list.getFocusedElements()[0]) || this._explainMode) && (this._state === 3 || this._state === 5 || this._state === 4) && (this._ctxSuggestWidgetDetailsVisible.set(!0), this._setDetailsVisible(!0), this.showDetails(!1));
  }
  showDetails(e) {
    this._pendingShowDetails.value = oC(fe(this.element.domNode), () => {
      this._pendingShowDetails.clear(), this._details.show(), e ? this._details.widget.renderLoading() : this._details.widget.renderItem(this._list.getFocusedElements()[0], this._explainMode), this._details.widget.isEmpty ? this._details.hide() : (this._positionDetails(), this.element.domNode.classList.add("shows-details")), this.editor.focus();
    });
  }
  toggleExplainMode() {
    this._list.getFocusedElements()[0] && (this._explainMode = !this._explainMode, this._isDetailsVisible() ? this.showDetails(!1) : this.toggleDetails());
  }
  resetPersistedSize() {
    this._persistedSize.reset();
  }
  hideWidget() {
    this._pendingLayout.clear(), this._pendingShowDetails.clear(), this._loadingTimeout?.dispose(), this._setState(
      0
      /* State.Hidden */
    ), this._onDidHide.fire(this), this.element.clearSashHoverState();
    const e = this._persistedSize.restore(), t = Math.ceil(this.getLayoutInfo().itemHeight * 4.3);
    e && e.height < t && this._persistedSize.store(e.with(void 0, t));
  }
  isFrozen() {
    return this._state === 4;
  }
  _afterRender(e) {
    if (e === null) {
      this._isDetailsVisible() && this._details.hide();
      return;
    }
    this._state === 2 || this._state === 1 || (this._isDetailsVisible() && !this._details.widget.isEmpty && this._details.show(), this._positionDetails());
  }
  _layout(e) {
    if (!this.editor.hasModel() || !this.editor.getDomNode())
      return;
    const t = mu(this.element.domNode.ownerDocument.body), i = this.getLayoutInfo();
    e || (e = i.defaultSize);
    let n = e.height, o = e.width;
    if (this._status.element.style.height = `${i.itemHeight}px`, this._state === 2 || this._state === 1)
      n = i.itemHeight + i.borderHeight, o = i.defaultSize.width / 2, this.element.enableSashes(!1, !1, !1, !1), this.element.minSize = this.element.maxSize = new at(o, n), this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      );
    else {
      const r = t.width - i.borderHeight - 2 * i.horizontalPadding;
      o > r && (o = r);
      const a = this._completionModel ? this._completionModel.stats.pLabelLen * i.typicalHalfwidthCharacterWidth : o, l = i.statusBarHeight + this._list.contentHeight + i.borderHeight, c = i.itemHeight + i.statusBarHeight, d = ui(this.editor.getDomNode()), h = this.editor.getScrolledVisiblePosition(this.editor.getPosition()), u = d.top + h.top + h.height, g = Math.min(t.height - u - i.verticalPadding, l), m = d.top + h.top - i.verticalPadding, p = Math.min(m, l);
      let A = Math.min(Math.max(p, g) + i.borderHeight, l);
      n === this._cappedHeight?.capped && (n = this._cappedHeight.wanted), n < c && (n = c), n > A && (n = A), n > g || this._forceRenderingAbove && m > 150 ? (this._contentWidget.setPreference(
        1
        /* ContentWidgetPositionPreference.ABOVE */
      ), this.element.enableSashes(!0, !0, !1, !1), A = p) : (this._contentWidget.setPreference(
        2
        /* ContentWidgetPositionPreference.BELOW */
      ), this.element.enableSashes(!1, !0, !0, !1), A = g), this.element.preferredSize = new at(a, i.defaultSize.height), this.element.maxSize = new at(r, A), this.element.minSize = new at(220, c), this._cappedHeight = n === l ? { wanted: this._cappedHeight?.wanted ?? e.height, capped: n } : void 0;
    }
    this._resize(o, n);
  }
  _resize(e, t) {
    const { width: i, height: n } = this.element.maxSize;
    e = Math.min(i, e), t = Math.min(n, t);
    const { statusBarHeight: o } = this.getLayoutInfo();
    this._list.layout(t - o, e), this._listElement.style.height = `${t - o}px`, this.element.layout(t, e), this._contentWidget.layout(), this._positionDetails();
  }
  _positionDetails() {
    this._isDetailsVisible() && this._details.placeAtAnchor(
      this.element.domNode,
      this._contentWidget.getPosition()?.preference[0] === 2
      /* ContentWidgetPositionPreference.BELOW */
    );
  }
  getLayoutInfo() {
    const e = this.editor.getOption(
      50
      /* EditorOption.fontInfo */
    ), t = kn(this.editor.getOption(
      121
      /* EditorOption.suggestLineHeight */
    ) || e.lineHeight, 8, 1e3), i = !this.editor.getOption(
      119
      /* EditorOption.suggest */
    ).showStatusBar || this._state === 2 || this._state === 1 ? 0 : t, n = this._details.widget.borderWidth, o = 2 * n;
    return {
      itemHeight: t,
      statusBarHeight: i,
      borderWidth: n,
      borderHeight: o,
      typicalHalfwidthCharacterWidth: e.typicalHalfwidthCharacterWidth,
      verticalPadding: 22,
      horizontalPadding: 14,
      defaultSize: new at(430, i + 12 * t + o)
    };
  }
  _isDetailsVisible() {
    return this._storageService.getBoolean("expandSuggestionDocs", 0, !1);
  }
  _setDetailsVisible(e) {
    this._storageService.store(
      "expandSuggestionDocs",
      e,
      0,
      0
      /* StorageTarget.USER */
    );
  }
  forceRenderingAbove() {
    this._forceRenderingAbove || (this._forceRenderingAbove = !0, this._layout(this._persistedSize.restore()));
  }
  stopForceRenderingAbove() {
    this._forceRenderingAbove = !1;
  }
}, Lg = td, td.LOADING_MESSAGE = f("suggestWidget.loading", "Loading..."), td.NO_SUGGESTIONS_MESSAGE = f("suggestWidget.noSuggestions", "No suggestions."), td);
iM = Lg = Lge([
  nw(1, Jl),
  nw(2, Se),
  nw(3, nn),
  nw(4, ke)
], iM);
class Mge {
  constructor(e, t) {
    this._widget = e, this._editor = t, this.allowEditorOverflow = !0, this.suppressMouseDown = !1, this._preferenceLocked = !1, this._added = !1, this._hidden = !1;
  }
  dispose() {
    this._added && (this._added = !1, this._editor.removeContentWidget(this));
  }
  getId() {
    return "editor.widget.suggestWidget";
  }
  getDomNode() {
    return this._widget.element.domNode;
  }
  show() {
    this._hidden = !1, this._added || (this._added = !0, this._editor.addContentWidget(this));
  }
  hide() {
    this._hidden || (this._hidden = !0, this.layout());
  }
  layout() {
    this._editor.layoutContentWidget(this);
  }
  getPosition() {
    return this._hidden || !this._position || !this._preference ? null : {
      position: this._position,
      preference: [this._preference]
    };
  }
  beforeRender() {
    const { height: e, width: t } = this._widget.element.size, { borderWidth: i, horizontalPadding: n } = this._widget.getLayoutInfo();
    return new at(t + 2 * i + n, e + 2 * i);
  }
  afterRender(e) {
    this._widget._afterRender(e);
  }
  setPreference(e) {
    this._preferenceLocked || (this._preference = e);
  }
  lockPreference() {
    this._preferenceLocked = !0;
  }
  unlockPreference() {
    this._preferenceLocked = !1;
  }
  setPosition(e) {
    this._position = e;
  }
}
var Nge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, _g = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, nM;
class Tge {
  constructor(e, t) {
    if (this._model = e, this._position = t, this._decorationOptions = He.register({
      description: "suggest-line-suffix",
      stickiness: 1
      /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
    }), e.getLineMaxColumn(t.lineNumber) !== t.column) {
      const n = e.getOffsetAt(t), o = e.getPositionAt(n + 1);
      e.changeDecorations((r) => {
        this._marker && r.removeDecoration(this._marker), this._marker = r.addDecoration(E.fromPositions(t, o), this._decorationOptions);
      });
    }
  }
  dispose() {
    this._marker && !this._model.isDisposed() && this._model.changeDecorations((e) => {
      e.removeDecoration(this._marker), this._marker = void 0;
    });
  }
  delta(e) {
    if (this._model.isDisposed() || this._position.lineNumber !== e.lineNumber)
      return 0;
    if (this._marker) {
      const t = this._model.getDecorationRange(this._marker);
      return this._model.getOffsetAt(t.getStartPosition()) - this._model.getOffsetAt(e);
    } else
      return this._model.getLineMaxColumn(e.lineNumber) - e.column;
  }
}
var su;
let Nu = (su = class {
  static get(e) {
    return e.getContribution(nM.ID);
  }
  constructor(e, t, i, n, o, r, a) {
    this._memoryService = t, this._commandService = i, this._contextKeyService = n, this._instantiationService = o, this._logService = r, this._telemetryService = a, this._lineSuffix = new On(), this._toDispose = new X(), this._selectors = new Bge((h) => h.priority), this._onWillInsertSuggestItem = new B(), this.onWillInsertSuggestItem = this._onWillInsertSuggestItem.event, this.editor = e, this.model = o.createInstance(l1, this.editor), this._selectors.register({
      priority: 0,
      select: (h, u, g) => this._memoryService.select(h, u, g)
    });
    const l = Te.InsertMode.bindTo(n);
    l.set(e.getOption(
      119
      /* EditorOption.suggest */
    ).insertMode), this._toDispose.add(this.model.onDidTrigger(() => l.set(e.getOption(
      119
      /* EditorOption.suggest */
    ).insertMode))), this.widget = this._toDispose.add(new ey(fe(e.getDomNode()), () => {
      const h = this._instantiationService.createInstance(iM, this.editor);
      this._toDispose.add(h), this._toDispose.add(h.onDidSelect((A) => this._insertSuggestion(
        A,
        0
        /* InsertFlags.None */
      ), this));
      const u = new fge(this.editor, h, this.model, (A) => this._insertSuggestion(
        A,
        2
        /* InsertFlags.NoAfterUndoStop */
      ));
      this._toDispose.add(u);
      const g = Te.MakesTextEdit.bindTo(this._contextKeyService), m = Te.HasInsertAndReplaceRange.bindTo(this._contextKeyService), p = Te.CanResolve.bindTo(this._contextKeyService);
      return this._toDispose.add(we(() => {
        g.reset(), m.reset(), p.reset();
      })), this._toDispose.add(h.onDidFocus(({ item: A }) => {
        const _ = this.editor.getPosition(), b = A.editStart.column, C = _.column;
        let w = !0;
        this.editor.getOption(
          1
          /* EditorOption.acceptSuggestionOnEnter */
        ) === "smart" && this.model.state === 2 && !A.completion.additionalTextEdits && !(A.completion.insertTextRules & 4) && C - b === A.completion.insertText.length && (w = this.editor.getModel().getValueInRange({
          startLineNumber: _.lineNumber,
          startColumn: b,
          endLineNumber: _.lineNumber,
          endColumn: C
        }) !== A.completion.insertText), g.set(w), m.set(!F.equals(A.editInsertEnd, A.editReplaceEnd)), p.set(!!A.provider.resolveCompletionItem || !!A.completion.documentation || A.completion.detail !== A.completion.label);
      })), this._toDispose.add(h.onDetailsKeyDown((A) => {
        if (A.toKeyCodeChord().equals(new Hl(
          !0,
          !1,
          !1,
          !1,
          33
          /* KeyCode.KeyC */
        )) || ze && A.toKeyCodeChord().equals(new Hl(
          !1,
          !1,
          !1,
          !0,
          33
          /* KeyCode.KeyC */
        ))) {
          A.stopPropagation();
          return;
        }
        A.toKeyCodeChord().isModifierKey() || this.editor.focus();
      })), h;
    })), this._overtypingCapturer = this._toDispose.add(new ey(fe(e.getDomNode()), () => this._toDispose.add(new XI(this.editor, this.model)))), this._alternatives = this._toDispose.add(new ey(fe(e.getDomNode()), () => this._toDispose.add(new hm(this.editor, this._contextKeyService)))), this._toDispose.add(o.createInstance(r1, e)), this._toDispose.add(this.model.onDidTrigger((h) => {
      this.widget.value.showTriggered(h.auto, h.shy ? 250 : 50), this._lineSuffix.value = new Tge(this.editor.getModel(), h.position);
    })), this._toDispose.add(this.model.onDidSuggest((h) => {
      if (h.triggerOptions.shy)
        return;
      let u = -1;
      for (const m of this._selectors.itemsOrderedByPriorityDesc)
        if (u = m.select(this.editor.getModel(), this.editor.getPosition(), h.completionModel.items), u !== -1)
          break;
      if (u === -1 && (u = 0), this.model.state === 0)
        return;
      let g = !1;
      if (h.triggerOptions.auto) {
        const m = this.editor.getOption(
          119
          /* EditorOption.suggest */
        );
        m.selectionMode === "never" || m.selectionMode === "always" ? g = m.selectionMode === "never" : m.selectionMode === "whenTriggerCharacter" ? g = h.triggerOptions.triggerKind !== 1 : m.selectionMode === "whenQuickSuggestion" && (g = h.triggerOptions.triggerKind === 1 && !h.triggerOptions.refilter);
      }
      this.widget.value.showSuggestions(h.completionModel, u, h.isFrozen, h.triggerOptions.auto, g);
    })), this._toDispose.add(this.model.onDidCancel((h) => {
      h.retrigger || this.widget.value.hideWidget();
    })), this._toDispose.add(this.editor.onDidBlurEditorWidget(() => {
      this.model.cancel(), this.model.clear();
    }));
    const c = Te.AcceptSuggestionsOnEnter.bindTo(n), d = () => {
      const h = this.editor.getOption(
        1
        /* EditorOption.acceptSuggestionOnEnter */
      );
      c.set(h === "on" || h === "smart");
    };
    this._toDispose.add(this.editor.onDidChangeConfiguration(() => d())), d();
  }
  dispose() {
    this._alternatives.dispose(), this._toDispose.dispose(), this.widget.dispose(), this.model.dispose(), this._lineSuffix.dispose(), this._onWillInsertSuggestItem.dispose();
  }
  _insertSuggestion(e, t) {
    if (!e || !e.item) {
      this._alternatives.value.reset(), this.model.cancel(), this.model.clear();
      return;
    }
    if (!this.editor.hasModel())
      return;
    const i = ss.get(this.editor);
    if (!i)
      return;
    this._onWillInsertSuggestItem.fire({ item: e.item });
    const n = this.editor.getModel(), o = n.getAlternativeVersionId(), { item: r } = e, a = [], l = new vs();
    t & 1 || this.editor.pushUndoStop();
    const c = this.getOverwriteInfo(r, !!(t & 8));
    this._memoryService.memorize(n, this.editor.getPosition(), r);
    const d = r.isResolved;
    let h = -1, u = -1;
    if (Array.isArray(r.completion.additionalTextEdits)) {
      this.model.cancel();
      const m = gd.capture(this.editor);
      this.editor.executeEdits("suggestController.additionalTextEdits.sync", r.completion.additionalTextEdits.map((p) => {
        let A = E.lift(p.range);
        if (A.startLineNumber === r.position.lineNumber && A.startColumn > r.position.column) {
          const _ = this.editor.getPosition().column - r.position.column, b = _, C = E.spansMultipleLines(A) ? 0 : _;
          A = new E(A.startLineNumber, A.startColumn + b, A.endLineNumber, A.endColumn + C);
        }
        return ms.replaceMove(A, p.text);
      })), m.restoreRelativeVerticalPositionOfCursor(this.editor);
    } else if (!d) {
      const m = new es();
      let p;
      const A = n.onDidChangeContent((w) => {
        if (w.isFlush) {
          l.cancel(), A.dispose();
          return;
        }
        for (const S of w.changes) {
          const x = E.getEndPosition(S.range);
          (!p || F.isBefore(x, p)) && (p = x);
        }
      }), _ = t;
      t |= 2;
      let b = !1;
      const C = this.editor.onWillType(() => {
        C.dispose(), b = !0, _ & 2 || this.editor.pushUndoStop();
      });
      a.push(r.resolve(l.token).then(() => {
        if (!r.completion.additionalTextEdits || l.token.isCancellationRequested)
          return;
        if (p && r.completion.additionalTextEdits.some((S) => F.isBefore(p, E.getStartPosition(S.range))))
          return !1;
        b && this.editor.pushUndoStop();
        const w = gd.capture(this.editor);
        return this.editor.executeEdits("suggestController.additionalTextEdits.async", r.completion.additionalTextEdits.map((S) => ms.replaceMove(E.lift(S.range), S.text))), w.restoreRelativeVerticalPositionOfCursor(this.editor), (b || !(_ & 2)) && this.editor.pushUndoStop(), !0;
      }).then((w) => {
        this._logService.trace("[suggest] async resolving of edits DONE (ms, applied?)", m.elapsed(), w), u = w === !0 ? 1 : w === !1 ? 0 : -2;
      }).finally(() => {
        A.dispose(), C.dispose();
      }));
    }
    let { insertText: g } = r.completion;
    if (r.completion.insertTextRules & 4 || (g = i1.escape(g)), this.model.cancel(), i.insert(g, {
      overwriteBefore: c.overwriteBefore,
      overwriteAfter: c.overwriteAfter,
      undoStopBefore: !1,
      undoStopAfter: !1,
      adjustWhitespace: !(r.completion.insertTextRules & 1),
      clipboardText: e.model.clipboardText,
      overtypingCapturer: this._overtypingCapturer.value
    }), t & 2 || this.editor.pushUndoStop(), r.completion.command)
      if (r.completion.command.id === c1.id)
        this.model.trigger({ auto: !0, retrigger: !0 });
      else {
        const m = new es();
        a.push(this._commandService.executeCommand(r.completion.command.id, ...r.completion.command.arguments ? [...r.completion.command.arguments] : []).catch((p) => {
          r.completion.extensionId ? xs(p) : Pe(p);
        }).finally(() => {
          h = m.elapsed();
        }));
      }
    t & 4 && this._alternatives.value.set(e, (m) => {
      for (l.cancel(); n.canUndo(); ) {
        o !== n.getAlternativeVersionId() && n.undo(), this._insertSuggestion(m, 3 | (t & 8 ? 8 : 0));
        break;
      }
    }), this._alertCompletionItem(r), Promise.all(a).finally(() => {
      this._reportSuggestionAcceptedTelemetry(r, n, d, h, u, e.index, e.model.items), this.model.clear(), l.dispose();
    });
  }
  _reportSuggestionAcceptedTelemetry(e, t, i, n, o, r, a) {
    if (Math.floor(Math.random() * 100) === 0)
      return;
    const l = /* @__PURE__ */ new Map();
    for (let u = 0; u < Math.min(30, a.length); u++) {
      const g = a[u].textLabel;
      l.has(g) ? l.get(g).push(u) : l.set(g, [u]);
    }
    const c = l.get(e.textLabel), h = c && c.length > 1 ? c[0] : -1;
    this._telemetryService.publicLog2("suggest.acceptedSuggestion", {
      extensionId: e.extensionId?.value ?? "unknown",
      providerId: e.provider._debugDisplayName ?? "unknown",
      kind: e.completion.kind,
      basenameHash: C0(Xo(t.uri)).toString(16),
      languageId: t.getLanguageId(),
      fileExtension: pJ(t.uri),
      resolveInfo: e.provider.resolveCompletionItem ? i ? 1 : 0 : -1,
      resolveDuration: e.resolveDuration,
      commandDuration: n,
      additionalEditsAsync: o,
      index: r,
      firstIndex: h
    });
  }
  getOverwriteInfo(e, t) {
    jt(this.editor.hasModel());
    let i = this.editor.getOption(
      119
      /* EditorOption.suggest */
    ).insertMode === "replace";
    t && (i = !i);
    const n = e.position.column - e.editStart.column, o = (i ? e.editReplaceEnd.column : e.editInsertEnd.column) - e.position.column, r = this.editor.getPosition().column - e.position.column, a = this._lineSuffix.value ? this._lineSuffix.value.delta(this.editor.getPosition()) : 0;
    return {
      overwriteBefore: n + r,
      overwriteAfter: o + a
    };
  }
  _alertCompletionItem(e) {
    if (Ys(e.completion.additionalTextEdits)) {
      const t = f("aria.alert.snippet", "Accepting '{0}' made {1} additional edits", e.textLabel, e.completion.additionalTextEdits.length);
      Ia(t);
    }
  }
  triggerSuggest(e, t, i) {
    this.editor.hasModel() && (this.model.trigger({
      auto: t ?? !1,
      completionOptions: { providerFilter: e, kindFilter: i ? /* @__PURE__ */ new Set() : void 0 }
    }), this.editor.revealPosition(
      this.editor.getPosition(),
      0
      /* ScrollType.Smooth */
    ), this.editor.focus());
  }
  triggerSuggestAndAcceptBest(e) {
    if (!this.editor.hasModel())
      return;
    const t = this.editor.getPosition(), i = () => {
      t.equals(this.editor.getPosition()) && this._commandService.executeCommand(e.fallback);
    }, n = (o) => {
      if (o.completion.insertTextRules & 4 || o.completion.additionalTextEdits)
        return !0;
      const r = this.editor.getPosition(), a = o.editStart.column, l = r.column;
      return l - a !== o.completion.insertText.length ? !0 : this.editor.getModel().getValueInRange({
        startLineNumber: r.lineNumber,
        startColumn: a,
        endLineNumber: r.lineNumber,
        endColumn: l
      }) !== o.completion.insertText;
    };
    te.once(this.model.onDidTrigger)((o) => {
      const r = [];
      te.any(this.model.onDidTrigger, this.model.onDidCancel)(() => {
        Ct(r), i();
      }, void 0, r), this.model.onDidSuggest(({ completionModel: a }) => {
        if (Ct(r), a.items.length === 0) {
          i();
          return;
        }
        const l = this._memoryService.select(this.editor.getModel(), this.editor.getPosition(), a.items), c = a.items[l];
        if (!n(c)) {
          i();
          return;
        }
        this.editor.pushUndoStop(), this._insertSuggestion(
          { index: l, item: c, model: a },
          7
          /* InsertFlags.NoAfterUndoStop */
        );
      }, void 0, r);
    }), this.model.trigger({ auto: !1, shy: !0 }), this.editor.revealPosition(
      t,
      0
      /* ScrollType.Smooth */
    ), this.editor.focus();
  }
  acceptSelectedSuggestion(e, t) {
    const i = this.widget.value.getFocusedItem();
    let n = 0;
    e && (n |= 4), t && (n |= 8), this._insertSuggestion(i, n);
  }
  acceptNextSuggestion() {
    this._alternatives.value.next();
  }
  acceptPrevSuggestion() {
    this._alternatives.value.prev();
  }
  cancelSuggestWidget() {
    this.model.cancel(), this.model.clear(), this.widget.value.hideWidget();
  }
  focusSuggestion() {
    this.widget.value.focusSelected();
  }
  selectNextSuggestion() {
    this.widget.value.selectNext();
  }
  selectNextPageSuggestion() {
    this.widget.value.selectNextPage();
  }
  selectLastSuggestion() {
    this.widget.value.selectLast();
  }
  selectPrevSuggestion() {
    this.widget.value.selectPrevious();
  }
  selectPrevPageSuggestion() {
    this.widget.value.selectPreviousPage();
  }
  selectFirstSuggestion() {
    this.widget.value.selectFirst();
  }
  toggleSuggestionDetails() {
    this.widget.value.toggleDetails();
  }
  toggleExplainMode() {
    this.widget.value.toggleExplainMode();
  }
  toggleSuggestionFocus() {
    this.widget.value.toggleDetailsFocus();
  }
  resetWidgetSize() {
    this.widget.value.resetPersistedSize();
  }
  forceRenderingAbove() {
    this.widget.value.forceRenderingAbove();
  }
  stopForceRenderingAbove() {
    this.widget.isInitialized && this.widget.value.stopForceRenderingAbove();
  }
  registerSelector(e) {
    return this._selectors.register(e);
  }
}, nM = su, su.ID = "editor.contrib.suggestController", su);
Nu = nM = Nge([
  _g(1, FS),
  _g(2, bi),
  _g(3, Se),
  _g(4, ke),
  _g(5, Es),
  _g(6, eo)
], Nu);
class Bge {
  constructor(e) {
    this.prioritySelector = e, this._items = new Array();
  }
  register(e) {
    if (this._items.indexOf(e) !== -1)
      throw new Error("Value is already registered");
    return this._items.push(e), this._items.sort((t, i) => this.prioritySelector(i) - this.prioritySelector(t)), {
      dispose: () => {
        const t = this._items.indexOf(e);
        t >= 0 && this._items.splice(t, 1);
      }
    };
  }
  get itemsOrderedByPriorityDesc() {
    return this._items;
  }
}
const d0 = class d0 extends Vt {
  constructor() {
    super({
      id: d0.id,
      label: f("suggest.trigger.label", "Trigger Suggest"),
      alias: "Trigger Suggest",
      precondition: ne.and(R.writable, R.hasCompletionItemProvider, Te.Visible.toNegated()),
      kbOpts: {
        kbExpr: R.textInputFocus,
        primary: 2058,
        secondary: [
          2087
          /* KeyCode.KeyI */
        ],
        mac: { primary: 266, secondary: [
          521,
          2087
          /* KeyCode.KeyI */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t, i) {
    const n = Nu.get(t);
    if (!n)
      return;
    let o;
    i && typeof i == "object" && i.auto === !0 && (o = !0), n.triggerSuggest(void 0, o, void 0);
  }
};
d0.id = "editor.action.triggerSuggest";
let c1 = d0;
rs(
  Nu.ID,
  Nu,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Ge(c1);
const Xs = 190, Qn = Wn.bindToContribution(Nu.get);
re(new Qn({
  id: "acceptSelectedSuggestion",
  precondition: ne.and(Te.Visible, Te.HasFocusedSuggestion),
  handler(s) {
    s.acceptSelectedSuggestion(!0, !1);
  },
  kbOpts: [{
    // normal tab
    primary: 2,
    kbExpr: ne.and(Te.Visible, R.textInputFocus),
    weight: Xs
  }, {
    // accept on enter has special rules
    primary: 3,
    kbExpr: ne.and(Te.Visible, R.textInputFocus, Te.AcceptSuggestionsOnEnter, Te.MakesTextEdit),
    weight: Xs
  }],
  menuOpts: [{
    menuId: Uc,
    title: f("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: Te.HasInsertAndReplaceRange.toNegated()
  }, {
    menuId: Uc,
    title: f("accept.insert", "Insert"),
    group: "left",
    order: 1,
    when: ne.and(Te.HasInsertAndReplaceRange, Te.InsertMode.isEqualTo("insert"))
  }, {
    menuId: Uc,
    title: f("accept.replace", "Replace"),
    group: "left",
    order: 1,
    when: ne.and(Te.HasInsertAndReplaceRange, Te.InsertMode.isEqualTo("replace"))
  }]
}));
re(new Qn({
  id: "acceptAlternativeSelectedSuggestion",
  precondition: ne.and(Te.Visible, R.textInputFocus, Te.HasFocusedSuggestion),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 1027,
    secondary: [
      1026
      /* KeyCode.Tab */
    ]
  },
  handler(s) {
    s.acceptSelectedSuggestion(!1, !0);
  },
  menuOpts: [{
    menuId: Uc,
    group: "left",
    order: 2,
    when: ne.and(Te.HasInsertAndReplaceRange, Te.InsertMode.isEqualTo("insert")),
    title: f("accept.replace", "Replace")
  }, {
    menuId: Uc,
    group: "left",
    order: 2,
    when: ne.and(Te.HasInsertAndReplaceRange, Te.InsertMode.isEqualTo("replace")),
    title: f("accept.insert", "Insert")
  }]
}));
mt.registerCommandAlias("acceptSelectedSuggestionOnEnter", "acceptSelectedSuggestion");
re(new Qn({
  id: "hideSuggestWidget",
  precondition: Te.Visible,
  handler: (s) => s.cancelSuggestWidget(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
re(new Qn({
  id: "selectNextSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectNextSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 18,
    secondary: [
      2066
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      2066,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
re(new Qn({
  id: "selectNextPageSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectNextPageSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 12,
    secondary: [
      2060
      /* KeyCode.PageDown */
    ]
  }
}));
re(new Qn({
  id: "selectLastSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectLastSuggestion()
}));
re(new Qn({
  id: "selectPrevSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectPrevSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 16,
    secondary: [
      2064
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      2064,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
re(new Qn({
  id: "selectPrevPageSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectPrevPageSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 11,
    secondary: [
      2059
      /* KeyCode.PageUp */
    ]
  }
}));
re(new Qn({
  id: "selectFirstSuggestion",
  precondition: ne.and(Te.Visible, ne.or(Te.MultipleSuggestions, Te.HasFocusedSuggestion.negate())),
  handler: (s) => s.selectFirstSuggestion()
}));
re(new Qn({
  id: "focusSuggestion",
  precondition: ne.and(Te.Visible, Te.HasFocusedSuggestion.negate()),
  handler: (s) => s.focusSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  }
}));
re(new Qn({
  id: "focusAndAcceptSuggestion",
  precondition: ne.and(Te.Visible, Te.HasFocusedSuggestion.negate()),
  handler: (s) => {
    s.focusSuggestion(), s.acceptSelectedSuggestion(!0, !1);
  }
}));
re(new Qn({
  id: "toggleSuggestionDetails",
  precondition: ne.and(Te.Visible, Te.HasFocusedSuggestion),
  handler: (s) => s.toggleSuggestionDetails(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 2058,
    secondary: [
      2087
      /* KeyCode.KeyI */
    ],
    mac: { primary: 266, secondary: [
      2087
      /* KeyCode.KeyI */
    ] }
  },
  menuOpts: [{
    menuId: Uc,
    group: "right",
    order: 1,
    when: ne.and(Te.DetailsVisible, Te.CanResolve),
    title: f("detail.more", "Show Less")
  }, {
    menuId: Uc,
    group: "right",
    order: 1,
    when: ne.and(Te.DetailsVisible.toNegated(), Te.CanResolve),
    title: f("detail.less", "Show More")
  }]
}));
re(new Qn({
  id: "toggleExplainMode",
  precondition: Te.Visible,
  handler: (s) => s.toggleExplainMode(),
  kbOpts: {
    weight: 100,
    primary: 2138
  }
}));
re(new Qn({
  id: "toggleSuggestionFocus",
  precondition: Te.Visible,
  handler: (s) => s.toggleSuggestionFocus(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 2570,
    mac: {
      primary: 778
      /* KeyCode.Space */
    }
  }
}));
re(new Qn({
  id: "insertBestCompletion",
  precondition: ne.and(R.textInputFocus, ne.equals("config.editor.tabCompletion", "on"), r1.AtEnd, Te.Visible.toNegated(), hm.OtherSuggestions.toNegated(), ss.InSnippetMode.toNegated()),
  handler: (s, e) => {
    s.triggerSuggestAndAcceptBest(Ti(e) ? { fallback: "tab", ...e } : { fallback: "tab" });
  },
  kbOpts: {
    weight: Xs,
    primary: 2
    /* KeyCode.Tab */
  }
}));
re(new Qn({
  id: "insertNextSuggestion",
  precondition: ne.and(R.textInputFocus, ne.equals("config.editor.tabCompletion", "on"), hm.OtherSuggestions, Te.Visible.toNegated(), ss.InSnippetMode.toNegated()),
  handler: (s) => s.acceptNextSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 2
    /* KeyCode.Tab */
  }
}));
re(new Qn({
  id: "insertPrevSuggestion",
  precondition: ne.and(R.textInputFocus, ne.equals("config.editor.tabCompletion", "on"), hm.OtherSuggestions, Te.Visible.toNegated(), ss.InSnippetMode.toNegated()),
  handler: (s) => s.acceptPrevSuggestion(),
  kbOpts: {
    weight: Xs,
    kbExpr: R.textInputFocus,
    primary: 1026
    /* KeyCode.Tab */
  }
}));
Ge(class extends Vt {
  constructor() {
    super({
      id: "editor.action.resetSuggestSize",
      label: f("suggest.reset.label", "Reset Suggest Widget Size"),
      alias: "Reset Suggest Widget Size",
      precondition: void 0
    });
  }
  run(s, e) {
    Nu.get(e)?.resetWidgetSize();
  }
});
var t9 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Lp = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
};
class Rge {
  constructor(e, t, i, n, o, r) {
    this.range = e, this.insertText = t, this.filterText = i, this.additionalTextEdits = n, this.command = o, this.completion = r;
  }
}
let sM = class extends Hz {
  constructor(e, t, i, n, o, r) {
    super(o.disposable), this.model = e, this.line = t, this.word = i, this.completionModel = n, this._suggestMemoryService = r;
  }
  canBeReused(e, t, i) {
    return this.model === e && this.line === t && this.word.word.length > 0 && this.word.startColumn === i.startColumn && this.word.endColumn < i.endColumn && this.completionModel.getIncompleteProvider().size === 0;
  }
  get items() {
    const e = [], { items: t } = this.completionModel, i = this._suggestMemoryService.select(this.model, { lineNumber: this.line, column: this.word.endColumn + this.completionModel.lineContext.characterCountDelta }, t), n = nt.slice(t, i), o = nt.slice(t, 0, i);
    let r = 5;
    for (const a of nt.concat(n, o)) {
      if (a.score === Tr.Default)
        continue;
      const l = new E(
        a.editStart.lineNumber,
        a.editStart.column,
        a.editInsertEnd.lineNumber,
        a.editInsertEnd.column + this.completionModel.lineContext.characterCountDelta
        // end PLUS character delta
      ), c = a.completion.insertTextRules && a.completion.insertTextRules & 4 ? { snippet: a.completion.insertText } : a.completion.insertText;
      e.push(new Rge(l, c, a.filterTextLow ?? a.labelLow, a.completion.additionalTextEdits, a.completion.command, a)), r-- >= 0 && a.resolve(ct.None);
    }
    return e;
  }
};
sM = t9([
  Lp(5, FS)
], sM);
let oM = class extends V {
  constructor(e, t, i, n) {
    super(), this._languageFeatureService = e, this._clipboardService = t, this._suggestMemoryService = i, this._editorService = n, this._store.add(e.inlineCompletionsProvider.register("*", this));
  }
  async provideInlineCompletions(e, t, i, n) {
    if (i.selectedSuggestionInfo)
      return;
    let o;
    for (const g of this._editorService.listCodeEditors())
      if (g.getModel() === e) {
        o = g;
        break;
      }
    if (!o)
      return;
    const r = o.getOption(
      90
      /* EditorOption.quickSuggestions */
    );
    if (Jg.isAllOff(r))
      return;
    e.tokenization.tokenizeIfCheap(t.lineNumber);
    const a = e.tokenization.getLineTokens(t.lineNumber), l = a.getStandardTokenType(a.findTokenIndexAtOffset(Math.max(t.column - 1 - 1, 0)));
    if (Jg.valueFor(r, l) !== "inline")
      return;
    let c = e.getWordAtPosition(t), d;
    if (c?.word || (d = this._getTriggerCharacterInfo(e, t)), !c?.word && !d || (c || (c = e.getWordUntilPosition(t)), c.endColumn !== t.column))
      return;
    let h;
    const u = e.getValueInRange(new E(t.lineNumber, 1, t.lineNumber, t.column));
    if (!d && this._lastResult?.canBeReused(e, t.lineNumber, c)) {
      const g = new _4(u, t.column - this._lastResult.word.endColumn);
      this._lastResult.completionModel.lineContext = g, this._lastResult.acquire(), h = this._lastResult;
    } else {
      const g = await AB(this._languageFeatureService.completionProvider, e, t, new y_(void 0, l1.createSuggestFilter(o).itemKind, d?.providers), d && { triggerKind: 1, triggerCharacter: d.ch }, n);
      let m;
      g.needsClipboard && (m = await this._clipboardService.readText());
      const p = new yc(g.items, t.column, new _4(u, 0), a1.None, o.getOption(
        119
        /* EditorOption.suggest */
      ), o.getOption(
        113
        /* EditorOption.snippetSuggestions */
      ), { boostFullMatch: !1, firstMatchCanBeWeak: !1 }, m);
      h = new sM(e, t.lineNumber, c, p, g, this._suggestMemoryService);
    }
    return this._lastResult = h, h;
  }
  handleItemDidShow(e, t) {
    t.completion.resolve(ct.None);
  }
  freeInlineCompletions(e) {
    e.release();
  }
  _getTriggerCharacterInfo(e, t) {
    const i = e.getValueInRange(E.fromPositions({ lineNumber: t.lineNumber, column: t.column - 1 }, t)), n = /* @__PURE__ */ new Set();
    for (const o of this._languageFeatureService.completionProvider.all(e))
      o.triggerCharacters?.includes(i) && n.add(o);
    if (n.size !== 0)
      return { providers: n, ch: i };
  }
};
oM = t9([
  Lp(0, ye),
  Lp(1, Yu),
  Lp(2, FS),
  Lp(3, Nt)
], oM);
p8(oM);
const Tu = {
  Visible: new le("parameterHintsVisible", !1),
  MultipleSignatures: new le("parameterHintsMultipleSignatures", !1)
};
async function i9(s, e, t, i, n) {
  const o = s.ordered(e);
  for (const r of o)
    try {
      const a = await r.provideSignatureHelp(e, t, n, i);
      if (a)
        return a;
    } catch (a) {
      xs(a);
    }
}
mt.registerCommand("_executeSignatureHelpProvider", async (s, ...e) => {
  const [t, i, n] = e;
  jt(_e.isUri(t)), jt(F.isIPosition(i)), jt(typeof n == "string" || !n);
  const o = s.get(ye), r = await s.get(Zs).createModelReference(t);
  try {
    const a = await i9(o.signatureHelpProvider, r.object.textEditorModel, F.lift(i), {
      triggerKind: wa.Invoke,
      isRetrigger: !1,
      triggerCharacter: n
    }, ct.None);
    return a ? (setTimeout(() => a.dispose(), 0), a.value) : void 0;
  } finally {
    r.dispose();
  }
});
var gc;
(function(s) {
  s.Default = {
    type: 0
    /* Type.Default */
  };
  class e {
    constructor(n, o) {
      this.request = n, this.previouslyActiveHints = o, this.type = 2;
    }
  }
  s.Pending = e;
  class t {
    constructor(n) {
      this.hints = n, this.type = 1;
    }
  }
  s.Active = t;
})(gc || (gc = {}));
const h0 = class h0 extends V {
  // ms
  constructor(e, t, i = h0.DEFAULT_DELAY) {
    super(), this._onChangedHints = this._register(new B()), this.onChangedHints = this._onChangedHints.event, this.triggerOnType = !1, this._state = gc.Default, this._pendingTriggers = [], this._lastSignatureHelpResult = this._register(new On()), this.triggerChars = new tL(), this.retriggerChars = new tL(), this.triggerId = 0, this.editor = e, this.providers = t, this.throttledDelayer = new Gl(i), this._register(this.editor.onDidBlurEditorWidget(() => this.cancel())), this._register(this.editor.onDidChangeConfiguration(() => this.onEditorConfigurationChange())), this._register(this.editor.onDidChangeModel((n) => this.onModelChanged())), this._register(this.editor.onDidChangeModelLanguage((n) => this.onModelChanged())), this._register(this.editor.onDidChangeCursorSelection((n) => this.onCursorChange(n))), this._register(this.editor.onDidChangeModelContent((n) => this.onModelContentChange())), this._register(this.providers.onDidChange(this.onModelChanged, this)), this._register(this.editor.onDidType((n) => this.onDidType(n))), this.onEditorConfigurationChange(), this.onModelChanged();
  }
  get state() {
    return this._state;
  }
  set state(e) {
    this._state.type === 2 && this._state.request.cancel(), this._state = e;
  }
  cancel(e = !1) {
    this.state = gc.Default, this.throttledDelayer.cancel(), e || this._onChangedHints.fire(void 0);
  }
  trigger(e, t) {
    const i = this.editor.getModel();
    if (!i || !this.providers.has(i))
      return;
    const n = ++this.triggerId;
    this._pendingTriggers.push(e), this.throttledDelayer.trigger(() => this.doTrigger(n), t).catch(Pe);
  }
  next() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t % e === e - 1, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? 0 : t + 1);
  }
  previous() {
    if (this.state.type !== 1)
      return;
    const e = this.state.hints.signatures.length, t = this.state.hints.activeSignature, i = t === 0, n = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).cycle;
    if ((e < 2 || i) && !n) {
      this.cancel();
      return;
    }
    this.updateActiveSignature(i && n ? e - 1 : t - 1);
  }
  updateActiveSignature(e) {
    this.state.type === 1 && (this.state = new gc.Active({ ...this.state.hints, activeSignature: e }), this._onChangedHints.fire(this.state.hints));
  }
  async doTrigger(e) {
    const t = this.state.type === 1 || this.state.type === 2, i = this.getLastActiveHints();
    if (this.cancel(!0), this._pendingTriggers.length === 0)
      return !1;
    const n = this._pendingTriggers.reduce(Fge);
    this._pendingTriggers = [];
    const o = {
      triggerKind: n.triggerKind,
      triggerCharacter: n.triggerCharacter,
      isRetrigger: t,
      activeSignatureHelp: i
    };
    if (!this.editor.hasModel())
      return !1;
    const r = this.editor.getModel(), a = this.editor.getPosition();
    this.state = new gc.Pending(ir((l) => i9(this.providers, r, a, o, l)), i);
    try {
      const l = await this.state.request;
      return e !== this.triggerId ? (l?.dispose(), !1) : !l || !l.value.signatures || l.value.signatures.length === 0 ? (l?.dispose(), this._lastSignatureHelpResult.clear(), this.cancel(), !1) : (this.state = new gc.Active(l.value), this._lastSignatureHelpResult.value = l, this._onChangedHints.fire(this.state.hints), !0);
    } catch (l) {
      return e === this.triggerId && (this.state = gc.Default), Pe(l), !1;
    }
  }
  getLastActiveHints() {
    switch (this.state.type) {
      case 1:
        return this.state.hints;
      case 2:
        return this.state.previouslyActiveHints;
      default:
        return;
    }
  }
  get isTriggered() {
    return this.state.type === 1 || this.state.type === 2 || this.throttledDelayer.isTriggered();
  }
  onModelChanged() {
    this.cancel(), this.triggerChars.clear(), this.retriggerChars.clear();
    const e = this.editor.getModel();
    if (e)
      for (const t of this.providers.ordered(e)) {
        for (const i of t.signatureHelpTriggerCharacters || [])
          if (i.length) {
            const n = i.charCodeAt(0);
            this.triggerChars.add(n), this.retriggerChars.add(n);
          }
        for (const i of t.signatureHelpRetriggerCharacters || [])
          i.length && this.retriggerChars.add(i.charCodeAt(0));
      }
  }
  onDidType(e) {
    if (!this.triggerOnType)
      return;
    const t = e.length - 1, i = e.charCodeAt(t);
    (this.triggerChars.has(i) || this.isTriggered && this.retriggerChars.has(i)) && this.trigger({
      triggerKind: wa.TriggerCharacter,
      triggerCharacter: e.charAt(t)
    });
  }
  onCursorChange(e) {
    e.source === "mouse" ? this.cancel() : this.isTriggered && this.trigger({ triggerKind: wa.ContentChange });
  }
  onModelContentChange() {
    this.isTriggered && this.trigger({ triggerKind: wa.ContentChange });
  }
  onEditorConfigurationChange() {
    this.triggerOnType = this.editor.getOption(
      86
      /* EditorOption.parameterHints */
    ).enabled, this.triggerOnType || this.cancel();
  }
  dispose() {
    this.cancel(!0), super.dispose();
  }
};
h0.DEFAULT_DELAY = 120;
let rM = h0;
function Fge(s, e) {
  switch (e.triggerKind) {
    case wa.Invoke:
      return e;
    case wa.ContentChange:
      return s;
    case wa.TriggerCharacter:
    default:
      return e;
  }
}
var Oge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, sw = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, aM;
const Ns = de, Pge = Rt("parameter-hints-next", Z.chevronDown, f("parameterHintsNextIcon", "Icon for show next parameter hint.")), Hge = Rt("parameter-hints-previous", Z.chevronUp, f("parameterHintsPreviousIcon", "Icon for show previous parameter hint."));
var ou;
let lM = (ou = class extends V {
  constructor(e, t, i, n, o, r) {
    super(), this.editor = e, this.model = t, this.telemetryService = r, this.renderDisposeables = this._register(new X()), this.visible = !1, this.announcedLabel = null, this.allowEditorOverflow = !0, this.markdownRenderer = this._register(new Cu({ editor: e }, o, n)), this.keyVisible = Tu.Visible.bindTo(i), this.keyMultipleSignatures = Tu.MultipleSignatures.bindTo(i);
  }
  createParameterHintDOMNodes() {
    const e = Ns(".editor-widget.parameter-hints-widget"), t = K(e, Ns(".phwrapper"));
    t.tabIndex = -1;
    const i = K(t, Ns(".controls")), n = K(i, Ns(".button" + pe.asCSSSelector(Hge))), o = K(i, Ns(".overloads")), r = K(i, Ns(".button" + pe.asCSSSelector(Pge)));
    this._register(U(n, "click", (u) => {
      Ve.stop(u), this.previous();
    })), this._register(U(r, "click", (u) => {
      Ve.stop(u), this.next();
    }));
    const a = Ns(".body"), l = new F_(a, {
      alwaysConsumeMouseWheel: !0
    });
    this._register(l), t.appendChild(l.getDomNode());
    const c = K(a, Ns(".signature")), d = K(a, Ns(".docs"));
    e.style.userSelect = "text", this.domNodes = {
      element: e,
      signature: c,
      overloads: o,
      docs: d,
      scrollbar: l
    }, this.editor.addContentWidget(this), this.hide(), this._register(this.editor.onDidChangeCursorSelection((u) => {
      this.visible && this.editor.layoutContentWidget(this);
    }));
    const h = () => {
      if (!this.domNodes)
        return;
      const u = this.editor.getOption(
        50
        /* EditorOption.fontInfo */
      ), g = this.domNodes.element;
      g.style.fontSize = `${u.fontSize}px`, g.style.lineHeight = `${u.lineHeight / u.fontSize}`, g.style.setProperty("--vscode-parameterHintsWidget-editorFontFamily", u.fontFamily), g.style.setProperty("--vscode-parameterHintsWidget-editorFontFamilyDefault", Zn.fontFamily);
    };
    h(), this._register(te.chain(this.editor.onDidChangeConfiguration.bind(this.editor), (u) => u.filter((g) => g.hasChanged(
      50
      /* EditorOption.fontInfo */
    )))(h)), this._register(this.editor.onDidLayoutChange((u) => this.updateMaxHeight())), this.updateMaxHeight();
  }
  show() {
    this.visible || (this.domNodes || this.createParameterHintDOMNodes(), this.keyVisible.set(!0), this.visible = !0, setTimeout(() => {
      this.domNodes?.element.classList.add("visible");
    }, 100), this.editor.layoutContentWidget(this));
  }
  hide() {
    this.renderDisposeables.clear(), this.visible && (this.keyVisible.reset(), this.visible = !1, this.announcedLabel = null, this.domNodes?.element.classList.remove("visible"), this.editor.layoutContentWidget(this));
  }
  getPosition() {
    return this.visible ? {
      position: this.editor.getPosition(),
      preference: [
        1,
        2
        /* ContentWidgetPositionPreference.BELOW */
      ]
    } : null;
  }
  render(e) {
    if (this.renderDisposeables.clear(), !this.domNodes)
      return;
    const t = e.signatures.length > 1;
    this.domNodes.element.classList.toggle("multiple", t), this.keyMultipleSignatures.set(t), this.domNodes.signature.innerText = "", this.domNodes.docs.innerText = "";
    const i = e.signatures[e.activeSignature];
    if (!i)
      return;
    const n = K(this.domNodes.signature, Ns(".code")), o = i.parameters.length > 0, r = i.activeParameter ?? e.activeParameter;
    if (o)
      this.renderParameters(n, i, r);
    else {
      const c = K(n, Ns("span"));
      c.textContent = i.label;
    }
    const a = i.parameters[r];
    if (a?.documentation) {
      const c = Ns("span.documentation");
      if (typeof a.documentation == "string")
        c.textContent = a.documentation;
      else {
        const d = this.renderMarkdownDocs(a.documentation);
        c.appendChild(d.element);
      }
      K(this.domNodes.docs, Ns("p", {}, c));
    }
    if (i.documentation !== void 0) if (typeof i.documentation == "string")
      K(this.domNodes.docs, Ns("p", {}, i.documentation));
    else {
      const c = this.renderMarkdownDocs(i.documentation);
      K(this.domNodes.docs, c.element);
    }
    const l = this.hasDocs(i, a);
    if (this.domNodes.signature.classList.toggle("has-docs", l), this.domNodes.docs.classList.toggle("empty", !l), this.domNodes.overloads.textContent = String(e.activeSignature + 1).padStart(e.signatures.length.toString().length, "0") + "/" + e.signatures.length, a) {
      let c = "";
      const d = i.parameters[r];
      Array.isArray(d.label) ? c = i.label.substring(d.label[0], d.label[1]) : c = d.label, d.documentation && (c += typeof d.documentation == "string" ? `, ${d.documentation}` : `, ${d.documentation.value}`), i.documentation && (c += typeof i.documentation == "string" ? `, ${i.documentation}` : `, ${i.documentation.value}`), this.announcedLabel !== c && (Ia(f("hint", "{0}, hint", c)), this.announcedLabel = c);
    }
    this.editor.layoutContentWidget(this), this.domNodes.scrollbar.scanDomNode();
  }
  renderMarkdownDocs(e) {
    const t = new es(), i = this.renderDisposeables.add(this.markdownRenderer.render(e, {
      asyncRenderCallback: () => {
        this.domNodes?.scrollbar.scanDomNode();
      }
    }));
    i.element.classList.add("markdown-docs");
    const n = t.elapsed();
    return n > 300 && this.telemetryService.publicLog2("parameterHints.parseMarkdown", {
      renderDuration: n
    }), i;
  }
  hasDocs(e, t) {
    return !!(t && typeof t.documentation == "string" && xc(t.documentation).length > 0 || t && typeof t.documentation == "object" && xc(t.documentation).value.length > 0 || e.documentation && typeof e.documentation == "string" && xc(e.documentation).length > 0 || e.documentation && typeof e.documentation == "object" && xc(e.documentation.value).length > 0);
  }
  renderParameters(e, t, i) {
    const [n, o] = this.getParameterLabelOffsets(t, i), r = document.createElement("span");
    r.textContent = t.label.substring(0, n);
    const a = document.createElement("span");
    a.textContent = t.label.substring(n, o), a.className = "parameter active";
    const l = document.createElement("span");
    l.textContent = t.label.substring(o), K(e, r, a, l);
  }
  getParameterLabelOffsets(e, t) {
    const i = e.parameters[t];
    if (i) {
      if (Array.isArray(i.label))
        return i.label;
      if (i.label.length) {
        const n = new RegExp(`(\\W|^)${So(i.label)}(?=\\W|$)`, "g");
        n.test(e.label);
        const o = n.lastIndex - i.label.length;
        return o >= 0 ? [o, n.lastIndex] : [0, 0];
      } else
        return [0, 0];
    } else return [0, 0];
  }
  next() {
    this.editor.focus(), this.model.next();
  }
  previous() {
    this.editor.focus(), this.model.previous();
  }
  getDomNode() {
    return this.domNodes || this.createParameterHintDOMNodes(), this.domNodes.element;
  }
  getId() {
    return aM.ID;
  }
  updateMaxHeight() {
    if (!this.domNodes)
      return;
    const t = `${Math.max(this.editor.getLayoutInfo().height / 4, 250)}px`;
    this.domNodes.element.style.maxHeight = t;
    const i = this.domNodes.element.getElementsByClassName("phwrapper");
    i.length && (i[0].style.maxHeight = t);
  }
}, aM = ou, ou.ID = "editor.widget.parameterHintsWidget", ou);
lM = aM = Oge([
  sw(2, Se),
  sw(3, lr),
  sw(4, si),
  sw(5, eo)
], lM);
L("editorHoverWidget.highlightForeground", Rg, f("editorHoverWidgetHighlightForeground", "Foreground color of the active item in the parameter hint."));
var Wge = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, b4 = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, cM, ru;
let um = (ru = class extends V {
  static get(e) {
    return e.getContribution(cM.ID);
  }
  constructor(e, t, i) {
    super(), this.editor = e, this.model = this._register(new rM(e, i.signatureHelpProvider)), this._register(this.model.onChangedHints((n) => {
      n ? (this.widget.value.show(), this.widget.value.render(n)) : this.widget.rawValue?.hide();
    })), this.widget = new Br(() => this._register(t.createInstance(lM, this.editor, this.model)));
  }
  cancel() {
    this.model.cancel();
  }
  previous() {
    this.widget.rawValue?.previous();
  }
  next() {
    this.widget.rawValue?.next();
  }
  trigger(e) {
    this.model.trigger(e, 0);
  }
}, cM = ru, ru.ID = "editor.controller.parameterHints", ru);
um = cM = Wge([
  b4(1, ke),
  b4(2, ye)
], um);
class Vge extends Vt {
  constructor() {
    super({
      id: "editor.action.triggerParameterHints",
      label: f("parameterHints.trigger.label", "Trigger Parameter Hints"),
      alias: "Trigger Parameter Hints",
      precondition: R.hasSignatureHelpProvider,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 3082,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    um.get(t)?.trigger({
      triggerKind: wa.Invoke
    });
  }
}
rs(
  um.ID,
  um,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Ge(Vge);
const CB = 175, vB = Wn.bindToContribution(um.get);
re(new vB({
  id: "closeParameterHints",
  precondition: Tu.Visible,
  handler: (s) => s.cancel(),
  kbOpts: {
    weight: CB,
    kbExpr: R.focus,
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
re(new vB({
  id: "showPrevParameterHint",
  precondition: ne.and(Tu.Visible, Tu.MultipleSignatures),
  handler: (s) => s.previous(),
  kbOpts: {
    weight: CB,
    kbExpr: R.focus,
    primary: 16,
    secondary: [
      528
      /* KeyCode.UpArrow */
    ],
    mac: { primary: 16, secondary: [
      528,
      302
      /* KeyCode.KeyP */
    ] }
  }
}));
re(new vB({
  id: "showNextParameterHint",
  precondition: ne.and(Tu.Visible, Tu.MultipleSignatures),
  handler: (s) => s.next(),
  kbOpts: {
    weight: CB,
    kbExpr: R.focus,
    primary: 18,
    secondary: [
      530
      /* KeyCode.DownArrow */
    ],
    mac: { primary: 18, secondary: [
      530,
      300
      /* KeyCode.KeyN */
    ] }
  }
}));
const zge = L("editorOverviewRuler.bracketMatchForeground", "#A0A0A0", f("overviewRulerBracketMatchForeground", "Overview ruler marker color for matching brackets."));
class Uge extends Vt {
  constructor() {
    super({
      id: "editor.action.jumpToBracket",
      label: f("smartSelect.jumpBracket", "Go to Bracket"),
      alias: "Go to Bracket",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 3165,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    Bu.get(t)?.jumpToBracket();
  }
}
class Qge extends Vt {
  constructor() {
    super({
      id: "editor.action.selectToBracket",
      label: f("smartSelect.selectToBracket", "Select to Bracket"),
      alias: "Select to Bracket",
      precondition: void 0,
      metadata: {
        description: ni("smartSelect.selectToBracketDescription", "Select the text inside and including the brackets or curly braces"),
        args: [{
          name: "args",
          schema: {
            type: "object",
            properties: {
              selectBrackets: {
                type: "boolean",
                default: !0
              }
            }
          }
        }]
      }
    });
  }
  run(e, t, i) {
    let n = !0;
    i && i.selectBrackets === !1 && (n = !1), Bu.get(t)?.selectToBracket(n);
  }
}
class Gge extends Vt {
  constructor() {
    super({
      id: "editor.action.removeBrackets",
      label: f("smartSelect.removeBrackets", "Remove Brackets"),
      alias: "Remove Brackets",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 2561,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    Bu.get(t)?.removeBrackets(this.id);
  }
}
class jge {
  constructor(e, t, i) {
    this.position = e, this.brackets = t, this.options = i;
  }
}
const Ac = class Ac extends V {
  static get(e) {
    return e.getContribution(Ac.ID);
  }
  constructor(e) {
    super(), this._editor = e, this._lastBracketsData = [], this._lastVersionId = 0, this._decorations = this._editor.createDecorationsCollection(), this._updateBracketsSoon = this._register(new zt(() => this._updateBrackets(), 50)), this._matchBrackets = this._editor.getOption(
      72
      /* EditorOption.matchBrackets */
    ), this._updateBracketsSoon.schedule(), this._register(e.onDidChangeCursorPosition((t) => {
      this._matchBrackets !== "never" && this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelContent((t) => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModel((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeModelLanguageConfiguration((t) => {
      this._lastBracketsData = [], this._updateBracketsSoon.schedule();
    })), this._register(e.onDidChangeConfiguration((t) => {
      t.hasChanged(
        72
        /* EditorOption.matchBrackets */
      ) && (this._matchBrackets = this._editor.getOption(
        72
        /* EditorOption.matchBrackets */
      ), this._decorations.clear(), this._lastBracketsData = [], this._lastVersionId = 0, this._updateBracketsSoon.schedule());
    })), this._register(e.onDidBlurEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    })), this._register(e.onDidFocusEditorWidget(() => {
      this._updateBracketsSoon.schedule();
    }));
  }
  jumpToBracket() {
    if (!this._editor.hasModel())
      return;
    const e = this._editor.getModel(), t = this._editor.getSelections().map((i) => {
      const n = i.getStartPosition(), o = e.bracketPairs.matchBracket(n);
      let r = null;
      if (o)
        o[0].containsPosition(n) && !o[1].containsPosition(n) ? r = o[1].getStartPosition() : o[1].containsPosition(n) && (r = o[0].getStartPosition());
      else {
        const a = e.bracketPairs.findEnclosingBrackets(n);
        if (a)
          r = a[1].getStartPosition();
        else {
          const l = e.bracketPairs.findNextBracket(n);
          l && l.range && (r = l.range.getStartPosition());
        }
      }
      return r ? new Ue(r.lineNumber, r.column, r.lineNumber, r.column) : new Ue(n.lineNumber, n.column, n.lineNumber, n.column);
    });
    this._editor.setSelections(t), this._editor.revealRange(t[0]);
  }
  selectToBracket(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel(), i = [];
    this._editor.getSelections().forEach((n) => {
      const o = n.getStartPosition();
      let r = t.bracketPairs.matchBracket(o);
      if (!r && (r = t.bracketPairs.findEnclosingBrackets(o), !r)) {
        const c = t.bracketPairs.findNextBracket(o);
        c && c.range && (r = t.bracketPairs.matchBracket(c.range.getStartPosition()));
      }
      let a = null, l = null;
      if (r) {
        r.sort(E.compareRangesUsingStarts);
        const [c, d] = r;
        if (a = e ? c.getStartPosition() : c.getEndPosition(), l = e ? d.getEndPosition() : d.getStartPosition(), d.containsPosition(o)) {
          const h = a;
          a = l, l = h;
        }
      }
      a && l && i.push(new Ue(a.lineNumber, a.column, l.lineNumber, l.column));
    }), i.length > 0 && (this._editor.setSelections(i), this._editor.revealRange(i[0]));
  }
  removeBrackets(e) {
    if (!this._editor.hasModel())
      return;
    const t = this._editor.getModel();
    this._editor.getSelections().forEach((i) => {
      const n = i.getPosition();
      let o = t.bracketPairs.matchBracket(n);
      o || (o = t.bracketPairs.findEnclosingBrackets(n)), o && (this._editor.pushUndoStop(), this._editor.executeEdits(e, [
        { range: o[0], text: "" },
        { range: o[1], text: "" }
      ]), this._editor.pushUndoStop());
    });
  }
  _updateBrackets() {
    if (this._matchBrackets === "never")
      return;
    this._recomputeBrackets();
    const e = [];
    let t = 0;
    for (const i of this._lastBracketsData) {
      const n = i.brackets;
      n && (e[t++] = { range: n[0], options: i.options }, e[t++] = { range: n[1], options: i.options });
    }
    this._decorations.set(e);
  }
  _recomputeBrackets() {
    if (!this._editor.hasModel() || !this._editor.hasWidgetFocus()) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const e = this._editor.getSelections();
    if (e.length > 100) {
      this._lastBracketsData = [], this._lastVersionId = 0;
      return;
    }
    const t = this._editor.getModel(), i = t.getVersionId();
    let n = [];
    this._lastVersionId === i && (n = this._lastBracketsData);
    const o = [];
    let r = 0;
    for (let h = 0, u = e.length; h < u; h++) {
      const g = e[h];
      g.isEmpty() && (o[r++] = g.getStartPosition());
    }
    o.length > 1 && o.sort(F.compare);
    const a = [];
    let l = 0, c = 0;
    const d = n.length;
    for (let h = 0, u = o.length; h < u; h++) {
      const g = o[h];
      for (; c < d && n[c].position.isBefore(g); )
        c++;
      if (c < d && n[c].position.equals(g))
        a[l++] = n[c];
      else {
        let m = t.bracketPairs.matchBracket(
          g,
          20
          /* give at most 20ms to compute */
        ), p = Ac._DECORATION_OPTIONS_WITH_OVERVIEW_RULER;
        !m && this._matchBrackets === "always" && (m = t.bracketPairs.findEnclosingBrackets(
          g,
          20
          /* give at most 20ms to compute */
        ), p = Ac._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER), a[l++] = new jge(g, m, p);
      }
    }
    this._lastBracketsData = a, this._lastVersionId = i;
  }
};
Ac.ID = "editor.contrib.bracketMatchingController", Ac._DECORATION_OPTIONS_WITH_OVERVIEW_RULER = He.register({
  description: "bracket-match-overview",
  stickiness: 1,
  className: "bracket-match",
  overviewRuler: {
    color: Wi(zge),
    position: Bl.Center
  }
}), Ac._DECORATION_OPTIONS_WITHOUT_OVERVIEW_RULER = He.register({
  description: "bracket-match-no-overview",
  stickiness: 1,
  className: "bracket-match"
});
let Bu = Ac;
rs(
  Bu.ID,
  Bu,
  1
  /* EditorContributionInstantiation.AfterFirstRender */
);
Ge(Qge);
Ge(Uge);
Ge(Gge);
mo.appendMenuItem(Qe.MenubarGoMenu, {
  group: "5_infile_nav",
  command: {
    id: "editor.action.jumpToBracket",
    title: f({ key: "miGoToBracket", comment: ["&& denotes a mnemonic"] }, "Go to &&Bracket")
  },
  order: 2
});
const mn = class mn {
  constructor(e) {
    this._editor = e, this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null, this._startPosition = this._editor.getPosition();
  }
  dispose() {
    this._editor.removeDecorations(this._allDecorations()), this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  reset() {
    this._decorations = [], this._overviewRulerApproximateDecorations = [], this._findScopeDecorationIds = [], this._rangeHighlightDecorationId = null, this._highlightedDecorationId = null;
  }
  getCount() {
    return this._decorations.length;
  }
  /** @deprecated use getFindScopes to support multiple selections */
  getFindScope() {
    return this._findScopeDecorationIds[0] ? this._editor.getModel().getDecorationRange(this._findScopeDecorationIds[0]) : null;
  }
  getFindScopes() {
    if (this._findScopeDecorationIds.length) {
      const e = this._findScopeDecorationIds.map((t) => this._editor.getModel().getDecorationRange(t)).filter((t) => !!t);
      if (e.length)
        return e;
    }
    return null;
  }
  getStartPosition() {
    return this._startPosition;
  }
  setStartPosition(e) {
    this._startPosition = e, this.setCurrentFindMatch(null);
  }
  _getDecorationIndex(e) {
    const t = this._decorations.indexOf(e);
    return t >= 0 ? t + 1 : 1;
  }
  getDecorationRangeAt(e) {
    const t = e < this._decorations.length ? this._decorations[e] : null;
    return t ? this._editor.getModel().getDecorationRange(t) : null;
  }
  getCurrentMatchesPosition(e) {
    const t = this._editor.getModel().getDecorationsInRange(e);
    for (const i of t) {
      const n = i.options;
      if (n === mn._FIND_MATCH_DECORATION || n === mn._CURRENT_FIND_MATCH_DECORATION)
        return this._getDecorationIndex(i.id);
    }
    return 0;
  }
  setCurrentFindMatch(e) {
    let t = null, i = 0;
    if (e)
      for (let n = 0, o = this._decorations.length; n < o; n++) {
        const r = this._editor.getModel().getDecorationRange(this._decorations[n]);
        if (e.equalsRange(r)) {
          t = this._decorations[n], i = n + 1;
          break;
        }
      }
    return (this._highlightedDecorationId !== null || t !== null) && this._editor.changeDecorations((n) => {
      if (this._highlightedDecorationId !== null && (n.changeDecorationOptions(this._highlightedDecorationId, mn._FIND_MATCH_DECORATION), this._highlightedDecorationId = null), t !== null && (this._highlightedDecorationId = t, n.changeDecorationOptions(this._highlightedDecorationId, mn._CURRENT_FIND_MATCH_DECORATION)), this._rangeHighlightDecorationId !== null && (n.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), t !== null) {
        let o = this._editor.getModel().getDecorationRange(t);
        if (o.startLineNumber !== o.endLineNumber && o.endColumn === 1) {
          const r = o.endLineNumber - 1, a = this._editor.getModel().getLineMaxColumn(r);
          o = new E(o.startLineNumber, o.startColumn, r, a);
        }
        this._rangeHighlightDecorationId = n.addDecoration(o, mn._RANGE_HIGHLIGHT_DECORATION);
      }
    }), i;
  }
  set(e, t) {
    this._editor.changeDecorations((i) => {
      let n = mn._FIND_MATCH_DECORATION;
      const o = [];
      if (e.length > 1e3) {
        n = mn._FIND_MATCH_NO_OVERVIEW_DECORATION;
        const a = this._editor.getModel().getLineCount(), c = this._editor.getLayoutInfo().height / a, d = Math.max(2, Math.ceil(3 / c));
        let h = e[0].range.startLineNumber, u = e[0].range.endLineNumber;
        for (let g = 1, m = e.length; g < m; g++) {
          const p = e[g].range;
          u + d >= p.startLineNumber ? p.endLineNumber > u && (u = p.endLineNumber) : (o.push({
            range: new E(h, 1, u, 1),
            options: mn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
          }), h = p.startLineNumber, u = p.endLineNumber);
        }
        o.push({
          range: new E(h, 1, u, 1),
          options: mn._FIND_MATCH_ONLY_OVERVIEW_DECORATION
        });
      }
      const r = new Array(e.length);
      for (let a = 0, l = e.length; a < l; a++)
        r[a] = {
          range: e[a].range,
          options: n
        };
      this._decorations = i.deltaDecorations(this._decorations, r), this._overviewRulerApproximateDecorations = i.deltaDecorations(this._overviewRulerApproximateDecorations, o), this._rangeHighlightDecorationId && (i.removeDecoration(this._rangeHighlightDecorationId), this._rangeHighlightDecorationId = null), this._findScopeDecorationIds.length && (this._findScopeDecorationIds.forEach((a) => i.removeDecoration(a)), this._findScopeDecorationIds = []), t?.length && (this._findScopeDecorationIds = t.map((a) => i.addDecoration(a, mn._FIND_SCOPE_DECORATION)));
    });
  }
  matchBeforePosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = this._decorations.length - 1; t >= 0; t--) {
      const i = this._decorations[t], n = this._editor.getModel().getDecorationRange(i);
      if (!(!n || n.endLineNumber > e.lineNumber)) {
        if (n.endLineNumber < e.lineNumber)
          return n;
        if (!(n.endColumn > e.column))
          return n;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[this._decorations.length - 1]);
  }
  matchAfterPosition(e) {
    if (this._decorations.length === 0)
      return null;
    for (let t = 0, i = this._decorations.length; t < i; t++) {
      const n = this._decorations[t], o = this._editor.getModel().getDecorationRange(n);
      if (!(!o || o.startLineNumber < e.lineNumber)) {
        if (o.startLineNumber > e.lineNumber)
          return o;
        if (!(o.startColumn < e.column))
          return o;
      }
    }
    return this._editor.getModel().getDecorationRange(this._decorations[0]);
  }
  _allDecorations() {
    let e = [];
    return e = e.concat(this._decorations), e = e.concat(this._overviewRulerApproximateDecorations), this._findScopeDecorationIds.length && e.push(...this._findScopeDecorationIds), this._rangeHighlightDecorationId && e.push(this._rangeHighlightDecorationId), e;
  }
};
mn._CURRENT_FIND_MATCH_DECORATION = He.register({
  description: "current-find-match",
  stickiness: 1,
  zIndex: 13,
  className: "currentFindMatch",
  inlineClassName: "currentFindMatchInline",
  showIfCollapsed: !0,
  overviewRuler: {
    color: Wi(Sy),
    position: Bl.Center
  },
  minimap: {
    color: Wi(EL),
    position: 1
    /* MinimapPosition.Inline */
  }
}), mn._FIND_MATCH_DECORATION = He.register({
  description: "find-match",
  stickiness: 1,
  zIndex: 10,
  className: "findMatch",
  inlineClassName: "findMatchInline",
  showIfCollapsed: !0,
  overviewRuler: {
    color: Wi(Sy),
    position: Bl.Center
  },
  minimap: {
    color: Wi(EL),
    position: 1
    /* MinimapPosition.Inline */
  }
}), mn._FIND_MATCH_NO_OVERVIEW_DECORATION = He.register({
  description: "find-match-no-overview",
  stickiness: 1,
  className: "findMatch",
  showIfCollapsed: !0
}), mn._FIND_MATCH_ONLY_OVERVIEW_DECORATION = He.register({
  description: "find-match-only-overview",
  stickiness: 1,
  overviewRuler: {
    color: Wi(Sy),
    position: Bl.Center
  }
}), mn._RANGE_HIGHLIGHT_DECORATION = He.register({
  description: "find-range-highlight",
  stickiness: 1,
  className: "rangeHighlight",
  isWholeLine: !0
}), mn._FIND_SCOPE_DECORATION = He.register({
  description: "find-scope",
  className: "findScope",
  isWholeLine: !0
});
let dM = mn;
class Yge {
  constructor(e, t, i) {
    this._editorSelection = e, this._ranges = t, this._replaceStrings = i, this._trackedEditorSelectionId = null;
  }
  getEditOperations(e, t) {
    if (this._ranges.length > 0) {
      const i = [];
      for (let r = 0; r < this._ranges.length; r++)
        i.push({
          range: this._ranges[r],
          text: this._replaceStrings[r]
        });
      i.sort((r, a) => E.compareRangesUsingStarts(r.range, a.range));
      const n = [];
      let o = i[0];
      for (let r = 1; r < i.length; r++)
        o.range.endLineNumber === i[r].range.startLineNumber && o.range.endColumn === i[r].range.startColumn ? (o.range = o.range.plusRange(i[r].range), o.text = o.text + i[r].text) : (n.push(o), o = i[r]);
      n.push(o);
      for (const r of n)
        t.addEditOperation(r.range, r.text);
    }
    this._trackedEditorSelectionId = t.trackSelection(this._editorSelection);
  }
  computeCursorState(e, t) {
    return t.getTrackedSelection(this._trackedEditorSelectionId);
  }
}
function n9(s, e) {
  if (s && s[0] !== "") {
    const t = w4(s, e, "-"), i = w4(s, e, "_");
    return t && !i ? C4(s, e, "-") : !t && i ? C4(s, e, "_") : s[0].toUpperCase() === s[0] ? e.toUpperCase() : s[0].toLowerCase() === s[0] ? e.toLowerCase() : O7(s[0][0]) && e.length > 0 ? e[0].toUpperCase() + e.substr(1) : s[0][0].toUpperCase() !== s[0][0] && e.length > 0 ? e[0].toLowerCase() + e.substr(1) : e;
  } else
    return e;
}
function w4(s, e, t) {
  return s[0].indexOf(t) !== -1 && e.indexOf(t) !== -1 && s[0].split(t).length === e.split(t).length;
}
function C4(s, e, t) {
  const i = e.split(t), n = s[0].split(t);
  let o = "";
  return i.forEach((r, a) => {
    o += n9([n[a]], r) + t;
  }), o.slice(0, -1);
}
class v4 {
  constructor(e) {
    this.staticValue = e, this.kind = 0;
  }
}
class Kge {
  constructor(e) {
    this.pieces = e, this.kind = 1;
  }
}
class gm {
  static fromStaticValue(e) {
    return new gm([Bh.staticValue(e)]);
  }
  get hasReplacementPatterns() {
    return this._state.kind === 1;
  }
  constructor(e) {
    !e || e.length === 0 ? this._state = new v4("") : e.length === 1 && e[0].staticValue !== null ? this._state = new v4(e[0].staticValue) : this._state = new Kge(e);
  }
  buildReplaceString(e, t) {
    if (this._state.kind === 0)
      return t ? n9(e, this._state.staticValue) : this._state.staticValue;
    let i = "";
    for (let n = 0, o = this._state.pieces.length; n < o; n++) {
      const r = this._state.pieces[n];
      if (r.staticValue !== null) {
        i += r.staticValue;
        continue;
      }
      let a = gm._substitute(r.matchIndex, e);
      if (r.caseOps !== null && r.caseOps.length > 0) {
        const l = [], c = r.caseOps.length;
        let d = 0;
        for (let h = 0, u = a.length; h < u; h++) {
          if (d >= c) {
            l.push(a.slice(h));
            break;
          }
          switch (r.caseOps[d]) {
            case "U":
              l.push(a[h].toUpperCase());
              break;
            case "u":
              l.push(a[h].toUpperCase()), d++;
              break;
            case "L":
              l.push(a[h].toLowerCase());
              break;
            case "l":
              l.push(a[h].toLowerCase()), d++;
              break;
            default:
              l.push(a[h]);
          }
        }
        a = l.join("");
      }
      i += a;
    }
    return i;
  }
  static _substitute(e, t) {
    if (t === null)
      return "";
    if (e === 0)
      return t[0];
    let i = "";
    for (; e > 0; ) {
      if (e < t.length)
        return (t[e] || "") + i;
      i = String(e % 10) + i, e = Math.floor(e / 10);
    }
    return "$" + i;
  }
}
class Bh {
  static staticValue(e) {
    return new Bh(e, -1, null);
  }
  static caseOps(e, t) {
    return new Bh(null, e, t);
  }
  constructor(e, t, i) {
    this.staticValue = e, this.matchIndex = t, !i || i.length === 0 ? this.caseOps = null : this.caseOps = i.slice(0);
  }
}
class Jge {
  constructor(e) {
    this._source = e, this._lastCharIndex = 0, this._result = [], this._resultLen = 0, this._currentStaticPiece = "";
  }
  emitUnchanged(e) {
    this._emitStatic(this._source.substring(this._lastCharIndex, e)), this._lastCharIndex = e;
  }
  emitStatic(e, t) {
    this._emitStatic(e), this._lastCharIndex = t;
  }
  _emitStatic(e) {
    e.length !== 0 && (this._currentStaticPiece += e);
  }
  emitMatchIndex(e, t, i) {
    this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Bh.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), this._result[this._resultLen++] = Bh.caseOps(e, i), this._lastCharIndex = t;
  }
  finalize() {
    return this.emitUnchanged(this._source.length), this._currentStaticPiece.length !== 0 && (this._result[this._resultLen++] = Bh.staticValue(this._currentStaticPiece), this._currentStaticPiece = ""), new gm(this._result);
  }
}
function qge(s) {
  if (!s || s.length === 0)
    return new gm(null);
  const e = [], t = new Jge(s);
  for (let i = 0, n = s.length; i < n; i++) {
    const o = s.charCodeAt(i);
    if (o === 92) {
      if (i++, i >= n)
        break;
      const r = s.charCodeAt(i);
      switch (r) {
        case 92:
          t.emitUnchanged(i - 1), t.emitStatic("\\", i + 1);
          break;
        case 110:
          t.emitUnchanged(i - 1), t.emitStatic(`
`, i + 1);
          break;
        case 116:
          t.emitUnchanged(i - 1), t.emitStatic("	", i + 1);
          break;
        case 117:
        case 85:
        case 108:
        case 76:
          t.emitUnchanged(i - 1), t.emitStatic("", i + 1), e.push(String.fromCharCode(r));
          break;
      }
      continue;
    }
    if (o === 36) {
      if (i++, i >= n)
        break;
      const r = s.charCodeAt(i);
      if (r === 36) {
        t.emitUnchanged(i - 1), t.emitStatic("$", i + 1);
        continue;
      }
      if (r === 48 || r === 38) {
        t.emitUnchanged(i - 1), t.emitMatchIndex(0, i + 1, e), e.length = 0;
        continue;
      }
      if (49 <= r && r <= 57) {
        let a = r - 48;
        if (i + 1 < n) {
          const l = s.charCodeAt(i + 1);
          if (48 <= l && l <= 57) {
            i++, a = a * 10 + (l - 48), t.emitUnchanged(i - 2), t.emitMatchIndex(a, i + 1, e), e.length = 0;
            continue;
          }
        }
        t.emitUnchanged(i - 1), t.emitMatchIndex(a, i + 1, e), e.length = 0;
        continue;
      }
    }
  }
  return t.finalize();
}
const $l = new le("findWidgetVisible", !1);
$l.toNegated();
const OS = new le("findInputFocussed", !1), SB = new le("replaceInputFocussed", !1), ow = {
  primary: 545,
  mac: {
    primary: 2593
    /* KeyCode.KeyC */
  }
}, rw = {
  primary: 565,
  mac: {
    primary: 2613
    /* KeyCode.KeyW */
  }
}, aw = {
  primary: 560,
  mac: {
    primary: 2608
    /* KeyCode.KeyR */
  }
}, lw = {
  primary: 554,
  mac: {
    primary: 2602
    /* KeyCode.KeyL */
  }
}, cw = {
  primary: 558,
  mac: {
    primary: 2606
    /* KeyCode.KeyP */
  }
}, xt = {
  StartFindAction: "actions.find",
  StartFindWithSelection: "actions.findWithSelection",
  StartFindWithArgs: "editor.actions.findWithArgs",
  NextMatchFindAction: "editor.action.nextMatchFindAction",
  PreviousMatchFindAction: "editor.action.previousMatchFindAction",
  GoToMatchFindAction: "editor.action.goToMatchFindAction",
  NextSelectionMatchFindAction: "editor.action.nextSelectionMatchFindAction",
  PreviousSelectionMatchFindAction: "editor.action.previousSelectionMatchFindAction",
  StartFindReplaceAction: "editor.action.startFindReplaceAction",
  CloseFindWidgetCommand: "closeFindWidget",
  ToggleCaseSensitiveCommand: "toggleFindCaseSensitive",
  ToggleWholeWordCommand: "toggleFindWholeWord",
  ToggleRegexCommand: "toggleFindRegex",
  ToggleSearchScopeCommand: "toggleFindInSelection",
  TogglePreserveCaseCommand: "togglePreserveCase",
  ReplaceOneAction: "editor.action.replaceOne",
  ReplaceAllAction: "editor.action.replaceAll",
  SelectAllMatchesAction: "editor.action.selectAllMatches"
}, Rc = 19999, $ge = 240;
class rA {
  constructor(e, t) {
    this._toDispose = new X(), this._editor = e, this._state = t, this._isDisposed = !1, this._startSearchingTimer = new nr(), this._decorations = new dM(e), this._toDispose.add(this._decorations), this._updateDecorationsScheduler = new zt(() => {
      if (this._editor.hasModel())
        return this.research(!1);
    }, 100), this._toDispose.add(this._updateDecorationsScheduler), this._toDispose.add(this._editor.onDidChangeCursorPosition((i) => {
      (i.reason === 3 || i.reason === 5 || i.reason === 6) && this._decorations.setStartPosition(this._editor.getPosition());
    })), this._ignoreModelContentChanged = !1, this._toDispose.add(this._editor.onDidChangeModelContent((i) => {
      this._ignoreModelContentChanged || (i.isFlush && this._decorations.reset(), this._decorations.setStartPosition(this._editor.getPosition()), this._updateDecorationsScheduler.schedule());
    })), this._toDispose.add(this._state.onFindReplaceStateChange((i) => this._onStateChanged(i))), this.research(!1, this._state.searchScope);
  }
  dispose() {
    this._isDisposed = !0, Ct(this._startSearchingTimer), this._toDispose.dispose();
  }
  _onStateChanged(e) {
    this._isDisposed || this._editor.hasModel() && (e.searchString || e.isReplaceRevealed || e.isRegex || e.wholeWord || e.matchCase || e.searchScope) && (this._editor.getModel().isTooLargeForSyncing() ? (this._startSearchingTimer.cancel(), this._startSearchingTimer.setIfNotSet(() => {
      e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor);
    }, $ge)) : e.searchScope ? this.research(e.moveCursor, this._state.searchScope) : this.research(e.moveCursor));
  }
  static _getSearchRange(e, t) {
    return t || e.getFullModelRange();
  }
  research(e, t) {
    let i = null;
    typeof t < "u" ? t !== null && (Array.isArray(t) ? i = t : i = [t]) : i = this._decorations.getFindScopes(), i !== null && (i = i.map((a) => {
      if (a.startLineNumber !== a.endLineNumber) {
        let l = a.endLineNumber;
        return a.endColumn === 1 && (l = l - 1), new E(a.startLineNumber, 1, l, this._editor.getModel().getLineMaxColumn(l));
      }
      return a;
    }));
    const n = this._findMatches(i, !1, Rc);
    this._decorations.set(n, i);
    const o = this._editor.getSelection();
    let r = this._decorations.getCurrentMatchesPosition(o);
    if (r === 0 && n.length > 0) {
      const a = OA(n.map((l) => l.range), (l) => E.compareRangesUsingStarts(l, o) >= 0);
      r = a > 0 ? a - 1 + 1 : r;
    }
    this._state.changeMatchInfo(r, this._decorations.getCount(), void 0), e && this._editor.getOption(
      41
      /* EditorOption.find */
    ).cursorMoveOnType && this._moveToNextMatch(this._decorations.getStartPosition());
  }
  _hasMatches() {
    return this._state.matchesCount > 0;
  }
  _cannotFind() {
    if (!this._hasMatches()) {
      const e = this._decorations.getFindScope();
      return e && this._editor.revealRangeInCenterIfOutsideViewport(
        e,
        0
        /* ScrollType.Smooth */
      ), !0;
    }
    return !1;
  }
  _setCurrentFindMatch(e) {
    const t = this._decorations.setCurrentFindMatch(e);
    this._state.changeMatchInfo(t, this._decorations.getCount(), e), this._editor.setSelection(e), this._editor.revealRangeInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
  _prevSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const o = this._editor.getModel();
    return t || n === 1 ? (i === 1 ? i = o.getLineCount() : i--, n = o.getLineMaxColumn(i)) : n--, new F(i, n);
  }
  _moveToPrevMatch(e, t = !1) {
    if (!this._state.canNavigateBack()) {
      const d = this._decorations.matchAfterPosition(e);
      d && this._setCurrentFindMatch(d);
      return;
    }
    if (this._decorations.getCount() < Rc) {
      let d = this._decorations.matchBeforePosition(e);
      d && d.isEmpty() && d.getStartPosition().equals(e) && (e = this._prevSearchPosition(e), d = this._decorations.matchBeforePosition(e)), d && this._setCurrentFindMatch(d);
      return;
    }
    if (this._cannotFind())
      return;
    const i = this._decorations.getFindScope(), n = rA._getSearchRange(this._editor.getModel(), i);
    n.getEndPosition().isBefore(e) && (e = n.getEndPosition()), e.isBefore(n.getStartPosition()) && (e = n.getEndPosition());
    const { lineNumber: o, column: r } = e, a = this._editor.getModel();
    let l = new F(o, r), c = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null, !1);
    if (c && c.range.isEmpty() && c.range.getStartPosition().equals(l) && (l = this._prevSearchPosition(l), c = a.findPreviousMatch(this._state.searchString, l, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null, !1)), !!c) {
      if (!t && !n.containsRange(c.range))
        return this._moveToPrevMatch(c.range.getStartPosition(), !0);
      this._setCurrentFindMatch(c.range);
    }
  }
  moveToPrevMatch() {
    this._moveToPrevMatch(this._editor.getSelection().getStartPosition());
  }
  _nextSearchPosition(e) {
    const t = this._state.isRegex && (this._state.searchString.indexOf("^") >= 0 || this._state.searchString.indexOf("$") >= 0);
    let { lineNumber: i, column: n } = e;
    const o = this._editor.getModel();
    return t || n === o.getLineMaxColumn(i) ? (i === o.getLineCount() ? i = 1 : i++, n = 1) : n++, new F(i, n);
  }
  _moveToNextMatch(e) {
    if (!this._state.canNavigateForward()) {
      const i = this._decorations.matchBeforePosition(e);
      i && this._setCurrentFindMatch(i);
      return;
    }
    if (this._decorations.getCount() < Rc) {
      let i = this._decorations.matchAfterPosition(e);
      i && i.isEmpty() && i.getStartPosition().equals(e) && (e = this._nextSearchPosition(e), i = this._decorations.matchAfterPosition(e)), i && this._setCurrentFindMatch(i);
      return;
    }
    const t = this._getNextMatch(e, !1, !0);
    t && this._setCurrentFindMatch(t.range);
  }
  _getNextMatch(e, t, i, n = !1) {
    if (this._cannotFind())
      return null;
    const o = this._decorations.getFindScope(), r = rA._getSearchRange(this._editor.getModel(), o);
    r.getEndPosition().isBefore(e) && (e = r.getStartPosition()), e.isBefore(r.getStartPosition()) && (e = r.getStartPosition());
    const { lineNumber: a, column: l } = e, c = this._editor.getModel();
    let d = new F(a, l), h = c.findNextMatch(this._state.searchString, d, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null, t);
    return i && h && h.range.isEmpty() && h.range.getStartPosition().equals(d) && (d = this._nextSearchPosition(d), h = c.findNextMatch(this._state.searchString, d, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null, t)), h ? !n && !r.containsRange(h.range) ? this._getNextMatch(h.range.getEndPosition(), t, i, !0) : h : null;
  }
  moveToNextMatch() {
    this._moveToNextMatch(this._editor.getSelection().getEndPosition());
  }
  _moveToMatch(e) {
    const t = this._decorations.getDecorationRangeAt(e);
    t && this._setCurrentFindMatch(t);
  }
  moveToMatch(e) {
    this._moveToMatch(e);
  }
  _getReplacePattern() {
    return this._state.isRegex ? qge(this._state.replaceString) : gm.fromStaticValue(this._state.replaceString);
  }
  replace() {
    if (!this._hasMatches())
      return;
    const e = this._getReplacePattern(), t = this._editor.getSelection(), i = this._getNextMatch(t.getStartPosition(), !0, !1);
    if (i)
      if (t.equalsRange(i.range)) {
        const n = e.buildReplaceString(i.matches, this._state.preserveCase), o = new vn(t, n);
        this._executeEditorCommand("replace", o), this._decorations.setStartPosition(new F(t.startLineNumber, t.startColumn + n.length)), this.research(!0);
      } else
        this._decorations.setStartPosition(this._editor.getPosition()), this._setCurrentFindMatch(i.range);
  }
  _findMatches(e, t, i) {
    const n = (e || [null]).map((o) => rA._getSearchRange(this._editor.getModel(), o));
    return this._editor.getModel().findMatches(this._state.searchString, n, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null, t, i);
  }
  replaceAll() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    e === null && this._state.matchesCount >= Rc ? this._largeReplaceAll() : this._regularReplaceAll(e), this.research(!1);
  }
  _largeReplaceAll() {
    const t = new Qd(this._state.searchString, this._state.isRegex, this._state.matchCase, this._state.wholeWord ? this._editor.getOption(
      132
      /* EditorOption.wordSeparators */
    ) : null).parseSearchRequest();
    if (!t)
      return;
    let i = t.regex;
    if (!i.multiline) {
      let h = "mu";
      i.ignoreCase && (h += "i"), i.global && (h += "g"), i = new RegExp(i.source, h);
    }
    const n = this._editor.getModel(), o = n.getValue(
      1
      /* EndOfLinePreference.LF */
    ), r = n.getFullModelRange(), a = this._getReplacePattern();
    let l;
    const c = this._state.preserveCase;
    a.hasReplacementPatterns || c ? l = o.replace(i, function() {
      return a.buildReplaceString(arguments, c);
    }) : l = o.replace(i, a.buildReplaceString(null, c));
    const d = new D8(r, l, this._editor.getSelection());
    this._executeEditorCommand("replaceAll", d);
  }
  _regularReplaceAll(e) {
    const t = this._getReplacePattern(), i = this._findMatches(
      e,
      t.hasReplacementPatterns || this._state.preserveCase,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ), n = [];
    for (let r = 0, a = i.length; r < a; r++)
      n[r] = t.buildReplaceString(i[r].matches, this._state.preserveCase);
    const o = new Yge(this._editor.getSelection(), i.map((r) => r.range), n);
    this._executeEditorCommand("replaceAll", o);
  }
  selectAllMatches() {
    if (!this._hasMatches())
      return;
    const e = this._decorations.getFindScopes();
    let i = this._findMatches(
      e,
      !1,
      1073741824
      /* Constants.MAX_SAFE_SMALL_INTEGER */
    ).map((o) => new Ue(o.range.startLineNumber, o.range.startColumn, o.range.endLineNumber, o.range.endColumn));
    const n = this._editor.getSelection();
    for (let o = 0, r = i.length; o < r; o++)
      if (i[o].equalsRange(n)) {
        i = [n].concat(i.slice(0, o)).concat(i.slice(o + 1));
        break;
      }
    this._editor.setSelections(i);
  }
  _executeEditorCommand(e, t) {
    try {
      this._ignoreModelContentChanged = !0, this._editor.pushUndoStop(), this._editor.executeCommand(e, t), this._editor.pushUndoStop();
    } finally {
      this._ignoreModelContentChanged = !1;
    }
  }
}
const u0 = class u0 extends to {
  constructor(e, t, i) {
    super(), this._hideSoon = this._register(new zt(() => this._hide(), 2e3)), this._isVisible = !1, this._editor = e, this._state = t, this._keybindingService = i, this._domNode = document.createElement("div"), this._domNode.className = "findOptionsWidget", this._domNode.style.display = "none", this._domNode.style.top = "10px", this._domNode.style.zIndex = "12", this._domNode.setAttribute("role", "presentation"), this._domNode.setAttribute("aria-hidden", "true");
    const n = {
      inputActiveOptionBorder: oe(Q0),
      inputActiveOptionForeground: oe(G0),
      inputActiveOptionBackground: oe(R_)
    }, o = this._register(im());
    this.caseSensitive = this._register(new MW({
      appendTitle: this._keybindingLabelFor(xt.ToggleCaseSensitiveCommand),
      isChecked: this._state.matchCase,
      hoverDelegate: o,
      ...n
    })), this._domNode.appendChild(this.caseSensitive.domNode), this._register(this.caseSensitive.onChange(() => {
      this._state.change({
        matchCase: this.caseSensitive.checked
      }, !1);
    })), this.wholeWords = this._register(new NW({
      appendTitle: this._keybindingLabelFor(xt.ToggleWholeWordCommand),
      isChecked: this._state.wholeWord,
      hoverDelegate: o,
      ...n
    })), this._domNode.appendChild(this.wholeWords.domNode), this._register(this.wholeWords.onChange(() => {
      this._state.change({
        wholeWord: this.wholeWords.checked
      }, !1);
    })), this.regex = this._register(new TW({
      appendTitle: this._keybindingLabelFor(xt.ToggleRegexCommand),
      isChecked: this._state.isRegex,
      hoverDelegate: o,
      ...n
    })), this._domNode.appendChild(this.regex.domNode), this._register(this.regex.onChange(() => {
      this._state.change({
        isRegex: this.regex.checked
      }, !1);
    })), this._editor.addOverlayWidget(this), this._register(this._state.onFindReplaceStateChange((r) => {
      let a = !1;
      r.isRegex && (this.regex.checked = this._state.isRegex, a = !0), r.wholeWord && (this.wholeWords.checked = this._state.wholeWord, a = !0), r.matchCase && (this.caseSensitive.checked = this._state.matchCase, a = !0), !this._state.isRevealed && a && this._revealTemporarily();
    })), this._register(U(this._domNode, ee.MOUSE_LEAVE, (r) => this._onMouseLeave())), this._register(U(this._domNode, "mouseover", (r) => this._onMouseOver()));
  }
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  dispose() {
    this._editor.removeOverlayWidget(this), super.dispose();
  }
  // ----- IOverlayWidget API
  getId() {
    return u0.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    };
  }
  highlightFindOptions() {
    this._revealTemporarily();
  }
  _revealTemporarily() {
    this._show(), this._hideSoon.schedule();
  }
  _onMouseLeave() {
    this._hideSoon.schedule();
  }
  _onMouseOver() {
    this._hideSoon.cancel();
  }
  _show() {
    this._isVisible || (this._isVisible = !0, this._domNode.style.display = "block");
  }
  _hide() {
    this._isVisible && (this._isVisible = !1, this._domNode.style.display = "none");
  }
};
u0.ID = "editor.contrib.findOptionsWidget";
let hM = u0;
function dw(s, e) {
  return s === 1 ? !0 : s === 2 ? !1 : e;
}
class Xge extends V {
  get searchString() {
    return this._searchString;
  }
  get replaceString() {
    return this._replaceString;
  }
  get isRevealed() {
    return this._isRevealed;
  }
  get isReplaceRevealed() {
    return this._isReplaceRevealed;
  }
  get isRegex() {
    return dw(this._isRegexOverride, this._isRegex);
  }
  get wholeWord() {
    return dw(this._wholeWordOverride, this._wholeWord);
  }
  get matchCase() {
    return dw(this._matchCaseOverride, this._matchCase);
  }
  get preserveCase() {
    return dw(this._preserveCaseOverride, this._preserveCase);
  }
  get actualIsRegex() {
    return this._isRegex;
  }
  get actualWholeWord() {
    return this._wholeWord;
  }
  get actualMatchCase() {
    return this._matchCase;
  }
  get actualPreserveCase() {
    return this._preserveCase;
  }
  get searchScope() {
    return this._searchScope;
  }
  get matchesPosition() {
    return this._matchesPosition;
  }
  get matchesCount() {
    return this._matchesCount;
  }
  get currentMatch() {
    return this._currentMatch;
  }
  constructor() {
    super(), this._onFindReplaceStateChange = this._register(new B()), this.onFindReplaceStateChange = this._onFindReplaceStateChange.event, this._searchString = "", this._replaceString = "", this._isRevealed = !1, this._isReplaceRevealed = !1, this._isRegex = !1, this._isRegexOverride = 0, this._wholeWord = !1, this._wholeWordOverride = 0, this._matchCase = !1, this._matchCaseOverride = 0, this._preserveCase = !1, this._preserveCaseOverride = 0, this._searchScope = null, this._matchesPosition = 0, this._matchesCount = 0, this._currentMatch = null, this._loop = !0, this._isSearching = !1, this._filters = null;
  }
  changeMatchInfo(e, t, i) {
    const n = {
      moveCursor: !1,
      updateHistory: !1,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let o = !1;
    t === 0 && (e = 0), e > t && (e = t), this._matchesPosition !== e && (this._matchesPosition = e, n.matchesPosition = !0, o = !0), this._matchesCount !== t && (this._matchesCount = t, n.matchesCount = !0, o = !0), typeof i < "u" && (E.equalsRange(this._currentMatch, i) || (this._currentMatch = i, n.currentMatch = !0, o = !0)), o && this._onFindReplaceStateChange.fire(n);
  }
  change(e, t, i = !0) {
    const n = {
      moveCursor: t,
      updateHistory: i,
      searchString: !1,
      replaceString: !1,
      isRevealed: !1,
      isReplaceRevealed: !1,
      isRegex: !1,
      wholeWord: !1,
      matchCase: !1,
      preserveCase: !1,
      searchScope: !1,
      matchesPosition: !1,
      matchesCount: !1,
      currentMatch: !1,
      loop: !1,
      isSearching: !1,
      filters: !1
    };
    let o = !1;
    const r = this.isRegex, a = this.wholeWord, l = this.matchCase, c = this.preserveCase;
    typeof e.searchString < "u" && this._searchString !== e.searchString && (this._searchString = e.searchString, n.searchString = !0, o = !0), typeof e.replaceString < "u" && this._replaceString !== e.replaceString && (this._replaceString = e.replaceString, n.replaceString = !0, o = !0), typeof e.isRevealed < "u" && this._isRevealed !== e.isRevealed && (this._isRevealed = e.isRevealed, n.isRevealed = !0, o = !0), typeof e.isReplaceRevealed < "u" && this._isReplaceRevealed !== e.isReplaceRevealed && (this._isReplaceRevealed = e.isReplaceRevealed, n.isReplaceRevealed = !0, o = !0), typeof e.isRegex < "u" && (this._isRegex = e.isRegex), typeof e.wholeWord < "u" && (this._wholeWord = e.wholeWord), typeof e.matchCase < "u" && (this._matchCase = e.matchCase), typeof e.preserveCase < "u" && (this._preserveCase = e.preserveCase), typeof e.searchScope < "u" && (e.searchScope?.every((d) => this._searchScope?.some((h) => !E.equalsRange(h, d))) || (this._searchScope = e.searchScope, n.searchScope = !0, o = !0)), typeof e.loop < "u" && this._loop !== e.loop && (this._loop = e.loop, n.loop = !0, o = !0), typeof e.isSearching < "u" && this._isSearching !== e.isSearching && (this._isSearching = e.isSearching, n.isSearching = !0, o = !0), typeof e.filters < "u" && (this._filters ? this._filters.update(e.filters) : this._filters = e.filters, n.filters = !0, o = !0), this._isRegexOverride = typeof e.isRegexOverride < "u" ? e.isRegexOverride : 0, this._wholeWordOverride = typeof e.wholeWordOverride < "u" ? e.wholeWordOverride : 0, this._matchCaseOverride = typeof e.matchCaseOverride < "u" ? e.matchCaseOverride : 0, this._preserveCaseOverride = typeof e.preserveCaseOverride < "u" ? e.preserveCaseOverride : 0, r !== this.isRegex && (o = !0, n.isRegex = !0), a !== this.wholeWord && (o = !0, n.wholeWord = !0), l !== this.matchCase && (o = !0, n.matchCase = !0), c !== this.preserveCase && (o = !0, n.preserveCase = !0), o && this._onFindReplaceStateChange.fire(n);
  }
  canNavigateBack() {
    return this.canNavigateInLoop() || this.matchesPosition !== 1;
  }
  canNavigateForward() {
    return this.canNavigateInLoop() || this.matchesPosition < this.matchesCount;
  }
  canNavigateInLoop() {
    return this._loop || this.matchesCount >= Rc;
  }
}
function S4(s) {
  return s.lookupKeybinding("history.showPrevious")?.getElectronAccelerator() === "Up" && s.lookupKeybinding("history.showNext")?.getElectronAccelerator() === "Down";
}
const y4 = Rt("find-collapsed", Z.chevronRight, f("findCollapsedIcon", "Icon to indicate that the editor find widget is collapsed.")), x4 = Rt("find-expanded", Z.chevronDown, f("findExpandedIcon", "Icon to indicate that the editor find widget is expanded.")), Zge = Rt("find-selection", Z.selection, f("findSelectionIcon", "Icon for 'Find in Selection' in the editor find widget.")), efe = Rt("find-replace", Z.replace, f("findReplaceIcon", "Icon for 'Replace' in the editor find widget.")), tfe = Rt("find-replace-all", Z.replaceAll, f("findReplaceAllIcon", "Icon for 'Replace All' in the editor find widget.")), ife = Rt("find-previous-match", Z.arrowUp, f("findPreviousMatchIcon", "Icon for 'Find Previous' in the editor find widget.")), nfe = Rt("find-next-match", Z.arrowDown, f("findNextMatchIcon", "Icon for 'Find Next' in the editor find widget.")), sfe = f("label.findDialog", "Find / Replace"), ofe = f("label.find", "Find"), rfe = f("placeholder.find", "Find"), afe = f("label.previousMatchButton", "Previous Match"), lfe = f("label.nextMatchButton", "Next Match"), cfe = f("label.toggleSelectionFind", "Find in Selection"), dfe = f("label.closeButton", "Close"), hfe = f("label.replace", "Replace"), ufe = f("placeholder.replace", "Replace"), gfe = f("label.replaceButton", "Replace"), ffe = f("label.replaceAllButton", "Replace All"), mfe = f("label.toggleReplaceButton", "Toggle Replace"), pfe = f("title.matchesCountLimit", "Only the first {0} results are highlighted, but all find operations work on the entire text.", Rc), Afe = f("label.matchesLocation", "{0} of {1}"), E4 = f("label.noResults", "No results"), Jr = 419, _fe = 275, bfe = _fe - 54;
let lp = 69;
const wfe = 33, L4 = "ctrlEnterReplaceAll.windows.donotask", k4 = ze ? 256 : 2048;
class bx {
  constructor(e) {
    this.afterLineNumber = e, this.heightInPx = wfe, this.suppressMouseDown = !1, this.domNode = document.createElement("div"), this.domNode.className = "dock-find-viewzone";
  }
}
function D4(s, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionStart > 0) {
    s.stopPropagation();
    return;
  }
}
function I4(s, e, t) {
  const i = !!e.match(/\n/);
  if (t && i && t.selectionEnd < t.value.length) {
    s.stopPropagation();
    return;
  }
}
const g0 = class g0 extends to {
  constructor(e, t, i, n, o, r, a, l, c, d) {
    super(), this._hoverService = d, this._cachedHeight = null, this._revealTimeouts = [], this._codeEditor = e, this._controller = t, this._state = i, this._contextViewProvider = n, this._keybindingService = o, this._contextKeyService = r, this._storageService = l, this._notificationService = c, this._ctrlEnterReplaceAllWarningPrompted = !!l.getBoolean(
      L4,
      0
      /* StorageScope.PROFILE */
    ), this._isVisible = !1, this._isReplaceVisible = !1, this._ignoreChangeEvent = !1, this._updateHistoryDelayer = new Gl(500), this._register(we(() => this._updateHistoryDelayer.cancel())), this._register(this._state.onFindReplaceStateChange((h) => this._onStateChanged(h))), this._buildDomNode(), this._updateButtons(), this._tryUpdateWidgetWidth(), this._findInput.inputBox.layout(), this._register(this._codeEditor.onDidChangeConfiguration((h) => {
      if (h.hasChanged(
        92
        /* EditorOption.readOnly */
      ) && (this._codeEditor.getOption(
        92
        /* EditorOption.readOnly */
      ) && this._state.change({ isReplaceRevealed: !1 }, !1), this._updateButtons()), h.hasChanged(
        146
        /* EditorOption.layoutInfo */
      ) && this._tryUpdateWidgetWidth(), h.hasChanged(
        2
        /* EditorOption.accessibilitySupport */
      ) && this.updateAccessibilitySupport(), h.hasChanged(
        41
        /* EditorOption.find */
      )) {
        const u = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).loop;
        this._state.change({ loop: u }, !1);
        const g = this._codeEditor.getOption(
          41
          /* EditorOption.find */
        ).addExtraSpaceOnTop;
        g && !this._viewZone && (this._viewZone = new bx(0), this._showViewZone()), !g && this._viewZone && this._removeViewZone();
      }
    })), this.updateAccessibilitySupport(), this._register(this._codeEditor.onDidChangeCursorSelection(() => {
      this._isVisible && this._updateToggleSelectionFindButton();
    })), this._register(this._codeEditor.onDidFocusEditorWidget(async () => {
      if (this._isVisible) {
        const h = await this._controller.getGlobalBufferTerm();
        h && h !== this._state.searchString && (this._state.change({ searchString: h }, !1), this._findInput.select());
      }
    })), this._findInputFocused = OS.bindTo(r), this._findFocusTracker = this._register(Wl(this._findInput.inputBox.inputElement)), this._register(this._findFocusTracker.onDidFocus(() => {
      this._findInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._findFocusTracker.onDidBlur(() => {
      this._findInputFocused.set(!1);
    })), this._replaceInputFocused = SB.bindTo(r), this._replaceFocusTracker = this._register(Wl(this._replaceInput.inputBox.inputElement)), this._register(this._replaceFocusTracker.onDidFocus(() => {
      this._replaceInputFocused.set(!0), this._updateSearchScope();
    })), this._register(this._replaceFocusTracker.onDidBlur(() => {
      this._replaceInputFocused.set(!1);
    })), this._codeEditor.addOverlayWidget(this), this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop && (this._viewZone = new bx(0)), this._register(this._codeEditor.onDidChangeModel(() => {
      this._isVisible && (this._viewZoneId = void 0);
    })), this._register(this._codeEditor.onDidScrollChange((h) => {
      if (h.scrollTopChanged) {
        this._layoutViewZone();
        return;
      }
      setTimeout(() => {
        this._layoutViewZone();
      }, 0);
    }));
  }
  // ----- IOverlayWidget API
  getId() {
    return g0.ID;
  }
  getDomNode() {
    return this._domNode;
  }
  getPosition() {
    return this._isVisible ? {
      preference: 0
      /* OverlayWidgetPositionPreference.TOP_RIGHT_CORNER */
    } : null;
  }
  // ----- React to state changes
  _onStateChanged(e) {
    if (e.searchString) {
      try {
        this._ignoreChangeEvent = !0, this._findInput.setValue(this._state.searchString);
      } finally {
        this._ignoreChangeEvent = !1;
      }
      this._updateButtons();
    }
    if (e.replaceString && (this._replaceInput.inputBox.value = this._state.replaceString), e.isRevealed && (this._state.isRevealed ? this._reveal() : this._hide(!0)), e.isReplaceRevealed && (this._state.isReplaceRevealed ? !this._codeEditor.getOption(
      92
      /* EditorOption.readOnly */
    ) && !this._isReplaceVisible && (this._isReplaceVisible = !0, this._replaceInput.width = Rs(this._findInput.domNode), this._updateButtons(), this._replaceInput.inputBox.layout()) : this._isReplaceVisible && (this._isReplaceVisible = !1, this._updateButtons())), (e.isRevealed || e.isReplaceRevealed) && (this._state.isRevealed || this._state.isReplaceRevealed) && this._tryUpdateHeight() && this._showViewZone(), e.isRegex && this._findInput.setRegex(this._state.isRegex), e.wholeWord && this._findInput.setWholeWords(this._state.wholeWord), e.matchCase && this._findInput.setCaseSensitive(this._state.matchCase), e.preserveCase && this._replaceInput.setPreserveCase(this._state.preserveCase), e.searchScope && (this._state.searchScope ? this._toggleSelectionFind.checked = !0 : this._toggleSelectionFind.checked = !1, this._updateToggleSelectionFindButton()), e.searchString || e.matchesCount || e.matchesPosition) {
      const t = this._state.searchString.length > 0 && this._state.matchesCount === 0;
      this._domNode.classList.toggle("no-results", t), this._updateMatchesCount(), this._updateButtons();
    }
    (e.searchString || e.currentMatch) && this._layoutViewZone(), e.updateHistory && this._delayedUpdateHistory(), e.loop && this._updateButtons();
  }
  _delayedUpdateHistory() {
    this._updateHistoryDelayer.trigger(this._updateHistory.bind(this)).then(void 0, Pe);
  }
  _updateHistory() {
    this._state.searchString && this._findInput.inputBox.addToHistory(), this._state.replaceString && this._replaceInput.inputBox.addToHistory();
  }
  _updateMatchesCount() {
    this._matchesCount.style.minWidth = lp + "px", this._state.matchesCount >= Rc ? this._matchesCount.title = pfe : this._matchesCount.title = "", this._matchesCount.firstChild?.remove();
    let e;
    if (this._state.matchesCount > 0) {
      let t = String(this._state.matchesCount);
      this._state.matchesCount >= Rc && (t += "+");
      let i = String(this._state.matchesPosition);
      i === "0" && (i = "?"), e = Vf(Afe, i, t);
    } else
      e = E4;
    this._matchesCount.appendChild(document.createTextNode(e)), Ia(this._getAriaLabel(e, this._state.currentMatch, this._state.searchString)), lp = Math.max(lp, this._matchesCount.clientWidth);
  }
  // ----- actions
  _getAriaLabel(e, t, i) {
    if (e === E4)
      return i === "" ? f("ariaSearchNoResultEmpty", "{0} found", e) : f("ariaSearchNoResult", "{0} found for '{1}'", e, i);
    if (t) {
      const n = f("ariaSearchNoResultWithLineNum", "{0} found for '{1}', at {2}", e, i, t.startLineNumber + ":" + t.startColumn), o = this._codeEditor.getModel();
      return o && t.startLineNumber <= o.getLineCount() && t.startLineNumber >= 1 ? `${o.getLineContent(t.startLineNumber)}, ${n}` : n;
    }
    return f("ariaSearchNoResultWithLineNumNoCurrentMatch", "{0} found for '{1}'", e, i);
  }
  /**
   * If 'selection find' is ON we should not disable the button (its function is to cancel 'selection find').
   * If 'selection find' is OFF we enable the button only if there is a selection.
   */
  _updateToggleSelectionFindButton() {
    const e = this._codeEditor.getSelection(), t = e ? e.startLineNumber !== e.endLineNumber || e.startColumn !== e.endColumn : !1, i = this._toggleSelectionFind.checked;
    this._isVisible && (i || t) ? this._toggleSelectionFind.enable() : this._toggleSelectionFind.disable();
  }
  _updateButtons() {
    this._findInput.setEnabled(this._isVisible), this._replaceInput.setEnabled(this._isVisible && this._isReplaceVisible), this._updateToggleSelectionFindButton(), this._closeBtn.setEnabled(this._isVisible);
    const e = this._state.searchString.length > 0, t = !!this._state.matchesCount;
    this._prevBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateBack()), this._nextBtn.setEnabled(this._isVisible && e && t && this._state.canNavigateForward()), this._replaceBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._replaceAllBtn.setEnabled(this._isVisible && this._isReplaceVisible && e), this._domNode.classList.toggle("replaceToggled", this._isReplaceVisible), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible);
    const i = !this._codeEditor.getOption(
      92
      /* EditorOption.readOnly */
    );
    this._toggleReplaceBtn.setEnabled(this._isVisible && i);
  }
  _reveal() {
    if (this._revealTimeouts.forEach((e) => {
      clearTimeout(e);
    }), this._revealTimeouts = [], !this._isVisible) {
      this._isVisible = !0;
      const e = this._codeEditor.getSelection();
      switch (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).autoFindInSelection) {
        case "always":
          this._toggleSelectionFind.checked = !0;
          break;
        case "never":
          this._toggleSelectionFind.checked = !1;
          break;
        case "multiline": {
          const i = !!e && e.startLineNumber !== e.endLineNumber;
          this._toggleSelectionFind.checked = i;
          break;
        }
      }
      this._tryUpdateWidgetWidth(), this._updateButtons(), this._revealTimeouts.push(setTimeout(() => {
        this._domNode.classList.add("visible"), this._domNode.setAttribute("aria-hidden", "false");
      }, 0)), this._revealTimeouts.push(setTimeout(() => {
        this._findInput.validate();
      }, 200)), this._codeEditor.layoutOverlayWidget(this);
      let t = !0;
      if (this._codeEditor.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection && e) {
        const i = this._codeEditor.getDomNode();
        if (i) {
          const n = ui(i), o = this._codeEditor.getScrolledVisiblePosition(e.getStartPosition()), r = n.left + (o ? o.left : 0), a = o ? o.top : 0;
          if (this._viewZone && a < this._viewZone.heightInPx) {
            e.endLineNumber > e.startLineNumber && (t = !1);
            const l = VH(this._domNode).left;
            r > l && (t = !1);
            const c = this._codeEditor.getScrolledVisiblePosition(e.getEndPosition());
            n.left + (c ? c.left : 0) > l && (t = !1);
          }
        }
      }
      this._showViewZone(t);
    }
  }
  _hide(e) {
    this._revealTimeouts.forEach((t) => {
      clearTimeout(t);
    }), this._revealTimeouts = [], this._isVisible && (this._isVisible = !1, this._updateButtons(), this._domNode.classList.remove("visible"), this._domNode.setAttribute("aria-hidden", "true"), this._findInput.clearMessage(), e && this._codeEditor.focus(), this._codeEditor.layoutOverlayWidget(this), this._removeViewZone());
  }
  _layoutViewZone(e) {
    if (!this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop) {
      this._removeViewZone();
      return;
    }
    if (!this._isVisible)
      return;
    const i = this._viewZone;
    this._viewZoneId !== void 0 || !i || this._codeEditor.changeViewZones((n) => {
      i.heightInPx = this._getHeight(), this._viewZoneId = n.addZone(i), this._codeEditor.setScrollTop(e || this._codeEditor.getScrollTop() + i.heightInPx);
    });
  }
  _showViewZone(e = !0) {
    if (!this._isVisible || !this._codeEditor.getOption(
      41
      /* EditorOption.find */
    ).addExtraSpaceOnTop)
      return;
    this._viewZone === void 0 && (this._viewZone = new bx(0));
    const i = this._viewZone;
    this._codeEditor.changeViewZones((n) => {
      if (this._viewZoneId !== void 0) {
        const o = this._getHeight();
        if (o === i.heightInPx)
          return;
        const r = o - i.heightInPx;
        i.heightInPx = o, n.layoutZone(this._viewZoneId), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + r);
        return;
      } else {
        let o = this._getHeight();
        if (o -= this._codeEditor.getOption(
          84
          /* EditorOption.padding */
        ).top, o <= 0)
          return;
        i.heightInPx = o, this._viewZoneId = n.addZone(i), e && this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() + o);
      }
    });
  }
  _removeViewZone() {
    this._codeEditor.changeViewZones((e) => {
      this._viewZoneId !== void 0 && (e.removeZone(this._viewZoneId), this._viewZoneId = void 0, this._viewZone && (this._codeEditor.setScrollTop(this._codeEditor.getScrollTop() - this._viewZone.heightInPx), this._viewZone = void 0));
    });
  }
  _tryUpdateWidgetWidth() {
    if (!this._isVisible || !this._domNode.isConnected)
      return;
    const e = this._codeEditor.getLayoutInfo();
    if (e.contentWidth <= 0) {
      this._domNode.classList.add("hiddenEditor");
      return;
    } else this._domNode.classList.contains("hiddenEditor") && this._domNode.classList.remove("hiddenEditor");
    const i = e.width, n = e.minimap.minimapWidth;
    let o = !1, r = !1, a = !1;
    if (this._resized && Rs(this._domNode) > Jr) {
      this._domNode.style.maxWidth = `${i - 28 - n - 15}px`, this._replaceInput.width = Rs(this._findInput.domNode);
      return;
    }
    if (Jr + 28 + n >= i && (r = !0), Jr + 28 + n - lp >= i && (a = !0), Jr + 28 + n - lp >= i + 50 && (o = !0), this._domNode.classList.toggle("collapsed-find-widget", o), this._domNode.classList.toggle("narrow-find-widget", a), this._domNode.classList.toggle("reduced-find-widget", r), !a && !o && (this._domNode.style.maxWidth = `${i - 28 - n - 15}px`), this._findInput.layout({ collapsedFindWidget: o, narrowFindWidget: a, reducedFindWidget: r }), this._resized) {
      const l = this._findInput.inputBox.element.clientWidth;
      l > 0 && (this._replaceInput.width = l);
    } else this._isReplaceVisible && (this._replaceInput.width = Rs(this._findInput.domNode));
  }
  _getHeight() {
    let e = 0;
    return e += 4, e += this._findInput.inputBox.height + 2, this._isReplaceVisible && (e += 4, e += this._replaceInput.inputBox.height + 2), e += 4, e;
  }
  _tryUpdateHeight() {
    const e = this._getHeight();
    return this._cachedHeight !== null && this._cachedHeight === e ? !1 : (this._cachedHeight = e, this._domNode.style.height = `${e}px`, !0);
  }
  // ----- Public
  focusFindInput() {
    this._findInput.select(), this._findInput.focus();
  }
  focusReplaceInput() {
    this._replaceInput.select(), this._replaceInput.focus();
  }
  highlightFindOptions() {
    this._findInput.highlightFindOptions();
  }
  _updateSearchScope() {
    if (this._codeEditor.hasModel() && this._toggleSelectionFind.checked) {
      const e = this._codeEditor.getSelections();
      e.map((t) => {
        t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(t.endLineNumber - 1)));
        const i = this._state.currentMatch;
        return t.startLineNumber !== t.endLineNumber && !E.equalsRange(t, i) ? t : null;
      }).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  _onFindInputMouseDown(e) {
    e.middleButton && e.stopPropagation();
  }
  _onFindInputKeyDown(e) {
    if (e.equals(
      k4 | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        this._findInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._isReplaceVisible ? this._replaceInput.focus() : this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return D4(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return I4(e, this._findInput.getValue(), this._findInput.domNode.querySelector("textarea"));
  }
  _onReplaceInputKeyDown(e) {
    if (e.equals(
      k4 | 3
      /* KeyCode.Enter */
    ))
      if (this._keybindingService.dispatchEvent(e, e.target)) {
        e.preventDefault();
        return;
      } else {
        yn && vA && !this._ctrlEnterReplaceAllWarningPrompted && (this._notificationService.info(f("ctrlEnter.keybindingChanged", "Ctrl+Enter now inserts line break instead of replacing all. You can modify the keybinding for editor.action.replaceAll to override this behavior.")), this._ctrlEnterReplaceAllWarningPrompted = !0, this._storageService.store(
          L4,
          !0,
          0,
          0
          /* StorageTarget.USER */
        )), this._replaceInput.inputBox.insertAtCursor(`
`), e.preventDefault();
        return;
      }
    if (e.equals(
      2
      /* KeyCode.Tab */
    )) {
      this._findInput.focusOnCaseSensitive(), e.preventDefault();
      return;
    }
    if (e.equals(
      1026
      /* KeyCode.Tab */
    )) {
      this._findInput.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      2066
      /* KeyCode.DownArrow */
    )) {
      this._codeEditor.focus(), e.preventDefault();
      return;
    }
    if (e.equals(
      16
      /* KeyCode.UpArrow */
    ))
      return D4(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
    if (e.equals(
      18
      /* KeyCode.DownArrow */
    ))
      return I4(e, this._replaceInput.inputBox.value, this._replaceInput.inputBox.element.querySelector("textarea"));
  }
  // ----- sash
  getVerticalSashLeft(e) {
    return 0;
  }
  // ----- initialization
  _keybindingLabelFor(e) {
    const t = this._keybindingService.lookupKeybinding(e);
    return t ? ` (${t.getLabel()})` : "";
  }
  _buildDomNode() {
    this._findInput = this._register(new GI(null, this._contextViewProvider, {
      width: bfe,
      label: ofe,
      placeholder: rfe,
      appendCaseSensitiveLabel: this._keybindingLabelFor(xt.ToggleCaseSensitiveCommand),
      appendWholeWordsLabel: this._keybindingLabelFor(xt.ToggleWholeWordCommand),
      appendRegexLabel: this._keybindingLabelFor(xt.ToggleRegexCommand),
      validation: (d) => {
        if (d.length === 0 || !this._findInput.getRegex())
          return null;
        try {
          return new RegExp(d, "gu"), null;
        } catch (h) {
          return { content: h.message };
        }
      },
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showCommonFindToggles: !0,
      showHistoryHint: () => S4(this._keybindingService),
      inputBoxStyles: HC,
      toggleStyles: PC
    }, this._contextKeyService)), this._findInput.setRegex(!!this._state.isRegex), this._findInput.setCaseSensitive(!!this._state.matchCase), this._findInput.setWholeWords(!!this._state.wholeWord), this._register(this._findInput.onKeyDown((d) => this._onFindInputKeyDown(d))), this._register(this._findInput.inputBox.onDidChange(() => {
      this._ignoreChangeEvent || this._state.change({ searchString: this._findInput.getValue() }, !0);
    })), this._register(this._findInput.onDidOptionChange(() => {
      this._state.change({
        isRegex: this._findInput.getRegex(),
        wholeWord: this._findInput.getWholeWords(),
        matchCase: this._findInput.getCaseSensitive()
      }, !0);
    })), this._register(this._findInput.onCaseSensitiveKeyDown((d) => {
      d.equals(
        1026
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focus(), d.preventDefault());
    })), this._register(this._findInput.onRegexKeyDown((d) => {
      d.equals(
        2
        /* KeyCode.Tab */
      ) && this._isReplaceVisible && (this._replaceInput.focusOnPreserve(), d.preventDefault());
    })), this._register(this._findInput.inputBox.onDidHeightChange((d) => {
      this._tryUpdateHeight() && this._showViewZone();
    })), Fn && this._register(this._findInput.onMouseDown((d) => this._onFindInputMouseDown(d))), this._matchesCount = document.createElement("div"), this._matchesCount.className = "matchesCount", this._updateMatchesCount();
    const i = this._register(im());
    this._prevBtn = this._register(new bg({
      label: afe + this._keybindingLabelFor(xt.PreviousMatchFindAction),
      icon: ife,
      hoverDelegate: i,
      onTrigger: () => {
        xc(this._codeEditor.getAction(xt.PreviousMatchFindAction)).run().then(void 0, Pe);
      }
    }, this._hoverService)), this._nextBtn = this._register(new bg({
      label: lfe + this._keybindingLabelFor(xt.NextMatchFindAction),
      icon: nfe,
      hoverDelegate: i,
      onTrigger: () => {
        xc(this._codeEditor.getAction(xt.NextMatchFindAction)).run().then(void 0, Pe);
      }
    }, this._hoverService));
    const n = document.createElement("div");
    n.className = "find-part", n.appendChild(this._findInput.domNode);
    const o = document.createElement("div");
    o.className = "find-actions", n.appendChild(o), o.appendChild(this._matchesCount), o.appendChild(this._prevBtn.domNode), o.appendChild(this._nextBtn.domNode), this._toggleSelectionFind = this._register(new xm({
      icon: Zge,
      title: cfe + this._keybindingLabelFor(xt.ToggleSearchScopeCommand),
      isChecked: !1,
      hoverDelegate: i,
      inputActiveOptionBackground: oe(R_),
      inputActiveOptionBorder: oe(Q0),
      inputActiveOptionForeground: oe(G0)
    })), this._register(this._toggleSelectionFind.onChange(() => {
      if (this._toggleSelectionFind.checked) {
        if (this._codeEditor.hasModel()) {
          let d = this._codeEditor.getSelections();
          d = d.map((h) => (h.endColumn === 1 && h.endLineNumber > h.startLineNumber && (h = h.setEndPosition(h.endLineNumber - 1, this._codeEditor.getModel().getLineMaxColumn(h.endLineNumber - 1))), h.isEmpty() ? null : h)).filter((h) => !!h), d.length && this._state.change({ searchScope: d }, !0);
        }
      } else
        this._state.change({ searchScope: null }, !0);
    })), o.appendChild(this._toggleSelectionFind.domNode), this._closeBtn = this._register(new bg({
      label: dfe + this._keybindingLabelFor(xt.CloseFindWidgetCommand),
      icon: Iie,
      hoverDelegate: i,
      onTrigger: () => {
        this._state.change({ isRevealed: !1, searchScope: null }, !1);
      },
      onKeyDown: (d) => {
        d.equals(
          2
          /* KeyCode.Tab */
        ) && this._isReplaceVisible && (this._replaceBtn.isEnabled() ? this._replaceBtn.focus() : this._codeEditor.focus(), d.preventDefault());
      }
    }, this._hoverService)), this._replaceInput = this._register(new jI(null, void 0, {
      label: hfe,
      placeholder: ufe,
      appendPreserveCaseLabel: this._keybindingLabelFor(xt.TogglePreserveCaseCommand),
      history: [],
      flexibleHeight: !0,
      flexibleWidth: !0,
      flexibleMaxHeight: 118,
      showHistoryHint: () => S4(this._keybindingService),
      inputBoxStyles: HC,
      toggleStyles: PC
    }, this._contextKeyService, !0)), this._replaceInput.setPreserveCase(!!this._state.preserveCase), this._register(this._replaceInput.onKeyDown((d) => this._onReplaceInputKeyDown(d))), this._register(this._replaceInput.inputBox.onDidChange(() => {
      this._state.change({ replaceString: this._replaceInput.inputBox.value }, !1);
    })), this._register(this._replaceInput.inputBox.onDidHeightChange((d) => {
      this._isReplaceVisible && this._tryUpdateHeight() && this._showViewZone();
    })), this._register(this._replaceInput.onDidOptionChange(() => {
      this._state.change({
        preserveCase: this._replaceInput.getPreserveCase()
      }, !0);
    })), this._register(this._replaceInput.onPreserveCaseKeyDown((d) => {
      d.equals(
        2
        /* KeyCode.Tab */
      ) && (this._prevBtn.isEnabled() ? this._prevBtn.focus() : this._nextBtn.isEnabled() ? this._nextBtn.focus() : this._toggleSelectionFind.enabled ? this._toggleSelectionFind.focus() : this._closeBtn.isEnabled() && this._closeBtn.focus(), d.preventDefault());
    }));
    const r = this._register(im());
    this._replaceBtn = this._register(new bg({
      label: gfe + this._keybindingLabelFor(xt.ReplaceOneAction),
      icon: efe,
      hoverDelegate: r,
      onTrigger: () => {
        this._controller.replace();
      },
      onKeyDown: (d) => {
        d.equals(
          1026
          /* KeyCode.Tab */
        ) && (this._closeBtn.focus(), d.preventDefault());
      }
    }, this._hoverService)), this._replaceAllBtn = this._register(new bg({
      label: ffe + this._keybindingLabelFor(xt.ReplaceAllAction),
      icon: tfe,
      hoverDelegate: r,
      onTrigger: () => {
        this._controller.replaceAll();
      }
    }, this._hoverService));
    const a = document.createElement("div");
    a.className = "replace-part", a.appendChild(this._replaceInput.domNode);
    const l = document.createElement("div");
    l.className = "replace-actions", a.appendChild(l), l.appendChild(this._replaceBtn.domNode), l.appendChild(this._replaceAllBtn.domNode), this._toggleReplaceBtn = this._register(new bg({
      label: mfe,
      className: "codicon toggle left",
      onTrigger: () => {
        this._state.change({ isReplaceRevealed: !this._isReplaceVisible }, !1), this._isReplaceVisible && (this._replaceInput.width = Rs(this._findInput.domNode), this._replaceInput.inputBox.layout()), this._showViewZone();
      }
    }, this._hoverService)), this._toggleReplaceBtn.setExpanded(this._isReplaceVisible), this._domNode = document.createElement("div"), this._domNode.className = "editor-widget find-widget", this._domNode.setAttribute("aria-hidden", "true"), this._domNode.ariaLabel = sfe, this._domNode.role = "dialog", this._domNode.style.width = `${Jr}px`, this._domNode.appendChild(this._toggleReplaceBtn.domNode), this._domNode.appendChild(n), this._domNode.appendChild(this._closeBtn.domNode), this._domNode.appendChild(a), this._resizeSash = this._register(new rn(this._domNode, this, { orientation: 0, size: 2 })), this._resized = !1;
    let c = Jr;
    this._register(this._resizeSash.onDidStart(() => {
      c = Rs(this._domNode);
    })), this._register(this._resizeSash.onDidChange((d) => {
      this._resized = !0;
      const h = c + d.startX - d.currentX;
      if (h < Jr)
        return;
      const u = parseFloat(y0(this._domNode).maxWidth) || 0;
      h > u || (this._domNode.style.width = `${h}px`, this._isReplaceVisible && (this._replaceInput.width = Rs(this._findInput.domNode)), this._findInput.inputBox.layout(), this._tryUpdateHeight());
    })), this._register(this._resizeSash.onDidReset(() => {
      const d = Rs(this._domNode);
      if (d < Jr)
        return;
      let h = Jr;
      if (!this._resized || d === Jr) {
        const u = this._codeEditor.getLayoutInfo();
        h = u.width - 28 - u.minimap.minimapWidth - 15, this._resized = !0;
      }
      this._domNode.style.width = `${h}px`, this._isReplaceVisible && (this._replaceInput.width = Rs(this._findInput.domNode)), this._findInput.inputBox.layout();
    }));
  }
  updateAccessibilitySupport() {
    const e = this._codeEditor.getOption(
      2
      /* EditorOption.accessibilitySupport */
    );
    this._findInput.setFocusInputOnOptionClick(
      e !== 2
      /* AccessibilitySupport.Enabled */
    );
  }
};
g0.ID = "editor.contrib.findWidget";
let uM = g0;
class bg extends to {
  constructor(e, t) {
    super(), this._opts = e;
    let i = "button";
    this._opts.className && (i = i + " " + this._opts.className), this._opts.icon && (i = i + " " + pe.asClassName(this._opts.icon)), this._domNode = document.createElement("div"), this._domNode.tabIndex = 0, this._domNode.className = i, this._domNode.setAttribute("role", "button"), this._domNode.setAttribute("aria-label", this._opts.label), this._register(t.setupManagedHover(e.hoverDelegate ?? Ls("element"), this._domNode, this._opts.label)), this.onclick(this._domNode, (n) => {
      this._opts.onTrigger(), n.preventDefault();
    }), this.onkeydown(this._domNode, (n) => {
      if (n.equals(
        10
        /* KeyCode.Space */
      ) || n.equals(
        3
        /* KeyCode.Enter */
      )) {
        this._opts.onTrigger(), n.preventDefault();
        return;
      }
      this._opts.onKeyDown?.(n);
    });
  }
  get domNode() {
    return this._domNode;
  }
  isEnabled() {
    return this._domNode.tabIndex >= 0;
  }
  focus() {
    this._domNode.focus();
  }
  setEnabled(e) {
    this._domNode.classList.toggle("disabled", !e), this._domNode.setAttribute("aria-disabled", String(!e)), this._domNode.tabIndex = e ? 0 : -1;
  }
  setExpanded(e) {
    this._domNode.setAttribute("aria-expanded", String(!!e)), e ? (this._domNode.classList.remove(...pe.asClassNameArray(y4)), this._domNode.classList.add(...pe.asClassNameArray(x4))) : (this._domNode.classList.remove(...pe.asClassNameArray(x4)), this._domNode.classList.add(...pe.asClassNameArray(y4)));
  }
}
rr((s, e) => {
  const t = s.getColor(Lc);
  t && e.addRule(`.monaco-editor .findMatch { border: 1px ${Ca(s.type) ? "dotted" : "solid"} ${t}; box-sizing: border-box; }`);
  const i = s.getColor(Yj);
  i && e.addRule(`.monaco-editor .findScope { border: 1px ${Ca(s.type) ? "dashed" : "solid"} ${i}; }`);
  const n = s.getColor(Je);
  n && e.addRule(`.monaco-editor .find-widget { border: 1px solid ${n}; }`);
  const o = s.getColor(Gj);
  o && e.addRule(`.monaco-editor .findMatchInline { color: ${o}; }`);
  const r = s.getColor(jj);
  r && e.addRule(`.monaco-editor .currentFindMatchInline { color: ${r}; }`);
});
var s9 = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, co = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, gM;
const Cfe = 524288;
function fM(s, e = "single", t = !1) {
  if (!s.hasModel())
    return null;
  const i = s.getSelection();
  if (e === "single" && i.startLineNumber === i.endLineNumber || e === "multiple") {
    if (i.isEmpty()) {
      const n = s.getConfiguredWordAtPosition(i.getStartPosition());
      if (n && t === !1)
        return n.word;
    } else if (s.getModel().getValueLengthInRange(i) < Cfe)
      return s.getModel().getValueInRange(i);
  }
  return null;
}
var au;
let tr = (au = class extends V {
  get editor() {
    return this._editor;
  }
  static get(e) {
    return e.getContribution(gM.ID);
  }
  constructor(e, t, i, n, o, r) {
    super(), this._editor = e, this._findWidgetVisible = $l.bindTo(t), this._contextKeyService = t, this._storageService = i, this._clipboardService = n, this._notificationService = o, this._hoverService = r, this._updateHistoryDelayer = new Gl(500), this._state = this._register(new Xge()), this.loadQueryState(), this._register(this._state.onFindReplaceStateChange((a) => this._onStateChanged(a))), this._model = null, this._register(this._editor.onDidChangeModel(() => {
      const a = this._editor.getModel() && this._state.isRevealed;
      this.disposeModel(), this._state.change({
        searchScope: null,
        matchCase: this._storageService.getBoolean("editor.matchCase", 1, !1),
        wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, !1),
        isRegex: this._storageService.getBoolean("editor.isRegex", 1, !1),
        preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, !1)
      }, !1), a && this._start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: "none",
        seedSearchStringFromNonEmptySelection: !1,
        seedSearchStringFromGlobalClipboard: !1,
        shouldFocus: 0,
        shouldAnimate: !1,
        updateSearchScope: !1,
        loop: this._editor.getOption(
          41
          /* EditorOption.find */
        ).loop
      });
    }));
  }
  dispose() {
    this.disposeModel(), super.dispose();
  }
  disposeModel() {
    this._model && (this._model.dispose(), this._model = null);
  }
  _onStateChanged(e) {
    this.saveQueryState(e), e.isRevealed && (this._state.isRevealed ? this._findWidgetVisible.set(!0) : (this._findWidgetVisible.reset(), this.disposeModel())), e.searchString && this.setGlobalBufferTerm(this._state.searchString);
  }
  saveQueryState(e) {
    e.isRegex && this._storageService.store(
      "editor.isRegex",
      this._state.actualIsRegex,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.wholeWord && this._storageService.store(
      "editor.wholeWord",
      this._state.actualWholeWord,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.matchCase && this._storageService.store(
      "editor.matchCase",
      this._state.actualMatchCase,
      1,
      1
      /* StorageTarget.MACHINE */
    ), e.preserveCase && this._storageService.store(
      "editor.preserveCase",
      this._state.actualPreserveCase,
      1,
      1
      /* StorageTarget.MACHINE */
    );
  }
  loadQueryState() {
    this._state.change({
      matchCase: this._storageService.getBoolean("editor.matchCase", 1, this._state.matchCase),
      wholeWord: this._storageService.getBoolean("editor.wholeWord", 1, this._state.wholeWord),
      isRegex: this._storageService.getBoolean("editor.isRegex", 1, this._state.isRegex),
      preserveCase: this._storageService.getBoolean("editor.preserveCase", 1, this._state.preserveCase)
    }, !1);
  }
  isFindInputFocused() {
    return !!OS.getValue(this._contextKeyService);
  }
  getState() {
    return this._state;
  }
  closeFindWidget() {
    this._state.change({
      isRevealed: !1,
      searchScope: null
    }, !1), this._editor.focus();
  }
  toggleCaseSensitive() {
    this._state.change({ matchCase: !this._state.matchCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleWholeWords() {
    this._state.change({ wholeWord: !this._state.wholeWord }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleRegex() {
    this._state.change({ isRegex: !this._state.isRegex }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  togglePreserveCase() {
    this._state.change({ preserveCase: !this._state.preserveCase }, !1), this._state.isRevealed || this.highlightFindOptions();
  }
  toggleSearchScope() {
    if (this._state.searchScope)
      this._state.change({ searchScope: null }, !0);
    else if (this._editor.hasModel()) {
      let e = this._editor.getSelections();
      e = e.map((t) => (t.endColumn === 1 && t.endLineNumber > t.startLineNumber && (t = t.setEndPosition(t.endLineNumber - 1, this._editor.getModel().getLineMaxColumn(t.endLineNumber - 1))), t.isEmpty() ? null : t)).filter((t) => !!t), e.length && this._state.change({ searchScope: e }, !0);
    }
  }
  setSearchString(e) {
    this._state.isRegex && (e = So(e)), this._state.change({ searchString: e }, !1);
  }
  highlightFindOptions(e = !1) {
  }
  async _start(e, t) {
    if (this.disposeModel(), !this._editor.hasModel())
      return;
    const i = {
      ...t,
      isRevealed: !0
    };
    if (e.seedSearchStringFromSelection === "single") {
      const n = fM(this._editor, e.seedSearchStringFromSelection, e.seedSearchStringFromNonEmptySelection);
      n && (this._state.isRegex ? i.searchString = So(n) : i.searchString = n);
    } else if (e.seedSearchStringFromSelection === "multiple" && !e.updateSearchScope) {
      const n = fM(this._editor, e.seedSearchStringFromSelection);
      n && (i.searchString = n);
    }
    if (!i.searchString && e.seedSearchStringFromGlobalClipboard) {
      const n = await this.getGlobalBufferTerm();
      if (!this._editor.hasModel())
        return;
      n && (i.searchString = n);
    }
    if (e.forceRevealReplace || i.isReplaceRevealed ? i.isReplaceRevealed = !0 : this._findWidgetVisible.get() || (i.isReplaceRevealed = !1), e.updateSearchScope) {
      const n = this._editor.getSelections();
      n.some((o) => !o.isEmpty()) && (i.searchScope = n);
    }
    i.loop = e.loop, this._state.change(i, !1), this._model || (this._model = new rA(this._editor, this._state));
  }
  start(e, t) {
    return this._start(e, t);
  }
  moveToNextMatch() {
    return this._model ? (this._model.moveToNextMatch(), !0) : !1;
  }
  moveToPrevMatch() {
    return this._model ? (this._model.moveToPrevMatch(), !0) : !1;
  }
  goToMatch(e) {
    return this._model ? (this._model.moveToMatch(e), !0) : !1;
  }
  replace() {
    return this._model ? (this._model.replace(), !0) : !1;
  }
  replaceAll() {
    return this._model ? this._editor.getModel()?.isTooLargeForHeapOperation() ? (this._notificationService.warn(f("too.large.for.replaceall", "The file is too large to perform a replace all operation.")), !1) : (this._model.replaceAll(), !0) : !1;
  }
  selectAllMatches() {
    return this._model ? (this._model.selectAllMatches(), this._editor.focus(), !0) : !1;
  }
  async getGlobalBufferTerm() {
    return this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() ? this._clipboardService.readFindText() : "";
  }
  setGlobalBufferTerm(e) {
    this._editor.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard && this._editor.hasModel() && !this._editor.getModel().isTooLargeForSyncing() && this._clipboardService.writeFindText(e);
  }
}, gM = au, au.ID = "editor.contrib.findController", au);
tr = gM = s9([
  co(1, Se),
  co(2, Jl),
  co(3, Yu),
  co(4, Oi),
  co(5, jl)
], tr);
let mM = class extends tr {
  constructor(e, t, i, n, o, r, a, l, c) {
    super(e, i, a, l, r, c), this._contextViewService = t, this._keybindingService = n, this._themeService = o, this._widget = null, this._findOptionsWidget = null;
  }
  async _start(e, t) {
    this._widget || this._createFindWidget();
    const i = this._editor.getSelection();
    let n = !1;
    switch (this._editor.getOption(
      41
      /* EditorOption.find */
    ).autoFindInSelection) {
      case "always":
        n = !0;
        break;
      case "never":
        n = !1;
        break;
      case "multiline": {
        n = !!i && i.startLineNumber !== i.endLineNumber;
        break;
      }
    }
    e.updateSearchScope = e.updateSearchScope || n, await super._start(e, t), this._widget && (e.shouldFocus === 2 ? this._widget.focusReplaceInput() : e.shouldFocus === 1 && this._widget.focusFindInput());
  }
  highlightFindOptions(e = !1) {
    this._widget || this._createFindWidget(), this._state.isRevealed && !e ? this._widget.highlightFindOptions() : this._findOptionsWidget.highlightFindOptions();
  }
  _createFindWidget() {
    this._widget = this._register(new uM(this._editor, this, this._state, this._contextViewService, this._keybindingService, this._contextKeyService, this._themeService, this._storageService, this._notificationService, this._hoverService)), this._findOptionsWidget = this._register(new hM(this._editor, this._state, this._keybindingService));
  }
};
mM = s9([
  co(1, Yl),
  co(2, Se),
  co(3, bt),
  co(4, nn),
  co(5, Oi),
  co(6, Jl),
  co(7, Yu),
  co(8, jl)
], mM);
const vfe = i5(new t5({
  id: xt.StartFindAction,
  label: f("startFindAction", "Find"),
  alias: "Find",
  precondition: ne.or(R.focus, ne.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2084,
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: Qe.MenubarEditMenu,
    group: "3_find",
    title: f({ key: "miFind", comment: ["&& denotes a mnemonic"] }, "&&Find"),
    order: 1
  }
}));
vfe.addImplementation(0, (s, e, t) => {
  const i = tr.get(e);
  return i ? i.start({
    forceRevealReplace: !1,
    seedSearchStringFromSelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never" ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).globalFindClipboard,
    shouldFocus: 1,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  }) : !1;
});
const Sfe = {
  description: "Open a new In-Editor Find Widget.",
  args: [{
    name: "Open a new In-Editor Find Widget args",
    schema: {
      properties: {
        searchString: { type: "string" },
        replaceString: { type: "string" },
        isRegex: { type: "boolean" },
        matchWholeWord: { type: "boolean" },
        isCaseSensitive: { type: "boolean" },
        preserveCase: { type: "boolean" },
        findInSelection: { type: "boolean" }
      }
    }
  }]
};
class yfe extends Vt {
  constructor() {
    super({
      id: xt.StartFindWithArgs,
      label: f("startFindWithArgsAction", "Find With Arguments"),
      alias: "Find With Arguments",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: Sfe
    });
  }
  async run(e, t, i) {
    const n = tr.get(t);
    if (n) {
      const o = i ? {
        searchString: i.searchString,
        replaceString: i.replaceString,
        isReplaceRevealed: i.replaceString !== void 0,
        isRegex: i.isRegex,
        // isRegexOverride: args.regexOverride,
        wholeWord: i.matchWholeWord,
        // wholeWordOverride: args.wholeWordOverride,
        matchCase: i.isCaseSensitive,
        // matchCaseOverride: args.matchCaseOverride,
        preserveCase: i.preserveCase
        // preserveCaseOverride: args.preserveCaseOverride,
      } : {};
      await n.start({
        forceRevealReplace: !1,
        seedSearchStringFromSelection: n.getState().searchString.length === 0 && t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection !== "never" ? "single" : "none",
        seedSearchStringFromNonEmptySelection: t.getOption(
          41
          /* EditorOption.find */
        ).seedSearchStringFromSelection === "selection",
        seedSearchStringFromGlobalClipboard: !0,
        shouldFocus: 1,
        shouldAnimate: !0,
        updateSearchScope: i?.findInSelection || !1,
        loop: t.getOption(
          41
          /* EditorOption.find */
        ).loop
      }, o), n.setGlobalBufferTerm(n.getState().searchString);
    }
  }
}
class xfe extends Vt {
  constructor() {
    super({
      id: xt.StartFindWithSelection,
      label: f("startFindWithSelectionAction", "Find With Selection"),
      alias: "Find With Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: null,
        primary: 0,
        mac: {
          primary: 2083
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  async run(e, t) {
    const i = tr.get(t);
    i && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "multiple",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), i.setGlobalBufferTerm(i.getState().searchString));
  }
}
class o9 extends Vt {
  async run(e, t) {
    const i = tr.get(t);
    i && !this._run(i) && (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: i.getState().searchString.length === 0 && t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection !== "never" ? "single" : "none",
      seedSearchStringFromNonEmptySelection: t.getOption(
        41
        /* EditorOption.find */
      ).seedSearchStringFromSelection === "selection",
      seedSearchStringFromGlobalClipboard: !0,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class Efe extends o9 {
  constructor() {
    super({
      id: xt.NextMatchFindAction,
      label: f("findNextMatchAction", "Find Next"),
      alias: "Find Next",
      precondition: void 0,
      kbOpts: [{
        kbExpr: R.focus,
        primary: 61,
        mac: { primary: 2085, secondary: [
          61
          /* KeyCode.F3 */
        ] },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }, {
        kbExpr: ne.and(R.focus, OS),
        primary: 3,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }]
    });
  }
  _run(e) {
    return e.moveToNextMatch() ? (e.editor.pushUndoStop(), !0) : !1;
  }
}
class Lfe extends o9 {
  constructor() {
    super({
      id: xt.PreviousMatchFindAction,
      label: f("findPreviousMatchAction", "Find Previous"),
      alias: "Find Previous",
      precondition: void 0,
      kbOpts: [
        {
          kbExpr: R.focus,
          primary: 1085,
          mac: { primary: 3109, secondary: [
            1085
            /* KeyCode.F3 */
          ] },
          weight: 100
          /* KeybindingWeight.EditorContrib */
        },
        {
          kbExpr: ne.and(R.focus, OS),
          primary: 1027,
          weight: 100
          /* KeybindingWeight.EditorContrib */
        }
      ]
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
class kfe extends Vt {
  constructor() {
    super({
      id: xt.GoToMatchFindAction,
      label: f("findMatchAction.goToMatch", "Go to Match..."),
      alias: "Go to Match...",
      precondition: $l
    }), this._highlightDecorations = [];
  }
  run(e, t, i) {
    const n = tr.get(t);
    if (!n)
      return;
    const o = n.getState().matchesCount;
    if (o < 1) {
      e.get(Oi).notify({
        severity: H0.Warning,
        message: f("findMatchAction.noResults", "No matches. Try searching for something else.")
      });
      return;
    }
    const r = e.get(Q_), a = new X(), l = a.add(r.createInputBox());
    l.placeholder = f("findMatchAction.inputPlaceHolder", "Type a number to go to a specific match (between 1 and {0})", o);
    const c = (h) => {
      const u = parseInt(h);
      if (isNaN(u))
        return;
      const g = n.getState().matchesCount;
      if (u > 0 && u <= g)
        return u - 1;
      if (u < 0 && u >= -g)
        return g + u;
    }, d = (h) => {
      const u = c(h);
      if (typeof u == "number") {
        l.validationMessage = void 0, n.goToMatch(u);
        const g = n.getState().currentMatch;
        g && this.addDecorations(t, g);
      } else
        l.validationMessage = f("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount), this.clearDecorations(t);
    };
    a.add(l.onDidChangeValue((h) => {
      d(h);
    })), a.add(l.onDidAccept(() => {
      const h = c(l.value);
      typeof h == "number" ? (n.goToMatch(h), l.hide()) : l.validationMessage = f("findMatchAction.inputValidationMessage", "Please type a number between 1 and {0}", n.getState().matchesCount);
    })), a.add(l.onDidHide(() => {
      this.clearDecorations(t), a.dispose();
    })), l.show();
  }
  clearDecorations(e) {
    e.changeDecorations((t) => {
      this._highlightDecorations = t.deltaDecorations(this._highlightDecorations, []);
    });
  }
  addDecorations(e, t) {
    e.changeDecorations((i) => {
      this._highlightDecorations = i.deltaDecorations(this._highlightDecorations, [
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight",
            className: "rangeHighlight",
            isWholeLine: !0
          }
        },
        {
          range: t,
          options: {
            description: "find-match-quick-access-range-highlight-overview",
            overviewRuler: {
              color: Wi(kX),
              position: Bl.Full
            }
          }
        }
      ]);
    });
  }
}
class r9 extends Vt {
  async run(e, t) {
    const i = tr.get(t);
    if (!i)
      return;
    const n = fM(t, "single", !1);
    n && i.setSearchString(n), this._run(i) || (await i.start({
      forceRevealReplace: !1,
      seedSearchStringFromSelection: "none",
      seedSearchStringFromNonEmptySelection: !1,
      seedSearchStringFromGlobalClipboard: !1,
      shouldFocus: 0,
      shouldAnimate: !0,
      updateSearchScope: !1,
      loop: t.getOption(
        41
        /* EditorOption.find */
      ).loop
    }), this._run(i));
  }
}
class Dfe extends r9 {
  constructor() {
    super({
      id: xt.NextSelectionMatchFindAction,
      label: f("nextSelectionMatchFindAction", "Find Next Selection"),
      alias: "Find Next Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 2109,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToNextMatch();
  }
}
class Ife extends r9 {
  constructor() {
    super({
      id: xt.PreviousSelectionMatchFindAction,
      label: f("previousSelectionMatchFindAction", "Find Previous Selection"),
      alias: "Find Previous Selection",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.focus,
        primary: 3133,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  _run(e) {
    return e.moveToPrevMatch();
  }
}
const Mfe = i5(new t5({
  id: xt.StartFindReplaceAction,
  label: f("startReplace", "Replace"),
  alias: "Replace",
  precondition: ne.or(R.focus, ne.has("editorIsOpen")),
  kbOpts: {
    kbExpr: null,
    primary: 2086,
    mac: {
      primary: 2596
      /* KeyCode.KeyF */
    },
    weight: 100
    /* KeybindingWeight.EditorContrib */
  },
  menuOpts: {
    menuId: Qe.MenubarEditMenu,
    group: "3_find",
    title: f({ key: "miReplace", comment: ["&& denotes a mnemonic"] }, "&&Replace"),
    order: 2
  }
}));
Mfe.addImplementation(0, (s, e, t) => {
  if (!e.hasModel() || e.getOption(
    92
    /* EditorOption.readOnly */
  ))
    return !1;
  const i = tr.get(e);
  if (!i)
    return !1;
  const n = e.getSelection(), o = i.isFindInputFocused(), r = !n.isEmpty() && n.startLineNumber === n.endLineNumber && e.getOption(
    41
    /* EditorOption.find */
  ).seedSearchStringFromSelection !== "never" && !o, a = o || r ? 2 : 1;
  return i.start({
    forceRevealReplace: !0,
    seedSearchStringFromSelection: r ? "single" : "none",
    seedSearchStringFromNonEmptySelection: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection === "selection",
    seedSearchStringFromGlobalClipboard: e.getOption(
      41
      /* EditorOption.find */
    ).seedSearchStringFromSelection !== "never",
    shouldFocus: a,
    shouldAnimate: !0,
    updateSearchScope: !1,
    loop: e.getOption(
      41
      /* EditorOption.find */
    ).loop
  });
});
rs(
  tr.ID,
  mM,
  0
  /* EditorContributionInstantiation.Eager */
);
Ge(yfe);
Ge(xfe);
Ge(Efe);
Ge(Lfe);
Ge(kfe);
Ge(Dfe);
Ge(Ife);
const Vr = Wn.bindToContribution(tr.get);
re(new Vr({
  id: xt.CloseFindWidgetCommand,
  precondition: $l,
  handler: (s) => s.closeFindWidget(),
  kbOpts: {
    weight: 105,
    kbExpr: ne.and(R.focus, ne.not("isComposing")),
    primary: 9,
    secondary: [
      1033
      /* KeyCode.Escape */
    ]
  }
}));
re(new Vr({
  id: xt.ToggleCaseSensitiveCommand,
  precondition: void 0,
  handler: (s) => s.toggleCaseSensitive(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: ow.primary,
    mac: ow.mac,
    win: ow.win,
    linux: ow.linux
  }
}));
re(new Vr({
  id: xt.ToggleWholeWordCommand,
  precondition: void 0,
  handler: (s) => s.toggleWholeWords(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: rw.primary,
    mac: rw.mac,
    win: rw.win,
    linux: rw.linux
  }
}));
re(new Vr({
  id: xt.ToggleRegexCommand,
  precondition: void 0,
  handler: (s) => s.toggleRegex(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: aw.primary,
    mac: aw.mac,
    win: aw.win,
    linux: aw.linux
  }
}));
re(new Vr({
  id: xt.ToggleSearchScopeCommand,
  precondition: void 0,
  handler: (s) => s.toggleSearchScope(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: lw.primary,
    mac: lw.mac,
    win: lw.win,
    linux: lw.linux
  }
}));
re(new Vr({
  id: xt.TogglePreserveCaseCommand,
  precondition: void 0,
  handler: (s) => s.togglePreserveCase(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: cw.primary,
    mac: cw.mac,
    win: cw.win,
    linux: cw.linux
  }
}));
re(new Vr({
  id: xt.ReplaceOneAction,
  precondition: $l,
  handler: (s) => s.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: 3094
    /* KeyCode.Digit1 */
  }
}));
re(new Vr({
  id: xt.ReplaceOneAction,
  precondition: $l,
  handler: (s) => s.replace(),
  kbOpts: {
    weight: 105,
    kbExpr: ne.and(R.focus, SB),
    primary: 3
    /* KeyCode.Enter */
  }
}));
re(new Vr({
  id: xt.ReplaceAllAction,
  precondition: $l,
  handler: (s) => s.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: 2563
    /* KeyCode.Enter */
  }
}));
re(new Vr({
  id: xt.ReplaceAllAction,
  precondition: $l,
  handler: (s) => s.replaceAll(),
  kbOpts: {
    weight: 105,
    kbExpr: ne.and(R.focus, SB),
    primary: void 0,
    mac: {
      primary: 2051
    }
  }
}));
re(new Vr({
  id: xt.SelectAllMatchesAction,
  precondition: $l,
  handler: (s) => s.selectAllMatches(),
  kbOpts: {
    weight: 105,
    kbExpr: R.focus,
    primary: 515
    /* KeyCode.Enter */
  }
}));
var Nfe = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, Wd = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, pM, lu;
let E_ = (lu = class {
  static get(e) {
    return e.getContribution(pM.ID);
  }
  constructor(e, t, i, n, o, r, a, l) {
    this._contextMenuService = t, this._contextViewService = i, this._contextKeyService = n, this._keybindingService = o, this._menuService = r, this._configurationService = a, this._workspaceContextService = l, this._toDispose = new X(), this._contextMenuIsBeingShownCount = 0, this._editor = e, this._toDispose.add(this._editor.onContextMenu((c) => this._onContextMenu(c))), this._toDispose.add(this._editor.onMouseWheel((c) => {
      if (this._contextMenuIsBeingShownCount > 0) {
        const d = this._contextViewService.getContextViewElement(), h = c.srcElement;
        h.shadowRoot && pu(d) === h.shadowRoot || this._contextViewService.hideContextView();
      }
    })), this._toDispose.add(this._editor.onKeyDown((c) => {
      this._editor.getOption(
        24
        /* EditorOption.contextmenu */
      ) && c.keyCode === 58 && (c.preventDefault(), c.stopPropagation(), this.showContextMenu());
    }));
  }
  _onContextMenu(e) {
    if (!this._editor.hasModel())
      return;
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    )) {
      this._editor.focus(), e.target.position && !this._editor.getSelection().containsPosition(e.target.position) && this._editor.setPosition(e.target.position);
      return;
    }
    if (e.target.type === 12 || e.target.type === 6 && e.target.detail.injectedText)
      return;
    if (e.event.preventDefault(), e.event.stopPropagation(), e.target.type === 11)
      return this._showScrollbarContextMenu(e.event);
    if (e.target.type !== 6 && e.target.type !== 7 && e.target.type !== 1)
      return;
    if (this._editor.focus(), e.target.position) {
      let i = !1;
      for (const n of this._editor.getSelections())
        if (n.containsPosition(e.target.position)) {
          i = !0;
          break;
        }
      i || this._editor.setPosition(e.target.position);
    }
    let t = null;
    e.target.type !== 1 && (t = e.event), this.showContextMenu(t);
  }
  showContextMenu(e) {
    if (!this._editor.getOption(
      24
      /* EditorOption.contextmenu */
    ) || !this._editor.hasModel())
      return;
    const t = this._getMenuActions(this._editor.getModel(), this._editor.contextMenuId);
    t.length > 0 && this._doShowContextMenu(t, e);
  }
  _getMenuActions(e, t) {
    const i = [], n = this._menuService.getMenuActions(t, this._contextKeyService, { arg: e.uri });
    for (const o of n) {
      const [, r] = o;
      let a = 0;
      for (const l of r)
        if (l instanceof mf) {
          const c = this._getMenuActions(e, l.item.submenu);
          c.length > 0 && (i.push(new Uf(l.id, l.label, c)), a++);
        } else
          i.push(l), a++;
      a && i.push(new Ri());
    }
    return i.length && i.pop(), i;
  }
  _doShowContextMenu(e, t = null) {
    if (!this._editor.hasModel())
      return;
    const i = this._editor.getOption(
      60
      /* EditorOption.hover */
    );
    this._editor.updateOptions({
      hover: {
        enabled: !1
      }
    });
    let n = t;
    if (!n) {
      this._editor.revealPosition(
        this._editor.getPosition(),
        1
        /* ScrollType.Immediate */
      ), this._editor.render();
      const r = this._editor.getScrolledVisiblePosition(this._editor.getPosition()), a = ui(this._editor.getDomNode()), l = a.left + r.left, c = a.top + r.top + r.height;
      n = { x: l, y: c };
    }
    const o = this._editor.getOption(
      128
      /* EditorOption.useShadowDOM */
    ) && !Ea;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: o ? this._editor.getOverflowWidgetsDomNode() ?? this._editor.getDomNode() : void 0,
      getAnchor: () => n,
      getActions: () => e,
      getActionViewItem: (r) => {
        const a = this._keybindingFor(r);
        if (a)
          return new nm(r, r, { label: !0, keybinding: a.getLabel(), isMenu: !0 });
        const l = r;
        return typeof l.getActionViewItem == "function" ? l.getActionViewItem() : new nm(r, r, { icon: !0, label: !0, isMenu: !0 });
      },
      getKeyBinding: (r) => this._keybindingFor(r),
      onHide: (r) => {
        this._contextMenuIsBeingShownCount--, this._editor.updateOptions({
          hover: i
        });
      }
    });
  }
  _showScrollbarContextMenu(e) {
    if (!this._editor.hasModel() || Pq(this._workspaceContextService.getWorkspace()))
      return;
    const t = this._editor.getOption(
      73
      /* EditorOption.minimap */
    );
    let i = 0;
    const n = (c) => ({
      id: `menu-action-${++i}`,
      label: c.label,
      tooltip: "",
      class: void 0,
      enabled: typeof c.enabled > "u" ? !0 : c.enabled,
      checked: c.checked,
      run: c.run
    }), o = (c, d) => new Uf(`menu-action-${++i}`, c, d, void 0), r = (c, d, h, u, g) => {
      if (!d)
        return n({ label: c, enabled: d, run: () => {
        } });
      const m = (A) => () => {
        this._configurationService.updateValue(h, A);
      }, p = [];
      for (const A of g)
        p.push(n({
          label: A.label,
          checked: u === A.value,
          run: m(A.value)
        }));
      return o(c, p);
    }, a = [];
    a.push(n({
      label: f("context.minimap.minimap", "Minimap"),
      checked: t.enabled,
      run: () => {
        this._configurationService.updateValue("editor.minimap.enabled", !t.enabled);
      }
    })), a.push(new Ri()), a.push(n({
      label: f("context.minimap.renderCharacters", "Render Characters"),
      enabled: t.enabled,
      checked: t.renderCharacters,
      run: () => {
        this._configurationService.updateValue("editor.minimap.renderCharacters", !t.renderCharacters);
      }
    })), a.push(r(f("context.minimap.size", "Vertical size"), t.enabled, "editor.minimap.size", t.size, [{
      label: f("context.minimap.size.proportional", "Proportional"),
      value: "proportional"
    }, {
      label: f("context.minimap.size.fill", "Fill"),
      value: "fill"
    }, {
      label: f("context.minimap.size.fit", "Fit"),
      value: "fit"
    }])), a.push(r(f("context.minimap.slider", "Slider"), t.enabled, "editor.minimap.showSlider", t.showSlider, [{
      label: f("context.minimap.slider.mouseover", "Mouse Over"),
      value: "mouseover"
    }, {
      label: f("context.minimap.slider.always", "Always"),
      value: "always"
    }]));
    const l = this._editor.getOption(
      128
      /* EditorOption.useShadowDOM */
    ) && !Ea;
    this._contextMenuIsBeingShownCount++, this._contextMenuService.showContextMenu({
      domForShadowRoot: l ? this._editor.getDomNode() : void 0,
      getAnchor: () => e,
      getActions: () => a,
      onHide: (c) => {
        this._contextMenuIsBeingShownCount--, this._editor.focus();
      }
    });
  }
  _keybindingFor(e) {
    return this._keybindingService.lookupKeybinding(e.id);
  }
  dispose() {
    this._contextMenuIsBeingShownCount > 0 && this._contextViewService.hideContextView(), this._toDispose.dispose();
  }
}, pM = lu, lu.ID = "editor.contrib.contextmenu", lu);
E_ = pM = Nfe([
  Wd(1, ar),
  Wd(2, Yl),
  Wd(3, Se),
  Wd(4, bt),
  Wd(5, sr),
  Wd(6, ht),
  Wd(7, BC)
], E_);
class Tfe extends Vt {
  constructor() {
    super({
      id: "editor.action.showContextMenu",
      label: f("action.showContextMenu.label", "Show Editor Context Menu"),
      alias: "Show Editor Context Menu",
      precondition: void 0,
      kbOpts: {
        kbExpr: R.textInputFocus,
        primary: 1092,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  run(e, t) {
    E_.get(t)?.showContextMenu();
  }
}
rs(
  E_.ID,
  E_,
  2
  /* EditorContributionInstantiation.BeforeFirstInteraction */
);
Ge(Tfe);
const Bfe = {
  0: " ",
  1: "u",
  2: "r"
}, M4 = 65535, Sr = 16777215, N4 = 4278190080;
class wx {
  constructor(e) {
    const t = Math.ceil(e / 32);
    this._states = new Uint32Array(t);
  }
  get(e) {
    const t = e / 32 | 0, i = e % 32;
    return (this._states[t] & 1 << i) !== 0;
  }
  set(e, t) {
    const i = e / 32 | 0, n = e % 32, o = this._states[i];
    t ? this._states[i] = o | 1 << n : this._states[i] = o & ~(1 << n);
  }
}
class Hs {
  constructor(e, t, i) {
    if (e.length !== t.length || e.length > M4)
      throw new Error("invalid startIndexes or endIndexes size");
    this._startIndexes = e, this._endIndexes = t, this._collapseStates = new wx(e.length), this._userDefinedStates = new wx(e.length), this._recoveredStates = new wx(e.length), this._types = i, this._parentsComputed = !1;
  }
  ensureParentIndices() {
    if (!this._parentsComputed) {
      this._parentsComputed = !0;
      const e = [], t = (i, n) => {
        const o = e[e.length - 1];
        return this.getStartLineNumber(o) <= i && this.getEndLineNumber(o) >= n;
      };
      for (let i = 0, n = this._startIndexes.length; i < n; i++) {
        const o = this._startIndexes[i], r = this._endIndexes[i];
        if (o > Sr || r > Sr)
          throw new Error("startLineNumber or endLineNumber must not exceed " + Sr);
        for (; e.length > 0 && !t(o, r); )
          e.pop();
        const a = e.length > 0 ? e[e.length - 1] : -1;
        e.push(i), this._startIndexes[i] = o + ((a & 255) << 24), this._endIndexes[i] = r + ((a & 65280) << 16);
      }
    }
  }
  get length() {
    return this._startIndexes.length;
  }
  getStartLineNumber(e) {
    return this._startIndexes[e] & Sr;
  }
  getEndLineNumber(e) {
    return this._endIndexes[e] & Sr;
  }
  getType(e) {
    return this._types ? this._types[e] : void 0;
  }
  hasTypes() {
    return !!this._types;
  }
  isCollapsed(e) {
    return this._collapseStates.get(e);
  }
  setCollapsed(e, t) {
    this._collapseStates.set(e, t);
  }
  isUserDefined(e) {
    return this._userDefinedStates.get(e);
  }
  setUserDefined(e, t) {
    return this._userDefinedStates.set(e, t);
  }
  isRecovered(e) {
    return this._recoveredStates.get(e);
  }
  setRecovered(e, t) {
    return this._recoveredStates.set(e, t);
  }
  getSource(e) {
    return this.isUserDefined(e) ? 1 : this.isRecovered(e) ? 2 : 0;
  }
  setSource(e, t) {
    t === 1 ? (this.setUserDefined(e, !0), this.setRecovered(e, !1)) : t === 2 ? (this.setUserDefined(e, !1), this.setRecovered(e, !0)) : (this.setUserDefined(e, !1), this.setRecovered(e, !1));
  }
  setCollapsedAllOfType(e, t) {
    let i = !1;
    if (this._types)
      for (let n = 0; n < this._types.length; n++)
        this._types[n] === e && (this.setCollapsed(n, t), i = !0);
    return i;
  }
  toRegion(e) {
    return new Rfe(this, e);
  }
  getParentIndex(e) {
    this.ensureParentIndices();
    const t = ((this._startIndexes[e] & N4) >>> 24) + ((this._endIndexes[e] & N4) >>> 16);
    return t === M4 ? -1 : t;
  }
  contains(e, t) {
    return this.getStartLineNumber(e) <= t && this.getEndLineNumber(e) >= t;
  }
  findIndex(e) {
    let t = 0, i = this._startIndexes.length;
    if (i === 0)
      return -1;
    for (; t < i; ) {
      const n = Math.floor((t + i) / 2);
      e < this.getStartLineNumber(n) ? i = n : t = n + 1;
    }
    return t - 1;
  }
  findRange(e) {
    let t = this.findIndex(e);
    if (t >= 0) {
      if (this.getEndLineNumber(t) >= e)
        return t;
      for (t = this.getParentIndex(t); t !== -1; ) {
        if (this.contains(t, e))
          return t;
        t = this.getParentIndex(t);
      }
    }
    return -1;
  }
  toString() {
    const e = [];
    for (let t = 0; t < this.length; t++)
      e[t] = `[${Bfe[this.getSource(t)]}${this.isCollapsed(t) ? "+" : "-"}] ${this.getStartLineNumber(t)}/${this.getEndLineNumber(t)}`;
    return e.join(", ");
  }
  toFoldRange(e) {
    return {
      startLineNumber: this._startIndexes[e] & Sr,
      endLineNumber: this._endIndexes[e] & Sr,
      type: this._types ? this._types[e] : void 0,
      isCollapsed: this.isCollapsed(e),
      source: this.getSource(e)
    };
  }
  static fromFoldRanges(e) {
    const t = e.length, i = new Uint32Array(t), n = new Uint32Array(t);
    let o = [], r = !1;
    for (let l = 0; l < t; l++) {
      const c = e[l];
      i[l] = c.startLineNumber, n[l] = c.endLineNumber, o.push(c.type), c.type && (r = !0);
    }
    r || (o = void 0);
    const a = new Hs(i, n, o);
    for (let l = 0; l < t; l++)
      e[l].isCollapsed && a.setCollapsed(l, !0), a.setSource(l, e[l].source);
    return a;
  }
  /**
   * Two inputs, each a FoldingRegions or a FoldRange[], are merged.
   * Each input must be pre-sorted on startLineNumber.
   * The first list is assumed to always include all regions currently defined by range providers.
   * The second list only contains the previously collapsed and all manual ranges.
   * If the line position matches, the range of the new range is taken, and the range is no longer manual
   * When an entry in one list overlaps an entry in the other, the second list's entry "wins" and
   * overlapping entries in the first list are discarded.
   * Invalid entries are discarded. An entry is invalid if:
   * 		the start and end line numbers aren't a valid range of line numbers,
   * 		it is out of sequence or has the same start line as a preceding entry,
   * 		it overlaps a preceding entry and is not fully contained by that entry.
   */
  static sanitizeAndMerge(e, t, i, n) {
    i = i ?? Number.MAX_VALUE;
    const o = (A, _) => Array.isArray(A) ? (b) => b < _ ? A[b] : void 0 : (b) => b < _ ? A.toFoldRange(b) : void 0, r = o(e, e.length), a = o(t, t.length);
    let l = 0, c = 0, d = r(0), h = a(0);
    const u = [];
    let g, m = 0;
    const p = [];
    for (; d || h; ) {
      let A;
      if (h && (!d || d.startLineNumber >= h.startLineNumber))
        d && d.startLineNumber === h.startLineNumber ? (h.source === 1 ? A = h : (A = d, A.isCollapsed = h.isCollapsed && (d.endLineNumber === h.endLineNumber || !n?.startsInside(d.startLineNumber + 1, d.endLineNumber + 1)), A.source = 0), d = r(++l)) : (A = h, h.isCollapsed && h.source === 0 && (A.source = 2)), h = a(++c);
      else {
        let _ = c, b = h;
        for (; ; ) {
          if (!b || b.startLineNumber > d.endLineNumber) {
            A = d;
            break;
          }
          if (b.source === 1 && b.endLineNumber > d.endLineNumber)
            break;
          b = a(++_);
        }
        d = r(++l);
      }
      if (A) {
        for (; g && g.endLineNumber < A.startLineNumber; )
          g = u.pop();
        A.endLineNumber > A.startLineNumber && A.startLineNumber > m && A.endLineNumber <= i && (!g || g.endLineNumber >= A.endLineNumber) && (p.push(A), m = A.startLineNumber, g && u.push(g), g = A);
      }
    }
    return p;
  }
}
class Rfe {
  constructor(e, t) {
    this.ranges = e, this.index = t;
  }
  get startLineNumber() {
    return this.ranges.getStartLineNumber(this.index);
  }
  get endLineNumber() {
    return this.ranges.getEndLineNumber(this.index);
  }
  get regionIndex() {
    return this.index;
  }
  get parentIndex() {
    return this.ranges.getParentIndex(this.index);
  }
  get isCollapsed() {
    return this.ranges.isCollapsed(this.index);
  }
  containedBy(e) {
    return e.startLineNumber <= this.startLineNumber && e.endLineNumber >= this.endLineNumber;
  }
  containsLine(e) {
    return this.startLineNumber <= e && e <= this.endLineNumber;
  }
}
class Ffe {
  get regions() {
    return this._regions;
  }
  get textModel() {
    return this._textModel;
  }
  constructor(e, t) {
    this._updateEventEmitter = new B(), this.onDidChange = this._updateEventEmitter.event, this._textModel = e, this._decorationProvider = t, this._regions = new Hs(new Uint32Array(0), new Uint32Array(0)), this._editorDecorationIds = [];
  }
  toggleCollapseState(e) {
    if (!e.length)
      return;
    e = e.sort((i, n) => i.regionIndex - n.regionIndex);
    const t = {};
    this._decorationProvider.changeDecorations((i) => {
      let n = 0, o = -1, r = -1;
      const a = (l) => {
        for (; n < l; ) {
          const c = this._regions.getEndLineNumber(n), d = this._regions.isCollapsed(n);
          if (c <= o) {
            const h = this.regions.getSource(n) !== 0;
            i.changeDecorationOptions(this._editorDecorationIds[n], this._decorationProvider.getDecorationOption(d, c <= r, h));
          }
          d && c > r && (r = c), n++;
        }
      };
      for (const l of e) {
        const c = l.regionIndex, d = this._editorDecorationIds[c];
        if (d && !t[d]) {
          t[d] = !0, a(c);
          const h = !this._regions.isCollapsed(c);
          this._regions.setCollapsed(c, h), o = Math.max(o, this._regions.getEndLineNumber(c));
        }
      }
      a(this._regions.length);
    }), this._updateEventEmitter.fire({ model: this, collapseStateChanged: e });
  }
  removeManualRanges(e) {
    const t = new Array(), i = (n) => {
      for (const o of e)
        if (!(o.startLineNumber > n.endLineNumber || n.startLineNumber > o.endLineNumber))
          return !0;
      return !1;
    };
    for (let n = 0; n < this._regions.length; n++) {
      const o = this._regions.toFoldRange(n);
      (o.source === 0 || !i(o)) && t.push(o);
    }
    this.updatePost(Hs.fromFoldRanges(t));
  }
  update(e, t) {
    const i = this._currentFoldedOrManualRanges(t), n = Hs.sanitizeAndMerge(e, i, this._textModel.getLineCount(), t);
    this.updatePost(Hs.fromFoldRanges(n));
  }
  updatePost(e) {
    const t = [];
    let i = -1;
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e.getStartLineNumber(n), a = e.getEndLineNumber(n), l = e.isCollapsed(n), c = e.getSource(n) !== 0, d = {
        startLineNumber: r,
        startColumn: this._textModel.getLineMaxColumn(r),
        endLineNumber: a,
        endColumn: this._textModel.getLineMaxColumn(a) + 1
      };
      t.push({ range: d, options: this._decorationProvider.getDecorationOption(l, a <= i, c) }), l && a > i && (i = a);
    }
    this._decorationProvider.changeDecorations((n) => this._editorDecorationIds = n.deltaDecorations(this._editorDecorationIds, t)), this._regions = e, this._updateEventEmitter.fire({ model: this });
  }
  _currentFoldedOrManualRanges(e) {
    const t = [];
    for (let i = 0, n = this._regions.length; i < n; i++) {
      let o = this.regions.isCollapsed(i);
      const r = this.regions.getSource(i);
      if (o || r !== 0) {
        const a = this._regions.toFoldRange(i), l = this._textModel.getDecorationRange(this._editorDecorationIds[i]);
        l && (o && e?.startsInside(l.startLineNumber + 1, l.endLineNumber) && (o = !1), t.push({
          startLineNumber: l.startLineNumber,
          endLineNumber: l.endLineNumber,
          type: a.type,
          isCollapsed: o,
          source: r
        }));
      }
    }
    return t;
  }
  /**
   * Collapse state memento, for persistence only
   */
  getMemento() {
    const e = this._currentFoldedOrManualRanges(), t = [], i = this._textModel.getLineCount();
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      if (r.startLineNumber >= r.endLineNumber || r.startLineNumber < 1 || r.endLineNumber > i)
        continue;
      const a = this._getLinesChecksum(r.startLineNumber + 1, r.endLineNumber);
      t.push({
        startLineNumber: r.startLineNumber,
        endLineNumber: r.endLineNumber,
        isCollapsed: r.isCollapsed,
        source: r.source,
        checksum: a
      });
    }
    return t.length > 0 ? t : void 0;
  }
  /**
   * Apply persisted state, for persistence only
   */
  applyMemento(e) {
    if (!Array.isArray(e))
      return;
    const t = [], i = this._textModel.getLineCount();
    for (const o of e) {
      if (o.startLineNumber >= o.endLineNumber || o.startLineNumber < 1 || o.endLineNumber > i)
        continue;
      const r = this._getLinesChecksum(o.startLineNumber + 1, o.endLineNumber);
      (!o.checksum || r === o.checksum) && t.push({
        startLineNumber: o.startLineNumber,
        endLineNumber: o.endLineNumber,
        type: void 0,
        isCollapsed: o.isCollapsed ?? !0,
        source: o.source ?? 0
        /* FoldSource.provider */
      });
    }
    const n = Hs.sanitizeAndMerge(this._regions, t, i);
    this.updatePost(Hs.fromFoldRanges(n));
  }
  _getLinesChecksum(e, t) {
    return C0(this._textModel.getLineContent(e) + this._textModel.getLineContent(t)) % 1e6;
  }
  dispose() {
    this._decorationProvider.removeDecorations(this._editorDecorationIds);
  }
  getAllRegionsAtLine(e, t) {
    const i = [];
    if (this._regions) {
      let n = this._regions.findRange(e), o = 1;
      for (; n >= 0; ) {
        const r = this._regions.toRegion(n);
        (!t || t(r, o)) && i.push(r), o++, n = r.parentIndex;
      }
    }
    return i;
  }
  getRegionAtLine(e) {
    if (this._regions) {
      const t = this._regions.findRange(e);
      if (t >= 0)
        return this._regions.toRegion(t);
    }
    return null;
  }
  getRegionsInside(e, t) {
    const i = [], n = e ? e.regionIndex + 1 : 0, o = e ? e.endLineNumber : Number.MAX_VALUE;
    if (t && t.length === 2) {
      const r = [];
      for (let a = n, l = this._regions.length; a < l; a++) {
        const c = this._regions.toRegion(a);
        if (this._regions.getStartLineNumber(a) < o) {
          for (; r.length > 0 && !c.containedBy(r[r.length - 1]); )
            r.pop();
          r.push(c), t(c, r.length) && i.push(c);
        } else
          break;
      }
    } else
      for (let r = n, a = this._regions.length; r < a; r++) {
        const l = this._regions.toRegion(r);
        if (this._regions.getStartLineNumber(r) < o)
          (!t || t(l)) && i.push(l);
        else
          break;
      }
    return i;
  }
}
function a9(s, e, t) {
  const i = [];
  for (const n of t) {
    const o = s.getRegionAtLine(n);
    if (o) {
      const r = !o.isCollapsed;
      if (i.push(o), e > 1) {
        const a = s.getRegionsInside(o, (l, c) => l.isCollapsed !== r && c < e);
        i.push(...a);
      }
    }
  }
  s.toggleCollapseState(i);
}
function Nm(s, e, t = Number.MAX_VALUE, i) {
  const n = [];
  if (i && i.length > 0)
    for (const o of i) {
      const r = s.getRegionAtLine(o);
      if (r && (r.isCollapsed !== e && n.push(r), t > 1)) {
        const a = s.getRegionsInside(r, (l, c) => l.isCollapsed !== e && c < t);
        n.push(...a);
      }
    }
  else {
    const o = s.getRegionsInside(null, (r, a) => r.isCollapsed !== e && a < t);
    n.push(...o);
  }
  s.toggleCollapseState(n);
}
function l9(s, e, t, i) {
  const n = [];
  for (const o of i) {
    const r = s.getAllRegionsAtLine(o, (a, l) => a.isCollapsed !== e && l <= t);
    n.push(...r);
  }
  s.toggleCollapseState(n);
}
function Ofe(s, e, t) {
  const i = [];
  for (const n of t) {
    const o = s.getAllRegionsAtLine(n, (r) => r.isCollapsed !== e);
    o.length > 0 && i.push(o[0]);
  }
  s.toggleCollapseState(i);
}
function Pfe(s, e, t, i) {
  const n = (r, a) => a === e && r.isCollapsed !== t && !i.some((l) => r.containsLine(l)), o = s.getRegionsInside(null, n);
  s.toggleCollapseState(o);
}
function c9(s, e, t) {
  const i = [];
  for (const r of t) {
    const a = s.getAllRegionsAtLine(r, void 0);
    a.length > 0 && i.push(a[0]);
  }
  const n = (r) => i.every((a) => !a.containedBy(r) && !r.containedBy(a)) && r.isCollapsed !== e, o = s.getRegionsInside(null, n);
  s.toggleCollapseState(o);
}
function yB(s, e, t) {
  const i = s.textModel, n = s.regions, o = [];
  for (let r = n.length - 1; r >= 0; r--)
    if (t !== n.isCollapsed(r)) {
      const a = n.getStartLineNumber(r);
      e.test(i.getLineContent(a)) && o.push(n.toRegion(r));
    }
  s.toggleCollapseState(o);
}
function xB(s, e, t) {
  const i = s.regions, n = [];
  for (let o = i.length - 1; o >= 0; o--)
    t !== i.isCollapsed(o) && e === i.getType(o) && n.push(i.toRegion(o));
  s.toggleCollapseState(n);
}
function Hfe(s, e) {
  let t = null;
  const i = e.getRegionAtLine(s);
  if (i !== null && (t = i.startLineNumber, s === t)) {
    const n = i.parentIndex;
    n !== -1 ? t = e.regions.getStartLineNumber(n) : t = null;
  }
  return t;
}
function Wfe(s, e) {
  let t = e.getRegionAtLine(s);
  if (t !== null && t.startLineNumber === s) {
    if (s !== t.startLineNumber)
      return t.startLineNumber;
    {
      const i = t.parentIndex;
      let n = 0;
      for (i !== -1 && (n = e.regions.getStartLineNumber(t.parentIndex)); t !== null; )
        if (t.regionIndex > 0) {
          if (t = e.regions.toRegion(t.regionIndex - 1), t.startLineNumber <= n)
            return null;
          if (t.parentIndex === i)
            return t.startLineNumber;
        } else
          return null;
    }
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(e.regions.length - 1); t !== null; ) {
      if (t.startLineNumber < s)
        return t.startLineNumber;
      t.regionIndex > 0 ? t = e.regions.toRegion(t.regionIndex - 1) : t = null;
    }
  return null;
}
function Vfe(s, e) {
  let t = e.getRegionAtLine(s);
  if (t !== null && t.startLineNumber === s) {
    const i = t.parentIndex;
    let n = 0;
    if (i !== -1)
      n = e.regions.getEndLineNumber(t.parentIndex);
    else {
      if (e.regions.length === 0)
        return null;
      n = e.regions.getEndLineNumber(e.regions.length - 1);
    }
    for (; t !== null; )
      if (t.regionIndex < e.regions.length) {
        if (t = e.regions.toRegion(t.regionIndex + 1), t.startLineNumber >= n)
          return null;
        if (t.parentIndex === i)
          return t.startLineNumber;
      } else
        return null;
  } else if (e.regions.length > 0)
    for (t = e.regions.toRegion(0); t !== null; ) {
      if (t.startLineNumber > s)
        return t.startLineNumber;
      t.regionIndex < e.regions.length ? t = e.regions.toRegion(t.regionIndex + 1) : t = null;
    }
  return null;
}
class zfe {
  get onDidChange() {
    return this._updateEventEmitter.event;
  }
  get hiddenRanges() {
    return this._hiddenRanges;
  }
  constructor(e) {
    this._updateEventEmitter = new B(), this._hasLineChanges = !1, this._foldingModel = e, this._foldingModelListener = e.onDidChange((t) => this.updateHiddenRanges()), this._hiddenRanges = [], e.regions.length && this.updateHiddenRanges();
  }
  notifyChangeModelContent(e) {
    this._hiddenRanges.length && !this._hasLineChanges && (this._hasLineChanges = e.changes.some((t) => t.range.endLineNumber !== t.range.startLineNumber || bu(t.text)[0] !== 0));
  }
  updateHiddenRanges() {
    let e = !1;
    const t = [];
    let i = 0, n = 0, o = Number.MAX_VALUE, r = -1;
    const a = this._foldingModel.regions;
    for (; i < a.length; i++) {
      if (!a.isCollapsed(i))
        continue;
      const l = a.getStartLineNumber(i) + 1, c = a.getEndLineNumber(i);
      o <= l && c <= r || (!e && n < this._hiddenRanges.length && this._hiddenRanges[n].startLineNumber === l && this._hiddenRanges[n].endLineNumber === c ? (t.push(this._hiddenRanges[n]), n++) : (e = !0, t.push(new E(l, 1, c, 1))), o = l, r = c);
    }
    (this._hasLineChanges || e || n < this._hiddenRanges.length) && this.applyHiddenRanges(t);
  }
  applyHiddenRanges(e) {
    this._hiddenRanges = e, this._hasLineChanges = !1, this._updateEventEmitter.fire(e);
  }
  hasRanges() {
    return this._hiddenRanges.length > 0;
  }
  isHidden(e) {
    return T4(this._hiddenRanges, e) !== null;
  }
  adjustSelections(e) {
    let t = !1;
    const i = this._foldingModel.textModel;
    let n = null;
    const o = (r) => ((!n || !Ufe(r, n)) && (n = T4(this._hiddenRanges, r)), n ? n.startLineNumber - 1 : null);
    for (let r = 0, a = e.length; r < a; r++) {
      let l = e[r];
      const c = o(l.startLineNumber);
      c && (l = l.setStartPosition(c, i.getLineMaxColumn(c)), t = !0);
      const d = o(l.endLineNumber);
      d && (l = l.setEndPosition(d, i.getLineMaxColumn(d)), t = !0), e[r] = l;
    }
    return t;
  }
  dispose() {
    this.hiddenRanges.length > 0 && (this._hiddenRanges = [], this._updateEventEmitter.fire(this._hiddenRanges)), this._foldingModelListener && (this._foldingModelListener.dispose(), this._foldingModelListener = null);
  }
}
function Ufe(s, e) {
  return s >= e.startLineNumber && s <= e.endLineNumber;
}
function T4(s, e) {
  const t = OA(s, (i) => e < i.startLineNumber) - 1;
  return t >= 0 && s[t].endLineNumber >= e ? s[t] : null;
}
const Qfe = 5e3, Gfe = "indent";
class d9 {
  constructor(e, t, i) {
    this.editorModel = e, this.languageConfigurationService = t, this.foldingRangesLimit = i, this.id = Gfe;
  }
  dispose() {
  }
  compute(e) {
    const t = this.languageConfigurationService.getLanguageConfiguration(this.editorModel.getLanguageId()).foldingRules, i = t && !!t.offSide, n = t && t.markers;
    return Promise.resolve(Kfe(this.editorModel, i, n, this.foldingRangesLimit));
  }
}
let jfe = class {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._indentOccurrences = [], this._length = 0, this._foldingRangesLimit = e;
  }
  insertFirst(e, t, i) {
    if (e > Sr || t > Sr)
      return;
    const n = this._length;
    this._startIndexes[n] = e, this._endIndexes[n] = t, this._length++, i < 1e3 && (this._indentOccurrences[i] = (this._indentOccurrences[i] || 0) + 1);
  }
  toIndentRanges(e) {
    const t = this._foldingRangesLimit.limit;
    if (this._length <= t) {
      this._foldingRangesLimit.update(this._length, !1);
      const i = new Uint32Array(this._length), n = new Uint32Array(this._length);
      for (let o = this._length - 1, r = 0; o >= 0; o--, r++)
        i[r] = this._startIndexes[o], n[r] = this._endIndexes[o];
      return new Hs(i, n);
    } else {
      this._foldingRangesLimit.update(this._length, t);
      let i = 0, n = this._indentOccurrences.length;
      for (let l = 0; l < this._indentOccurrences.length; l++) {
        const c = this._indentOccurrences[l];
        if (c) {
          if (c + i > t) {
            n = l;
            break;
          }
          i += c;
        }
      }
      const o = e.getOptions().tabSize, r = new Uint32Array(t), a = new Uint32Array(t);
      for (let l = this._length - 1, c = 0; l >= 0; l--) {
        const d = this._startIndexes[l], h = e.getLineContent(d), u = dS(h, o);
        (u < n || u === n && i++ < t) && (r[c] = d, a[c] = this._endIndexes[l], c++);
      }
      return new Hs(r, a);
    }
  }
};
const Yfe = {
  limit: Qfe,
  update: () => {
  }
};
function Kfe(s, e, t, i = Yfe) {
  const n = s.getOptions().tabSize, o = new jfe(i);
  let r;
  t && (r = new RegExp(`(${t.start.source})|(?:${t.end.source})`));
  const a = [], l = s.getLineCount() + 1;
  a.push({ indent: -1, endAbove: l, line: l });
  for (let c = s.getLineCount(); c > 0; c--) {
    const d = s.getLineContent(c), h = dS(d, n);
    let u = a[a.length - 1];
    if (h === -1) {
      e && (u.endAbove = c);
      continue;
    }
    let g;
    if (r && (g = d.match(r)))
      if (g[1]) {
        let m = a.length - 1;
        for (; m > 0 && a[m].indent !== -2; )
          m--;
        if (m > 0) {
          a.length = m + 1, u = a[m], o.insertFirst(c, u.line, h), u.line = c, u.indent = h, u.endAbove = c;
          continue;
        }
      } else {
        a.push({ indent: -2, endAbove: c, line: c });
        continue;
      }
    if (u.indent > h) {
      do
        a.pop(), u = a[a.length - 1];
      while (u.indent > h);
      const m = u.endAbove - 1;
      m - c >= 1 && o.insertFirst(c, m, h);
    }
    u.indent === h ? u.endAbove = c : a.push({ indent: h, endAbove: c, line: c });
  }
  return o.toIndentRanges(s);
}
const Jfe = L("editor.foldBackground", { light: Me(Ec, 0.3), dark: Me(Ec, 0.3), hcDark: null, hcLight: null }, f("foldBackgroundBackground", "Background color behind folded ranges. The color must not be opaque so as not to hide underlying decorations."), !0);
L("editor.foldPlaceholderForeground", { light: "#808080", dark: "#808080", hcDark: null, hcLight: null }, f("collapsedTextColor", "Color of the collapsed text after the first line of a folded range."));
L("editorGutter.foldingControlForeground", CC, f("editorGutter.foldingControlForeground", "Color of the folding control in the editor gutter."));
const AM = Rt("folding-expanded", Z.chevronDown, f("foldingExpandedIcon", "Icon for expanded ranges in the editor glyph margin.")), _M = Rt("folding-collapsed", Z.chevronRight, f("foldingCollapsedIcon", "Icon for collapsed ranges in the editor glyph margin.")), B4 = Rt("folding-manual-collapsed", _M, f("foldingManualCollapedIcon", "Icon for manually collapsed ranges in the editor glyph margin.")), R4 = Rt("folding-manual-expanded", AM, f("foldingManualExpandedIcon", "Icon for manually expanded ranges in the editor glyph margin.")), Cx = {
  color: Wi(Jfe),
  position: 1
  /* MinimapPosition.Inline */
}, wg = f("linesCollapsed", "Click to expand the range."), hw = f("linesExpanded", "Click to collapse the range."), mi = class mi {
  constructor(e) {
    this.editor = e, this.showFoldingControls = "mouseover", this.showFoldingHighlights = !0;
  }
  getDecorationOption(e, t, i) {
    return t ? mi.HIDDEN_RANGE_DECORATION : this.showFoldingControls === "never" ? e ? this.showFoldingHighlights ? mi.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION : mi.NO_CONTROLS_COLLAPSED_RANGE_DECORATION : mi.NO_CONTROLS_EXPANDED_RANGE_DECORATION : e ? i ? this.showFoldingHighlights ? mi.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : mi.MANUALLY_COLLAPSED_VISUAL_DECORATION : this.showFoldingHighlights ? mi.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION : mi.COLLAPSED_VISUAL_DECORATION : this.showFoldingControls === "mouseover" ? i ? mi.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION : mi.EXPANDED_AUTO_HIDE_VISUAL_DECORATION : i ? mi.MANUALLY_EXPANDED_VISUAL_DECORATION : mi.EXPANDED_VISUAL_DECORATION;
  }
  changeDecorations(e) {
    return this.editor.changeDecorations(e);
  }
  removeDecorations(e) {
    this.editor.removeDecorations(e);
  }
};
mi.COLLAPSED_VISUAL_DECORATION = He.register({
  description: "folding-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wg,
  firstLineDecorationClassName: pe.asClassName(_M)
}), mi.COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = He.register({
  description: "folding-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Cx,
  isWholeLine: !0,
  linesDecorationsTooltip: wg,
  firstLineDecorationClassName: pe.asClassName(_M)
}), mi.MANUALLY_COLLAPSED_VISUAL_DECORATION = He.register({
  description: "folding-manually-collapsed-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wg,
  firstLineDecorationClassName: pe.asClassName(B4)
}), mi.MANUALLY_COLLAPSED_HIGHLIGHTED_VISUAL_DECORATION = He.register({
  description: "folding-manually-collapsed-highlighted-visual-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Cx,
  isWholeLine: !0,
  linesDecorationsTooltip: wg,
  firstLineDecorationClassName: pe.asClassName(B4)
}), mi.NO_CONTROLS_COLLAPSED_RANGE_DECORATION = He.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  isWholeLine: !0,
  linesDecorationsTooltip: wg
}), mi.NO_CONTROLS_COLLAPSED_HIGHLIGHTED_RANGE_DECORATION = He.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  afterContentClassName: "inline-folded",
  className: "folded-background",
  minimap: Cx,
  isWholeLine: !0,
  linesDecorationsTooltip: wg
}), mi.EXPANDED_VISUAL_DECORATION = He.register({
  description: "folding-expanded-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + pe.asClassName(AM),
  linesDecorationsTooltip: hw
}), mi.EXPANDED_AUTO_HIDE_VISUAL_DECORATION = He.register({
  description: "folding-expanded-auto-hide-visual-decoration",
  stickiness: 1,
  isWholeLine: !0,
  firstLineDecorationClassName: pe.asClassName(AM),
  linesDecorationsTooltip: hw
}), mi.MANUALLY_EXPANDED_VISUAL_DECORATION = He.register({
  description: "folding-manually-expanded-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: "alwaysShowFoldIcons " + pe.asClassName(R4),
  linesDecorationsTooltip: hw
}), mi.MANUALLY_EXPANDED_AUTO_HIDE_VISUAL_DECORATION = He.register({
  description: "folding-manually-expanded-auto-hide-visual-decoration",
  stickiness: 0,
  isWholeLine: !0,
  firstLineDecorationClassName: pe.asClassName(R4),
  linesDecorationsTooltip: hw
}), mi.NO_CONTROLS_EXPANDED_RANGE_DECORATION = He.register({
  description: "folding-no-controls-range-decoration",
  stickiness: 0,
  isWholeLine: !0
}), mi.HIDDEN_RANGE_DECORATION = He.register({
  description: "folding-hidden-range-decoration",
  stickiness: 1
  /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */
});
let bM = mi;
const qfe = {}, $fe = "syntax";
class h9 {
  constructor(e, t, i, n, o) {
    this.editorModel = e, this.providers = t, this.handleFoldingRangesChange = i, this.foldingRangesLimit = n, this.fallbackRangeProvider = o, this.id = $fe, this.disposables = new X(), o && this.disposables.add(o);
    for (const r of t)
      typeof r.onDidChange == "function" && this.disposables.add(r.onDidChange(i));
  }
  compute(e) {
    return Xfe(this.providers, this.editorModel, e).then((t) => t ? eme(t, this.foldingRangesLimit) : this.fallbackRangeProvider?.compute(e) ?? null);
  }
  dispose() {
    this.disposables.dispose();
  }
}
function Xfe(s, e, t) {
  let i = null;
  const n = s.map((o, r) => Promise.resolve(o.provideFoldingRanges(e, qfe, t)).then((a) => {
    if (!t.isCancellationRequested && Array.isArray(a)) {
      Array.isArray(i) || (i = []);
      const l = e.getLineCount();
      for (const c of a)
        c.start > 0 && c.end > c.start && c.end <= l && i.push({ start: c.start, end: c.end, rank: r, kind: c.kind });
    }
  }, xs));
  return Promise.all(n).then((o) => i);
}
class Zfe {
  constructor(e) {
    this._startIndexes = [], this._endIndexes = [], this._nestingLevels = [], this._nestingLevelCounts = [], this._types = [], this._length = 0, this._foldingRangesLimit = e;
  }
  add(e, t, i, n) {
    if (e > Sr || t > Sr)
      return;
    const o = this._length;
    this._startIndexes[o] = e, this._endIndexes[o] = t, this._nestingLevels[o] = n, this._types[o] = i, this._length++, n < 30 && (this._nestingLevelCounts[n] = (this._nestingLevelCounts[n] || 0) + 1);
  }
  toIndentRanges() {
    const e = this._foldingRangesLimit.limit;
    if (this._length <= e) {
      this._foldingRangesLimit.update(this._length, !1);
      const t = new Uint32Array(this._length), i = new Uint32Array(this._length);
      for (let n = 0; n < this._length; n++)
        t[n] = this._startIndexes[n], i[n] = this._endIndexes[n];
      return new Hs(t, i, this._types);
    } else {
      this._foldingRangesLimit.update(this._length, e);
      let t = 0, i = this._nestingLevelCounts.length;
      for (let a = 0; a < this._nestingLevelCounts.length; a++) {
        const l = this._nestingLevelCounts[a];
        if (l) {
          if (l + t > e) {
            i = a;
            break;
          }
          t += l;
        }
      }
      const n = new Uint32Array(e), o = new Uint32Array(e), r = [];
      for (let a = 0, l = 0; a < this._length; a++) {
        const c = this._nestingLevels[a];
        (c < i || c === i && t++ < e) && (n[l] = this._startIndexes[a], o[l] = this._endIndexes[a], r[l] = this._types[a], l++);
      }
      return new Hs(n, o, r);
    }
  }
}
function eme(s, e) {
  const t = s.sort((r, a) => {
    let l = r.start - a.start;
    return l === 0 && (l = r.rank - a.rank), l;
  }), i = new Zfe(e);
  let n;
  const o = [];
  for (const r of t)
    if (!n)
      n = r, i.add(r.start, r.end, r.kind && r.kind.value, o.length);
    else if (r.start > n.start)
      if (r.end <= n.end)
        o.push(n), n = r, i.add(r.start, r.end, r.kind && r.kind.value, o.length);
      else {
        if (r.start > n.end) {
          do
            n = o.pop();
          while (n && r.start > n.end);
          n && o.push(n), n = r;
        }
        i.add(r.start, r.end, r.kind && r.kind.value, o.length);
      }
  return i.toIndentRanges();
}
var tme = function(s, e, t, i) {
  var n = arguments.length, o = n < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, r;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function") o = Reflect.decorate(s, e, t, i);
  else for (var a = s.length - 1; a >= 0; a--) (r = s[a]) && (o = (n < 3 ? r(o) : n > 3 ? r(e, t, o) : r(e, t)) || o);
  return n > 3 && o && Object.defineProperty(e, t, o), o;
}, cp = function(s, e) {
  return function(t, i) {
    e(t, i, s);
  };
}, kp;
const sn = new le("foldingEnabled", !1);
var cu;
let fm = (cu = class extends V {
  static get(e) {
    return e.getContribution(kp.ID);
  }
  static getFoldingRangeProviders(e, t) {
    const i = e.foldingRangeProvider.ordered(t);
    return kp._foldingRangeSelector?.(i, t) ?? i;
  }
  constructor(e, t, i, n, o, r) {
    super(), this.contextKeyService = t, this.languageConfigurationService = i, this.languageFeaturesService = r, this.localToDispose = this._register(new X()), this.editor = e, this._foldingLimitReporter = new ime(e);
    const a = this.editor.getOptions();
    this._isEnabled = a.get(
      43
      /* EditorOption.folding */
    ), this._useFoldingProviders = a.get(
      44
      /* EditorOption.foldingStrategy */
    ) !== "indentation", this._unfoldOnClickAfterEndOfLine = a.get(
      48
      /* EditorOption.unfoldOnClickAfterEndOfLine */
    ), this._restoringViewState = !1, this._currentModelHasFoldedImports = !1, this._foldingImportsByDefault = a.get(
      46
      /* EditorOption.foldingImportsByDefault */
    ), this.updateDebounceInfo = o.for(r.foldingRangeProvider, "Folding", { min: 200 }), this.foldingModel = null, this.hiddenRangeModel = null, this.rangeProvider = null, this.foldingRegionPromise = null, this.foldingModelPromise = null, this.updateScheduler = null, this.cursorChangedScheduler = null, this.mouseDownInfo = null, this.foldingDecorationProvider = new bM(e), this.foldingDecorationProvider.showFoldingControls = a.get(
      111
      /* EditorOption.showFoldingControls */
    ), this.foldingDecorationProvider.showFoldingHighlights = a.get(
      45
      /* EditorOption.foldingHighlight */
    ), this.foldingEnabled = sn.bindTo(this.contextKeyService), this.foldingEnabled.set(this._isEnabled), this._register(this.editor.onDidChangeModel(() => this.onModelChanged())), this._register(this.editor.onDidChangeConfiguration((l) => {
      if (l.hasChanged(
        43
        /* EditorOption.folding */
      ) && (this._isEnabled = this.editor.getOptions().get(
        43
        /* EditorOption.folding */
      ), this.foldingEnabled.set(this._isEnabled), this.onModelChanged()), l.hasChanged(
        47
        /* EditorOption.foldingMaximumRegions */
      ) && this.onModelChanged(), l.hasChanged(
        111
        /* EditorOption.showFoldingControls */
      ) || l.hasChanged(
        45
        /* EditorOption.foldingHighlight */
      )) {
        const c = this.editor.getOptions();
        this.foldingDecorationProvider.showFoldingControls = c.get(
          111
          /* EditorOption.showFoldingControls */
        ), this.foldingDecorationProvider.showFoldingHighlights = c.get(
          45
          /* EditorOption.foldingHighlight */
        ), this.triggerFoldingModelChanged();
      }
      l.hasChanged(
        44
        /* EditorOption.foldingStrategy */
      ) && (this._useFoldingProviders = this.editor.getOptions().get(
        44
        /* EditorOption.foldingStrategy */
      ) !== "indentation", this.onFoldingStrategyChanged()), l.hasChanged(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      ) && (this._unfoldOnClickAfterEndOfLine = this.editor.getOptions().get(
        48
        /* EditorOption.unfoldOnClickAfterEndOfLine */
      )), l.hasChanged(
        46
        /* EditorOption.foldingImportsByDefault */
      ) && (this._foldingImportsByDefault = this.editor.getOptions().get(
        46
        /* EditorOption.foldingImportsByDefault */
      ));
    })), this.onModelChanged();
  }
  /**
   * Store view state.
   */
  saveViewState() {
    const e = this.editor.getModel();
    if (!e || !this._isEnabled || e.isTooLargeForTokenization())
      return {};
    if (this.foldingModel) {
      const t = this.foldingModel.getMemento(), i = this.rangeProvider ? this.rangeProvider.id : void 0;
      return { collapsedRegions: t, lineCount: e.getLineCount(), provider: i, foldedImports: this._currentModelHasFoldedImports };
    }
  }
  /**
   * Restore view state.
   */
  restoreViewState(e) {
    const t = this.editor.getModel();
    if (!(!t || !this._isEnabled || t.isTooLargeForTokenization() || !this.hiddenRangeModel) && e && (this._currentModelHasFoldedImports = !!e.foldedImports, e.collapsedRegions && e.collapsedRegions.length > 0 && this.foldingModel)) {
      this._restoringViewState = !0;
      try {
        this.foldingModel.applyMemento(e.collapsedRegions);
      } finally {
        this._restoringViewState = !1;
      }
    }
  }
  onModelChanged() {
    this.localToDispose.clear();
    const e = this.editor.getModel();
    !this._isEnabled || !e || e.isTooLargeForTokenization() || (this._currentModelHasFoldedImports = !1, this.foldingModel = new Ffe(e, this.foldingDecorationProvider), this.localToDispose.add(this.foldingModel), this.hiddenRangeModel = new zfe(this.foldingModel), this.localToDispose.add(this.hiddenRangeModel), this.localToDispose.add(this.hiddenRangeModel.onDidChange((t) => this.onHiddenRangesChanges(t))), this.updateScheduler = new Gl(this.updateDebounceInfo.get(e)), this.cursorChangedScheduler = new zt(() => this.revealCursor(), 200), this.localToDispose.add(this.cursorChangedScheduler), this.localToDispose.add(this.languageFeaturesService.foldingRangeProvider.onDidChange(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelLanguageConfiguration(() => this.onFoldingStrategyChanged())), this.localToDispose.add(this.editor.onDidChangeModelContent((t) => this.onDidChangeModelContent(t))), this.localToDispose.add(this.editor.onDidChangeCursorPosition(() => this.onCursorPositionChanged())), this.localToDispose.add(this.editor.onMouseDown((t) => this.onEditorMouseDown(t))), this.localToDispose.add(this.editor.onMouseUp((t) => this.onEditorMouseUp(t))), this.localToDispose.add({
      dispose: () => {
        this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.updateScheduler?.cancel(), this.updateScheduler = null, this.foldingModel = null, this.foldingModelPromise = null, this.hiddenRangeModel = null, this.cursorChangedScheduler = null, this.rangeProvider?.dispose(), this.rangeProvider = null;
      }
    }), this.triggerFoldingModelChanged());
  }
  onFoldingStrategyChanged() {
    this.rangeProvider?.dispose(), this.rangeProvider = null, this.triggerFoldingModelChanged();
  }
  getRangeProvider(e) {
    if (this.rangeProvider)
      return this.rangeProvider;
    const t = new d9(e, this.languageConfigurationService, this._foldingLimitReporter);
    if (this.rangeProvider = t, this._useFoldingProviders && this.foldingModel) {
      const i = kp.getFoldingRangeProviders(this.languageFeaturesService, e);
      i.length > 0 && (this.rangeProvider = new h9(e, i, () => this.triggerFoldingModelChanged(), this._foldingLimitReporter, t));
    }
    return this.rangeProvider;
  }
  getFoldingModel() {
    return this.foldingModelPromise;
  }
  onDidChangeModelContent(e) {
    this.hiddenRangeModel?.notifyChangeModelContent(e), this.triggerFoldingModelChanged();
  }
  triggerFoldingModelChanged() {
    this.updateScheduler && (this.foldingRegionPromise && (this.foldingRegionPromise.cancel(), this.foldingRegionPromise = null), this.foldingModelPromise = this.updateScheduler.trigger(() => {
      const e = this.foldingModel;
      if (!e)
        return null;
      const t = new es(), i = this.getRangeProvider(e.textModel), n = this.foldingRegionPromise = ir((o) => i.compute(o));
      return n.then((o) => {
        if (o && n === this.foldingRegionPromise) {
          let r;
          if (this._foldingImportsByDefault && !this._currentModelHasFoldedImports) {
            const c = o.setCollapsedAllOfType(nd.Imports.value, !0);
            c && (r = gd.capture(this.editor), this._currentModelHasFoldedImports = c);
          }
          const a = this.editor.getSelections();
          e.update(o, nme(a)), r?.restore(this.editor);
          const l = this.updateDebounceInfo.update(e.textModel, t.elapsed());
          this.updateScheduler && (this.updateScheduler.defaultDelay = l);
        }
        return e;
      });
    }).then(void 0, (e) => (Pe(e), null)));
  }
  onHiddenRangesChanges(e) {
    if (this.hiddenRangeModel && e.length && !this._restoringViewState) {
      const t = this.editor.getSelections();
      t && this.hiddenRangeModel.adjustSelections(t) && this.editor.setSelections(t);
    }
    this.editor.setHiddenAreas(e, this);
  }
  onCursorPositionChanged() {
    this.hiddenRangeModel && this.hiddenRangeModel.hasRanges() && this.cursorChangedScheduler.schedule();
  }
  revealCursor() {
    const e = this.getFoldingModel();
    e && e.then((t) => {
      if (t) {
        const i = this.editor.getSelections();
        if (i && i.length > 0) {
          const n = [];
          for (const o of i) {
            const r = o.selectionStartLineNumber;
            this.hiddenRangeModel && this.hiddenRangeModel.isHidden(r) && n.push(...t.getAllRegionsAtLine(r, (a) => a.isCollapsed && r > a.startLineNumber));
          }
          n.length && (t.toggleCollapseState(n), this.reveal(i[0].getPosition()));
        }
      }
    }).then(void 0, Pe);
  }
  onEditorMouseDown(e) {
    if (this.mouseDownInfo = null, !this.hiddenRangeModel || !e.target || !e.target.range || !e.event.leftButton && !e.event.middleButton)
      return;
    const t = e.target.range;
    let i = !1;
    switch (e.target.type) {
      case 4: {
        const n = e.target.detail, o = e.target.element.offsetLeft;
        if (n.offsetX - o < 4)
          return;
        i = !0;
        break;
      }
      case 7: {
        if (this._unfoldOnClickAfterEndOfLine && this.hiddenRangeModel.hasRanges() && !e.target.detail.isAfterLines)
          break;
        return;
      }
      case 6: {
        if (this.hiddenRangeModel.hasRanges()) {
          const n = this.editor.getModel();
          if (n && t.startColumn === n.getLineMaxColumn(t.startLineNumber))
            break;
        }
        return;
      }
      default:
        return;
    }
    this.mouseDownInfo = { lineNumber: t.startLineNumber, iconClicked: i };
  }
  onEditorMouseUp(e) {
    const t = this.foldingModel;
    if (!t || !this.mouseDownInfo || !e.target)
      return;
    const i = this.mouseDownInfo.lineNumber, n = this.mouseDownInfo.iconClicked, o = e.target.range;
    if (!o || o.startLineNumber !== i)
      return;
    if (n) {
      if (e.target.type !== 4)
        return;
    } else {
      const a = this.editor.getModel();
      if (!a || o.startColumn !== a.getLineMaxColumn(i))
        return;
    }
    const r = t.getRegionAtLine(i);
    if (r && r.startLineNumber === i) {
      const a = r.isCollapsed;
      if (n || a) {
        const l = e.event.altKey;
        let c = [];
        if (l) {
          const d = (u) => !u.containedBy(r) && !r.containedBy(u), h = t.getRegionsInside(null, d);
          for (const u of h)
            u.isCollapsed && c.push(u);
          c.length === 0 && (c = h);
        } else {
          const d = e.event.middleButton || e.event.shiftKey;
          if (d)
            for (const h of t.getRegionsInside(r))
              h.isCollapsed === a && c.push(h);
          (a || !d || c.length === 0) && c.push(r);
        }
        t.toggleCollapseState(c), this.reveal({ lineNumber: i, column: 1 });
      }
    }
  }
  reveal(e) {
    this.editor.revealPositionInCenterIfOutsideViewport(
      e,
      0
      /* ScrollType.Smooth */
    );
  }
}, kp = cu, cu.ID = "editor.contrib.folding", cu);
fm = kp = tme([
  cp(1, Se),
  cp(2, tn),
  cp(3, Oi),
  cp(4, W0),
  cp(5, ye)
], fm);
class ime {
  constructor(e) {
    this.editor = e, this._onDidChange = new B(), this._computed = 0, this._limited = !1;
  }
  get limit() {
    return this.editor.getOptions().get(
      47
      /* EditorOption.foldingMaximumRegions */
    );
  }
  update(e, t) {
    (e !== this._computed || t !== this._limited) && (this._computed = e, this._limited = t, this._onDidChange.fire());
  }
}
class un extends Vt {
  runEditorCommand(e, t, i) {
    const n = e.get(tn), o = fm.get(t);
    if (!o)
      return;
    const r = o.getFoldingModel();
    if (r)
      return this.reportTelemetry(e, t), r.then((a) => {
        if (a) {
          this.invoke(o, a, t, i, n);
          const l = t.getSelection();
          l && o.reveal(l.getStartPosition());
        }
      });
  }
  getSelectedLines(e) {
    const t = e.getSelections();
    return t ? t.map((i) => i.startLineNumber) : [];
  }
  getLineNumbers(e, t) {
    return e && e.selectionLines ? e.selectionLines.map((i) => i + 1) : this.getSelectedLines(t);
  }
  run(e, t) {
  }
}
function nme(s) {
  return !s || s.length === 0 ? {
    startsInside: () => !1
  } : {
    startsInside(e, t) {
      for (const i of s) {
        const n = i.startLineNumber;
        if (n >= e && n <= t)
          return !0;
      }
      return !1;
    }
  };
}
function u9(s) {
  if (!Mn(s)) {
    if (!Ti(s))
      return !1;
    const e = s;
    if (!Mn(e.levels) && !id(e.levels) || !Mn(e.direction) && !_s(e.direction) || !Mn(e.selectionLines) && (!Array.isArray(e.selectionLines) || !e.selectionLines.every(id)))
      return !1;
  }
  return !0;
}
class sme extends un {
  constructor() {
    super({
      id: "editor.unfold",
      label: f("unfoldAction.label", "Unfold"),
      alias: "Unfold",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 3166,
        mac: {
          primary: 2654
          /* KeyCode.BracketRight */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Unfold the content in the editor",
        args: [
          {
            name: "Unfold editor argument",
            description: `Property-value pairs that can be passed through this argument:
						* 'levels': Number of levels to unfold. If not set, defaults to 1.
						* 'direction': If 'up', unfold given number of levels up otherwise unfolds down.
						* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the unfold action to. If not set, the active selection(s) will be used.
						`,
            constraint: u9,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number",
                  default: 1
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"],
                  default: "down"
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const o = n && n.levels || 1, r = this.getLineNumbers(n, i);
    n && n.direction === "up" ? l9(t, !1, o, r) : Nm(t, !1, o, r);
  }
}
class ome extends un {
  constructor() {
    super({
      id: "editor.unfoldRecursively",
      label: f("unFoldRecursivelyAction.label", "Unfold Recursively"),
      alias: "Unfold Recursively",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2142
          /* KeyCode.BracketRight */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n) {
    Nm(t, !1, Number.MAX_VALUE, this.getSelectedLines(i));
  }
}
class rme extends un {
  constructor() {
    super({
      id: "editor.fold",
      label: f("foldAction.label", "Fold"),
      alias: "Fold",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 3164,
        mac: {
          primary: 2652
          /* KeyCode.BracketLeft */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      metadata: {
        description: "Fold the content in the editor",
        args: [
          {
            name: "Fold editor argument",
            description: `Property-value pairs that can be passed through this argument:
							* 'levels': Number of levels to fold.
							* 'direction': If 'up', folds given number of levels up otherwise folds down.
							* 'selectionLines': Array of the start lines (0-based) of the editor selections to apply the fold action to. If not set, the active selection(s) will be used.
							If no levels or direction is set, folds the region at the locations or if already collapsed, the first uncollapsed parent instead.
						`,
            constraint: u9,
            schema: {
              type: "object",
              properties: {
                levels: {
                  type: "number"
                },
                direction: {
                  type: "string",
                  enum: ["up", "down"]
                },
                selectionLines: {
                  type: "array",
                  items: {
                    type: "number"
                  }
                }
              }
            }
          }
        ]
      }
    });
  }
  invoke(e, t, i, n) {
    const o = this.getLineNumbers(n, i), r = n && n.levels, a = n && n.direction;
    typeof r != "number" && typeof a != "string" ? Ofe(t, !0, o) : a === "up" ? l9(t, !0, r || 1, o) : Nm(t, !0, r || 1, o);
  }
}
class ame extends un {
  constructor() {
    super({
      id: "editor.toggleFold",
      label: f("toggleFoldAction.label", "Toggle Fold"),
      alias: "Toggle Fold",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2090
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    a9(t, 1, n);
  }
}
class lme extends un {
  constructor() {
    super({
      id: "editor.foldRecursively",
      label: f("foldRecursivelyAction.label", "Fold Recursively"),
      alias: "Fold Recursively",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2140
          /* KeyCode.BracketLeft */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    Nm(t, !0, Number.MAX_VALUE, n);
  }
}
class cme extends un {
  constructor() {
    super({
      id: "editor.toggleFoldRecursively",
      label: f("toggleFoldRecursivelyAction.label", "Toggle Fold Recursively"),
      alias: "Toggle Fold Recursively",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          3114
          /* KeyCode.KeyL */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    a9(t, Number.MAX_VALUE, n);
  }
}
class dme extends un {
  constructor() {
    super({
      id: "editor.foldAllBlockComments",
      label: f("foldAllBlockComments.label", "Fold All Block Comments"),
      alias: "Fold All Block Comments",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2138
          /* KeyCode.Slash */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, o) {
    if (t.regions.hasTypes())
      xB(t, nd.Comment.value, !0);
    else {
      const r = i.getModel();
      if (!r)
        return;
      const a = o.getLanguageConfiguration(r.getLanguageId()).comments;
      if (a && a.blockCommentStartToken) {
        const l = new RegExp("^\\s*" + So(a.blockCommentStartToken));
        yB(t, l, !0);
      }
    }
  }
}
class hme extends un {
  constructor() {
    super({
      id: "editor.foldAllMarkerRegions",
      label: f("foldAllMarkerRegions.label", "Fold All Regions"),
      alias: "Fold All Regions",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2077
          /* KeyCode.Digit8 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, o) {
    if (t.regions.hasTypes())
      xB(t, nd.Region.value, !0);
    else {
      const r = i.getModel();
      if (!r)
        return;
      const a = o.getLanguageConfiguration(r.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        yB(t, l, !0);
      }
    }
  }
}
class ume extends un {
  constructor() {
    super({
      id: "editor.unfoldAllMarkerRegions",
      label: f("unfoldAllMarkerRegions.label", "Unfold All Regions"),
      alias: "Unfold All Regions",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2078
          /* KeyCode.Digit9 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i, n, o) {
    if (t.regions.hasTypes())
      xB(t, nd.Region.value, !1);
    else {
      const r = i.getModel();
      if (!r)
        return;
      const a = o.getLanguageConfiguration(r.getLanguageId()).foldingRules;
      if (a && a.markers && a.markers.start) {
        const l = new RegExp(a.markers.start);
        yB(t, l, !1);
      }
    }
  }
}
class gme extends un {
  constructor() {
    super({
      id: "editor.foldAllExcept",
      label: f("foldAllExcept.label", "Fold All Except Selected"),
      alias: "Fold All Except Selected",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2136
          /* KeyCode.Minus */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    c9(t, !0, n);
  }
}
class fme extends un {
  constructor() {
    super({
      id: "editor.unfoldAllExcept",
      label: f("unfoldAllExcept.label", "Unfold All Except Selected"),
      alias: "Unfold All Except Selected",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2134
          /* KeyCode.Equal */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    c9(t, !1, n);
  }
}
class mme extends un {
  constructor() {
    super({
      id: "editor.foldAll",
      label: f("foldAllAction.label", "Fold All"),
      alias: "Fold All",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2069
          /* KeyCode.Digit0 */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    Nm(t, !0);
  }
}
class pme extends un {
  constructor() {
    super({
      id: "editor.unfoldAll",
      label: f("unfoldAllAction.label", "Unfold All"),
      alias: "Unfold All",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2088
          /* KeyCode.KeyJ */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    Nm(t, !1);
  }
}
const cf = class cf extends un {
  getFoldingLevel() {
    return parseInt(this.id.substr(cf.ID_PREFIX.length));
  }
  invoke(e, t, i) {
    Pfe(t, this.getFoldingLevel(), !0, this.getSelectedLines(i));
  }
};
cf.ID_PREFIX = "editor.foldLevel", cf.ID = (e) => cf.ID_PREFIX + e;
let d1 = cf;
class Ame extends un {
  constructor() {
    super({
      id: "editor.gotoParentFold",
      label: f("gotoParentFold.label", "Go to Parent Fold"),
      alias: "Go to Parent Fold",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const o = Hfe(n[0], t);
      o !== null && i.setSelection({
        startLineNumber: o,
        startColumn: 1,
        endLineNumber: o,
        endColumn: 1
      });
    }
  }
}
class _me extends un {
  constructor() {
    super({
      id: "editor.gotoPreviousFold",
      label: f("gotoPreviousFold.label", "Go to Previous Folding Range"),
      alias: "Go to Previous Folding Range",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const o = Wfe(n[0], t);
      o !== null && i.setSelection({
        startLineNumber: o,
        startColumn: 1,
        endLineNumber: o,
        endColumn: 1
      });
    }
  }
}
class bme extends un {
  constructor() {
    super({
      id: "editor.gotoNextFold",
      label: f("gotoNextFold.label", "Go to Next Folding Range"),
      alias: "Go to Next Folding Range",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = this.getSelectedLines(i);
    if (n.length > 0) {
      const o = Vfe(n[0], t);
      o !== null && i.setSelection({
        startLineNumber: o,
        startColumn: 1,
        endLineNumber: o,
        endColumn: 1
      });
    }
  }
}
class wme extends un {
  constructor() {
    super({
      id: "editor.createFoldingRangeFromSelection",
      label: f("createManualFoldRange.label", "Create Folding Range from Selection"),
      alias: "Create Folding Range from Selection",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2135
          /* KeyCode.Comma */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = [], o = i.getSelections();
    if (o) {
      for (const r of o) {
        let a = r.endLineNumber;
        r.endColumn === 1 && --a, a > r.startLineNumber && (n.push({
          startLineNumber: r.startLineNumber,
          endLineNumber: a,
          type: void 0,
          isCollapsed: !0,
          source: 1
          /* FoldSource.userDefined */
        }), i.setSelection({
          startLineNumber: r.startLineNumber,
          startColumn: 1,
          endLineNumber: r.startLineNumber,
          endColumn: 1
        }));
      }
      if (n.length > 0) {
        n.sort((a, l) => a.startLineNumber - l.startLineNumber);
        const r = Hs.sanitizeAndMerge(t.regions, n, i.getModel()?.getLineCount());
        t.updatePost(Hs.fromFoldRanges(r));
      }
    }
  }
}
class Cme extends un {
  constructor() {
    super({
      id: "editor.removeManualFoldingRanges",
      label: f("removeManualFoldingRanges.label", "Remove Manual Folding Ranges"),
      alias: "Remove Manual Folding Ranges",
      precondition: sn,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2137
          /* KeyCode.Period */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
  invoke(e, t, i) {
    const n = i.getSelections();
    if (n) {
      const o = [];
      for (const r of n) {
        const { startLineNumber: a, endLineNumber: l } = r;
        o.push(l >= a ? { startLineNumber: a, endLineNumber: l } : { endLineNumber: l, startLineNumber: a });
      }
      t.removeManualRanges(o), e.triggerFoldingModelChanged();
    }
  }
}
rs(
  fm.ID,
  fm,
  0
  /* EditorContributionInstantiation.Eager */
);
Ge(sme);
Ge(ome);
Ge(rme);
Ge(lme);
Ge(cme);
Ge(mme);
Ge(pme);
Ge(dme);
Ge(hme);
Ge(ume);
Ge(gme);
Ge(fme);
Ge(ame);
Ge(Ame);
Ge(_me);
Ge(bme);
Ge(wme);
Ge(Cme);
for (let s = 1; s <= 7; s++)
  RU(new d1({
    id: d1.ID(s),
    label: f("foldLevelAction.label", "Fold Level {0}", s),
    alias: `Fold Level ${s}`,
    precondition: sn,
    kbOpts: {
      kbExpr: R.editorTextFocus,
      primary: Qi(2089, 2048 | 21 + s),
      weight: 100
      /* KeybindingWeight.EditorContrib */
    }
  }));
mt.registerCommand("_executeFoldingRangeProvider", async function(s, ...e) {
  const [t] = e;
  if (!(t instanceof _e))
    throw Go();
  const i = s.get(ye), n = s.get(Fi).getModel(t);
  if (!n)
    throw Go();
  const o = s.get(ht);
  if (!o.getValue("editor.folding", { resource: t }))
    return [];
  const r = s.get(tn), a = o.getValue("editor.foldingStrategy", { resource: t }), l = {
    get limit() {
      return o.getValue("editor.foldingMaximumRegions", { resource: t });
    },
    update: (g, m) => {
    }
  }, c = new d9(n, r, l);
  let d = c;
  if (a !== "indentation") {
    const g = fm.getFoldingRangeProviders(i, n);
    g.length && (d = new h9(n, g, () => {
    }, l, c));
  }
  const h = await d.compute(ct.None), u = [];
  try {
    if (h)
      for (let g = 0; g < h.length; g++) {
        const m = h.getType(g);
        u.push({ start: h.getStartLineNumber(g), end: h.getEndLineNumber(g), kind: m ? nd.fromValue(m) : void 0 });
      }
    return u;
  } finally {
    d.dispose();
  }
});
class g9 extends Wn {
  constructor(e) {
    super(e), this._inSelectionMode = e.inSelectionMode, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    if (!t.hasModel())
      return;
    const n = Eo(t.getOption(
      132
      /* EditorOption.wordSeparators */
    ), t.getOption(
      131
      /* EditorOption.wordSegmenterLocales */
    )), o = t.getModel(), r = t.getSelections(), a = r.length > 1, l = r.map((c) => {
      const d = new F(c.positionLineNumber, c.positionColumn), h = this._move(n, o, d, this._wordNavigationType, a);
      return this._moveTo(c, h, this._inSelectionMode);
    });
    if (o.pushStackElement(), t._getViewModel().setCursorStates("moveWordCommand", 3, l.map((c) => Ye.fromModelSelection(c))), l.length === 1) {
      const c = new F(l[0].positionLineNumber, l[0].positionColumn);
      t.revealPosition(
        c,
        0
        /* ScrollType.Smooth */
      );
    }
  }
  _moveTo(e, t, i) {
    return i ? new Ue(e.selectionStartLineNumber, e.selectionStartColumn, t.lineNumber, t.column) : new Ue(t.lineNumber, t.column, t.lineNumber, t.column);
  }
}
class yd extends g9 {
  _move(e, t, i, n, o) {
    return Wt.moveWordLeft(e, t, i, n, o);
  }
}
class xd extends g9 {
  _move(e, t, i, n, o) {
    return Wt.moveWordRight(e, t, i, n);
  }
}
class vme extends yd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartLeft",
      precondition: void 0
    });
  }
}
class Sme extends yd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndLeft",
      precondition: void 0
    });
  }
}
class yme extends yd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 1,
      id: "cursorWordLeft",
      precondition: void 0,
      kbOpts: {
        kbExpr: ne.and(R.textInputFocus, ne.and(O_, hS)?.negate()),
        primary: 2063,
        mac: {
          primary: 527
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class xme extends yd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartLeftSelect",
      precondition: void 0
    });
  }
}
class Eme extends yd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndLeftSelect",
      precondition: void 0
    });
  }
}
class Lme extends yd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 1,
      id: "cursorWordLeftSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ne.and(R.textInputFocus, ne.and(O_, hS)?.negate()),
        primary: 3087,
        mac: {
          primary: 1551
          /* KeyCode.LeftArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class kme extends yd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeft",
      precondition: void 0
    });
  }
  _move(e, t, i, n, o) {
    return super._move(Eo(Hr.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n, o);
  }
}
class Dme extends yd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityLeftSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n, o) {
    return super._move(Eo(Hr.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n, o);
  }
}
class Ime extends xd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 0,
      id: "cursorWordStartRight",
      precondition: void 0
    });
  }
}
class Mme extends xd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordEndRight",
      precondition: void 0,
      kbOpts: {
        kbExpr: ne.and(R.textInputFocus, ne.and(O_, hS)?.negate()),
        primary: 2065,
        mac: {
          primary: 529
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Nme extends xd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 2,
      id: "cursorWordRight",
      precondition: void 0
    });
  }
}
class Tme extends xd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 0,
      id: "cursorWordStartRightSelect",
      precondition: void 0
    });
  }
}
class Bme extends xd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordEndRightSelect",
      precondition: void 0,
      kbOpts: {
        kbExpr: ne.and(R.textInputFocus, ne.and(O_, hS)?.negate()),
        primary: 3089,
        mac: {
          primary: 1553
          /* KeyCode.RightArrow */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Rme extends xd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 2,
      id: "cursorWordRightSelect",
      precondition: void 0
    });
  }
}
class Fme extends xd {
  constructor() {
    super({
      inSelectionMode: !1,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRight",
      precondition: void 0
    });
  }
  _move(e, t, i, n, o) {
    return super._move(Eo(Hr.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n, o);
  }
}
class Ome extends xd {
  constructor() {
    super({
      inSelectionMode: !0,
      wordNavigationType: 3,
      id: "cursorWordAccessibilityRightSelect",
      precondition: void 0
    });
  }
  _move(e, t, i, n, o) {
    return super._move(Eo(Hr.wordSeparators.defaultValue, e.intlSegmenterLocales), t, i, n, o);
  }
}
class f9 extends Wn {
  constructor(e) {
    super(e), this._whitespaceHeuristics = e.whitespaceHeuristics, this._wordNavigationType = e.wordNavigationType;
  }
  runEditorCommand(e, t, i) {
    const n = e.get(tn);
    if (!t.hasModel())
      return;
    const o = Eo(t.getOption(
      132
      /* EditorOption.wordSeparators */
    ), t.getOption(
      131
      /* EditorOption.wordSegmenterLocales */
    )), r = t.getModel(), a = t.getSelections(), l = t.getOption(
      6
      /* EditorOption.autoClosingBrackets */
    ), c = t.getOption(
      11
      /* EditorOption.autoClosingQuotes */
    ), d = n.getLanguageConfiguration(r.getLanguageId()).getAutoClosingPairs(), h = t._getViewModel(), u = a.map((g) => {
      const m = this._delete({
        wordSeparators: o,
        model: r,
        selection: g,
        whitespaceHeuristics: this._whitespaceHeuristics,
        autoClosingDelete: t.getOption(
          9
          /* EditorOption.autoClosingDelete */
        ),
        autoClosingBrackets: l,
        autoClosingQuotes: c,
        autoClosingPairs: d,
        autoClosedCharacters: h.getCursorAutoClosedCharacters()
      }, this._wordNavigationType);
      return new vn(m, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, u), t.pushUndoStop();
  }
}
class EB extends f9 {
  _delete(e, t) {
    const i = Wt.deleteWordLeft(e, t);
    return i || new E(1, 1, 1, 1);
  }
}
class LB extends f9 {
  _delete(e, t) {
    const i = Wt.deleteWordRight(e, t);
    if (i)
      return i;
    const n = e.model.getLineCount(), o = e.model.getLineMaxColumn(n);
    return new E(n, o, n, o);
  }
}
class Pme extends EB {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartLeft",
      precondition: R.writable
    });
  }
}
class Hme extends EB {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndLeft",
      precondition: R.writable
    });
  }
}
class Wme extends EB {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 0,
      id: "deleteWordLeft",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.textInputFocus,
        primary: 2049,
        mac: {
          primary: 513
          /* KeyCode.Backspace */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Vme extends LB {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 0,
      id: "deleteWordStartRight",
      precondition: R.writable
    });
  }
}
class zme extends LB {
  constructor() {
    super({
      whitespaceHeuristics: !1,
      wordNavigationType: 2,
      id: "deleteWordEndRight",
      precondition: R.writable
    });
  }
}
class Ume extends LB {
  constructor() {
    super({
      whitespaceHeuristics: !0,
      wordNavigationType: 2,
      id: "deleteWordRight",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.textInputFocus,
        primary: 2068,
        mac: {
          primary: 532
          /* KeyCode.Delete */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Qme extends Vt {
  constructor() {
    super({
      id: "deleteInsideWord",
      precondition: R.writable,
      label: f("deleteInsideWord", "Delete Word"),
      alias: "Delete Word"
    });
  }
  run(e, t, i) {
    if (!t.hasModel())
      return;
    const n = Eo(t.getOption(
      132
      /* EditorOption.wordSeparators */
    ), t.getOption(
      131
      /* EditorOption.wordSegmenterLocales */
    )), o = t.getModel(), a = t.getSelections().map((l) => {
      const c = Wt.deleteInsideWord(n, o, l);
      return new vn(c, "");
    });
    t.pushUndoStop(), t.executeCommands(this.id, a), t.pushUndoStop();
  }
}
re(new vme());
re(new Sme());
re(new yme());
re(new xme());
re(new Eme());
re(new Lme());
re(new Ime());
re(new Mme());
re(new Nme());
re(new Tme());
re(new Bme());
re(new Rme());
re(new kme());
re(new Dme());
re(new Fme());
re(new Ome());
re(new Pme());
re(new Hme());
re(new Wme());
re(new Vme());
re(new zme());
re(new Ume());
Ge(Qme);
class Fc {
  constructor(e, t, i) {
    this.languageConfigurationService = i, this._selection = e, this._insertSpace = t, this._usedEndToken = null;
  }
  static _haystackHasNeedleAtOffset(e, t, i) {
    if (i < 0)
      return !1;
    const n = t.length, o = e.length;
    if (i + n > o)
      return !1;
    for (let r = 0; r < n; r++) {
      const a = e.charCodeAt(i + r), l = t.charCodeAt(r);
      if (a !== l && !(a >= 65 && a <= 90 && a + 32 === l) && !(l >= 65 && l <= 90 && l + 32 === a))
        return !1;
    }
    return !0;
  }
  _createOperationsForBlockComment(e, t, i, n, o, r) {
    const a = e.startLineNumber, l = e.startColumn, c = e.endLineNumber, d = e.endColumn, h = o.getLineContent(a), u = o.getLineContent(c);
    let g = h.lastIndexOf(t, l - 1 + t.length), m = u.indexOf(i, d - 1 - i.length);
    if (g !== -1 && m !== -1)
      if (a === c)
        h.substring(g + t.length, m).indexOf(i) >= 0 && (g = -1, m = -1);
      else {
        const A = h.substring(g + t.length), _ = u.substring(0, m);
        (A.indexOf(i) >= 0 || _.indexOf(i) >= 0) && (g = -1, m = -1);
      }
    let p;
    g !== -1 && m !== -1 ? (n && g + t.length < h.length && h.charCodeAt(g + t.length) === 32 && (t = t + " "), n && m > 0 && u.charCodeAt(m - 1) === 32 && (i = " " + i, m -= 1), p = Fc._createRemoveBlockCommentOperations(new E(a, g + t.length + 1, c, m + 1), t, i)) : (p = Fc._createAddBlockCommentOperations(e, t, i, this._insertSpace), this._usedEndToken = p.length === 1 ? i : null);
    for (const A of p)
      r.addTrackedEditOperation(A.range, A.text);
  }
  static _createRemoveBlockCommentOperations(e, t, i) {
    const n = [];
    return E.isEmpty(e) ? n.push(ms.delete(new E(e.startLineNumber, e.startColumn - t.length, e.endLineNumber, e.endColumn + i.length))) : (n.push(ms.delete(new E(e.startLineNumber, e.startColumn - t.length, e.startLineNumber, e.startColumn))), n.push(ms.delete(new E(e.endLineNumber, e.endColumn, e.endLineNumber, e.endColumn + i.length)))), n;
  }
  static _createAddBlockCommentOperations(e, t, i, n) {
    const o = [];
    return E.isEmpty(e) ? o.push(ms.replace(new E(e.startLineNumber, e.startColumn, e.endLineNumber, e.endColumn), t + "  " + i)) : (o.push(ms.insert(new F(e.startLineNumber, e.startColumn), t + (n ? " " : ""))), o.push(ms.insert(new F(e.endLineNumber, e.endColumn), (n ? " " : "") + i))), o;
  }
  getEditOperations(e, t) {
    const i = this._selection.startLineNumber, n = this._selection.startColumn;
    e.tokenization.tokenizeIfCheap(i);
    const o = e.getLanguageIdAtPosition(i, n), r = this.languageConfigurationService.getLanguageConfiguration(o).comments;
    !r || !r.blockCommentStartToken || !r.blockCommentEndToken || this._createOperationsForBlockComment(this._selection, r.blockCommentStartToken, r.blockCommentEndToken, this._insertSpace, e, t);
  }
  computeCursorState(e, t) {
    const i = t.getInverseEditOperations();
    if (i.length === 2) {
      const n = i[0], o = i[1];
      return new Ue(n.range.endLineNumber, n.range.endColumn, o.range.startLineNumber, o.range.startColumn);
    } else {
      const n = i[0].range, o = this._usedEndToken ? -this._usedEndToken.length - 1 : 0;
      return new Ue(n.endLineNumber, n.endColumn + o, n.endLineNumber, n.endColumn + o);
    }
  }
}
class il {
  constructor(e, t, i, n, o, r, a) {
    this.languageConfigurationService = e, this._selection = t, this._indentSize = i, this._type = n, this._insertSpace = o, this._selectionId = null, this._deltaColumn = 0, this._moveEndPositionDown = !1, this._ignoreEmptyLines = r, this._ignoreFirstLine = a || !1;
  }
  /**
   * Do an initial pass over the lines and gather info about the line comment string.
   * Returns null if any of the lines doesn't support a line comment string.
   */
  static _gatherPreflightCommentStrings(e, t, i, n) {
    e.tokenization.tokenizeIfCheap(t);
    const o = e.getLanguageIdAtPosition(t, 1), r = n.getLanguageConfiguration(o).comments, a = r ? r.lineCommentToken : null;
    if (!a)
      return null;
    const l = [];
    for (let c = 0, d = i - t + 1; c < d; c++)
      l[c] = {
        ignore: !1,
        commentStr: a,
        commentStrOffset: 0,
        commentStrLength: a.length
      };
    return l;
  }
  /**
   * Analyze lines and decide which lines are relevant and what the toggle should do.
   * Also, build up several offsets and lengths useful in the generation of editor operations.
   */
  static _analyzeLines(e, t, i, n, o, r, a, l) {
    let c = !0, d;
    e === 0 ? d = !0 : e === 1 ? d = !1 : d = !0;
    for (let h = 0, u = n.length; h < u; h++) {
      const g = n[h], m = o + h;
      if (m === o && a) {
        g.ignore = !0;
        continue;
      }
      const p = i.getLineContent(m), A = Sn(p);
      if (A === -1) {
        g.ignore = r, g.commentStrOffset = p.length;
        continue;
      }
      if (c = !1, g.ignore = !1, g.commentStrOffset = A, d && !Fc._haystackHasNeedleAtOffset(p, g.commentStr, A) && (e === 0 ? d = !1 : e === 1 || (g.ignore = !0)), d && t) {
        const _ = A + g.commentStrLength;
        _ < p.length && p.charCodeAt(_) === 32 && (g.commentStrLength += 1);
      }
    }
    if (e === 0 && c) {
      d = !1;
      for (let h = 0, u = n.length; h < u; h++)
        n[h].ignore = !1;
    }
    return {
      supported: !0,
      shouldRemoveComments: d,
      lines: n
    };
  }
  /**
   * Analyze all lines and decide exactly what to do => not supported | insert line comments | remove line comments
   */
  static _gatherPreflightData(e, t, i, n, o, r, a, l) {
    const c = il._gatherPreflightCommentStrings(i, n, o, l);
    return c === null ? {
      supported: !1
    } : il._analyzeLines(e, t, i, c, n, r, a, l);
  }
  /**
   * Given a successful analysis, execute either insert line comments, either remove line comments
   */
  _executeLineComments(e, t, i, n) {
    let o;
    i.shouldRemoveComments ? o = il._createRemoveLineCommentsOperations(i.lines, n.startLineNumber) : (il._normalizeInsertionPoint(e, i.lines, n.startLineNumber, this._indentSize), o = this._createAddLineCommentsOperations(i.lines, n.startLineNumber));
    const r = new F(n.positionLineNumber, n.positionColumn);
    for (let a = 0, l = o.length; a < l; a++)
      t.addEditOperation(o[a].range, o[a].text), E.isEmpty(o[a].range) && E.getStartPosition(o[a].range).equals(r) && e.getLineContent(r.lineNumber).length + 1 === r.column && (this._deltaColumn = (o[a].text || "").length);
    this._selectionId = t.trackSelection(n);
  }
  _attemptRemoveBlockComment(e, t, i, n) {
    let o = t.startLineNumber, r = t.endLineNumber;
    const a = n.length + Math.max(e.getLineFirstNonWhitespaceColumn(t.startLineNumber), t.startColumn);
    let l = e.getLineContent(o).lastIndexOf(i, a - 1), c = e.getLineContent(r).indexOf(n, t.endColumn - 1 - i.length);
    return l !== -1 && c === -1 && (c = e.getLineContent(o).indexOf(n, l + i.length), r = o), l === -1 && c !== -1 && (l = e.getLineContent(r).lastIndexOf(i, c), o = r), t.isEmpty() && (l === -1 || c === -1) && (l = e.getLineContent(o).indexOf(i), l !== -1 && (c = e.getLineContent(o).indexOf(n, l + i.length))), l !== -1 && e.getLineContent(o).charCodeAt(l + i.length) === 32 && (i += " "), c !== -1 && e.getLineContent(r).charCodeAt(c - 1) === 32 && (n = " " + n, c -= 1), l !== -1 && c !== -1 ? Fc._createRemoveBlockCommentOperations(new E(o, l + i.length + 1, r, c + 1), i, n) : null;
  }
  /**
   * Given an unsuccessful analysis, delegate to the block comment command
   */
  _executeBlockComment(e, t, i) {
    e.tokenization.tokenizeIfCheap(i.startLineNumber);
    const n = e.getLanguageIdAtPosition(i.startLineNumber, 1), o = this.languageConfigurationService.getLanguageConfiguration(n).comments;
    if (!o || !o.blockCommentStartToken || !o.blockCommentEndToken)
      return;
    const r = o.blockCommentStartToken, a = o.blockCommentEndToken;
    let l = this._attemptRemoveBlockComment(e, i, r, a);
    if (!l) {
      if (i.isEmpty()) {
        const c = e.getLineContent(i.startLineNumber);
        let d = Sn(c);
        d === -1 && (d = c.length), l = Fc._createAddBlockCommentOperations(new E(i.startLineNumber, d + 1, i.startLineNumber, c.length + 1), r, a, this._insertSpace);
      } else
        l = Fc._createAddBlockCommentOperations(new E(i.startLineNumber, e.getLineFirstNonWhitespaceColumn(i.startLineNumber), i.endLineNumber, e.getLineMaxColumn(i.endLineNumber)), r, a, this._insertSpace);
      l.length === 1 && (this._deltaColumn = r.length + 1);
    }
    this._selectionId = t.trackSelection(i);
    for (const c of l)
      t.addEditOperation(c.range, c.text);
  }
  getEditOperations(e, t) {
    let i = this._selection;
    if (this._moveEndPositionDown = !1, i.startLineNumber === i.endLineNumber && this._ignoreFirstLine) {
      t.addEditOperation(new E(i.startLineNumber, e.getLineMaxColumn(i.startLineNumber), i.startLineNumber + 1, 1), i.startLineNumber === e.getLineCount() ? "" : `
`), this._selectionId = t.trackSelection(i);
      return;
    }
    i.startLineNumber < i.endLineNumber && i.endColumn === 1 && (this._moveEndPositionDown = !0, i = i.setEndPosition(i.endLineNumber - 1, e.getLineMaxColumn(i.endLineNumber - 1)));
    const n = il._gatherPreflightData(this._type, this._insertSpace, e, i.startLineNumber, i.endLineNumber, this._ignoreEmptyLines, this._ignoreFirstLine, this.languageConfigurationService);
    return n.supported ? this._executeLineComments(e, t, n, i) : this._executeBlockComment(e, t, i);
  }
  computeCursorState(e, t) {
    let i = t.getTrackedSelection(this._selectionId);
    return this._moveEndPositionDown && (i = i.setEndPosition(i.endLineNumber + 1, 1)), new Ue(i.selectionStartLineNumber, i.selectionStartColumn + this._deltaColumn, i.positionLineNumber, i.positionColumn + this._deltaColumn);
  }
  /**
   * Generate edit operations in the remove line comment case
   */
  static _createRemoveLineCommentsOperations(e, t) {
    const i = [];
    for (let n = 0, o = e.length; n < o; n++) {
      const r = e[n];
      r.ignore || i.push(ms.delete(new E(t + n, r.commentStrOffset + 1, t + n, r.commentStrOffset + r.commentStrLength + 1)));
    }
    return i;
  }
  /**
   * Generate edit operations in the add line comment case
   */
  _createAddLineCommentsOperations(e, t) {
    const i = [], n = this._insertSpace ? " " : "";
    for (let o = 0, r = e.length; o < r; o++) {
      const a = e[o];
      a.ignore || i.push(ms.insert(new F(t + o, a.commentStrOffset + 1), a.commentStr + n));
    }
    return i;
  }
  static nextVisibleColumn(e, t, i, n) {
    return i ? e + (t - e % t) : e + n;
  }
  /**
   * Adjust insertion points to have them vertically aligned in the add line comment case
   */
  static _normalizeInsertionPoint(e, t, i, n) {
    let o = 1073741824, r, a;
    for (let l = 0, c = t.length; l < c; l++) {
      if (t[l].ignore)
        continue;
      const d = e.getLineContent(i + l);
      let h = 0;
      for (let u = 0, g = t[l].commentStrOffset; h < o && u < g; u++)
        h = il.nextVisibleColumn(h, n, d.charCodeAt(u) === 9, 1);
      h < o && (o = h);
    }
    o = Math.floor(o / n) * n;
    for (let l = 0, c = t.length; l < c; l++) {
      if (t[l].ignore)
        continue;
      const d = e.getLineContent(i + l);
      let h = 0;
      for (r = 0, a = t[l].commentStrOffset; h < o && r < a; r++)
        h = il.nextVisibleColumn(h, n, d.charCodeAt(r) === 9, 1);
      h > o ? t[l].commentStrOffset = r - 1 : t[l].commentStrOffset = r;
    }
  }
}
class kB extends Vt {
  constructor(e, t) {
    super(t), this._type = e;
  }
  run(e, t) {
    const i = e.get(tn);
    if (!t.hasModel())
      return;
    const n = t.getModel(), o = [], r = n.getOptions(), a = t.getOption(
      23
      /* EditorOption.comments */
    ), l = t.getSelections().map((d, h) => ({ selection: d, index: h, ignoreFirstLine: !1 }));
    l.sort((d, h) => E.compareRangesUsingStarts(d.selection, h.selection));
    let c = l[0];
    for (let d = 1; d < l.length; d++) {
      const h = l[d];
      c.selection.endLineNumber === h.selection.startLineNumber && (c.index < h.index ? h.ignoreFirstLine = !0 : (c.ignoreFirstLine = !0, c = h));
    }
    for (const d of l)
      o.push(new il(i, d.selection, r.indentSize, this._type, a.insertSpace, a.ignoreEmptyLines, d.ignoreFirstLine));
    t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
  }
}
class Gme extends kB {
  constructor() {
    super(0, {
      id: "editor.action.commentLine",
      label: f("comment.line", "Toggle Line Comment"),
      alias: "Toggle Line Comment",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 2138,
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: Qe.MenubarEditMenu,
        group: "5_insert",
        title: f({ key: "miToggleLineComment", comment: ["&& denotes a mnemonic"] }, "&&Toggle Line Comment"),
        order: 1
      }
    });
  }
}
class jme extends kB {
  constructor() {
    super(1, {
      id: "editor.action.addCommentLine",
      label: f("comment.line.add", "Add Line Comment"),
      alias: "Add Line Comment",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2081
          /* KeyCode.KeyC */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Yme extends kB {
  constructor() {
    super(2, {
      id: "editor.action.removeCommentLine",
      label: f("comment.line.remove", "Remove Line Comment"),
      alias: "Remove Line Comment",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: Qi(
          2089,
          2099
          /* KeyCode.KeyU */
        ),
        weight: 100
        /* KeybindingWeight.EditorContrib */
      }
    });
  }
}
class Kme extends Vt {
  constructor() {
    super({
      id: "editor.action.blockComment",
      label: f("comment.block", "Toggle Block Comment"),
      alias: "Toggle Block Comment",
      precondition: R.writable,
      kbOpts: {
        kbExpr: R.editorTextFocus,
        primary: 1567,
        linux: {
          primary: 3103
          /* KeyCode.KeyA */
        },
        weight: 100
        /* KeybindingWeight.EditorContrib */
      },
      menuOpts: {
        menuId: Qe.MenubarEditMenu,
        group: "5_insert",
        title: f({ key: "miToggleBlockComment", comment: ["&& denotes a mnemonic"] }, "Toggle &&Block Comment"),
        order: 2
      }
    });
  }
  run(e, t) {
    const i = e.get(tn);
    if (!t.hasModel())
      return;
    const n = t.getOption(
      23
      /* EditorOption.comments */
    ), o = [], r = t.getSelections();
    for (const a of r)
      o.push(new Fc(a, n.insertSpace, i));
    t.pushUndoStop(), t.executeCommands(this.id, o), t.pushUndoStop();
  }
}
Ge(Gme);
Ge(jme);
Ge(Yme);
Ge(Kme);
const Jme = `/*!-----------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Version: 0.52.2(404545bded1df6ffa41ea0af4e8ddb219018c6c1)
 * Released under the MIT license
 * https://github.com/microsoft/vscode/blob/main/LICENSE.txt
 *-----------------------------------------------------------*/.monaco-action-bar{height:100%;white-space:nowrap}.monaco-action-bar .actions-container{align-items:center;display:flex;height:100%;margin:0 auto;padding:0;width:100%}.monaco-action-bar.vertical .actions-container{display:inline-block}.monaco-action-bar .action-item{align-items:center;cursor:pointer;display:block;justify-content:center;position:relative}.monaco-action-bar .action-item.disabled{cursor:default}.monaco-action-bar .action-item .codicon,.monaco-action-bar .action-item .icon{display:block}.monaco-action-bar .action-item .codicon{align-items:center;display:flex;height:16px;width:16px}.monaco-action-bar .action-label{border-radius:5px;display:flex;font-size:11px;padding:3px}.monaco-action-bar .action-item.disabled .action-label,.monaco-action-bar .action-item.disabled .action-label:before,.monaco-action-bar .action-item.disabled .action-label:hover{color:var(--vscode-disabledForeground)}.monaco-action-bar.vertical{text-align:left}.monaco-action-bar.vertical .action-item{display:block}.monaco-action-bar.vertical .action-label.separator{border-bottom:1px solid #bbb;display:block;margin-left:.8em;margin-right:.8em;padding-top:1px}.monaco-action-bar .action-item .action-label.separator{background-color:#bbb;cursor:default;height:16px;margin:5px 4px!important;min-width:1px;padding:0;width:1px}.secondary-actions .monaco-action-bar .action-label{margin-left:6px}.monaco-action-bar .action-item.select-container{align-items:center;display:flex;flex:1;justify-content:center;margin-right:10px;max-width:170px;min-width:60px;overflow:hidden}.monaco-action-bar .action-item.action-dropdown-item{display:flex}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator{align-items:center;cursor:default;display:flex}.monaco-action-bar .action-item.action-dropdown-item>.action-dropdown-item-separator>div{width:1px}.monaco-aria-container{left:-999em;position:absolute}.monaco-text-button{align-items:center;border:1px solid var(--vscode-button-border,transparent);border-radius:2px;box-sizing:border-box;cursor:pointer;display:flex;justify-content:center;line-height:18px;padding:4px;text-align:center;width:100%}.monaco-text-button:focus{outline-offset:2px!important}.monaco-text-button:hover{text-decoration:none!important}.monaco-button.disabled,.monaco-button.disabled:focus{cursor:default;opacity:.4!important}.monaco-text-button .codicon{color:inherit!important;margin:0 .2em}.monaco-text-button.monaco-text-button-with-short-label{flex-direction:row;flex-wrap:wrap;height:28px;overflow:hidden;padding:0 4px}.monaco-text-button.monaco-text-button-with-short-label>.monaco-button-label{flex-basis:100%}.monaco-text-button.monaco-text-button-with-short-label>.monaco-button-label-short{flex-grow:1;overflow:hidden;width:0}.monaco-text-button.monaco-text-button-with-short-label>.monaco-button-label,.monaco-text-button.monaco-text-button-with-short-label>.monaco-button-label-short{align-items:center;display:flex;font-style:inherit;font-weight:400;justify-content:center;padding:4px 0}.monaco-button-dropdown{cursor:pointer;display:flex}.monaco-button-dropdown.disabled{cursor:default}.monaco-button-dropdown>.monaco-button:focus{outline-offset:-1px!important}.monaco-button-dropdown.disabled>.monaco-button-dropdown-separator,.monaco-button-dropdown.disabled>.monaco-button.disabled,.monaco-button-dropdown.disabled>.monaco-button.disabled:focus{opacity:.4!important}.monaco-button-dropdown>.monaco-button.monaco-text-button{border-right-width:0!important}.monaco-button-dropdown .monaco-button-dropdown-separator{cursor:default;padding:4px 0}.monaco-button-dropdown .monaco-button-dropdown-separator>div{height:100%;width:1px}.monaco-button-dropdown>.monaco-button.monaco-dropdown-button{align-items:center;border:1px solid var(--vscode-button-border,transparent);border-left-width:0!important;border-radius:0 2px 2px 0;display:flex}.monaco-button-dropdown>.monaco-button.monaco-text-button{border-radius:2px 0 0 2px}.monaco-description-button{align-items:center;display:flex;flex-direction:column;margin:4px 5px}.monaco-description-button .monaco-button-description{font-size:11px;font-style:italic;padding:4px 20px}.monaco-description-button .monaco-button-description,.monaco-description-button .monaco-button-label{align-items:center;display:flex;justify-content:center}.monaco-description-button .monaco-button-description>.codicon,.monaco-description-button .monaco-button-label>.codicon{color:inherit!important;margin:0 .2em}.monaco-button-dropdown.default-colors>.monaco-button,.monaco-button.default-colors{background-color:var(--vscode-button-background);color:var(--vscode-button-foreground)}.monaco-button-dropdown.default-colors>.monaco-button:hover,.monaco-button.default-colors:hover{background-color:var(--vscode-button-hoverBackground)}.monaco-button-dropdown.default-colors>.monaco-button.secondary,.monaco-button.default-colors.secondary{background-color:var(--vscode-button-secondaryBackground);color:var(--vscode-button-secondaryForeground)}.monaco-button-dropdown.default-colors>.monaco-button.secondary:hover,.monaco-button.default-colors.secondary:hover{background-color:var(--vscode-button-secondaryHoverBackground)}.monaco-button-dropdown.default-colors .monaco-button-dropdown-separator{background-color:var(--vscode-button-background);border-bottom:1px solid var(--vscode-button-border);border-top:1px solid var(--vscode-button-border)}.monaco-button-dropdown.default-colors .monaco-button.secondary+.monaco-button-dropdown-separator{background-color:var(--vscode-button-secondaryBackground)}.monaco-button-dropdown.default-colors .monaco-button-dropdown-separator>div{background-color:var(--vscode-button-separator)}@font-face{font-display:block;font-family:codicon;src:url(data:font/ttf;base64,AAEAAAALAIAAAwAwR1NVQiCLJXoAAAE4AAAAVE9TLzI3T0tHAAABjAAAAGBjbWFwQ5s/ewAACSQAABreZ2x5ZvJtKHkAACekAAD3FGhlYWRYl6BTAAAA4AAAADZoaGVhAlsC+QAAALwAAAAkaG10eBxB//oAAAHsAAAHOGxvY2EFi8dWAAAkBAAAA55tYXhwAu8BgQAAARgAAAAgbmFtZZP3uUsAAR64AAAB+HBvc3RjGEbCAAEgsAAAGSQAAQAAASwAAAAAASz////+AS4AAQAAAAAAAAAAAAAAAAAAAc4AAQAAAAEAAFT7+XFfDzz1AAsBLAAAAAB8JbCAAAAAAHwlsID////9AS4BLQAAAAgAAgAAAAAAAAABAAABzgF1ABcAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKADAAPgACREZMVAAObGF0bgAaAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAQBKwGQAAUAAADLANIAAAAqAMsA0gAAAJAADgBNAAACAAUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBmRWQAwOpg8QEBLAAAABsBRwADAAAAAQAAAAAAAAAAAAAAAAACAAAAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEs//8BLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLP//ASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEs//8BLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASz//wEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASz//wEsAAABLAAAASwAAAEs//8BLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAASwAAAEsAAABLAAAAAAABQAAAAMAAAAsAAAABAAABSYAAQAAAAAEIAADAAEAAAAsAAMACgAABSYABAP0AAAAEgAQAAMAAuqI6ozqx+rJ6wnrTuw08QH//wAA6mDqiuqP6snqzOsL61DxAf//AAAAAAAAAAAAAAAAAAAAAAABABIAYgBmANYA1gFQAdYDngAAAAMA8QFKAUcAtAE3AZUBJQFuAQ4BdABOAcMBYAFqAWkAkQA2ATAAhgDPAP4AQQGTAHkAFwG+AJsAiAFDAR0BFAEVAagAyQCmALwBoAGAAIsBkQF5AYgBhgF6AYkBkAGLAYQAvgF/AY0AAgAEAAUACgALAAwADQAOAA8AEAASABsAHQAeAB8AXABdAF4AXwBiAGMAIgAjACQAJQAmACkAKwAsAC0ALgAvADAAMgAzADQANQA8ADkAPQA+AD8AQABCAEMARgBIAEkASwBVAFYAVwBYAGcAaQBrAG4AcgB0AHUAdgB3AHgAegB7AHwAfQB+AH8AgQCCAIQAhQCHAIkAjACPAJAAkwCUAJUAlgCXAJgAmQCaAJwAngCfAKAAoQCiAKMApQCoAKkAqgCUAKsArACuALgAuQC9AMAAxADFAMgAygDLAMwAzQDTANQA1QDWANcA2ADZANoA7wDyAPMA9gD5APoA+wD8AQABAQEGAQcBCAENAQ8BEAERARMBFwEYARsBHAEfASABKAEsAS0BLgEvATEBMgEzATQBNQE2ATsBPAE9AT4BPwFAAUEBQgFEAUYBSAFJAUsBTAFOAU8BUAFRAVIBWQFaAVsBXAFdAV8BZAFlAWYBaAFrAW0BcQFyAXMBdQF2AXsBfAF9AX4BgQGCAYMBhQGHAYoBjAGOAZcBmAGhAaIBpAGmAacBqQGqAasBrAGtAbEBswG0AbUBuAG5AboBvAG9AcQBxQHGAccByAHMAc0A9AD1APcA+ABgAGEAcAA6AHEAZAGPAG8AcwBtAFsAJwAoAQkAjQCSAMYBsgABABgAZQDuAR4BVQGSASoAugFjAWIBIgF3ASsBOQBaAbsARAEKAI4AwQD/ARoBOgAqASkBIQA3ADgASgGUAbYBsAGuAa8AsAFTAVYBGQBsAckBywHKAZoBmwGcAZ0BngGfAZkAEQBTASQAnQHCAGoA0QDdANwA2wBRAFAATwAVANIArwCxAFkAaAFYAKQAZgAWAMIAwwEnACAAIQD9ABQBtwEWAO0A3gDfAOQA4gDjAOYA5wDpAOsA7ADhAOABlgDOATgAigAGAAcACAAJAOoA5QDoABwAxwEFAQIAOwAaABkATQCyALMBXgBMAWEBcADQAQwBowGlAEcBbACnAb8AMQEmARIBCwFFAFIA8AFNAW8AgwCAAXgBZwC3ALUAtgHBAcAARQFXAVQAVAC7AQQBAwC/ASMAEwCtAAABBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAABW4AAAAAAAAAc4AAOpgAADqYAAAAAMAAOphAADqYQAAAPEAAOpiAADqYgAAAUoAAOpjAADqYwAAAUcAAOpkAADqZAAAALQAAOplAADqZQAAATcAAOpmAADqZgAAAZUAAOpnAADqZwAAASUAAOpoAADqaAAAAW4AAOppAADqaQAAAQ4AAOpqAADqagAAAXQAAOprAADqawAAAE4AAOpsAADqbAAAAcMAAOptAADqbQAAAWAAAOpuAADqbgAAAWoAAOpvAADqbwAAAWkAAOpwAADqcAAAAJEAAOpxAADqcQAAADYAAOpyAADqcgAAATAAAOpzAADqcwAAAIYAAOp0AADqdAAAAM8AAOp1AADqdQAAAP4AAOp2AADqdgAAAEEAAOp3AADqdwAAAZMAAOp4AADqeAAAAHkAAOp5AADqeQAAABcAAOp6AADqegAAAb4AAOp7AADqewAAAJsAAOp8AADqfAAAAIgAAOp9AADqfQAAAUMAAOp+AADqfgAAAR0AAOp/AADqfwAAARQAAOqAAADqgAAAARUAAOqBAADqgQAAAagAAOqCAADqggAAAMkAAOqDAADqgwAAAKYAAOqEAADqhAAAALwAAOqFAADqhQAAAaAAAOqGAADqhgAAAYAAAOqHAADqhwAAAIsAAOqIAADqiAAAAZEAAOqKAADqigAAAXkAAOqLAADqiwAAAYgAAOqMAADqjAAAAYYAAOqPAADqjwAAAXoAAOqQAADqkAAAAYkAAOqRAADqkQAAAZAAAOqSAADqkgAAAYsAAOqTAADqkwAAAYQAAOqUAADqlAAAAL4AAOqVAADqlQAAAX8AAOqWAADqlgAAAY0AAOqXAADqlwAAAAIAAOqYAADqmAAAAAQAAOqZAADqmQAAAAUAAOqaAADqmgAAAAoAAOqbAADqmwAAAAsAAOqcAADqnAAAAAwAAOqdAADqnQAAAA0AAOqeAADqngAAAA4AAOqfAADqnwAAAA8AAOqgAADqoAAAABAAAOqhAADqoQAAABIAAOqiAADqogAAABsAAOqjAADqowAAAB0AAOqkAADqpAAAAB4AAOqlAADqpQAAAB8AAOqmAADqpgAAAFwAAOqnAADqpwAAAF0AAOqoAADqqAAAAF4AAOqpAADqqQAAAF8AAOqqAADqqgAAAGIAAOqrAADqqwAAAGMAAOqsAADqrAAAACIAAOqtAADqrQAAACMAAOquAADqrgAAACQAAOqvAADqrwAAACUAAOqwAADqsAAAACYAAOqxAADqsQAAACkAAOqyAADqsgAAACsAAOqzAADqswAAACwAAOq0AADqtAAAAC0AAOq1AADqtQAAAC4AAOq2AADqtgAAAC8AAOq3AADqtwAAADAAAOq4AADquAAAADIAAOq5AADquQAAADMAAOq6AADqugAAADQAAOq7AADquwAAADUAAOq8AADqvAAAADwAAOq9AADqvQAAADkAAOq+AADqvgAAAD0AAOq/AADqvwAAAD4AAOrAAADqwAAAAD8AAOrBAADqwQAAAEAAAOrCAADqwgAAAEIAAOrDAADqwwAAAEMAAOrEAADqxAAAAEYAAOrFAADqxQAAAEgAAOrGAADqxgAAAEkAAOrHAADqxwAAAEsAAOrJAADqyQAAAFUAAOrMAADqzAAAAFYAAOrNAADqzQAAAFcAAOrOAADqzgAAAFgAAOrPAADqzwAAAGcAAOrQAADq0AAAAGkAAOrRAADq0QAAAGsAAOrSAADq0gAAAG4AAOrTAADq0wAAAHIAAOrUAADq1AAAAHQAAOrVAADq1QAAAHUAAOrWAADq1gAAAHYAAOrXAADq1wAAAHcAAOrYAADq2AAAAHgAAOrZAADq2QAAAHoAAOraAADq2gAAAHsAAOrbAADq2wAAAHwAAOrcAADq3AAAAH0AAOrdAADq3QAAAH4AAOreAADq3gAAAH8AAOrfAADq3wAAAIEAAOrgAADq4AAAAIIAAOrhAADq4QAAAIQAAOriAADq4gAAAIUAAOrjAADq4wAAAIcAAOrkAADq5AAAAIkAAOrlAADq5QAAAIwAAOrmAADq5gAAAI8AAOrnAADq5wAAAJAAAOroAADq6AAAAJMAAOrpAADq6QAAAJQAAOrqAADq6gAAAJUAAOrrAADq6wAAAJYAAOrsAADq7AAAAJcAAOrtAADq7QAAAJgAAOruAADq7gAAAJkAAOrvAADq7wAAAJoAAOrwAADq8AAAAJwAAOrxAADq8QAAAJ4AAOryAADq8gAAAJ8AAOrzAADq8wAAAKAAAOr0AADq9AAAAKEAAOr1AADq9QAAAKIAAOr2AADq9gAAAKMAAOr3AADq9wAAAKUAAOr4AADq+AAAAKgAAOr5AADq+QAAAKkAAOr6AADq+gAAAKoAAOr7AADq+wAAAJQAAOr8AADq/AAAAKsAAOr9AADq/QAAAKwAAOr+AADq/gAAAK4AAOr/AADq/wAAALgAAOsAAADrAAAAALkAAOsBAADrAQAAAL0AAOsCAADrAgAAAMAAAOsDAADrAwAAAMQAAOsEAADrBAAAAMUAAOsFAADrBQAAAMgAAOsGAADrBgAAAMoAAOsHAADrBwAAAMsAAOsIAADrCAAAAMwAAOsJAADrCQAAAM0AAOsLAADrCwAAANMAAOsMAADrDAAAANQAAOsNAADrDQAAANUAAOsOAADrDgAAANYAAOsPAADrDwAAANcAAOsQAADrEAAAANgAAOsRAADrEQAAANkAAOsSAADrEgAAANoAAOsTAADrEwAAAO8AAOsUAADrFAAAAPIAAOsVAADrFQAAAPMAAOsWAADrFgAAAPYAAOsXAADrFwAAAPkAAOsYAADrGAAAAPoAAOsZAADrGQAAAPsAAOsaAADrGgAAAPwAAOsbAADrGwAAAQAAAOscAADrHAAAAQEAAOsdAADrHQAAAQYAAOseAADrHgAAAQcAAOsfAADrHwAAAQgAAOsgAADrIAAAAQ0AAOshAADrIQAAAQ8AAOsiAADrIgAAARAAAOsjAADrIwAAAREAAOskAADrJAAAARMAAOslAADrJQAAARcAAOsmAADrJgAAARgAAOsnAADrJwAAARsAAOsoAADrKAAAARwAAOspAADrKQAAAR8AAOsqAADrKgAAASAAAOsrAADrKwAAASgAAOssAADrLAAAASwAAOstAADrLQAAAS0AAOsuAADrLgAAAS4AAOsvAADrLwAAAS8AAOswAADrMAAAATEAAOsxAADrMQAAATIAAOsyAADrMgAAATMAAOszAADrMwAAATQAAOs0AADrNAAAATUAAOs1AADrNQAAATYAAOs2AADrNgAAATsAAOs3AADrNwAAATwAAOs4AADrOAAAAT0AAOs5AADrOQAAAT4AAOs6AADrOgAAAT8AAOs7AADrOwAAAUAAAOs8AADrPAAAAUEAAOs9AADrPQAAAUIAAOs+AADrPgAAAUQAAOs/AADrPwAAAUYAAOtAAADrQAAAAUgAAOtBAADrQQAAAUkAAOtCAADrQgAAAUsAAOtDAADrQwAAAUwAAOtEAADrRAAAAU4AAOtFAADrRQAAAU8AAOtGAADrRgAAAVAAAOtHAADrRwAAAVEAAOtIAADrSAAAAVIAAOtJAADrSQAAAVkAAOtKAADrSgAAAVoAAOtLAADrSwAAAVsAAOtMAADrTAAAAVwAAOtNAADrTQAAAV0AAOtOAADrTgAAAV8AAOtQAADrUAAAAWQAAOtRAADrUQAAAWUAAOtSAADrUgAAAWYAAOtTAADrUwAAAWgAAOtUAADrVAAAAWsAAOtVAADrVQAAAW0AAOtWAADrVgAAAXEAAOtXAADrVwAAAXIAAOtYAADrWAAAAXMAAOtZAADrWQAAAXUAAOtaAADrWgAAAXYAAOtbAADrWwAAAXsAAOtcAADrXAAAAXwAAOtdAADrXQAAAX0AAOteAADrXgAAAX4AAOtfAADrXwAAAYEAAOtgAADrYAAAAYIAAOthAADrYQAAAYMAAOtiAADrYgAAAYUAAOtjAADrYwAAAYcAAOtkAADrZAAAAYoAAOtlAADrZQAAAYwAAOtmAADrZgAAAY4AAOtnAADrZwAAAZcAAOtoAADraAAAAZgAAOtpAADraQAAAaEAAOtqAADragAAAaIAAOtrAADrawAAAaQAAOtsAADrbAAAAaYAAOttAADrbQAAAacAAOtuAADrbgAAAakAAOtvAADrbwAAAaoAAOtwAADrcAAAAasAAOtxAADrcQAAAawAAOtyAADrcgAAAa0AAOtzAADrcwAAAbEAAOt0AADrdAAAAbMAAOt1AADrdQAAAbQAAOt2AADrdgAAAbUAAOt3AADrdwAAAbgAAOt4AADreAAAAbkAAOt5AADreQAAAboAAOt6AADregAAAbwAAOt7AADrewAAAb0AAOt8AADrfAAAAcQAAOt9AADrfQAAAcUAAOt+AADrfgAAAcYAAOt/AADrfwAAAccAAOuAAADrgAAAAcgAAOuBAADrgQAAAcwAAOuCAADrggAAAc0AAOuDAADrgwAAAPQAAOuEAADrhAAAAPUAAOuFAADrhQAAAPcAAOuGAADrhgAAAPgAAOuHAADrhwAAAGAAAOuIAADriAAAAGEAAOuJAADriQAAAHAAAOuKAADrigAAADoAAOuLAADriwAAAHEAAOuMAADrjAAAAGQAAOuNAADrjQAAAY8AAOuOAADrjgAAAG8AAOuPAADrjwAAAHMAAOuQAADrkAAAAG0AAOuRAADrkQAAAFsAAOuSAADrkgAAACcAAOuTAADrkwAAACgAAOuUAADrlAAAAQkAAOuVAADrlQAAAI0AAOuWAADrlgAAAJIAAOuXAADrlwAAAMYAAOuYAADrmAAAAbIAAOuZAADrmQAAAAEAAOuaAADrmgAAABgAAOubAADrmwAAAGUAAOucAADrnAAAAO4AAOudAADrnQAAAR4AAOueAADrngAAAVUAAOufAADrnwAAAZIAAOugAADroAAAASoAAOuhAADroQAAALoAAOuiAADrogAAAWMAAOujAADrowAAAWIAAOukAADrpAAAASIAAOulAADrpQAAAXcAAOumAADrpgAAASsAAOunAADrpwAAATkAAOuoAADrqAAAAFoAAOupAADrqQAAAbsAAOuqAADrqgAAAEQAAOurAADrqwAAAQoAAOusAADrrAAAAI4AAOutAADrrQAAAMEAAOuuAADrrgAAAP8AAOuvAADrrwAAARoAAOuwAADrsAAAAToAAOuxAADrsQAAACoAAOuyAADrsgAAASkAAOuzAADrswAAASEAAOu0AADrtAAAADcAAOu1AADrtQAAADgAAOu2AADrtgAAAEoAAOu3AADrtwAAAZQAAOu4AADruAAAAbYAAOu5AADruQAAAbAAAOu6AADrugAAAa4AAOu7AADruwAAAa8AAOu8AADrvAAAALAAAOu9AADrvQAAAVMAAOu+AADrvgAAAVYAAOu/AADrvwAAARkAAOvAAADrwAAAAGwAAOvBAADrwQAAAckAAOvCAADrwgAAAcsAAOvDAADrwwAAAcoAAOvEAADrxAAAAZoAAOvFAADrxQAAAZsAAOvGAADrxgAAAZwAAOvHAADrxwAAAZ0AAOvIAADryAAAAZ4AAOvJAADryQAAAZ8AAOvKAADrygAAAZkAAOvLAADrywAAABEAAOvMAADrzAAAAFMAAOvNAADrzQAAASQAAOvOAADrzgAAAJ0AAOvPAADrzwAAAcIAAOvQAADr0AAAAGoAAOvRAADr0QAAANEAAOvSAADr0gAAAN0AAOvTAADr0wAAANwAAOvUAADr1AAAANsAAOvVAADr1QAAAFEAAOvWAADr1gAAAFAAAOvXAADr1wAAAE8AAOvYAADr2AAAABUAAOvZAADr2QAAANIAAOvaAADr2gAAAK8AAOvbAADr2wAAALEAAOvcAADr3AAAAFkAAOvdAADr3QAAAGgAAOveAADr3gAAAVgAAOvfAADr3wAAAKQAAOvgAADr4AAAAGYAAOvhAADr4QAAABYAAOviAADr4gAAAMIAAOvjAADr4wAAAMMAAOvkAADr5AAAAScAAOvlAADr5QAAACAAAOvmAADr5gAAACEAAOvnAADr5wAAAP0AAOvoAADr6AAAABQAAOvpAADr6QAAAbcAAOvqAADr6gAAARYAAOvrAADr6wAAAO0AAOvsAADr7AAAAN4AAOvtAADr7QAAAN8AAOvuAADr7gAAAOQAAOvvAADr7wAAAOIAAOvwAADr8AAAAOMAAOvxAADr8QAAAOYAAOvyAADr8gAAAOcAAOvzAADr8wAAAOkAAOv0AADr9AAAAOsAAOv1AADr9QAAAOwAAOv2AADr9gAAAOEAAOv3AADr9wAAAOAAAOv4AADr+AAAAZYAAOv5AADr+QAAAM4AAOv6AADr+gAAATgAAOv7AADr+wAAAIoAAOv8AADr/AAAAAYAAOv9AADr/QAAAAcAAOv+AADr/gAAAAgAAOv/AADr/wAAAAkAAOwAAADsAAAAAOoAAOwBAADsAQAAAOUAAOwCAADsAgAAAOgAAOwDAADsAwAAABwAAOwEAADsBAAAAMcAAOwFAADsBQAAAQUAAOwGAADsBgAAAQIAAOwHAADsBwAAADsAAOwIAADsCAAAABoAAOwJAADsCQAAABkAAOwKAADsCgAAAE0AAOwLAADsCwAAALIAAOwMAADsDAAAALMAAOwNAADsDQAAAV4AAOwOAADsDgAAAEwAAOwPAADsDwAAAWEAAOwQAADsEAAAAXAAAOwRAADsEQAAANAAAOwSAADsEgAAAQwAAOwTAADsEwAAAaMAAOwUAADsFAAAAaUAAOwVAADsFQAAAEcAAOwWAADsFgAAAWwAAOwXAADsFwAAAKcAAOwYAADsGAAAAb8AAOwZAADsGQAAADEAAOwaAADsGgAAASYAAOwbAADsGwAAARIAAOwcAADsHAAAAQsAAOwdAADsHQAAAUUAAOweAADsHgAAAFIAAOwfAADsHwAAAPAAAOwgAADsIAAAAU0AAOwhAADsIQAAAW8AAOwiAADsIgAAAIMAAOwjAADsIwAAAIAAAOwkAADsJAAAAXgAAOwlAADsJQAAAWcAAOwmAADsJgAAALcAAOwnAADsJwAAALUAAOwoAADsKAAAALYAAOwpAADsKQAAAcEAAOwqAADsKgAAAcAAAOwrAADsKwAAAEUAAOwsAADsLAAAAVcAAOwtAADsLQAAAVQAAOwuAADsLgAAAFQAAOwvAADsLwAAALsAAOwwAADsMAAAAQQAAOwxAADsMQAAAQMAAOwyAADsMgAAAL8AAOwzAADsMwAAASMAAOw0AADsNAAAABMAAPEBAADxAQAAAK0AAAAAAAAAlADUAOgBFAEyAWwBpgHgAhoCLgJCAlYCagJ+ApICpgLIAt4DGgM4A4oD5AQQBGYEzAUcBWoFagWYBeoGBgamB1oHmggkCEIIqgkcCdQKiArOCvYLCAtQC2ILdAuGC5gL4Av6DAwMGAw2DGIMkAz0DSoNPg1mDY4N/A4uDnwOtg7QDyYPgA/IEAIQJhCyEN4RBBFiEZwR8BImEkoSuBMWE2AUFBQ4FI4UuBTEFTYVihX0FlQWthbsFxAXKBc4F0gXVBdoF3YXmhgYGDIYTBiaGQoZNhlIGYIZzBn8GhYaPhpaGnAaohrEGugbHBs0G7Qb5BwKHFgcdhycHLwc4B0aHTYdWB2IHbod5h4IHjAeXB6EHrwfFB+WH8gf4iAaIHgguiEeIXohsiIEImwitCL6IzojoCPCI/AkAiQeJKIkwCTcJPglRiWEJbgl5iZYJsonQieOJ7goOCheKOQpeCn0KnwqxisKK54r3iwULEosiC0qLaQtyC5iLuQvIi9sL4Avxi/qMBYwVjB8MNoxCjFsMagx1jIcMnwyrDLKMxgzTDNwM940NDRwNKA07jWmNdg2PjamNvo3PDdqN4I3mje4N+A4BDgmOEQ4YjiAOJg4tjjOOOw5BDkcOVY5kjnkOn46vjriO0Q7XDt4PA48JjxGPHg83Dz6PUw9eD2mPew+Ej4yPko+ZD6QPrw+4j8SP3I/jD/iQBhAZECOQMpBAkFCQXZBxkH4QiZCYEJ+QsJC6kNwQ6pEJERuRVJFikW8RiJGRkaURtRHNkeOR8pIEEhkSNxJMEmCSZhJyEoOSkZKXkqGSqZLBks6S8RMIkyETLZNBk0yTZhNyE3uTkZOYk5wTypPkE+0UC5QqlDwUWBRmFHQUihSVlKGUxZTcFPMVCZUTlRyVJZU7lUOVTJVhlXiVhxWXFaCVrZW8Fc6V5hXylfoWCRYsFkaWZRZ+lpaWtBbCFtCW5xcEFxWXMJdSl4QXi5eTF86X2xfgl+oX/JgOGBYYIpgzmFeYYBhumH6Yh5iSmJsYqJjOGNsY5hj3mSWZMBlQGV8ZeZmDmZIZr5m+mc+Z4BnvGgCaE5opmjKaRRprGoEbARtum3mbgpudm6ebspu4m8Qb2JvkG/icIBwunDKcNpw6nD6cVpxmnHaciRyanLacwRzUnPYdHR0pHT2dSh1ZHW6dfx2SHZodtp3Hndgd7p32ngYeER4nni8eYB58HqSewp7TnuKAAAABAAA//8BLAEsABEAIgA0AGQAACU0LgEiDgEVFBYfARYyPwE+AQciJzc+BDMyHgEXFhcGJyY0PgIyHgIUDgEHBicuARcwPQEuAScmJzY3Njc2JzYuAiIOAhUUHgEXFhcGBw4BBxUuATU0PgEyHgEVFAYBLChFUkUoHBkNJlwmDhgclikiAQMKDhAVCg8dFQYDAiJYBAgNEhYRDggIDgkTFAgOhwQRDAkLBQQHBQoBAQsUGh0aEwsGCAgEBQoJDBEFEhQjPEg8IxOWKUUoKEUpITwVChoaChU8YhgHChEOCgULFQ4ICRiLCRQSDQkIDhIVEQ4ECAgEDlsBAQ4YCQcFAwQHCBAUDhoUCgoUGg4KEw4IBAQEBwkYDwESMBokPCMjPCQaMAAAAAACAAAAAAEaARoAGgAoAAAlFg4BBzQnPgE3LgMOAQcmIz4CMzIeAgciDgEUHgEyPgE0LgEjARkBFCIWAxkiAQEQHSMeEwIJCgMYJRURHxgMshcnFhYnLicXFycXxRYlGAIKCQMlGhEeEgEPHBEDFSIUDBgfGhcnLicWFicuJxYAAAEAAAAAAQcBGgALAAAlFSMVIzUjNTM1MxUBB3ETcHATqRNwcBNwcAAEAAAAAAEaARoADQASABYAGgAAASMHFRczFRczNzUzNzUHIzUzFQc1MxUnIxUzARD0CQkKCc4KCQkc1+HPvCZwcAEZCTgKnwkJnwo4LyYmqZaWcRMAAAAAAQAAAAABEgDMAA8AADcXByc1NxcHMyc3FxUHJzc4KA04OA0ovCgNODgNKIMoDTgNOQ4oKA45DTgNKAAAAwAAAAABBwEHAAkAFgAjAAA3FzUzFTcXByMnNzQuASIOARQeATI+AScUDgEiLgE0PgEyHgFlKBMmDjgNOLAfMz4zHh4zPjMfExksMiwZGSwyLBmUKGxqJg03Nw8fMx8fMz4zHh4zHxksGRksMiwZGSwAAAADAAAAAAEHAQcACQAXACQAADcnMzUjNycHFRc3Mh4BFA4CLgI+ARcVIg4BFB4BMj4BNC4BlChsaiYNNzcPHzMfHzM+Mx4BHzMfGSwZGSwyLBkZLGUoEyYOOA04sB8zPjMeAR8zPjMfARIZLDIsGRksMiwZAAMAAAAAAQcBBwAJABYAIwAANxcjFTMHFzc1JwcGLgI+ATIeARQOAScyPgE0LgEiDgEUHgGYKGxqJg03Nw8fMx4BHzM+Mx8fMx8ZLBkZLDIsGRksxygTJg44DTivAR8zPjMfHzM+Mx4SGSwyLBkZLDIsGQAAAwAAAAABBwEHAAkAFgAjAAA/ARUzNRc3JyMHFxQOAi4CPgEyHgEHNC4BIg4BFB4BMj4BZSgTJg44DTiwHzM+Mx4BHzM+Mx8TGSwyLBkZLDIsGZgobGomDTc3Dx8zHgEfMz4zHx8zHxksGRksMiwZGSwAAAABAAAAAAEEAQcACQAANxczNycHNSMVJzteDV4NThNOg11dDk7ExE4AAQAAAAABBwDzAAkAADcHFRc3JzM1IzeDXV0OTsTETvJeDV4OTRNOAAEAAAAAAQcA8QAJAAA/ATUnBxcjFTMHqV5eDk7Dw04oXQ5dDU4STgABAAAAAADJAOEACQAANwcjJzcXNTMVN8kvDS8NHxMfii8vDR5oaB8AAQAAAAAA0QDPAAkAADcnNTcXBzMVIxd6Ly8NH2lpH2MvDS8NHxMeAAEAAAAAANEAzwAJAAA3FxUHJzcjNTMnoi8vDR5oaB7OLw0vDh4THwABAAAAAADJAOEACQAAPwEzFwcnFSM1B14vDS8NHxMfsi8vDR9paR8AAgAAAAABGgEbAAkAEwAANyc1NxcHMxUjFz8BNScHFyMVMwdPPDwNLOnpLIE8PA0s6eksEjwNPA0sEyx2PA08DSwTLAABAAAAAAEEAQcACQAAJScjBxc3FTM1FwEEXg1eDU4TTaleXg5Ow8NOAAAAAAEAAAAAARwBHAAlAAA/ATYyFhQPAQYiJjQ/ATY0JiIPAQYUFjI/AT4BLgIGDwEOARYyNm0RMCIRgggYEQh0AwUIA3QOHCgOgg4LCx0oKA9tAgEGCI9oECAuEHwIEBcIbwIIBQJvDSYbDXwOJiYcCgoOaAMIBQAAAAIAAAAAARoBGgAHAA8AACUVBycVJxc1FycVDwEVFzUBGUFmOqgBXlYaJeigNSUlSw2QATklGiFLEWEAAAMAAAAAASIBGgAbACcANgAAJScuAQcjIgYPAQYeAjsBMjY/ARcWOwEyPgIHIi8BMzcXHAEOASMzIzYvATMeARUXFg4CIwEgSwIKB1gGCgJMAgIFCQU3BQoCDDgFBlgECQUCawICbDkUKgIEAVdFAgJMRQIETAEBAgICLOEFCAEHBeEFCQgDBwYhKwMEBwkIAVA0fQEDAwEGB+EBAgLhAQMCAgAABAAAAAABGgEaAB0ALAA1AD0AADczJicjNzM0NyM3NTMVFzY3JzUzNSMVMxUHBh4CNzYzMh4CFRQOAS4CNhcWFzI3JwYVFDcXNjU0JiMiOF4LCEsdGwITJCYBCQkBE3ASSQIBBQhyEhcPHBULGSotIAkSFBEXEg9PChhOCyEYEhMICjkJCUhOTwMEAgFLExJLjgUJCQSJDQwVGw8XJhEJICwqWRABC04OEhhGTw8SFyEAAAAAAwAAAAABCgEaAA8AFgAaAAAlJzUzNSMVMxUHBhY7ATI2Jzc1MxUXIwc3MxcBBEgScBNKBAsKvAoLiAImJG4nHYIdLo1LExJLjgoREZAETk9HSzk5AAAAAAMAAAAAARoBGwAqADEAOgAANwYjFRQfASM3Nj0BND4CFzM2NyYnJg4CHQEUDwEXMxQWMjY1MzcnJjUHMjYnIxQWNzI2NCYiBhQW9AkKCAe1BwkNFx8PAwUHBgcUJh0QBwsIQhYfFkIJCwdeBwwBJQtTFyEhLiEhmAIEGhkUFRkZKRAeFQoCCQcCAQINGyQUKRYWIQ0PFhYPDSEWFm0LCAgLhCEuISEuIQAAAAAGAAAAAAEqASYAFQAnAC4AMwA4AEEAABMGByIHDgIdARQPATc2PQE0PgIfAQYHFh8BIwczFBYyNjUzNycmBwYiJjUzFjcmJzcXDwEXNyYXMjY0JiIGFBaiCgcJCg8XDQQcBgcQHSYUVQkKAgYHehIMFh8WQgkLBlIGDwslAXUGBwsNgpQNlQczFyEhLiEhARgICgMFFR4QKRERHRMWFikUJBsNApEDARMSFBMPFhYPDSERTAYLCAjdBwcKDWeVDZUGASEuISEuIQAAAAAEAAAAAAEqASYAFQAnAC4AMgAAEyYnJg4CHQEUBzc2PQE0PgIXFhcHMycmPQE3FRQfAQcjFAYiJicXMjYnIxQWBwEXAc8VGxQmHRAHGQENFx8PFBA9bAcIEwcLCUIWHxUBJgcMASULewEJDf73AQUQBAINGyQUKRYVGQkJKRAeFQoCAwysFBkaFhMpFhYhDQ8WFQ8SCwgICwkBCQ3+9wAAAwAAAAABBgEbABoAIQA0AAA3Jj0BNC4CJyYOAh0BFA8BFzMUFjI2NTM3BwYiJjUzFic3Nj0BND4CFxYXHgEdARQfAfsHDBgfEhQmHRAHCwhCFh8WQgljBg8LJQFuBwkNFx8PHhMJCggHZhUXJhIhGxECAg0bJBQpFxUhDQ8WFg8NGgYLCAgbFRgaKRAeFQoCBBYLGw4mGhkUAAAAAwAAAAAA4QD0AA4AFgAeAAA3NTMyFhUUBgceARUUBiMnFTMyNjU0IyczMjY0JisBXj8fIBANEBIiHioqEhQlKycQFBITJji8GhgNFQUEGBEZHVhEEhAiFBAdDgAJAAAAAAEaAQcAEAAXAB4AIgAmACoALgAyADYAAAEjDwEvASMHFRczFzM3Mzc1By8BIzUzHwEjDwE1NzMHIxUzFSMVMyczFSM3IxUzBzMVIxUzFSMBEGcHDAwHZwkJYxAOEGMJjAQGXVkOel4HAg1aljk5OTk5OTm8ODg4ODg4OAEHAwwMAwq7ChAQCru4AwOpDpsDAqENJhI5EjgTOBITExMSAAIAAAAAAPQBGgAIAA4AABMjBxUXNxc3NQcnIwc1M+qoChFNTRETRA5ElgEZCfQGVlYG9NtLS9IAAwAAAAABGgEHAEcAcQB9AAA3MSMiDgIdARQOAgceAx0BFB4COwEVIyIuAScxJic1Jjc1NCcxJic1JicxJisBNTMyPgE3MTY9ASY3MTY3MT4COwEXMzUjIicxJic1JicxJj0BNic1JicxLgIrARUzMh4CHQEUHgIXIxYHIg4BHgI+ATU0JnECBgoHBAIEBwUFBwQCBAcKBgICCRANAwMBAQECAgQDBQUGAQEGCgcCAgEBAQMDDRAJApQCAgYFBQMEAgIBAQEDAw0QCQEBBgoHBAIEBwUBDxcRHA0GGCIfEyH0BAgKBhkGDAsIBAQICwwGGQYKCAQSBg0ICAcBCAgQBgUFAwEDAgMSBQcFBQYQCAgICAgNB3oSAwIDAQMFBQYQCAgBBwgIDQcTBAgKBhkGDAsIBAIREx8iGAYNHBEXIQAEAAAAAAEaAQcARwBxAH4AigAANzEjIg4CHQEUDgIHHgMdARQeAjsBFSMiLgEnMSYnNSY3NTQnMSYnNSYnMSYrATUzMj4BNzE2PQEmNzE2NzE+AjsBFzM1IyInMSYnNSYnMSY9ATYnNSYnMS4CKwEVMzIeAh0BFB4CFyMWBzYzMhYVFA4BLgI2FwcnBxcHFzcXNyc3cQIGCgcEAgQHBQUHBAIEBwoGAgIJEA0DAwEBAQICBAMFBQYBAQYKBwICAQEBAwMNEAkClAICBgUFAwQCAgEBAQMDDRAJAQEGCgcEAgQHBQEPNg4RFyETHyIYBg1CFRUOFhYOFRUOFhb0BAgKBhkGDAsIBAQICwwGGQYKCAQSBg0ICAcBCAgQBgUFAwEDAgMSBQcFBQYQCAgICAgNB3oSAwIDAQMFBQYQCAgBBwgIDQcTBAgKBhkGDAsIBAIaCSEXERwNBhgiHwIWFg4VFQ4WFg4VFQAFAAAAAAEaAQcADQARABsAHwApAAAlIzUnIwcVIwcVFzM3NSczFSMXFQc1JyMHFSc1FxUjNQc1FxUXMzc1NxUBEEIJXglCCQn0CahLS5ZLCjgJS4MmXUsJOApL4RwKChwJlgoKlhwTEw4qCQoKCSsNOBMTS2ArBgkJBipfAAAAAAQAAAAAAQcBGgAiAD8AWwBkAAATNjMyHgEXDgEHNTE2PQE+AiYnLgEOAhYXFRQXFS4CNhcGIxUUBisBMCMxLgE9ASImPQE0NjsBMhYdARQHNxQHFh0BPgImJy4BDgIWFzU0NyY+Ah4BByMUBiImNDYyFlgcIh8zHgEBKSEJERcJBwoRNjkoCRoZCR4oCBtyAgQFBBQBBAQEBQsIEggLAxkJBgkLAQsJDSQjGgkLDQYJARQeHhMBHgsQCwsQCwEGEx40HiQ6DAEJCwMJICYnEBkVDCs6NQ4DDAgBCzFAOqcDLwQFAQQELwUEJggLCwgmBAJbDw0JCgIJGRwZCQ4KChokIw0CCwkNHxoJCxkQCAsLEAsLAAMAAAAAARoBGgAHAAsADwAAEzMXFQcjJzUXFTM1JzM1Ixz0CQn0CRPh4eHhARkJ4QkJ4UKWlhMmAAAAAAMAAAAAARgBGgAxADkASQAANzU0JiIGHQEjJwcXBwYdASMVOwEWHwEHFzcXHgEyNj8BFzcnNTY3MTM1IzU2LwE3JwcjNTQ2MhYdARcVFhUUDgIiLgI1NDc1zCAtIBAfCx4BCSYoAQQNASULIwIMHyIfDAEkCyUOBSknAQoBHgsfbRcgFx0JDRYbHRwWDAjYCxYgIBYLHwseARobDBAbFQElCyMBDhAPDgEkCyYBFhsQDBsaAR4LHwsQFxcQCxABFhkXJxwPDxwnFxkWAQAAAAARAAAAAAEaARoADwATABcAGwAfACMAJwArAC8AMwA3ADsAPwBDAEcASwBPAAABIzUjFSM1IxUjBxUXMzc1ByM1MzUjNTMHIxUzBzMVIxcjFTM3MxUjFyMVMwczFSM3IxUzFzMVIxcjFTMHMxUjNyMVMxczFSMXIxUzJzMVIwEQHBOWExwJCfQJEuHh4eG8ExMTExMTExMmEhISEhISEhISEhImExMTExMTExMTExMlExMTExMTExMBBxISEhIK4QkJ4deoExNeExITExNeExITExOEExMTEhMTE4QTExMSE14TAAADAAAAAAEaARoAPQB5AIIAADcuAQ4BDwIGJi8BJicuAj8CPgI1NCcuAyMiDwEOAhUUHgYzMj4BPwE2NTQmLwEmLwEmBwYnIiYnJicuAzUmPgE/ATYzMh8BFh8BFhQPAQ4CFBYfARYzMjc2PwE+ATIfAhYfARYVFA8BDgE3BzMVIzUzFTfrBQsKBwMGBQMIAikLCwQGAQMEBwMGAwgFCwwNCAwIDgUJAwoRGBwgIiEQChENBg4IAwMHBAQPBA0HCA4eDh8aDRYQCQEEBgULAwQCBAcKBwYDAgsEBQQEBUUJDAUFCQYGAgYFBAcJBQMGAwQKBQovVz5eE1d9AgEFBQQGBAMBAycLDAUIBQMFBgMHCQYMCQUMCwgIDgYNEQoPIiEgHBkRCgQIBQ4IDAUKBAgEBA4EVAIBCQcSGg0cHh4PBw4JBQoEAwYICQcEBQMLAwcKCwoFRQkCBAcGAwQDBggEBQgDAgQDCwQH41cTXj5XAAMAAAAAARoBGgAIAEQAgAAAPwEjNTMVIzUHFzIfAx4BFRQPAQ4CIyIuBjU0PgE/ATYzMh4CFxYVFA4BDwIGFBYXFh8BHgE/Aj4CBzI+AT8BNic2LwEmLwImIgYPAQ4CIyIvAS4BND4CPwE2NC8EJiMiDwEOAgceAxcWFx4Bolc9XRJYMQwJDwgHAwMIDgUOEQoQIiEgHBgRCgMIBg4IDAcODQoFCAMGAwcEAgYECwspAggDBQYDCAkGCQwKBQoEAQEDBgMFCQcEBQYCBgMHCgUMCUUFBAQFBwMFAgMGCAkHBAIEAwsEBwMBAQkQFg0aHw4er1gSXT1XIwgOCAgECgUMCA4FCAQKEhgcICEhEAsQDQYOCAgLDQQJDAUJCAMGBQMFCAUMCycDAQMEBgQFBVoDBgULAwQCAwgFBAgGAwQDBgQFBAlFBAsMCQcGAwUDBQQHCQgGAwQKBAsNBw4fHhwNGhEICQAAAAQAAAAAAQIA4QAHAA8AJAAvAAA3IycjByM3MxcnJicjBg8BFyM1MQYjIiY1ND8BNCMiBzU2MzIVDwEOARUUFjMyNjWmEw89DxI3ERAWAQEBAQEXthELFQ8SIh8VEg8PFCQRGAwMCwkMEFEoKJBZPgMGBgM+NxATEA4dBQQaDBAKJg8EAQgLBwoRDQAABAAAAAABJQD0AAYACgAMABMAACUHIyc3FzcHNycPARcHFwcjJzcXASWSDjoONIuQUg1QEgopCw8OOg406a1TCkmkbWILXhYPFQ8RUwpJAAABAAAAAAEPAPoABgAAJQcvATcXNwEPnw8/DziX7rwBWQtPsgAIAAAAAAEaAQcABgAKAA4AEgAWAB0AJAArAAA3Iyc3FzcfATMVIxUzFSMXIxUzBzMVIyczNycHJwcXIyc3FzcXBzM3JwcnB0YNEw0NGg4blpaWlpaWlpaWlkoNIg4aDQ0gDRMNDRoOLw0iDhoNDdgUDQ0bDgUTJRMmEiYTaCENGg0OTBQNDRsNWiENGg0NAAABAAAAAADzAMEABgAAPwEXByMnN5ZRDFgLWAxvUgxXVwwAAAABAAAAAADBAPQABgAANxcHJzU3F29SDFdXDJZRDFgLWAwAAAABAAAAAADPAPMABgAANyc3FxUHJ71SDFdXDJZRDFgLWAwAAAABAAAAAAD0AM8ABgAANwcnNzMXB5ZRDFgLWAy9UgxXVwwAAAACAAAAAAEHARoANwA7AAATMxUzNTMVMzUzFTMXFTMVIxUzFSMVMxUjFQcjFSM1IxUjNSMVIzUjJzUjNTM1IzUzNSM1MzU3MwczNSNeExITExMSEyYmJiYmJhMSExMTEhMTEyUlJSUlJRMTE4ODARklJSUlJRMTEhMTExITEyUlJSUlJRMTEhMTExITE5aDAAABAAAAAAD9AP0ACwAANwcXNxc3JzcnBycHhVURVVURVVURVVURllURVVURVVURVVURAAAAAgAAAAAA9AD0AAMABwAANxUzNQcjNTM4vBOWlvS8vKmWAAAAAQAAAAABBwCWAAMAACUVIzUBB8+WExMAAwAAAAABBwD0AAMABwARAAA3FTM1ByM1MyczNTMVIxUzNSM4qRODg3ATgxMmqc6oqJaEEhODE6kAAAAAAQAAAAAA4gDiABkAADcyFx4BFxYUBw4BBwYiJy4BJyY0Njc2Nz4BlgoKExwFAwMFHBMKFAoTHAUDBQUKEQkT4QMFHBMKFAoTHAUDAwUcEwoUEwkRCgUFAAEAAAAAARoBGgAaAAATMhceARcWFAYHBgcOASIuBDQ2NzY3PgGWEhEhMQoECQkRHg8hJCEeGBEJCQkRHg8hARkECjEhESQhDx4RCQkJERgeISQhDx4RCQkAAAAAAgAAAAABGgEaACoARAAAEyYiBzEGBwYHMQ4BFhcWFx4CPgE3MTY3NjcxNiYnMSYnMSYnMSYnMSYnFwYHDgEiLgQ0Njc2Nz4BMhceARcWFAa0Dx4PDg0ZDwgIAQMIFQsZHR8cDRkPCAMFAQQDCAcLCgwNDlMRHg8hJCEeGBEJCQkRHg8hJBEhMQoECQECBQUDCA8ZDR0fDhwWCg8IAQcIDxkNDg8fDg4NDAoLBwgDrh4RCQkJERgeISQhDx4RCQkECjEhESQhAAADAAAAAAEaARoADAAWAB8AABMyHgEUDgEiLgE0PgEHFBYXNy4BDgEVMzQmJwceAT4BliQ8IyM8SDwjIzxMDQ2fGUI7JOIODZ8ZQjskARkjPEg8IyM8SDwjgxQlEJ8VCRw3IRQlEJ8VCRw3AAABAAAAAAC8ALwACAAANxQGLgE0NjIWvBYgFRUgFpYQFgEVIBYWAAAAAgAAAAAAvAC8AAoAFwAANw4BLgI+ATIWFBc2NTQmIyIOAR4CNqYECgsIAgQJDgsMBxYQCxMJBBEWFYwFBAIICwoHCw4PCgsQFg0VFhEECQADAAAAAADhAOIADAAVABYAADcyPgE0LgEiDgEUHgE3FAYiJjQ2MhYnlhQjFBQjKCMUFCNFHSgdHSgdMUsUIygjFBQjKCMUSxQdHSgdHSAAAAUAAAAAARoBGgAHADQAPQBGAE8AAAEjBxUXMzc1ByM1Mx4BMzI2NCYiBhUjFSM1MxUOARUUFjI2NTMUFjI2NCYjIgYHIy4BIzUzBzQ2MhYUBiImJzIWFAYiJjQ2MzIWFAYiJjQ2ARD0CQn0CRKpKwQSCg8WFh8WOCUlCAsWHxYmFh8WFhAKEQUwBREKqXEKEQsLEQo4CAsLEQoKeQkKChEKCgEZCfQJCfTqJQgLFh8WFg844SwEEgkQFhYQEBYWHxYKCQkKJqkICwsRCgp5ChEKChEKChEKChEKAAAFAAAAAAEaAPQACwAPABMAGAAcAAA3FzcXNyc3JwcnBxcnITUhFSE1IRc1IxUzFTUjFbwNHh4PICAPHh4NHscBBv76AQb++paWlpZADR4eDR4eDyAgDx6DE0sTQgkSORMTAAAABAAAAAABFgEaABYAIgAsADYAADcjNTMVMzUnIzUjNCYiBhUjFSMHFRczNT4CHgEUDgEuAhcHNSMVJwcXMzcnMxcHJxUjNQcngziWEwocEhYgFRQbCgpBAQkLCgcFCgsIBYYUExQOJQ0kfA0lDhQTFA0mqCUvCRMPFhYPEwm8CeUFCQIECgoKBQEGCqwUZGQUDSQkWyQNFGRkFA0ABAAAAAABBwEHAAsAGQAgACQAADcnBycHFwcXNxc3LwE3MxcVByMVByMnNTc7AhcVMzUjFyMVM6IOGhsNGxsNGxoOGykTgxMTJhKEEhImE0sSJoNLhISUDhsbDhobDRsbDRt6ExODEyYSEoQSEkuDOIQAAAABAAAAAADoAOgACwAANxc3JzcnBycHFwcXlkQORUUOREQORUUOiUUOREQORUUOREQOAAAAAgAAAAABGgD2AC8AOQAANzMeARQGIzUyNjQmJyMnLgIGDwEnJiciBw4BHgE7ARUjIiYnLgE+ATc2Fz4BHgEHFzUzFTcXByMn4AEXISEXDxUVDxECAhcfGwYGEAUFFA0KBgsYDgkJDhoJDAcLGxEODgkmKx9fGBMYDSgNKLwBIC8hExYeFgEQDxYFEA4OAwEBDgocGhATCwsNIyIXAwMEFBYGH3YYZmUXDSgoAAIAAAAAARoA9gAyADwAADczHgEUBisBNTMyNjQmJyMnLgIGDwEnJicGBw4BHgE7ARUjIiYnLgE3PgIXPgEeARcHJxUjNQcnNzMX4AEXISEXJSUPFRUPEQICFx8bBgYQBQUUDQoGCxgOLy8OGgkPBAsHFxwOCSYrHwMfGRIYDSgNKLwBIC8hExYeFgEQDxYFEA4OAwEBAQ0KHBoQEwsLECsSDBEFBBQWBh8WSBlmZRgOKCgAAAIAAAAAARoA9gAVAC4AADczHgEUBisBIiYnLgE+ATc2Fz4BHgEHMzI2NCYrAScuAgYPAScmJyIHDgEeATPgARchIReMDhoJDAcLGxEODgkmKx9/gxAWFhARAgIXHxsGBhAFBRQNCgYLGA68ASAvIQsLDSMiFwMDBBQWBh9zFh8WEA8WBRAODgMBAQ4KHBoQAAcAAAAAARoBGgADAAcACwAPABMAFwAnAAATMxUjNzMVIxczFSMVMxUjFTMVIwczFSMnBxUzNTMVIzUjFRczNzUnXhMTJUtLJktLS0tLSyZLS10TE+HhExPhEhIBB8+8ExMSExMTEhMTzhJeXs9xcRISzxIAAwAAAAABFAD0AAYADQARAAA3BxcHJzU3MwcXBxc3NQcXNydYMTENODiRDjIyDji4EV4RwzEyDTgNOQ4xMg04DWAIuwkAAAAABgAAAAABLAEaABUAKwBBAFMAXQBlAAATFRQWFzMWFxYdASM1NCYvASYnJj0BMxUGFhczFhcWHQEjNTQmJzUmJyY9ATMVFBYXMRYXFh0BIzU0Ji8BJicmPQEHNzMyFhQGKwEOASsBIi4BPQEXNSMVFBY7ATI2NxUzFjY0JiM4BwgBCgQIEwcIAQoECEwBBwgBCgQIEwYJCgUHSwYJCgUHEgcIAQoECHASxRQbGxQMBigaOBUiFbypIRc5FyETCQwQEAwBGQkGCAcIBQoMCgoGCAYBBwYKDAkJBggHCAUKDAoKBggGAQcGCgwJCQYIBwgFCgwKCgYIBgEHBgoMCXATHCcbGR8UIhQ5ODg4GCEhUDgBERcRAAAAAAQAAAAAAQcBBwADABEAGAAcAAA3IxUzJzczFxUHIxUHIyc1NzsCFxUzNSMXIxUzqV5eSxODExMmEoQSEiYTSxImg0uEhIMSgxMTgxMmEhKEEhJLgziEAAACAAAAAAEaARoADAAUAAATIg4BFB4BMj4BNC4BBzUyHgEUDgGWJDwjIzxIPCMjPCQfMx8fMwEZIzxIPCMjPEg8I/PhHzM+Mx4AAAAACgAAAAABLAEaAAcACwATABcAHwAjACsALwAzAD0AABMHFRczNzUnBzUzFQ8BFRczNzUnBzUzFQc3MxcVByMnNxUzNTcHFRczNzUnByM1MxUjNTMnIxUzBxc3NScHHAkJOAoKLiUvCQk4CgouJTgJOAoKOAkTJZ8JCTkJCQolJSUlbjo6Ew0iIg0BGQk4Cgo4CTgmJiUKOAkJOAo5JiYvCgo4CQkvJSWDCXEJCXEJOCZeJRMTEgwiDSINAAADAAAAAAEaARoAEgAeACcAAD8BFQcnNSMnNTczFxUjNSMVMx8CNzUzNzUnIwcVFzcjNTMVIwcVJ0sTFhAcCQnhChPOHAl2IxAcCQmWCQlLQoQdCRZYExsVBy8JlgkJVEuECUIiBhwKXQoKXQoTS0sJDxUAAAoAAAAAARoBBwAGAAoADgAUABgAIwAnAC0AMQA4AAABIxUzFTM1JzMVIyczFSMXHQEzNzUHNSMVJyMPATUnIxUXNzM3NSMVBzUjFRczPQEjFTcVIzU3MxUBEBwTEnAlJUslJakJCTglJgkHKAoJEDYFgxLhEwkKExMTCRwBBhITHAkSEhKEEhMJHCUTExMDKCEKQgc2SyUlOBIcCUslJV4THAkSAAAAAAIAAAAAARoBBwAXACMAABMzFxUmJzUjFTMXFT8BMwYVIwcnNSMnNRciDgEeAj4BNTQmHPQJCArhLgooBwsCBTYQLwnOERwNBhgiHxMhAQcKgAkGaJYKISgDCQo2By8JqXoTHyIYBg0cERchAAIAAAAAARoBBwALABQAAAEjBxUXMxUXNzM3NQcjDwE1JyM1MwEQ9AkJLxA2fwkSegcoCi7hAQcKqQkvBzYJqZ8DKCEKlgAAAAUAAP/9AS0BGgAsADIANgBDAEoAADcGIzUjFS4CJzM1Iz4CNxUzNR4CFyMVMwcWFzY1NC4BIg4BFB4BMzI3JjcvAR8BBi8CHwE2FzIWFRQOAS4CNhc3JwcnBxerBgYSGy4cAhISAh0tGxIbLhwCEhIBCQgDIzxIPCMjPCQODQQNNyZMGwYNEiQSRw8RFyETHyIYBw0uIg8cEAwYJwESEgIdLRsTGy0cAhISAhwuGxIMAgQNDiQ8IyM8SDwjAwhKG0wmNwQNJBIkJgoBIBgRHA0GGSEgPy0LJQ4PEwAEAAAAAAEsARoALAAyADYAPwAANwYjNSMVLgInMzUjPgI3FTM1HgIXIxUzBxYXNjU0LgEiDgEUHgEzMjcmNy8BHwEGLwIfARQWMjY0JiIGqwYGEhsuHAISEgIdLRsSGy4cAhISAQkIAyM8SDwjIzwkDg0EDTcmTBsGDRIkEi8gLyEhLyAnARISAh0tGxMbLRwCEhICHC4bEgwCBA0OJDwjIzxIPCMDCEobTCY3BA0kEiRVFyEhLyEhAAAAAAQAAAAAARoBGgADAAcAIwAwAAA3Fy8BFy8BFzMOAgc1IxUuAiczNSM+AjcVMzUeAhcjFQcyPgE0LgEiDgEUHgGpJkwmVBIkEnkCHC4bEhsuHAISEgIdLRsSGy4cAhJeJDwjIzxIPCMjPKlMJkxUJBIkGy4cAhISAh0tGxMbLRwCEhICHC4bEnojPEg8IyM8SDwjAAAG//8AAAEsAQsADAAYAE4AZwBxAHsAADcyFh0BFAYiJj0BNDYXNCYiBh0BFBYyNjUnFhc3NhcWFxYVFAcXMx4BHQEUBw4BDwEGBwYHBiInJicmLwEuAScmPQE0NjczNyY1NDc2NzYPARUXFhcWMjc2PwE1JwYjIicmJwYHBiMiNyYOARQWMjY3NjcGFx4BMjY0LgF1BggIDAgIVggMCAgMCDICAQMRJiMQDQUDAQ4PAwIHBwsGBwwNKVIpDQwHBgsHBwIDDw4BAwUNECMmSQEBCgwkRiQMCgEBDBQhEgYEBAYSIRQ6CDAPDCoTAgMnBwMCEyoMDzBxCQYcBggIBhwGCQ8GCQkGHAYICAayAQIDEwUEExEeEwwQBxkOGAUGAwkFCAUEBwUSEgUHBAUIBQkDBgUYDhkHEAwTHhETBAWCAlABBgUPDwUGAVACBhMGCAgGE2IIBRMoDhQUFggIFhQUDigTBQAAAAADAAAAAAEHARoABwAMABMAAD8BMxcVByMnNycjFTMnBxUXNTMnSxNlRBOWE6k4Xpa8EhJ5E+ETQ4sTE4M4u/MSvBPPEgAAAAAEAAAAAAEHAPQABgAbACgANgAANw8BJzcXNxc+ATU0LgEjIgcmIzYzMh4BFAYHNgciLgE0PgIeAg4BBzI+ATQuASIOARQeARenLw4cDRUoSQkKEh4SDQwNDxceFycXGRQFZRIeEhIeJB4RARIeEhcnFhYnLicWFicXkDgBHA4VMCsJGA0SHhIFBRMXJy4oCw4rEh4kHhEBEh4kHhISFicuJxYWJy4nFgEAAAAABAAAAAABGgDiAAMABwAXABsAACUVIzUVMxUjNyMiBh0BFBY7ATI2PQE0JgczFSMBB+Hh4eHhCAsLCOEHCwtAJibOEhIlXpYLCIMICwsIgwgLcBMAAQAAAAAAzwCWAAMAADczFSNecHCWEwAABgAAAAABCQEcAAwAHAAoADAAOgBIAAATPgEeAg4CLgI2FxYzMj4BNTQuAg4CHgE3FwcWDgEuAj4BFwcWNjQmDgEWNwcWFRQHFz4BLwEmIyIOARQXByY+AhdJG0E7JAQdNkE6JQQcJhogHC8cFiUwLiQTAxiCDSgEBREUDwIMFAoSBQoHCAQBVA8FCQ4MAwo0CwwSHhIJDRADJjgaAQUSBB02QTskBBw3QTqoEhwvHBkqHgkMIC0vKooNKQkUDAIOFREFBCEDBAsFAQcHKw4LDRIPDhMuFBcFEh4kDw4YOSsMDQAAAwAAAAAA9AEaABMAJAA1AAA3NC4BIg4BFRcjFRceATI2PwE1IycyFx4BFAYHBiInLgE0Njc2FwcOAQcGIicuAS8BNRY3Fjf0GSwyLBkBAQEENUg1BAEBXRUTEBMTEBMqExATExATYAEBEw8SKhIPEwEBIygoI+oNFgwMFg0CpgcRFxcRB6YeBQQOCg0EBQUEDQoOBAXEAwUMBAUFBAwFA4wUAQEVAAAABQAAAAABKAEHACUALAA1AD8ARgAANwcuASIGBycHFwcVIxUzFRYXBxc3HgEyNjcXNyc2NzUzNSM1JzcnMhYVIzQ2Fw4BBy4BJzUzJwcVMzUXBxU3NQc1Nyc1FxWJEQQZIBkEEQ0WAxMTAQQYDRUHFhgWBxUNGAQBExMDFksMEDgQMgIVDw8VAUsqDxOOMEdHaY+lgxAPFBQPEA0WAhMTAQkJGA0VCgsLChUNGAkKARITAhYNEAwMEEsPFQEBFQ8cswhWRF8gFy8QZBZGXxduEAAAAAAEAAAAAAEWAQcAJQAsADUAPwAANwcuASIGBycHFwcVIxUzFRYXBxc3HgEyNjcXNyc2NzUzNSM1JzcnMhYVIzQ2Fw4BBy4BJzUzJzcXFQc1NycVI4kRBBkgGQQRDRYDExMBBBgNFQcWGBYHFQ0YBAETEwMWSwwQOBAyAhUPDxUBSxMOqWxWjhODEA8UFA8QDRYCExMBCQkYDRUKCwsKFQ0YCQoBEhMCFg0QDAwQSw8VAQEVDxyrCHEQSBc5X0QAAAAEAAAAAAEpASwAJQAsADUAQAAANwcuASIGBycHFwcVIxUzFRYXBxc3HgEyNjcXNyc2NzUzNSM1JzcnMhYVIzQ2Fw4BBy4BJzUzNxUHNTcnFSYnNTeJEQQZIBkEEQ0WAxMTAQQYDRUHFhgWBxUNGAQBExMCFUsMEDgQMgIVDw8VAUu4gGqiCQoOgxAPFBQPEA0VAxMTAQkJGA0VCgsLChUNGQgKARITAxUNEAwMEEsPFQEBFQ8cYBBRFkNndgYDfggAAAAABAAAAAAA4wDjAAwAGAAcACAAADc+AR4CDgIuAjYXHgE+AiYnJg4BFjcjFTMVIxUzbBEoJBcCEiEoJBYDEh0MHBkPAg0LEikYCEo4ODg41AwCESIoJBcCEiEoJF4IAgwXHBkICwgjKjsTEhMAAwAAAAAA4QDiAAwAEAAUAAA3Ig4BFB4BMj4BNC4BFxUjNTcVIzWWFCMUFCMoIxQUIxJLS0vhFCMoIxQUIygjFF4SEjkTEwAAAgAAAAAA5gDhAAUACwAANyMHFzM3ByMnNzMXulYsLFYsOjoeHjod4UtLSzMzMzMAAQAAAAAA5gDhAAUAADcHIyc3M+UrViwsVpZLS0sAAAACAAAAAADhAOEAAgAFAAA3MycHMydLlksjRiNeg2w9AAEAAAAAAOEA4QACAAA3FyOWS5bhgQAAAAIAAAAAAPQA9AADAAcAAD8BFwc1NycHOV1dXTQ0NJZeXl0pNDU1AAABAAAAAAD0APQAAwAANxcHJ5ZeXl70Xl5eAAAAAwAAAAAA4wDjAAwAEAAUAAA3PgEuAg4CHgI2JyMVMyc1MxXUDAIRIigkFwIRIigkJxcXFxdsESgkFwIRIigkFwIRFhMlS0sABQAAAAABHAEcABUAHgBEAEwAVgAAEzczHwIVDwErATU0JzM1IxUmIz0BFwcmLwE3JzcXBzcXBxcVMxUjFQYHFwcnDgEiJicHJzcmJzUjNTM1Nyc3Fz4BMhYHLgEOARUzNAc2NzUjFR4BFzZYArEBDwEBDwFcB2CsCQqGIwICBhwtCjRXEQ0VAhMTAQQYDRUHFhgWBxUNGAQBExMDFg0RBBkgGRUGERAJOAIKAUoBFQ8PARsBAQ8BsQIPAgoHrFsCXAFnIwMDBRwuCjM7EA0VAxMSAQoJGA0VCgsLChUNGQgJARMTAxUNEA8UFAcGAwYOCQxUCg8cHA8VAQEAAwAAAAABDAEHAAMACQAMAAATIxUzNwcVFzc1DwE1SxMTPg8PgxZpAQfh1Qe8B10QCEyYAAMAAAAAAQ8BBwADAAkADAAAEzMVIzcHFRc3NQ8BNS8cHFwWFoQhXQEH4dkLvAteFgtChAADAAAAAAEWAQcACQAuADgAAD8BFxUHNTcnFSMXDgEdARQOAisBIi4CPQE0LgI1ND4EMh4EFRQGByMVFBY7ATI2NV4OqWxWjhMVBQYCAwUDEAMFAwIGCwcDBggKDAwMCggGBAccFgIBEAEC/whxEEgXOV9EYAUNBxADBQMCAgMFAxAHDQsQCgYLCwgGAwMGCAsLBgoQGRYBAgIBAAAEAAAAAAERARoAEQAfADcARAAANyYnNycHJicmBwYPARc3Njc2BwYPASc3Njc2Fx4BFxYHNycHJzcnBycHDgEUFhcHFzceATI2PwEHBiIuAjU0PwEXBwb/AwUZCxoHCRQUCwgdUR0JBAgXAwYSOhIGBxAQBwsEBmEcDBsjHAwcCx0JCAUGGQsaBxIVFQgdNggQDwwGDBI6EgbkCQcaCxkGAgcIBAkdUR0ICxQOBwYSOhIGAwYGBAsHEG4dDB0jHQwdCx0IFRURCBkMGQUGCQgdGgQHCw8IEQwSOhIFAAAAAAYAAAAAARoBAAADAAcACwAPABUAGAAANzUzFSczFSM3FSM1HQEzNSU3FxUHJzcVN3GoXV1dXaio/voOZWUOE0pxEhJLE0sTE6kTE60HQw9ECHVjMQAAAAACAAAAAADYAPQAAwAHAAA3MxUjNxUjNVQdHYQc9Ly8vLwAAAACAAD//QEWAQcAGgAkAAA3FA4BJicHHgE+Ai4BBgc1IxUXMzUjPgEeASc3FxUHNTcnFSOGGScjCBIKLTIjBxovMQ8TCSwYCiMlFygOqVlDjhNLFB8IEhIHFxkHJTIsEw0UFzIKExEOCh6hCHEQOxYtX0QAAAUAAAAAARwA9AAEAAkADgASAC0AADc1MwYHNzY3IxUXJicjFSUVITUXMj4BLgEGBzMVIyc1MxU+AR4BDgImJzceARNhAgEXCQuJaQUDYQEG/vrHEhoGESEgCRQlCBANKicWBh4qJQkPBhdxEgkJOAoIEnEJChO8ExO8FiIeDAwPEAgqExELESQrHgcVFAYNDwAAAAABAAAAAAEMAQ0AHQAANxQOASYnBx4CPgI1NC4BBgc1IxUXMzUjPgEeAe8mOjUMGgooMjMpFypERRYcDkEjDjU3I5YeLg0bHAsYIQ0KIC8aJDsXFRwiSw4cGRYPLQAAAAADAAAAAAD+AQcAAwAJAAwAABMjFTMnFxUHJzUfATX9HBxcFhaEIV0BB+HZC7wLXhYLQoQAAwAAAAABEAEHAAgAEgAXAAA3FAYuATQ2MhYzLwEjBxUXMz8BByM1Mxe8FiAVFSAWVFARXxgYXxFQYV9fT5YQFgEVIBYWWQgYshcIWUqyWQACAAAAAAEQAQcACQAOAAAlLwEjBxUXMz8BByM1MxcBEFARXxgYXxFQYV9fT6ZZCBiyFwhZSrJZAAIAAAAAAPwBAAAFAAgAAD8BFxUHJzcVN1AWlpYWHG70C2QXZAytk0oAAAAAAgAAAAABDAEMABcAIAAANzUzFT4BMzIeAR8BIzUuAiIGBzMVIycXIiY0NjIWFAYhHBAwGx00IAIBHQIYJy4pCzVOEnUQFRUgFhbASy8TFhsuHAUEFCIUFhMcEpAVIBYWIBUAAAIAAAAAAOoBGgAKABMAADczNycHNSMVJwcfARQGIiY0NjIWlgpJFDEcMRRJLxYfFhYfFnlJFDF0dDEUSUEQFRUgFhYAAgAAAAAA6gEaAAoAEwAAEyMHFzcVMzUXNycXFAYiJjQ2MhaWCkkUMRwxFEkbFh8WFh8WARlJFDF0dDEUSeEQFRUgFhYAAAAAAgAAAAABDAEMABcAIQAAJTUjFS4BIyIOAQ8BMzU+AjIWFyMVMzcHMjY0LgEGFBYzAQscEDAbHTQgAgEdAhgnLikLNU4SdRAWFiAVFRDASy8TFhsuHAUEFCIUFhMcEpAVIBUBFiAWAAACAAAAAAEHAQcABwALAAATFxUHIyc1NxcjFTP0ExO8EhK3srIBBxO8EhK8ExiyAAAFAAAAAAErASwAAQANAEEASQBZAAA3NRcnNxc3FwcXBycHJzcVMzcXBxUWFQczFSMxBg8BFwcnBw4BIiYvAQcnNycmJysBNTM1NDc1JzcXMzU0PgEyHgEHFTM1NCYiBhc1IwcGFRQeAjI+AjU0K1smDSgnDSYmDSgnDXQQJA0iDAEsLgYPASsNKQEOJCYkDgEpDCoBDwUBLiwLIw0kEhAdIh0Ra1kaJRp6mwEJDhkfIh8ZD4sBCSYMKCgNJiYNKSgNkAwkDSIBHh8OEh8ZASsMKQIPEhIQAigMKgEZHhIOIBwBIw0kDBEdEREdEQwMExoaMgEBGhwZLSERESEtGR0AAgAAAAABGgEHABQAHgAANzUyNjc2NSMnNTczFxUnNSMVMwcXMzcnBzUjFScHF0sREQICVQkJ9AkS4WsJLigvDR8THg4vExMFBQMFCrsKCq0TkakJLy8NH3l5Hw0vAAAAAwAAAAABGgDhAA0AEQAVAAAlBzUnIwcVFzM3NRc3NQcjNTMXJzU3AQs9CakJCakJPQ5dlpZLOTnTIygJCYQJCSYjCWttcF0fCiIAAAUAAAAAARoBBwANABcAIAApADIAADczFxUHIyc1NzM/ATMXBzM1Iy8BIw8BIxciBhQWPgE0JhcyFhQGLgE0NjciBhQWMjY0JslHCQn0CQlHEAc4B5PhQgcQMBAHQRwEBgYIBQVQEBYWIBUVEBchIS4hIfQKqAoKqAoQAwO5lgMQEAMTBQgGAQUIBRIWIBYBFSAWEiEuISEuIQAAAAMAAAAAAPQBGgAHAAsADwAAEzMXFQcjJzUXMzUjFzMVI1SWCgqWCRODgy8lJQEZCfQJCfTq4bwTAAAAAAMAAAAAAQcBGgAHAAsAFwAAEzMXFQcjJzUXMzUjFyMVIxUzFTM1MzUjHOEKCuEJE87OcBM4OBM4OAEZCeEJCeHYzyY4Ezg4EwAAAAADAAAAAAEaARoABwALABEAABMzFxUHIyc1FzM1IxczFQcjNRz0CQn0CRPh4ZYlcCYBGQn0CQn06uEmJXEmAAAAAwAAAAABGgEaAAcACwAUAAATMxcVByMnNRcVMzUHMjY0JiIGFBYc9AkJ9AkT4XEXISEuISEBGQn0CQn0CeHhqSEuISEuIQAABQAAAAABGgEaAAkADgAaAB4AJQAAEx8BFQcjJzU3MwczNScjFyMVMxUzNTM1IzUjBzMVIzcfARUHLwG2OAYTqRMTcXGpOHFLJSUTJiYTJV5eiysFEgE4ARQ4DqgTE+ES86g5SxMmJhMlgxPOKw27E844AAADAAAAAAEHARoAAwALAA8AADcVIzUnMxcVByMnNRczNSO8XkLhCgrhCRPOzqkTE3AJ4QkJ4djPAAMAAAAAARoBGgAHAAsAEgAAEzMXFQcjJzUXMzUjFzMVNycVIxz0CQn0CRPh4SU4Xl44ARkJ9AkJ9OrhhDhLSzgAAAAABAAAAAABBwEaAAkADgAaAB4AABMfARUHIyc1NzMHMzUnIxcjFTMVMzUzNSM1IwczFSPJOAUSqRMTcHCpOXBLJSUTJSUTJV1dARQ4DqgTE+ES86g5SxMmJhMlgxMAAAAABgAAAAABGgD0AAcACwAPABcAGwAfAAA/ATMXFQcjJzczNSM1MzUjNzMXFQcjJzUXMzUjNTM1IyYJXgkJXgkSS0tLS3peCQleCRNLS0tL6goKqAoKCXESExMKqAoKqJ8mJUsAAAEAAAAAAPcBCgAZAAATFRczNSM3PgEeAgYPARc3PgEuAgYPATVCCUIwEg0iIxkKCg1hDWIQDAwhLCwQDgEHQgkSEg0JCRkjIwxiDWERLCwhCwsRDScAAAADAAAAAAEaARoACQAMABAAABMjDwIXPwI1BzcXNyc3F/gbmwMsGk0FmuwdGxAhliEBGZoFTRosA5sbyzgbCiGWIQAAAAMAAAAAARoBGgANABEAGAAAJScjNScjBxUXMxUXMzcnNTMVFyM1Mzc1MwEZCY0JXgkJLwm8CfNLlqkcCYSyClQJCZcIVQkJZ3FxXUsIHQAAAwAAAAABBwCpAAgAEQAaAAA3FAYiJjQ2MhYXFAYiJjQ2MhYXFAYiJjQ2MhZLCxAKChALXgsQCwsQC14LEAsLEAuWCAsLEAsLCAgLCxALCwgICwsQCwsAAAIAAAAAARoBGgALABwAADczFSMVIzUjNTM1Mwc1MxUzNSM1MzUjNTMXFQcjSzg4Ezg4EzgT4XFxcXoJCfThEzg4Ezj9Z12DEyUTCs4JAAAAAwAAAAAA4gDhAAsAGAAhAAA3JwcnNyc3FzcXBxc3FA4BIi4BND4BMh4BBzQmIgYUFjI2rBYWERYWERYWERYWJBQjKCMUFCMoIxQTIS4hIS4hbxYWERYWERYWERYWFhQjFBQjKCMUFCMUFyEhLiEhAAMAAAAAARYBGwAVACgANAAAEx4BFxYVFAcOAQcGJy4DNzY3PgEXNjc2JzQmJyYnJgYHDgEWFx4BJzcXBxcHJwcnNyc3oRYpECYeDyYWMCcUHhADBw8mEishJhkZAhEPHSYTJg8gFyEiECYELQ0tLQ0tLQ0tLQ0BGQEUECk3KycSFwQJFgsiKi4VLhkMDPQJHyIlFyoQHQMBCQsYTkgTCgZ8Lw0vLw0vLw0vLw0AAAAABAAAAAABHQEaAC8AQwBQAFQAABMjBycHFwcVFwcXNxczJicjLwEHJzcvATU/ASc3Fz8BMx8BNxcHHwEVFhc1JzcnDwEyFhcGBy4BDgIWFwYHLgE+AR8BPgEeAg4CLgI2FxUzNbA0CiYmGi0tGiYmCicKCAYJDiYPGQYsLAYZDyYOCRYJDiYPGQYsCwgtGiYmJAwTBAkIAQsOCgEIBwYDDQ0EFQ4YDiMhFwUNHCIgFgYMCF4BGS0aJiYKNAomJhotCAssBhkPJg4JFgkOJg8ZBiwsBhkPJg4JBggKJwomJhowDgsDBgcIAQoOCwEICQUXGxIBNAwGDBwjIRYFDBsiIR4TEwAFAAAAAAEHAQcAAwAHABUAHAAgAAA3IxUzBzUjFSc3MxcVByMVByMnNTc7AhcVMzUjFyMVM6leXiYSExODExMmEoQSEiYTSxImg0uEhIMSJl5eqRMTgxMmEhKEEhJLgziEAAAAAgAAAAABGgDjAAgADAAANyc3FwcnNyM1JzMVI/UsDUNDDSy9JRMTqS0NREMNLRM4gwAAAAYAAAAAASwBLAAHAAsAFwAbAB8AIwAAEzczFxUHIyc3FTM1BTU3MxcVMxcVByMnNzUjFRcjFTsCNSOpE10TE10TE13+5xNeEl4TE84TcV5eXl4SXl4BGRMTXRMTXV1dqHATE14SXhMTcF5eEl5eAAAEAAAAAAEUARQAIAAmADcAOwAAEwYUHwEOAQcGHgE2Nz4BNxcGFBYyNxcWMjY0LwExJyYiHwEGIiY0NyIHFzYzMhYXHgE+AScuAgcXLgEcAwIzEhoFAQQHBwEFFxEWDh0pD0oDCAUCgGgDCGIsCRoSHxMRDwsKJTkJAQcHBAEHIzMaMAEbARACBwMzDSUWBAcCBAQUIAsXDikeD0oDBQcDgGgDdCwJExlRBRADLiMEBAIHBBsrGCwvExsAAAMAAAAAAREA6AAIABEAKAAANzIWFAYiJjQ2FyIGFBYyNjQmJzIeARcWDgEmJy4BIgYHDgEuATc+ApYVHR0qHR0VDRISGhISDRwzIwcBBAcHAQk5SjkJAQcHBAEHIzO7HSkeHikdEhMaEhIaEz4YKxsEBwIEBCMtLSMEBAIHBBsrGAAAAAP//wAAARoBGgAVADsARAAAEwcVNxc1MxUjBzUjFwczFRc3Mzc1Jwc+ATQuASIOARQWFw4BBwYPATM1ND4COwEyHgIdATMnJicuASciJjQ2MhYUBlQJCQqpIRgmAQEUECIiCQmYDhASHiMfERANDRYHBAEBEwoSGA0BDRgSChMBAQUGFjITGxsnGxsBGQkdAQEUXhgYCgkcByMJcQmxCR0jHhISHiMdCQYWEAsMEgoNFxMKChMXDQoTCwsQFg8bJxsbJxsAAAAACAAAAAABBwEaAAkADgAYAB0AJwAxADsAQAAAEx8BFQcjJzU3MwcVMzUnBxQzMjY1NCMiBhc0MhQiFzM1IzUHFTcVIwcjNTM1BzU3FTM3FDMyNjU0IyIGFzQyFCLGPgMKzgkJkYi8OGgZDQ4ZDQ4QFBQ8LQ8fEA8aLQ8QIA4UGg0NGQ0OEBQUARc+B7YJCfQJEuGoOUwlFBIlFBIaMgsMPQYNAy1qDC0DDQY9GCQTEyUUExoyAAAAAAUAAAAAAQcBGgAJAAwAEwAaACEAABMfARUHIyc1NzMHMycjFTM1Iyc1BzcnBxUXPwIXFQcnN8Y+AwrOCQmRBDg4hLxCCUoiDSkpDSQNKSkNIgEXPge2CQn0CUs54ZYJQo4jDSkNKQ1EDikNKQ0iAAAHAAAAAAEaARoAEQAUABwAJQApAC0ANgAAEzMVFzMVMzUvAiMHFRczNSM3FyMXIwcVFzM3NQcVJyMHJyMHNRc3FysBNTcXNzI2NCYiBhQWJnAJQhMDPgaRCQlCOIM4OGeWCQmWCRIfDRYoDQ1PDx0eXRMvJQQGBggFBQEHQgkTKQc+Agn0CRPhOTgJcQkJcQpLHhYoDCdQDxwbEy5BBgcGBgcGAAkAAAAAAQcBGgAOABEAGQAeACgALgA3AD8ASQAAJS8BIwcVMzUzFRczFTM1BzUXDwEVFzM3NScHFSM1MwcjFSM1MzIVFAYnIxUzMjQXNic0ByMVMzInNTM2FhQGJzcjFSM1MxUjFTMBBD4GkQkScQlCE0s4xQkJzgoKCby8lgYNFBUNCgUFCkIJAR4UFA0UBgcLCghNEg0hFBLZPgIJZ15CCRMpBDk5OAlxCQlxCV4SXTgTORMICxsRESYJDBwBOAsjAQsPCwELFjkLDgAAAAAEAAAAAAEaAQcAAwAhACsAMgAANzM1Izc1NzMfATMXFQcjJzUjJzU3Mx8BMxcVIzUjLwEjFRcnIxUzPwEzNSMHIxUzNSMHJhISEgpTCAhrCQnOChwJCVMICGsKE2cICERxCEQ7CAhxaBNBvGsIXksTCQkEDgqWCQkvCakKBQ4KLiUFDjgPDzkOBRM4S10OAAAEAAAAAAEaAQcACgASABwALAAANzMXFQcjJzU3Mx8BNTcjDwEjFTczNyMvASMVMzcXJzcXFQcnNyMOARcjNDY3kX8JCfQJCV4HhQF3EAZUZnoBegcQUFAQMRkOKSsNGxoPFQETHhf0CrsJCc4KA8wdZxADcZYTAxA5EEkaDSoNKg4ZARUOFiABAAAAAAUAAAAAAQcBGgARABQAHAAgACoAABMfARUHIzUzNSMnNSMVIzU3MwczJwcjBxUXMzc1ByM1MwcVIzUHJzcjNTPGPgMKQThCCXESCZEEODgdgwkJgwoTcHATEjINMSE4ARc+B7YJE5YJQktUCUs5XgqDCQmDeXAcOCExDTISAAAACwAAAAABBwEaAAoADgAjACcAKwAvADMANwA7AD8ASQAAEzMXFQ8BFQcjJzUXIxUzFTM1LwE1IxUHIxUjNSMnNSMVMzUzNRUzNScVIzU3MxUjNRUjNTczFSM1FSM1OwE1Ixc3NSMVHwEVMzUvzgoDEAq7CUsTE0sQAyYJCRMKCRMmExISExMSEhMTEhITExIScxA4DwMTARkJXgYRfwkJ9Akmu3YQB1QvChISCi/hEhMTExMTExMTJRISExMmExMTFhBRUQ8HenkAAAAAAwAAAAABBwEaAAkADwASAAAlLwEjBxUXMzc1ByM1MxUzJzUXAQE4DXETE6kTE6leSzg43DgFEuETE6io4UsSOTkAAAAEAAAAAAETASwADQAQABcAHQAAEyMHFSMHFRczNzUzNzUnFyMHIzUzFRczNyM1MxUz23ESORISlxI7EDgeHiaWORJLS5ZeOAEsEzgTvBISORKXHh7hu3ESE7s4AAEAAAAAARoBBwAHAAABFQcVIzUnNQEZXUteAQcgWWhoWSAAAAIAAAAAARoBBwAHAA8AAAEVBxUjNSc1FxUzNTc1IxUBGV1LXnAmXuEBByBZaGhZIHFeXlkFBQAAAgAAAAAA+wEaAC0AUwAANyc2JicmJwYHBhcWFwcuAjc1Njc2NzY/ATY3Njc2JzceAQc2PwEVFhcWBw4BJxcGFhceAQc+ATc2JicOAS8BNiYnBgcGDwEGBwYVMQYWFyY3NjerCgkDCxIEDgIDBgMKCxQfEQEBAwQJChAICQcKAwQGDR8bCQYEEQoGCwsJJTsQAQkJDQoEDBIFBQQIBhMKBgwJFAIRCQ8CFwkEARAPCgUGHBMOCxwJDxYTEQ4NCA4OBBglFAcJCQ0NDw4ICgsPDBEMDBZHJQcIAgEQEyUbFBp/Bw0ZCQkcDwQRCxEjEAkJAg0bOxYWGg0PAhQXDAoSHwoXFRwfAAAAAgAAAAABCwEaAAYADQAAAScHJwcXMzcnBycHFzMBCg1wcQ13DXcNcHENdw0BDA1wcA13Bg5xcQ53AAAAAgAAAAABDgEaAAYADQAANxc3FzcnIwcXNxc3JyMTDXBxDXYNeA1wcQ12DaENcXENeOgNcHANeAACAAAAAADuAQAABgANAAA3BycHFzM3BzcXNycjB+BKSwxRC1GjTUwMUwtS/0pKC1FRzkxMC1JSAAQAAP//AS4BBwAUAB4AKwAyAAA3MxcVJic1Iw8BIxUzFhcjJzU3Mx8BMzcjLwEjFTM3Fz4BHgIOAi4CNhc3JwcnBxeRfwkIC3YQBlVgAgRvCQleBwt6AXoHEFBQEDERKCQXAhIhKCQWAxI4LQ8nGAwg9ApUBwQbEANxCQkJzgoDNhMDEDkQQgwCESIoJBcCEiEoJFI7DDQTDhoAAAUAAAAAARoBBwASABwAIAAkACgAADczFxUjNSMPASMVMxUjJzU3Mx8BMzcjLwEjFTM3FzMVIzczFSM/ARcHkX8JEncQB1ReZwkJXgcLegF6BxBQUBAQExMmEhIlEiYR9ApBExADcRIJzgoDNhMDEDkQNXBwcGkHagYAAAADAAAAAAElAQcADQAZACAAADczPwEnIzUnIy8BIwcVNzMfATMVIw8BIw8BFyM3Mz8BMxzOCTIJFQpsEQZeCRNQEAdnVQYQRwkTvbofRQYQbSYGhAwuChADCs7FEAMlAxAHOTFeAxAAAAMAAAAAARoBBwAKABIAHAAAJSMvASMHFRczNzUHFSM1Mz8BMycjDwEjNTMfATMBEH8QB14JCfQJE+FVBhB3AXoGEFBQEAd69BADCs4JCbuVHXEDEBIDEDkQAwAABQAAAAABLAD0ABMAIwBAAEkAUwAANzMyHgEdARQOASsBIi4BPQE0PgEXIgYdARQWOwEyNj0BNCYjByIGHQEjIgYUFjsBFRQWMjY9ATMyNjQmKwE1NCYXFAYiJjQ2HgEHFAYiJj4BMhYVS5YUIxQUIxSWFCMUFCMUFyEhF5YXISEXegQFHAQGBgQcBQgGHAQFBQQcBokLEAsLEAsTCxALAQoQC/QUIxQ4FSIUFCIUORQjFBMhFzgYISEYOBchJQYEHAUIBhwEBQUEHAYIBRwEBhMICwsQCwEKQAgLCw8LCwgAAAAABAAAAAABGgEaAB8ANwBAAEkAADcnIw8BJwcXDwEVHwEHFzcfATM/ARc3Jz8BNS8BNycHJxc3FwcXFQcXBycHIycHJzcnNTcnNxc3FxQGIiY0NjIWBzI2NCYiBhQWqwoWCg0lERgDLS0FGA8lDwgWCg8lDxgFLC0GGA8lCAonJhstLRsmJwo0CiclGi0tGSYnCEAXHhYWHhcmCAsLEAsL2i0tBhgPJQ0KFgoPJQ8YBSstBRgPJQ8IFgoPJQ8YQy0ZJicINAonJRotLRkmJwg0CicmGy2DDxYWHhcXIgsQCwsQCwAABQAAAAABBwEaACIAJgA5AEwAUAAANyM2NSYnJi8BJiIGBwYHJicmIyIHBgcGDwEUFyMHFRczNzUHIzUzNSM1JjU3Njc2NzYyFxYXFhcWFTM0NzY3Njc2MhYXFh8BFAcVByMXIzUz/R4CBAMGCAUICQgDEQ0NEQwFCQgHBgMEAQIeCQnhCoRdXTgCAQIDAgcCDwQJBgQBAhMCAgQFCgMPCAUBAQICAjZeXl7hCA8LBQkDAgMBAgUUFAUDBQMJAwsDDggJqQkJqaCWEwQFCgMFAQQEAgIECAUDBQUFBQMFCAQCBAYBAwUKBQICqZYAAAAABQAAAAABGgEaABMAFgAmADAANAAANzMVFyMnNTczHwIVJic1Iyc1IxcnFRcVMxcVByMnNTczNTQ2MhYHBh0BMzU0LgEGBxUzNThLAlYJCZEGPgMIC0IJcbw4QRMJCXEJCRMWHxYzBSUGCgwlXiYSAQn0CQI+BzALBwgJQjk5OUsSCksJCUsKEhAWFgIGCBISBgkFAjc4OAACAAAAAADhASwADwAYAAATMxUeARQGBxUjNS4BNDY3FzI2NCYiBhQWjRIcJiYcEhwmJhwJFB0dKB0dASxMAyo6KgNMTAMqOioDex0oHR0oHQAAAAAEAAD//gEcARoAHwAqAEkAVQAANyc3FxUHJzcjBiY9AS4CPgEzMhcWFxYVFAYHFRQWMycWPgIuAQ4CFhcWFx4BBw4BLgI2NzY3NTQmKwEXByc1NxcHMzIWDwE+Ai4CDgIeAYsYDCgoDRgjExwOFAULFw8JCRIIAxUQEAw1CBQOAgoQEA0DB8gOCgwDCQgaHBQGCwwICRELIxgOKCgOGCMTHAEGBwwHAQkQEQwDBxA4GA0oDSgOGAEcE2gDFBwaEAMIEgkJERoDZwwRmwUCDhQPBwMNEBB7AwoMIQ4MCwYUHBoIBQJoDBAYDSgNKA0YGxSyAQgODg4GAwwREAoAAAAABAAAAAABBAEHAAMADQARABUAABMjFTMHJzcXNTMVNxcHJzMVIxcjFTOpExMQXg1OE00OXhATExMTEwEHE85dDk4bG04OXagSJhMAAAQAAAAAAQgBLQA0AD8ASgBXAAA3LgEHBgcGBy4BJzI3PgE1NCcmJyYjIg4BHgEXFQYHDgEeAj4BNTYuASc1FhcWFx4BPgE0Bx4BDgIuAT4CJyIuAT4CHgEOARcOAS4CPgIeAgb5DCEODAYBAR4qAwQEDRAEBxIJCg4XCwUUDgkICwsFFBwbDwEJEgsPFhMUBB0kGKgICgIOFA8HAw0QAwgOBwMNEBEKBA+NBQ4OCwYEDBEOCQMEmwwDCQgNBAQDKh4CBhcOCgkSBwQQGhwUA18CBQgbGxQGCxcPCRQPAi0VCwoBEhUDGyUyBA8UDgIKEBANA4IKDxEMAwcRFA17BQQDCQ4RDAMGCw0OAAAGAAD//gEaARoAIQAtADkASgBVAGEAADcGDwEVFhceARUUDgIjIi4BPgE3NS4CPgEzMh4CFRQHLgEiDgEeAj4CJxYyPgEuAg4CFhcWFxYVFA4BLgI2NzY3NTMXPgEuAQ4CHgE2JwcXNxc3JzcnBycHaQgNCAQEDRAHDRIJDxcLBRQODhQFCxcPCRINBxYEDRAOBwMNEBAJASwHEA0IAQkQEQwDB8gOCg4QGhwUBgsMBwoSCwcCChARDAMGEBQdHw0fIA0fHw0gHw3QDAYCXgECBRgOChEOBxAaHBQDXwMUHBoQBw0SCQ+fBwgKDxEMAwYOD54FCA4QDQcEDBAQewMKDhMOGAsGFBwaCAUCQ4UHFBAGAwwRDwsC2B8OICAOHyANHx8NAAAAAAUAAAAAASwBGgAdACoANgBKAFYAADcGDwEVFhcWFRQHDgEiLgE+ATc1LgI+ATM2FgcUBy4BIyIGFx4CPgInFjI+AS4CDgIWFyM1NCYrARcHJzU3FwczMhYXFgcVIzUjNTM1MxUzFSNpCA0IEwoIAwYYHRcLBRQODhQFCxcPEx0BFgQNCA0RAwENEBAJASwHEA0IAQkQEQwDB8gSEQsjGA4oKA4YIw4YBQQBEzg4Ezg40AwGAl4EEAwOCgkNEBAaHBQDXwMUHBoQARwUD58HCBUNCAwDBg4PngUIDhANBwQMEBAvHAwQGA0oDSgNGBANCQnFOBM4OBMABwAAAAABGwEaACAALAA4AEEASgBTAFwAADc+ATU0LgIjIg4BHgEXFQ4CHgEzMj4CNTQmJyYnNRceAQ4CLgI+ATInIi4BPgIeAg4BFxQGIiY0NjIWBzI2NCYiBhQWJxQWMjY0JiIGNRQWMjY0JiIGVA0QBw0SCQ8XCwUUDg4UBQsXDwkSDQcQDQQEBQYIAQkQEA0DBw4QCAgOBwMMERAJAQgN0BsnGxsnGy8MEREXEREHCw8LCw8LCw8LCw8LvgYXDwkSDQcQGhwUA18DFBwaEAcOEQoOGAUCAV51BA4PDgYDDBEPCoMKEBAMBAcNEA4InxQbGyccHC8QGBAQGBCICAsLDwsLSAcLCw8LCwAAAAAE//8AAAEHARoADwAbAB8ANQAANxUXMzc1LwIjFTMXFSM1NyM1IxUjFTMVMzUzBzMVIzcHJzcjIgYUFjsBFSMiJjQ2OwEnNxc4E6kSBTgOJSU5qYMlEyUlEyVdXV0TKA0YOAwQEAwJCRQbGxQ4GA0ocUsTE6gOOAUSOahLSyUlEyYmSxOZKA0YEBgQExsnHBgNKAAABAAAAAABGgEaABEAFgAiAC4AACUvASMHFRczJicjNTMXFRYXNQcjFTM0JzM1MxUzFSMVIzUjFyIOAR4CPgE1NCYBATgOcBMTZAkGVXA5CghuJyUlJRMlJRMlcBEcDQYYIh8TIdw4BRLhEwgK4jk6AwVCcBMKZyUlEyYmJhMfIhgGDRwRFyEAAAUAAP/+ARoBGgAdACoANgBXAGMAADcGDwEVFhcWFRQHDgEiLgE+ATc1LgI+ATM2FgcUBy4BIyIGFx4CPgInFjI+AS4CDgIWFxYXFhUUDgEuAjY3Njc1NCYrARcHJzU3FwczMhYXFgcXPgEuAQ4CHgI2aQgNCBMKCAMGGB0XCwUUDg4UBQsXDxMdARYEDQgNEQMBDRAQCQEsBxANCAEJEBEMAwfIDgoOEBocFAYLDAgJEQsjGA4oKA4YIw4YBQQBCwcCChARDAMGCw0O0AwGAl4EEAwOCgkNEBAaHBQDXwMUHBoQARwUD58HCBUNCAwDBg4PngUIDhANBwQMEBB7AwoOEw4YCwYUHBoIBQJoDBAYDSgNKA0YEA0JCaoHFBAGAwwRDgkDBAAABQAAAAABBwEOAAkAFwAhACUAKQAANxUzNRc3JyMHFw8BFRczNzUnIw4BIiYnFzMVIzUzHgEyNiczFSMVMxUjgxMyDUINQg42CQnhCgpCBBohGgNpLM4rCCAnID0TExMT8CIiMg5BQQ47CV4JCV4JEBUVEBJLSxEVFVwTExMAAAADAAAAAAEHAQ4ACQAXACEAADcVMzUXNycjBxcPARUXMzc1JyMOASImJxczFSM1Mx4BMjaDEzINQg1CDjYJCeEKCkIEGiEaA2kszisIICcg8G1tMg5BQQ47CV4JCV4JEBUVEBJLSxEVFQAAAAADAAAAAAEHARoACQAXACEAADc1MxU3FwcjJzcPARUXMzc1JyMOASImJxczFSM1Mx4BMjaDEzINQg1CDjYJCeEKCkIEGiEaA2kszisIICcgrWxsMQ1CQg1bCV4JCV4JEBUVEBJLSxEVFQAAAAAFAAAAAAEaARoADAAYAB8AIwAnAAA3MxcjJzU3MxcVJzUjFwczNycjNycjDwEXNzMHMwc3IycjNTMHIzUzOTANRgoK4QkTzmgbKmkNHw8PNhErESs2I0JsHzMKNj8aJS5xEwmpCQlaITCpQWwgGx0LXhpwOG1IOBM5EwAAAQAAAAABGAEhAGwAACUWFRQHBgcWHQEUBiImPQE2Jic3Njc2NzY1NC8BNicGDwEmBycmIwYXBw4BFRQXFhcWHwEGFxUWBiImPQEGJyYnJi8BLgEnLgE+ARcWFxYfARYXFjc1JjcmJyY1NDcmPwE2FxYXNhc2NzYfARYBBxEXEiAGBQcFAQUFBRYNEQkLEAIHBhETBykpBxoLBgcDCAkLCBINFgULAQEGBwYRDQsJBQgBBQcDAgMCBgMHBwMHAQoIDRUCByARGREFCQYEChAVKSoUEAsEBgnqFBstGBEFChEuBAUFBC4IDQYOAwYHDxIdFhEKEBIEDQILCwIQExAJCBUKHREPCAYDDwoPLwQGBgQaBAQDCAQLAQYGAQEGBgQCAQUDCAINBAcFBA4NBhEYKxwUGhUEAgEDDQoKDQQCAgUZAAAAAf//AAABLQEsAFQAABMiDgEVFB4BFzI2PQEGJyYnJi8BLgEvASY3NjMxHgEfARYXFjc2NyYnJjU0NzEmNzMyFxYXNjMyFzY3NhcxFg8BFhUUBwYHHgEdARQWMz4CNTQuAZYpRSgaLh4FBQ4LCQcEAwMCCAMDCQQCBAYLAwMJDgoKAQgeEBYQBwkEBggKDQ8XERQSDQcDCAUBEBYPHwQGBQUeLxkpRQEsKEUpIDoqCgQEGQMDAgUEBQQICgMBBgMBAQcEBA8BAQQMCAQNEycXERMUAwQJBQUMAwIBExQBERcnEg0EAw4KKQQECis6HylFKAAAAAMAAAAAAQcBBwALABMAFwAANzM1MzUjNSMVIxUzJzMXFQcjJzUXMzUjcRJxcRI5OULOCgrOCRK8vDhxEjk5El4KzgkJzsW8AAIAAAAAAS0BLAAMAGoAABMiDgEUHgEyPgE0LgEDIyImPQE0Jic+Ajc2NTQmJz4BNCYnIyIGDwImBy8BLgErAQ4BFBYXDgEVFBceAhcOAQcOASYvAi4BIwcGFB8BFh8BHgE3MzcVFAYrAS4CPgIyHgIOAQeWKUUoKEVSRSgoRQECAgQEBQ0XEAMEBwYBAQICAgUIBAkHICAHCQQJBAMBAgEBBgcEAxAWDQMEAQcPCwQEBAMGAwUBAggCAgYDEQoGBwQDAR0sEwokNz43JAoTLB0BLChFUkUoKEVSRSj+8AMDIwcNBAEJEAsNDgkSBwQHCQkFAgIFBAkJBAUCAgUJCQcEBxIJDg0LEAkBAwkFAwEIBwQFAQMBAQICBgICCwkKAQEWAwMJLDo+MhwcMj46LAkAAAAACgAAAAABGgEaAAwAEgAeACoAMQA3AEEASABNAFMAABMyHgEUDgEiLgE0PgEXLgEnFh8BNjUmJyMWFRQHMzYnNTY0JyMGFRQXMzYnJicrAQYHIzY3DgEPAQYUFzMmNTQ3IxcjHgEXJicXNjcjFjcGBz4BN58hOCEhOEI4ISE4fQkeEgwGMgEBAywBBC8CQQECSAEEQwIDBxAKCREGFAUNEx0JCAQELwQBLDQsCiYXEgkvEgo3CUIJEhclCwEZIThCOCAgOEI4IUsSGgYXGzgFBA8NCggTEwkKAQkSCQkJExMKQR4aGh4bGAcaEhIOHQ4TEwgKShYcBRkdMRYbGxweGQUcFgADAAAAAAEsARoAFgAnACoAAD8BNScHFyMiBhQWOwE1IyIuATY7AQcXNyMnMx8CFQcjJzUXFTM1IzcVM3EmKA0YOBQbGxQJCQwQAREMOBgNXzITWA05BROoExOoSxM4vScNKA0YHCcbExAYEBgNSxIFOA6oExOMEHyWSzkAAwAAAAABDwEaAAMAGgAwAAA3Bxc3Jx4BMj4BNC4BIyIHFzMyHgEUDgEiJic3Byc3IyIGFBY7ARUjIiY0NjsBJzcXWkcORx0NMTovHBwvHAwMEQcXJxYWJy0lCzYoDRg4DBAQDAkJFBsbFDgYDShuRQ1FIhkfHC84MBsCERYnLicWFBFhKA0YEBgQExsnHBgNKAAAAAIAAAAAARoAvAADAAcAACUhFSEVIRUhARn++gEG/voBBrwTJhIAAAAHAAAAAAEaAQ8ACQARABUAHQAhACkALQAANxcHJzU3FwczFQc1NzMXFQcjNzUjFTc1NzMXFQcjNzUjFTcVFzM3NScjFxUjNSgQCyAgCw/wzgkmCQkmHRM4CSYJCSYdEzgJJgkJJh0T4RELHwwfDA8TxqsICKsIEZmZHYUICIUJEXV1fWAICGAIEFBQAAIAAAAAASABLAAGABMAACUVIyc1MxU3ByMnByc3Mxc3MxcHARn9CRPOYQ0fRA5LDh9gDSYNOBIJ/fS4YR9EDUsfYSYNAAAAAAYAAAAAARoBLAAGAAoADgASABYAGgAAJRUjJzUzFTczFSM3MxUjBzMVIwczFSM3MxUjARn9CRM4JSWDJiZLJiY4JSWDJiY4Egn99M8mOCUmJSYlOCUAAAAHAAAAAAEaASwABgAOABIAGgAeACYAKgAANzM1IzUjFTc1NzMXFQcjNzUjFTcVFzM3NScjFxUjNQc1NzMXFQcjNzUjFRz98xMlCiUKCiUcE4MKJQoKJRwTXgolCgolHBMmEvT9JZYKCpYJE4ODsrwJCbwJEqmps3EJCXEJE15eAAYAAAAAAM8A9AADAAcACwAPABMAFwAANzMVIxUzFSMVMxUjNzMVIxUzFSMVMxUjXiUlJSUlJUslJSUlJSX0JiUmJSa8JiUmJSYAAAALAAAAAAEHARoACQARABUAHQAhACkALQA1ADkAPQBBAAATMxUjFTMVIyc1FyMnNTczFxUnMzUjFyMnNTczFxUnMzUjByMnNTczFxUnMzUjFyMnNTczFxUnMzUrAhUzNSMVMxwmHBwmCXomCQkmCSUSEow4CQk4CjkmJkEmCQkmCSUSEow4CQk4CjkmJhImJiYmARkS4RMJ9GcJJgkJJgoSJQk4Cgo4CiWWCSYJCSYKEzkKOAkJOAkmE3ASAAEAAAAAARoBBwAcAAAlLgEnLgEiBg8BJy4BIgYHDgIUHgEfATc+AjQBFwIJBwoaGxkKDQ0KGRsaCgcJBAQJB29vBwkE0gkRBgoKCgkNDQkKCgoHEBISEhAHbm4HEBISAAIAAAAAARoBBwAdAD0AACUuAScuASIGDwEnLgEiBgcGBwYUHgEfATc2NzY1NAcGDwEnLgI0PgE3Njc2FxYfATc2NzYXFhcWFxYVFAcBFwIJBwoaGxkKDQ0KGRsaCg0FAgQJB29vBwQJFQMKYWIFBwMDBwUHChMUCQcaGQcKExQJBwUDBwHSCREGCgsLCQ0NCQsLCg0TCRISEAZvbwYIEBMJFQ0KYWEFDAwODQsFBwQICAMIGRkHBAgIBAcFBgsOBwYAAAACAAAAAAEdARsAHgAlAAA3PgEmJy4BDgEHNSMVFzM1Iz4BHgEOAiYnBx4CNic3JzUjFRf9Eg0MEhM8QTgQEwlCKRNISi4CMUtGEhAPOEI+Kw42EwNFFzk5FxocBCEcLUIJEiIdFT5NPBIhIgkdJgYbLA02R0sHAAACAAAAAAEUARMAEQAcAAATFwcnFQcjJzUjFQcjJzUHJzcHFTM1NzMXFTM1J513DRMKOAkmCTgKEg53RCYJOAolSwESbA4RegkJQkIJCXoRDmxYgkIJCUKCRAAAAAQAAAAAAPQA4gALACAALAAwAAA3MzUjFSM1IxUzNTMXMyc2NzY3NjQuAScmJyYrARUzNTM3BisBNTMyFhUUBwYXIxUzeQ8PMRAQMWoRGAMECAMCAwUEBgcEAy4PHAkDAiAgBgoBAxe8vHFwMTFwMDAxAQMGCQULCgcDBQIBcC4QASQKCAUDB2YTAAAABQAAAAABBwEaACQALgA7AD8AQwAANzMXFTMXFQcjFQcjByc1Iyc1Iyc1NzM1NzM1LgE1NDYyFhUGBxc1IxUXMxU/ATMnBgcxBiYnBx4BMjY3JyMVMzczFSOfSwkKCgoKCTovEC8KCQkJCQpLBAYLEAsBCUKWLwkiBzUoCw4NGAkNChkcGQlMExM4ExPhCSYKEgk5CTQHLQw2CRIKKAcVAwgGBwsLBwsFYThuAikmAy4KAwMICQ4JCwsJMxMTEwAAAwAAAAABGgEaAAkAEwAdAAA3Mzc1LwEjDwEVNyM1Mx8BMz8BMycjDwEjLwEjNzMc9Ak0CI0JNPThLw4IVggNMQE1CQxLDgg1MX8mCVSQBgaLWQk4FwUFFxMFFxcFhAAAAQAAAAAA9ADPABEAADcVFBY7ASc3FxUHJzcjIiY9AUsFBIEeDTAwDR6BCxHOJQQFHg4wCy8NHhAMJQAABAAAAAABGQEbABMAJwArAC8AABMeARceAQYHDgEmJy4DPgMXPgE3PgEmJy4BBgcOAR4BFx4BNyczNSMXFSM1oRYpDxgSDBUTNzwbFB4RAg0aJisgEiEMEgsQFBIxMxUZGgMfGhEmEh8YGBgYARkDExAYPkAaGBkCDgsiKi0sJBoL8wQUDxY3NRUSEQcOETU7Mg4JBgSUEiVLSwAABQAAAAABGgEaAAcACwATABcAHQAAARcVByMnNTcXIxUzFRcVByMnNTcXIxUzJxcHFzcnAQcSEpYTE5aWlhISlhMTlpaW9B4eDSsrARkSSxMTSxISSzkSSxMTSxISS44eHg0rKwAAAAADAAAAAAEnAQcADAAQABQAAD8BMxcVIzUjFTMVIycFJxU3BzUXIxMT4RIS4V1dEwEUfjMgPSX0ExNxcZYTEyB+sTMGVj4AAAAJAAAAAAEHARoABwANABUAGwAkACoAMgA4AEEAADcXNjQnBxYUJzcmJwcWJzcmIgcXNjIHJwYHFzYHNDcXBhYXByYXBxYXNyYXBx4BNycGIjcXNjcnBicyNjQmIgYUFu8SBgYSBQsQEiMJHiwFEicSBg8hPwkjEhEPLQYSBgEFEgYeERIjCR4tBhInEgUQIT8JIxIQEEwHCwsPCwt/BRInEgYPIT8JIxIRDxUSBgYSBgwREiMJHk0UEgYPIRAFEhsJIxIQEBYSBQEGEgULEBIjCR46Cw8LCw8LAAAAAwAAAAABIwEbABUAMAA5AAA3By8BNxc+Ax4DFyMuAgYHNx8BBycOAy4DJzM1FB4DPgI3Byc3JxQWMjY0JiIGYz0NGREPCBskKCklHBABEgQySD4MLK0ZEQ8IGyQpKSQcEAITDBgfJCMgFwcrBz1/CxALCxALwhkFPAckEx8UCAYUHiYUJDQJJyISQz0IJRMfFAgHFB4mFQkSIhwSBgYSHBESEhkKCAsLDwsLAAMAAAAAAQcBGgANABsAJAAAEyIOAR4CPgEnNi4CByIuAT4CHgEVFA4CJxQWMjY0JiIGjSU+HA41SEQqAQETIi0YIDQYDSw9OiMQHSYnCw8LCw8LARkpREk0Dhw9JRksIxLhIzo9LA0YNCAUJh0QZwcLCw8LCwAAAAEAAAAAAOABBwAcAAA3ByM3Mjc2NzY/ATY1NC4BIzczByYOAQ8BBhQeAakCXAIOBQcDBgYmBQQJDAJWAgoNCAYmBgQJLQYGAgMFCBSHEAkEBwIHBwEGDBWHEwkGAwAAAAIAAAAAARoBBwAbADEAADcjJzUjLwE/ARceARcWFxY3Nj8DHwEPASMVJzM1NzM3JwcGBw4BIiYnJi8BBxczF9+TCRsJDAZQDAEFAgUGDg0GBQUEDFAGDAkbk4AJHQg/AwMDCBQVEwcEAwNACRwKIQp9BzILGwYFBwIFAwUGAgUFCQYbCzIHfQl9CSMVBAUDCAgICAMFBBUjCQAAAAIAAAAAAQcBBwBGAI0AADc1IyIOAQcxBgcxBhcVFAcxBgcGKwEVMzIXFRYXFRYXMRYdAQYXFRYXMR4CFzM1IyIuAj0BNCYnJic2Nz4BPQE0Njc2MxcVMzI+ATcxNjcxNic1NDcxNjc2OwE1IyInNSYnNSYnMSY9ATYnNSYnMS4CByMVMzIeAh0BFBYXFhcGBw4BHQEUBgcGI3ECCREMAwMBAQECBAoFBgEBBgUFAwQCAgEBAQMDDRAJAgIGCgcEAgIFCQkFAgIJBwUGTQEJEA0DAwEBAQIECgUGAgIGBQUDBAICAQEBAwMNEAkBAQYKBwQCAgUJCQUCAgkHBQb0EwcNCAgICAgQBgUKBQISAgECAwEDBQUGEAgIAQcICA0GARMECAoGGQYMBQsHBwsFDAYZCQ0EArwSBg0IBwkICBAGBQoFAhICAQIDAQMFBQYQCAgBBwgIDQcBEgQICgYZBgwFCwcHCwUMBhkJDQQCAAAAAwAAAAAAqgEHAAsAFAAdAAA3HgE+AiYnJg4BFjciJjQ2MhYUBiciJjQ2MhYUBowECgkFAQQFBg8IAhEICwsQCwsICAsLEAsLKQMBBQgKCQMEAw0PVgsQCwsQC14LEAsLEAsAAAMAAAAAARwBHAAcADkARQAAEx4CBw4BIyInDwEjFQcjFQcjJzU/ASY1ND4CFzY3MTYuAgcOARUGFw8BFTM1NzM1NzM/ARYzMjc+AS4CBgcGHgE21RcjDAQGLx4NCw8HEwkcCjgJAl4EER0lLBIFAwkYIBEWHgEFAl4lCR0JFxEKDAwXAwMBBQgLCQIEAw0OARgFICsWHSYEEgMcChwJCSsHXQ0OEiMXCYoOFxEgGAkDBSQXDQwKXx4dCRwJEwMEQgQKCQYBBQQHDwgDAAYAAAAAARoBGgAvADYAOQA9AEAARwAAJSczNSM1IxUjFTMHIxUzHgEyNjczNSMnMxUjDwEXMzcvASM1MwcjFTMeATI2NzM1BwYiJiczBicjNx8BIz8BFyMXBiImJzMGARIeE14TXhMeBwIFGB4ZBQIIHzolCCUHqQclCCU6HwgCBRgfGAUCtwYPDAQvBAEmE3YXgxd2EyYgBg8MBC8EqUsTEhITSxMOEhIOE0uWBC8PDy8ElksTDhISDhMdAwcGBhktixwcii0cBAgGBgAAAAAGAAD//QEtARgABwALABcAHwAsADMAABMjBxUXMzc1BzcXDwEnMxc3MwcjIgYPARcHJyMXMzcmNzYXMhYVFA4BLgI2FzcnBycHF5kKb28Kc9ZeYWEFbSFRVCIPBxknCBMQFVEhbQoUBCsPERchEx8iGAcNLiIPHBAMGAEYTBBKShAIQUE/Qko3NwodFg0ODjdKDQk9CgEgGBEcDQYZISA/LQslDg8TAAAFAAAAAAEsARgABwALABcAHwAoAAATIwcVFzM3NQc3Fw8BJzMXNzMHIyIGDwEXBycjFzM3JjcUFjI2NCYiBpkKb28Kc9ZeYWEFbSFRVCIPBxknCBMQFVEhbQoUBBMgLyEhLyABGEwQSkoQCEFBP0JKNzcKHRYNDg43Sg0JDhchIS8hIQAEAAAAAAEMARgABwALABIAGQAAEzMXFQcjJzU3Bxc3BxczNyMHJxcnMxc3MwePCnNzCm90Xl5h020KcSJUUUxtIVFUInEBGEwQSkoQOUE/PzdKSjc3eUo3N0oAAAIAAAAAARoBGgAHAAsAABMHFRczNzUnFSM1MyYTE+ESEry8ARkS4RMT4RLz4QAAAAIAAAAAARoBGgAHAAsAABMHFRczNzUnBzUzFSYTE+ESEuG7ARkS4RMT4RLz4eEAAAMAAAAAARoBGgAHAAsADwAAEwcVFzM3NScHNTMVMzUzFSYTE+ESEuFLS0sBGRLhExPhEvPh4eHhAAAAAAUAAAAAARoBGgAHAAsADwATABcAABM3MxcVByMnNxUzNQczFSM3MxUjNyMVMxMT4RIS4RMT4c8mJjklJV0lJQEGExPhEhLh4eESExMTExMABAAAAAABGgEaAAcACwAPABMAABMHFRczNzUnBzUzFTc1MxU3MxUjJhMT4RIS4SUTcBMmJgEZEuETE+ES8+HhS5aWluEAAAAABAAAAAABGgEaAAcACwAPABMAABMHFRczNzUnBzUzFTM1MxUzNTMVJhMT4RIS4SUTcBMmARkS4RMT4RKolpaWlpaWAAADAAAAAAEaARoABwALAA8AABM3MxcVByMnNxUzNTMVMzUTE+ESEuETE5YSOQEHEhLhExPhlpbh4QAAAAADAAAAAAEaARoABwALAA8AABMHFRczNzUnBzUzFQczFSMmExPhEhLh4eHh4QEZE+ESEuETqZaWEjkAAAADAAAAAAEaARoABwALAA8AABM3MxcVByMnNxUzNTMVMzUTE+ESEuETEzgTlgEHEhLhExPh4eGWlgAAAAACAAAAAAEaARoABwALAAATBxUXMzc1Jwc1MxUmExPhEhLh4QEZEuETE+ESqJaWAAADAAAAAAEaARoABwALAA8AABMHFRczNzUnBzUzFTM1MxUmExPhEhLhSxKEARkT4RIS4RP04eHh4QAAAAACAAAAAAEaARoABwALAAATBxUXMzc1JxUjNTMmExPhEhKEhAEZEuETE+ES8+EAAAADAAAAAAEaARoABwALAA8AABMHFRczNzUnBzUzFTM1MxUmExPhEhLhgxNLARkT4RIS4RP04eHh4QAAAAACAAAAAAEaARoABwALAAATBxUXMzc1Jwc1MxUmExPhEhLhgwEZEuETE+ES8+HhAAACAAAAAAEaARoABwALAAATBxUXMzc1Jwc1MxUmExPhEhLh4QEZE+ESEuET4c7OAAAGAAAAAAEaAQcABwALABMAFwAfACMAABMHFRczNzUnBzUzFT8BMxcVByMnNxUzNQc3MxcVByMnNxUzNTgSEksTE0tLORI5EhI5EhI5SxI5EhI5EhI5AQcTvBISvBPPvLy8ExM4ExM4ODiDEhI5EhI5OTkAAAYAAAAAASgBBwAHAAsAEwAXAB8AIwAAPwEzFxUHIyc3FTM1Fz8BHwEPAS8BFzcvATczFxUHIyc3FTM1XgkmCQkmCRMSKQYjDEYFIwwyQBJBvwkmCQkmCRMS/QoKzgkJxby8BwwNBcIMDQXAsAawDAoKzgkJxby8AAMAAAAAARoBGgAIABIANwAANyIGFBYyNjQmFycHNyczNxczBycOAQcjFRQWOwEWFyMGJj0BNCYnLgE1NDc+AzMyHgEVFAcG4RchIS4hIQIZGAkWGwoKHBcfEh0HIwMDGgMFIgoPCgkMDgwFEBMVDBcnFwcEgyEuISEuIV0SEhwQHx8QUgMYEikCBAoIAQ8KHg0YCQsfERcTCg8LBhYnFxIOCQAAAwAAAAABHQEaADsAWABsAAA3Njc2PwE2NzY1NC4EIg4EBx4BFx4BHQEUHgI7ATI+AjUnIyYnFRQGKwEiJj0BMz4BMzcyFzY3Njc2MzAxJyYnJicmJwYHBgcGDwEXFhcWFxYXNjc2MhcWFxYUBwYHBiInJicmNKgFCAYEAgIHBQYLEBMVGBUTDwsGAQENDAoKAwcJBR4FCQcEAQIJBwMDHgIEJQMLBwIEMwYOCw0HBQcICAsICgQFCggLBwkHBwkHCwgKHwkGAgcCBgkCAgkGAgcCBgkCeAoIBQYHCAUNDwwVEw8LBgYLDxMVDBIdDAoXDR4FCQcDAwcJBQgBBg8CBAQCKQYIAVAYDwoFAgEBBQYKDhMTDgoGBQEBAQIEBgsNBQYJAgIJBgIGAgYJAwMJBgIGAAACAAAAAAD1ARoAIQArAAA3DgEdARQGBwYnIwYmPQE0JicuATU0Nz4DMzIeARUUBgcjFRQWOwEyNjXbCQsIBwQFHgsOCgkMDgwFDxMWDBcnFg0zKQMDHgIDigkYDR4HDQMCAQEPCh4NGAkLHxEXEwoPCwYWJxcSHi4pAgQDAwAAAAIAAAAAARoBGgAMABYAABMzFSMVMzUzFQcjJzUhFSM1Byc3IzUzHFVL4RIJ9AkBBhJ/DX5jegEZEuFLVQkJ9Hpjfg1/EgAAAAIAAAAAARoA9AAkAEkAADczMh4BHQEUDgErATUzMjY9ATQmKwEiBh0BHgEXFS4BPQE0PgEXNR4BHQEUDgErASIuAT0BND4BOwEVIyIGHQEUFjsBMjY3NS4BUzkSHRERHRIJCRMaGhM5ExsBFRAYIBEdoBggER0ROhIdEREdEgkJExoaEzoSGgEBFfQRHhEEER0SExsSBBMaGhMEEBkDEwMkGAQRHhFMEwMkGAQRHhERHhEEER0REhsSBBMaGhMEEBkAAAADAAAAAAEHAPQAAwAHAAsAADc1MxUnMxUjNxUjNXFLcZaWvOFLExNeE14TEwAAAAAEAAAAAAEHAPQAAwAHAAsADwAANzMVIxUzFSM1MxUjNTMVIyaoqJaW4eHOzoMSJhOEE0sTAAAAAAYAAAAAARoBBwAGAAoADgASADMAawAAEzczFSM1BzczFSMVMxUjFyMVMyc/ATY0JyYnJiIHBgcGBxUzNTQ/ATIzFxUWDwIVMzUjFzIXFhUUBwYHBiIuAS8BJicxMxUXFjM/Ai8BKwE1NzM/ASc0Jg8BBh0BIzU0Nz4CMh4CFAcrBw0NBzO7u7u7u7u70wEBAwECBwUIBQYCAQEQAQEBAgEBAQITJRELAgEDAQIHBQgFBAICAQEQAQIBAQEBAQEBBAQBAQEBAwEBAQ8DAQQGBwYGBAMBAAc5KgYCEzgTOBNSAQEFCAQHAgICAgcDAwEBAQIBAgEDAwMVCw06AgQGAwMHAgICAwIEAwQCAgEBAgIDAgwBAQMCAQEBAQECAQEGBQIDAgIDBwkEAAAAAAMAAAAAARoA9AADAAcACwAANzUzFSchFSE3FSM1E6mpAQb++s7OSxMTXhNeExMAAAUAAAAAAQcA9AADAAcACwAPABMAADczFSMVMxUjNTMVIyczFSM7ARUjS6mpg4O8vDjOzjgTE4MSJhOEE0sTqQAIAAAAAAEaAPQAAwAHAAsADwATABcAGwAfAAA3IxUzFSMVMwczFSMXIxUzNzMVIxcjFTMHMxUjFyMVMyYTExMTExMTExMTJc7Ozs7Ozs7Ozs7O9BMlEyYSJhO8EyUTJhImEwAABAAAAAABIwEgABYAJwAzAD8AABM3FxUHJzUjIgcGBwYHJyY3PgMXMxcVNycVIyYGBwYHNjc2NzYzBz4BHgIGBwYuATYXHgE+AiYnJg4BFqwSZGQSCB8PFhQVFxMBBAQZKDAaDRZHRiQYLhEVCRQUEhYPHEIMHRoQAg0MEysZCR4HERAJAggHDBoPBgEXCVARTAkjAwQNDx4GDg4ZLCARAUEjNjghARERFh0TCggDAkoJAg0YHRsHDAkkLDsFAggPERAECAYWGgABAAAAAAEYARoADwAAJS4CIg4BByM+AjIeARcBBQUfMDYwHwUTBSU4QDglBakaKxgYKxogMx0dMyAAAAAEAAAAAADiARAAEAAeACcAMwAANy4BIzEiDgIfATM3Nic0Jic7AR4BFxQPAScmNT4BFyYOAR4BPgEmJz4BHgIGBwYuATbLChwPFSIUAQw7CjsMAQtBAQIWIAEJMDAJASAiBhAIAw0PCQMmCBUSCwEJCQweEQX6CgwVIioSd3cSFg8bDgEhFxANYWENEBchKAUDDQ8JAw0PFAYCCREVEgUIBhkeAAMAAAAAAPQBBwAHAAsAGwAAPwEzFxUHIyc3FTM1JzU0JiIGHQEzNTQ2MhYdATgTlhMTlhMTlhMhLiETFSAVlhMTXhISXl5eEyUYISEYJSUQFhYQJQAAAAADAAAAAAEHARoAEQAZAB0AADcjNTQuASIOAR0BIwcVFzM3NSc0PgEWHQEjFyM1M/QTFCMoIxQTEhK8E6khLiFwlry8qSUVIhQUIhUlE3ATE3A4GCABIRglg3AAAAQAAAAAARoBEAAWABoAHgAwAAATIg4BHQEXMzc1NDYyFh0BFzM3NTQuAQcjNTMXIzUzJzU0JiIGBxUjNTQ+ATIeAR0BliQ8IxM4ExYeFxI5EiM8XDg4qTk5OSAuIQE4HjQ8NB8BECM8JF4TE14PFhYPXhMTXiQ8I+E4ODgTExggHxYWEx40Hh40HhMAAwAAAAABGgEPAAcADAAUAAATIwcVFzM3NScXByMnFyM1HwEzPwGbCn4J9AmDahqgGNnhFAioCBUBD0uVCQmVOD8dHYVyGgMDGgAAAAMAAAAAARoA9AAHAA0AEAAAPwEzFxUHIyc3FTM1ByM3IxcTCfQJCfQJE+FrDGS8XuoKCqgKCpWMjFJcSQAAAAADAAAAAAEHAPQAAwAHAAsAADcVNzUXNScVFzU3FSZBSzhLQsWNKY2wjSONI40pjQADAAAAAAD0AQcAAwAHAAsAABMzByMXIyczFyMHM2eNKY2wjSONI40pjQEHQks4S0EAAAAABAAAAAAA/AEQAAMABwAVABkAADczByMVMxcjPwEnIw8BFRcHFzM/ATUHMwcjbHcjd3cjd2QsCI0ILywsCI0IL5B3I3f9OBM4QkYOBUsJRkcOBUsJDjgAAAQAAAAAARAA/AADAAcAFQAZAAA3FTc1MxUXNQ8BJzU/ATMXNxcVDwEjNxU3NS84EzhBRw4FSwlHRg4FSwkOOMB3I3d3I3dkLAiNCC8sLAiNCC+QdyN3AAACAAAAAAEaAM8AEAAXAAA3MxUjNwcjJxQVFyM1MxcWFzc1IxUjFzd3JxsBIRchARkoDw4BnCUkNzbOemNjYwcvLXorKwQWQkI2NgAAAwAAAAABGgDuAA8AFwAbAAA/ARcVBycOAi4CNy8BNRcGFRQeATY3Jxc1BybnDAxyAw8VFg8GAyYIQAELEA4CWNfXrUAKoQoeCw8GBRAVCwoKJD0CAgkMAggILDmKPQAAAgAAAAAA7gD1ADgAQgAANwYnBi4CNzQ+AjMyFxYVFAYjIjUOASMiJjQ+ATM2Fhc3MwcGFjMyNjU0JiMiDgEVBh4CNxY3JxQzMjY3NiMiBsQaHxEhGQwBDh0mFCQWGR8XFQYRCg4RDRcNCQ8DBBEPAwMGDhUlHxglFQEJFBsOHBlMEQsQBAkZDhJEDwEBDBkgEhQnHRATFSMeJxIJCRMiHRIBCggPPA0KHxYdIBgpGA8aFAoBAQ04FxIRJB4AAAAAAwAAAAABLADhAAMABwALAAAlITUhFSE1ITUhNSEBLP7UASz+1AEs/tQBLM4TqRM4EwAAAAIAAAAAAOsA/gAmADsAADcnIwcXNxUxFTEVFB8BFhceAR8BHgIdATM1NC4CLwEuAjcnFwc2NyYvAQYPAQ4DHQEzNTQ+ATfFKA4oDRUBAgICBA0HDgcMBxoFCwwHDQYLBgEBFTQDAwcEAgUGDQcMCwUaBwwH1SgoDRQTCQYFBQsGBgsRCA8HERMNERENGBIQBw4GEBQLHRRTBAMKDAUHBg4HDxMYDRERDRMRBwADAAAAAAD+ARAACwAPACMAADc0NjIWHQEUBiImNRc1MxUnBi4BNTMUHgE7ATI+ATUzFA4BI14hLiEhLiEvEhIaKxkTFCIVEhUiFBMZKxrYFyEhF0sYISEYjSYmJgEaKxkUIxQUIxQZKxkAAAAEAAAAAAD+ARoACwAcACAANAAANzU0NjIWHQEUBiImNyIOAR0BFB4BMj4BPQE0LgEDNTMVJwYuATUzFB4BOwEyPgE1MxQOASNnHCYcHCYcLxIeEhIeJB4SEh4bEhIaKxkTFCIVEhUiFBMZKxqNSxMcHBNLFBsboBEfEUsSHhISHhJLER8R/ucmJiYBGisZFCMUFCMUGSsZAAMAAAAAARoBGgARABYAGgAAEyMVIwcVFzMVMzUzPwE1LwEjFyM1MxcnMxUjlhNnCQlnE1QHKCgHVFDAwB+nXl4BGSUKSwmDgwImDiUDSzgcCRIAAAMAAAAAARoBGgAKABUAJQAAEx8BFQcnByc1PwEfATUnFSM1BxU3MT8BFxUHJzcjFwcnNTcXBzOhdAQOdXUOBHQVZ2cTZ2cjDi4uDR5xHg0uLg0fcgEZSwesCEtLCKwHS6tClkI2NkKWQloNLw0uDR4eDS4NLw0fAAMAAAAAARoA9AATAB4AIgAAJScjBxUzNRcGHQEfATM/ATU0JzcHFQcnNTY3FzM3Fi8BNxcBGYAGgBMrDwVLCEkGDz9CQUIBDTEHMA1BZ2dnwjIyd14RFRoIByIiCAgZFRlHAR4eARYSExMSESgoKAAEAAAAAAEQARoACQATAB0AJwAANwc1IxUnBxczNycXNxUzNRc3JyMPATMVIxcHJzU3FzMnNxcVByc3I8AhEiENMA4wbg0hEiENMA41IUFBIQ0xMWVBIQ0xMQ0hQWMgQEAgDTAwkw0gQEAgDTBQIBMgDjENMC0gDTANMQ4gAAAAAAUAAAAAARoBGgAMABAAGAAcACAAABM3MxcVByM1MzUjFSM3FTM1DwEVFzM3NScHNTMVBzMVI3EJlgkJLyaEEhKE6wkJlgoKjIODg4MBEAkJgwoTSxM5ExNeCoMJCYMKJhMTEksAAAAABQAAAAABBwEHAAwAFQAnACsANAAAJSMVJiMiBhQWPgE9AQcyFhQGIiY+ATcPARUmIw4BFBYyNj0BNxUzNQcVBzUHMhYUBiImNDYBBxMNDxQbGycbLgsRERcRARAxlgkNDxQbGycbhBMTgy8LEREXEBCpLwkbJxwBGxNVOBEXEREXEZUJCY0KARsnGxsUcQgSVAolCSaNERcQEBcRAAAAAAMAAAAAARkBFwAJABEAHQAANzM3FxUHJyMnNR8BNQ8BIxUzNxcHFwcnByc3JzcXHDRJEBBJNAlIOzsHLi63DSAgDSEgDSAgDSDOSAb0BkgJXlg7xzsCS0kNICENICANISANIAADAAAAAAEsARoAEAATAB8AABMfARUjNSM1IxUzFSMnNTczBxUzFyM1IzUzNTMVMxUjskACE0teS1QJCX4ENhUTODgTODgBF0EIJRNLzxIJ4QkSOc44Ezg4EwAAAAMAAAAAASwBGgASABwAKAAAASMvASMHFRczNSM1Mz8BMwczNQcjDwEjNTMfATMHIzUjNTM1MxUzFSMBEH8QB14JCWdeVQYQdwETE3oGEFBQEAd6ExM4OBM4OAEHDwMJzgoTcQIQJVQcAxA4EAL0OBM4OBMAAQAAAAAA9ADFABEAADcVFAYrATcnBxUXNyczMjY9AeEFBIEeDTAwDR6BCxHFJQQGHw0wCjANHxAMJQAABAAAAAABGgDSAAgADwAWACgAADc2HgEOAS4BNhcuAQ4BFh8BHgE+ASYnNxUUBisBNycHFRc3JzMyNj0BLBMuGgknLhoJRgkUEgoBBQ0JFBIKAQWcBgRNHg0wMA0eTQwQxQ0JJy4aCScuAgUBChIUCQ0FAQoSFAklJQQFHg4wCy8NHhAMJQAAAAUAAAAAARoBBwAHAAsADwATABcAABMzFxUHIyc1FxUzNQczFSMXIxUzBzMVIxz0CQn0CRPhvJaWcXFxcUtLAQcKuwoKuwmpqSYSExMTEgAAFwAAAAABLAEsAAMABwALAA8AEwAXABsAHwAjACcAKwAvADMANwA7AD8AQwBLAE8AUwBXAFsAXwAANyM1MxUjNTMVIzUzFSM1MxUjNTMdASM1FzMVIzczFSMDIzUzFyM1OwIVIzMjNTMXIzUzFyM1MxU1Mx0BIzUzKwE1Mxc3MxcVByMnNxUzNRczFSMVMxUjFTMVIyczFSMTExMTExMTExMTExMTExMlExMlExMlEhITExM4EhImExMlEhITExPOExNLE4MTE4MTE4MlExMTExMTll5ezhM4EzkTOBM5EyUTExMTExMBGRMTExMTExMTEyUSEiYTE0sSEqkTE6mpqRMmEiYTJYMTAAAAAAcAAAAAARoBGgAHAAsAEwAXABsAHwAjAAATNzMXFQcjJzcVMzUHNzMXFQcjJzcVMzUXIxUzBzMVIxcjFTMmEqkTE6kSEqmWE14SEl4TE15dEhISEhISEhIBBxIS4RMT4eHhJhMTExISExMTEyUTJRMmAAAABAAAAAABGgD6ACUAQABJAFIAACU2NzYnIyYHBgcGByYiByYnJgcxBhcWFwYVFBcWFxYyNzY3NjU0ByInJicmNTQ3NjcyFxYyNzYzFhcWFRQHBgcGJyIGFBYyNjQmMyIGFBYyNjQmAQQDAQEHBAQGCAkMDhJCEhkSCQUHAQEDFREPHxpTGx8PEYMhEBgMDREIDwoWERISFQoPCBENDBgQSggMDBAMDEoIDAwQDAzCCAoSEgECAQUFCQUFEAQCARISCggXICkYFQoICAoVGCkgeAMECwwZEw8IAgEBAQECCA8TGA0LBANSERgRERgRERgRERgRAAQAAAAAAS0BGgAMABAAIgAuAAATMxcVJic1IxUHIyc1FzM1IxciByMOARcHFzceAT4CLgIHBi4BPgIeAg4BOM8SCQpdFVwSEl5ewwwKAREJCywNLAkXFQ8HBA0VCAoPBwQMEBAJAQYMARkSZAQCXswVEs/Pz3EHCicRLA0sBgMIEBUWEgpLAQsPEQwDBg0PDggAAAAKAAAAAAEaARwACwAXACQALQBIAGIAdwCSAJ4ApwAANw4BLgI2NzYeAQYnLgEOAhYXFj4BJjc2FhceAQ4CJicmNhcWMjY0JiIGFAczFSMiJj0BIiY9ATQ2OwEGByMiBh0BMxUUFjcmKwEiBh0BFBYzFQYXFhczPgE9ATI2PQE0ByMVFAYrASImPQEjNSY2OwEyHgEVFyM1MzI2PQEzNTQmKwEmJzMyFh0BFAYjFRQGJyIOAR4CPgE1NCYHIiY0NjIWFAarCRQSCwIKCA0eEgYYBAoJBgEFBQYPCAMrCRQHBQQDCQ4RBgkCFAMIBQUIBZwiIgkOBwsTDiIHAxgGCRMCiwoOLg4TCwgBBwUHJggLBwsSEwICHgICEgEJBi4FBwM0IiIBAxMJBhgDByIOEwsHDq4JDgYDDBEQCRAMBAUFCAUF1QYCCREUEgYIBhkfJgMBBAkKCQMEBAwPBAUCBwUNDgsGAwYKGhYDBQgGBgilEw0KIgwIKQ0UCAsJBSo1AgJ6ChQOOwgMLAkHBQECDAgsDAg8DUo/AQICAT89BQkFBwJ2EwICNSoFCQsIFA0pCAwiCg3ZChARDAMGDwgMESYFCAYGCAUAAAAFAAAAAAEHASwAFQAZAB0AIQAlAAATFRcVByMnNTc1MxUzNTMVMzUzFTM1AzM1IxczFSMXIxUzBzMVI/QTE7wSEhMmEiYTJam8vCZwcHBwcHBwcAEsExL0ExP0EhMTExMTExP+5/QmEzgTOBMAAAAABAAAAAABGgD0AAoAEAAUABwAADcfARUPAS8BNT8BFwcfAT8BBxc1JxcVNzUHFQc1oWwMB3NzBgtrBEsKQDkRsV5ecV4mE/QdCX4JICAJfgkdExMDEQ8FdxpsGRlsGmsKMAUwAAMAAAAAARIBGgAjAC0AQgAAJSc1JzU0JyYnJiMiBh0BBwYUHwEWFxY3Nj8BBxQeAjI+AicmPgIeAR0BBxcOASYvASY0PwEVBhQeAT4BJic1FwERFlwCBAsGBQwQOQkJRAQFCwoFBF0NAQYHCggGApYBAQMEBgQSEwEFBgFEAwNSBQYKCQQDBEhPOgFcFwYFCwQCEAw9OAgXCUQEAgQEAgRdKgQJBwQEBwizAgQDAQEFBBcTqgICAgJEAggDUTUECwkDBQkKAzVJAAAAAAIAAAAAARoBGgAMABMAADcyPgE0LgEiDgEUHgE3Iyc3FzcXliQ8IyM8SDwjIzwRDSsNJE8NEyM8SDwjIzxIPCNNKw0kTw0AAAMAAAAAARYBGwAGABwALwAANzM3JwcnBzceARcWFRQHDgEHBicuAzc2Nz4BFzY3Nic0JicmJyYGBw4BFhceAXYNVQ1PJA1WFikQJh4PJhYwJxQeEAMHDyYSKyEmGRkCEQ8dJhMmDyAXISIQJmBWDU8kDY4BFBApNysnEhcECRYLIiouFS4ZDAz0CR8iJRcqEB0DAQkLGE5IEwoGAAUAAAAAAQcA/gADAAwAFQAeACcAAD8BFwc3IiY0NjIWFAYHMjY0JiIGFBYXIiY+ATIWFAYHMjY0JiIGFBZElg6WAgsRERcREQwUGxsnGxuXDBEBEBcREQsTHBwnGxs+vAy8gBEXEBAXERMcJxsbJxxdEBcRERcQExsnHBwnGwAABAAAAAABGgEbAAsAFwAjAEUAADcjFSMVMxUzNTM1IycuAQ4CFhcWPgEmJz4BHgIGBwYuATYXMzIWHQEjNTQmKwEiBh0BMxUUFjsBFSMiJjc1IiY3NTQ29BMlJRMlJVQECgkFAQQFBg8JAyYJFBILAgoIDR4RBgouDhMSCQYuBgkTAgIPDwkOAQkLARNxJhMlJRO4AwEFCAoJAwQDDQ8UBgEJERQSBQkHGR5FEw4ODgYICAYzPwECEw0JLAwIMg4TAAAAAAQAAAAAAM8BGgAIABEAKQA9AAATMhYUBiImNDY3IgYeATI2NCYXIyIGHQEGFjMVBhY7ATI2PQEyNic1NCYHNSY2OwEyFgcVIxUUBisBIiY9AZYICwsQCwsIEBYBFSAWFgcuDhMBCwkBDgkeCg0ICwETSgEJBi4GCQESAgIeAgIBBwsQCwsQCxIWHxYWHxZUEw4yCAwsCQ0NCisMCDIOE1QzBggIBjM/AQICAT8AAAAAAQAAAAABLAEHAC0AABMHFTM1MxUXMzc1MxUXMzc1MxUXMzc1MxUjNSMVIzUjFSM1IxUjNSMVFyE3NScTExMlChIKJQoSCiUKEgolOBMvEi8TOBMTAQYTEwEHE3FxZwoKZ2cKCmdnCgpnvDk5OTk5OUtLEhK8EwAABAAAAAABGgEaAAUADgAbAC0AADczLgEnFTceARcWFSM1MgcXMw4BIyIuATU0NjcXMj4BNzY1IzUiBw4CFxQeAbxJBigcASMzBgFwCS8TXAczIhksGSsgExswIAQCcQkKGisZAR4zvBsoBklcBjMjCglwgxMgKxksGSIzB8wYKxoKCXECBCAwGx8zHgACAAAAAAEHAOEAHAA3AAAlFSMiJicjDgMrATUjJzczNTMyFhcWFzM+ATMHBgcGDwEjJyYnLgEnFT4BNzY/ATMXFh8BFhcBBwYLEwc2BAwPEgoJPBMTPAkKEQgQCDYHEwsJAwMFAwRNAgQJBA8GBg8ECQQCTQQBAgUCBM6DCgkJDgoFSwoJSwUFChIJChQBAgMGBQYMCAMHAYMBBwQICwcGAwIEAgEAAAACAAAAAAEtAQcANgBQAAATMxUUBgcVHgEXBgcxJi8BNTc2PwE2NyMWFxYfARUHBgcOAQczBgcjFQcnNSM1NDY3Njc1LgE1Fz4CFx4BFxYUBw4BBwYiJy4BJyY2NzY3NkuDCQoJDQQJCAkMBgUDAgQCAVsCAQQFBgcLCAQHAV4FBAoJCksGBAoSCQqMBw4PCA4VBAICBBUOCA8HDhYEAgEBBQwEAQcGCxMHNgQLBgMFCgQCTQQBAgUDAwQCBQMETQIECQQPBgcIPBMTPAkKEQgQCDYHEwuYBAMBAwMVDwcPCA4VBAICBBUOCA8HEAsEAAACAAAAAADhAQcAHAA3AAATMxUUBgcVHgMdASMVByc1IzU0Njc2NzUuATUXFhcWHwEVBwYHDgEHMy4BJyYvATU3Nj8BNjdLgwkKCQ4KBUsJCksGBAoSCQoUAgEEBQYHCwgEBwGDAQYECAwGBQMCBAIBAQcGCxMHNgQMDxIKCTwTEzwJChEIEAg2BxMLCQQCBQMETQIECQQPBgYPBAkEAk0EAQIFAwMAAAAEAAAAAAEWARsAFQAoAC4AMQAAEx4BFxYVFAcOAQcGJy4DNzY3PgEXNjc2JzQmJyYnJgYHDgEWFx4BJzcXFQcnNxU3oRYpECYeDyYWMCcUHhADBw8mEishJhkZAhEPHSYTJg8gFyEiECYnDlRUDhI6ARkBFBApNysnEhcECRYLIiouFS4ZDAz0CR8iJRcqEB0DAQkLGE5IEwoGqwg4EDgIX04nAAIAAAAAAPABBwAFAAgAABMHFRc3NQc1F0cPD6mljwEHCOEIcBBnvl8AAAAAAgAAAAAA4gEaABUAHwAAEyMVIwcVFBYXFTM1PgE9AScjNSMVIxcOAS4BPQEzFRSDEh0JJR0SHSUJHBMmOwwiHxNwARk4CUIcKwM5OQMrHEIJODhzDAYNHBE4OBcAAAAABQAAAAABDQDvAAcADwAfACcALwAANyMnIwcjNzMXJyYnMQYPARc1MzIWFRQGBxUeARUUBiMnFTMyNjU0IwcVMzI2NTQjoBMPPg4TOBEQFwEBAQIWbikTFg4LDhIbFBkRDhAcExcPECNeKCiQWT4DBwcDPjeQEg8MEgQBARMPEheBLw4MFT40DgwaAAAIAAAAAAEaAQcABwALAA8AEwAXABsAHwAjAAATMxcVByMnNRczNSMXIxUzJyM1MwczNSMXMxUjJyMVMwczFSMm4RIS4RMT4eHOvLwTlpY4S0sTJSU5S0tLS0sBBxO8EhK8vLwTOBMSg0sTJTgTJRMAAgAAAAAA6wDrAAcACwAAPwEzFxUHIyc3FTM1QgmWCQmWCRKE4QkJlgkJjYSEAAAABQAAAAABGgEaAAcACwAPABMAFwAAEzMXFQcjJzUXMzUjFzMVIzcjFTM3MxUjHPQJCfQJE+HhEiYmcSYmJSYmARkJ9AkJ9OrhE7y8cXGWAAABAAAAAAEaAPQAEgAANycjBycjByMVMz8BFzM3HwEzNd0hEyMWEhY1PAoNFhMjGwlDg3F9XVESBzJfhFgGEgAABAAAAAABBwEaAAwAGQA8AEAAABMiDgEUHgEyPgE0LgEHIi4BPgIyHgEUDgE3LgEiDgIHMzQ+ATIeAhQGDwEOARcVMzU0Nj8BPgI0JgczFSONITghIThCOCEhOCEcMBwBGzA4LxwcLwEFDxEPCgQBFwUHBgUEAgQDDgMEARYEAwcEBgQELhUVARkhOEI4ICA4Qjgh4RwvODAcHDA4LxyeBQYGCw0HBQcDAQMFCAkEEAQJBQwJBAgECAQKCw0MXhYAAgAAAAABCgENABAAIgAANw4BFTIzMhYUBiMiJjU0NjcXDgEVMjMyFhQGIyImNTQ2NxeGIyADBRMcGhUbHS8vmSQgAwUTHBoVGx0wLhbqFjMkGCsbKiY1ThsjFjMkGCsbKiY1ThsjAAAIAAAAAAEZARoADAAZACUAMQBDAE4AUgBWAAA3NDY3Jw4BFBYXNy4BNxQWFzcuATQ2NycOARcnPgE0Jic3HgEUBjcHHgEUBgcXPgE0JgcWDwEXBycjByc3LgE+Ah4BBw4CHgEyNjQuARcjBzMXJyMHOBAPDhETExEODxAUDQwNCQoKCQ0MDZAOCgoKCg4LDQ0ODQ4QEA4NERMTSwEFBUARDmgPEUAFBAcNDw0JHgIEAQIFBgYEBQIFESYZETYQwxUmDg0RLDEsEQ0OJhQQHwwNCRgaGAkODB9NDgkYGhgJDQwfIR+GDQ4mKSYODREsMSxCCggEkQghIQiRBhAQCQEGDAEBBAUFAwUHBAInJDglJQAAAAAFAAAAAAEaAQsAFQAeACoAMwA/AAA3FAczNi4BDgIeATc1Bi4BPgIeAQcyNjQmIgYUFhcyNxcOASImJzceATcyNjQmIgYUFhczFTMVIxUjNSM1M+EBEwMgO0AuDBw5IBouGAYjMzEeeggLCxALCy4UDg0JGRsZCQ0HEi8ICwsQCws3EyUlEyUlnwQFIDkcDC5AOyADEwMYLzQnDRMrEQsPCwsPCy8ODQkLCwoNBwgvCw8LCw8LOCYTJSUTAA4AAAAAARoA9AAPABMAFwAbAB8AIwAnACsALwAzADcAOwA/AEMAACUjIgYdARQWOwEyNj0BNCYHIzUzByMVMwcjFTM3MxUjFyMVMyczFSM3IxUzJzMVIxUjFTMHMxUjNTMVIzcjFTMHMxUjAQfPCAoKCM8HCwsHz885EhISExMlExMTExODXV2DJiZeExMTE0sTExMTOBISOCYm9AsIgwgLCwiDCAuWgxMSExM4EjkSEhI4EzgSExMTEl0SEhITEwAAAAADAAAAAADiAOEACAAVAB4AADcyNjQmIgYUFjcUDgEiLgE0PgEyHgEHNCYiBhQWMjaWCAsLEAsLUxQjKCMUFCMoIxQTIS4hIS4hgwsQCwsQCxMUIxQUIygjFBQjFBchIS4hIQAAAwAAAAABFgEbAAgAHgAxAAA3MjY0JiIGHgE3HgEXFhUUBw4BBwYnLgM3Njc+ARc2NzYnNCYnJicmBgcOARYXHgGWEBYWIBYBFRsWKRAmHg8mFjAnFB4QAwcPJhIrISYZGQIRDx0mEyYPIBchIhAmcRUgFhYgFagBFBApNysnEhcECRYLIiouFS4ZDAz0CR8iJRcqEB0DAQkLGE5IEwoGAAEAAAAAAOsBCgAZAAATFQcjNTMnLgEOAhYfAQcnLgE+AhYfATXqCUIwEg0iIxkKCg1hDWIQDAwhLCwRDQEHQgkSEg0JCRkjIwxiDWERLCwhCwsRDScAAAAKAAAAAAEqASwAFQAdACEALgAyADYAOgA+AEIARwAANwcnNyMiBhQWOwEVIy4BNDY3Myc3FxMjJzU3MxcVJzM1IzczFxUHIzUzNSMVIzUXIxUzBzMVIxcjFTM3MxUjFyMVMycxMxUjiysOGjwNERENCwsUHBwUPBoOK0V4Cgp4CnhkZEZ4CgoyKGQUFDw8PDw8PDw8FDw8PBQUKioW8ysOGhEZEhQBHSgdARoOK/7/CqAKCqAKjHgKoAoUjDxGghQUFBQUyBQ8FDwUAAABAAAAAAEJAQcAHQAANyM1MxcVIzUOAR4BPgImJzceAg4DLgI+AVgyQQoTGhEaOUArBSQfBRklEgQaKzMxJRIEGvQTCkElEz88HwswQTUKEggjMDMsHQcQIzAzLAAAAAACAAAAAAEIAQcAEQAVAAATMxU3FwcXBycVIzUHJzcnNxcHMxUjvBIwCTAwCTASMAkwMAkwlktLAQc7HRAdHhAdOjodEB4dEB1bSwAABQAAAAABLQESABIAHwAsADIAOAAAEzMXFSYnNSMVMxQXIzUzNSMnNRciDgEUHgEyPgE0LgEHIi4BND4BMh4BFA4BNyc3FwcXJxcHFzcnEf4JCQrqYRROOmsK1xUkFRUkKiQVFSQVEBsQEBsgGw8PGxAaGgkTE0sSEggbGwERCWwHBVawIBoTFAnEbBUkKiQVFSQqJBWIDxsgGxAQGyAbDycbGwkSExESEwgbGwAAAAACAAAAAADyARoABgANAAA3JzcnBxUXJxcHFzc1J/JLSwxQUK5NTQxSUnlKSwtQDFBWTUwMUwtSAAEAAAAAARoAqQADAAAlITUhARn++gEGlhMAAAALAAAAAAEaARoACwAVACYAOgBEAFgAYQBzAHsAfwCGAAA3NjIWFAYiJwcjNTMVFBYyNjQmIgYVByc3FzU0NjsBFSMiBh0BNxc3MzU0IyIGBxU2Mg8BBhUUFjMyPwEVFAYiJjU0PwEHIzUGIyImNTQ/ATQiBzU+ATcyFQc1BwYVFBYyNhcyNzUGIiY0NjIXNSYnIgYUFic3MxcVByMnNxUzNSc3MxcVBzXaBA4ICQ4DAQsLBAcEAwcFjCcMEw8LLCwEBRIMOw0SBAkDBw8BCw4HBggEAQUGAwYHLAwECAYHDgsOBwMJBBEMBwYDBgQ3CQUFDAcICwQDCAwODX0SqRMTqRISqXAShBIS+gkOGA8HBko0BAcIDgcIBU4oDBMdChARBgMdEgwNIBcDAgwFCQEDEAcJCRIEBAcEAgcBAa8HCQkHEAMBCQUMAgIBFwsEAQEHAgQGEgMOBAgOCQQOAgEQGg9LExNdExNdXV0mExNeE3EAAAAGAAAAAADiARoAEAAdACcAOgBCAEYAADcXNycHNTQ2OwE1IyIGHQEnFzMWPgE0JiIHJyMVMz0BNDYyFhQGIiYHBiMiJjUmNjMyFxUmIgYUFjI3JwcVFzM3NScHMxUjPCspDRMGAx0cDBAUbwEFFQ0LFgYBEBAGCwYGCwYQBw4QEwEWEQwGBxELChEIXhMTgxMTg4OD5isqDRMeBAYSEAweFC8JARIeEQsnXBsHBwgJEQoJlgUUEBIVAxMFCxMLBVsTcBMTcBMTcAAAAAABAAAAAAEHAQQAFQAAEwcVFzcnMzIWFxYdATM1NC4CKwE3dktLDj0kJzQQHhMRJjwpIjsBBEwNSw08EBAfRwYGJzkmEzoAAAAJAAAAAAEaARoAKAAsADAANAA7AEsAUwBXAFsAADcjNTM1IyIOAh0BBhYXFhczNSMiJyYnND0BNDU2NzY7ARUjFTM3NSMnIxUzBzMVIxUzFSMXIzUzFSMnNzMXFQcjFSM1IyImPQE0NhczNSMiBh4BOwE1IyczNSP0qUtQBg0JBAELCgYGBQUDAgYCAgYCA65LVAoTgxMTExMTExMFBTgFF0JUCQkvExIICwsRCQkEBgEFICYmEzk5cZYSBQoMBrIKEAQCARMBAwUDAgoCAwUDASYTClRxExMSExODODgc6glxCRMTCwheBwtwEwYIBRMSOQAABwAAAAABGgEsAA8AHwAvAD8ARwBXAGAAADcxMhYVMRQGIzEiJjUxNDYXMTIWFTEUBiMxIiY1MTQ2NzEyFhUxFAYjMSImNTE0NjcxMhYVMRQGIzEiJjUxNDYHMzcXByMnNxcjFTMeATI2NzM1Iy4BIgYXFAYiLgE+ARafBAYGBAQFBQQEBgYEBAUFBAQGBgQEBQUEBAYGBAQFBQUTRA1UDVUODDg4BCUxJQM5OQMlMSVsGycbARwnG+EFBAQGBgQEBSUGBAQFBQQEBksGBAQFBQQEBiUFBAQGBgQEBXlFDlRUDq0TGCAgGBMYICAhFBsbJxsBHAAAAAAEAAAAAAEaARoACQATACMALAAANxUzNRc3JyMHFzcVMzUXNycjBx8BIxUzHgEyNjczNSMuASIGFxQGIi4BPgEWlhNEDVQNVQ5EE0QNVA1VDgw4OAQlMSUDOTkDJTElbBsnGwEcJxv8EhJEDVRUDQwuLkUOVFQONBMYICAYExggICEUGxsnGwEcAAAAAAQAAAAAAQcBCAAvADgAQQBKAAAlNC4BDgEWFxUUDwEnJj0BPgEuASIOARYXFRQWHwEVDgEeATI+ASYnNTc+AT0BPgEnNDYyFhQGIiYXFAYiJjQ2MhY3IiY0NjIWFAYBBxQeFwQQDgU0NAUOEAQVHBUEEA4IBzMOEAQVHRUDEA0yCAgMD7sLEAoKEAtnCxALCxALLwgLCxALC+EPFQMTHBkDFAYDGhoDBhQDGBwSEhwYAxQIDgMbGAQXHBMTHBcEGBoEDggUAxQNCAsLEAsLoQgKChALC44LEAsLEAsAAAAAAwAAAAABGgEsAA8AGAAiAAA3IxUzHgEyNjczNSMuASIGFxQGIi4BPgEWJzUzFTcXByMnN144OAQlMSUDOTkDJTElbBsnGwEcJxs4E0QNVA1VDksTGCAgGBMYICAhFBsbJxsBHF55eUUOVFQOAAAAAAMAAAAAARoBGgAJABkAIgAANxUzNRc3JyMHHwEjFTMeATI2NzM1Iy4BIgYXFAYiLgE+ARaWE0QNVA1VDgw4OAQlMSUDOTkDJTElbBsnGwEcJxv8ZmZEDVRUDW0TGCAgGBMYICAhFBsbJxsBHAAAAAAGAAAAAAEHARoAJgAqAC4AMgA2AD0AACU1JyMiBwYHBgcVFBcWFxY7ATUjIicmJyY9ATQ3Njc2OwEVIxUzNyc1MxUnMxUjFTMVIxcjFTMXByM1MxUjAQcKtwYGDQUCAQMFDQYGBQUDAgYCAQECBgIDrktUCryplhMTExMTExMJFwU4BXGfCQIGDQYGsgYGDQUCEgEDBQMCCgIDBQMBJhIJQpaWgxMTEhMTZxw4OAAAAAQAAAAAARoBGgALABQAGAAcAAATMxcVByMHJzUjJzUXMzUjFTMXFT8BMxUjFTM1Ixz0CQl/NhAvCXp64S4KKAcSEhISARkJvAk2By8JvLKpqQohKJleJRIAAAAABAAAAAABBwEaAAkADgAaAB4AABMfARUHIyc1NzMHMzUnIxcjFTMVMzUzNSM1IwczFSPJOAUSqRMTcHCpOXBLJSUTJSUTJV1dARQ4DqgTE+ES86g5SxMmJhMlgxMAAAAABwAAAAABGgEsAAgAEQAaACMAMABWAGYAADcUBiImNDYyFgcUFjI2NCYiBhcUFjI2NCYiBhcUBiImNDYyFgc2NxcOASImJzceAT8BFAYHFTMyFh0BFxUHFRQGKwEiJj0BJzU3NTQ2OwE1LgE1NDYyFgciBh0BFBY7AT4BPQE0JiOWFh8WFh8WOAsPCwsPCzgWHxYWHxY4Cw8LCw8LLg4LDQkZHBkKDQkYDRIKCS8YIBMSIRhwGCATEyAYLwkKEBgQVBAWFhBwEBYWEJYQFRUgFRUQCAsLEAsLCBAVFSAVFRAICwsQCwtFAwsNCgoKCg0JBwK3CQ8DASEXExMlExMXISEXExMlExMXIQEDDwkMEBA7Fg9xEBYBFRBxDxYAAAAABgAAAAABGgEaABEAFgAbACgALgA3AAABIgcGByMHFR8CMzc1Njc2NQczBgcnFyc2NxUvATY3Njc2NwYHBgcGBzUjNSMVNzYuAQ4BHgE2ARAvLiUkTgkDcAc4CSETF/MxFxMHagcbF0BAEBUjJDAvAx4XJBdIJRO3BgUTFw0FExcBGRcTIQk4B3ECCU4kJS4vVBgbB2oHExcxFUAYFyQXHgMvMCQjFTgTJTiQCRcNBRMXDQUABAAAAAABJQEHAB4AKAA1AD4AADc1NzMfATMXFTMXDwEjNjczNyMmJz8BMzUjLwEjFQYXFAYiJjQ2MhYVMxQOASIuATQ+ATIeAQcyNjQmIgYUFhMJXgYRbAoVCTIJRgcFMy1sBggDBlVnBxBQClURFxERFxAmEh4jHxERHyMeEkIUGxsnGxu3RgoDEAouDIQGCApxBwYDAyUDEDEFVwwQEBgQEAwSHhERHiQeEhIeQRwnGxsnHAAAAAQAAAAAARoBBwAcACYAMwA8AAA3MxcVByM2NzM3IxUmJz8BMzcjLwEjFQYHNTczFwcUBiImNDYyFhUzFA4BIi4BND4BMh4BBzI2NCYiBhQWkX8JCWwHBVYBdwgJBwZ6AXoHEFAKCQleBxARFxERFxAmEh4jHxERHyMeEkIUGxsnGxv0CrsJCAqEAQYEBgMTAxAxBQdGCgOdDBAQGBAQDBIeEREeJB4SEh5BHCcbGyccAAAAAAMAAAAAAPQA9AAEAA4AGAAANyM1MhYnFTIeARUzNC4BBxUyHgEVMzQuAV4mEBYmLk4tEzNWMxorGRMfMzgmFqwTLU4uM1YzSxMZKxofMx8AAwAAAAABGgD0AAkADgASAAA3FzM3NS8BIw8BFyc3MxcnMxcHE3wOfD4HfAc+g281dDVvMiJUpXx8Dj4DAz52bzU1IiJTAAAAAwAAAAABIAEaAAUACAASAAATBxUXNzUHNR8BMxcHJxUjNQcnIQ4OqaSOMA0vDR8THw0BGQjhB3AQZ75fCy8NH2ZmHw0AAAAABQAAAAABFwD4AAYAEAAgADIAOQAAPwE1JxUXByc3FxUHNTcnFSMXJg4BHgE2NzE2NTQnMS4BBzYXMRYXHgEVMRYOAS4BNzE2FwcjJzcXN593moZjag6fQy6GEiEYJg4RKS4QDxMIFS0NExENBggBFiMeDwYFSiMNEQwMHS9QDmcVWUKsB2oOLRUfWUAOARktLBcIExQWGxUIChgKAQINBhMLEB0IEiASERMjEQ0MHQADAAAAAAEWAQcABQAIAA8AABMHFRc3NQc1Fwc3NScVFwc0Dg6ppY9WpKSOjgEHCOEIcBBnvl91bRBuF19fAAAAAwAAAAABIAEaAAUACAASAAATBxUXNzUHNR8BIyc3FzUzFTcXIg8PqaWOPQ0vDR8THw0BGQjhB3AQZ75fji8NH2ZmHw4AAAAABAAAAAABFgEHAAkAHAAuADUAAD8BFxUHNTcnFSMHJgYHBhYXHgE2NzE2NTQnNS4BBzYXMRYXHgEVMRYOAS4BNzE2FwcjJzcXN14OqWxWjhMDGSgIBAIECSsxERAUCRYwDhQSDgcIARgkIBAGBU8lDhINDB//CHEQSBc5X0QPARoZDBgMFhkKExUXHhUBCAsZCgECDQgUCxEfCBMhExMVJRMNDB8AAAAABAAAAAABFgEHAAkAHAAuADoAAD8BFxUHNTcnFSMHJgYHBhYXHgE2NzE2NTQnNS4BBzYXMRYXHgEVMRYOAS4BNzE2FycHFwcXNxc3JzcnXg6pbFaOEwMZKAgEAgQJKzEREBQJFjAOFBIOBwgBGCQgEAYFLBYMFxcMFhcMFxcM/whxEEgXOV9EDwEaGQwYDBYZChMVFx4VAQgLGQoBAg0IFAsRHwgTIRMTFxcMGBcMFxcMFxgMAAAAAAQAAAAAARoBGgAPABgAHAAmAAAlLwEjBxUjBxUXMzc1Mzc1ByM1MxUzNTMXBzUzFRcjNS8CIzUzFwEWHAagCS8JCbwJLwlLqBJxDxZdJXEmAxwGXpIX+hwDCS8JvAkJLwmgzqg5ORYPJSVLXgYcAyYXAAAABQAAAAABGgEZABQAGAAgACMAJwAAEx8BFSMHNScjFSM1IxUzByMnNTczBzM1Ix8BFQ8BJz8BDwE/ARc3J88fBgoJHwZxJTgKLhMTnD8mJnoccjkMHHJnChMDD2EPARMfDgYJDyBLS7wSErwTSzk5HA1yHA04cocTCR0PYQ4AAAADAAAAAAEaARoACQASABYAABMfARUHIyc1NzMHFTM1JyMVIzUzFTM1+hwDCfQJCdjO4Rcig0smARcdBtgJCfQJEuHKF0tLOTkAAAAABgAAAAABGgEHAAMABwAOABUAHAAjAAA3MzUjFzMVIycjNTczFSM3FSM1IzUzBzMVByM1MyMzFSMnNTM4vLwmcHA4EwlCOPMSOUIJEglCOeE4QgkTS5YlS0tBChMJQTgTlkIJEhIJQgAGAAAAAAEaARoABgANABQAGwAjACcAADcjNTM1MxU3NSMVFzM1BxUzNTM1KwEVMxUzNSc3ByMnNTczFwcjFTNCLyUTqRMJLzgTJS/XJRMJnwmECQmECSVLS+ETJS8KJS8JE7IvJRMTJS8JHAkJXgkJHCYAAAMAAP//ASwBEAASAB8ALwAAEyIOARUUFhcHFzcWMzI+ATQuAQc0PgEyHgEUDgEiLgEXByMnNxc3Mxc3MxcVJwcjlhcnFgwLRQ1GFRoXJxYWJ1kSHiQeEhIeJB4SVSgOHA0WKA0pKA0fJSkNARAXJxYRHgxFDUYOFyctJxdUER4SEh4jHhISHoIoHA0VKCgoHxolKAAEAAAAAAEbAR8AHAApADIAOgAANw4BFxYXBhcVJwcnNy4BPgEeARUUByYnNTQuAQYXPgEeAg4CLgI2FxY3FjcnBhUUNxc2JzYmIyJsEwkLCA8CAQlHDkcXBSRBQikBCAkdLzInECkkFgMSIigkFgIREhEXEg9PChhOCwEBIRgS7hM1GBIMCQkDBkUNRRlFOhkTNyMHCAcGAhoqFApkCwMSISgkFwIRIigkWxEBAQtODhIYRk8PEhchAAAAAAIAAAAAASwBLQAPAB0AABMiDgEWFwcXNx4BPgEuASMVIi4BND4BMh4BFA4BI78fMxkJFGQOZBtDOBYUNyEXJxcXJy4mFxcmFwEsITg8FnMMchUCJkBBKLsWJy4nFhYnLicXAAACAAAAAAEaARAABgANAAATNxcVByc3Fwc3Jx8BFRMO+PgOHRQY0dEYZQEICHARcAhvCVdiX1YCEgAAAAAGAAAAAAEcARoAAwAHAAsAHQAhACkAADczFSMVMxUjFTMVIxchNzM1ND4COwEyHgIdATMHMzUjFycjFSM1IwdxS0tLS0tLq/70GCMDBQcEcAQHBQMjpnBwpg4VlhUO9BNeEhMTS16pAwcFAwMFBwSoJs/0OCUlOAAGAAAAAAEaAQcADAAQAC4ANwBVAF4AABMzFxUjNSMVMxUjJzUXMzUjFzUmJwcnNyY3JzcXNjc1MxUWFzcXBxYHFwcnBgcVJxQWMjY0JiIGFzUmJwcnNyY3JzcXNjc1MxUWFzcXBxYHFwcnBgcVJxQWMjY0JiIGHPQJEuGDjQkT4eFdBQQRChIBARIKEQUEEwUEEgkSAQESCRIEBRcICwkJCwllBQQSCREBAREJEgQFEgUEEgkRAQERCRIEBRcIDAgIDAgBBwp6OYQSCc4vJqkVAQMKEQoFBQoQCgQBFRUBBAoQCgUFChELBAEVLwYICAwICG0UAgMKEAsFBQoQCgMCFRUCAwoQCgUFCxAKAwIULwYJCQsJCQAABgAAAAABBwEaAAcAGwAjADcAPwBTAAA3JzU3MxcVBycjFSM1IxUjNSMVIzUjFTM1IxUjByc1NzMXFQcnIxUjNSMVMzUjFSM1IxUjNSMVIxc3NScjBxUXNzUzFTM1MxUzNTMVMzUzFTM1MxUvCQnOCgpBExMTEhMTE7wmEo0JCc4KCowTExO8JhITExMSjAoKzgkJCRMTExITExMSJs4KOAkJOAo5ExMTExMTJiYTgwk4Cgo4CTgTEyYmExMTExODCTgKCjgJEyUTExMTExMTEyUAAAAEAAAAAAEsASwAFwA3AEMATgAANxcVBxcHJwcjJwcnNyc1Nyc3FzczFzcXBzc1LwE3JwcvASMPAScHFw8BFR8BBxc3HwEzPwEXNy8BNjMyFhUUDgEuATYXFjMyNjQuAQ4BFvg0NB4rLAs8CywqHTQ0HSosCzwLLCsxMjIHHBErEQoZChArEh0HMjIHHRIrEAoZChErERxgCw0SGRQeGwsIGQYGCQwJDw4GBb8LPAssKh00NB4rLAs8CywrHjQ0HitsChkLECsSHQcyMgcdEisQCxkKECsSHQcyMgcdEitLBxkSDxgGDh0dLQMMEQsDBw4PAAAABAAAAAABBwD+ABkAIwA8AEYAADcyFhczMhYUBgcjDgEiJicjIiY+ATczPgEzFyIGFBYyNjQmIzcyFhczMhYUBgcjDgEiJicjIiY0NjczPgEXIgYUFjI2NCYjcQwVA2gEBgUDagMVGRUDHQQGAQQDHwMVDAEICwsPCwsITAwVAx0EBgUDHwMVGRUDaAQFBANqAxUNCAsLDwsLCHoQDAYHBQEMEBAMBQgFAQwQEwsPCwsPC5YQDAUIBQEMEBAMBgcFAQwQEwsPCwsPCwAABQAAAAABGQEaAAwAJQA9AEAAQgAANyMHFRczNzUjFSM1MxcjNTQ2NzU0NjIfARUHBiImPQEGBwYPASM3Ig4BDwEzNjc2NzYzFxQWMj8BJy4BBhUHMjAjMV5CCQnOChO7OBMTKiEPFQdFRQcVDxUKBAIBE0wUIRUBAQQFCg8XCQkBAwYCREQCBgM5AQHhCbwJCTgvqXAvITQGGAoPCEkZSQgPChQFEQcKBnoTIBMhDwsPBAEoAwMCSUgCAQQDogAAAwAAAAABGgEcACQARQBRAAA3LgU3NTcyPgI3Njc2FxYXFhceAzMXFRQOBAcnFRQeAx8BNjc+BD0BIyYnJi8BJicmBw4DBxc+AS4BIg4BFhcHM5sPHBoWEQoBCQoQEQ8HCwwSEwwLBgUIDxEQCgkJERcZHA9sCA8VGA0WDAsNGBUOCQsJChQRCQgKDg8JERMTCmgJCgQQFA8ECQoIJRgJExYZHiMSPAkCAwYFBwQFAwEGAwMFBgMCCTwSIx4ZFhMJ0TMQHRsXFQgPBwgJFBcbHRAzAQIECwUEAgIEAwsIBAFRBBITDQ0TEgQxAAADAAAAAAEbAQcAFQAZACMAADc1FzUnIwcVHwE3NTM3NQcVIzUvATMHJzUfATMVIxcHJzU3F88SCakJBl4MQgkSOQZEg0xLSzpdXB4OLi8N5QETKgoKygkgCRMJKhMOnAgY1BmtGS4THg0uDS8NAAAAAwAAAAABGwEHABcAGwAlAAA3FTc1JyMHFTEVHwE3NTM3NScVIzUvATMHJzUfASM1Myc3FxUHJ88SCakJBl4MQgkSOQZEg0xLS3teXR4NLi4N5R0TIgoKCcEJIAkTCSITLJwIGNQZrRlAEx4NLg4uDQAAAAAFAAAAAAEdAR0ADAAZACIAKwA4AAATPgEeAg4CLgI2Fx4BPgIuAg4CFjcUBiImNDYyFhcUBiImNDYyFgciJicHHgE+ATcnDgFNHUc/KAQgO0U/KAQeKRk8NiIEGzM7NiIEGjwLEAsLEAteCxALCxALQhAaCBAKJSojCRAHHAEDFAUfO0ZAJwQePEU/txAFGzI9NiEEGzI8NV8ICwsQCwsICAsLEAsLUxANCRIVARYTCA4RAAADAAAAAAEaARoACAAxAFgAADcUBiImNDYyFiciBhUUFwcjFTMVMzU3FhczFSMiBhUiBh4BOwE+ATQmIzQmIzU0LgEjBzQ2OwEyFh0BFzMyFh0BMzIWFAYrASImNDY7ATU0NjsBNzUnIyImlgUIBgYIBS8THAgVIh0SFQwOHBIQFhAWARUQqQ8WFg8WEBEfEUIQDCYTGwoJCAsTCAsLCKkICwsIEwsIHAkJJgwQ6gQFBQgGBisbFA4LFRMcIRUHASUWDxYgFgEVIBYPFkIRHxEvDBEcE0sKCwgSCxALCxALEwcLCjgJEQAABwAAAAABGgEHAAoADgASABoAHgAiACwAABMHFTM1MxU3FzUnBzMVIwcjFTMnBxUXMzc1Jwc1MxUnIxUzNyMVJwcXMzcnB4MSEoQDDxJxJiY4JiY4ExODExODgxMlJV4TFg0mDSYNFgEHEzg4LgMPOhMmJTklSxNeEhJeE3FeXjkmlkgWDiYmDhYAAAAEAAD//wEHASwALAA1AD4ARwAAJTQuAQ4CHgEXDgErASIHNT4BLgEiDgEWFxUOAR4CPgEmJz4BOwEyNjc+ASc0NjIWFAYiJhcUBiImNDYyFjciJjQ2MhYUBgEHDhgaFgkEEg0FEgslFhASFQMbJBsDFRISFgMZJBwGEhIFEgslEh0GERjOEBgQEBgQOBAYEBAYEGcMEBAXERHFDRcMAhAZGhMECgsPWwMdJBgYJB0DcgQcJBkCFiQeBQoLFRECG0kMEBAXERHCDBAQFxERbhEXEBAXEQAAAAACAAAAAAEaARoALABXAAA3FjI2PwE+AT8BPgIuAS8BLgEvAS4CDgEPAQ4BDwEOAh4BHwEWFxYfARYXFjI2PwE+AT8BPgIuAS8BLgEvAS4CDgEPAQ4BDwEOARQWHwEeAR8BFmUFDQoCCAQOChoFBgMCBgcZCg8DCQIJCQkGAggDDwkaBQYDAgYGGgwJBAMIAngECggBBQEHBQ4FBQEDBQMPBAcBBQIGCAYFAgQCBgUOBQUFBQ4FBwEFAWEDBwYaCg4ECAIGCQkJAgkDDgoaBgYCAwcEGgoOAwkBBwkJCQIIBAsGBxoGTwMFBQ4FBwEFAQcHBwUBBQEHBQ4FBQEDBQMOBQcBBQEICggBBQEHBQ4FAAQAAAAAARoBGgAsAEAAawB/AAA3FjI2PwE+AT8BPgIuAS8BLgEvAS4CDgEPAQ4BDwEOAh4BHwEWFxYfARY/ARceAR8BBw4BDwEnLgEvATc+ARcWMjY/AT4BPwE+Ai4BLwEuAS8BLgIOAQ8BDgEPAQ4BFBYfAR4BHwEWLwE3PgE/ARceAR8BBw4BDwEnLgFlBQ0KAggEDgoaBQYDAgYHGQoPAwkCCQkJBgIIAw8JGgUGAwIGBhoMCQQDCAIHCggFFQ4aGg4VBQkJBBUOGhoOFHYECggBBQEHBQ4FBQEDBQMPBAcBBQIGCAYFAgQCBgUOBQUFBQ4FBwEFAQ0DAwkNAwEBAw0JAwMJDQMBAQMNYQMHBhoKDgQIAgYJCQkCCQMOChoGBgIDBwQaCg4DCQEHCQkJAggECwYHGgaHGhoOFQQKCQQVDhoaDhUFCQkFFMgDBQUOBQcBBQEHBwcFAQUBBwUOBQUBAwUDDgUGAgUBCAoIAQUBBwUOBTIBAQMNCQMDCQ0DAQEDDQkDAwkNAAMAAAAAARoBGgAHAAsADwAAASMHFRczNzUHIzUzFyM1MwEHzxISzxKDXl5xXl4BGRLPEhLPz8/PzwAAAAMAAAAAARoBGgAHAAsADwAAASMHFRczNzUHIzUzNSM1MwEHzxISzxISz8/PzwEZEs8SEs/PXhNeAAAAAAMAAAAAARoBEgBNAJwApgAANyYjLgEjFQ4BBxUWFxYXMjEGBwYHBh0BFBYyNzMGByMOARUGFjsBFj4CJyYvAS4BNj8BMzIXFhcWNjc2NTQnJicmBwYHBgcmJzU0JicXFgcGBwYrATQ2OwE1JjY3JwYHIyIHBiY+ATsBMjY/AQYmJz4BNzMyFxYXFh8BMzUmNjc+ATc2Fx4BFxUUDgEmJyYHDgEHBhYfAR4BByYvASIGFBY+ATQmI2gBAQIPChYeBAURCAoBEAoIBAMLDwcnBQIGERcBBAR9EBwWCQEBDQIHBQMDAgMDAwYHChIFAg0MERgaEg0KBQUHDwxkAgIDDggJbgoIGAESDgwIAzwDAgUFBAoHEwQFAQYPHAoEIRUCCAcKEAgGAQMBAgEEEw4TEA0RAgUHCAQKCwcJAgMHCAIKAQYBB4MEBgYHBgYE+gEJDBkJIxcICgYEAgIHBggGBwYHCgMJCgIbEgQFAQsXHRAWEQMICwkCAQEEAgEJCQYHERYSCw0FAw4LDgcHAwsQAbkPCQ4IAwcLCg0UAREDAgECAwsIBQMYAgkKFRwBAwUVCwoBAQcXBgwTAgQJCBsMAgcFAgICBgMCCgcLFwgDDB4NDQxwBQgGAQUIBQAABQAAAAABGgEaAAkADQAPABEAGwAANycHIxcHNxcnNwczNw8CNyMHMzcXMwcXJwc3tB4eZVIfUFAfUu1SGBgQGKpSUiwODiwkDiQkDrdiYkBkPj5kQAlPTzRQhBEtLRwtHBwtAAEAAAAAARoBGgAJAAA3JwcjFwc3Fyc3tB4eZVIfUFAfUrdiYkBkPj5kQAAABAAAAAABGgEaAAkADwAQABIAAD8BFzMHFycHNycfASc3Iyc1FyN4Hh5lUh9QUB9SgyQOJCwOalK3YmJAZD4+ZEBHHC0cLTNPAAAAAAMAAAAAARYBGwADABkALAAANzMVIzceARcWFRQHDgEHBicuAzc2Nz4BFzY3Nic0JicmJyYGBw4BFhceAXFLSzAWKRAmHg8mFjAnFB4QAwcPJhIrISYZGQIRDx0mEyYPIBchIhAmvEuoARQQKTcrJxIXBAkWCyIqLhUuGQwM9AkfIiUXKhAdAwEJCxhOSBMKBgAAAAAFAAAAAAEaAPQACQATABwAJQAuAAA3MzUjBxUXMzUjNyMVMxUjFTM3NQcyNjQmIgYUFjcUBiImNDYyFhcyNjQmIgYeASYSHAkJHBLqHBMTHAm7CAsLEAsLUwsQCwsQCyUICwsQCwEK4RMKqAoTqROWEwqoZwsQCwsQCxMICwsQCwsbCxALCxALAAAAAAIAAAAAARoBBwAJABMAABMHFRczNSM1MzUXNzUnIxUzFSMVHAkJLyUlxQkJLyYmAQcKzgkSvBPhCc4KE7wSAAACAAAAAAEaAPQABwAfAAA/ATMXFQcjJzcjFSM3JwcVFzcnMzUzJzcXFQcnNyMVMxMJ9AkJ9An0cUwnDTg4DShNSScNNzcNJ0lx6goKqAoKn0EnDTcONw0oEigNNw43DSdBAAAABAAAAAABFAEaACAAJAAoACwAADczNzUnIwcjNTc1JyMHFRczNxUXMxUXMzc1JyMHIzUzFTcXBycfAQcvAjcX1Q0yGQ0iXiMmDUslDhUJWBgOMhkNI15POAwlDCUMJQyQGD0ZdjINGSIYIg4lSw0mFm0JChkyDhkjSwkqCyYMOAwmDHgZPRgAAAcAAAAAARoBGgAZADUAPgBHAFAAWQBiAAATIg4CHQEeAT4BHgIOARYXMzI+ATQuASMHIy4BNSY3NjQmIgcGJyImPQE0PgEyHgEUDgEjNxQGIiY0NjIWFxQGIiY+ATIWJzI2LgEiBhQWNxQGIiY+ATIWFxQGIiY0NjIWlhowJRQBExoUHBQBFAMODwsjPSMjPSMBCgQFAggPHywQBwoCBB8zPTQeHjQeEgsQCwsQCzgLEAsBChALgwgLAQoQCwuLCxALAQoQCxMLEAsLEAsBGRQlMBoIDg0EEwEUGxUcFQEkPEc8JPUBBAQMCBArIBAIAgQDBx8zHx8zPTQevAgLCxALC4sICwsPCwtWCxALCxALEwgLCxALC0AICwsQCwsAAAQAAAAAARoA9AADAAcADwATAAA3MxUjFyMVMyc3MxcVByMnNxUzNUuWlpaWls4T4RIS4RMT4bwTJhJwExOWExOWlpYABgAAAAABGgEHAAwAFQAZAB4AIgAmAAA/ATMXFQcjNTM1IxUjFzUnIwcVFzM3JxUjNTcnNTMVJzMVIwcjFTODE3ESEktLcRMmE3ATE3ATE3CLCEtLS0smS0v0ExNeExNeODkTExNeEhJeXl4TCAsTOBNdEwAHAAAAAAEaAQcADAARABoAHgAiACYAKgAAASMHFTM1MxUjFTM3NQczFSMnByMHFRczNzUnFSM1MwczFSMVMxUjNzMVIwEHcRMTcUtLEnBLRAcmXRMTcBMTcHBeS0tLS3FLSwEHEzg4XhMTXjgTBwcTXhISXhNxXhMSExOWEwAAAAIAAAAAAO8BGgALABIAABM3MxcHMxcHJzcjJxcHNyM3IweLET4PKSEOhh4oFxFHNoVFPj5AAQ8KHUAgiRZIGwljiV6EAAAAAAQAAAAAARoBBwALAA8AEwAXAAAlJyMPARUfATM/ATUHJzUXNyc3HwEHNTcBD14RgwoKXhGDCqBUVAlXfVcHenrYL0IRVBEvQhFUkSpGJhAnPyxXPUk5AAADAAAAAAEHARoACQAMABMAACUvASMHFRczNzUHIzUHNTMVFzMVAQQ+BpEJCc4KEziEcQlC2T4CCfQJCbYEOeHhQgmWAAIAAAAAARsA4gAXACEAADciBgcjLgEOARQeATY3Mx4CPgIuAgciJjQ2MhYUBiPYGSUDOgQXHRISHRcEOgIVHyIcDwISHREUGxsnGxsT4SAYDRADFR0VBBAOERsOBBMeIxwRcBsnGxsnHAAAAAUAAAAAARoA6wASACUAPwBKAGUAADcWPgE3Nic2Jy4BIyIHNSMVMzU3Nhc2FxYVFgcOAScGJjc1Jjc2Jw4BDwEVNzY3MhYVBw4BFBYzMj8BFTM1NiYXFAYjIiY0NzY/ARcWNxY/ATUHBiImNDYXMh8BNScmIgYHBhQXFocKFBIGDQEBDAYQCRAMExMQBQYLBgcBCQMJBgsPAQEIBFAJEQcCCAsPBwkXDhUTDgsJBhEBEwEPCwYJBAgKE5wICg4MAwkJFxASDQoICAMKFhMHDw4GXwYBCAgRFhQPBwcLNI8GTAMBAQkKDQ8NBAYBARELCwwKBBYBBQUBFwcKAQwIBAESGhIGBQk/EBc5DREIDAQFAQMvBAEBCAEWBgcUHBYBBQUWAQUIBxEqEAcAAAgAAAAAARoBBwADAAcACwAPABMAFwAbAB8AACUjNTMHIxUzJyMVMxcjFTMnIxUzNyMVMycVIzUXIxUzARldXRImJkupqSXOzl5wcJZdXYODcF1d4RNLExMTXhJLExMTqTk5ExMAAAAABAAAAAABBwEaAAsADwATABcAADcnIw8BFR8BMz8BNQcnNRcnNxcHFwc1N/1dE14JCV4TXQp6VVVQWVlZXlRU4Tg4EHEQODgQcaMyYS5BNTUxQzJlLgAAAAUAAAAAARwBGgAIAAwAEAAdACkAABMzFRYXNSMVNxcnBzMnPwEXNz4BHgIOAi4CNhceAT4CJicmDgEWS5YKCbwTKBVLlnYgCysqDyMgFAIQHiIfFAIPGQoZFw4CDAoQJhYIAQdLAQRinyEqJYMTOBNLeAoCDx4jIBMCEB0iIFQHAgsVGhYHCwggJgAAAgAAAAABBwEHAEYAjQAANzUjIg4BBzEGBzEGFxUUBzEGBwYrARUzMhcVFhcVFhcxFh0BBhcVFhcxHgIXMzUjIi4CPQE0JicmJzY3PgE9ATQ2NzYzFxUzMj4BNzE2NzE2JzU0NzE2NzY7ATUjIic1Jic1JicxJj0BNic1JicxLgIHIxUzMh4CHQEUFhcWFwYHDgEdARQHDgEjcQIJEQwDAwEBAQIECgUGAQEGBQUDBAICAQEBAwMNEAkCAgYKBwQCAgUJCQUCAgkHBQZNAQkQDQMDAQEBAgQKBQYCAgYFBQMEAgIBAQEDAwwRCQEBBgoHBAICBQkJBQICCAMKBvQTBw0ICAgICBAGBQoFAhICAQIDAQMFBQYQCAgBBwgIDQYBEwQICgYZBgwFCwcHCwUMBhkJDQQCvBIGDQgHCQgIEAYFCgUCEgIBAgMBAwUFBhAICAEHCAgNBwESBAgKBhkGDAULBwcLBQwGGQwIBAQAAAACAAAAAAEaARoAGwAfAAATFTMVIxUzFSMVIzUjFSM1IzUzNSM1MzUzFTM1BxUzNc5LS0tLEksTS0tLSxNLS0sBGUsSSxNLS0tLE0sSS0tLXUtLAAAIAAAAAAEaARwADgAZAB0AKQA1AEIATwBTAAATFhcWFA4BIyImNTQ2NzYXNjc0LgEOARQeATcHFzcXMxUzFSMVIzUjNTMnFwcXBycHJzcnNxc3LgEiDgEeAz4CBwYHBicuAT4CFhcWNyMVMzYKBAIGDAgKDwgHCgQGAQUGBgQFBkxkDWNTEi8vEi8vbA0hIQ0hIQ0hIQ0hOgMMEA0FAQcLDQwHAREBBAYFAgIBBQYFAQWNS0sBFwQJBQwLCA8LBw0DBCUDBwMGAgMFBwUCImQMY4cvEi8vEiUNISENISENISENIXAHCQkNDQoGAQcKDQgEAQMFAQUGBQECAgU0EwAAAwAAAAABGQDhABsAIgApAAA3IzU0JisBFRQWOwEVIzUzMjY9ASMiBgcVIzUzFyc3FxUHJyMnNycHFRfOEgYEEwUECjkKBAUSBAUBEnA3HA4iIQ6nHBsOISK8CQQFZwQFExMFBGcFBAklTBwNIg4hDhsbDSEOIgAAAgAAAAABGgEbAB8AQwAANyIuATc2NyY0NzY3PgEfAQcXNxcWFAYHBgcOAScGBwY3IgcGBw4BHwEHBgcGHgIyNzY/ARcWNjc2Nz4BNTQnByc3JjUOEwIII0AFBgoVESkSDDYXOAUGDAsGCBAlEkQgCYkSEAYFDgcIAwREIwMBBwYIAx5JBQUPIA4GBQkJATEwMAYTExkKJj4OHg4YDQsECAU4FzYMDyAeCwYFCwQHRR4I9QsDBQ4mEgYEQiUFCwcCAxtLBAIHAwkDBQkXDQYGMDAxAQACAAAAAAD0ARoABwAbAAATBxUXMzc1Jwc1MxUjNTM1IzUzNSM1MzUjNTM1SxMTlhMTlpaWJiZLSyYmSwEZEuETE+ESJRPhEhMmEiYTJRMAAAgAAAAAARoBGgAJAA0AEQAVABkAHQAhACUAABMHFTM1MxUzNScDNTMVNyMVMzczFSM3IxUzNzMVIzM1IxUnMxUjLwkSzxIJ6hImExMTEhI4ExMTEhJdEiYTEwEZCdjPz9gJ/voTExMTExMTExMTExMTEwAABwAAAAABGgEHAAcACwAfACkANgBAAFIAABMHFRczNzUnBzUzFSczNTQjIgYHFTYyFQcGFRQWMzI/ARUUBiImNTQ/ARcjFSM1Mxc2MhYUBiInFRQWMjY0JiIGFzI3NQYiJjQ2Mhc1JgcmBhQWJhMT4RIS4eGjDRIECQMHDwwOBwYIBAEFBgMGBysBCwsBBA4ICQ4EBAcEAwcFRQkFBQsHBwwEBAgLDg0BBxOpExOpE7ypqTogFwMCDAUJAQMQBwkJEgQEBwQCBwEBFAZKHwkOGA8cBQQHCA4HCCEDDgQIDgkEDgMBARAaDwAAAAAGAAAAAAEaAQcABwALABMAGAAgACUAABMHFRczNzUnBzMVIwc3MxcVByMnNyMVMzUzNzMXFQcjJzcjFTM1JhMT4RIS4eHhExM4ExM4EyUSOF4SORISORIlEzkBBxM4ExM4ExM4SxISORISOTk5EhI5EhI5OTkAAAAGAAAAAAEaAOEACQATAB8AIwAnACsAADczNSMHFRczNSM3IxUzFSMVMzc1BxcVDwEjLwE1PwEzBxc1JzcXNycHNzUHJiUvCQkvJeovJiYvCTwEBlQJLgUGVAlQHBwLGz8bG0JCzhMJlgoTlhODEwqWJwgvCSUcCC8IJlcRGREPEBwQVx0aHQAAAwAAAAABKwEIABEAIwAnAAA3Jz4BHgEXNxcHIyc3Fy4CBh8BBi4CJwcnNzMXByceAyc3FwdnDxo9NiABFw4nDycPFwEaLDFADxo6Mh4BFw8nDigPFgIYJy6SDd8N5w0RAxwzHxYOJygOFxgqGAGzDQ4BHTEdFw4nKA4WFycXA74N0A4AAgAAAAABKwENABEAIwAANwcnNzMXByceAjY3Fw4BLgE3JwcXMzcnBy4CBgcXPgEeASYXDycOKA8WAyk9OQ8PE0VJMM0XDycPJw4XAS5IRRQPEDo8J5EXDicoDhYfLw0aHAshHhE6LxcOKCcOFiU6ExsgCxsYEDAACwAAAAABBwEHAAcACwAPABMAFwAbAB8AIwAnACsALwAAEyMHFRczNzUHMxUjFyM1Mx0BIzUnMxUjFTMVIxU1MxUzNTMVMyM1MzUjNTMnNTMV/eEJCeEK4c7Ogzg4OEs4ODg4OBM4Szg4ODg4OAEHCs4JCc4JEzglOCUlOCUTJTkmJiYmJhMlEyUlAAADAAAAAAEnAQcAEQAjADAAABMjDwEVFzM3FjI+AT8BNCYnNQcmIyIGFBYzMhcVBwYPASc3MxceARUGFQ4DJz8B+GIGfWENKhIqJRcCARQREw4OBAUFBA8NSQMCJVRzVBMJCgECERseDkUDAQcDfQ1iKgoUIhUKFSUMKiEFBQgGBihKAQMmVHQ5ChcNBQUPGQ8CBkUHAAAAAAUAAAAAARoBGgAIABUAHgArADgAADcyNjQmIgYUFjcUDgEiLgE0PgEyHgEHMjY0JiIGFBY3FA4BIi4BND4BMh4BBzI+ATQuASIOARQeAZYICwsQCwtTFCMoIxQUIygjFEsXISEuISGaIzxIPCMjPEg8I4MfMx8fMz4zHh4zgwsQCwsQCxMUIxQUIygjFBQjTCEuISEuITgkPCMjPEg8IyM8lB4zPjMfHzM+Mx4AAAAABAAAAAABGgEaAAYACgAOABIAAD8BJwcnBxc3IzczBzMVIxcjFTNDaw1kHA4i5JkrbqioqKioqK5dDlYiDCofJksmJSYAAAAABQAAAAABBgEaABMAFwAbACAAKgAAEx8BDwEvAQcvAQcvAT8BJz8BJzcHFzcnNxc3JzcXNycPARcjJxUjNQcjN9MLJwQ+CwNDCgMwCw4FLwMEQwMFZwYqBwoVOBQKIyshLgU5FiMTIxUgARkEXQsaBAgcBAcUBR8LFAgKHQgLYhAREBcuGC0YTRNNE3NbOEthTkkAAAQAAAAAARIBIwAXAEcAUQBuAAAlJyYiDwEOAR0BFBYfARYyPwE+AT0BNCYHFRQPAQY9AQYnIjU3NDczFjc2NCImNTQ3NTQ/ATIdATYXMg8BFAcxJgYVFBYzMhQ3FCMHIzU0PwExNwcOAR0BFBcjIi8BLgE9ATQ2PwE2Mh8BFhcuAQcBAFkIEghZCAkJCFkIEghZCAkJTQEFAQUFAQIBAQUEBw0GCgEFAQQEAgECAQUKBAQMJAEWAQEWEFQJCQgFBwdZBggIBlkHDwZZCwICCQbpNQUFNQUQCWoJEAU1BQU1BRAJagkQnwgBAQMBAggDAgEHAQEBAgMNBAcNCAgBAQMBCAIBAgYBAQEFBwICGgQBDgYBAQ18NAUMCWcLAwM1BA4HagcOBDUDAzUHDQQCAwAHAAAAAAEsARoAAwAgACQAKAAwADQAOAAANxcjJwciDgIUHgIyNxcGIwYiLgI0PgIyFhcHLgEXMxUjFTMVIzchBxUXITc1ByE1ITUhNSHMJg4lUwgMCgUFCQwSCQIEBQcQEAwHBwwSEgoCAgQJJRMTExON/uYJCQEaCRP++gEG/voBBqleXgsFCQ8QDQkFAwkCAgYMERQRDAcCAgkCAggTEhO7CfQJCfTqqBMmAAAAAA///wAAAPIBLQAEARcBGgEtATUBOwFKAVABUgFXAV4BYwFkAW4BdAAAEyIrATcXNjUHNj0BIy4BJy4BBz4BJw4BBwYHBjM3MAcjDgEHFDYxByYHBgczBgcxBhUHBhUUFwcXIx4DFyYnFBYXBxYfASYXFh8BNwYXMx4BMwcWFzMWFycXHgIXIyYnLgI3Jjc0JzU2NzUxFj8BNjczNjc2NzE2NxU2NzY/AQYzNwc2FzEyMwcGMRY3MTYXJxcWFzI3MTYXFRYXMicxHgEXJjEVFiMWFzUmJxQjMSYGFxY3MTQxFxYfASInMSYVHgEVMSIVFBY3MwcGFycUFTEWBzY0BxYHMQYVJwYWBzY1MTQ3Ig8BDgEnNCcmJyY3Njc2Nz4CFhcuAQ4BFzcyNRQeATcVNj8BBwY2PwE2NTEmPwEHMDkBFBYXFjcGLgEnMhcxFhcmJxYXNyIjMhYjMCcXNCIHFxQHBgc0JjY3FAcxBhQ/ATYHLgE3FjcnDwIXFhcnFh8BJyYnNwcGBzYnFTAzMTIUDwE1NgcUBzU0N4UEAwIOSAMCAgEBGxANIwkBBgEHCAMGBgEBBgMFBQgFBAIIDw0FAwIEBQECBAEDAQIEBQUEBAIFAwICAwEEAwIGAwIBCAUBCAMDBQIBAwYDBgUNDgUEFAccMhwCAQEBBwcCAwMDAQIBBQQHBwIHDAcNCAEBDwcFBAQFBQIFBQYGAQsKCgICBAUBCAEFDxoFAwEBBAIGBgMCAQIBAQIBAQEBAQIBAwECAQECAwEDAQIBAgEFBAMEAQMBAQEFBxAmFAISBgkDAgIDBQQSFhIFCRoYDgEBARUfDgUDCQEDBQ4DAQECBFQGAwsSCRsYBgEFCAQEBgkLAwEBBgICBDYCAQIDAgQEAQQCAgQBAxkFBgQHBRoBJwEDBAMFAgIBAQMBjAECBgfgAgEBBAIGAgMBKwGQCAYFCBAKEyYHBgIEAQEBAQICBAIBAQIBAwYBAgMBDwwJBQcJBAwRCA0FBwcJBAEFCQEEAgkFAgMCAQIGAwgEAgUJAwcEAQIDAgQFBgUCAgECCC1AIQYMDwICFg4BAgUFBwQEBgQHBgIDBgcDBgMBAgQBAQEBAQIBAgMEAwUBAQIBAwQFCB4RBAQFCwoBFAkCAQMFAgEBBAIGBQIDAQQGAQMFAwEECQcIAwQFBgYJAwcKCAMEBwUEAgEBAgUHDQUHAQIOCw8XAQYLAwcMAQoHCAQLGQ4BAhEbCwcBAQIIAgMBDQMCAgIDAykBBAIEAQQGEAoFCgEDCAoFuwEBegYEAwELBwYBAQQFAgIEAQIBBBMBAgEBAZkBnwQEBgMXBAIFAgYDGAIPDQ5XAQEDAwEDFQQEAgQEAAAFAAAAAAESAS0AWgCxAM8BGQE+AAA3HgEfARYfAR4BFA4BDwEOAgcOASMiJicmLwIiDwEiDwEOASImJyYvAS4CNDY1JzQ2NzY/Ayc0PgI3PgE1JzQ1ND4CMzIeAh0BFhcWHwEeAhUUJzIWHwEVDwEGDwEGFBcWHwEeATsBMj8DNC8CLgEvAT0BND4BMzIWFAYUFzMyNjUnLgIjIgYHFycmByMiPQEuAiIOARUHFB8BFjI2NSMiLwEmNgcyPgMmLwIuAgYPAQ4CFRcUBhQWHwIWFzcyNzY3Njc1PwE0PgE3NTQ/ATY/AS8BJi8BJjUnJi8CJiIPAQYiJi8BJiIdAQcGBxcUFwcOAR0CMh8BFh8BFh8BFAYHHgMXMj4BNzY/AjY9AS8CJiMiDwEGIiYvAQcGBwYVBwYPAhQW+QQFAQIBAwMCAwMGBAcGCQoGBAcECAsEAgEEHQcGDQEBBAMICwoFCQkZAwUDAwEHBwMCBQcBAQcKDAYICQEFCxINDhIJAwEDAwQOBwwIfgIDAQEBBAECBgICAwEEAQYGAQYFDgsBAQIFAwcDAQIDAgUEAgECAwMBAQMGBAgGAQEFAgICAgECBAYDAwECAQECAgEBAQIBBB0EBgYDAQICDQoCBAUGAwoDCAUBAgUEEAgDBUMEBQkJBAQCBQMGAwECAQIDBQICAgcBAQIDAwMCBQUUBQkHAwUDAggDAQEBBQYEAwMHBAQGBAECBQMCCAgKQAMHCAMICgoDAQUDBQMGAwIKAwUFAQQCAgECAgEDAQEJWwIHBQYEBQQCBgcFBAEEAwcKBAIDBggCAQEBAQICBQIEAgMEAgQBAwYICAUNBwcCAQIECQIHChQTEggKGA4LBgYMEg4HDBMXDA0KCQQGEgkUFg0KjwIBBAQCBQEBBQIDAQIEBgMFAwgIBAIBAgEBBAEBAgcCAwIHBQQCAQMDBwQIBAcICQEBAQEGAwYFAwQDBQQDBQECAQEFBAbkAgMGBwUCEhAEBgQBAgoDAwQEDAQHBwMBAwEBAw4BAgQCAwEIHwQGBQIBAQIDAQECFwYEAgoCAgQHBwcFAwMNAgUEBgMCBw0HCAQCAgcIEwkKBAIEAwQIAwQGBAUBBAYEAhUCBQQJBQUCAgICCAUPBAEGAQMCCgMCAgUFEQgIBQUHCgAAAAAEAAAAAAErARoABwALAA8AFQAAEx8BDwEvATcHFzcnFwcXNy8BBxcHFy/0CCIL9AgiDuEg4U0DXgI9RQ0yPQkBGQMJ8gkDCvHoA98CnRICEy83DycnDwAABAAAAAABBwEaAAcADAAQABQAABMjBxUXMzc1BxUjNTMXIzUzNSM1M/3hCQnhCoRdXXFeXl5eARkJ9AkJ9HFnz89eE14AAAAABv//AAABHAEaAAgAEQAeACcANABEAAA3FAYiJjQ2MhYHFAYiJjQ2MhYXLgEnBiceARcWMyY1NxQGIiY0NjIWFzY3NiYnBgcWBwYHFiciMT4BFwYPAQ4BByYnJiP2FyEXFyEXphghFxchGDIWIgoREg0xIA4OC2EXIRgYIRcQEwYGCg8GEBEIAwkO0gESRCYJAgEYKQ4ICgYG8xEWFiEWFmURFhYhFhZ0BBoTCAQeKAcCDhIBEBYWIRYWAhcdGTIWEQkfIhAOC3wgIwMKDQgBFRMFAgEAAAAABAAAAAABGgEaAAcACwASABYAABM3MxcVByMnNxUzNQ8BFwcXNzUVMxUjExPhEhLhExPhrw01NQ0+S0sBBxIS4RMT4eHhOQ01NQ09CjMTAAAEAAAAAAEaAOEABwAKABIAGAAANwczNzMXMycHNxc3IwczNzMXMyc3NjcfAT8sGQkrChksGw8OhR49Hg4/Dh1kFgIBAhepcRwccUIoKHqpKytCQwYFC0MAAwAAAAABBwD0AAMABwALAAAlIzUzFSM1MwczNSMBB+Hh4eHh4eHOJnEmcSYAAAAAAQAAAAABGgEHABsAADciLgE/ASMGLgI3Njc+ATczHgEdARQGKwEHBmYIDgUEEjQHDAcBAyMIAw0IpwsPDwsZbggjCxEJKQEGCw4GShcHCQEBDwtCCg9nBwAAAAACAAAAAAEaAQcAGwA2AAA3Ii4BPwEjBi4CNzY3PgE3Mx4BHQEUBisBBwYnIgcGBwYWNzMXFQcGHgEyPwIzMjY9ATQmI2YIDgUEEjQHDAcBAyMIAw0IpwsPDwsZbggYBQILIAIEBT4JFAEBBAUCcgkZAwUFAyMLEQkpAQYLDgZKFwcJAQEPC0IKD2cH0QUfQwQHAQwJLgIFAwJoAwQDQgMFAAAAAAEAAAAAARoBBwAbAAATHgIPATM2HgIHBgcOASsBLgE9ATQ2OwE3NsYIDgUEEjQHDAcBAyMIAw0IpwsPDwsabQgBBwEKEQkpAQcLDQZKFwcKAQ8LQgoPZwYAAAAAAgAAAAABGgEHABsANgAAEx4CDwEzNh4CBwYHDgErAS4BPQE0NjsBNzYXMjc2NzYmByMnNTc2LgEiDwIjIgYXFQYWM8YIDgUEEjQHDAcBAyMIAw0IpwsPDwsabQgYBQILIQEEBT0KFAEBBAUCcgkZAwUBAQUDAQcBChEJKQEHCw0GShcHCgEPC0IKD2cG0AUfQwQHAQwJLgIFAwJoAwQDQgMFAAAGAAAAAAEZARoAIAAvAEEATQBSAGgAACUnByc3JyYiDgIUFwYHBhYXHgEzMjc2NzY3FjI+AjQHBisBIi4CNzY3HgEXBjcWBiInLgE3PgI7AQcVFzM3BzMXNyc3LwEPAhcnFxUjJxc3FxYUBw4BJyYvATcXHgE+AjQmJwEVDycXJwMNGxoUCwU6OQYBCAQJBQkHFSQiGg0cGhQL4gECAgICAwIBKkYDBgRJqQEgLA8MBgYEDxQKBSIjDSLKHA4MDAEENgsPAiMKKxQcig06CAgGDwgFAzsNOgIFBQIBAQHrAycXKA8ECxQbHQ06OwgVBwQFBxMlIRsGCxUaHLcBAQQGAixGBAcDS4UXHw8MIA8KEAgjDSMiJw4NDR8IJAIPDDZAHRUsfQ08CBYIBgMDAgQ8DTwCAgIDAwQDAQAABgAAAAAA9AEaABMAFwAbAB8AIwAnAAA3MxUjFQcjJzUjNTM1NDY7ATIWFSsBFTMHMzUjFyMVMzczFSM3MxUjvDgTE4MTEjgLCDgICxM4OF6DgyYTExITEyYTE/QTqRISqRMTBwsLBxO8qRODg4ODgwAAAAABAAAAAAEHAM8ABQAAPwEzFwcjJgfSCGoQxAoKZgAAAAEAAAAAAM8BBwAFAAATFxUHJzXECgpmAQcI0ghqEAAAAQAAAAAAzwEHAAUAADcnNTcXFWgKCmYmB9IIahAAAAABAAAAAAEHAM8ABQAAJQcjJzczAQcI0gdpEGgKCmYAAAEAAAAAARoA/wA+AAAlDgEHFxQGBw4DIiYnFjY3IiYnJicXFjcuAScmNTEWMyYnJicmNzY3FhcWFxYXJzU0NzY3NjIWFzY3Bgc2ARkFDggBBwcJHSQrLSoSFSoQDBcHBQMFCgkJEAYMDA0LBwMCAwQBBAoNGR8QEAEECBUKFhQIEhAGEhDlCA4GBxAfDxUiGAwMDAILDgwKBwgBAQMCCQgOFAYHDAYGDg0HBgwKFQgEAQYGDAkVCAQJCAQJEwoBAAQAAAAAAQcBGgAeACIAJgAqAAA3IyczNzUnIwcVFzMHIwcVFzM3NScjNxcjBxUXMzc1JzUzFQcVIzUXIzUz/SA/FAoKSwkJFD4hCQk4CgoBOjkBCQk4CpY4XiXOJiZeXglLCQlLCV4KOAkJOApWVgo4CQk4ejk5gyUlJSUAAAAABAAAAAABBwEaAB4AIgAmACoAABMjBxUXMwcnMzc1JyMHFRczFyMHFRczNzUnIzczNzUHNTMVFxUjNTcjNTP9OAkJATk6AQoKOAkJIT4UCQlLCgoUPyAK4SVeOIMmJgEZCTgKVlYKOAkJOApdCksJCUsKXQo4LyYmgzg4gyYAAAAFAAAAAAEHARoAIwAnACsALwAzAAA3Iyc1JyM1Mzc1JyMHFRczFSMHFQcjBxUXMzc1NzMXFRczNzUnMxUjBzMVIwcjNTMXIzUz/SEgChwJCgolCQkJHAkgIgkJJgkgQyAKJQqEExMSODg5EhK8ExNLIEcKJQkmCQkmCSUKRyAJJgkJIiAgIgkJJsUTSzhLEhISAAAAAwAAAAABBwEaAAkAEwAtAAA3NQcnNzMXBycVBxUnBxczNycHNTcXBxcHIzUzJyMHMxUjJzcnNzMVIxczNyM1jRMNIg4iDRMSEw0iDiINE2IGRUUGTjg4ODo5TwVFRQVPOTg4OjiySxMOISINE0s4SxMNIiINE0tnEzc5ExMtLRMTNzkTEy0tEwAAAAAMAAAAAAEaARoACQATABsAHwAnACsAMwA3AD8AQwBHAEsAABMXBycVIzUHJzcXNSMVJwcXMzcnNyMnNTczFxUnMzUjFyMnNTczFxUnMzUjByMnNTczFxUnMzUjFyMnNTczFxUnMzUrAhUzNSMVMzYoDxcSFw0nDxIXDScNKA1OJQkJJQomExONOAoKOAk4JiZCJQkJJQomExONOAoKOAk4JiYTJSUlJQEZJw0WUlQYDSfoUlIWDScnDWIJJgkJJgoSJQk4Cgo4CiWWCSYJCSYKEzkKOAkJOAkmE3ASAAAAAAIAAAAAAQcBHQAVABoAADc1ND4BFhczLgEOAR0BIwcVFzM3NScHMxUjNV4aKSMHFAguOCYTEhK8ExMmJrypJRUfBxUTGyAHKh0lE3ATE3ATE3BwAAUAAAAAARoBGgAJABEAHgAnAC8AADczNxcVBycjJzUfATUPASMVMzcUBgcnPgEnNic3HgEHFAcnNjQnNxYHFAcnNic3Fhw0SRAQSTQJSDs7By4uxQ8ODgwNAQEZDg4PJRMNDQ0NEyYIDgcHDgjRSAb0BkgJXlc7xjoDSyUXKhINDyQTJx8NESsXHxkNFC8TDRkfEA0ODxANDQAAAAQAAAAAARUBFAAXAC8AWwBfAAA3MzczNzU3NSc1JyMnIwcjBxUHFRcVFzM3IzUvAT8BNTM/AR8BMxUfAQ8BFSMPASc3Bg8BIzU2Nz4DMzIeAhQOAQ8BDgEdASM1NDY/AT4BNCcxLgEnMSYiBhcjNTOQDSAtCiAgCS4gDR8vCh8fCi8DKQIdHAMpBhwdBigDHR0DKAccHBUCAQERAQMCBAcJBQgLCAMEBQMGAgQRBAMLAwMBAQMCAwYGDxAQGCAKLSAOIC4JICAKLSAOIC0KEygHHBwHKAMcHAMoBxwcBygDHBxxAwMGAQkHAwYEAwUICwwJCAQHAwYDCQoFCAMOAwgHAwIEAQIEXRAAAAAGAAAAAAEsARoAQgBOAFoAYgBmAGoAADc0Nh8BFjI2PwInLgIiBzU3Fh8BNz4DFhUUIyImIgYHBgcXFh8BFjI3Nj8BFw4DIi4BLwEmJw8BDgIiJhc+ATQmJzMWFRQGByMuATU0NzMOARUUFzchBxUXITc1ByE1ITUhNSFlBwQFAQMFAwsGBwEFBgcDGwYDBQUDCQkJBggDBQYGAwUECAEBAgEEAQUDAwMBBgcIBgUDAQQBAQkGAwgHCAZzBwkJBw0SCQmeCQkSDQgIEM/+5gkJARoJE/76AQb++gEGVAQFAgQBBQMQDRsDBQMBBAUGCBAIBgkGAQQECAMGBAYIIgQDAwEBBAUEAgMIBwYEBgMUBAMPCQUGBQUFChgaGAoVGg4XCgkZDRoVChkMGxTOCfQJCfTqqBMmAAACAAAAAAEVARQAFwAeAAA3IycjJzUnNTc1NzM3MxczFxUXFQcVByMnMzcnBycHnQ0fLwofHwovHw0gLgkgIAotPw5GDUAaDRggCi0gDiAtCiAgCS4gDiAtCjBGDkEaDQADAAAAAAEVARQAFwAvADYAADczNzM3NTc1JzUnIycjByMHFQcVFxUXMzcjNS8BPwE1Mz8BHwEzFR8BDwEVIw8BJzczNycHJweQDSAtCiAgCS4gDR8vCh8fCi8DKQIdHAMpBhwdBigDHR0DKAccHAQORg1AGg0YIAotIA4gLgkgIAotIA4gLQoTKAccHAcoAxwcAygHHBwHKAMcHCBGDkEaDQAAAAQAAAAAARoA9AAHAAsAFgAhAAA3BxUXMzc1JxUjNTMHNTM1IwcVFzM1Iyc1MzUjBxUXMzUjlhMTcRIScXGpEx0JCR0TOBIcCQkcEvQTlhMTlhOpll5LEwmECRM4JhIJXgkTAAADAAD//wEuAQcAEgAfACYAABMzFxUmJzUjFTMUFyM1MzUjJzUXPgEeAg4CLgI2FzcnBycHFxz0CQgL4F0TSzhnCaQRKCQXAhIhKCQWAxI4LQ8nGAwgAQcKZwcEU6kfGRMSCrt0DAIRIigkFwISISgkUjsMNBMOGgAFAAAAAAEsAQcAEgAfACsAMQA3AAATMxcVJic1IxUzFBcjNTM1Iyc1FyIOARQeATI+ATQuAQciLgE0PgEzMhYUBicXNyc3JwcnNxcHJxz0CQgL4F0TSzhnCc4UIxQUIygjFBQjFA8aDw8aDxchIRUbCRMTCTASCBsbCAEHCmcHBFOpHxkTEgq7ZxQjKCMUFCMoIxSDDxoeGg8hLiFDGwgTEgguEggaGwgAAAAAAwAAAAABLAEHABIAHwArAAATMxcVJic1IxUzFBcjNTM1Iyc1FyIOARQeATI+ATQuAQciLgE0PgEzMhYUBhz0CQgL4F0TSzhnCc4UIxQUIygjFBQjFA8aDw8aDxchIQEHCmcHBFOpHxkTEgq7ZxQjKCMUFCMoIxSDDxoeGg8hLiEAAAAAAwAA//4BLgEHABIALgAxAAATMxcVJic1IxUzFBcjNTM1Iyc1FzIeAhceAQcOAgcOAScuAicuATc+Ajc2FycVHPQJCAvgXRNLOGcJzgoTEQ4FBwQEAgoOCA0eDwkRDgUHBAQCCg4IEjo5AQcKZwcEU6kfGRMSCrtnBQoOCA0eDwkRDgUHBAQCCg4IDR4PCREOBQpLJksAAAACAAAAAAEaAQcADwATAAABIwcVFzMVIxUzNSM1Mzc1ByM1MwEQ9AkJZziWOGcJEuHhAQcKuwoSExMSCruyqQAABgAAAAABLAD0ABkAMwA3ADsARwBTAAA3MzIWHQEUBisBIi8BJiIPAQYrASImPQE0NhciBh0BHgE7ATI/ATYyHwEWOwEyNj0BNCYjBzMVIyUzFSMnMhYUBisBIiY0NjsBMhYUBisBIiY0NjNLlhchIRcHEQ8PChYKDw8RBxchIRcQFgEVEAcMCRAOIg4QCQwHEBYWEOETEwEZExOfBAUFBC8EBQUElgQFBQQvBAUFBPQhF0sYIQoKBgYKCiEYSxchExYPSxAWBgsJCQsGFhBLDxY4ODg4JQUIBgYIBQUIBgYIBQAABAAAAAABBwEZAAUAEQAfACkAABMHFzc1NBUnJiIPAQ4BHwE2NTcWHQEUBzc+AT0BNiYnBzcXBwYiLwEmNLdPKCyMAggDDQMBBKEFDgQENAQEAQUE6BYfGwIIAw0DARJIHyE7BppqAgMMAwkDlAUG4QkJzwkJGQIIBKUECAGBFRwVAgMMAwkAAAEAAAAAAQcBGgAqAAA3BicmLwEHBiIvASY0PwEnJjQ/ATYyHwE3PgEfAR4BHQEjNQcXNTMVFAYHzAYGAwNgKgIIAw0DAyQkAwMNAwgCKmIECAQyBAQ8SUk9BQQnAwMBAlggAgMMAwkDISIDCQMMAwIgWQMBAhkBCARcQTg3LkkECAIAAAYAAAAAARoBGgALABcAIwAwADgAQAAANzM1MzUjNSMVIxUzFyMVIxUzFTM1MzUjNzUjFSMVMxUzNTM1ByYiDwEGFBYyPwE2NAcGIiY0PwEXNwcnNzYyFhRSExMTExMTlhMSEhMTEx8TExMTEkoIFwmMCBAYCIwIogIIBgN5DhMGDQYCCAbOExMTExNeEhMTExOWEhITExMTLggIjQgXEQmMCBeeAwYHA3kNEwYOBgIFCAAAAAQAAAAAARkBGgAFAAgADAAQAAATMxcHIyc3BzMnNSMVPQEzFY4Qewj2CINr1l8YGAEZ5g0NzskTExMmS0sAAAADAAAAAAD0ARoABgAaACcAADczNSM1IxUnDgEUFhcVFzM3NT4BNCYnNScjBxcUDgEiLgE0PgEyHgGNJRwTHBYZGRYKSwkWGRkWCUsKehQjKCMUFCMoIxSDEy84WgwsMiwMKQkJKQwsMiwMKQkJehQjFBQjKCMUFCMAAAAAAwAAAAAA4QEaABEAGQAdAAATNSMiDgEUHgE7ARUjFTM1IzUHIyImNDY7ARcjNTPhZxIeEhIeEhwTXhM4HBQbGxQcJhMTAQcSER8jHhJeEhLPXhsnHM/PAAUAAAAAASwA9wAHABwAJwA3AEMAADUzFSE1MxUhNyM1IwYjIiY1ND8BNCMiBzU2MzIVDwEOARUUFjMyNjUXMRUjNTMVMTYzMhYVFAYiJxUUFjMyNjU0JiIGEwEGE/7UgBABChUQESIfFhIPDxQkEBkMCwoJDRA/EREMGBQWGSoLEA0PERAcEV4mJjg4EBMRDR0FBBoMEQkmDwQBCAsHChEOGw+YQxQbGBofOw4NEhcVERMUAAMAAAAAARoBBwAHAAsADwAAASMHFRczNzUHIzUzNSM1MwEQ9AkJ9AkS4eHh4QEHCs4JCc7FhBImAAAAAAYAAAAAARoBGgAfAC8ARQBaAHoAigAANyYnJgcGDwEVNz4BMhYXBw4CBwYWFxYzMjcVMzU0JgcVFAcOAScuAj0BND4BMzcuAiIHBgc1IxUzNRYXFjMyPgI0BxQOAQcGJy4CPQE+Axc2Fx4BBz4BMhYfATUnJg4DFB4CMjY/ATUPAQYnLgI0NjcjNTMXFQcjFwcnNTcXBzNJBAUJCwcGBgQECwsFARIHCQYBAwYJBQULBxMDDwECCgUCAgEDBANrAQYLDgUDAhISAwYCBAcLBwQSAgQCBgUCBAIBAgMFAwYEAQJeAwYIBgMHAggSDgoFBQkNDgoEAgYKBgYDBQME3EtUCQl8Jw42Ng4mcusFAgMCAQMDFAMDBQYGAgEFBwQKEgQCCQcxBwsfBQMDBgUCAQIDAgQBAwIWBgsHBAIDLnQFBQEBBgwQEAcHCgYBAwICBAYECgQIBQMBAQYCCWADAwICBRUBBQEGDA8RDgoGAwIBEQIEAQICBggLCU0SCXEJJw02DTcOJQAAAwAAAAABJQEtACQAPwBMAAATMh4CFxYXFhcWMxUUDgQPAScuBT0BMj4CNz4BFy4BJy4BIgYHDgEHFRQeBBc+BTUvAQ8BLwEPAR8CPwGXCA0NDAcKCxUXDAsLExkfIREEBREiHhoTCgsYFhUKDBqIFSkSCRYWFQkSKRYKERgaHg8QHRsXEgk0CAhRHAgIAiQECQRbASwCBAYEBgUIAgFKFiYjHhsXCgMDChcbHiMnFEwBBQkGCAg4AQwMBgYGBgwMATkSIiAbGBUJCRQZGyAiEhkHAWAnAgcHMwIBAmsAAAAEAAAAAAElAS0AJAA/AGkAcQAAEzIeAhcWFxYXMhcVFA4EDwEnLgU9ARY+Ajc+ARcuAScuASIGBw4BBxUUHgQXPgU1Jx4BFA4BDwEOAR0BByMnNTQ+AT8BPgE0JicmIgcOARUHIyc0PgE3NhcWBzczFxUHIyeXCA0NDAcKCxUWDQsLExkfIREFBBEiHhoTCgsYFhUKDBqIFSkSCRYWFQkSKRYKERgaHg8QHRsXEQpgBQYFBgQGAwMDDQMFBgQGAwMDAgUPBQIDAw0DBgoGDg8GHgMNAwMNAwEsAgQGBAYFCAIBShYmIx4bFwoDAwoXGx4jJxRMAQIFCQYICDgBDAwGBgYGDAwBORIiIBsYFQkJFBkbICISGQYMDgsIAwYDBgQGAwMGBwsHAwYEBgcGAwUFAwYEAgIIDQoCBgYDYQMDDQMDAAADAAAAAAElAS0AJAA/AFMAABMyHgIXFhcWFzIXFRQOBA8BJy4FPQEWPgI3PgEXLgEnLgEiBgcOAQcVFB4EFz4FNS8BIwcnIwcVFwcVFzM3FzM3NSc3lwgNDQwHCgsVFg0LCxMZHyERBQQRIh4aEwoLGBYVCgwaiBUpEgkWFhUJEikWChEYGh4PEB0bFxEKRwcEJSUECCUlCAQlJQQHJSUBLAIEBgQGBQgCAUoWJiMeGxcKAwMKFxseIycUTAECBQkGCAg4AQwMBgYGBgwMATkSIiAbGBUJCRQZGyAiEgsIJiYIBCUlBAgmJggEJSUAAAADAAAAAAEaAR4ADgAfACsAADcWBgcXBycOAS4BPgEeAQcyNjcHPgE1NC4BIg4BFB4BNzUjNSMVIxUzFTM14gENDFAOTxxIORMcP0cwZBEfDAEMDhcnLiYXFyZFJRMmJhO5FCYQTw5QFwIrRUIjDDWADQwBDB8RFycXFyctJxdLEyUlEyUlAAAAAwAAAAABGgEeAA4AHwAjAAA3FgYHFwcnDgEuAT4BHgEHMjY3Bz4BNTQuASIOARQeASczFSPiAQ0MUA5PHEg5Exw/RzBkER8MAQwOFycuJhcXJhhdXbkUJhBPDlAXAitFQiMMNYANDAEMHxEXJxcXJy0nF10SAAAAAAAQAMYAAQAAAAAAAQAHAAAAAQAAAAAAAgAHAAcAAQAAAAAAAwAHAA4AAQAAAAAABAAHABUAAQAAAAAABQAMABwAAQAAAAAABgAHACgAAQAAAAAACgAkAC8AAQAAAAAACwATAFMAAwABBAkAAQAOAGYAAwABBAkAAgAOAHQAAwABBAkAAwAOAIIAAwABBAkABAAOAJAAAwABBAkABQAYAJ4AAwABBAkABgAOALYAAwABBAkACgBIAMQAAwABBAkACwAmAQxjb2RpY29uUmVndWxhcmNvZGljb25jb2RpY29uVmVyc2lvbiAxLjExY29kaWNvblRoZSBpY29uIGZvbnQgZm9yIFZpc3VhbCBTdHVkaW8gQ29kZWh0dHA6Ly9mb250ZWxsby5jb20AYwBvAGQAaQBjAG8AbgBSAGUAZwB1AGwAYQByAGMAbwBkAGkAYwBvAG4AYwBvAGQAaQBjAG8AbgBWAGUAcgBzAGkAbwBuACAAMQAuADEAMQBjAG8AZABpAGMAbwBuAFQAaABlACAAaQBjAG8AbgAgAGYAbwBuAHQAIABmAG8AcgAgAFYAaQBzAHUAYQBsACAAUwB0AHUAZABpAG8AIABDAG8AZABlAGgAdAB0AHAAOgAvAC8AZgBvAG4AdABlAGwAbABvAC4AYwBvAG0AAgAAAAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHOAQIBAwEEAQUBBgEHAQgBCQEKAQsBDAENAQ4BDwEQAREBEgETARQBFQEWARcBGAEZARoBGwEcAR0BHgEfASABIQEiASMBJAElASYBJwEoASkBKgErASwBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQE6ATsBPAE9AT4BPwFAAUEBQgFDAUQBRQFGAUcBSAFJAUoBSwFMAU0BTgFPAVABUQFSAVMBVAFVAVYBVwFYAVkBWgFbAVwBXQFeAV8BYAFhAWIBYwFkAWUBZgFnAWgBaQFqAWsBbAFtAW4BbwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQIGAgcCCAIJAgoCCwIMAg0CDgIPAhACEQISAhMCFAIVAhYCFwIYAhkCGgIbAhwCHQIeAh8CIAIhAiICIwIkAiUCJgInAigCKQIqAisCLAItAi4CLwIwAjECMgIzAjQCNQI2AjcCOAI5AjoCOwI8Aj0CPgI/AkACQQJCAkMCRAJFAkYCRwJIAkkCSgJLAkwCTQJOAk8CUAJRAlICUwJUAlUCVgJXAlgCWQJaAlsCXAJdAl4CXwJgAmECYgJjAmQCZQJmAmcCaAJpAmoCawJsAm0CbgJvAnACcQJyAnMCdAJ1AnYCdwJ4AnkCegJ7AnwCfQJ+An8CgAKBAoICgwKEAoUChgKHAogCiQKKAosCjAKNAo4CjwKQApECkgKTApQClQKWApcCmAKZApoCmwKcAp0CngKfAqACoQKiAqMCpAKlAqYCpwKoAqkCqgKrAqwCrQKuAq8CsAKxArICswK0ArUCtgK3ArgCuQK6ArsCvAK9Ar4CvwLAAsECwgLDAsQCxQLGAscCyALJAsoCywLMAs0CzgLPAAdhY2NvdW50FGFjdGl2YXRlLWJyZWFrcG9pbnRzA2FkZAdhcmNoaXZlCmFycm93LWJvdGgRYXJyb3ctY2lyY2xlLWRvd24RYXJyb3ctY2lyY2xlLWxlZnQSYXJyb3ctY2lyY2xlLXJpZ2h0D2Fycm93LWNpcmNsZS11cAphcnJvdy1kb3duCmFycm93LWxlZnQLYXJyb3ctcmlnaHQQYXJyb3ctc21hbGwtZG93bhBhcnJvdy1zbWFsbC1sZWZ0EWFycm93LXNtYWxsLXJpZ2h0DmFycm93LXNtYWxsLXVwCmFycm93LXN3YXAIYXJyb3ctdXAGYXR0YWNoDGF6dXJlLWRldm9wcwVhenVyZQtiZWFrZXItc3RvcAZiZWFrZXIIYmVsbC1kb3QOYmVsbC1zbGFzaC1kb3QKYmVsbC1zbGFzaARiZWxsBWJsYW5rBGJvbGQEYm9vawhib29rbWFyawticmFja2V0LWRvdA1icmFja2V0LWVycm9yCWJyaWVmY2FzZQlicm9hZGNhc3QHYnJvd3NlcgNidWcIY2FsZW5kYXINY2FsbC1pbmNvbWluZw1jYWxsLW91dGdvaW5nDmNhc2Utc2Vuc2l0aXZlCWNoZWNrLWFsbAVjaGVjawljaGVja2xpc3QMY2hldnJvbi1kb3duDGNoZXZyb24tbGVmdA1jaGV2cm9uLXJpZ2h0CmNoZXZyb24tdXAEY2hpcAxjaHJvbWUtY2xvc2UPY2hyb21lLW1heGltaXplD2Nocm9tZS1taW5pbWl6ZQ5jaHJvbWUtcmVzdG9yZQ1jaXJjbGUtZmlsbGVkE2NpcmNsZS1sYXJnZS1maWxsZWQMY2lyY2xlLWxhcmdlDGNpcmNsZS1zbGFzaBNjaXJjbGUtc21hbGwtZmlsbGVkDGNpcmNsZS1zbWFsbAZjaXJjbGUNY2lyY3VpdC1ib2FyZAljbGVhci1hbGwGY2xpcHB5CWNsb3NlLWFsbAVjbG9zZQ5jbG91ZC1kb3dubG9hZAxjbG91ZC11cGxvYWQFY2xvdWQIY29kZS1vc3MEY29kZQZjb2ZmZWUMY29sbGFwc2UtYWxsCmNvbG9yLW1vZGUHY29tYmluZRJjb21tZW50LWRpc2N1c3Npb24NY29tbWVudC1kcmFmdBJjb21tZW50LXVucmVzb2x2ZWQHY29tbWVudA5jb21wYXNzLWFjdGl2ZQtjb21wYXNzLWRvdAdjb21wYXNzB2NvcGlsb3QEY29weQhjb3ZlcmFnZQtjcmVkaXQtY2FyZARkYXNoCWRhc2hib2FyZAhkYXRhYmFzZQlkZWJ1Zy1hbGwPZGVidWctYWx0LXNtYWxsCWRlYnVnLWFsdCdkZWJ1Zy1icmVha3BvaW50LWNvbmRpdGlvbmFsLXVudmVyaWZpZWQcZGVidWctYnJlYWtwb2ludC1jb25kaXRpb25hbCBkZWJ1Zy1icmVha3BvaW50LWRhdGEtdW52ZXJpZmllZBVkZWJ1Zy1icmVha3BvaW50LWRhdGEkZGVidWctYnJlYWtwb2ludC1mdW5jdGlvbi11bnZlcmlmaWVkGWRlYnVnLWJyZWFrcG9pbnQtZnVuY3Rpb24fZGVidWctYnJlYWtwb2ludC1sb2ctdW52ZXJpZmllZBRkZWJ1Zy1icmVha3BvaW50LWxvZxxkZWJ1Zy1icmVha3BvaW50LXVuc3VwcG9ydGVkDWRlYnVnLWNvbnNvbGUUZGVidWctY29udGludWUtc21hbGwOZGVidWctY29udGludWUOZGVidWctY292ZXJhZ2UQZGVidWctZGlzY29ubmVjdBJkZWJ1Zy1saW5lLWJ5LWxpbmULZGVidWctcGF1c2ULZGVidWctcmVydW4TZGVidWctcmVzdGFydC1mcmFtZQ1kZWJ1Zy1yZXN0YXJ0FmRlYnVnLXJldmVyc2UtY29udGludWUXZGVidWctc3RhY2tmcmFtZS1hY3RpdmUQZGVidWctc3RhY2tmcmFtZQtkZWJ1Zy1zdGFydA9kZWJ1Zy1zdGVwLWJhY2sPZGVidWctc3RlcC1pbnRvDmRlYnVnLXN0ZXAtb3V0D2RlYnVnLXN0ZXAtb3ZlcgpkZWJ1Zy1zdG9wBWRlYnVnEGRlc2t0b3AtZG93bmxvYWQTZGV2aWNlLWNhbWVyYS12aWRlbw1kZXZpY2UtY2FtZXJhDWRldmljZS1tb2JpbGUKZGlmZi1hZGRlZAxkaWZmLWlnbm9yZWQNZGlmZi1tb2RpZmllZA1kaWZmLW11bHRpcGxlDGRpZmYtcmVtb3ZlZAxkaWZmLXJlbmFtZWQLZGlmZi1zaW5nbGUEZGlmZgdkaXNjYXJkBGVkaXQNZWRpdG9yLWxheW91dAhlbGxpcHNpcwxlbXB0eS13aW5kb3cLZXJyb3Itc21hbGwFZXJyb3IHZXhjbHVkZQpleHBhbmQtYWxsBmV4cG9ydApleHRlbnNpb25zCmV5ZS1jbG9zZWQDZXllCGZlZWRiYWNrC2ZpbGUtYmluYXJ5CWZpbGUtY29kZQpmaWxlLW1lZGlhCGZpbGUtcGRmDmZpbGUtc3VibW9kdWxlFmZpbGUtc3ltbGluay1kaXJlY3RvcnkRZmlsZS1zeW1saW5rLWZpbGUIZmlsZS16aXAEZmlsZQVmaWxlcw1maWx0ZXItZmlsbGVkBmZpbHRlcgVmbGFtZQlmb2xkLWRvd24HZm9sZC11cARmb2xkDWZvbGRlci1hY3RpdmUOZm9sZGVyLWxpYnJhcnkNZm9sZGVyLW9wZW5lZAZmb2xkZXIEZ2FtZQRnZWFyBGdpZnQLZ2lzdC1zZWNyZXQKZ2l0LWNvbW1pdAtnaXQtY29tcGFyZQlnaXQtZmV0Y2gJZ2l0LW1lcmdlF2dpdC1wdWxsLXJlcXVlc3QtY2xvc2VkF2dpdC1wdWxsLXJlcXVlc3QtY3JlYXRlFmdpdC1wdWxsLXJlcXVlc3QtZHJhZnQeZ2l0LXB1bGwtcmVxdWVzdC1nby10by1jaGFuZ2VzHGdpdC1wdWxsLXJlcXVlc3QtbmV3LWNoYW5nZXMQZ2l0LXB1bGwtcmVxdWVzdA9naXQtc3Rhc2gtYXBwbHkNZ2l0LXN0YXNoLXBvcAlnaXQtc3Rhc2gNZ2l0aHViLWFjdGlvbgpnaXRodWItYWx0D2dpdGh1Yi1pbnZlcnRlZA5naXRodWItcHJvamVjdAZnaXRodWIFZ2xvYmUKZ28tdG8tZmlsZQxnby10by1zZWFyY2gHZ3JhYmJlcgpncmFwaC1sZWZ0CmdyYXBoLWxpbmUNZ3JhcGgtc2NhdHRlcgVncmFwaAdncmlwcGVyEWdyb3VwLWJ5LXJlZi10eXBlDGhlYXJ0LWZpbGxlZAVoZWFydAdoaXN0b3J5BGhvbWUPaG9yaXpvbnRhbC1ydWxlBWh1Ym90BWluYm94BmluZGVudARpbmZvBmluc2VydAdpbnNwZWN0C2lzc3VlLWRyYWZ0Dmlzc3VlLXJlb3BlbmVkBmlzc3VlcwZpdGFsaWMGamVyc2V5BGpzb24Oa2ViYWItdmVydGljYWwDa2V5A2xhdw1sYXllcnMtYWN0aXZlCmxheWVycy1kb3QGbGF5ZXJzF2xheW91dC1hY3Rpdml0eWJhci1sZWZ0GGxheW91dC1hY3Rpdml0eWJhci1yaWdodA9sYXlvdXQtY2VudGVyZWQObGF5b3V0LW1lbnViYXITbGF5b3V0LXBhbmVsLWNlbnRlchRsYXlvdXQtcGFuZWwtanVzdGlmeRFsYXlvdXQtcGFuZWwtbGVmdBBsYXlvdXQtcGFuZWwtb2ZmEmxheW91dC1wYW5lbC1yaWdodAxsYXlvdXQtcGFuZWwXbGF5b3V0LXNpZGViYXItbGVmdC1vZmYTbGF5b3V0LXNpZGViYXItbGVmdBhsYXlvdXQtc2lkZWJhci1yaWdodC1vZmYUbGF5b3V0LXNpZGViYXItcmlnaHQQbGF5b3V0LXN0YXR1c2JhcgZsYXlvdXQHbGlicmFyeRFsaWdodGJ1bGItYXV0b2ZpeBFsaWdodGJ1bGItc3BhcmtsZQlsaWdodGJ1bGINbGluay1leHRlcm5hbARsaW5rC2xpc3QtZmlsdGVyCWxpc3QtZmxhdAxsaXN0LW9yZGVyZWQObGlzdC1zZWxlY3Rpb24JbGlzdC10cmVlDmxpc3QtdW5vcmRlcmVkCmxpdmUtc2hhcmUHbG9hZGluZwhsb2NhdGlvbgpsb2NrLXNtYWxsBGxvY2sGbWFnbmV0CW1haWwtcmVhZARtYWlsCm1hcC1maWxsZWQTbWFwLXZlcnRpY2FsLWZpbGxlZAxtYXAtdmVydGljYWwDbWFwCG1hcmtkb3duCW1lZ2FwaG9uZQdtZW50aW9uBG1lbnUFbWVyZ2UKbWljLWZpbGxlZANtaWMJbWlsZXN0b25lBm1pcnJvcgxtb3J0YXItYm9hcmQEbW92ZRBtdWx0aXBsZS13aW5kb3dzBW11c2ljBG11dGUIbmV3LWZpbGUKbmV3LWZvbGRlcgduZXdsaW5lCm5vLW5ld2xpbmUEbm90ZRFub3RlYm9vay10ZW1wbGF0ZQhub3RlYm9vawhvY3RvZmFjZQxvcGVuLXByZXZpZXcMb3JnYW5pemF0aW9uBm91dHB1dAdwYWNrYWdlCHBhaW50Y2FuC3Bhc3MtZmlsbGVkBHBhc3MKcGVyY2VudGFnZQpwZXJzb24tYWRkBnBlcnNvbgVwaWFubwlwaWUtY2hhcnQDcGluDHBpbm5lZC1kaXJ0eQZwaW5uZWQLcGxheS1jaXJjbGUEcGxheQRwbHVnDXByZXNlcnZlLWNhc2UHcHJldmlldxBwcmltaXRpdmUtc3F1YXJlB3Byb2plY3QFcHVsc2UIcXVlc3Rpb24FcXVvdGULcmFkaW8tdG93ZXIJcmVhY3Rpb25zC3JlY29yZC1rZXlzDHJlY29yZC1zbWFsbAZyZWNvcmQEcmVkbwpyZWZlcmVuY2VzB3JlZnJlc2gFcmVnZXgPcmVtb3RlLWV4cGxvcmVyBnJlbW90ZQZyZW1vdmULcmVwbGFjZS1hbGwHcmVwbGFjZQVyZXBseQpyZXBvLWNsb25lCnJlcG8tZmV0Y2gPcmVwby1mb3JjZS1wdXNoC3JlcG8tZm9ya2VkCXJlcG8tcHVsbAlyZXBvLXB1c2gEcmVwbwZyZXBvcnQPcmVxdWVzdC1jaGFuZ2VzBXJvYm90BnJvY2tldBJyb290LWZvbGRlci1vcGVuZWQLcm9vdC1mb2xkZXIDcnNzBHJ1YnkJcnVuLWFib3ZlEHJ1bi1hbGwtY292ZXJhZ2UHcnVuLWFsbAlydW4tYmVsb3cMcnVuLWNvdmVyYWdlCnJ1bi1lcnJvcnMIc2F2ZS1hbGwHc2F2ZS1hcwRzYXZlC3NjcmVlbi1mdWxsDXNjcmVlbi1ub3JtYWwMc2VhcmNoLWZ1enp5C3NlYXJjaC1zdG9wBnNlYXJjaARzZW5kEnNlcnZlci1lbnZpcm9ubWVudA5zZXJ2ZXItcHJvY2VzcwZzZXJ2ZXINc2V0dGluZ3MtZ2VhcghzZXR0aW5ncwVzaGFyZQZzaGllbGQHc2lnbi1pbghzaWduLW91dAZzbWlsZXkFc25ha2UPc29ydC1wcmVjZWRlbmNlDnNvdXJjZS1jb250cm9sDnNwYXJrbGUtZmlsbGVkB3NwYXJrbGUQc3BsaXQtaG9yaXpvbnRhbA5zcGxpdC12ZXJ0aWNhbAhzcXVpcnJlbApzdGFyLWVtcHR5CXN0YXItZnVsbAlzdGFyLWhhbGYLc3RvcC1jaXJjbGUNc3Vycm91bmQtd2l0aAxzeW1ib2wtYXJyYXkOc3ltYm9sLWJvb2xlYW4Mc3ltYm9sLWNsYXNzDHN5bWJvbC1jb2xvcg9zeW1ib2wtY29uc3RhbnQSc3ltYm9sLWVudW0tbWVtYmVyC3N5bWJvbC1lbnVtDHN5bWJvbC1ldmVudAxzeW1ib2wtZmllbGQLc3ltYm9sLWZpbGUQc3ltYm9sLWludGVyZmFjZQpzeW1ib2wta2V5DnN5bWJvbC1rZXl3b3JkDXN5bWJvbC1tZXRob2QLc3ltYm9sLW1pc2MQc3ltYm9sLW5hbWVzcGFjZQ5zeW1ib2wtbnVtZXJpYw9zeW1ib2wtb3BlcmF0b3IQc3ltYm9sLXBhcmFtZXRlcg9zeW1ib2wtcHJvcGVydHkMc3ltYm9sLXJ1bGVyDnN5bWJvbC1zbmlwcGV0DXN5bWJvbC1zdHJpbmcQc3ltYm9sLXN0cnVjdHVyZQ9zeW1ib2wtdmFyaWFibGUMc3luYy1pZ25vcmVkBHN5bmMFdGFibGUDdGFnBnRhcmdldAh0YXNrbGlzdAl0ZWxlc2NvcGUNdGVybWluYWwtYmFzaAx0ZXJtaW5hbC1jbWQPdGVybWluYWwtZGViaWFuDnRlcm1pbmFsLWxpbnV4E3Rlcm1pbmFsLXBvd2Vyc2hlbGwNdGVybWluYWwtdG11eA90ZXJtaW5hbC11YnVudHUIdGVybWluYWwJdGV4dC1zaXplCnRocmVlLWJhcnMRdGh1bWJzZG93bi1maWxsZWQKdGh1bWJzZG93bg90aHVtYnN1cC1maWxsZWQIdGh1bWJzdXAFdG9vbHMFdHJhc2gNdHJpYW5nbGUtZG93bg10cmlhbmdsZS1sZWZ0DnRyaWFuZ2xlLXJpZ2h0C3RyaWFuZ2xlLXVwB3R3aXR0ZXISdHlwZS1oaWVyYXJjaHktc3ViFHR5cGUtaGllcmFyY2h5LXN1cGVyDnR5cGUtaGllcmFyY2h5BnVuZm9sZBN1bmdyb3VwLWJ5LXJlZi10eXBlBnVubG9jawZ1bm11dGUKdW52ZXJpZmllZA52YXJpYWJsZS1ncm91cA92ZXJpZmllZC1maWxsZWQIdmVyaWZpZWQIdmVyc2lvbnMJdm0tYWN0aXZlCnZtLWNvbm5lY3QKdm0tb3V0bGluZQp2bS1ydW5uaW5nAnZtAnZyD3ZzY29kZS1pbnNpZGVycwZ2c2NvZGUEd2FuZAd3YXJuaW5nBXdhdGNoCndoaXRlc3BhY2UKd2hvbGUtd29yZAZ3aW5kb3cJd29yZC13cmFwEXdvcmtzcGFjZS10cnVzdGVkEXdvcmtzcGFjZS11bmtub3duE3dvcmtzcGFjZS11bnRydXN0ZWQHem9vbS1pbgh6b29tLW91dAAA) format("truetype")}.codicon[class*=codicon-]{display:inline-block;font: 16px/1 codicon;text-align:center;text-decoration:none;text-rendering:auto;text-transform:none;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;user-select:none;-webkit-user-select:none}.codicon-wrench-subaction{opacity:.5}@keyframes codicon-spin{to{transform:rotate(1turn)}}.codicon-gear.codicon-modifier-spin,.codicon-loading.codicon-modifier-spin,.codicon-notebook-state-executing.codicon-modifier-spin,.codicon-sync.codicon-modifier-spin{animation:codicon-spin 1.5s steps(30) infinite}.codicon-modifier-disabled{opacity:.4}.codicon-loading,.codicon-tree-item-loading:before{animation-duration:1s!important;animation-timing-function:cubic-bezier(.53,.21,.29,.67)!important}.context-view{position:absolute}.context-view.fixed{all:initial;color:inherit;font-family:inherit;font-size:13px;position:fixed}.monaco-count-badge{border-radius:11px;box-sizing:border-box;display:inline-block;font-size:11px;font-weight:400;line-height:11px;min-height:18px;min-width:18px;padding:3px 6px;text-align:center}.monaco-count-badge.long{border-radius:2px;line-height:normal;min-height:auto;padding:2px 3px}.monaco-dropdown{height:100%;padding:0}.monaco-dropdown>.dropdown-label{align-items:center;cursor:pointer;display:flex;height:100%;justify-content:center}.monaco-dropdown>.dropdown-label>.action-label.disabled{cursor:default}.monaco-dropdown-with-primary{border-radius:5px;display:flex!important;flex-direction:row}.monaco-dropdown-with-primary>.action-container>.action-label{margin-right:0}.monaco-dropdown-with-primary>.dropdown-action-container>.monaco-dropdown>.dropdown-label .codicon[class*=codicon-]{font-size:12px;line-height:16px;margin-left:-3px;padding-left:0;padding-right:0}.monaco-dropdown-with-primary>.dropdown-action-container>.monaco-dropdown>.dropdown-label>.action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;display:block}.monaco-findInput{position:relative}.monaco-findInput .monaco-inputbox{font-size:13px;width:100%}.monaco-findInput>.controls{position:absolute;right:2px;top:3px}.vs .monaco-findInput.disabled{background-color:#e1e1e1}.vs-dark .monaco-findInput.disabled{background-color:#333}.hc-light .monaco-findInput.highlight-0 .controls,.monaco-findInput.highlight-0 .controls{animation:monaco-findInput-highlight-0 .1s linear 0s}.hc-light .monaco-findInput.highlight-1 .controls,.monaco-findInput.highlight-1 .controls{animation:monaco-findInput-highlight-1 .1s linear 0s}.hc-black .monaco-findInput.highlight-0 .controls,.vs-dark .monaco-findInput.highlight-0 .controls{animation:monaco-findInput-highlight-dark-0 .1s linear 0s}.hc-black .monaco-findInput.highlight-1 .controls,.vs-dark .monaco-findInput.highlight-1 .controls{animation:monaco-findInput-highlight-dark-1 .1s linear 0s}@keyframes monaco-findInput-highlight-0{0%{background:#fdff00cc}to{background:transparent}}@keyframes monaco-findInput-highlight-1{0%{background:#fdff00cc}99%{background:transparent}}@keyframes monaco-findInput-highlight-dark-0{0%{background:#ffffff70}to{background:transparent}}@keyframes monaco-findInput-highlight-dark-1{0%{background:#ffffff70}99%{background:transparent}}.monaco-hover{animation:fadein .1s linear;box-sizing:border-box;cursor:default;line-height:1.5em;overflow:hidden;position:absolute;user-select:text;-webkit-user-select:text;white-space:var(--vscode-hover-whiteSpace,normal)}.monaco-hover.hidden{display:none}.monaco-hover a:hover:not(.disabled){cursor:pointer}.monaco-hover .hover-contents:not(.html-hover-contents){padding:4px 8px}.monaco-hover .markdown-hover>.hover-contents:not(.code-hover-contents){max-width:var(--vscode-hover-maxWidth,500px);word-wrap:break-word}.monaco-hover .markdown-hover>.hover-contents:not(.code-hover-contents) hr{min-width:100%}.monaco-hover .code,.monaco-hover h1,.monaco-hover h2,.monaco-hover h3,.monaco-hover h4,.monaco-hover h5,.monaco-hover h6,.monaco-hover p,.monaco-hover ul{margin:8px 0}.monaco-hover h1,.monaco-hover h2,.monaco-hover h3,.monaco-hover h4,.monaco-hover h5,.monaco-hover h6{line-height:1.1}.monaco-hover code{font-family:var(--monaco-monospace-font)}.monaco-hover hr{border-left:0;border-right:0;box-sizing:border-box;height:1px;margin:4px -8px -4px}.monaco-hover .code:first-child,.monaco-hover p:first-child,.monaco-hover ul:first-child{margin-top:0}.monaco-hover .code:last-child,.monaco-hover p:last-child,.monaco-hover ul:last-child{margin-bottom:0}.monaco-hover ol,.monaco-hover ul{padding-left:20px}.monaco-hover li>p{margin-bottom:0}.monaco-hover li>ul{margin-top:0}.monaco-hover code{border-radius:3px;padding:0 .4em}.monaco-hover .monaco-tokenized-source{white-space:var(--vscode-hover-sourceWhiteSpace,pre-wrap)}.monaco-hover .hover-row.status-bar{font-size:12px;line-height:22px}.monaco-hover .hover-row.status-bar .info{font-style:italic;padding:0 8px}.monaco-hover .hover-row.status-bar .actions{display:flex;padding:0 8px;width:100%}.monaco-hover .hover-row.status-bar .actions .action-container{cursor:pointer;margin-right:16px}.monaco-hover .hover-row.status-bar .actions .action-container .action .icon{padding-right:4px}.monaco-hover .hover-row.status-bar .actions .action-container a{color:var(--vscode-textLink-foreground);text-decoration:var(--text-link-decoration)}.monaco-hover .markdown-hover .hover-contents .codicon{color:inherit;font-size:inherit;vertical-align:middle}.monaco-hover .hover-contents a.code-link,.monaco-hover .hover-contents a.code-link:hover{color:inherit}.monaco-hover .hover-contents a.code-link:before{content:"("}.monaco-hover .hover-contents a.code-link:after{content:")"}.monaco-hover .hover-contents a.code-link>span{border-bottom:1px solid transparent;color:var(--vscode-textLink-foreground);text-decoration:underline;text-underline-position:under}.monaco-hover .hover-contents a.code-link>span:hover{color:var(--vscode-textLink-activeForeground)}.monaco-hover .markdown-hover .hover-contents:not(.code-hover-contents):not(.html-hover-contents) span{display:inline-block;margin-bottom:4px}.monaco-hover .markdown-hover .hover-contents:not(.code-hover-contents):not(.html-hover-contents) span.codicon{margin-bottom:2px}.monaco-hover-content .action-container a{-webkit-user-select:none;user-select:none}.monaco-hover-content .action-container.disabled{cursor:default;opacity:.4;pointer-events:none}.monaco-icon-label{display:flex;overflow:hidden;text-overflow:ellipsis}.monaco-icon-label:before{background-position:0;background-repeat:no-repeat;background-size:16px;display:inline-block;height:22px;line-height:inherit!important;padding-right:6px;width:16px;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;flex-shrink:0;vertical-align:top}.monaco-icon-label-iconpath{display:flex;height:16px;margin-top:2px;padding-left:2px;width:16px}.monaco-icon-label-container.disabled{color:var(--vscode-disabledForeground)}.monaco-icon-label>.monaco-icon-label-container{flex:1;min-width:0;overflow:hidden;text-overflow:ellipsis}.monaco-icon-label>.monaco-icon-label-container>.monaco-icon-name-container>.label-name{color:inherit;white-space:pre}.monaco-icon-label>.monaco-icon-label-container>.monaco-icon-name-container>.label-name>.label-separator{margin:0 2px;opacity:.5}.monaco-icon-label>.monaco-icon-label-container>.monaco-icon-suffix-container>.label-suffix{opacity:.7;white-space:pre}.monaco-icon-label>.monaco-icon-label-container>.monaco-icon-description-container>.label-description{font-size:.9em;margin-left:.5em;opacity:.7;white-space:pre}.monaco-icon-label.nowrap>.monaco-icon-label-container>.monaco-icon-description-container>.label-description{white-space:nowrap}.vs .monaco-icon-label>.monaco-icon-label-container>.monaco-icon-description-container>.label-description{opacity:.95}.monaco-icon-label.italic>.monaco-icon-label-container>.monaco-icon-description-container>.label-description,.monaco-icon-label.italic>.monaco-icon-label-container>.monaco-icon-name-container>.label-name{font-style:italic}.monaco-icon-label.deprecated{opacity:.66;text-decoration:line-through}.monaco-icon-label.italic:after{font-style:italic}.monaco-icon-label.strikethrough>.monaco-icon-label-container>.monaco-icon-description-container>.label-description,.monaco-icon-label.strikethrough>.monaco-icon-label-container>.monaco-icon-name-container>.label-name{text-decoration:line-through}.monaco-icon-label:after{font-size:90%;font-weight:600;margin:auto 16px 0 5px;opacity:.75;text-align:center}.monaco-list:focus .selected .monaco-icon-label,.monaco-list:focus .selected .monaco-icon-label:after{color:inherit!important}.monaco-list-row.focused.selected .label-description,.monaco-list-row.selected .label-description{opacity:.8}.monaco-inputbox{border-radius:2px;box-sizing:border-box;display:block;font-size:inherit;padding:0;position:relative}.monaco-inputbox>.ibwrapper>.input,.monaco-inputbox>.ibwrapper>.mirror{padding:4px 6px}.monaco-inputbox>.ibwrapper{height:100%;position:relative;width:100%}.monaco-inputbox>.ibwrapper>.input{border:none;box-sizing:border-box;color:inherit;display:inline-block;font-family:inherit;font-size:inherit;height:100%;line-height:inherit;resize:none;width:100%}.monaco-inputbox>.ibwrapper>input{text-overflow:ellipsis}.monaco-inputbox>.ibwrapper>textarea.input{display:block;outline:none;scrollbar-width:none}.monaco-inputbox>.ibwrapper>textarea.input::-webkit-scrollbar{display:none}.monaco-inputbox>.ibwrapper>textarea.input.empty{white-space:nowrap}.monaco-inputbox>.ibwrapper>.mirror{box-sizing:border-box;display:inline-block;left:0;position:absolute;top:0;visibility:hidden;white-space:pre-wrap;width:100%;word-wrap:break-word}.monaco-inputbox-container{text-align:right}.monaco-inputbox-container .monaco-inputbox-message{box-sizing:border-box;display:inline-block;font-size:12px;line-height:17px;margin-top:-1px;overflow:hidden;padding:.4em;text-align:left;width:100%;word-wrap:break-word}.monaco-inputbox .monaco-action-bar{position:absolute;right:2px;top:4px}.monaco-inputbox .monaco-action-bar .action-item{margin-left:2px}.monaco-inputbox .monaco-action-bar .action-item .codicon{background-repeat:no-repeat;height:16px;width:16px}.monaco-keybinding{align-items:center;display:flex;line-height:10px}.monaco-keybinding>.monaco-keybinding-key{border-radius:3px;border-style:solid;border-width:1px;display:inline-block;font-size:11px;margin:0 2px;padding:3px 5px;vertical-align:middle}.monaco-keybinding>.monaco-keybinding-key:first-child{margin-left:0}.monaco-keybinding>.monaco-keybinding-key:last-child{margin-right:0}.monaco-keybinding>.monaco-keybinding-key-separator{display:inline-block}.monaco-keybinding>.monaco-keybinding-key-chord-separator{width:6px}.monaco-list{height:100%;position:relative;white-space:nowrap;width:100%}.monaco-list.mouse-support{user-select:none;-webkit-user-select:none}.monaco-list>.monaco-scrollable-element{height:100%}.monaco-list-rows{height:100%;position:relative;width:100%}.monaco-list.horizontal-scrolling .monaco-list-rows{min-width:100%;width:auto}.monaco-list-row{box-sizing:border-box;overflow:hidden;position:absolute;width:100%}.monaco-list.mouse-support .monaco-list-row{cursor:pointer;touch-action:none}.monaco-list .monaco-scrollable-element>.scrollbar.vertical,.monaco-pane-view>.monaco-split-view2.vertical>.monaco-scrollable-element>.scrollbar.vertical{z-index:14}.monaco-list-row.scrolling{display:none!important}.monaco-list.element-focused,.monaco-list.selection-multiple,.monaco-list.selection-single{outline:0!important}.monaco-drag-image{border-radius:10px;display:inline-block;font-size:12px;padding:1px 7px;position:absolute;z-index:1000}.monaco-list-type-filter-message{box-sizing:border-box;height:100%;left:0;opacity:.7;padding:40px 1em 1em;pointer-events:none;position:absolute;text-align:center;top:0;white-space:normal;width:100%}.monaco-list-type-filter-message:empty{display:none}.monaco-mouse-cursor-text{cursor:text}.monaco-progress-container{height:2px;overflow:hidden;width:100%}.monaco-progress-container .progress-bit{display:none;height:2px;left:0;position:absolute;width:2%}.monaco-progress-container.active .progress-bit{display:inherit}.monaco-progress-container.discrete .progress-bit{left:0;transition:width .1s linear}.monaco-progress-container.discrete.done .progress-bit{width:100%}.monaco-progress-container.infinite .progress-bit{animation-duration:4s;animation-iteration-count:infinite;animation-name:progress;animation-timing-function:linear;transform:translateZ(0)}.monaco-progress-container.infinite.infinite-long-running .progress-bit{animation-timing-function:steps(100)}@keyframes progress{0%{transform:translate(0) scaleX(1)}50%{transform:translate(2500%) scaleX(3)}to{transform:translate(4900%) scaleX(1)}}:root{--vscode-sash-size:4px;--vscode-sash-hover-size:4px}.monaco-sash{position:absolute;touch-action:none;z-index:35}.monaco-sash.disabled{pointer-events:none}.monaco-sash.mac.vertical{cursor:col-resize}.monaco-sash.vertical.minimum{cursor:e-resize}.monaco-sash.vertical.maximum{cursor:w-resize}.monaco-sash.mac.horizontal{cursor:row-resize}.monaco-sash.horizontal.minimum{cursor:s-resize}.monaco-sash.horizontal.maximum{cursor:n-resize}.monaco-sash.disabled{cursor:default!important;pointer-events:none!important}.monaco-sash.vertical{cursor:ew-resize;height:100%;top:0;width:var(--vscode-sash-size)}.monaco-sash.horizontal{cursor:ns-resize;height:var(--vscode-sash-size);left:0;width:100%}.monaco-sash:not(.disabled)>.orthogonal-drag-handle{content:" ";cursor:all-scroll;display:block;height:calc(var(--vscode-sash-size)*2);position:absolute;width:calc(var(--vscode-sash-size)*2);z-index:100}.monaco-sash.horizontal.orthogonal-edge-north:not(.disabled)>.orthogonal-drag-handle.start,.monaco-sash.horizontal.orthogonal-edge-south:not(.disabled)>.orthogonal-drag-handle.end{cursor:nwse-resize}.monaco-sash.horizontal.orthogonal-edge-north:not(.disabled)>.orthogonal-drag-handle.end,.monaco-sash.horizontal.orthogonal-edge-south:not(.disabled)>.orthogonal-drag-handle.start{cursor:nesw-resize}.monaco-sash.vertical>.orthogonal-drag-handle.start{left:calc(var(--vscode-sash-size)*-.5);top:calc(var(--vscode-sash-size)*-1)}.monaco-sash.vertical>.orthogonal-drag-handle.end{bottom:calc(var(--vscode-sash-size)*-1);left:calc(var(--vscode-sash-size)*-.5)}.monaco-sash.horizontal>.orthogonal-drag-handle.start{left:calc(var(--vscode-sash-size)*-1);top:calc(var(--vscode-sash-size)*-.5)}.monaco-sash.horizontal>.orthogonal-drag-handle.end{right:calc(var(--vscode-sash-size)*-1);top:calc(var(--vscode-sash-size)*-.5)}.monaco-sash:before{background:transparent;content:"";height:100%;pointer-events:none;position:absolute;width:100%}.monaco-workbench:not(.reduce-motion) .monaco-sash:before{transition:background-color .1s ease-out}.monaco-sash.active:before,.monaco-sash.hover:before{background:var(--vscode-sash-hoverBorder)}.monaco-sash.vertical:before{left:calc(50% - var(--vscode-sash-hover-size)/2);width:var(--vscode-sash-hover-size)}.monaco-sash.horizontal:before{height:var(--vscode-sash-hover-size);top:calc(50% - var(--vscode-sash-hover-size)/2)}.pointer-events-disabled{pointer-events:none!important}.monaco-sash.debug{background:#0ff}.monaco-sash.debug.disabled{background:#0ff3}.monaco-sash.debug:not(.disabled)>.orthogonal-drag-handle{background:red}.monaco-scrollable-element>.scrollbar>.scra{cursor:pointer;font-size:11px!important}.monaco-scrollable-element>.visible{background:transparent;opacity:1;transition:opacity .1s linear;z-index:11}.monaco-scrollable-element>.invisible{opacity:0;pointer-events:none}.monaco-scrollable-element>.invisible.fade{transition:opacity .8s linear}.monaco-scrollable-element>.shadow{display:none;position:absolute}.monaco-scrollable-element>.shadow.top{box-shadow:var(--vscode-scrollbar-shadow) 0 6px 6px -6px inset;display:block;height:3px;left:3px;top:0;width:100%}.monaco-scrollable-element>.shadow.left{box-shadow:var(--vscode-scrollbar-shadow) 6px 0 6px -6px inset;display:block;height:100%;left:0;top:3px;width:3px}.monaco-scrollable-element>.shadow.top-left-corner{display:block;height:3px;left:0;top:0;width:3px}.monaco-scrollable-element>.shadow.top.left{box-shadow:var(--vscode-scrollbar-shadow) 6px 0 6px -6px inset}.monaco-scrollable-element>.scrollbar>.slider{background:var(--vscode-scrollbarSlider-background)}.monaco-scrollable-element>.scrollbar>.slider:hover{background:var(--vscode-scrollbarSlider-hoverBackground)}.monaco-scrollable-element>.scrollbar>.slider.active{background:var(--vscode-scrollbarSlider-activeBackground)}.monaco-select-box{border-radius:2px;cursor:pointer;width:100%}.monaco-select-box-dropdown-container{font-size:13px;font-weight:400;text-transform:none}.monaco-action-bar .action-item.select-container{cursor:default}.monaco-action-bar .action-item .monaco-select-box{cursor:pointer;min-height:18px;min-width:100px;padding:2px 23px 2px 8px}.mac .monaco-action-bar .action-item .monaco-select-box{border-radius:5px;font-size:11px}.monaco-select-box-dropdown-padding{--dropdown-padding-top:1px;--dropdown-padding-bottom:1px}.hc-black .monaco-select-box-dropdown-padding,.hc-light .monaco-select-box-dropdown-padding{--dropdown-padding-top:3px;--dropdown-padding-bottom:4px}.monaco-select-box-dropdown-container{box-sizing:border-box;display:none}.monaco-select-box-dropdown-container>.select-box-details-pane>.select-box-description-markdown *{margin:0}.monaco-select-box-dropdown-container>.select-box-details-pane>.select-box-description-markdown a:focus{outline:1px solid -webkit-focus-ring-color;outline-offset:-1px}.monaco-select-box-dropdown-container>.select-box-details-pane>.select-box-description-markdown code{font-family:var(--monaco-monospace-font);line-height:15px}.monaco-select-box-dropdown-container.visible{border-bottom-left-radius:3px;border-bottom-right-radius:3px;display:flex;flex-direction:column;overflow:hidden;text-align:left;width:1px}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container{align-self:flex-start;box-sizing:border-box;flex:0 0 auto;overflow:hidden;padding-bottom:var(--dropdown-padding-bottom);padding-left:1px;padding-right:1px;padding-top:var(--dropdown-padding-top);width:100%}.monaco-select-box-dropdown-container>.select-box-details-pane{padding:5px}.hc-black .monaco-select-box-dropdown-container>.select-box-dropdown-list-container{padding-bottom:var(--dropdown-padding-bottom);padding-top:var(--dropdown-padding-top)}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container .monaco-list .monaco-list-row{cursor:pointer}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container .monaco-list .monaco-list-row>.option-text{float:left;overflow:hidden;padding-left:3.5px;text-overflow:ellipsis;white-space:nowrap}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container .monaco-list .monaco-list-row>.option-detail{float:left;opacity:.7;overflow:hidden;padding-left:3.5px;text-overflow:ellipsis;white-space:nowrap}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container .monaco-list .monaco-list-row>.option-decorator-right{float:right;overflow:hidden;padding-right:10px;text-overflow:ellipsis;white-space:nowrap}.monaco-select-box-dropdown-container>.select-box-dropdown-list-container .monaco-list .monaco-list-row>.visually-hidden{height:1px;left:-10000px;overflow:hidden;position:absolute;top:auto;width:1px}.monaco-select-box-dropdown-container>.select-box-dropdown-container-width-control{align-self:flex-start;flex:1 1 auto;opacity:0}.monaco-select-box-dropdown-container>.select-box-dropdown-container-width-control>.width-control-div{max-height:0;overflow:hidden}.monaco-select-box-dropdown-container>.select-box-dropdown-container-width-control>.width-control-div>.option-text-width-control{padding-left:4px;padding-right:8px;white-space:nowrap}.monaco-split-view2{height:100%;position:relative;width:100%}.monaco-split-view2>.sash-container{height:100%;pointer-events:none;position:absolute;width:100%}.monaco-split-view2>.sash-container>.monaco-sash{pointer-events:auto}.monaco-split-view2>.monaco-scrollable-element{height:100%;width:100%}.monaco-split-view2>.monaco-scrollable-element>.split-view-container{height:100%;position:relative;white-space:nowrap;width:100%}.monaco-split-view2>.monaco-scrollable-element>.split-view-container>.split-view-view{position:absolute;white-space:normal}.monaco-split-view2>.monaco-scrollable-element>.split-view-container>.split-view-view:not(.visible){display:none}.monaco-split-view2.vertical>.monaco-scrollable-element>.split-view-container>.split-view-view{width:100%}.monaco-split-view2.horizontal>.monaco-scrollable-element>.split-view-container>.split-view-view{height:100%}.monaco-split-view2.separator-border>.monaco-scrollable-element>.split-view-container>.split-view-view:not(:first-child):before{background-color:var(--separator-border);content:" ";left:0;pointer-events:none;position:absolute;top:0;z-index:5}.monaco-split-view2.separator-border.horizontal>.monaco-scrollable-element>.split-view-container>.split-view-view:not(:first-child):before{height:100%;width:1px}.monaco-split-view2.separator-border.vertical>.monaco-scrollable-element>.split-view-container>.split-view-view:not(:first-child):before{height:1px;width:100%}.monaco-table{display:flex;flex-direction:column;height:100%;overflow:hidden;position:relative;white-space:nowrap;width:100%}.monaco-table>.monaco-split-view2{border-bottom:1px solid transparent}.monaco-table>.monaco-list{flex:1}.monaco-table-tr{display:flex;height:100%}.monaco-table-th{font-weight:700;height:100%;overflow:hidden;text-overflow:ellipsis;width:100%}.monaco-table-td,.monaco-table-th{box-sizing:border-box;flex-shrink:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-table>.monaco-split-view2 .monaco-sash.vertical:before{border-left:1px solid transparent;content:"";left:calc(var(--vscode-sash-size)/2);position:absolute;width:0}.monaco-workbench:not(.reduce-motion) .monaco-table>.monaco-split-view2,.monaco-workbench:not(.reduce-motion) .monaco-table>.monaco-split-view2 .monaco-sash.vertical:before{transition:border-color .2s ease-out}.monaco-custom-toggle{border:1px solid transparent;border-radius:3px;box-sizing:border-box;cursor:pointer;float:left;height:20px;margin-left:2px;overflow:hidden;padding:1px;user-select:none;-webkit-user-select:none;width:20px}.monaco-custom-toggle:hover{background-color:var(--vscode-inputOption-hoverBackground)}.hc-black .monaco-custom-toggle:hover,.hc-light .monaco-custom-toggle:hover{border:1px dashed var(--vscode-focusBorder)}.hc-black .monaco-custom-toggle,.hc-black .monaco-custom-toggle:hover,.hc-light .monaco-custom-toggle,.hc-light .monaco-custom-toggle:hover{background:none}.monaco-custom-toggle.monaco-checkbox{background-size:16px!important;border:1px solid transparent;border-radius:3px;height:18px;margin-left:0;margin-right:9px;opacity:1;padding:0;width:18px}.monaco-action-bar .checkbox-action-item{align-items:center;border-radius:2px;display:flex;padding-right:2px}.monaco-action-bar .checkbox-action-item:hover{background-color:var(--vscode-toolbar-hoverBackground)}.monaco-action-bar .checkbox-action-item>.monaco-custom-toggle.monaco-checkbox{margin-right:4px}.monaco-action-bar .checkbox-action-item>.checkbox-label{font-size:12px}.monaco-custom-toggle.monaco-checkbox:not(.checked):before{visibility:hidden}.monaco-toolbar{height:100%}.monaco-toolbar .toolbar-toggle-more{display:inline-block;padding:0}.monaco-tl-row{align-items:center;display:flex;height:100%;position:relative}.monaco-tl-row.disabled{cursor:default}.monaco-tl-indent{height:100%;left:16px;pointer-events:none;position:absolute;top:0}.hide-arrows .monaco-tl-indent{left:12px}.monaco-tl-indent>.indent-guide{border-left:1px solid transparent;box-sizing:border-box;display:inline-block;height:100%}.monaco-workbench:not(.reduce-motion) .monaco-tl-indent>.indent-guide{transition:border-color .1s linear}.monaco-tl-contents,.monaco-tl-twistie{height:100%}.monaco-tl-twistie{align-items:center;display:flex!important;flex-shrink:0;font-size:10px;justify-content:center;padding-right:6px;text-align:right;transform:translate(3px);width:16px}.monaco-tl-contents{flex:1;overflow:hidden}.monaco-tl-twistie:before{border-radius:20px}.monaco-tl-twistie.collapsed:before{transform:rotate(-90deg)}.monaco-tl-twistie.codicon-tree-item-loading:before{animation:codicon-spin 1.25s steps(30) infinite}.monaco-tree-type-filter{border:1px solid var(--vscode-widget-border);border-bottom-left-radius:4px;border-bottom-right-radius:4px;display:flex;margin:0 6px;max-width:200px;padding:3px;position:absolute;top:0;z-index:100}.monaco-workbench:not(.reduce-motion) .monaco-tree-type-filter{transition:top .3s}.monaco-tree-type-filter.disabled{top:-40px!important}.monaco-tree-type-filter-grab{align-items:center;cursor:grab;display:flex!important;justify-content:center;margin-right:2px}.monaco-tree-type-filter-grab.grabbing{cursor:grabbing}.monaco-tree-type-filter-input{flex:1}.monaco-tree-type-filter-input .monaco-inputbox{height:23px}.monaco-tree-type-filter-input .monaco-inputbox>.ibwrapper>.input,.monaco-tree-type-filter-input .monaco-inputbox>.ibwrapper>.mirror{padding:2px 4px}.monaco-tree-type-filter-input .monaco-findInput>.controls{top:2px}.monaco-tree-type-filter-actionbar{margin-left:4px}.monaco-tree-type-filter-actionbar .monaco-action-bar .action-label{padding:2px}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container{background-color:var(--vscode-sideBar-background);height:0;left:0;position:absolute;top:0;width:100%;z-index:13}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row.monaco-list-row{background-color:var(--vscode-sideBar-background);opacity:1!important;overflow:hidden;position:absolute;width:100%}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-row:hover{background-color:var(--vscode-list-hoverBackground)!important;cursor:pointer}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container.empty,.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container.empty .monaco-tree-sticky-container-shadow{display:none}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container .monaco-tree-sticky-container-shadow{bottom:-3px;height:0;left:0;position:absolute;width:100%}.monaco-list .monaco-scrollable-element .monaco-tree-sticky-container[tabindex="0"]:focus{outline:none}.monaco-editor .inputarea{background-color:transparent;border:none;color:transparent;margin:0;min-height:0;min-width:0;outline:none!important;overflow:hidden;padding:0;position:absolute;resize:none;z-index:-10}.monaco-editor .inputarea.ime-input{caret-color:var(--vscode-editorCursor-foreground);color:var(--vscode-editor-foreground);z-index:10}.monaco-workbench .workbench-hover{background:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);border-radius:3px;box-shadow:0 2px 8px var(--vscode-widget-shadow);color:var(--vscode-editorHoverWidget-foreground);font-size:13px;line-height:19px;max-width:700px;overflow:hidden;position:relative;z-index:40}.monaco-workbench .workbench-hover hr{border-bottom:none}.monaco-workbench .workbench-hover:not(.skip-fade-in){animation:fadein .1s linear}.monaco-workbench .workbench-hover.compact{font-size:12px}.monaco-workbench .workbench-hover.compact .hover-contents{padding:2px 8px}.monaco-workbench .workbench-hover-container.locked .workbench-hover{outline:1px solid var(--vscode-editorHoverWidget-border)}.monaco-workbench .workbench-hover-container.locked .workbench-hover:focus,.monaco-workbench .workbench-hover-lock:focus{outline:1px solid var(--vscode-focusBorder)}.monaco-workbench .workbench-hover-container.locked .workbench-hover-lock:hover{background:var(--vscode-toolbar-hoverBackground)}.monaco-workbench .workbench-hover-pointer{pointer-events:none;position:absolute;z-index:41}.monaco-workbench .workbench-hover-pointer:after{background-color:var(--vscode-editorHoverWidget-background);border-bottom:1px solid var(--vscode-editorHoverWidget-border);border-right:1px solid var(--vscode-editorHoverWidget-border);content:"";height:5px;position:absolute;width:5px}.monaco-workbench .locked .workbench-hover-pointer:after{border-bottom-width:2px;border-right-width:2px;height:4px;width:4px}.monaco-workbench .workbench-hover-pointer.left{left:-3px}.monaco-workbench .workbench-hover-pointer.right{right:3px}.monaco-workbench .workbench-hover-pointer.top{top:-3px}.monaco-workbench .workbench-hover-pointer.bottom{bottom:3px}.monaco-workbench .workbench-hover-pointer.left:after{transform:rotate(135deg)}.monaco-workbench .workbench-hover-pointer.right:after{transform:rotate(315deg)}.monaco-workbench .workbench-hover-pointer.top:after{transform:rotate(225deg)}.monaco-workbench .workbench-hover-pointer.bottom:after{transform:rotate(45deg)}.monaco-workbench .workbench-hover a{color:var(--vscode-textLink-foreground)}.monaco-workbench .workbench-hover a:focus{outline:1px solid;outline-color:var(--vscode-focusBorder);outline-offset:-1px;text-decoration:underline}.monaco-workbench .workbench-hover a:active,.monaco-workbench .workbench-hover a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-workbench .workbench-hover code{background:var(--vscode-textCodeBlock-background)}.monaco-workbench .workbench-hover .hover-row .actions{background:var(--vscode-editorHoverWidget-statusBarBackground)}.monaco-workbench .workbench-hover.right-aligned{left:1px}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions{flex-direction:row-reverse}.monaco-workbench .workbench-hover.right-aligned .hover-row.status-bar .actions .action-container{margin-left:16px;margin-right:0}.monaco-editor .blockDecorations-container{pointer-events:none;position:absolute;top:0}.monaco-editor .blockDecorations-block{box-sizing:border-box;position:absolute}.monaco-editor .margin-view-overlays .current-line,.monaco-editor .view-overlays .current-line{box-sizing:border-box;display:block;height:100%;left:0;position:absolute;top:0}.monaco-editor .margin-view-overlays .current-line.current-line-margin.current-line-margin-both{border-right:0}.monaco-editor .lines-content .cdr{height:100%;position:absolute}.monaco-editor .glyph-margin{position:absolute;top:0}.monaco-editor .glyph-margin-widgets .cgmr{align-items:center;display:flex;justify-content:center;position:absolute}.monaco-editor .glyph-margin-widgets .cgmr.codicon-modifier-spin:before{left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}.monaco-editor .lines-content .core-guide{box-sizing:border-box;height:100%;position:absolute}.monaco-editor .margin-view-overlays .line-numbers{bottom:0;box-sizing:border-box;cursor:default;display:inline-block;font-variant-numeric:tabular-nums;position:absolute;text-align:right;vertical-align:middle}.monaco-editor .relative-current-line-number{display:inline-block;text-align:left;width:100%}.monaco-editor .margin-view-overlays .line-numbers.lh-odd{margin-top:1px}.monaco-editor .line-numbers{color:var(--vscode-editorLineNumber-foreground)}.monaco-editor .line-numbers.active-line-number{color:var(--vscode-editorLineNumber-activeForeground)}.mtkcontrol{background:#960000!important;color:#fff!important}.mtkoverflow{background-color:var(--vscode-button-background,var(--vscode-editor-background));border-color:var(--vscode-contrastBorder);border-radius:2px;border-style:solid;border-width:1px;color:var(--vscode-button-foreground,var(--vscode-editor-foreground));cursor:pointer;padding:4px}.mtkoverflow:hover{background-color:var(--vscode-button-hoverBackground)}.monaco-editor.no-user-select .lines-content,.monaco-editor.no-user-select .view-line,.monaco-editor.no-user-select .view-lines{user-select:none;-webkit-user-select:none}.monaco-editor.mac .lines-content:hover,.monaco-editor.mac .view-line:hover,.monaco-editor.mac .view-lines:hover{user-select:text;-webkit-user-select:text;-ms-user-select:text}.monaco-editor.enable-user-select{user-select:auto;-webkit-user-select:initial}.monaco-editor .view-lines{white-space:nowrap}.monaco-editor .view-line{position:absolute;width:100%}.monaco-editor .lines-content>.view-lines>.view-line>span{bottom:0;position:absolute;top:0}.monaco-editor .mtkw,.monaco-editor .mtkz{color:var(--vscode-editorWhitespace-foreground)!important}.monaco-editor .mtkz{display:inline-block}.monaco-editor .lines-decorations{background:#fff;position:absolute;top:0}.monaco-editor .margin-view-overlays .cldr{height:100%;position:absolute}.monaco-editor .margin{background-color:var(--vscode-editorGutter-background)}.monaco-editor .margin-view-overlays .cmdr{height:100%;left:0;position:absolute;width:100%}.monaco-editor .minimap.slider-mouseover .minimap-slider{opacity:0;transition:opacity .1s linear}.monaco-editor .minimap.slider-mouseover .minimap-slider.active,.monaco-editor .minimap.slider-mouseover:hover .minimap-slider{opacity:1}.monaco-editor .minimap-slider .minimap-slider-horizontal{background:var(--vscode-minimapSlider-background)}.monaco-editor .minimap-slider:hover .minimap-slider-horizontal{background:var(--vscode-minimapSlider-hoverBackground)}.monaco-editor .minimap-slider.active .minimap-slider-horizontal{background:var(--vscode-minimapSlider-activeBackground)}.monaco-editor .minimap-shadow-visible{box-shadow:var(--vscode-scrollbar-shadow) -6px 0 6px -6px inset}.monaco-editor .minimap-shadow-hidden{position:absolute;width:0}.monaco-editor .minimap-shadow-visible{left:-6px;position:absolute;width:6px}.monaco-editor.no-minimap-shadow .minimap-shadow-visible{left:-1px;position:absolute;width:1px}.minimap.autohide{opacity:0;transition:opacity .5s}.minimap.autohide:hover{opacity:1}.monaco-editor .minimap{z-index:5}.monaco-editor .overlayWidgets{left:0;position:absolute;top:0}.monaco-editor .view-ruler{box-shadow:1px 0 0 0 var(--vscode-editorRuler-foreground) inset;position:absolute;top:0}.monaco-editor .scroll-decoration{box-shadow:var(--vscode-scrollbar-shadow) 0 6px 6px -6px inset;height:6px;left:0;position:absolute;top:0}.monaco-editor .lines-content .cslr{position:absolute}.monaco-editor .focused .selected-text{background-color:var(--vscode-editor-selectionBackground)}.monaco-editor .selected-text{background-color:var(--vscode-editor-inactiveSelectionBackground)}.monaco-editor .top-left-radius{border-top-left-radius:3px}.monaco-editor .bottom-left-radius{border-bottom-left-radius:3px}.monaco-editor .top-right-radius{border-top-right-radius:3px}.monaco-editor .bottom-right-radius{border-bottom-right-radius:3px}.monaco-editor.hc-black .top-left-radius{border-top-left-radius:0}.monaco-editor.hc-black .bottom-left-radius{border-bottom-left-radius:0}.monaco-editor.hc-black .top-right-radius{border-top-right-radius:0}.monaco-editor.hc-black .bottom-right-radius{border-bottom-right-radius:0}.monaco-editor.hc-light .top-left-radius{border-top-left-radius:0}.monaco-editor.hc-light .bottom-left-radius{border-bottom-left-radius:0}.monaco-editor.hc-light .top-right-radius{border-top-right-radius:0}.monaco-editor.hc-light .bottom-right-radius{border-bottom-right-radius:0}.monaco-editor .cursors-layer{position:absolute;top:0}.monaco-editor .cursors-layer>.cursor{box-sizing:border-box;overflow:hidden;position:absolute}.monaco-editor .cursors-layer.cursor-smooth-caret-animation>.cursor{transition:all 80ms}.monaco-editor .cursors-layer.cursor-block-outline-style>.cursor{background:transparent!important;border-style:solid;border-width:1px}.monaco-editor .cursors-layer.cursor-underline-style>.cursor{background:transparent!important;border-bottom-style:solid;border-bottom-width:2px}.monaco-editor .cursors-layer.cursor-underline-thin-style>.cursor{background:transparent!important;border-bottom-style:solid;border-bottom-width:1px}@keyframes monaco-cursor-smooth{0%,20%{opacity:1}60%,to{opacity:0}}@keyframes monaco-cursor-phase{0%,20%{opacity:1}90%,to{opacity:0}}@keyframes monaco-cursor-expand{0%,20%{transform:scaleY(1)}80%,to{transform:scaleY(0)}}.cursor-smooth{animation:monaco-cursor-smooth .5s ease-in-out 0s 20 alternate}.cursor-phase{animation:monaco-cursor-phase .5s ease-in-out 0s 20 alternate}.cursor-expand>.cursor{animation:monaco-cursor-expand .5s ease-in-out 0s 20 alternate}.monaco-editor .mwh{color:var(--vscode-editorWhitespace-foreground)!important;position:absolute}::-ms-clear{display:none}.monaco-editor .editor-widget input{color:inherit}.monaco-editor{overflow:visible;position:relative;-webkit-text-size-adjust:100%;color:var(--vscode-editor-foreground);overflow-wrap:normal}.monaco-editor,.monaco-editor-background{background-color:var(--vscode-editor-background)}.monaco-editor .rangeHighlight{background-color:var(--vscode-editor-rangeHighlightBackground);border:1px solid var(--vscode-editor-rangeHighlightBorder);box-sizing:border-box}.monaco-editor.hc-black .rangeHighlight,.monaco-editor.hc-light .rangeHighlight{border-style:dotted}.monaco-editor .symbolHighlight{background-color:var(--vscode-editor-symbolHighlightBackground);border:1px solid var(--vscode-editor-symbolHighlightBorder);box-sizing:border-box}.monaco-editor.hc-black .symbolHighlight,.monaco-editor.hc-light .symbolHighlight{border-style:dotted}.monaco-editor .overflow-guard{overflow:hidden;position:relative}.monaco-editor .view-overlays{position:absolute;top:0}.monaco-editor .margin-view-overlays>div,.monaco-editor .view-overlays>div{position:absolute;width:100%}.monaco-editor .squiggly-error{border-bottom:4px double var(--vscode-editorError-border)}.monaco-editor .squiggly-error:before{background:var(--vscode-editorError-background);content:"";display:block;height:100%;width:100%}.monaco-editor .squiggly-warning{border-bottom:4px double var(--vscode-editorWarning-border)}.monaco-editor .squiggly-warning:before{background:var(--vscode-editorWarning-background);content:"";display:block;height:100%;width:100%}.monaco-editor .squiggly-info{border-bottom:4px double var(--vscode-editorInfo-border)}.monaco-editor .squiggly-info:before{background:var(--vscode-editorInfo-background);content:"";display:block;height:100%;width:100%}.monaco-editor .squiggly-hint{border-bottom:2px dotted var(--vscode-editorHint-border)}.monaco-editor.showUnused .squiggly-unnecessary{border-bottom:2px dashed var(--vscode-editorUnnecessaryCode-border)}.monaco-editor.showDeprecated .squiggly-inline-deprecated{text-decoration:line-through;text-decoration-color:var(--vscode-editor-foreground,inherit)}.monaco-component.diff-review{user-select:none;-webkit-user-select:none;z-index:99}.monaco-diff-editor .diff-review{position:absolute}.monaco-component.diff-review .diff-review-line-number{color:var(--vscode-editorLineNumber-foreground);display:inline-block;text-align:right}.monaco-component.diff-review .diff-review-summary{padding-left:10px}.monaco-component.diff-review .diff-review-shadow{box-shadow:var(--vscode-scrollbar-shadow) 0 -6px 6px -6px inset;position:absolute}.monaco-component.diff-review .diff-review-row{white-space:pre}.monaco-component.diff-review .diff-review-table{display:table;min-width:100%}.monaco-component.diff-review .diff-review-row{display:table-row;width:100%}.monaco-component.diff-review .diff-review-spacer{display:inline-block;vertical-align:middle;width:10px}.monaco-component.diff-review .diff-review-spacer>.codicon{font-size:9px!important}.monaco-component.diff-review .diff-review-actions{display:inline-block;position:absolute;right:10px;top:2px;z-index:100}.monaco-component.diff-review .diff-review-actions .action-label{height:16px;margin:2px 0;width:16px}.monaco-component.diff-review .revertButton{cursor:pointer}.monaco-editor .diff-hidden-lines-widget{width:100%}.monaco-editor .diff-hidden-lines{font-size:13px;height:0;line-height:14px;transform:translateY(-10px)}.monaco-editor .diff-hidden-lines .bottom.dragging,.monaco-editor .diff-hidden-lines .top.dragging,.monaco-editor .diff-hidden-lines:not(.dragging) .bottom:hover,.monaco-editor .diff-hidden-lines:not(.dragging) .top:hover{background-color:var(--vscode-focusBorder)}.monaco-editor .diff-hidden-lines .bottom,.monaco-editor .diff-hidden-lines .top{background-clip:padding-box;background-color:transparent;border-bottom:2px solid transparent;border-top:4px solid transparent;height:4px;transition:background-color .1s ease-out}.monaco-editor .diff-hidden-lines .bottom.canMoveTop:not(.canMoveBottom),.monaco-editor .diff-hidden-lines .top.canMoveTop:not(.canMoveBottom),.monaco-editor.draggingUnchangedRegion.canMoveTop:not(.canMoveBottom) *{cursor:n-resize!important}.monaco-editor .diff-hidden-lines .bottom:not(.canMoveTop).canMoveBottom,.monaco-editor .diff-hidden-lines .top:not(.canMoveTop).canMoveBottom,.monaco-editor.draggingUnchangedRegion:not(.canMoveTop).canMoveBottom *{cursor:s-resize!important}.monaco-editor .diff-hidden-lines .bottom.canMoveTop.canMoveBottom,.monaco-editor .diff-hidden-lines .top.canMoveTop.canMoveBottom,.monaco-editor.draggingUnchangedRegion.canMoveTop.canMoveBottom *{cursor:ns-resize!important}.monaco-editor .diff-hidden-lines .top{transform:translateY(4px)}.monaco-editor .diff-hidden-lines .bottom{transform:translateY(-6px)}.monaco-editor .diff-unchanged-lines{background:var(--vscode-diffEditor-unchangedCodeBackground)}.monaco-editor .noModificationsOverlay{align-items:center;background:var(--vscode-editor-background);display:flex;justify-content:center;z-index:1}.monaco-editor .diff-hidden-lines .center{background:var(--vscode-diffEditor-unchangedRegionBackground);box-shadow:inset 0 -5px 5px -7px var(--vscode-diffEditor-unchangedRegionShadow),inset 0 5px 5px -7px var(--vscode-diffEditor-unchangedRegionShadow);color:var(--vscode-diffEditor-unchangedRegionForeground);display:block;height:24px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-editor .diff-hidden-lines .center span.codicon{vertical-align:middle}.monaco-editor .diff-hidden-lines .center a:hover .codicon{color:var(--vscode-editorLink-activeForeground)!important;cursor:pointer}.monaco-editor .diff-hidden-lines div.breadcrumb-item{cursor:pointer}.monaco-editor .diff-hidden-lines div.breadcrumb-item:hover{color:var(--vscode-editorLink-activeForeground)}.monaco-editor .movedModified,.monaco-editor .movedOriginal{border:2px solid var(--vscode-diffEditor-move-border)}.monaco-editor .movedModified.currentMove,.monaco-editor .movedOriginal.currentMove{border:2px solid var(--vscode-diffEditor-moveActive-border)}.monaco-diff-editor .moved-blocks-lines path.currentMove{stroke:var(--vscode-diffEditor-moveActive-border)}.monaco-diff-editor .moved-blocks-lines path{pointer-events:visiblestroke}.monaco-diff-editor .moved-blocks-lines .arrow{fill:var(--vscode-diffEditor-move-border)}.monaco-diff-editor .moved-blocks-lines .arrow.currentMove{fill:var(--vscode-diffEditor-moveActive-border)}.monaco-diff-editor .moved-blocks-lines .arrow-rectangle{fill:var(--vscode-editor-background)}.monaco-diff-editor .moved-blocks-lines{pointer-events:none;position:absolute}.monaco-diff-editor .moved-blocks-lines path{fill:none;stroke:var(--vscode-diffEditor-move-border);stroke-width:2}.monaco-editor .char-delete.diff-range-empty{border-left:3px solid var(--vscode-diffEditor-removedTextBackground);margin-left:-1px}.monaco-editor .char-insert.diff-range-empty{border-left:3px solid var(--vscode-diffEditor-insertedTextBackground)}.monaco-editor .fold-unchanged{cursor:pointer}.monaco-diff-editor .diff-moved-code-block{display:flex;justify-content:flex-end;margin-top:-4px}.monaco-diff-editor .diff-moved-code-block .action-bar .action-label.codicon{font-size:12px;height:12px;width:12px}.monaco-diff-editor .diffOverview{z-index:9}.monaco-diff-editor .diffOverview .diffViewport{z-index:10}.monaco-diff-editor.vs .diffOverview{background:#00000008}.monaco-diff-editor.vs-dark .diffOverview{background:#ffffff03}.monaco-scrollable-element.modified-in-monaco-diff-editor.vs .scrollbar,.monaco-scrollable-element.modified-in-monaco-diff-editor.vs-dark .scrollbar{background:transparent}.monaco-scrollable-element.modified-in-monaco-diff-editor.hc-black .scrollbar,.monaco-scrollable-element.modified-in-monaco-diff-editor.hc-light .scrollbar{background:none}.monaco-scrollable-element.modified-in-monaco-diff-editor .slider{z-index:10}.modified-in-monaco-diff-editor .slider.active{background:#ababab66}.modified-in-monaco-diff-editor.hc-black .slider.active,.modified-in-monaco-diff-editor.hc-light .slider.active{background:none}.monaco-diff-editor .delete-sign,.monaco-diff-editor .insert-sign,.monaco-editor .delete-sign,.monaco-editor .insert-sign{align-items:center;display:flex!important;font-size:11px!important;opacity:.7!important}.monaco-diff-editor.hc-black .delete-sign,.monaco-diff-editor.hc-black .insert-sign,.monaco-diff-editor.hc-light .delete-sign,.monaco-diff-editor.hc-light .insert-sign,.monaco-editor.hc-black .delete-sign,.monaco-editor.hc-black .insert-sign,.monaco-editor.hc-light .delete-sign,.monaco-editor.hc-light .insert-sign{opacity:1}.monaco-editor .inline-added-margin-view-zone,.monaco-editor .inline-deleted-margin-view-zone{text-align:right}.monaco-editor .arrow-revert-change{position:absolute;z-index:10}.monaco-editor .arrow-revert-change:hover{cursor:pointer}.monaco-editor .view-zones .view-lines .view-line span{display:inline-block}.monaco-editor .margin-view-zones .lightbulb-glyph:hover{cursor:pointer}.monaco-diff-editor .char-insert,.monaco-editor .char-insert{background-color:var(--vscode-diffEditor-insertedTextBackground)}.monaco-diff-editor .line-insert,.monaco-editor .line-insert{background-color:var(--vscode-diffEditor-insertedLineBackground,var(--vscode-diffEditor-insertedTextBackground))}.monaco-editor .char-insert,.monaco-editor .line-insert{border:1px solid var(--vscode-diffEditor-insertedTextBorder);box-sizing:border-box}.monaco-editor.hc-black .char-insert,.monaco-editor.hc-black .line-insert,.monaco-editor.hc-light .char-insert,.monaco-editor.hc-light .line-insert{border-style:dashed}.monaco-editor .char-delete,.monaco-editor .line-delete{border:1px solid var(--vscode-diffEditor-removedTextBorder);box-sizing:border-box}.monaco-editor.hc-black .char-delete,.monaco-editor.hc-black .line-delete,.monaco-editor.hc-light .char-delete,.monaco-editor.hc-light .line-delete{border-style:dashed}.monaco-diff-editor .gutter-insert,.monaco-editor .gutter-insert,.monaco-editor .inline-added-margin-view-zone{background-color:var(--vscode-diffEditorGutter-insertedLineBackground,var(--vscode-diffEditor-insertedLineBackground),var(--vscode-diffEditor-insertedTextBackground))}.monaco-diff-editor .char-delete,.monaco-editor .char-delete,.monaco-editor .inline-deleted-text{background-color:var(--vscode-diffEditor-removedTextBackground)}.monaco-editor .inline-deleted-text{text-decoration:line-through}.monaco-diff-editor .line-delete,.monaco-editor .line-delete{background-color:var(--vscode-diffEditor-removedLineBackground,var(--vscode-diffEditor-removedTextBackground))}.monaco-diff-editor .gutter-delete,.monaco-editor .gutter-delete,.monaco-editor .inline-deleted-margin-view-zone{background-color:var(--vscode-diffEditorGutter-removedLineBackground,var(--vscode-diffEditor-removedLineBackground),var(--vscode-diffEditor-removedTextBackground))}.monaco-diff-editor.side-by-side .editor.modified{border-left:1px solid var(--vscode-diffEditor-border);box-shadow:-6px 0 5px -5px var(--vscode-scrollbar-shadow)}.monaco-diff-editor.side-by-side .editor.original{border-right:1px solid var(--vscode-diffEditor-border);box-shadow:6px 0 5px -5px var(--vscode-scrollbar-shadow)}.monaco-diff-editor .diffViewport{background:var(--vscode-scrollbarSlider-background)}.monaco-diff-editor .diffViewport:hover{background:var(--vscode-scrollbarSlider-hoverBackground)}.monaco-diff-editor .diffViewport:active{background:var(--vscode-scrollbarSlider-activeBackground)}.monaco-editor .diagonal-fill{background-image:linear-gradient(-45deg,var(--vscode-diffEditor-diagonalFill) 12.5%,#0000 12.5%,#0000 50%,var(--vscode-diffEditor-diagonalFill) 50%,var(--vscode-diffEditor-diagonalFill) 62.5%,#0000 62.5%,#0000 100%);background-size:8px 8px}.monaco-diff-editor .gutter{flex-grow:0;flex-shrink:0;overflow:hidden;position:relative}.monaco-diff-editor .gutter>div{position:absolute}.monaco-diff-editor .gutter .gutterItem{opacity:0;transition:opacity .7s}.monaco-diff-editor .gutter .gutterItem.showAlways{opacity:1;transition:none}.monaco-diff-editor .gutter .gutterItem.noTransition{transition:none}.monaco-diff-editor .gutter:hover .gutterItem{opacity:1;transition:opacity .1s ease-in-out}.monaco-diff-editor .gutter .gutterItem .background{border-left:2px solid var(--vscode-menu-border);height:100%;left:50%;position:absolute;width:1px}.monaco-diff-editor .gutter .gutterItem .buttons{align-items:center;display:flex;justify-content:center;position:absolute;width:100%}.monaco-diff-editor .gutter .gutterItem .buttons .monaco-toolbar{height:fit-content}.monaco-diff-editor .gutter .gutterItem .buttons .monaco-toolbar .monaco-action-bar{line-height:1}.monaco-diff-editor .gutter .gutterItem .buttons .monaco-toolbar .monaco-action-bar .actions-container{background:var(--vscode-editorGutter-commentRangeForeground);border-radius:4px;width:fit-content}.monaco-diff-editor .gutter .gutterItem .buttons .monaco-toolbar .monaco-action-bar .actions-container .action-item:hover{background:var(--vscode-toolbar-hoverBackground)}.monaco-diff-editor .gutter .gutterItem .buttons .monaco-toolbar .monaco-action-bar .actions-container .action-item .action-label{padding:1px 2px}.monaco-diff-editor .diff-hidden-lines-compact{display:flex;height:11px}.monaco-diff-editor .diff-hidden-lines-compact .line-left,.monaco-diff-editor .diff-hidden-lines-compact .line-right{border-top:1px solid;border-color:var(--vscode-editorCodeLens-foreground);height:1px;margin:auto;opacity:.5;width:100%}.monaco-diff-editor .diff-hidden-lines-compact .line-left{width:20px}.monaco-diff-editor .diff-hidden-lines-compact .text{color:var(--vscode-editorCodeLens-foreground);text-wrap:nowrap;font-size:11px;line-height:11px;margin:0 4px}.monaco-editor .rendered-markdown kbd{background-color:var(--vscode-keybindingLabel-background);border-color:var(--vscode-keybindingLabel-border);border-bottom-color:var(--vscode-keybindingLabel-bottomBorder);border-radius:3px;border-style:solid;border-width:1px;box-shadow:inset 0 -1px 0 var(--vscode-widget-shadow);color:var(--vscode-keybindingLabel-foreground);padding:1px 3px;vertical-align:middle}.rendered-markdown li:has(input[type=checkbox]){list-style-type:none}.monaco-component.multiDiffEditor{background:var(--vscode-multiDiffEditor-background);height:100%;overflow-y:hidden;position:relative;width:100%}.monaco-component.multiDiffEditor>div{height:100%;left:0;position:absolute;top:0;width:100%}.monaco-component.multiDiffEditor>div.placeholder{display:grid;place-content:center;place-items:center;visibility:hidden}.monaco-component.multiDiffEditor>div.placeholder.visible{visibility:visible}.monaco-component.multiDiffEditor .active{--vscode-multiDiffEditor-border:var(--vscode-focusBorder)}.monaco-component.multiDiffEditor .multiDiffEntry{display:flex;flex:1;flex-direction:column;overflow:hidden}.monaco-component.multiDiffEditor .multiDiffEntry .collapse-button{cursor:pointer;margin:0 5px}.monaco-component.multiDiffEditor .multiDiffEntry .collapse-button a{display:block}.monaco-component.multiDiffEditor .multiDiffEntry .header{background:var(--vscode-editor-background);z-index:1000}.monaco-component.multiDiffEditor .multiDiffEntry .header:not(.collapsed) .header-content{border-bottom:1px solid var(--vscode-sideBarSectionHeader-border)}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content{align-items:center;background:var(--vscode-multiDiffEditor-headerBackground);border-top:1px solid var(--vscode-multiDiffEditor-border);color:var(--vscode-foreground);display:flex;margin:8px 0 0;padding:4px 5px}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content.shadow{box-shadow:var(--vscode-scrollbar-shadow) 0 6px 6px -6px}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content .file-path{display:flex;flex:1;min-width:0}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content .file-path .title{font-size:14px;line-height:22px}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content .file-path .title.original{flex:1;min-width:0;text-overflow:ellipsis}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content .file-path .status{font-weight:600;line-height:22px;margin:0 10px;opacity:.75}.monaco-component.multiDiffEditor .multiDiffEntry .header .header-content .actions{padding:0 8px}.monaco-component.multiDiffEditor .multiDiffEntry .editorParent{border-bottom:1px solid var(--vscode-multiDiffEditor-border);display:flex;flex:1;flex-direction:column;overflow:hidden}.monaco-component.multiDiffEditor .multiDiffEntry .editorContainer{flex:1}.monaco-editor .selection-anchor{background-color:#007acc;width:2px!important}.monaco-editor .bracket-match{background-color:var(--vscode-editorBracketMatch-background);border:1px solid var(--vscode-editorBracketMatch-border);box-sizing:border-box}.monaco-editor .lightBulbWidget{align-items:center;display:flex;justify-content:center}.monaco-editor .lightBulbWidget:hover{cursor:pointer}.monaco-editor .lightBulbWidget.codicon-light-bulb,.monaco-editor .lightBulbWidget.codicon-lightbulb-sparkle{color:var(--vscode-editorLightBulb-foreground)}.monaco-editor .lightBulbWidget.codicon-lightbulb-autofix,.monaco-editor .lightBulbWidget.codicon-lightbulb-sparkle-autofix{color:var(--vscode-editorLightBulbAutoFix-foreground,var(--vscode-editorLightBulb-foreground))}.monaco-editor .lightBulbWidget.codicon-sparkle-filled{color:var(--vscode-editorLightBulbAi-foreground,var(--vscode-icon-foreground))}.monaco-editor .lightBulbWidget:before{position:relative;z-index:2}.monaco-editor .lightBulbWidget:after{content:"";display:block;height:100%;left:0;opacity:.3;position:absolute;top:0;width:100%;z-index:1}.monaco-editor .glyph-margin-widgets .cgmr[class*=codicon-gutter-lightbulb]{cursor:pointer;display:block}.monaco-editor .glyph-margin-widgets .cgmr.codicon-gutter-lightbulb,.monaco-editor .glyph-margin-widgets .cgmr.codicon-gutter-lightbulb-sparkle{color:var(--vscode-editorLightBulb-foreground)}.monaco-editor .glyph-margin-widgets .cgmr.codicon-gutter-lightbulb-aifix-auto-fix,.monaco-editor .glyph-margin-widgets .cgmr.codicon-gutter-lightbulb-auto-fix{color:var(--vscode-editorLightBulbAutoFix-foreground,var(--vscode-editorLightBulb-foreground))}.monaco-editor .glyph-margin-widgets .cgmr.codicon-gutter-lightbulb-sparkle-filled{color:var(--vscode-editorLightBulbAi-foreground,var(--vscode-icon-foreground))}.monaco-editor .codelens-decoration{color:var(--vscode-editorCodeLens-foreground);display:inline-block;font-family:var(--vscode-editorCodeLens-fontFamily),var(--vscode-editorCodeLens-fontFamilyDefault);font-feature-settings:var(--vscode-editorCodeLens-fontFeatureSettings);font-size:var(--vscode-editorCodeLens-fontSize);line-height:var(--vscode-editorCodeLens-lineHeight);overflow:hidden;padding-right:calc(var(--vscode-editorCodeLens-fontSize)*.5);text-overflow:ellipsis;white-space:nowrap}.monaco-editor .codelens-decoration>a,.monaco-editor .codelens-decoration>span{user-select:none;-webkit-user-select:none;vertical-align:sub;white-space:nowrap}.monaco-editor .codelens-decoration>a{text-decoration:none}.monaco-editor .codelens-decoration>a:hover{cursor:pointer}.monaco-editor .codelens-decoration>a:hover,.monaco-editor .codelens-decoration>a:hover .codicon{color:var(--vscode-editorLink-activeForeground)!important}.monaco-editor .codelens-decoration .codicon{color:currentColor!important;color:var(--vscode-editorCodeLens-foreground);font-size:var(--vscode-editorCodeLens-fontSize);line-height:var(--vscode-editorCodeLens-lineHeight);vertical-align:middle}.monaco-editor .codelens-decoration>a:hover .codicon:before{cursor:pointer}@keyframes fadein{0%{opacity:0;visibility:visible}to{opacity:1}}.monaco-editor .codelens-decoration.fadein{animation:fadein .1s linear}.colorpicker-widget{height:190px;user-select:none;-webkit-user-select:none}.colorpicker-color-decoration,.hc-light .colorpicker-color-decoration{border:.1em solid #000;box-sizing:border-box;cursor:pointer;display:inline-block;height:.8em;line-height:.8em;margin:.1em .2em 0;width:.8em}.hc-black .colorpicker-color-decoration,.vs-dark .colorpicker-color-decoration{border:.1em solid #eee}.colorpicker-header{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=);background-size:9px 9px;display:flex;height:24px;image-rendering:pixelated;position:relative}.colorpicker-header .picked-color{align-items:center;color:#fff;cursor:pointer;display:flex;flex:1;justify-content:center;line-height:24px;overflow:hidden;white-space:nowrap;width:240px}.colorpicker-header .picked-color .picked-color-presentation{margin-left:5px;margin-right:5px;white-space:nowrap}.colorpicker-header .picked-color .codicon{color:inherit;font-size:14px}.colorpicker-header .picked-color.light{color:#000}.colorpicker-header .original-color{cursor:pointer;width:74px;z-index:inherit}.standalone-colorpicker{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground)}.colorpicker-header.standalone-colorpicker{border-bottom:none}.colorpicker-header .close-button{background-color:var(--vscode-editorHoverWidget-background);border-left:1px solid var(--vscode-editorHoverWidget-border);cursor:pointer}.colorpicker-header .close-button-inner-div{height:100%;text-align:center;width:100%}.colorpicker-header .close-button-inner-div:hover{background-color:var(--vscode-toolbar-hoverBackground)}.colorpicker-header .close-icon{padding:3px}.colorpicker-body{display:flex;padding:8px;position:relative}.colorpicker-body .saturation-wrap{flex:1;height:150px;min-width:220px;overflow:hidden;position:relative}.colorpicker-body .saturation-box{height:150px;position:absolute}.colorpicker-body .saturation-selection{border:1px solid #fff;border-radius:100%;box-shadow:0 0 2px #000c;height:9px;margin:-5px 0 0 -5px;position:absolute;width:9px}.colorpicker-body .strip{height:150px;width:25px}.colorpicker-body .standalone-strip{height:122px;width:25px}.colorpicker-body .hue-strip{background:linear-gradient(180deg,red 0,#ff0 17%,#0f0 33%,#0ff,#00f 67%,#f0f 83%,red);cursor:grab;margin-left:8px;position:relative}.colorpicker-body .opacity-strip{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=);background-size:9px 9px;cursor:grab;image-rendering:pixelated;margin-left:8px;position:relative}.colorpicker-body .strip.grabbing{cursor:grabbing}.colorpicker-body .slider{border:1px solid hsla(0,0%,100%,.71);box-shadow:0 0 1px #000000d9;box-sizing:border-box;height:4px;left:-2px;position:absolute;top:0;width:calc(100% + 4px)}.colorpicker-body .strip .overlay{height:150px;pointer-events:none}.colorpicker-body .standalone-strip .standalone-overlay{height:122px;pointer-events:none}.standalone-colorpicker-body{border:1px solid transparent;border-bottom:1px solid var(--vscode-editorHoverWidget-border);display:block;overflow:hidden}.colorpicker-body .insert-button{background:var(--vscode-button-background);border:none;border-radius:2px;bottom:8px;color:var(--vscode-button-foreground);cursor:pointer;height:20px;padding:0;position:absolute;right:8px;width:58px}.colorpicker-body .insert-button:hover{background:var(--vscode-button-hoverBackground)}.monaco-editor.hc-light .dnd-target,.monaco-editor.vs .dnd-target{border-right:2px dotted #000;color:#fff}.monaco-editor.vs-dark .dnd-target{border-right:2px dotted #aeafad;color:#51504f}.monaco-editor.hc-black .dnd-target{border-right:2px dotted #fff;color:#000}.monaco-editor.hc-black.mac.mouse-default .view-lines,.monaco-editor.hc-light.mac.mouse-default .view-lines,.monaco-editor.mouse-default .view-lines,.monaco-editor.vs-dark.mac.mouse-default .view-lines{cursor:default}.monaco-editor.hc-black.mac.mouse-copy .view-lines,.monaco-editor.hc-light.mac.mouse-copy .view-lines,.monaco-editor.mouse-copy .view-lines,.monaco-editor.vs-dark.mac.mouse-copy .view-lines{cursor:copy}.post-edit-widget{background-color:var(--vscode-editorWidget-background);border:1px solid var(--vscode-widget-border,transparent);border-radius:4px;box-shadow:0 0 8px 2px var(--vscode-widget-shadow);overflow:hidden}.post-edit-widget .monaco-button{border:none;border-radius:0;padding:2px}.post-edit-widget .monaco-button:hover{background-color:var(--vscode-button-secondaryHoverBackground)!important}.post-edit-widget .monaco-button .codicon{margin:0}.monaco-editor .findOptionsWidget{border:2px solid var(--vscode-contrastBorder)}.monaco-editor .find-widget,.monaco-editor .findOptionsWidget{background-color:var(--vscode-editorWidget-background);box-shadow:0 0 8px 2px var(--vscode-widget-shadow);color:var(--vscode-editorWidget-foreground)}.monaco-editor .find-widget{border-bottom:1px solid var(--vscode-widget-border);border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-left:1px solid var(--vscode-widget-border);border-right:1px solid var(--vscode-widget-border);box-sizing:border-box;height:33px;line-height:19px;overflow:hidden;padding:0 4px;position:absolute;transform:translateY(calc(-100% - 10px));transition:transform .2s linear;z-index:35}.monaco-workbench.reduce-motion .monaco-editor .find-widget{transition:transform 0ms linear}.monaco-editor .find-widget textarea{margin:0}.monaco-editor .find-widget.hiddenEditor{display:none}.monaco-editor .find-widget.replaceToggled>.replace-part{display:flex}.monaco-editor .find-widget.visible{transform:translateY(0)}.monaco-editor .find-widget .monaco-inputbox.synthetic-focus{outline:1px solid -webkit-focus-ring-color;outline-color:var(--vscode-focusBorder);outline-offset:-1px}.monaco-editor .find-widget .monaco-inputbox .input{background-color:transparent;min-height:0}.monaco-editor .find-widget .monaco-findInput .input{font-size:13px}.monaco-editor .find-widget>.find-part,.monaco-editor .find-widget>.replace-part{display:flex;font-size:12px;margin:3px 25px 0 17px}.monaco-editor .find-widget>.find-part .monaco-inputbox,.monaco-editor .find-widget>.replace-part .monaco-inputbox{min-height:25px}.monaco-editor .find-widget>.replace-part .monaco-inputbox>.ibwrapper>.mirror{padding-right:22px}.monaco-editor .find-widget>.find-part .monaco-inputbox>.ibwrapper>.input,.monaco-editor .find-widget>.find-part .monaco-inputbox>.ibwrapper>.mirror,.monaco-editor .find-widget>.replace-part .monaco-inputbox>.ibwrapper>.input,.monaco-editor .find-widget>.replace-part .monaco-inputbox>.ibwrapper>.mirror{padding-bottom:2px;padding-top:2px}.monaco-editor .find-widget>.find-part .find-actions,.monaco-editor .find-widget>.replace-part .replace-actions{align-items:center;display:flex;height:25px}.monaco-editor .find-widget .monaco-findInput{display:flex;flex:1;vertical-align:middle}.monaco-editor .find-widget .monaco-findInput .monaco-scrollable-element{width:100%}.monaco-editor .find-widget .monaco-findInput .monaco-scrollable-element .scrollbar.vertical{opacity:0}.monaco-editor .find-widget .matchesCount{box-sizing:border-box;display:flex;flex:initial;height:25px;line-height:23px;margin:0 0 0 3px;padding:2px 0 0 2px;text-align:center;vertical-align:middle}.monaco-editor .find-widget .button{align-items:center;background-position:50%;background-repeat:no-repeat;border-radius:5px;cursor:pointer;display:flex;flex:initial;height:16px;justify-content:center;margin-left:3px;padding:3px;width:16px}.monaco-editor .find-widget .codicon-find-selection{border-radius:5px;height:22px;padding:3px;width:22px}.monaco-editor .find-widget .button.left{margin-left:0;margin-right:3px}.monaco-editor .find-widget .button.wide{padding:1px 6px;top:-1px;width:auto}.monaco-editor .find-widget .button.toggle{border-radius:0;box-sizing:border-box;height:100%;left:3px;position:absolute;top:0;width:18px}.monaco-editor .find-widget .button.toggle.disabled{display:none}.monaco-editor .find-widget .disabled{color:var(--vscode-disabledForeground);cursor:default}.monaco-editor .find-widget>.replace-part{display:none}.monaco-editor .find-widget>.replace-part>.monaco-findInput{display:flex;flex:auto;flex-grow:0;flex-shrink:0;position:relative;vertical-align:middle}.monaco-editor .find-widget>.replace-part>.monaco-findInput>.controls{position:absolute;right:2px;top:3px}.monaco-editor .find-widget.reduced-find-widget .matchesCount{display:none}.monaco-editor .find-widget.narrow-find-widget{max-width:257px!important}.monaco-editor .find-widget.collapsed-find-widget{max-width:170px!important}.monaco-editor .find-widget.collapsed-find-widget .button.next,.monaco-editor .find-widget.collapsed-find-widget .button.previous,.monaco-editor .find-widget.collapsed-find-widget .button.replace,.monaco-editor .find-widget.collapsed-find-widget .button.replace-all,.monaco-editor .find-widget.collapsed-find-widget>.find-part .monaco-findInput .controls{display:none}.monaco-editor .find-widget.no-results .matchesCount{color:var(--vscode-errorForeground)}.monaco-editor .findMatch{animation-duration:0;animation-name:inherit!important;background-color:var(--vscode-editor-findMatchHighlightBackground)}.monaco-editor .currentFindMatch{background-color:var(--vscode-editor-findMatchBackground);border:2px solid var(--vscode-editor-findMatchBorder);box-sizing:border-box;padding:1px}.monaco-editor .findScope{background-color:var(--vscode-editor-findRangeHighlightBackground)}.monaco-editor .find-widget .monaco-sash{background-color:var(--vscode-editorWidget-resizeBorder,var(--vscode-editorWidget-border));left:0!important}.monaco-editor.hc-black .find-widget .button:before{left:2px;position:relative;top:1px}.monaco-editor .find-widget .button:not(.disabled):hover,.monaco-editor .find-widget .codicon-find-selection:hover{background-color:var(--vscode-toolbar-hoverBackground)!important}.monaco-editor.findMatch{background-color:var(--vscode-editor-findMatchHighlightBackground)}.monaco-editor.currentFindMatch{background-color:var(--vscode-editor-findMatchBackground)}.monaco-editor.findScope{background-color:var(--vscode-editor-findRangeHighlightBackground)}.monaco-editor.findMatch{background-color:var(--vscode-editorWidget-background)}.monaco-editor .find-widget>.button.codicon-widget-close{position:absolute;right:4px;top:5px}.monaco-editor .margin-view-overlays .codicon-folding-collapsed,.monaco-editor .margin-view-overlays .codicon-folding-expanded,.monaco-editor .margin-view-overlays .codicon-folding-manual-collapsed,.monaco-editor .margin-view-overlays .codicon-folding-manual-expanded{align-items:center;cursor:pointer;display:flex;font-size:140%;justify-content:center;margin-left:2px;opacity:0;transition:opacity .5s}.monaco-workbench.reduce-motion .monaco-editor .margin-view-overlays .codicon-folding-collapsed,.monaco-workbench.reduce-motion .monaco-editor .margin-view-overlays .codicon-folding-expanded,.monaco-workbench.reduce-motion .monaco-editor .margin-view-overlays .codicon-folding-manual-collapsed,.monaco-workbench.reduce-motion .monaco-editor .margin-view-overlays .codicon-folding-manual-expanded{transition:initial}.monaco-editor .margin-view-overlays .codicon.alwaysShowFoldIcons,.monaco-editor .margin-view-overlays .codicon.codicon-folding-collapsed,.monaco-editor .margin-view-overlays .codicon.codicon-folding-manual-collapsed,.monaco-editor .margin-view-overlays:hover .codicon{opacity:1}.monaco-editor .inline-folded:after{color:var(--vscode-editor-foldPlaceholderForeground);content:"⋯";cursor:pointer;display:inline;line-height:1em;margin:.1em .2em 0}.monaco-editor .folded-background{background-color:var(--vscode-editor-foldBackground)}.monaco-editor .cldr.codicon.codicon-folding-collapsed,.monaco-editor .cldr.codicon.codicon-folding-expanded,.monaco-editor .cldr.codicon.codicon-folding-manual-collapsed,.monaco-editor .cldr.codicon.codicon-folding-manual-expanded{color:var(--vscode-editorGutter-foldingControlForeground)!important}.monaco-editor .peekview-widget .head .peekview-title .severity-icon{display:inline-block;margin-right:4px;vertical-align:text-top}.monaco-editor .marker-widget{text-overflow:ellipsis;white-space:nowrap}.monaco-editor .marker-widget>.stale{font-style:italic;opacity:.6}.monaco-editor .marker-widget .title{display:inline-block;padding-right:5px}.monaco-editor .marker-widget .descriptioncontainer{padding:8px 12px 0 20px;position:absolute;user-select:text;-webkit-user-select:text;white-space:pre}.monaco-editor .marker-widget .descriptioncontainer .message{display:flex;flex-direction:column}.monaco-editor .marker-widget .descriptioncontainer .message .details{padding-left:6px}.monaco-editor .marker-widget .descriptioncontainer .message .source,.monaco-editor .marker-widget .descriptioncontainer .message span.code{opacity:.6}.monaco-editor .marker-widget .descriptioncontainer .message a.code-link{color:inherit;opacity:.6}.monaco-editor .marker-widget .descriptioncontainer .message a.code-link:before{content:"("}.monaco-editor .marker-widget .descriptioncontainer .message a.code-link:after{content:")"}.monaco-editor .marker-widget .descriptioncontainer .message a.code-link>span{border-bottom:1px solid transparent;color:var(--vscode-textLink-activeForeground);text-decoration:underline;text-underline-position:under}.monaco-editor .marker-widget .descriptioncontainer .filename{color:var(--vscode-textLink-activeForeground);cursor:pointer}.monaco-editor .goto-definition-link{color:var(--vscode-editorLink-activeForeground)!important;cursor:pointer;text-decoration:underline}.monaco-editor .zone-widget .zone-widget-container.reference-zone-widget{border-bottom-width:1px;border-top-width:1px}.monaco-editor .reference-zone-widget .inline{display:inline-block;vertical-align:top}.monaco-editor .reference-zone-widget .messages{height:100%;padding:3em 0;text-align:center;width:100%}.monaco-editor .reference-zone-widget .ref-tree{background-color:var(--vscode-peekViewResult-background);color:var(--vscode-peekViewResult-lineForeground);line-height:23px}.monaco-editor .reference-zone-widget .ref-tree .reference{overflow:hidden;text-overflow:ellipsis}.monaco-editor .reference-zone-widget .ref-tree .reference-file{color:var(--vscode-peekViewResult-fileForeground);display:inline-flex;height:100%;width:100%}.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .selected .reference-file{color:inherit!important}.monaco-editor .reference-zone-widget .ref-tree .monaco-list:focus .monaco-list-rows>.monaco-list-row.selected:not(.highlighted){background-color:var(--vscode-peekViewResult-selectionBackground);color:var(--vscode-peekViewResult-selectionForeground)!important}.monaco-editor .reference-zone-widget .ref-tree .reference-file .count{margin-left:auto;margin-right:12px}.monaco-editor .reference-zone-widget .ref-tree .referenceMatch .highlight{background-color:var(--vscode-peekViewResult-matchHighlightBackground)}.monaco-editor .reference-zone-widget .preview .reference-decoration{background-color:var(--vscode-peekViewEditor-matchHighlightBackground);border:2px solid var(--vscode-peekViewEditor-matchHighlightBorder);box-sizing:border-box}.monaco-editor .reference-zone-widget .preview .monaco-editor .inputarea.ime-input,.monaco-editor .reference-zone-widget .preview .monaco-editor .monaco-editor-background{background-color:var(--vscode-peekViewEditor-background)}.monaco-editor .reference-zone-widget .preview .monaco-editor .margin{background-color:var(--vscode-peekViewEditorGutter-background)}.monaco-editor.hc-black .reference-zone-widget .ref-tree .reference-file,.monaco-editor.hc-light .reference-zone-widget .ref-tree .reference-file{font-weight:700}.monaco-editor.hc-black .reference-zone-widget .ref-tree .referenceMatch .highlight,.monaco-editor.hc-light .reference-zone-widget .ref-tree .referenceMatch .highlight{border:1px dotted var(--vscode-contrastActiveBorder,transparent);box-sizing:border-box}.monaco-editor .hoverHighlight{background-color:var(--vscode-editor-hoverHighlightBackground)}.monaco-editor .monaco-hover-content{box-sizing:border-box;padding-bottom:2px;padding-right:2px}.monaco-editor .monaco-hover{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);border-radius:3px;color:var(--vscode-editorHoverWidget-foreground)}.monaco-editor .monaco-hover a{color:var(--vscode-textLink-foreground)}.monaco-editor .monaco-hover a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-editor .monaco-hover .hover-row{display:flex}.monaco-editor .monaco-hover .hover-row .hover-row-contents{display:flex;flex-direction:column;min-width:0}.monaco-editor .monaco-hover .hover-row .verbosity-actions{border-right:1px solid var(--vscode-editorHoverWidget-border);display:flex;flex-direction:column;justify-content:end;padding-left:5px;padding-right:5px}.monaco-editor .monaco-hover .hover-row .verbosity-actions .codicon{cursor:pointer;font-size:11px}.monaco-editor .monaco-hover .hover-row .verbosity-actions .codicon.enabled{color:var(--vscode-textLink-foreground)}.monaco-editor .monaco-hover .hover-row .verbosity-actions .codicon.disabled{opacity:.6}.monaco-editor .monaco-hover .hover-row .actions{background-color:var(--vscode-editorHoverWidget-statusBarBackground)}.monaco-editor .monaco-hover code{background-color:var(--vscode-textCodeBlock-background)}.monaco-editor.vs .valueSetReplacement{outline:solid 2px var(--vscode-editorBracketMatch-border)}.monaco-editor .inlineSuggestionsHints.withBorder{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground);z-index:39}.monaco-editor .inlineSuggestionsHints a,.monaco-editor .inlineSuggestionsHints a:hover{color:var(--vscode-foreground)}.monaco-editor .inlineSuggestionsHints .keybinding{display:flex;margin-left:4px;opacity:.6}.monaco-editor .inlineSuggestionsHints .keybinding .monaco-keybinding-key{font-size:8px;padding:2px 3px}.monaco-editor .inlineSuggestionsHints .availableSuggestionCount a{display:flex;justify-content:center;min-width:19px}.monaco-editor .inlineSuggestionStatusBarItemLabel{margin-right:2px}.monaco-editor .suggest-preview-additional-widget{white-space:nowrap}.monaco-editor .suggest-preview-additional-widget .content-spacer{color:transparent;white-space:pre}.monaco-editor .suggest-preview-additional-widget .button{cursor:pointer;display:inline-block;text-decoration:underline;text-underline-position:under}.monaco-editor .ghost-text-hidden{font-size:0;opacity:0}.monaco-editor .ghost-text-decoration,.monaco-editor .suggest-preview-text .ghost-text{font-style:italic}.monaco-editor .ghost-text-decoration,.monaco-editor .ghost-text-decoration-preview,.monaco-editor .suggest-preview-text .ghost-text{background-color:var(--vscode-editorGhostText-background);border:1px solid var(--vscode-editorGhostText-border);color:var(--vscode-editorGhostText-foreground)!important}.monaco-editor .inline-edit-remove{background-color:var(--vscode-editorGhostText-background);font-style:italic}.monaco-editor .inline-edit-hidden{font-size:0;opacity:0}.monaco-editor .inline-edit-decoration,.monaco-editor .suggest-preview-text .inline-edit{font-style:italic}.monaco-editor .inline-completion-text-to-replace{text-decoration:underline;text-underline-position:under}.monaco-editor .inline-edit-decoration,.monaco-editor .inline-edit-decoration-preview,.monaco-editor .suggest-preview-text .inline-edit{background-color:var(--vscode-editorGhostText-background);border:1px solid var(--vscode-editorGhostText-border);color:var(--vscode-editorGhostText-foreground)!important}.monaco-editor .inlineEditHints.withBorder{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground);z-index:39}.monaco-editor .inlineEditHints a,.monaco-editor .inlineEditHints a:hover{color:var(--vscode-foreground)}.monaco-editor .inlineEditHints .keybinding{display:flex;margin-left:4px;opacity:.6}.monaco-editor .inlineEditHints .keybinding .monaco-keybinding-key{font-size:8px;padding:2px 3px}.monaco-editor .inlineEditStatusBarItemLabel{margin-right:2px}.monaco-editor .inlineEditSideBySide{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground);white-space:pre;z-index:39}.monaco-editor div.inline-edits-widget{--widget-color:var(--vscode-notifications-background)}.monaco-editor div.inline-edits-widget .promptEditor .monaco-editor{--vscode-editor-placeholder-foreground:var(--vscode-editorGhostText-foreground)}.monaco-editor div.inline-edits-widget .promptEditor,.monaco-editor div.inline-edits-widget .toolbar{opacity:0;transition:opacity .2s ease-in-out}.monaco-editor div.inline-edits-widget.focused .promptEditor,.monaco-editor div.inline-edits-widget.focused .toolbar,.monaco-editor div.inline-edits-widget:hover .promptEditor,.monaco-editor div.inline-edits-widget:hover .toolbar{opacity:1}.monaco-editor div.inline-edits-widget .preview .monaco-editor{--vscode-editor-background:var(--widget-color)}.monaco-editor div.inline-edits-widget .preview .monaco-editor .mtk1{color:var(--vscode-editorGhostText-foreground)}.monaco-editor div.inline-edits-widget .preview .monaco-editor .current-line-margin,.monaco-editor div.inline-edits-widget .preview .monaco-editor .view-overlays .current-line-exact{border:none}.monaco-editor div.inline-edits-widget svg .gradient-start{stop-color:var(--vscode-editor-background)}.monaco-editor div.inline-edits-widget svg .gradient-stop{stop-color:var(--widget-color)}.inline-editor-progress-decoration{display:inline-block;height:1em;width:1em}.inline-progress-widget{align-items:center;display:flex!important;justify-content:center}.inline-progress-widget .icon{font-size:80%!important}.inline-progress-widget:hover .icon{animation:none;font-size:90%!important}.inline-progress-widget:hover .icon:before{content:var(--vscode-icon-x-content);font-family:var(--vscode-icon-x-font-family)}.monaco-editor .linked-editing-decoration{background-color:var(--vscode-editor-linkedEditingBackground);min-width:1px}.monaco-editor .detected-link,.monaco-editor .detected-link-active{text-decoration:underline;text-underline-position:under}.monaco-editor .detected-link-active{color:var(--vscode-editorLink-activeForeground)!important;cursor:pointer}.monaco-editor .monaco-editor-overlaymessage{padding-bottom:8px;z-index:10000}.monaco-editor .monaco-editor-overlaymessage.below{padding-bottom:0;padding-top:8px;z-index:10000}@keyframes fadeIn{0%{opacity:0}to{opacity:1}}.monaco-editor .monaco-editor-overlaymessage.fadeIn{animation:fadeIn .15s ease-out}@keyframes fadeOut{0%{opacity:1}to{opacity:0}}.monaco-editor .monaco-editor-overlaymessage.fadeOut{animation:fadeOut .1s ease-out}.monaco-editor .monaco-editor-overlaymessage .message{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-inputValidation-infoBorder);border-radius:3px;color:var(--vscode-editorHoverWidget-foreground);padding:2px 4px}.monaco-editor .monaco-editor-overlaymessage .message p{margin-block:0}.monaco-editor .monaco-editor-overlaymessage .message a{color:var(--vscode-textLink-foreground)}.monaco-editor .monaco-editor-overlaymessage .message a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-editor.hc-black .monaco-editor-overlaymessage .message,.monaco-editor.hc-light .monaco-editor-overlaymessage .message{border-width:2px}.monaco-editor .monaco-editor-overlaymessage .anchor{border:8px solid transparent;height:0!important;left:2px;position:absolute;width:0!important;z-index:1000}.monaco-editor .monaco-editor-overlaymessage .anchor.top{border-bottom-color:var(--vscode-inputValidation-infoBorder)}.monaco-editor .monaco-editor-overlaymessage .anchor.below{border-top-color:var(--vscode-inputValidation-infoBorder)}.monaco-editor .monaco-editor-overlaymessage.below .anchor.below,.monaco-editor .monaco-editor-overlaymessage:not(.below) .anchor.top{display:none}.monaco-editor .monaco-editor-overlaymessage.below .anchor.top{display:inherit;top:-8px}.monaco-editor .parameter-hints-widget{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground);cursor:default;display:flex;flex-direction:column;line-height:1.5em;z-index:39}.hc-black .monaco-editor .parameter-hints-widget,.hc-light .monaco-editor .parameter-hints-widget{border-width:2px}.monaco-editor .parameter-hints-widget>.phwrapper{display:flex;flex-direction:row;max-width:440px}.monaco-editor .parameter-hints-widget.multiple{min-height:3.3em;padding:0}.monaco-editor .parameter-hints-widget.multiple .body:before{border-left:1px solid var(--vscode-editorHoverWidget-border);content:"";display:block;height:100%;opacity:.5;position:absolute}.monaco-editor .parameter-hints-widget p,.monaco-editor .parameter-hints-widget ul{margin:8px 0}.monaco-editor .parameter-hints-widget .body,.monaco-editor .parameter-hints-widget .monaco-scrollable-element{display:flex;flex:1;flex-direction:column;min-height:100%}.monaco-editor .parameter-hints-widget .signature{padding:4px 5px;position:relative}.monaco-editor .parameter-hints-widget .signature.has-docs:after{border-bottom:1px solid var(--vscode-editorHoverWidget-border);content:"";display:block;left:0;opacity:.5;padding-top:4px;position:absolute;width:100%}.monaco-editor .parameter-hints-widget .code{font-family:var(--vscode-parameterHintsWidget-editorFontFamily),var(--vscode-parameterHintsWidget-editorFontFamilyDefault)}.monaco-editor .parameter-hints-widget .docs{padding:0 10px 0 5px;white-space:pre-wrap}.monaco-editor .parameter-hints-widget .docs.empty{display:none}.monaco-editor .parameter-hints-widget .docs a{color:var(--vscode-textLink-foreground)}.monaco-editor .parameter-hints-widget .docs a:hover{color:var(--vscode-textLink-activeForeground);cursor:pointer}.monaco-editor .parameter-hints-widget .docs .markdown-docs{white-space:normal}.monaco-editor .parameter-hints-widget .docs code{background-color:var(--vscode-textCodeBlock-background);border-radius:3px;font-family:var(--monaco-monospace-font);padding:0 .4em}.monaco-editor .parameter-hints-widget .docs .code,.monaco-editor .parameter-hints-widget .docs .monaco-tokenized-source{white-space:pre-wrap}.monaco-editor .parameter-hints-widget .controls{align-items:center;display:none;flex-direction:column;justify-content:flex-end;min-width:22px}.monaco-editor .parameter-hints-widget.multiple .controls{display:flex;padding:0 2px}.monaco-editor .parameter-hints-widget.multiple .button{background-repeat:no-repeat;cursor:pointer;height:16px;width:16px}.monaco-editor .parameter-hints-widget .button.previous{bottom:24px}.monaco-editor .parameter-hints-widget .overloads{font-family:var(--monaco-monospace-font);height:12px;line-height:12px;text-align:center}.monaco-editor .parameter-hints-widget .signature .parameter.active{color:var(--vscode-editorHoverWidget-highlightForeground);font-weight:700}.monaco-editor .parameter-hints-widget .documentation-parameter>.parameter{font-weight:700;margin-right:.5em}.monaco-editor .peekview-widget .head{box-sizing:border-box;display:flex;flex-wrap:nowrap;justify-content:space-between}.monaco-editor .peekview-widget .head .peekview-title{align-items:baseline;display:flex;font-size:13px;margin-left:20px;min-width:0;overflow:hidden;text-overflow:ellipsis}.monaco-editor .peekview-widget .head .peekview-title.clickable{cursor:pointer}.monaco-editor .peekview-widget .head .peekview-title .dirname:not(:empty){font-size:.9em;margin-left:.5em}.monaco-editor .peekview-widget .head .peekview-title .dirname,.monaco-editor .peekview-widget .head .peekview-title .filename,.monaco-editor .peekview-widget .head .peekview-title .meta{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-editor .peekview-widget .head .peekview-title .meta:not(:empty):before{content:"-";padding:0 .3em}.monaco-editor .peekview-widget .head .peekview-actions{flex:1;padding-right:2px;text-align:right}.monaco-editor .peekview-widget .head .peekview-actions>.monaco-action-bar{display:inline-block}.monaco-editor .peekview-widget .head .peekview-actions>.monaco-action-bar,.monaco-editor .peekview-widget .head .peekview-actions>.monaco-action-bar>.actions-container{height:100%}.monaco-editor .peekview-widget>.body{border-top:1px solid;position:relative}.monaco-editor .peekview-widget .head .peekview-title .codicon{align-self:center;margin-right:4px}.monaco-editor .peekview-widget .monaco-list .monaco-list-row.focused .codicon{color:inherit!important}.monaco-editor{--vscode-editor-placeholder-foreground:var(--vscode-editorGhostText-foreground)}.monaco-editor .editorPlaceholder{overflow:hidden;position:absolute;text-overflow:ellipsis;top:0;text-wrap:nowrap;color:var(--vscode-editor-placeholder-foreground);pointer-events:none}.monaco-editor .rename-box{border-radius:4px;color:inherit;z-index:100}.monaco-editor .rename-box.preview{padding:4px 4px 0}.monaco-editor .rename-box .rename-input-with-button{border-radius:2px;padding:3px;width:calc(100% - 8px)}.monaco-editor .rename-box .rename-input{padding:0;width:calc(100% - 8px)}.monaco-editor .rename-box .rename-input:focus{outline:none}.monaco-editor .rename-box .rename-suggestions-button{align-items:center;background-color:transparent;border:none;border-radius:5px;cursor:pointer;display:flex;padding:3px}.monaco-editor .rename-box .rename-suggestions-button:hover{background-color:var(--vscode-toolbar-hoverBackground)}.monaco-editor .rename-box .rename-candidate-list-container .monaco-list-row{border-radius:2px}.monaco-editor .rename-box .rename-label{display:none;opacity:.8}.monaco-editor .rename-box.preview .rename-label{display:inherit}.monaco-editor .snippet-placeholder{background-color:var(--vscode-editor-snippetTabstopHighlightBackground,transparent);min-width:2px;outline-color:var(--vscode-editor-snippetTabstopHighlightBorder,transparent);outline-style:solid;outline-width:1px}.monaco-editor .finish-snippet-placeholder{background-color:var(--vscode-editor-snippetFinalTabstopHighlightBackground,transparent);outline-color:var(--vscode-editor-snippetFinalTabstopHighlightBorder,transparent);outline-style:solid;outline-width:1px}.monaco-editor .sticky-widget{overflow:hidden}.monaco-editor .sticky-widget-line-numbers{background-color:inherit;float:left}.monaco-editor .sticky-widget-lines-scrollable{background-color:inherit;display:inline-block;overflow:hidden;position:absolute;width:var(--vscode-editorStickyScroll-scrollableWidth)}.monaco-editor .sticky-widget-lines{background-color:inherit;position:absolute}.monaco-editor .sticky-line-content,.monaco-editor .sticky-line-number{background-color:inherit;color:var(--vscode-editorLineNumber-foreground);display:inline-block;position:absolute;white-space:nowrap}.monaco-editor .sticky-line-number .codicon-folding-collapsed,.monaco-editor .sticky-line-number .codicon-folding-expanded{float:right;transition:var(--vscode-editorStickyScroll-foldingOpacityTransition)}.monaco-editor .sticky-line-content{background-color:inherit;white-space:nowrap;width:var(--vscode-editorStickyScroll-scrollableWidth)}.monaco-editor .sticky-line-number-inner{display:inline-block;text-align:right}.monaco-editor .sticky-widget{border-bottom:1px solid var(--vscode-editorStickyScroll-border)}.monaco-editor .sticky-line-content:hover{background-color:var(--vscode-editorStickyScrollHover-background);cursor:pointer}.monaco-editor .sticky-widget{background-color:var(--vscode-editorStickyScroll-background);box-shadow:var(--vscode-editorStickyScroll-shadow) 0 4px 2px -2px;right:auto!important;width:100%;z-index:4}.monaco-editor .sticky-widget.peek{background-color:var(--vscode-peekViewEditorStickyScroll-background)}.monaco-editor .suggest-widget{border-radius:3px;display:flex;flex-direction:column;width:430px;z-index:40}.monaco-editor .suggest-widget.message{align-items:center;flex-direction:row}.monaco-editor .suggest-details,.monaco-editor .suggest-widget{background-color:var(--vscode-editorSuggestWidget-background);border-color:var(--vscode-editorSuggestWidget-border);border-style:solid;border-width:1px;flex:0 1 auto;width:100%}.monaco-editor.hc-black .suggest-details,.monaco-editor.hc-black .suggest-widget,.monaco-editor.hc-light .suggest-details,.monaco-editor.hc-light .suggest-widget{border-width:2px}.monaco-editor .suggest-widget .suggest-status-bar{border-top:1px solid var(--vscode-editorSuggestWidget-border);box-sizing:border-box;display:none;flex-flow:row nowrap;font-size:80%;justify-content:space-between;overflow:hidden;padding:0 4px;width:100%}.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar{display:flex}.monaco-editor .suggest-widget .suggest-status-bar .left{padding-right:8px}.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-label{color:var(--vscode-editorSuggestWidgetStatus-foreground)}.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label{margin-right:0}.monaco-editor .suggest-widget.with-status-bar .suggest-status-bar .action-item:not(:last-of-type) .action-label:after{content:", ";margin-right:.3em}.monaco-editor .suggest-widget.with-status-bar .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore,.monaco-editor .suggest-widget.with-status-bar .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:none}.monaco-editor .suggest-widget.with-status-bar:not(.docs-side) .monaco-list .monaco-list-row:hover>.contents>.main>.right.can-expand-details>.details-label{width:100%}.monaco-editor .suggest-widget>.message{padding-left:22px}.monaco-editor .suggest-widget>.tree{height:100%;width:100%}.monaco-editor .suggest-widget .monaco-list{user-select:none;-webkit-user-select:none}.monaco-editor .suggest-widget .monaco-list .monaco-list-row{background-position:2px 2px;background-repeat:no-repeat;-mox-box-sizing:border-box;box-sizing:border-box;cursor:pointer;display:flex;padding-right:10px;touch-action:none;white-space:nowrap}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused{color:var(--vscode-editorSuggestWidget-selectedForeground)}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused .codicon{color:var(--vscode-editorSuggestWidget-selectedIconForeground)}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents{flex:1;height:100%;overflow:hidden;padding-left:2px}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main{display:flex;justify-content:space-between;overflow:hidden;text-overflow:ellipsis;white-space:pre}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left,.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{display:flex}.monaco-editor .suggest-widget .monaco-list .monaco-list-row:not(.focused)>.contents>.main .monaco-icon-label{color:var(--vscode-editorSuggestWidget-foreground)}.monaco-editor .suggest-widget:not(.frozen) .monaco-highlighted-label .highlight{font-weight:700}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-highlightForeground)}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused>.contents>.main .monaco-highlighted-label .highlight{color:var(--vscode-editorSuggestWidget-focusHighlightForeground)}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close,.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore:before{color:inherit;cursor:pointer;font-size:14px;opacity:1}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close{position:absolute;right:2px;top:6px}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.codicon-close:hover,.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore:hover{opacity:1}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{opacity:.7}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.signature-label{opacity:.6;overflow:hidden;text-overflow:ellipsis}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.qualifier-label{align-self:center;font-size:85%;line-height:normal;margin-left:12px;opacity:.4;overflow:hidden;text-overflow:ellipsis}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{font-size:85%;margin-left:1.1em;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label>.monaco-tokenized-source{display:inline}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.details-label{display:none}.monaco-editor .suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.right>.details-label,.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row.focused:not(.string-label)>.contents>.main>.right>.details-label,.monaco-editor .suggest-widget:not(.shows-details) .monaco-list .monaco-list-row.focused>.contents>.main>.right>.details-label{display:inline}.monaco-editor .suggest-widget:not(.docs-side) .monaco-list .monaco-list-row.focused:hover>.contents>.main>.right.can-expand-details>.details-label{width:calc(100% - 26px)}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left{flex-grow:1;flex-shrink:1;overflow:hidden}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.left>.monaco-icon-label{flex-shrink:0}.monaco-editor .suggest-widget .monaco-list .monaco-list-row:not(.string-label)>.contents>.main>.left>.monaco-icon-label{max-width:100%}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.left>.monaco-icon-label{flex-shrink:1}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right{flex-shrink:4;max-width:70%;overflow:hidden}.monaco-editor .suggest-widget .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:inline-block;height:18px;position:absolute;right:10px;visibility:hidden;width:18px}.monaco-editor .suggest-widget.docs-side .monaco-list .monaco-list-row>.contents>.main>.right>.readMore{display:none!important}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.string-label>.contents>.main>.right>.readMore{display:none}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused.string-label>.contents>.main>.right>.readMore{display:inline-block}.monaco-editor .suggest-widget .monaco-list .monaco-list-row.focused:hover>.contents>.main>.right>.readMore{visibility:visible}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated{opacity:.66;text-decoration:unset}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label.deprecated>.monaco-icon-label-container>.monaco-icon-name-container{text-decoration:line-through}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .monaco-icon-label:before{height:100%}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon{background-position:50%;background-repeat:no-repeat;background-size:80%;display:block;height:16px;margin-left:2px;width:16px}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.hide{display:none}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .suggest-icon{align-items:center;display:flex;margin-right:4px}.monaco-editor .suggest-widget.no-icons .monaco-list .monaco-list-row .icon,.monaco-editor .suggest-widget.no-icons .monaco-list .monaco-list-row .suggest-icon:before{display:none}.monaco-editor .suggest-widget .monaco-list .monaco-list-row .icon.customcolor .colorspan{border:.1em solid #000;display:inline-block;height:.7em;margin:0 0 0 .3em;width:.7em}.monaco-editor .suggest-details-container{z-index:41}.monaco-editor .suggest-details{color:var(--vscode-editorSuggestWidget-foreground);cursor:default;display:flex;flex-direction:column}.monaco-editor .suggest-details.focused{border-color:var(--vscode-focusBorder)}.monaco-editor .suggest-details a{color:var(--vscode-textLink-foreground)}.monaco-editor .suggest-details a:hover{color:var(--vscode-textLink-activeForeground)}.monaco-editor .suggest-details code{background-color:var(--vscode-textCodeBlock-background)}.monaco-editor .suggest-details.no-docs{display:none}.monaco-editor .suggest-details>.monaco-scrollable-element{flex:1}.monaco-editor .suggest-details>.monaco-scrollable-element>.body{box-sizing:border-box;height:100%;width:100%}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.type{flex:2;margin:0 24px 0 0;opacity:.7;overflow:hidden;padding:4px 0 12px 5px;text-overflow:ellipsis;white-space:pre}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.header>.type.auto-wrap{white-space:normal;word-break:break-all}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs{margin:0;padding:4px 5px;white-space:pre-wrap}.monaco-editor .suggest-details.no-type>.monaco-scrollable-element>.body>.docs{margin-right:24px;overflow:hidden}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs{min-height:calc(1rem + 8px);padding:0;white-space:normal}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div,.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>span:not(:empty){padding:4px 5px}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div>p:first-child{margin-top:0}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs>div>p:last-child{margin-bottom:0}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs .monaco-tokenized-source{white-space:pre}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs .code{white-space:pre-wrap;word-wrap:break-word}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>.docs.markdown-docs .codicon{vertical-align:sub}.monaco-editor .suggest-details>.monaco-scrollable-element>.body>p:empty{display:none}.monaco-editor .suggest-details code{border-radius:3px;padding:0 .4em}.monaco-editor .suggest-details ol,.monaco-editor .suggest-details ul{padding-left:20px}.monaco-editor .suggest-details p code{font-family:var(--monaco-monospace-font)}.monaco-editor .codicon.codicon-symbol-array,.monaco-workbench .codicon.codicon-symbol-array{color:var(--vscode-symbolIcon-arrayForeground)}.monaco-editor .codicon.codicon-symbol-boolean,.monaco-workbench .codicon.codicon-symbol-boolean{color:var(--vscode-symbolIcon-booleanForeground)}.monaco-editor .codicon.codicon-symbol-class,.monaco-workbench .codicon.codicon-symbol-class{color:var(--vscode-symbolIcon-classForeground)}.monaco-editor .codicon.codicon-symbol-method,.monaco-workbench .codicon.codicon-symbol-method{color:var(--vscode-symbolIcon-methodForeground)}.monaco-editor .codicon.codicon-symbol-color,.monaco-workbench .codicon.codicon-symbol-color{color:var(--vscode-symbolIcon-colorForeground)}.monaco-editor .codicon.codicon-symbol-constant,.monaco-workbench .codicon.codicon-symbol-constant{color:var(--vscode-symbolIcon-constantForeground)}.monaco-editor .codicon.codicon-symbol-constructor,.monaco-workbench .codicon.codicon-symbol-constructor{color:var(--vscode-symbolIcon-constructorForeground)}.monaco-editor .codicon.codicon-symbol-enum,.monaco-editor .codicon.codicon-symbol-value,.monaco-workbench .codicon.codicon-symbol-enum,.monaco-workbench .codicon.codicon-symbol-value{color:var(--vscode-symbolIcon-enumeratorForeground)}.monaco-editor .codicon.codicon-symbol-enum-member,.monaco-workbench .codicon.codicon-symbol-enum-member{color:var(--vscode-symbolIcon-enumeratorMemberForeground)}.monaco-editor .codicon.codicon-symbol-event,.monaco-workbench .codicon.codicon-symbol-event{color:var(--vscode-symbolIcon-eventForeground)}.monaco-editor .codicon.codicon-symbol-field,.monaco-workbench .codicon.codicon-symbol-field{color:var(--vscode-symbolIcon-fieldForeground)}.monaco-editor .codicon.codicon-symbol-file,.monaco-workbench .codicon.codicon-symbol-file{color:var(--vscode-symbolIcon-fileForeground)}.monaco-editor .codicon.codicon-symbol-folder,.monaco-workbench .codicon.codicon-symbol-folder{color:var(--vscode-symbolIcon-folderForeground)}.monaco-editor .codicon.codicon-symbol-function,.monaco-workbench .codicon.codicon-symbol-function{color:var(--vscode-symbolIcon-functionForeground)}.monaco-editor .codicon.codicon-symbol-interface,.monaco-workbench .codicon.codicon-symbol-interface{color:var(--vscode-symbolIcon-interfaceForeground)}.monaco-editor .codicon.codicon-symbol-key,.monaco-workbench .codicon.codicon-symbol-key{color:var(--vscode-symbolIcon-keyForeground)}.monaco-editor .codicon.codicon-symbol-keyword,.monaco-workbench .codicon.codicon-symbol-keyword{color:var(--vscode-symbolIcon-keywordForeground)}.monaco-editor .codicon.codicon-symbol-module,.monaco-workbench .codicon.codicon-symbol-module{color:var(--vscode-symbolIcon-moduleForeground)}.monaco-editor .codicon.codicon-symbol-namespace,.monaco-workbench .codicon.codicon-symbol-namespace{color:var(--vscode-symbolIcon-namespaceForeground)}.monaco-editor .codicon.codicon-symbol-null,.monaco-workbench .codicon.codicon-symbol-null{color:var(--vscode-symbolIcon-nullForeground)}.monaco-editor .codicon.codicon-symbol-number,.monaco-workbench .codicon.codicon-symbol-number{color:var(--vscode-symbolIcon-numberForeground)}.monaco-editor .codicon.codicon-symbol-object,.monaco-workbench .codicon.codicon-symbol-object{color:var(--vscode-symbolIcon-objectForeground)}.monaco-editor .codicon.codicon-symbol-operator,.monaco-workbench .codicon.codicon-symbol-operator{color:var(--vscode-symbolIcon-operatorForeground)}.monaco-editor .codicon.codicon-symbol-package,.monaco-workbench .codicon.codicon-symbol-package{color:var(--vscode-symbolIcon-packageForeground)}.monaco-editor .codicon.codicon-symbol-property,.monaco-workbench .codicon.codicon-symbol-property{color:var(--vscode-symbolIcon-propertyForeground)}.monaco-editor .codicon.codicon-symbol-reference,.monaco-workbench .codicon.codicon-symbol-reference{color:var(--vscode-symbolIcon-referenceForeground)}.monaco-editor .codicon.codicon-symbol-snippet,.monaco-workbench .codicon.codicon-symbol-snippet{color:var(--vscode-symbolIcon-snippetForeground)}.monaco-editor .codicon.codicon-symbol-string,.monaco-workbench .codicon.codicon-symbol-string{color:var(--vscode-symbolIcon-stringForeground)}.monaco-editor .codicon.codicon-symbol-struct,.monaco-workbench .codicon.codicon-symbol-struct{color:var(--vscode-symbolIcon-structForeground)}.monaco-editor .codicon.codicon-symbol-text,.monaco-workbench .codicon.codicon-symbol-text{color:var(--vscode-symbolIcon-textForeground)}.monaco-editor .codicon.codicon-symbol-type-parameter,.monaco-workbench .codicon.codicon-symbol-type-parameter{color:var(--vscode-symbolIcon-typeParameterForeground)}.monaco-editor .codicon.codicon-symbol-unit,.monaco-workbench .codicon.codicon-symbol-unit{color:var(--vscode-symbolIcon-unitForeground)}.monaco-editor .codicon.codicon-symbol-variable,.monaco-workbench .codicon.codicon-symbol-variable{color:var(--vscode-symbolIcon-variableForeground)}.editor-banner{background:var(--vscode-banner-background);box-sizing:border-box;cursor:default;display:flex;font-size:12px;height:26px;overflow:visible;width:100%}.editor-banner .icon-container{align-items:center;display:flex;flex-shrink:0;padding:0 6px 0 10px}.editor-banner .icon-container.custom-icon{background-position:50%;background-repeat:no-repeat;background-size:16px;margin:0 6px 0 10px;padding:0;width:16px}.editor-banner .message-container{align-items:center;display:flex;line-height:26px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.editor-banner .message-container p{margin-block-end:0;margin-block-start:0}.editor-banner .message-actions-container{flex-grow:1;flex-shrink:0;line-height:26px;margin:0 4px}.editor-banner .message-actions-container a.monaco-button{margin:2px 8px;padding:0 12px;width:inherit}.editor-banner .message-actions-container a{margin-left:12px;padding:3px;text-decoration:underline}.editor-banner .action-container{padding:0 10px 0 6px}.editor-banner{background-color:var(--vscode-banner-background)}.editor-banner,.editor-banner .action-container .codicon,.editor-banner .message-actions-container .monaco-link{color:var(--vscode-banner-foreground)}.editor-banner .icon-container .codicon{color:var(--vscode-banner-iconForeground)}.monaco-editor .unicode-highlight{background-color:var(--vscode-editorUnicodeHighlight-background);border:1px solid var(--vscode-editorUnicodeHighlight-border);box-sizing:border-box}.monaco-editor .focused .selectionHighlight{background-color:var(--vscode-editor-selectionHighlightBackground);border:1px solid var(--vscode-editor-selectionHighlightBorder);box-sizing:border-box}.monaco-editor.hc-black .focused .selectionHighlight,.monaco-editor.hc-light .focused .selectionHighlight{border-style:dotted}.monaco-editor .wordHighlight{background-color:var(--vscode-editor-wordHighlightBackground);border:1px solid var(--vscode-editor-wordHighlightBorder);box-sizing:border-box}.monaco-editor.hc-black .wordHighlight,.monaco-editor.hc-light .wordHighlight{border-style:dotted}.monaco-editor .wordHighlightStrong{background-color:var(--vscode-editor-wordHighlightStrongBackground);border:1px solid var(--vscode-editor-wordHighlightStrongBorder);box-sizing:border-box}.monaco-editor.hc-black .wordHighlightStrong,.monaco-editor.hc-light .wordHighlightStrong{border-style:dotted}.monaco-editor .wordHighlightText{background-color:var(--vscode-editor-wordHighlightTextBackground);border:1px solid var(--vscode-editor-wordHighlightTextBorder);box-sizing:border-box}.monaco-editor.hc-black .wordHighlightText,.monaco-editor.hc-light .wordHighlightText{border-style:dotted}.monaco-editor .zone-widget{position:absolute;z-index:10}.monaco-editor .zone-widget .zone-widget-container{border-bottom-style:solid;border-bottom-width:0;border-top-style:solid;border-top-width:0;position:relative}.monaco-editor .iPadShowKeyboard{background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MyIgaGVpZ2h0PSIzNiIgZmlsbD0ibm9uZSI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSIjNDI0MjQyIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00OC4wMzYgNC4wMUg0LjAwOFYzMi4wM2g0NC4wMjh6TTQuMDA4LjAwOEE0LjAwMyA0LjAwMyAwIDAgMCAuMDA1IDQuMDFWMzIuMDNhNC4wMDMgNC4wMDMgMCAwIDAgNC4wMDMgNC4wMDJoNDQuMDI4YTQuMDAzIDQuMDAzIDAgMCAwIDQuMDAzLTQuMDAyVjQuMDFBNC4wMDMgNC4wMDMgMCAwIDAgNDguMDM2LjAwOHpNOC4wMSA4LjAxM2g0LjAwM3Y0LjAwM0g4LjAxem0xMi4wMDggMGgtNC4wMDJ2NC4wMDNoNC4wMDJ6bTQuMDAzIDBoNC4wMDJ2NC4wMDNoLTQuMDAyem0xMi4wMDggMGgtNC4wMDN2NC4wMDNoNC4wMDN6bTQuMDAyIDBoNC4wMDN2NC4wMDNINDAuMDN6bS0yNC4wMTUgOC4wMDVIOC4wMXY0LjAwM2g4LjAwNnptNC4wMDIgMGg0LjAwM3Y0LjAwM2gtNC4wMDN6bTEyLjAwOCAwaC00LjAwM3Y0LjAwM2g0LjAwM3ptMTIuMDA4IDB2NC4wMDNoLTguMDA1di00LjAwM3ptLTMyLjAyMSA4LjAwNUg4LjAxdjQuMDAzaDQuMDAzem00LjAwMyAwaDIwLjAxM3Y0LjAwM0gxNi4wMTZ6bTI4LjAxOCAwSDQwLjAzdjQuMDAzaDQuMDAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD0iYSI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTAgMGg1M3YzNkgweiIvPjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPg==) 50% no-repeat;border:4px solid #f6f6f6;border-radius:4px;height:36px;margin:0;min-height:0;min-width:0;overflow:hidden;padding:0;position:absolute;resize:none;width:58px}.monaco-editor.vs-dark .iPadShowKeyboard{background:url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MyIgaGVpZ2h0PSIzNiIgZmlsbD0ibm9uZSI+PGcgY2xpcC1wYXRoPSJ1cmwoI2EpIj48cGF0aCBmaWxsPSIjQzVDNUM1IiBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00OC4wMzYgNC4wMUg0LjAwOFYzMi4wM2g0NC4wMjh6TTQuMDA4LjAwOEE0LjAwMyA0LjAwMyAwIDAgMCAuMDA1IDQuMDFWMzIuMDNhNC4wMDMgNC4wMDMgMCAwIDAgNC4wMDMgNC4wMDJoNDQuMDI4YTQuMDAzIDQuMDAzIDAgMCAwIDQuMDAzLTQuMDAyVjQuMDFBNC4wMDMgNC4wMDMgMCAwIDAgNDguMDM2LjAwOHpNOC4wMSA4LjAxM2g0LjAwM3Y0LjAwM0g4LjAxem0xMi4wMDggMGgtNC4wMDJ2NC4wMDNoNC4wMDJ6bTQuMDAzIDBoNC4wMDJ2NC4wMDNoLTQuMDAyem0xMi4wMDggMGgtNC4wMDN2NC4wMDNoNC4wMDN6bTQuMDAyIDBoNC4wMDN2NC4wMDNINDAuMDN6bS0yNC4wMTUgOC4wMDVIOC4wMXY0LjAwM2g4LjAwNnptNC4wMDIgMGg0LjAwM3Y0LjAwM2gtNC4wMDN6bTEyLjAwOCAwaC00LjAwM3Y0LjAwM2g0LjAwM3ptMTIuMDA4IDB2NC4wMDNoLTguMDA1di00LjAwM3ptLTMyLjAyMSA4LjAwNUg4LjAxdjQuMDAzaDQuMDAzem00LjAwMyAwaDIwLjAxM3Y0LjAwM0gxNi4wMTZ6bTI4LjAxOCAwSDQwLjAzdjQuMDAzaDQuMDAzeiIgY2xpcC1ydWxlPSJldmVub2RkIi8+PC9nPjxkZWZzPjxjbGlwUGF0aCBpZD0iYSI+PHBhdGggZmlsbD0iI2ZmZiIgZD0iTTAgMGg1M3YzNkgweiIvPjwvY2xpcFBhdGg+PC9kZWZzPjwvc3ZnPg==) 50% no-repeat;border:4px solid #252526}.monaco-editor .tokens-inspect-widget{background-color:var(--vscode-editorHoverWidget-background);border:1px solid var(--vscode-editorHoverWidget-border);color:var(--vscode-editorHoverWidget-foreground);padding:10px;user-select:text;-webkit-user-select:text;z-index:50}.monaco-editor.hc-black .tokens-inspect-widget,.monaco-editor.hc-light .tokens-inspect-widget{border-width:2px}.monaco-editor .tokens-inspect-widget .tokens-inspect-separator{background-color:var(--vscode-editorHoverWidget-border);border:0;height:1px}.monaco-editor .tokens-inspect-widget .tm-token{font-family:var(--monaco-monospace-font)}.monaco-editor .tokens-inspect-widget .tm-token-length{float:right;font-size:60%;font-weight:400}.monaco-editor .tokens-inspect-widget .tm-metadata-table{width:100%}.monaco-editor .tokens-inspect-widget .tm-metadata-value{font-family:var(--monaco-monospace-font);text-align:right}.monaco-editor .tokens-inspect-widget .tm-token-type{font-family:var(--monaco-monospace-font)}.quick-input-widget{font-size:13px}.quick-input-widget .monaco-highlighted-label .highlight{color:#0066bf}.vs .quick-input-widget .monaco-list-row.focused .monaco-highlighted-label .highlight{color:#9dddff}.vs-dark .quick-input-widget .monaco-highlighted-label .highlight{color:#0097fb}.hc-black .quick-input-widget .monaco-highlighted-label .highlight{color:#f38518}.hc-light .quick-input-widget .monaco-highlighted-label .highlight{color:#0f4a85}.monaco-keybinding>.monaco-keybinding-key{background-color:#dedede66;border:1px solid hsla(0,0%,80%,.4);border-bottom-color:#bababa66;box-shadow:inset 0 -1px #bababa66;color:#555}.hc-black .monaco-keybinding>.monaco-keybinding-key{background-color:transparent;border:1px solid #6fc3df;box-shadow:none;color:#fff}.hc-light .monaco-keybinding>.monaco-keybinding-key{background-color:transparent;border:1px solid #0f4a85;box-shadow:none;color:#292929}.vs-dark .monaco-keybinding>.monaco-keybinding-key{background-color:#8080802b;border:1px solid rgba(51,51,51,.6);border-bottom-color:#4449;box-shadow:inset 0 -1px #4449;color:#ccc}.monaco-editor{font-family:-apple-system,BlinkMacSystemFont,Segoe WPC,Segoe UI,HelveticaNeue-Light,system-ui,Ubuntu,Droid Sans,sans-serif;--monaco-monospace-font:"SF Mono",Monaco,Menlo,Consolas,"Ubuntu Mono","Liberation Mono","DejaVu Sans Mono","Courier New",monospace}.monaco-editor.hc-black .monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .action-label,.monaco-editor.hc-light .monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .action-label,.monaco-editor.vs-dark .monaco-menu .monaco-action-bar.vertical .action-menu-item:focus .action-label,.monaco-menu .monaco-action-bar.vertical .action-item .action-menu-item:focus .action-label{stroke-width:1.2px}.monaco-hover p{margin:0}.monaco-aria-container{height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute!important;top:0;width:1px;clip:rect(1px,1px,1px,1px);clip-path:inset(50%)}.monaco-diff-editor .synthetic-focus,.monaco-diff-editor [tabindex="-1"]:focus,.monaco-diff-editor [tabindex="0"]:focus,.monaco-diff-editor button:focus,.monaco-diff-editor input[type=button]:focus,.monaco-diff-editor input[type=checkbox]:focus,.monaco-diff-editor input[type=search]:focus,.monaco-diff-editor input[type=text]:focus,.monaco-diff-editor select:focus,.monaco-diff-editor textarea:focus,.monaco-editor{opacity:1;outline-color:var(--vscode-focusBorder);outline-offset:-1px;outline-style:solid;outline-width:1px}.action-widget{background-color:var(--vscode-editorActionList-background);border:1px solid var(--vscode-editorWidget-border)!important;border-radius:5px;box-shadow:0 2px 8px var(--vscode-widget-shadow);color:var(--vscode-editorActionList-foreground);display:block;font-size:13px;max-width:80vw;min-width:160px;padding:4px;width:100%;z-index:40}.context-view-block{z-index:-1}.context-view-block,.context-view-pointerBlock{cursor:auto;height:100%;left:0;position:fixed;top:0;width:100%}.context-view-pointerBlock{z-index:2}.action-widget .monaco-list{border:0!important;user-select:none;-webkit-user-select:none}.action-widget .monaco-list:focus:before{outline:0!important}.action-widget .monaco-list .monaco-scrollable-element{overflow:visible}.action-widget .monaco-list .monaco-list-row{border-radius:4px;cursor:pointer;padding:0 10px;touch-action:none;white-space:nowrap;width:100%}.action-widget .monaco-list .monaco-list-row.action.focused:not(.option-disabled){background-color:var(--vscode-editorActionList-focusBackground)!important;color:var(--vscode-editorActionList-focusForeground);outline:1px solid var(--vscode-menu-selectionBorder,transparent);outline-offset:-1px}.action-widget .monaco-list-row.group-header{color:var(--vscode-descriptionForeground)!important;font-size:12px;font-weight:600}.action-widget .monaco-list-row.group-header:not(:first-of-type){margin-top:2px}.action-widget .monaco-list .group-header,.action-widget .monaco-list .option-disabled,.action-widget .monaco-list .option-disabled .focused,.action-widget .monaco-list .option-disabled .focused:before,.action-widget .monaco-list .option-disabled:before{cursor:default!important;-webkit-touch-callout:none;background-color:transparent!important;outline:0 solid!important;-webkit-user-select:none;user-select:none}.action-widget .monaco-list-row.action{align-items:center;display:flex;gap:8px}.action-widget .monaco-list-row.action.option-disabled,.action-widget .monaco-list-row.action.option-disabled .codicon,.action-widget .monaco-list:focus .monaco-list-row.focused.action.option-disabled,.action-widget .monaco-list:not(.drop-target):not(.dragging) .monaco-list-row:hover:not(.selected):not(.focused).option-disabled{color:var(--vscode-disabledForeground)}.action-widget .monaco-list-row.action:not(.option-disabled) .codicon{color:inherit}.action-widget .monaco-list-row.action .title{flex:1;overflow:hidden;text-overflow:ellipsis}.action-widget .monaco-list-row.action .monaco-keybinding>.monaco-keybinding-key{background-color:var(--vscode-keybindingLabel-background);border-color:var(--vscode-keybindingLabel-border);border-bottom-color:var(--vscode-keybindingLabel-bottomBorder);border-radius:3px;border-style:solid;border-width:1px;box-shadow:inset 0 -1px 0 var(--vscode-widget-shadow);color:var(--vscode-keybindingLabel-foreground)}.action-widget .action-widget-action-bar{background-color:var(--vscode-editorActionList-background);border-top:1px solid var(--vscode-editorHoverWidget-border);margin-top:2px}.action-widget .action-widget-action-bar:before{content:"";display:block;width:100%}.action-widget .action-widget-action-bar .actions-container{padding:3px 8px 0}.action-widget-action-bar .action-label{color:var(--vscode-textLink-activeForeground);font-size:12px;line-height:22px;padding:0;pointer-events:all}.action-widget-action-bar .action-item{margin-right:16px;pointer-events:none}.action-widget-action-bar .action-label:hover{background-color:transparent!important}.monaco-action-bar .actions-container.highlight-toggled .action-label.checked{background:var(--vscode-actionBar-toggledBackground)!important}.monaco-action-bar .action-item.menu-entry .action-label.icon{background-position:50%;background-repeat:no-repeat;background-size:16px;height:16px;width:16px}.monaco-action-bar .action-item.menu-entry.text-only .action-label{border-radius:2px;color:var(--vscode-descriptionForeground);overflow:hidden}.monaco-action-bar .action-item.menu-entry.text-only.use-comma:not(:last-of-type) .action-label:after{content:", "}.monaco-action-bar .action-item.menu-entry.text-only+.action-item:not(.text-only)>.monaco-dropdown .action-label{color:var(--vscode-descriptionForeground)}.monaco-dropdown-with-default{border-radius:5px;display:flex!important;flex-direction:row}.monaco-dropdown-with-default>.action-container>.action-label{margin-right:0}.monaco-dropdown-with-default>.action-container.menu-entry>.action-label.icon{background-position:50%;background-repeat:no-repeat;background-size:16px;height:16px;width:16px}.monaco-dropdown-with-default:hover{background-color:var(--vscode-toolbar-hoverBackground)}.monaco-dropdown-with-default>.dropdown-action-container>.monaco-dropdown>.dropdown-label .codicon[class*=codicon-]{font-size:12px;line-height:16px;margin-left:-3px;padding-left:0;padding-right:0}.monaco-dropdown-with-default>.dropdown-action-container>.monaco-dropdown>.dropdown-label>.action-label{background-position:50%;background-repeat:no-repeat;background-size:16px;display:block}.monaco-link{color:var(--vscode-textLink-foreground)}.monaco-link:hover{color:var(--vscode-textLink-activeForeground)}.quick-input-widget{left:50%;margin-left:-300px;position:absolute;width:600px;z-index:2550;-webkit-app-region:no-drag;border-radius:6px}.quick-input-titlebar{align-items:center;border-top-left-radius:5px;border-top-right-radius:5px;display:flex}.quick-input-left-action-bar{display:flex;flex:1;margin-left:4px}.quick-input-inline-action-bar{margin:2px 0 0 5px}.quick-input-title{overflow:hidden;padding:3px 0;text-align:center;text-overflow:ellipsis}.quick-input-right-action-bar{display:flex;flex:1;margin-right:4px}.quick-input-right-action-bar>.actions-container{justify-content:flex-end}.quick-input-titlebar .monaco-action-bar .action-label.codicon{background-position:50%;background-repeat:no-repeat;padding:2px}.quick-input-description{margin:6px 6px 6px 11px}.quick-input-header .quick-input-description{flex:1;margin:4px 2px}.quick-input-header{display:flex;padding:8px 6px 2px}.quick-input-widget.hidden-input .quick-input-header{margin-bottom:0;padding:0}.quick-input-and-message{display:flex;flex-direction:column;flex-grow:1;min-width:0;position:relative}.quick-input-check-all{align-self:center;margin:0}.quick-input-filter{display:flex;flex-grow:1;position:relative}.quick-input-box{flex-grow:1}.quick-input-widget.show-checkboxes .quick-input-box,.quick-input-widget.show-checkboxes .quick-input-message{margin-left:5px}.quick-input-visible-count{left:-10000px;position:absolute}.quick-input-count{align-items:center;align-self:center;display:flex;position:absolute;right:4px}.quick-input-count .monaco-count-badge{border-radius:2px;line-height:normal;min-height:auto;padding:2px 4px;vertical-align:middle}.quick-input-action{margin-left:6px}.quick-input-action .monaco-text-button{align-items:center;display:flex;font-size:11px;height:25px;padding:0 6px}.quick-input-message{margin-top:-1px;overflow-wrap:break-word;padding:5px}.quick-input-message>.codicon{margin:0 .2em;vertical-align:text-bottom}.quick-input-message a{color:inherit}.quick-input-progress.monaco-progress-container{position:relative}.quick-input-list{line-height:22px}.quick-input-widget.hidden-input .quick-input-list{margin-top:4px;padding-bottom:4px}.quick-input-list .monaco-list{max-height:440px;overflow:hidden;padding-bottom:5px}.quick-input-list .monaco-scrollable-element{padding:0 5px}.quick-input-list .quick-input-list-entry{box-sizing:border-box;display:flex;overflow:hidden;padding:0 6px}.quick-input-list .quick-input-list-entry.quick-input-list-separator-border{border-top-style:solid;border-top-width:1px}.quick-input-list .monaco-list-row{border-radius:3px}.quick-input-list .monaco-list-row[data-index="0"] .quick-input-list-entry.quick-input-list-separator-border{border-top-style:none}.quick-input-list .quick-input-list-label{display:flex;flex:1;height:100%;overflow:hidden}.quick-input-list .quick-input-list-checkbox{align-self:center;margin:0}.quick-input-list .quick-input-list-icon{align-items:center;background-position:0;background-repeat:no-repeat;background-size:16px;display:flex;height:22px;justify-content:center;padding-right:6px;width:16px}.quick-input-list .quick-input-list-rows{display:flex;flex:1;flex-direction:column;height:100%;margin-left:5px;overflow:hidden;text-overflow:ellipsis}.quick-input-widget.show-checkboxes .quick-input-list .quick-input-list-rows{margin-left:10px}.quick-input-widget .quick-input-list .quick-input-list-checkbox{display:none}.quick-input-widget.show-checkboxes .quick-input-list .quick-input-list-checkbox{display:inline}.quick-input-list .quick-input-list-rows>.quick-input-list-row{align-items:center;display:flex}.quick-input-list .quick-input-list-rows>.quick-input-list-row .monaco-icon-label,.quick-input-list .quick-input-list-rows>.quick-input-list-row .monaco-icon-label .monaco-icon-label-container>.monaco-icon-name-container{flex:1}.quick-input-list .quick-input-list-rows>.quick-input-list-row .codicon[class*=codicon-]{vertical-align:text-bottom}.quick-input-list .quick-input-list-rows .monaco-highlighted-label>span{opacity:1}.quick-input-list .quick-input-list-entry .quick-input-list-entry-keybinding{margin-right:8px}.quick-input-list .quick-input-list-label-meta{line-height:normal;opacity:.7;overflow:hidden;text-overflow:ellipsis}.quick-input-list .monaco-list .monaco-list-row .monaco-highlighted-label .highlight{background-color:unset;color:var(--vscode-list-highlightForeground)!important;font-weight:700}.quick-input-list .monaco-list .monaco-list-row.focused .monaco-highlighted-label .highlight{color:var(--vscode-list-focusHighlightForeground)!important}.quick-input-list .quick-input-list-entry .quick-input-list-separator{margin-right:4px}.quick-input-list .quick-input-list-entry-action-bar{display:flex;flex:0;overflow:visible}.quick-input-list .quick-input-list-entry-action-bar .action-label{display:none}.quick-input-list .quick-input-list-entry-action-bar .action-label.codicon{margin-right:4px;padding:2px}.quick-input-list .quick-input-list-entry-action-bar{margin-right:4px;margin-top:1px}.quick-input-list .monaco-list-row.focused .quick-input-list-entry-action-bar .action-label,.quick-input-list .monaco-list-row.passive-focused .quick-input-list-entry-action-bar .action-label,.quick-input-list .quick-input-list-entry .quick-input-list-entry-action-bar .action-label.always-visible,.quick-input-list .quick-input-list-entry.focus-inside .quick-input-list-entry-action-bar .action-label,.quick-input-list .quick-input-list-entry:hover .quick-input-list-entry-action-bar .action-label{display:flex}.quick-input-list .monaco-list-row.focused .monaco-keybinding-key,.quick-input-list .monaco-list-row.focused .quick-input-list-entry .quick-input-list-separator{color:inherit}.quick-input-list .monaco-list-row.focused .monaco-keybinding-key{background:none}.quick-input-list .quick-input-list-separator-as-item{font-size:12px;padding:4px 6px}.quick-input-list .quick-input-list-separator-as-item .label-name{font-weight:600}.quick-input-list .quick-input-list-separator-as-item .label-description{opacity:1!important}.quick-input-list .monaco-tree-sticky-row .quick-input-list-entry.quick-input-list-separator-as-item.quick-input-list-separator-border{border-top-style:none}.quick-input-list .monaco-tree-sticky-row{padding:0 5px}.quick-input-list .monaco-tl-twistie{display:none!important}.extension-editor .codicon.codicon-error,.extensions-viewlet>.extensions .codicon.codicon-error,.markers-panel .marker-icon .codicon.codicon-error,.markers-panel .marker-icon.error,.monaco-editor .zone-widget .codicon.codicon-error,.preferences-editor .codicon.codicon-error,.text-search-provider-messages .providerMessage .codicon.codicon-error{color:var(--vscode-problemsErrorIcon-foreground)}.extension-editor .codicon.codicon-warning,.extensions-viewlet>.extensions .codicon.codicon-warning,.markers-panel .marker-icon .codicon.codicon-warning,.markers-panel .marker-icon.warning,.monaco-editor .zone-widget .codicon.codicon-warning,.preferences-editor .codicon.codicon-warning,.text-search-provider-messages .providerMessage .codicon.codicon-warning{color:var(--vscode-problemsWarningIcon-foreground)}.extension-editor .codicon.codicon-info,.extensions-viewlet>.extensions .codicon.codicon-info,.markers-panel .marker-icon .codicon.codicon-info,.markers-panel .marker-icon.info,.monaco-editor .zone-widget .codicon.codicon-info,.preferences-editor .codicon.codicon-info,.text-search-provider-messages .providerMessage .codicon.codicon-info{color:var(--vscode-problemsInfoIcon-foreground)}`;
let F4 = !1;
function B_e() {
  if (F4 || typeof document > "u")
    return;
  const s = document.createElement("style");
  s.setAttribute("data-trust-monaco", "true"), s.textContent = Jme, document.head.appendChild(s), F4 = !0;
}
export {
  B_e as ensureStyleInjected,
  UAe as monaco
};
